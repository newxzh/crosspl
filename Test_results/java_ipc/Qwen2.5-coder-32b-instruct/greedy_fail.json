[
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.Properties;\nimport java.util.UUID;\n\nclass HttpClientException extends Exception {\n    public HttpClientException(String message) {\n        super(message);\n    }\n}\n\ninterface HttpConnectionRetryHandler {\n    boolean shouldRetry(IOException exception, int executionCount);\n}\n\nclass HttpClient {\n    private static final HttpClient me = new HttpClient();\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private final String delimiter = \"--\";\n    private final String boundary = UUID.randomUUID().toString();\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n\n    private HttpClient() {}\n\n    public static HttpClient getInstance() {\n        return me;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        try {\n            doConnection(method, props);\n        } catch (IOException e) {\n            if (handler != null && handler.shouldRetry(e, 1)) {\n                try {\n                    doConnection(method, props);\n                } catch (IOException ex) {\n                    throw new HttpClientException(\"Failed to connect after retry\", ex);\n                }\n            } else {\n                throw new HttpClientException(\"Failed to connect\", e);\n            }\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL u = new URL(url);\n        if (proxyHost != null && proxyPort != null) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) u.openConnection(proxy);\n        } else {\n            con = (HttpURLConnection) u.openConnection();\n        }\n        con.setRequestMethod(method);\n        con.setDoOutput(true);\n        for (String key : props.stringPropertyNames()) {\n            con.setRequestProperty(key, props.getProperty(key));\n        }\n    }\n\n    public byte[] downloadImage(String imgName) throws Exception {\n        connect(\"GET\", new Properties());\n        InputStream is = con.getInputStream();\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[16384];\n        while ((nRead = is.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        connect(\"POST\", new Properties() {{\n            setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        }});\n        os = con.getOutputStream();\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\\r\\n\").getBytes());\n        os.write(data);\n        os.write((\"\\r\\n\" + delimiter + boundary + \"\\r\\n\").getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"--\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = br.readLine()) != null) {\n            response.append(line).append('\\r');\n        }\n        br.close();\n        return response.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Java class that asynchronously fetches weather data from a remote API using HTTP URL connection and processes the JSON response to extract sunrise and sunset times.\n\nClass Description: HttpWeatherClient is an Android utility class that performs asynchronous HTTP requests to fetch weather data and parse the JSON response. It uses AsyncTask to handle network operations off the main thread.\n\nAttributes: None (All variables are local to methods)\n\nMethods:\n1: WeatherAsyncTask(String... params) -> String - AsyncTask subclass that handles the background HTTP request. Takes URL string as input and returns null (results are processed via progress updates).\n2: onProgressUpdate(String... progress) -> void - Processes the JSON response to extract sunrise and sunset times from the astronomy data.\n3: convertStreamToString(InputStream inputStream) -> String - Helper method that converts an InputStream to a String for JSON parsing. Takes InputStream as input and returns the converted String.\n\nNote: All methods include basic exception handling with empty catch blocks as shown in the reference code. The class is designed for Android platform (uses android.os.AsyncTask).",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String weatherData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    weatherData = convertStreamToString(in);\n                    publishProgress(weatherData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                JSONObject query = json.getJSONObject(\"query\");\n                JSONObject results = query.getJSONObject(\"results\");\n                JSONObject channel = results.getJSONObject(\"channel\");\n                JSONObject astronomy = channel.getJSONObject(\"astronomy\");\n                String sunset = astronomy.getString(\"sunset\");\n                String sunrise = astronomy.getString(\"sunrise\");\n            } catch (Exception ex) {}\n        }\n    }\n\n    private static String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String result = \"\";\n\n        try {\n            while ((line = reader.readLine()) != null) {\n                result += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    private class WeatherAsyncTask extends AsyncTask<String, String, Void> {\n        @Override\n        protected Void doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                InputStream in = urlConnection.getInputStream();\n                String result = convertStreamToString(in);\n                publishProgress(result);\n            } catch (Exception e) {\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            try {\n                JSONObject jsonObject = new JSONObject(progress[0]);\n                JSONObject astronomy = jsonObject.getJSONObject(\"data\").getJSONArray(\"astronomy\").getJSONObject(0);\n                String sunrise = astronomy.getString(\"sunrise\");\n                String sunset = astronomy.getString(\"sunset\");\n                // Process sunrise and sunset times\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    private String convertStreamToString(InputStream inputStream) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    private static class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            String urlString = params[0];\n            try {\n                URL url = new URL(urlString);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = connection.getInputStream();\n                    return ConvertInputToStringNoChange(inputStream);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            String jsonData = progress[0];\n            try {\n                JSONArray jsonArray = new JSONArray(jsonData);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    JSONObject jsonObject = jsonArray.getJSONObject(i);\n                    // Process each JSON object here\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n            if (result != null) {\n                publishProgress(result);\n            }\n        }\n    }\n\n    private static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        int redirectCount = 0;\n        String currentUrlString = targetUrlString;\n        while (redirectCount <= MAXIMUM_REDIRECTS) {\n            Optional<String> nextUrl = getDownloadedOrNextUrl(currentUrlString, path, userAgent);\n            if (!nextUrl.isPresent()) {\n                logger.info(\"Download completed successfully.\");\n                return;\n            }\n            currentUrlString = nextUrl.get();\n            redirectCount++;\n            logger.info(\"Redirecting to: {}\", currentUrlString);\n        }\n        throw new IOException(\"Exceeded maximum number of redirects (\" + MAXIMUM_REDIRECTS + \")\");\n    }\n\n    private Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        URL url = new URL(urlString);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestProperty(\"User-Agent\", userAgent);\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            Files.copy(connection.getInputStream(), path);\n            return Optional.empty();\n        } else if (responseCode >= HttpURLConnection.HTTP_MOVED_PERM && responseCode <= HttpURLConnection.HTTP_SEE_OTHER) {\n            String newLocation = connection.getHeaderField(\"Location\");\n            return Optional.of(newLocation);\n        } else {\n            logger.error(\"Failed to download file. Server responded with code: {}\", responseCode);\n            throw new IOException(\"Server returned non-successful response code: \" + responseCode);\n        }\n    }\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Map;\nimport java.util.stream.Stream;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        return connectionToString(con);\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        String responseBody = getBody(reqURL);\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readTree(responseBody);\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        try (InputStream in = con.getInputStream();\n             FileOutputStream out = new FileOutputStream(fileLocation)) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = postContent.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);           \n        }\n        return connectionToString(con);\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry<String, String> param : fields.entrySet()) {\n            if (postData.length() != 0) postData.append('&');\n            postData.append(param.getKey());\n            postData.append('=');\n            postData.append(param.getValue());\n        }\n        byte[] postDataBytes = postData.toString().getBytes(\"UTF-8\");\n\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-Length\", String.valueOf(postDataBytes.length));\n        con.setDoOutput(true);\n        try (DataOutputStream wr = new DataOutputStream(con.getOutputStream())) {\n            wr.write(postDataBytes);\n        }\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        return new BufferedReader(new InputStreamReader(con.getInputStream())).lines();\n    }\n\n    public static String getUserAgent() {\n        return \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\";\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                content.append(line);\n                content.append(System.lineSeparator());\n            }\n        }\n        return content.toString();\n    }\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\nclass RealRequest {\n    static String sRequestURL;\n    private HttpConfig httpConfig;\n    private final String TAG = \"SA.HttpRequest\";\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n        setHeader(conn, headerMap);\n        return getRealResponse(conn);\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n        setHeader(conn, headerMap);\n        try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n            wr.writeBytes(body);\n            wr.flush();\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        }\n        return getRealResponse(conn);\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) {\n        try {\n            URL url = new URL(requestURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(requestMethod);\n            if (httpConfig != null) {\n                conn.setConnectTimeout(httpConfig.getConnectTimeout());\n                conn.setReadTimeout(httpConfig.getReadTimeout());\n            }\n            return conn;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        try {\n            int responseCode = conn.getResponseCode();\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return new RealResponse(responseCode, response.toString());\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(500, e.getMessage());\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}\n\nclass RealResponse {\n    private final int statusCode;\n    private final String responseBody;\n\n    public RealResponse(int statusCode, String responseBody) {\n        this.statusCode = statusCode;\n        this.responseBody = responseBody;\n    }\n\n    public int getStatusCode() {\n        return statusCode;\n    }\n\n    public String getResponseBody() {\n        return responseBody;\n    }\n}\n\nclass HttpConfig {\n    private int connectTimeout;\n    private int readTimeout;\n\n    public HttpConfig setConnectTimeout(int connectTimeout) {\n        this.connectTimeout = connectTimeout;\n        return this;\n    }\n\n    public HttpConfig setReadTimeout(int readTimeout) {\n        this.readTimeout = readTimeout;\n        return this;\n    }\n\n    public int getConnectTimeout() {\n        return connectTimeout;\n    }\n\n    public int getReadTimeout() {\n        return readTimeout;\n    }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n    private DataSpec dataSpec;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n    private boolean opened;\n\n    public YoutubeHttpDataSource(boolean allowCrossProtocolRedirects, int connectTimeoutMillis, int readTimeoutMillis, RequestProperties requestProperties) {\n        super(/* isNetwork */ true);\n        this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;\n        this.connectTimeoutMillis = connectTimeoutMillis;\n        this.readTimeoutMillis = readTimeoutMillis;\n        this.requestProperties = requestProperties;\n        this.dataSpec = null;\n        this.connection = null;\n        this.inputStream = null;\n        this.opened = false;\n    }\n\n    @Override\n    public long open(DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        this.connection = makeConnection(dataSpecParameter);\n        try {\n            this.inputStream = this.connection.getInputStream();\n        } catch (IOException e) {\n            closeConnectionQuietly();\n            throw new HttpDataSourceException(\"Unable to open input stream.\", e, dataSpec, HttpDataSourceException.TYPE_OPEN);\n        }\n        opened = true;\n        return checkContentLength(this.connection.getContentLengthLong());\n    }\n\n    private HttpURLConnection makeConnection(DataSpec dataSpecToUse) throws HttpDataSourceException {\n        URL url = dataSpecToUse.uri.toUrl();\n        HttpURLConnection connection = openConnection(url);\n        configureConnection(connection, dataSpecToUse);\n        try {\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\n                String location = connection.getHeaderField(\"Location\");\n                url = handleRedirect(url, location, dataSpecToUse);\n                connection.disconnect();\n                return makeConnection(dataSpecToUse.withUri(url));\n            }\n            if (responseCode != HttpURLConnection.HTTP_OK) {\n                connection.disconnect();\n                throw new InvalidResponseCodeException(responseCode, connection.getResponseMessage(), dataSpecToUse);\n            }\n        } catch (IOException e) {\n            connection.disconnect();\n            throw new HttpDataSourceException(\"Unable to connect to \" + url, e, dataSpecToUse, HttpDataSourceException.TYPE_OPEN);\n        }\n        return connection;\n    }\n\n    private HttpURLConnection openConnection(URL url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setConnectTimeout(connectTimeoutMillis);\n        connection.setReadTimeout(readTimeoutMillis);\n        return connection;\n    }\n\n    private URL handleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) throws HttpDataSourceException {\n        if (!allowCrossProtocolRedirects && !originalUrl.getProtocol().equals(location)) {\n            throw new HttpDataSourceException(\"Disallowed cross-protocol redirect (from \" + originalUrl.getProtocol() + \" to \" + location + \").\", dataSpecToHandleRedirect, HttpDataSourceException.TYPE_OPEN);\n        }\n        try {\n            return new URL(originalUrl, location);\n        } catch (MalformedURLException e) {\n            throw new HttpDataSourceException(\"Unable to follow redirect to \" + location, e, dataSpecToHandleRedirect, HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, 0);\n                inputStream.close();\n            }\n        } catch (IOException e) {\n            throw new HttpDataSourceException(\"Error closing input stream.\", e, dataSpec, HttpDataSourceException.TYPE_CLOSE);\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {\n        // Implementation specific to Android versions can go here\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (Exception ignored) {\n                // Ignored\n            }\n            connection = null;\n        }\n    }\n}"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a WebSocket client using Java Netty framework that can establish a connection to a WebSocket server, send and receive frames, and handle connection lifecycle events.\n\nClass Description: WebSocketTestClient is a Netty-based WebSocket client implementation that handles WebSocket connections, frame transmission, and connection management. It supports different WebSocket versions and provides callback mechanisms for frame handling.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- ch: [Channel] - Active channel representing the WebSocket connection\n- uri: [URI] - Target WebSocket server URI\n- version: [WebSocketVersion] - WebSocket protocol version to use\n- closed: [boolean] - Connection status flag\n- count: [AtomicInteger] - Counter for handler naming\n\nMethods:\n- connect(): [WebSocketTestClient] - Establishes connection to WebSocket server, performs handshake, and returns self for chaining\n- send(WebSocketFrame frame, FrameListener listener): [WebSocketTestClient] - Sends WebSocket frame and registers listener for response, returns self for chaining\n- destroy(): [void] - Gracefully closes connection and releases resources\n- destroy(boolean dirty): [void] - Closes connection with option for immediate termination\n- isActive(): [boolean] - Returns connection active status\n- isOpen(): [boolean] - Returns connection open status\n- isWritable(): [boolean] - Returns channel writable status\n\nNested Interfaces:\n- FrameListener: Callback interface for frame reception and error handling\n  - onFrame(WebSocketFrame frame): [void] - Called when frame is received\n  - onError(Throwable t): [void] - Called when error occurs\n\nNested Classes:\n- WSClientHandler: [SimpleChannelInboundHandler<Object>] - Internal handler for WebSocket handshake and frame processing\n  - handshakeFuture(): [ChannelFuture] - Returns handshake completion future\n  - handlerAdded(ChannelHandlerContext ctx): [void] - Initializes handshake promise\n  - channelActive(ChannelHandlerContext ctx): [void] - Initiates handshake\n  - channelRead0(ChannelHandlerContext ctx, Object o): [void] - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext ctx, Throwable cause): [void] - Handles channel errors",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic final class WebSocketTestClient {\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed;\n    private static final AtomicInteger count = new AtomicInteger();\n\n    public WebSocketTestClient(WebSocketVersion version, URI uri) {\n        this.uri = uri;\n        this.version = version;\n    }\n\n    public WebSocketTestClient connect() throws Exception {\n        String protocol = uri.getScheme();\n        if (!\"ws\".equals(protocol)) {\n            throw new IllegalArgumentException(\"Unsupported protocol: \" + protocol);\n        }\n        final WebSocketClientHandshaker handshaker =\n                WebSocketClientHandshakerFactory.newHandshaker(\n                        uri, version, null, false, new DefaultHttpHeaders());\n        WSClientHandler handler = new WSClientHandler(handshaker);\n        EventLoopGroup group = new NioEventLoopGroup();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception {\n                        ChannelPipeline p = channel.pipeline();\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192), handler);\n                    }\n                });\n\n        ChannelFuture future =\n                bootstrap.connect(\n                        new InetSocketAddress(uri.getHost(), uri.getPort()));\n        future.syncUninterruptibly();\n        handler.handshakeFuture.syncUninterruptibly();\n        ch = future.channel();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, final FrameListener listener) {\n        ch.pipeline().addLast(\"responseHandler\" + count.incrementAndGet(), new SimpleChannelInboundHandler<Object>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof CloseWebSocketFrame) {\n                    closed = true;\n                }\n                listener.onFrame((WebSocketFrame) msg);\n                ctx.pipeline().remove(this);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                cause.printStackTrace();\n                listener.onError(cause);\n                ctx.pipeline().remove(this);\n            }\n        });\n        ChannelFuture cf = ch.writeAndFlush(frame).syncUninterruptibly();\n        if (!cf.isSuccess()) {\n            listener.onError(cf.cause());\n        }\n        return this;\n    }\n\n    public void destroy() {\n        this.destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed && !dirty) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            send(new CloseWebSocketFrame(), new FrameListener() {\n                @Override\n                public void onFrame(WebSocketFrame frame) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    latch.countDown();\n                }\n            });\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (ch != null) {\n            ch.close().syncUninterruptibly();\n        }\n        try {\n            bootstrap.group().shutdownGracefully(0, 1, TimeUnit.SECONDS).get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean isActive() {\n        return this.ch != null && this.ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return this.ch != null && this.ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return this.ch != null && this.ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private static final class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        WSClientHandler(WebSocketClientHandshaker handshaker) {\n            super(false);\n            this.handshaker = handshaker;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object o) throws Exception {\n            Channel ch = ctx.channel();\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.finishHandshake(ch, (FullHttpResponse) o);\n                handshakeFuture.setSuccess();\n                ReferenceCountUtil.release(o);\n                return;\n            }\n\n            if (o instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) o;\n                ReferenceCountUtil.release(o);\n                throw new Exception(\"Unexpected HttpResponse (status=\" + response.getStatus() + \", content=\"\n                        + response.content().toString(CharsetUtil.UTF_8) + ')');\n            }\n            ctx.fireChannelRead(o);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.net.URI;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class WebSocketTestClient {\n    private Bootstrap bootstrap;\n    private Channel ch;\n    private URI uri;\n    private WebSocketVersion version;\n    private boolean closed;\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public WebSocketTestClient(URI uri, WebSocketVersion version) {\n        this.uri = uri;\n        this.version = version;\n        this.closed = false;\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            if (\"wss\".equals(uri.getScheme())) {\n                final SslContext sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                bootstrap = new Bootstrap().group(group)\n                        .channel(NioSocketChannel.class)\n                        .handler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            protected void initChannel(SocketChannel ch) throws Exception {\n                                ChannelPipeline pipeline = ch.pipeline();\n                                pipeline.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), uri.getPort()));\n                                pipeline.addLast(new HttpClientCodec());\n                                pipeline.addLast(new HttpObjectAggregator(8192));\n                                pipeline.addLast(new WSClientHandler(uri, version));\n                            }\n                        });\n            } else {\n                bootstrap = new Bootstrap().group(group)\n                        .channel(NioSocketChannel.class)\n                        .handler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            protected void initChannel(SocketChannel ch) throws Exception {\n                                ChannelPipeline pipeline = ch.pipeline();\n                                pipeline.addLast(new HttpClientCodec());\n                                pipeline.addLast(new HttpObjectAggregator(8192));\n                                pipeline.addLast(new WSClientHandler(uri, version));\n                            }\n                        });\n            }\n        } catch (Exception e) {\n            group.shutdownGracefully();\n            throw new RuntimeException(\"Failed to initialize WebSocket client\", e);\n        }\n    }\n\n    public WebSocketTestClient connect() {\n        try {\n            ch = bootstrap.connect(uri.getHost(), uri.getPort()).sync().channel();\n            ((WSClientHandler) ch.pipeline().get(WSClientHandler.class)).handshakeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Connection interrupted\", e);\n        }\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, FrameListener listener) {\n        if (!isActive()) {\n            throw new IllegalStateException(\"WebSocket connection is not active\");\n        }\n        ch.writeAndFlush(frame).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                listener.onFrame(frame);\n            } else {\n                listener.onError(future.cause());\n            }\n        });\n        return this;\n    }\n\n    public void destroy() {\n        destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed) {\n            closed = true;\n            if (dirty) {\n                ch.close();\n            } else {\n                ch.writeAndFlush(new CloseWebSocketFrame()).addListener(ChannelFutureListener.CLOSE);\n            }\n        }\n    }\n\n    public boolean isActive() {\n        return ch != null && ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return ch != null && ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return ch != null && ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private static class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final URI uri;\n        private final WebSocketVersion version;\n        private ChannelPromise handshakeFuture;\n\n        public WSClientHandler(URI uri, WebSocketVersion version) {\n            this.uri = uri;\n            this.version = version;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            WebSocketClientHandshakerFactory wsFactory = new WebSocketClientHandshakerFactory();\n            WebSocketClientHandshaker handshaker = wsFactory.newHandshaker(\n                    uri, version, null, false, new DefaultHttpHeaders());\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            Channel ch = ctx.channel();\n            if (!handshakeFuture.isDone()) {\n                WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                        uri, version, null, false, new DefaultHttpHeaders());\n                try {\n                    handshaker.finishHandshake(ch, (FullHttpResponse) msg);\n                    handshakeFuture.setSuccess();\n                } catch (WebSocketHandshakeException e) {\n                    handshakeFuture.setFailure(e);\n                }\n                return;\n            }\n\n            if (msg instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) msg;\n                throw new IllegalStateException(\n                        \"Unexpected FullHttpResponse (getStatus=\" + response.status() +\n                                \", content=\" + response.content().toString(CharsetUtil.UTF_8) + ')');\n            }\n\n            WebSocketFrame frame = (WebSocketFrame) msg;\n            if (frame instanceof TextWebSocketFrame) {\n                TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;\n                System.out.println(\"WebSocket Client received message: \" + textFrame.text());\n            } else if (frame instanceof PongWebSocketFrame) {\n                System.out.println(\"WebSocket Client received pong\");\n            } else if (frame instanceof CloseWebSocketFrame) {\n                System.out.println(\"WebSocket Client received closing\");\n                ch.close();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using Netty framework for making GET and POST requests to a remote server, with support for timeout handling and asynchronous response processing.\n\nClass Description: TestHttpClient is a Netty-based HTTP client that handles both GET and POST requests asynchronously. It manages connection pooling, request/response processing, and timeout handling. The class uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- host: String - The target server hostname or IP address\n- port: int - The target server port number\n- defaultTimeout: int - Default timeout in milliseconds for request completion\n- workerGroup: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- b: Bootstrap - Netty bootstrap for client configuration\n- results: ConcurrentHashMap<String, CompletableFuture<String>> - Map for tracking pending requests and their futures\n\nMethods:\n- init(): void - Initializes the Netty client configuration including pipeline setup\n- close(): void - Shuts down the client gracefully and releases resources\n- get(String uri) -> String - Sends an HTTP GET request to the specified URI\n- post(String uri, Map<String, String> params, Map<String, String> headers) -> String - Sends an HTTP POST request with parameters and headers\n- send(HttpRequest request) -> String - Internal method for sending requests and handling responses",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private Map<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b = new Bootstrap();\n        workerGroup = new NioEventLoopGroup();\n        b.group(workerGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\"http-decoder\", new HttpResponseDecoder());\n                ch.pipeline().addLast(\"http-encoder\", new HttpRequestEncoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(1024 * 1024));\n                ch.pipeline().addLast(\"clientHandler\", new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpResponse httpResponse) {\n                        CompletableFuture<String> future = results.get(ctx.channel().id().asLongText());\n                        if (future != null) {\n                            future.complete(httpResponse.content().toString(CharsetUtil.UTF_8));\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void close() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        results.clear();\n    }\n\n    public String get(String uri) throws Exception {\n        DefaultHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, new URI(uri).toASCIIString());\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws Exception {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(uri).toASCIIString());\n        if (params != null && !params.isEmpty()) {\n            HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(new DefaultHttpDataFactory(), request, false);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encoder.addBodyAttribute(entry.getKey(), entry.getValue());\n            }\n            request = encoder.finalizeRequest();\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) throws Exception {\n        ChannelFuture f = b.connect(host, port).sync();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(f.channel().id().asLongText(), future);\n        String result;\n        try {\n            f.channel().writeAndFlush(request).sync();\n            result = future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } finally {\n            results.remove(f.channel().id().asLongText());\n            f.channel().closeFuture().sync();\n        }\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private final String host;\n    private final int port;\n    private final int defaultTimeout;\n    private final EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private final ConcurrentHashMap<String, CompletableFuture<String>> results;\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        this.workerGroup = new NioEventLoopGroup();\n        this.results = new ConcurrentHashMap<>();\n    }\n\n    public void init() {\n        b = new Bootstrap();\n        b.group(workerGroup)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.SO_KEEPALIVE, true)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             protected void initChannel(SocketChannel ch) throws Exception {\n                 ChannelPipeline p = ch.pipeline();\n                 p.addLast(new IdleStateHandler(0, 0, defaultTimeout, TimeUnit.MILLISECONDS));\n                 p.addLast(new HttpClientCodec());\n                 p.addLast(new HttpObjectAggregator(65536));\n                 p.addLast(new HttpClientInboundHandler(results));\n             }\n         });\n    }\n\n    public void close() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public String get(String uri) {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) {\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri);\n        StringBuilder bodyBuilder = new StringBuilder();\n        for (Map.Entry<String, String> param : params.entrySet()) {\n            if (bodyBuilder.length() > 0) bodyBuilder.append(\"&\");\n            bodyBuilder.append(param.getKey()).append(\"=\").append(param.getValue());\n        }\n        request.content().writeBytes(bodyBuilder.toString(), CharsetUtil.UTF_8);\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());\n        request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n\n        for (Map.Entry<String, String> header : headers.entrySet()) {\n            request.headers().set(header.getKey(), header.getValue());\n        }\n\n        return send(request);\n    }\n\n    private String send(HttpRequest request) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        String requestId = String.valueOf(System.currentTimeMillis());\n        results.put(requestId, future);\n\n        ChannelFuture channelFuture = b.connect(host, port).syncUninterruptibly();\n        channelFuture.addListener((ChannelFutureListener) future1 -> {\n            if (future1.isSuccess()) {\n                Channel channel = future1.channel();\n                channel.writeAndFlush(request);\n            } else {\n                future.completeExceptionally(future1.cause());\n            }\n        });\n\n        try {\n            return future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n            return null;\n        }\n    }\n\n    private static class HttpClientInboundHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n        private final ConcurrentHashMap<String, CompletableFuture<String>> results;\n\n        public HttpClientInboundHandler(ConcurrentHashMap<String, CompletableFuture<String>> results) {\n            this.results = results;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) {\n            String responseContent = msg.content().toString(CharsetUtil.UTF_8);\n            // Assuming requestId is part of the response headers for simplicity\n            String requestId = msg.headers().get(\"RequestId\");\n            if (requestId != null && results.containsKey(requestId)) {\n                results.get(requestId).complete(responseContent);\n                results.remove(requestId);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Java class that provides functionality for interacting with files using Java NIO's FileChannel and memory-mapped file operations. The class should support opening files, mapping files to memory, accessing mapped buffers, forcing writes to disk, and properly closing resources.\n\nClass Description: The FileChannelInteractor class encapsulates operations for file channel interaction and memory-mapped file operations using Java NIO. It provides methods to open files, map file regions to memory, access mapped buffers, ensure data persistence, and clean up resources.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedBuffer: MappedByteBuffer - The buffer representing the memory-mapped file region\n\nMethods:\nopenFileChannel: openFileChannel(String filePath) -> void - Opens a FileChannel for reading the specified file. Throws IOException if the file cannot be opened.\nmapFileToMemory: mapFileToMemory(long position, long size) -> void - Maps a region of the file into memory for read-only access. Throws IOException if mapping fails.\ngetMappedBuffer: getMappedBuffer() -> MappedByteBuffer - Returns the currently mapped byte buffer.\ncloseChannel: closeChannel() -> void - Closes the FileChannel and releases associated resources. Throws IOException if closing fails.\nforceWriteToDisk: forceWriteToDisk() -> void - Forces any changes made to the mapped buffer to be written to disk (though in this implementation the buffer is read-only).",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.Path;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        Path path = Paths.get(filePath);\n        this.fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        this.mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return this.mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (this.fileChannel != null) {\n            this.fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (this.mappedBuffer != null) {\n            this.mappedBuffer.force();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        FileInputStream fis = new FileInputStream(filePath);\n        fileChannel = fis.getChannel();\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n        }\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() throws IOException {\n        // In this implementation, the buffer is read-only, so forceWriteToDisk does nothing.\n        // If the buffer were writable, we would call mappedBuffer.force().\n    }\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\nimport javax.net.ssl.SSLException;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient {\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group;\n    private final Bootstrap b;\n    private final Queue<HttpObject> responseParts = new ConcurrentLinkedQueue<>();\n    private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n    private final CommunicationHandler communicationHandler;\n    private final AtomicBoolean isOpen = new AtomicBoolean(false);\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private FutureResult<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n\n    public NettyClient(String hostname, int port, SSLFactory sslFactory) throws SSLException {\n        this.hostname = hostname;\n        this.port = port;\n        this.group = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        SslContext sslCtx = sslFactory != null ? sslFactory.getSslContext() : SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             protected void initChannel(SocketChannel ch) throws Exception {\n                 ChannelPipeline p = ch.pipeline();\n                 if (sslCtx != null) {\n                     p.addLast(sslCtx.newHandler(ch.alloc(), hostname, port));\n                 }\n                 p.addLast(new HttpClientCodec());\n                 p.addLast(new HttpObjectAggregator(8192));\n                 p.addLast(new ChunkedWriteHandler());\n                 communicationHandler = new CommunicationHandler();\n                 p.addLast(communicationHandler);\n             }\n         });\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        this.request = request;\n        this.content = content;\n        this.callback = callback;\n        this.responseFuture = new FutureResult<>();\n        createChannel();\n        return responseFuture;\n    }\n\n    public void close() {\n        if (isOpen.compareAndSet(true, false)) {\n            group.shutdownGracefully();\n        }\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        callbackInvoked.set(false);\n        request = null;\n        content = null;\n        responseFuture = null;\n        callback = null;\n        channelConnectFuture = null;\n        exception = null;\n        isKeepAlive = false;\n    }\n\n    private void createChannel() {\n        channelConnectFuture = b.connect(hostname, port);\n        channelConnectFuture.addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                Channel channel = future.channel();\n                isOpen.set(true);\n                channel.writeAndFlush(request);\n                if (content != null) {\n                    channel.writeAndFlush(content).addListener(ChannelFutureListener.CLOSE);\n                }\n            } else {\n                exception = future.cause();\n                invokeFutureAndCallback(\"Failed to connect\");\n            }\n        });\n    }\n\n    private void invokeFutureAndCallback(String message) {\n        if (callbackInvoked.compareAndSet(false, true)) {\n            ResponseParts responsePartsWrapper = new ResponseParts(responseParts, exception, isKeepAlive);\n            responseFuture.complete(responsePartsWrapper);\n            if (callback != null) {\n                callback.call(responsePartsWrapper);\n            }\n            resetState();\n        }\n    }\n\n    public interface Callback<T> {\n        void call(T result);\n    }\n\n    public static class FutureResult<T> {\n        private T result;\n        private boolean completed;\n\n        public synchronized void complete(T result) {\n            this.result = result;\n            completed = true;\n            notifyAll();\n        }\n\n        public synchronized T get() throws InterruptedException {\n            while (!completed) {\n                wait();\n            }\n            return result;\n        }\n    }\n\n    public static class ResponseParts {\n        private final Queue<HttpObject> parts;\n        private final Exception exception;\n        private final boolean isKeepAlive;\n\n        public ResponseParts(Queue<HttpObject> parts, Exception exception, boolean isKeepAlive) {\n            this.parts = parts;\n            this.exception = exception;\n            this.isKeepAlive = isKeepAlive;\n        }\n\n        public Queue<HttpObject> getParts() {\n            return parts;\n        }\n\n        public Exception getException() {\n            return exception;\n        }\n\n        public boolean isKeepAlive() {\n            return isKeepAlive;\n        }\n    }\n\n    private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            responseParts.add(msg);\n            if (msg instanceof LastHttpContent) {\n                isKeepAlive = HttpHeaders.isKeepAlive(request);\n                invokeFutureAndCallback(\"Response received\");\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            exception = new Exception(cause);\n            invokeFutureAndCallback(\"Exception caught\");\n            ctx.close();\n        }\n    }\n\n    public interface SSLFactory {\n        SslContext getSslContext() throws SSLException;\n    }\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Java class that implements a transactional log writer for Elasticsearch, handling file operations using Java NIO's FileChannel for efficient I/O operations. The class should manage writing operations, buffer management, and resource cleanup.\n\nClass Description: TranslogWriter is a transactional log writer that extends BaseTranslogReader and implements Closeable. It provides functionality to write operations to a log file using FileChannel, manage buffers, and handle synchronization. The class includes mechanisms for checkpointing, thread-safe operations, and resource management.\n\nAttributes:\n- channel: [FileChannel] - The main file channel for writing transaction log entries\n- checkpointChannel: [FileChannel] - File channel for writing checkpoint information\n- checkpointPath: [Path] - Path to the checkpoint file\n- bigArrays: [BigArrays] - Helper for managing large arrays\n- totalOffset: [long] - Current offset in the log file\n- closed: [AtomicBoolean] - Flag indicating whether the writer is closed\n- writeLock: [ReleasableLock] - Lock for thread-safe write operations\n- syncLock: [Object] - Synchronization lock object\n- buffer: [ReleasableBytesStreamOutput] - Buffer for holding data before writing\n- globalCheckpointSupplier: [LongSupplier] - Supplier for global checkpoint information\n- minTranslogGenerationSupplier: [LongSupplier] - Supplier for minimum translog generation\n- persistedSequenceNumberConsumer: [LongConsumer] - Consumer for persisted sequence numbers\n\nMethods:\n- TranslogWriter([ShardId, Checkpoint, FileChannel, FileChannel, Path, Path, ByteSizeValue, LongSupplier, LongSupplier, TranslogHeader, TragicExceptionHolder, LongConsumer, BigArrays]) -> [void] - Constructor that initializes the translog writer with all required components\n- writeAndReleaseOps([ReleasableBytesReference]) -> [void] - Writes the given bytes reference to the file and releases it\n- writeToFile([ByteBuffer]) -> [void] - Helper method that writes buffer contents to the file channel\n- readBytes([ByteBuffer, long]) -> [void] - Reads bytes from the specified position into the target buffer\n- writeCheckpoint([FileChannel, Path, Checkpoint]) -> [void] - Static helper method to write checkpoint information\n- close() -> [void] - Closes all resources and marks the writer as closed",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefIterator;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.DiskIoBufferPool;\nimport org.elasticsearch.common.lease.Releasables;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\n\nimport io.crate.common.SuppressForbidden;\nimport io.crate.common.io.IOUtils;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private volatile long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(\n        final ShardId shardId,\n        final Checkpoint initialCheckpoint,\n        final FileChannel channel,\n        final FileChannel checkpointChannel,\n        final Path path,\n        final Path checkpointPath,\n        final ByteSizeValue bufferSize,\n        final LongSupplier globalCheckpointSupplier,\n        LongSupplier minTranslogGenerationSupplier,\n        TranslogHeader header,\n        final TragicExceptionHolder tragedy,\n        final LongConsumer persistedSequenceNumberConsumer,\n        final BigArrays bigArrays) throws IOException {\n        super(initialCheckpoint.generation, channel, path, header);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = initialCheckpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    private void writeAndReleaseOps(ReleasableBytesReference toWrite) throws IOException {\n        try (ReleasableBytesReference toClose = toWrite) {\n            assert writeLock.isHeldByCurrentThread();\n            ByteBuffer ioBuffer = DiskIoBufferPool.getIoBuffer();\n\n            BytesRefIterator iterator = toWrite.iterator();\n            BytesRef current;\n            while ((current = iterator.next()) != null) {\n                int currentBytesConsumed = 0;\n                while (currentBytesConsumed != current.length) {\n                    int nBytesToWrite = Math.min(current.length - currentBytesConsumed, ioBuffer.remaining());\n                    ioBuffer.put(current.bytes, current.offset + currentBytesConsumed, nBytesToWrite);\n                    currentBytesConsumed += nBytesToWrite;\n                    if (ioBuffer.hasRemaining() == false) {\n                        ioBuffer.flip();\n                        writeToFile(ioBuffer);\n                        ioBuffer.clear();\n                    }\n                }\n            }\n            ioBuffer.flip();\n            writeToFile(ioBuffer);\n        }\n    }\n\n    @SuppressForbidden(reason = \"Channel#write\")\n    private void writeToFile(ByteBuffer ioBuffer) throws IOException {\n        while (ioBuffer.remaining() > 0) {\n            channel.write(ioBuffer);\n        }\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        try {\n            if (position + targetBuffer.remaining() > getWrittenOffset()) {\n                writeBufferedOps(position + targetBuffer.remaining(), true);\n            }\n        } catch (final Exception ex) {\n            closeWithTragicEvent(ex);\n            throw ex;\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, targetBuffer);\n    }\n\n    private static void writeCheckpoint(\n        final FileChannel fileChannel,\n        final Path checkpointFile,\n        final Checkpoint checkpoint) throws IOException {\n        Checkpoint.write(fileChannel, checkpointFile, checkpoint);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            synchronized (this) {\n                Releasables.closeIgnoringException(buffer);\n                buffer = null;\n            }\n            IOUtils.close(checkpointChannel, channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.lucene.store.Releasable;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesStreamOutput;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\nimport org.elasticsearch.index.translog.Checkpoint;\nimport org.elasticsearch.index.translog.TranslogHeader;\nimport org.elasticsearch.index.translog.TragicExceptionHolder;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.core.ReleasableLock;\n\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\npublic class TranslogWriter extends BaseTranslogReader implements Releasable {\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock;\n    private final Object syncLock = new Object();\n    private final ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(ShardId shardId, Checkpoint checkpoint, FileChannel channel, FileChannel checkpointChannel, Path checkpointPath, Path translogPath, ByteSizeValue bufferSize, LongSupplier globalCheckpointSupplier, LongSupplier minTranslogGenerationSupplier, TranslogHeader header, TragicExceptionHolder tragicExceptionHolder, LongConsumer persistedSequenceNumberConsumer, BigArrays bigArrays) throws IOException {\n        super(shardId, checkpoint, translogPath, header, tragicExceptionHolder);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = checkpoint.offset;\n        this.writeLock = new ReleasableLock(writeLock());\n        this.buffer = new ReleasableBytesStreamOutput(bigArrays, bufferSize.getBytes());\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    public void writeAndReleaseOps(ReleasableBytesReference ops) throws IOException {\n        try (Releasable ignored = writeLock.acquire()) {\n            buffer.writeBytesReference(ops);\n            flushBuffer();\n        } finally {\n            ops.close();\n        }\n    }\n\n    private void writeToFile(ByteBuffer buffer) throws IOException {\n        while (buffer.hasRemaining()) {\n            channel.write(buffer);\n        }\n    }\n\n    private void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        channel.position(position);\n        while (targetBuffer.hasRemaining()) {\n            channel.read(targetBuffer);\n        }\n    }\n\n    public static void writeCheckpoint(FileChannel checkpointChannel, Path checkpointPath, Checkpoint checkpoint) throws IOException {\n        // Implementation of writing checkpoint information\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                flushBuffer();\n                channel.force(true);\n                checkpointChannel.force(true);\n            } finally {\n                IOUtils.close(channel, checkpointChannel);\n            }\n        }\n    }\n\n    private void flushBuffer() throws IOException {\n        synchronized (syncLock) {\n            buffer.flush();\n            ByteBuffer data = buffer.bytes().toByteBuffer();\n            writeToFile(data);\n            totalOffset += data.remaining();\n            persistedSequenceNumberConsumer.accept(globalCheckpointSupplier.getAsLong());\n        }\n    }\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n    private final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        while (chunk.hasRemaining()) {\n            // Assuming each entry is a pair of [fieldNameLength, fieldNameBytes, value]\n            int fieldNameLength = chunk.getInt();\n            ByteBuffer fieldName = chunk.slice().limit(fieldNameLength);\n            chunk.position(chunk.position() + fieldNameLength);\n            int value = chunk.getInt();\n\n            mins.compute(fieldName.duplicate(), (k, v) -> v == null ? value : Math.min(v, value));\n            maxs.compute(fieldName.duplicate(), (k, v) -> v == null ? value : Math.max(v, value));\n            sums.compute(fieldName.duplicate(), (k, v) -> v == null ? value : v + value);\n            counts.compute(fieldName.duplicate(), (k, v) -> v == null ? 1 : v + 1);\n        }\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.READ)) {\n            long fileSize = fileChannel.size();\n            long position = 0;\n            long chunkSize = 1024 * 1024; // 1 MB per chunk\n\n            while (position < fileSize) {\n                long remaining = fileSize - position;\n                chunkSize = Math.min(chunkSize, remaining);\n                MappedByteBuffer chunk = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, chunkSize);\n                processChunk(chunk, chunkSize);\n                position += chunkSize;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
    "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.ServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class NettyAcceptor {\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass = NioServerSocketChannel.class;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) {\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        nettySoBacklog = props.getInt(\"nettySoBacklog\", 128);\n        nettySoReuseaddr = props.getBoolean(\"nettySoReuseaddr\", true);\n        nettyTcpNodelay = props.getBoolean(\"nettyTcpNodelay\", true);\n        nettySoKeepalive = props.getBoolean(\"nettySoKeepalive\", true);\n        nettyChannelTimeoutSeconds = props.getInt(\"nettyChannelTimeoutSeconds\", 30);\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(m_bossGroup, m_workerGroup)\n             .channel(channelClass)\n             .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n             .childOption(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n             .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n             .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) throws Exception {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new MqttDecoder());\n                     pipeline.addLast(MqttEncoder.INSTANCE);\n                     pipeline.addLast(new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                     pipeline.addLast(new NettyMQTTHandler(processor));\n                 }\n             });\n\n            ChannelFuture f = b.bind(props.getInt(\"port\")).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            close();\n        }\n    }\n\n    public void initializePlainTCPTransport(NettyMQTTHandler handler, IConfig props) {\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        nettySoBacklog = props.getInt(\"nettySoBacklog\", 128);\n        nettySoReuseaddr = props.getBoolean(\"nettySoReuseaddr\", true);\n        nettyTcpNodelay = props.getBoolean(\"nettyTcpNodelay\", true);\n        nettySoKeepalive = props.getBoolean(\"nettySoKeepalive\", true);\n        nettyChannelTimeoutSeconds = props.getInt(\"nettyChannelTimeoutSeconds\", 30);\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(m_bossGroup, m_workerGroup)\n             .channel(channelClass)\n             .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n             .childOption(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n             .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n             .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) throws Exception {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new MqttDecoder());\n                     pipeline.addLast(MqttEncoder.INSTANCE);\n                     pipeline.addLast(new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                     pipeline.addLast(handler);\n                 }\n             });\n\n            ChannelFuture f = b.bind(props.getInt(\"port\")).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        if (m_bossGroup != null) {\n            m_bossGroup.shutdownGracefully();\n        }\n        if (m_workerGroup != null) {\n            m_workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Java class that provides memory-mapped file access capabilities and process spawning functionality for inter-process communication scenarios.\n\nClass Description: FileChannelInteractor is a utility class that handles memory-mapped file operations and process management. It allows read-only memory mapping of files and provides functionality to spawn worker processes for IPC scenarios.\n\nAttributes:\n- fileChannel: FileChannel - The NIO FileChannel used for file operations\n- mapAddress: long - The memory address of the mapped file region\n- fileSize: long - The size of the mapped file in bytes\n\nMethods:\n- FileChannelInteractor(String filePath) -> void - Constructor that opens a file channel and maps the file into memory in read-only mode\n- getMemoryMappedAddress() -> long - Returns the memory address of the mapped file region\n- getFileSize() -> long - Returns the size of the mapped file\n- close() -> void - Closes the file channel and releases system resources\n- spawnWorkerProcess() -> void - Static method that spawns a worker process with the same command and arguments as the current process, adding a \"--worker\" flag",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelInteractor {\n\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mapAddress = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        fileChannel.close();\n    }\n\n    public static void spawnWorkerProcess() throws IOException {\n        ProcessHandle.Info info = ProcessHandle.current().info();\n        ArrayList<String> workerCommand = new ArrayList<>();\n        info.command().ifPresent(workerCommand::add);\n        info.arguments().ifPresent(args -> workerCommand.addAll(Arrays.asList(args)));\n        workerCommand.add(\"--worker\");\n        new ProcessBuilder()\n                .command(workerCommand)\n                .inheritIO()\n                .redirectOutput(ProcessBuilder.Redirect.PIPE)\n                .start()\n                .getInputStream()\n                .transferTo(System.out);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n        fileChannel = file.getChannel();\n        fileSize = fileChannel.size();\n        MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n        mapAddress = ((sun.nio.ch.DirectBuffer) buffer).address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public static void spawnWorkerProcess() throws IOException {\n        String[] cmd = new String[2 + ManagementFactory.getRuntimeMXBean().getInputArguments().size()];\n        cmd[0] = System.getProperty(\"java.home\") + \"/bin/java\";\n        cmd[1] = \"-cp\";\n        cmd[2] = System.getProperty(\"java.class.path\");\n        int index = 3;\n        for (String arg : ManagementFactory.getRuntimeMXBean().getInputArguments()) {\n            cmd[index++] = arg;\n        }\n        cmd[index] = FileChannelInteractor.class.getName();\n        cmd[index + 1] = \"--worker\";\n        ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n        processBuilder.start();\n    }\n\n    public static void main(String[] args) {\n        if (args.length > 0 && args[args.length - 1].equals(\"--worker\")) {\n            // Worker process logic here\n        } else {\n            // Main process logic here\n        }\n    }\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n    public static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        boolean supported = false;\n        try {\n            File tempFile = File.createTempFile(\"anonalloc\", null);\n            tempFile.deleteOnExit();\n            try (FileChannel channel = FileChannel.open(tempFile.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DELETE_ON_CLOSE)) {\n                MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1);\n                supported = true;\n            }\n        } catch (IOException e) {\n            // Fallback to direct byte buffers if mapping with unlinking fails\n        }\n        MAP_AND_UNLINK_SUPPORTED = supported;\n    }\n\n    public ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                File tempFile = File.createTempFile(\"anonalloc\", null);\n                tempFile.deleteOnExit();\n                try (FileChannel channel = FileChannel.open(tempFile.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DELETE_ON_CLOSE)) {\n                    return channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                }\n            } catch (IOException e) {\n                // Fallback to direct byte buffers if an error occurs\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract class TransferType {\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n    public TransferType(String path, DataStream cli) throws IOException {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = Files.size(Paths.get(path));\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncSize();\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    public boolean isSync(long position) {\n        return position >= syncPosition + syncSize;\n    }\n\n    public List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable) throws IOException {\n        List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        try (FileChannel in = FileChannel.open(file.toPath())) {\n            DataStreamOutput out = client.getDataStreamOutput(routingTable);\n            long offset = 0;\n            while (offset < fileSize) {\n                offset = write(in, out, offset, futures);\n                if (isSync(offset)) {\n                    syncPosition = offset;\n                    // Perform synchronization here if needed\n                }\n            }\n        }\n        return futures;\n    }\n\n    protected abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n                \"path='\" + path + '\\'' +\n                \", fileSize=\" + fileSize +\n                \", bufferSize=\" + bufferSize +\n                \", syncSize=\" + syncSize +\n                \", syncPosition=\" + syncPosition +\n                '}';\n    }\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class WidgetUtil {\n    private static final String WIDGET_URL = \"https://discord.com/api/guilds/%d/widget.json\";\n\n    public Widget getWidget(long guildId) throws RateLimitedException {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(String.format(WIDGET_URL, guildId)))\n                .build();\n\n        try {\n            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n            switch (response.statusCode()) {\n                case 200:\n                    ObjectMapper mapper = new ObjectMapper();\n                    return mapper.readValue(response.body(), Widget.class);\n                case 404:\n                case 403:\n                    return null;\n                case 429:\n                    throw new RateLimitedException(\"Rate limited\");\n                default:\n                    throw new IOException(\"Unexpected status code: \" + response.statusCode());\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new UncheckedIOException(new IOException(\"Request interrupted\", e));\n        }\n    }\n\n    public static class RateLimitedException extends Exception {\n        public RateLimitedException(String message) {\n            super(message);\n        }\n    }\n\n    public static class Widget {\n        // Define the structure of the Widget class based on the expected JSON response\n    }\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass HttpClient {\n    private static final OkHttpClient httpClient = new OkHttpClient.Builder().build();\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS = new FallBackDNS();\n    private static boolean doh = true;\n\n    static {\n        Cache cache = new Cache(new File(\"cache\"), 10 * 1024 * 1024);\n        DnsOverHttps dnsOverHttps = new DnsOverHttps.Builder()\n                .client(httpClient)\n                .url(HttpUrl.get(\"https://dns.google/dns-query\"))\n                .bootstrapDns(Arrays.asList(InetAddress.getByName(\"8.8.8.8\"), InetAddress.getByName(\"8.8.4.4\")))\n                .build();\n\n        httpClientDoH = new OkHttpClient.Builder()\n                .dns(dnsOverHttps)\n                .build();\n\n        httpClientWithCache = new OkHttpClient.Builder()\n                .cache(cache)\n                .build();\n\n        httpClientWithCacheDoH = new OkHttpClient.Builder()\n                .dns(dnsOverHttps)\n                .cache(cache)\n                .build();\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return response.body().bytes();\n        }\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        RequestBody body = new JsonRequestBody(data);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return response.body().bytes();\n        }\n    }\n\n    public static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        // Implementation for captcha check\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private final String jsonData;\n\n        JsonRequestBody(String jsonData) {\n            this.jsonData = jsonData;\n        }\n\n        @Override\n        public MediaType contentType() {\n            return MediaType.parse(\"application/json; charset=utf-8\");\n        }\n\n        @Override\n        public void writeTo(BufferedSink sink) throws IOException {\n            sink.writeUtf8(jsonData);\n        }\n    }\n\n    private static class FallBackDNS implements Dns {\n        @Override\n        public List<InetAddress> lookup(String hostname) throws UnknownHostException {\n            try {\n                return Dns.SYSTEM.lookup(hostname);\n            } catch (UnknownHostException e) {\n                return Arrays.asList(InetAddress.getByName(\"8.8.8.8\"));\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hadoop.conf.Configuration;\n\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class VaultClient implements KmsClient {\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private final String kmsToken;\n    private final Configuration hadoopConfiguration;\n    private final String endPointPrefix;\n    private final OkHttpClient httpClient;\n\n    public VaultClient(String kmsToken, Configuration hadoopConfiguration, String endPointPrefix, OkHttpClient httpClient) {\n        this.kmsToken = kmsToken;\n        this.hadoopConfiguration = hadoopConfiguration;\n        this.endPointPrefix = endPointPrefix;\n        this.httpClient = httpClient;\n    }\n\n    private String getContentFromTransitEngine(String path, String payload, String masterKeyIdentifier) throws IOException {\n        HttpUrl.Builder urlBuilder = HttpUrl.parse(endPointPrefix + path).newBuilder();\n        urlBuilder.addQueryParameter(\"name\", masterKeyIdentifier);\n        RequestBody body = RequestBody.create(payload, JSON_MEDIA_TYPE);\n        Request request = new Request.Builder()\n                .url(urlBuilder.build())\n                .post(body)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .build();\n        return executeAndGetResponse(\"POST\", request);\n    }\n\n    private String executeAndGetResponse(String method, Request request) throws IOException {\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return response.body().string();\n        }\n    }\n\n    private String buildPayload(Map<String, String> parameters) throws IOException {\n        return objectMapper.writeValueAsString(parameters);\n    }\n\n    @Override\n    public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws IOException {\n        Map<String, String> payloadMap = Map.of(\"plaintext\", Base64.getEncoder().encodeToString(keyBytes));\n        String payload = buildPayload(payloadMap);\n        String response = getContentFromTransitEngine(\"/v1/transit/encrypt/\" + masterKeyIdentifier, payload, masterKeyIdentifier);\n        return parseReturn(response, \"ciphertext\");\n    }\n\n    @Override\n    public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws IOException {\n        Map<String, String> payloadMap = Map.of(\"ciphertext\", wrappedKey);\n        String payload = buildPayload(payloadMap);\n        String response = getContentFromTransitEngine(\"/v1/transit/decrypt/\" + masterKeyIdentifier, payload, masterKeyIdentifier);\n        String base64DecodedKey = parseReturn(response, \"plaintext\");\n        return Base64.getDecoder().decode(base64DecodedKey);\n    }\n\n    private String parseReturn(String response, String key) throws IOException {\n        Map<String, Object> responseMap = objectMapper.readValue(response, Map.class);\n        Map<String, Object> dataMap = (Map<String, Object>) responseMap.get(\"data\");\n        return (String) dataMap.get(key);\n    }\n\n    @Override\n    public void refreshToken() {\n        // Implementation not shown\n    }\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Implement a Java class that interacts with GitHub's OAuth API to obtain an access token and retrieve user information using the OkHttp library for HTTP requests.\n\nClass Description: The `GithubProvider` class handles authentication with GitHub's OAuth API. It provides methods to obtain an access token using authorization code and to fetch GitHub user information using the obtained access token.\n\nAttributes:\n- clientId: String - GitHub OAuth application client ID (injected from configuration)\n- clientSecret: String - GitHub OAuth application client secret (injected from configuration)\n- redirectUri: String - Redirect URI registered with GitHub OAuth application (injected from configuration)\n\nMethods:\n- getAccessToken(AccessTokenDTO accessTokenDTO) -> String - Obtains an access token from GitHub's OAuth API. Takes an AccessTokenDTO object containing authorization code and other parameters, sets client credentials, makes a POST request to GitHub's token endpoint, and returns the access token.\n- getUser(String accessToken) -> GithubUser - Retrieves GitHub user information using the provided access token. Makes a GET request to GitHub's user API endpoint with the access token in the Authorization header and returns the user data as a GithubUser object.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport life.majiang.community.dto.AccessTokenDTO;\nimport life.majiang.community.provider.dto.GithubUser;\nimport okhttp3.*;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class GithubProvider {\n\n    @Value(\"${github.client.id}\")\n    private String clientId;\n\n    @Value(\"${github.client.secret}\")\n    private String clientSecret;\n\n    @Value(\"${github.redirect.uri}\")\n    private String redirectUri;\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) {\n        accessTokenDTO.setClient_id(clientId);\n        accessTokenDTO.setClient_secret(clientSecret);\n        accessTokenDTO.setRedirect_uri(redirectUri);\n        MediaType mediaType = MediaType.get(\"application/json; charset=utf-8\");\n        OkHttpClient client = new OkHttpClient();\n\n        RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(body)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            String string = response.body().string();\n            String token = string.split(\"&\")[0].split(\"=\")[1];\n            return token;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public GithubUser getUser(String accessToken) {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .header(\"Authorization\", \"token \" + accessToken)\n                .build();\n        try {\n            Response response = client.newCall(request).execute();\n            String string = response.body().string();\n            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);\n            return githubUser;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport com.google.gson.Gson;\nimport java.io.IOException;\n\nclass GithubProvider {\n    private final String clientId;\n    private final String clientSecret;\n    private final String redirectUri;\n    private final OkHttpClient client = new OkHttpClient();\n    private final Gson gson = new Gson();\n\n    public GithubProvider(String clientId, String clientSecret, String redirectUri) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n    }\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) throws IOException {\n        MediaType mediaType = MediaType.parse(\"application/json\");\n        RequestBody body = RequestBody.create(mediaType, gson.toJson(accessTokenDTO));\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(body)\n                .addHeader(\"Accept\", \"application/json\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return gson.fromJson(response.body().string(), AccessTokenResponse.class).getAccessToken();\n        }\n    }\n\n    public GithubUser getUser(String accessToken) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .addHeader(\"Authorization\", \"token \" + accessToken)\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return gson.fromJson(response.body().string(), GithubUser.class);\n        }\n    }\n\n    static class AccessTokenDTO {\n        private String client_id;\n        private String client_secret;\n        private String code;\n        private String redirect_uri;\n\n        public AccessTokenDTO(String client_id, String client_secret, String code, String redirect_uri) {\n            this.client_id = client_id;\n            this.client_secret = client_secret;\n            this.code = code;\n            this.redirect_uri = redirect_uri;\n        }\n    }\n\n    static class AccessTokenResponse {\n        private String access_token;\n\n        public String getAccessToken() {\n            return access_token;\n        }\n    }\n\n    static class GithubUser {\n        private String login;\n        private int id;\n        private String node_id;\n        private String avatar_url;\n        private String gravatar_id;\n        private String url;\n        private String html_url;\n        private String followers_url;\n        private String following_url;\n        private String gists_url;\n        private String starred_url;\n        private String subscriptions_url;\n        private String organizations_url;\n        private String repos_url;\n        private String events_url;\n        private String received_events_url;\n        private String type;\n        private boolean site_admin;\n\n        // Getters and setters can be added here if needed\n    }\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.TimeUnit;\n\npublic class GraphHopperGeocoding {\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key;\n    private static final long DEFAULT_TIMEOUT = 5000L;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        this.downloader = new OkHttpClient.Builder()\n                .connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) throws IOException {\n        OkHttpClient client = getClientForRequest(request);\n        String url = buildUrl(request);\n        Request req = new Request.Builder().url(url).build();\n        try (Response response = client.newCall(req).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return objectMapper.readValue(response.body().string(), GHGeocodingResponse.class);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        return downloader.newBuilder()\n                .connectTimeout(request.getTimeout(), TimeUnit.MILLISECONDS)\n                .readTimeout(request.getTimeout(), TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        StringBuilder urlBuilder = new StringBuilder(routeServiceUrl).append(\"?\");\n        if (request.getQuery() != null) urlBuilder.append(\"q=\").append(encodeURL(request.getQuery())).append(\"&\");\n        if (request.getPoint() != null) urlBuilder.append(\"point=\").append(request.getPoint()).append(\"&\");\n        if (key != null) urlBuilder.append(\"key=\").append(key);\n        return urlBuilder.toString();\n    }\n\n    private String encodeURL(String str) {\n        return URLEncoder.encode(str, StandardCharsets.UTF_8);\n    }\n}\n\nclass GHGeocodingRequest {\n    private String query;\n    private String point;\n    private long timeout = GraphHopperGeocoding.DEFAULT_TIMEOUT;\n\n    public GHGeocodingRequest() {}\n\n    public GHGeocodingRequest(String query) {\n        this.query = query;\n    }\n\n    public GHGeocodingRequest(String point, boolean isPoint) {\n        if (isPoint) this.point = point;\n    }\n\n    public String getQuery() {\n        return query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    public String getPoint() {\n        return point;\n    }\n\n    public void setPoint(String point) {\n        this.point = point;\n    }\n\n    public long getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(long timeout) {\n        this.timeout = timeout;\n    }\n}\n\nclass GHGeocodingResponse {\n    // Define the structure of the response as per GraphHopper API documentation\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"https://danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private final Pattern gidPattern;\n    private int currentPageNum;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n        this.gidPattern = Pattern.compile(\"/posts/(\\\\d+)\");\n        this.currentPageNum = 1;\n    }\n\n    public JSONObject getPage(int pageNum) throws IOException {\n        String url = DOMAIN + \"/posts.json?page=\" + pageNum;\n        Request request = new Request.Builder().url(url).build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            return new JSONObject(response.body().string());\n        }\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> urls = new ArrayList<>();\n        JSONArray posts = json.getJSONArray(\"posts\");\n        for (int i = 0; i < posts.length(); i++) {\n            JSONObject post = posts.getJSONObject(i);\n            urls.add(post.getString(\"file_url\"));\n        }\n        return urls;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        Matcher matcher = gidPattern.matcher(url.getPath());\n        if (matcher.find()) {\n            return matcher.group(1);\n        } else {\n            throw new MalformedURLException(\"Invalid Danbooru URL format\");\n        }\n    }\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.apache.commons.validator.routines.UrlValidator;\n\nimport java.io.IOException;\n\nclass TerminologyServiceClient {\n    private OkHttpClient client;\n    private UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient() {\n        this.client = new OkHttpClient();\n        this.urlValidator = new UrlValidator(new String[]{\"http\", \"https\"}, UrlValidator.ALLOW_LOCAL_URLS | UrlValidator.NO_FRAGMENTS);\n    }\n\n    public void setBaseUrl(String url) {\n        if (!url.endsWith(\"/\")) {\n            url += \"/\";\n        }\n        this.expandBaseUrl = url + \"ValueSet/$expand\";\n    }\n\n    public Response expandValueSet(String valueSetUri) throws IOException {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid value set URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + \"?url=\" + valueSetUri)\n                .build();\n\n        return client.newCall(request).execute();\n    }\n}"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport java.util.Map;\nimport java.util.UUID;\n\nclass ApiClient {\n    private OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .writeTimeout(30, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) {\n        // Implementation for retrieving Copilot token\n        return \"copilot_token\";\n    }\n\n    public String getCoCoToken(String apiKey) {\n        // Implementation for retrieving CoCoPilot token\n        return \"coco_token\";\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws Exception {\n        RequestBody requestBody = body != null ? RequestBody.create(body, MediaType.parse(\"application/json\")) : null;\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, requestBody);\n\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                requestBuilder.addHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        Request request = requestBuilder.build();\n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        return Map.of(\n                \"Authorization\", \"Bearer \" + chatToken,\n                \"User-Agent\", \"ApiClient\",\n                \"X-Machine-Id\", machineId\n        );\n    }\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "import org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.ItemReader;\n\nimport java.time.Duration;\nimport java.util.*;\n\npublic class KafkaItemReader<K, V> implements ItemReader<V> {\n    public static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30000L;\n\n    private final List<TopicPartition> topicPartitions;\n    private final Map<TopicPartition, Long> partitionOffsets;\n    private final KafkaConsumer<K, V> kafkaConsumer;\n    private final Duration pollTimeout;\n    private final boolean saveState;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n\n    public KafkaItemReader(Properties consumerProperties, String topic, Integer... partitions) {\n        this(consumerProperties, topic, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, List<Integer> partitions) {\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            topicPartitions.add(new TopicPartition(topic, partition));\n        }\n        this.partitionOffsets = new HashMap<>();\n        this.kafkaConsumer = new KafkaConsumer<>(consumerProperties);\n        this.pollTimeout = Duration.ofMillis(DEFAULT_POLL_TIMEOUT);\n        this.saveState = true;\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        kafkaConsumer.assign(topicPartitions);\n        if (executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            partitionOffsets.putAll((Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS));\n        } else {\n            for (TopicPartition topicPartition : topicPartitions) {\n                partitionOffsets.put(topicPartition, kafkaConsumer.position(topicPartition));\n            }\n        }\n        for (Map.Entry<TopicPartition, Long> entry : partitionOffsets.entrySet()) {\n            kafkaConsumer.seek(entry.getKey(), entry.getValue());\n        }\n    }\n\n    @Override\n    public V read() {\n        if (consumerRecords == null || !consumerRecords.hasNext()) {\n            consumerRecords = kafkaConsumer.poll(pollTimeout).iterator();\n        }\n        if (consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = consumerRecords.next();\n            partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset() + 1);\n            return record.value();\n        }\n        return null;\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(partitionOffsets));\n            kafkaConsumer.commitSync();\n        }\n    }\n\n    @Override\n    public void close() {\n        kafkaConsumer.close();\n    }\n}"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Create a Kafka producer class that handles message serialization and sending to a Kafka topic with configurable properties and error handling.\n\nClass Description: The KafkaStoreProducer class is a generic Kafka producer that serializes and sends key-value pairs to a specified Kafka topic. It provides configurable timeout settings and handles various Kafka-related exceptions.\n\nAttributes:\n- producer: KafkaProducer<byte[], byte[]> - The underlying Kafka producer instance\n- topic: String - The Kafka topic to which messages will be sent\n- serializer: Serializer<K, V> - The serializer for key-value pairs\n- timeout: int - The maximum time to wait for message acknowledgment in milliseconds\n\nMethods:\n- Constructor: KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) -> void - Initializes the Kafka producer with configuration properties including bootstrap servers, topic, serializer, timeout, and additional custom properties\n- put: put(K key, V value) -> V - Serializes and sends a key-value pair to the Kafka topic, returning the value if successful. Throws StoreTimeoutException if the operation times out or StoreException for other errors\n- close: close() -> void - Closes the Kafka producer and releases all resources",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.exceptions.StoreException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.StoreTimeoutException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.SerializationException;\nimport io.confluent.kafka.schemaregistry.storage.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, \n                            Serializer<K, V> serializer, int timeout,\n                            Properties configProps) {\n        Properties props = new Properties();\n        props.putAll(configProps);\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.ACKS_CONFIG, \"-1\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        if (key == null) {\n            throw new StoreException(\"Key should not be null\");\n        }\n\n        ProducerRecord<byte[], byte[]> producerRecord;\n        try {\n            producerRecord = new ProducerRecord<>(\n                topic, \n                0, \n                this.serializer.serializeKey(key),\n                value == null ? null : this.serializer.serializeValue(value)\n            );\n        } catch (SerializationException e) {\n            throw new StoreException(\"Error serializing schema while creating the Kafka produce record\", e);\n        }\n\n        try {\n            Future<RecordMetadata> ack = producer.send(producerRecord);\n            RecordMetadata recordMetadata = ack.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            throw new StoreException(\"Put operation interrupted while waiting for an ack from Kafka\", e);\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof RecordTooLargeException) {\n                throw new StoreException(\"Put operation failed because entry is too large\");\n            } else {\n                throw new StoreException(\"Put operation failed while waiting for an ack from Kafka\", e);\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\n                \"Put operation timed out while waiting for an ack from Kafka\", e);\n        } catch (KafkaException ke) {\n            throw new StoreException(\"Put operation to Kafka failed\", ke);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\n\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nclass KafkaStoreProducer<K, V> {\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K> keySerializer;\n    private final Serializer<V> valueSerializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K> keySerializer, Serializer<V> valueSerializer, int timeout, Properties configProps) {\n        this.topic = topic;\n        this.keySerializer = keySerializer;\n        this.valueSerializer = valueSerializer;\n        this.timeout = timeout;\n\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapBrokers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        props.putAll(configProps);\n\n        this.producer = new KafkaProducer<>(props);\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        byte[] serializedKey = keySerializer.serialize(topic, key);\n        byte[] serializedValue = valueSerializer.serialize(topic, value);\n\n        ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, serializedKey, serializedValue);\n        Future<RecordMetadata> future = producer.send(record);\n\n        try {\n            future.get(timeout, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new StoreException(\"Thread interrupted while waiting for message acknowledgment\", e);\n        } catch (ExecutionException e) {\n            throw new StoreException(\"Error occurred while sending message\", e.getCause());\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\"Operation timed out after \" + timeout + \" ms\", e);\n        }\n\n        return value;\n    }\n\n    public void close() {\n        producer.close();\n    }\n}\n\nclass StoreTimeoutException extends Exception {\n    public StoreTimeoutException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass StoreException extends Exception {\n    public StoreException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a Kafka producer wrapper class in Java that simplifies sending JSON data to Kafka topics.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for producing messages to Kafka topics. It handles producer creation, message serialization, and error handling internally.\n\nAttributes:\n- kafkaProducer: Producer<Long, String> - The underlying Kafka producer instance\n- kafkaBrokers: String - Comma-separated list of Kafka broker addresses\n- gson: Gson - JSON serializer/deserializer instance\n\nMethods:\n- createKafkaProducer() -> Producer<Long, String> - Creates and configures a new Kafka producer instance with the specified broker addresses and serializers\n- send2Kafka(JsonElement jsonElement, String topicName) -> void - Serializes the JSON element and sends it to the specified Kafka topic\n- close() -> void - Properly closes the Kafka producer to release resources",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport com.google.gson.JsonElement;\nimport com.google.gson.Gson;\n\npublic class KafkaProducerWrapper {\n\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson = new Gson();\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.kafkaProducer = createKafkaProducer();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, Launcher.getInstanceId());\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 10000);\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName,\n                gson.toJson(jsonElement));\n        try {\n            kafkaProducer.send(record).get();\n        } \n        catch (ExecutionException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n        } catch (InterruptedException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonElement;\n\nimport java.util.Properties;\n\npublic class KafkaProducerWrapper {\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson;\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.kafkaProducer = createKafkaProducer();\n        this.gson = new Gson();\n    }\n\n    private Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", kafkaBrokers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.LongSerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        String jsonString = gson.toJson(jsonElement);\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName, System.currentTimeMillis(), jsonString);\n        kafkaProducer.send(record);\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Action1;\nimport rx.functions.Func1;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class KafkaSink<T> {\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef;\n    private Subscription subscription;\n\n    public KafkaSink(Func1<T, byte[]> encoder, Registry registry) {\n        this.encoder = encoder;\n        this.registry = registry;\n        this.kafkaProducerAtomicRef = new AtomicReference<>();\n    }\n\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            KafkaProducer<byte[], byte[]> producer = new KafkaProducer<>(context.getConfig().asProperties());\n            kafkaProducerAtomicRef.set(producer);\n        }\n\n        subscription = dataO.subscribe(new Action1<T>() {\n            @Override\n            public void call(T t) {\n                byte[] encodedData = encoder.call(t);\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(context.getConfig().getString(\"topic\"), encodedData);\n                kafkaProducerAtomicRef.get().send(record);\n            }\n        });\n    }\n\n    public List<ParameterDefinition<?>> getParameters() {\n        return List.of(\n                new ParameterDefinition<>(\"bootstrap.servers\", \"String\", \"Kafka broker addresses\"),\n                new ParameterDefinition<>(\"topic\", \"String\", \"Kafka topic to write to\")\n        );\n    }\n\n    public Metadata metadata() {\n        return new Metadata(\"KafkaSink\", \"Writes data to a Kafka topic\");\n    }\n\n    public void close() {\n        if (subscription != null) {\n            subscription.unsubscribe();\n        }\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.getAndSet(null);\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.slf4j.Logger;\n\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class KafkaSampleProducer {\n    private static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofSeconds(30);\n    private boolean _shutdown;\n    private Producer<byte[], byte[]> _producer;\n\n    public void createProducer(Map<String, ?> config, String producerClientId) {\n        config.put(\"client.id\", producerClientId);\n        _producer = new KafkaProducer<>(config);\n    }\n\n    public AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, String partitionMetricSampleStoreTopic, Logger log) {\n        AtomicInteger successCount = new AtomicInteger(0);\n        for (MetricSampler.Sample sample : samples) {\n            try {\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(partitionMetricSampleStoreTopic, sample.getKey(), sample.getValue());\n                RecordMetadata metadata = _producer.send(record).get();\n                log.info(\"Sent sample to topic: {}, partition: {}, offset: {}\", metadata.topic(), metadata.partition(), metadata.offset());\n                successCount.incrementAndGet();\n            } catch (InterruptedException | ExecutionException e) {\n                log.error(\"Failed to send sample\", e);\n                Thread.currentThread().interrupt();\n            }\n        }\n        return successCount;\n    }\n\n    public void close() {\n        if (_producer != null) {\n            _producer.flush();\n            _producer.close(PRODUCER_CLOSE_TIMEOUT);\n        }\n    }\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.concurrent.ListenableFuture;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush, boolean transactional) {\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = transactional;\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return send(topic, null, data);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return send(topic, null, key, data);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        ProducerRecord<K, V> record = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(record);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    private CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> producerRecord) {\n        Producer<K, V> producer = getTheProducer();\n        ListenableFuture<SendResult<K, V>> future = org.springframework.kafka.core.KafkaTemplate.send(producer, producerRecord);\n        if (autoFlush) {\n            producer.flush();\n        }\n        return future.completable();\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        return producer.partitionsFor(topic);\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        return producer.metrics();\n    }\n\n    public void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    public Producer<K, V> getTheProducer() {\n        return producerFactory.createProducer();\n    }\n\n    public Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.createProducer();\n    }\n\n    public boolean inTransaction() {\n        return transactional;\n    }\n}"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class JobPrefixFile implements AutoCloseable {\n    private final String prefix;\n    private final Path file;\n    private final FileChannel channel;\n    private FileLock lock;\n\n    private JobPrefixFile(String prefix, Path file, FileChannel channel) throws IOException {\n        this.prefix = prefix;\n        this.file = file;\n        this.channel = channel;\n        this.lock = channel.tryLock();\n        if (lock == null) {\n            throw new IOException(\"Could not lock file \" + file);\n        }\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        return create(\"jobprefix\", directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        Path tempFile = Files.createTempFile(directory, prefix, \".tmp\");\n        FileChannel channel = FileChannel.open(tempFile, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);\n        return new JobPrefixFile(prefix, tempFile, channel);\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        if (!Files.exists(file)) {\n            throw new IOException(\"File does not exist: \" + file);\n        }\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        FileLock lock = channel.tryLock();\n        if (lock == null) {\n            channel.close();\n            throw new IOException(\"Could not lock file \" + file);\n        }\n        return new JobPrefixFile(file.getFileName().toString(), file, channel);\n    }\n\n    public void delete() throws IOException {\n        release();\n        deleteIfExists(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() throws IOException {\n        if (lock != null) {\n            lock.release();\n            lock = null;\n        }\n        close(channel);\n    }\n\n    @Override\n    public void close() throws IOException {\n        release();\n    }\n\n    public static void deleteIfExists(Path file) {\n        try {\n            Files.deleteIfExists(file);\n        } catch (IOException e) {\n            // Log or handle exception as needed\n        }\n    }\n\n    public static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (Exception e) {\n                // Log or handle exception as needed\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\n\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        props.put(\"value.serializer\", \"com.example.MaintenancePlanSerializer\");\n        props.putAll(overrides);\n\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        ProducerRecord<String, MaintenancePlan> record = new ProducerRecord<>(topic, maintenancePlan.getId(), maintenancePlan);\n        _producer.send(record);\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.*;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 server using Netty framework, supporting SSL/TLS encryption and providing methods for server startup and shutdown.\n\nClass Description: BaseHttp2Server is an abstract class that serves as a foundation for building HTTP/2 servers using Netty. It handles SSL/TLS configuration, channel management, and provides basic server lifecycle methods. Concrete implementations must define their own request handlers.\n\nAttributes:\n- sslContext: [SslContext] - SSL/TLS context for secure connections\n- hasReleasedSslContext: [AtomicBoolean] - Tracks whether SSL context resources have been released\n- bootstrap: [ServerBootstrap] - Netty server bootstrap configuration\n- shouldShutDownEventLoopGroup: [boolean] - Flag indicating whether to shutdown event loop group\n- allChannels: [ChannelGroup] - Tracks all active server channels\n\nMethods:\n- BaseHttp2Server([SslContext], [EventLoopGroup]) -> [void] - Constructor that initializes the server with SSL context and optional event loop group\n- addHandlersToPipeline([SSLSession], [ChannelPipeline]) -> [void] - Abstract method to be implemented by subclasses for adding custom handlers to the pipeline\n- start([int]) -> [CompletableFuture<Integer>] - Starts the server on specified port and returns future with bound port number\n- shutdown() -> [CompletableFuture<Void>] - Gracefully shuts down the server and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.ReferenceCounted;\nimport io.netty.util.concurrent.Future;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLSession;\n\nabstract class BaseHttp2Server {\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels;\n\n    BaseHttp2Server(final SslContext sslContext, final EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n\n        if (this.sslContext instanceof ReferenceCounted) {\n            ((ReferenceCounted) this.sslContext).retain();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n\n        if (eventLoopGroup != null) {\n            this.bootstrap.group(eventLoopGroup);\n            this.shouldShutDownEventLoopGroup = false;\n        } else {\n            this.bootstrap.group(new NioEventLoopGroup(1));\n            this.shouldShutDownEventLoopGroup = true;\n        }\n\n        this.allChannels = new DefaultChannelGroup(this.bootstrap.config().group().next());\n\n        this.bootstrap.channel(ServerChannelClassUtil.getServerSocketChannelClass(this.bootstrap.config().group()));\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(final SocketChannel channel) {\n                final SslHandler sslHandler = sslContext.newHandler(channel.alloc());\n                channel.pipeline().addLast(sslHandler);\n\n                sslHandler.handshakeFuture().addListener(handshakeFuture -> {\n                    if (handshakeFuture.isSuccess()) {\n                        BaseHttp2Server.this.addHandlersToPipeline(sslHandler.engine().getSession(), channel.pipeline());\n                        BaseHttp2Server.this.allChannels.add(channel);\n                    }\n                });\n            }\n        });\n    }\n\n    protected abstract void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception;\n\n    public CompletableFuture<Integer> start(final int port) {\n        final ChannelFuture channelFuture = this.bootstrap.bind(port);\n        this.allChannels.add(channelFuture.channel());\n\n        final CompletableFuture<Integer> startFuture = new CompletableFuture<>();\n\n        channelFuture.addListener((future -> {\n            if (future.isSuccess()) {\n                startFuture.complete(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n            } else {\n                startFuture.completeExceptionally(future.cause());\n            }\n        }));\n\n        return startFuture;\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>();\n        final Future<Void> channelCloseFuture = this.allChannels.close();\n\n        if (this.shouldShutDownEventLoopGroup) {\n            channelCloseFuture.addListener(future ->\n                    BaseHttp2Server.this.bootstrap.config().group().shutdownGracefully());\n\n            this.bootstrap.config().group().terminationFuture().addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            channelCloseFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        }\n\n        return shutdownFuture.thenRun(() -> {\n            if (BaseHttp2Server.this.sslContext instanceof ReferenceCounted) {\n                if (BaseHttp2Server.this.hasReleasedSslContext.compareAndSet(false, true)) {\n                    ((ReferenceCounted) BaseHttp2Server.this.sslContext).release();\n                }\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslProvider;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GlobalEventExecutor;\n\nimport javax.net.ssl.SSLSession;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic abstract class BaseHttp2Server {\n\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    protected BaseHttp2Server(SslContext sslContext) {\n        this(sslContext, null);\n    }\n\n    protected BaseHttp2Server(SslContext sslContext, EventLoopGroup bossGroup) {\n        this.sslContext = sslContext;\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup();\n            shouldShutDownEventLoopGroup = true;\n        } else {\n            shouldShutDownEventLoopGroup = false;\n        }\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslContext != null) {\n                            p.addLast(\"ssl\", sslContext.newHandler(ch.alloc()));\n                        }\n                        addHandlersToPipeline(null, p);\n                    }\n                });\n    }\n\n    protected abstract void addHandlersToPipeline(SSLSession sslSession, ChannelPipeline pipeline);\n\n    public CompletableFuture<Integer> start(int port) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                ChannelFuture f = bootstrap.bind(port).syncUninterruptibly();\n                allChannels.add(f.channel());\n                return f.channel().localAddress().getPort();\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to start server\", e);\n            }\n        });\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        return CompletableFuture.runAsync(() -> {\n            allChannels.close().awaitUninterruptibly();\n            if (shouldShutDownEventLoopGroup) {\n                Future<?> bossGroupShutdownFuture = bootstrap.config().group().shutdownGracefully();\n                Future<?> workerGroupShutdownFuture = bootstrap.config().childGroup().shutdownGracefully();\n                bossGroupShutdownFuture.awaitUninterruptibly();\n                workerGroupShutdownFuture.awaitUninterruptibly();\n            }\n            if (sslContext != null && !hasReleasedSslContext.getAndSet(true)) {\n                sslContext.release();\n            }\n        });\n    }\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic abstract class RpcServer {\n    private static final Logger logger = LoggerFactory.getLogger(RpcServer.class);\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>();\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    private RpcRemoting rpcRemoting;\n    private Codec codec;\n\n    public RpcServer(int port, boolean manageConnection) {\n        this.addressParser = new RemotingAddressParser();\n        this.connectionManager = new DefaultServerConnectionManager(manageConnection);\n        this.rpcRemoting = new RpcRemoting(this);\n        this.codec = new Codec();\n        initialize(port);\n    }\n\n    private void initialize(int port) {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline p = ch.pipeline();\n                        p.addLast(codec.getDecoder());\n                        p.addLast(codec.getEncoder());\n                        p.addLast(new ServerHandler(rpcRemoting, connectionManager));\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n        try {\n            channelFuture = bootstrap.bind(port).sync();\n        } catch (InterruptedException e) {\n            logger.error(\"Failed to bind server to port \" + port, e);\n        }\n    }\n\n    public boolean doStart() {\n        if (channelFuture != null && channelFuture.isSuccess()) {\n            logger.info(\"Server started successfully on port {}\", channelFuture.channel().localAddress());\n            return true;\n        } else {\n            logger.error(\"Failed to start server\");\n            return false;\n        }\n    }\n\n    public boolean doStop() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        logger.info(\"Server stopped\");\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        userProcessors.put(processor.getInterest(), processor);\n    }\n\n    public Object invokeSync(Connection conn, Object request, int timeoutMillis) {\n        return rpcRemoting.invokeSync(conn, request, timeoutMillis);\n    }\n}"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes with proper stream handling and synchronization.\n\nClass Description: The ProcessRunner class is designed to execute external system processes while managing their input, output, and error streams asynchronously. It provides a clean interface for process execution with automatic stream redirection and proper thread synchronization.\n\nAttributes:\n- processRoot: File - The working directory where the external process will be executed\n\nMethods:\n- Constructor: ProcessRunner(File processRoot) -> void - Initializes the ProcessRunner with the specified working directory\n- execute: execute(ProcessBuilder pb) -> void - Executes the process configured by the ProcessBuilder, redirects error stream to output, and manages stream piping asynchronously\n- AsyncPipe (inner class): \n  - Constructor: AsyncPipe(InputStream is, OutputStream os) -> void - Creates a pipe between input and output streams with automatic closing\n  - Constructor: AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) -> void - Creates a pipe with configurable stream closing behavior\n  - run: run() -> void - The thread's main execution method that continuously reads from input stream and writes to output stream",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nclass ProcessRunner {\n    private final File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        executor.submit(new AsyncPipe(process.getInputStream(), System.out));\n        executor.submit(new AsyncPipe(process.getErrorStream(), System.err));\n\n        try {\n            int exitCode = process.waitFor();\n            System.out.println(\"Process exited with code \" + exitCode);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            executor.shutdown();\n        }\n    }\n\n    private static class AsyncPipe implements Runnable {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            byte[] buffer = new byte[1024];\n            try {\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (closeStreams) {\n                        is.close();\n                        os.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.charset.StandardCharsets;\n\nclass FileReader extends Reader {\n    private InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        try {\n            mStream = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);\n        } catch (FileNotFoundException e) {\n            if (shell != null) {\n                try {\n                    Process process = shell.execute(\"cat\", file);\n                    mStream = new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8);\n                } catch (IOException ex) {\n                    throw new FileNotFoundException(\"Failed to open file using both direct access and system command.\");\n                }\n            } else {\n                throw new FileNotFoundException(\"Failed to open file using direct access and no shell provided for fallback.\");\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mStream != null) {\n            mStream.close();\n        }\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        if (mStream == null) {\n            throw new IOException(\"Reader is not initialized.\");\n        }\n        return mStream.read(buffer, offset, count);\n    }\n}\n\nclass Shell {\n    public Process execute(String... command) throws IOException {\n        return new ProcessBuilder(command).start();\n    }\n}"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nabstract class AbstractShell {\n    // Abstract methods or common functionalities can be defined here\n}\n\nclass ProcessShell extends AbstractShell {\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput;\n    private StringBuilder mErrorOutput;\n\n    public void init(String initialCommand) throws IOException {\n        mProcess = Runtime.getRuntime().exec(initialCommand);\n        mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n        mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n        mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        mSucceedOutput = new StringBuilder();\n        mErrorOutput = new StringBuilder();\n    }\n\n    public void exec(String command) throws IOException {\n        mCommandOutputStream.writeBytes(command + \"\\n\");\n        mCommandOutputStream.flush();\n    }\n\n    public void exit() throws IOException {\n        if (mCommandOutputStream != null) {\n            mCommandOutputStream.close();\n        }\n        if (mProcess != null) {\n            mProcess.destroy();\n        }\n    }\n\n    public void exitAndWaitFor() throws IOException, InterruptedException {\n        exec(\"exit\");\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() throws InterruptedException {\n        return mProcess.waitFor();\n    }\n\n    public ProcessShell readAll() throws IOException {\n        readSucceedOutput();\n        readErrorOutput();\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() throws IOException {\n        String line;\n        while ((line = mSucceedReader.readLine()) != null) {\n            mSucceedOutput.append(line).append(\"\\n\");\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() throws IOException {\n        String line;\n        while ((line = mErrorReader.readLine()) != null) {\n            mErrorOutput.append(line).append(\"\\n\");\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}"
  },
  {
    "Task_id": 277,
    "Instruction": "Task Description: The task involves creating a Java class that utilizes ProcessBuilder to execute external processes, specifically for performance monitoring and data collection using the 'perf' tool. The class should handle process execution, stream management, and synchronization.\n\nClass Description: This class is designed to interact with the Linux 'perf' performance monitoring tool. It provides functionality to parse performance events and add JVM invocation options for performance recording. The class manages process execution, handles input/output streams, and ensures proper synchronization.\n\nAttributes:\n- sampleFrequency: [String] - The sampling frequency for performance recording\n- optFrequency: [OptionSpec<String>] - Configuration option for frequency setting\n- perfBinData: [File] - File object storing binary performance data (implied from context)\n- perfParsedData: [File] - File object for storing parsed performance data (implied from context)\n- requestedEventNames: [Collection<String>] - Collection of performance event names to monitor (implied from context)\n\nMethods:\n- parseEvents() -> [void] - Executes the 'perf script' command to parse binary performance data, redirects process output streams to a file, and waits for process completion\n- addJVMInvokeOptions(BenchmarkParams params) -> [Collection<String>] - Generates command-line options for 'perf record' with specified sampling frequency and events\n- InputStreamDrainer(InputStream, OutputStream) -> [void] - Helper class/thread for draining process streams (implied from context)",
    "Canonical_solution": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.openjdk.jmh.infra.BenchmarkParams;\nimport org.openjdk.jmh.util.Utils;\n\nprivate String sampleFrequency;\nprivate OptionSpec<String> optFrequency;\n\n@Override\nprotected void parseEvents() {\n    try (FileOutputStream fos = new FileOutputStream(perfParsedData.file())) {\n        ProcessBuilder pb = new ProcessBuilder(PerfSupport.PERF_EXEC, \"script\", \"--fields\", \"time,event,ip,sym,dso\", \"--input\", perfBinData.getAbsolutePath());\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fos);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fos);\n\n        errDrainer.start();\n        outDrainer.start();\n\n        p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n    } catch (IOException | InterruptedException ex) {\n        throw new IllegalStateException(ex);\n    }\n}\n\n@Override\npublic Collection<String> addJVMInvokeOptions(BenchmarkParams params) {\n    return Arrays.asList(PerfSupport.PERF_EXEC, \"record\", \"--freq\", String.valueOf(sampleFrequency), \"--event\", Utils.join(requestedEventNames, \",\"), \"--output\", perfBinData.getAbsolutePath());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.Collection;\nimport java.util.Collections;\n\npublic class PerfMonitor {\n    private String sampleFrequency;\n    private OptionSpec<String> optFrequency;\n    private File perfBinData;\n    private File perfParsedData;\n    private Collection<String> requestedEventNames;\n\n    public PerfMonitor(String sampleFrequency, OptionSpec<String> optFrequency, File perfBinData, File perfParsedData, Collection<String> requestedEventNames) {\n        this.sampleFrequency = sampleFrequency;\n        this.optFrequency = optFrequency;\n        this.perfBinData = perfBinData;\n        this.perfParsedData = perfParsedData;\n        this.requestedEventNames = requestedEventNames;\n    }\n\n    public void parseEvents() throws IOException, InterruptedException {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"perf\", \"script\", \"-i\", perfBinData.getAbsolutePath());\n        processBuilder.redirectOutput(perfParsedData);\n        Process process = processBuilder.start();\n        process.waitFor();\n    }\n\n    public Collection<String> addJVMInvokeOptions(BenchmarkParams params) {\n        Collection<String> options = params.getJvmArgs();\n        StringBuilder perfRecordCommand = new StringBuilder(\"perf record -F \").append(sampleFrequency);\n        for (String eventName : requestedEventNames) {\n            perfRecordCommand.append(\" -e \").append(eventName);\n        }\n        options.add(perfRecordCommand.toString());\n        return options;\n    }\n\n    private static class InputStreamDrainer extends Thread {\n        private final InputStream inputStream;\n        private final OutputStream outputStream;\n\n        public InputStreamDrainer(InputStream inputStream, OutputStream outputStream) {\n            this.inputStream = inputStream;\n            this.outputStream = outputStream;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    writer.write(line);\n                    writer.newLine();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class JavaCompilerVersion {\n    public static String getJavaCompilerVersion() {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"javac\", \"-version\");\n        processBuilder.redirectErrorStream(true);\n        try {\n            Process process = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String version = reader.readLine();\n            return version != null ? version : \"unknown\";\n        } catch (IOException e) {\n            return \"unknown\";\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getJavaCompilerVersion());\n    }\n}"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter;\n    private final Object mLock = new Object();\n    private boolean mIsActive;\n    private final boolean mIsRoot;\n    private final String mCommandEnd = \"COMMAND_END\";\n\n    public ShellStream(boolean requestRoot, OnStreamListener listener) {\n        mIsRoot = requestRoot;\n        mListener = listener;\n        mCounter = new Counter();\n        try {\n            mConnection = Runtime.getRuntime().exec(mIsRoot ? \"su\" : \"sh\");\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            mIsActive = true;\n            mStdOutputWorker = new Thread(() -> {\n                String line;\n                try {\n                    while ((line = mStdOutput.readLine()) != null) {\n                        if (line.contains(mCommandEnd)) {\n                            int exitCode = Integer.parseInt(line.split(\":\")[1]);\n                            synchronized (mLock) {\n                                mCounter.decrease();\n                                if (!isRunning()) {\n                                    mIsActive = false;\n                                }\n                            }\n                            mListener.onStreamStop(exitCode);\n                        } else {\n                            mListener.onStreamInput(line);\n                        }\n                    }\n                } catch (IOException e) {\n                    if (mIsActive) {\n                        mListener.onStreamDied();\n                    }\n                } finally {\n                    destroy();\n                }\n            });\n            mStdOutputWorker.start();\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public void execute(String command) {\n        if (mIsActive) {\n            synchronized (mLock) {\n                mCounter.encrease();\n            }\n            mListener.onStreamStart();\n            try {\n                mStdInput.writeBytes(command + \" && echo \" + mCommandEnd + \":\" + mCounter.size() + \"\\n\");\n                mStdInput.flush();\n            } catch (IOException e) {\n                mListener.onStreamDied();\n            }\n        }\n    }\n\n    public boolean waitFor() {\n        return waitFor(0);\n    }\n\n    public boolean waitFor(int timeout) {\n        return waitFor(timeout, mCounter.size());\n    }\n\n    private boolean waitFor(int timeout, int index) {\n        long startTime = System.currentTimeMillis();\n        while (index > 0) {\n            synchronized (mLock) {\n                if (mCounter.size() < index) {\n                    return true;\n                }\n                try {\n                    mLock.wait(timeout == 0 ? 0 : timeout - (System.currentTimeMillis() - startTime));\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    return false;\n                }\n                if (timeout > 0 && System.currentTimeMillis() - startTime >= timeout) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        if (mIsActive) {\n            try {\n                mStdInput.writeBytes(\"exit\\n\");\n                mStdInput.flush();\n            } catch (IOException e) {\n                // Ignore\n            }\n            mConnection.destroy();\n            mIsActive = false;\n        }\n    }\n\n    public interface OnStreamListener {\n        void onStreamStart();\n        void onStreamInput(String line);\n        void onStreamStop(int exitCode);\n        void onStreamDied();\n    }\n\n    public static class Counter {\n        private int count = 0;\n\n        public synchronized int size() {\n            return count;\n        }\n\n        public synchronized int encrease() {\n            return ++count;\n        }\n\n        public synchronized int decrease() {\n            return --count;\n        }\n\n        public synchronized void reset() {\n            count = 0;\n        }\n    }\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellCommand {\n    private Runtime rt;\n    private String[] command;\n    private String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error;\n    private int exitval;\n\n    public ShellCommand(String[] command) {\n        this(command, \"ShellCommand\");\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.command = command;\n        this.tag = tag;\n        this.rt = Runtime.getRuntime();\n        this.process = null;\n        this.stdout = null;\n        this.error = null;\n        this.exitval = -1;\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            if (waitForExit) {\n                waitForExit();\n            }\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error starting process: \" + error);\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            exitval = process.waitFor();\n            finish();\n        } catch (InterruptedException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Process interrupted: \" + error);\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n            if (process != null) {\n                process.destroy();\n            }\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error finishing process: \" + error);\n        }\n    }\n\n    public boolean checkForExit() {\n        try {\n            exitval = process.exitValue();\n            return true;\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error checking stdout availability: \" + error);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, \"Error reading stdout blocking: \" + error);\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        if (stdoutAvailable()) {\n            return readStdoutBlocking();\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SystemInfoUtil {\n\n    public static String getHostName() {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        if (os.contains(\"win\")) {\n            String hostname = System.getenv(\"COMPUTERNAME\");\n            if (hostname != null && !hostname.isEmpty()) {\n                return hostname;\n            } else {\n                return executeCommand(\"hostname\");\n            }\n        } else if (os.contains(\"nix\") || os.contains(\"nux\") || os.contains(\"aix\")) {\n            return getUname(\"-n\");\n        }\n        return \"\";\n    }\n\n    public static String getUname(String param) {\n        return executeCommand(\"uname \" + param);\n    }\n\n    private static String executeCommand(String command) {\n        StringBuilder output = new StringBuilder();\n        Process process;\n        try {\n            process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line);\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n        return output.toString().trim();\n    }\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TemporaryPorts {\n    public static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports;\n\n    public TemporaryPorts(Path lockDirectory) {\n        this.lockDirectory = lockDirectory == null ? DEFAULT_LOCK_DIRECTORY : lockDirectory;\n        if (!Files.exists(this.lockDirectory)) {\n            try {\n                Files.createDirectories(this.lockDirectory);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to create lock directory\", e);\n            }\n        }\n        this.ports = new ArrayList<>();\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) {\n        return lock(port, name);\n    }\n\n    private AllocatedPort lock(int port, String name) {\n        Path path = lockDirectory.resolve(name + \"-\" + port + \".lock\");\n        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {\n            FileLock fileLock = fileChannel.tryLock();\n            if (fileLock != null) {\n                AllocatedPort allocatedPort = new AllocatedPort(port, path, fileChannel, fileLock);\n                ports.add(allocatedPort);\n                return allocatedPort;\n            }\n        } catch (Exception e) {\n            // Ignore and return null if locking fails\n        }\n        return null;\n    }\n\n    public class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        public AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n        public void release() {\n            try {\n                if (lock != null && lock.isValid()) {\n                    lock.release();\n                }\n                if (file != null) {\n                    file.close();\n                }\n                Files.deleteIfExists(path);\n            } catch (Exception e) {\n                // Handle exception if necessary\n            } finally {\n                ports.remove(this);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\n\nimport com.google.common.collect.ImmutableMap;\n\npublic class CliDockerClient {\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    private static final Path DEFAULT_DOCKER_CLIENT = Path.of(\"/usr/bin/docker\");\n    private static final Long DOCKER_OUTPUT_TIMEOUT = 600L; // 10 minutes\n\n    public CliDockerClient(Path dockerPath, Map<String, String> envVars) {\n        this(defaultProcessBuilderFactory(dockerPath.toString(), ImmutableMap.copyOf(envVars)));\n    }\n\n    public CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n        this.processBuilderFactory = processBuilderFactory;\n    }\n\n    public static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(String dockerPath, ImmutableMap<String, String> envVars) {\n        return cmd -> {\n            ProcessBuilder pb = new ProcessBuilder(cmd);\n            pb.environment().putAll(envVars);\n            pb.redirectErrorStream(true);\n            pb.command().add(0, dockerPath);\n            return pb;\n        };\n    }\n\n    private String getStderrOutput(Process process) {\n        try (InputStream stderr = process.getErrorStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(stderr))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to read stderr\", e);\n        }\n    }\n\n    public Process docker(String... args) {\n        List<String> cmd = List.of(args);\n        ProcessBuilder pb = processBuilderFactory.apply(cmd);\n        try {\n            return pb.start();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start Docker process\", e);\n        }\n    }\n\n    public DockerInfoDetails info() {\n        Process process = docker(\"info\", \"--format\", \"{{json .}}\");\n        try {\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                String errorOutput = getStderrOutput(process);\n                throw new RuntimeException(\"Docker info command failed with exit code \" + exitCode + \": \" + errorOutput);\n            }\n            String output = readOutput(process.getInputStream());\n            return fetchInfoDetails(output);\n        } catch (InterruptedException | IOException e) {\n            throw new RuntimeException(\"Error executing Docker info command\", e);\n        }\n    }\n\n    private DockerInfoDetails fetchInfoDetails(String output) {\n        // Implement parsing logic here\n        return new DockerInfoDetails(output);\n    }\n\n    private String readOutput(InputStream inputStream) throws IOException {\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n                StringBuilder sb = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line).append(\"\\n\");\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to read process output\", e);\n            }\n        });\n\n        try {\n            return future.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.SECONDS);\n        } catch (InterruptedException | ExecutionException | java.util.concurrent.TimeoutException e) {\n            future.cancel(true);\n            throw new RuntimeException(\"Timeout reading Docker output\", e);\n        }\n    }\n\n    public static class DockerInfoDetails {\n        private final String rawOutput;\n\n        public DockerInfoDetails(String rawOutput) {\n            this.rawOutput = rawOutput;\n        }\n\n        // Implement getters and other methods as needed\n    }\n}"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Create a Java class that manages the execution of external processes, handles their input/output streams, and provides mechanisms for process termination and output handling through callbacks.\n\nClass Description: The ProcessExecutor class is responsible for executing external processes using ProcessBuilder, managing their lifecycle, and providing real-time output handling through a callback interface. It uses a thread pool for asynchronous execution and includes methods for graceful termination.\n\nAttributes:\n- mProcessBuilder: ProcessBuilder - Configures and manages the external process to be executed\n- mProcess: Process - Represents the currently running external process instance\n- mExecutor: ThreadPoolExecutor - Manages the thread used for asynchronous process execution\n\nMethods:\n- ProcessExecutor(Path scriptPath, Path libraryPath) -> void - Constructor that initializes the ProcessBuilder with the given script and library paths\n- execute(ProcessOutputHandler outputHandler) -> void - Starts the external process asynchronously and handles its output through the provided callback interface\n- terminate() -> void - Terminates the running process and shuts down the executor service\n- interface ProcessOutputHandler - Callback interface for handling process output, completion, and errors\n  - handleOutput(String output) -> void - Called for each line of output from the process\n  - handleCompletion(int exitCode) -> void - Called when the process completes with its exit code\n  - handleError(String errorMessage) -> void - Called when an error occurs during process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Path;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class ProcessExecutor {\n\n    private ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private ThreadPoolExecutor mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder();\n        mProcessBuilder.command(scriptPath.toString(), libraryPath.toString());\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor = ThreadPool.CACHED;\n        mExecutor.execute(() -> {\n            try {\n                mProcess = mProcessBuilder.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n                String line;\n                while((line = reader.readLine()) != null) {\n                    outputHandler.handleOutput(line);\n                }\n\n                int exitCode = mProcess.waitFor();\n                outputHandler.handleCompletion(exitCode);\n            } catch(InterruptedException ie) {\n                outputHandler.handleError(\"Process was interrupted\");\n            } catch(IOException ioe) {\n                outputHandler.handleError(\"IO Error during process execution\");\n            }\n        });\n    }\n\n    public void terminate() {\n        if(mProcess != null) {\n            mProcess.destroy();\n        }\n        if(mExecutor != null) {\n            mExecutor.shutdownNow();\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.nio.file.Path;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class ProcessExecutor {\n    private ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private ExecutorService mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder();\n        mProcessBuilder.command(scriptPath.toString());\n        mProcessBuilder.environment().put(\"LD_LIBRARY_PATH\", libraryPath.toString());\n        mExecutor = Executors.newSingleThreadExecutor();\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor.submit(() -> {\n            try {\n                mProcess = mProcessBuilder.start();\n                var inputStream = mProcess.getInputStream();\n                var errorStream = mProcess.getErrorStream();\n\n                Thread outputThread = new Thread(() -> {\n                    try (var reader = new java.io.BufferedReader(new java.io.InputStreamReader(inputStream))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            outputHandler.handleOutput(line);\n                        }\n                    } catch (Exception e) {\n                        outputHandler.handleError(e.getMessage());\n                    }\n                });\n\n                Thread errorThread = new Thread(() -> {\n                    try (var reader = new java.io.BufferedReader(new java.io.InputStreamReader(errorStream))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            outputHandler.handleError(line);\n                        }\n                    } catch (Exception e) {\n                        outputHandler.handleError(e.getMessage());\n                    }\n                });\n\n                outputThread.start();\n                errorThread.start();\n\n                int exitCode = mProcess.waitFor();\n                outputThread.join();\n                errorThread.join();\n                outputHandler.handleCompletion(exitCode);\n            } catch (Exception e) {\n                outputHandler.handleError(e.getMessage());\n            }\n        });\n    }\n\n    public void terminate() {\n        if (mProcess != null && mProcess.isAlive()) {\n            mProcess.destroy();\n        }\n        mExecutor.shutdownNow();\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n}"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nclass ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        new AsyncPipe(process.getInputStream(), System.out).start();\n        new AsyncPipe(process.getErrorStream(), System.err).start();\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Process exited with error code \" + exitCode);\n        }\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        ExecutorService executor = Executors.newFixedThreadPool(builders.length + 1);\n        File tempFile = File.createTempFile(\"pipe\", null, processRoot);\n        try (OutputStream currentOs = new FileOutputStream(tempFile)) {\n            executor.submit(new AsyncPipe(is, currentOs));\n        }\n\n        InputStream currentIs = new FileInputStream(tempFile);\n        for (int i = 0; i < builders.length; i++) {\n            ProcessBuilder builder = builders[i];\n            builder.directory(processRoot);\n            Process process = builder.start();\n\n            if (i < builders.length - 1) {\n                tempFile = File.createTempFile(\"pipe\", null, processRoot);\n                try (OutputStream nextOs = new FileOutputStream(tempFile)) {\n                    executor.submit(new AsyncPipe(process.getInputStream(), nextOs));\n                }\n                currentIs.close();\n                currentIs = new FileInputStream(tempFile);\n            } else {\n                executor.submit(new AsyncPipe(process.getInputStream(), os));\n                executor.submit(new AsyncPipe(process.getErrorStream(), System.err));\n            }\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new IOException(\"Process exited with error code \" + exitCode);\n            }\n        }\n        currentIs.close();\n        executor.shutdown();\n    }\n\n    static class AsyncPipe extends Thread {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int length;\n                while ((length = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, length);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (closeStreams) {\n                        is.close();\n                        os.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\nclass BenchmarkException extends Exception {\n    public BenchmarkException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass IterationResult {\n    // Define the fields and methods for IterationResult as per your requirements\n}\n\ninterface BinaryLinkServer {\n    List<IterationResult> readResults() throws IOException;\n}\n\npublic class ProcessExecutor {\n\n    public static List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr, boolean printOut, boolean printErr) throws BenchmarkException {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        pb.redirectOutput(ProcessBuilder.Redirect.to(stdOut));\n        pb.redirectError(ProcessBuilder.Redirect.to(stdErr));\n\n        try {\n            Process process = pb.start();\n\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new BenchmarkException(\"Process exited with non-zero code: \" + exitCode, null);\n            }\n\n            List<IterationResult> results = reader.readResults();\n\n            if (printOut) {\n                printFileContents(stdOut);\n            }\n            if (printErr) {\n                printFileContents(stdErr);\n            }\n\n            return results;\n\n        } catch (IOException | InterruptedException e) {\n            throw new BenchmarkException(\"Error executing process\", e);\n        }\n    }\n\n    private static void printFileContents(File file) throws IOException {\n        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Java utility class for executing shell commands with root privileges and handling process execution in Android environments.\n\nClass Description: ShellUtils is a utility class designed to execute shell commands, particularly in rooted Android environments. It provides methods for finding system binaries, executing commands with or without root privileges, and handling process input/output streams. The class includes functionality for environment variable handling and process synchronization.\n\nAttributes:\n\nBINARY_PLACES: String[] - Array of common binary directories in Android systems for command lookup\nPYTHON_HOME: String - Path to Python installation directory\nDATA_DIR: File - Application data directory\nBUSYBOX_FILE: File - Path to busybox binary\nIS_ROOTED: Boolean - Cached flag indicating whether the device is rooted\n\nMethods:\n\nexecuteNoWait: executeNoWait(Map<String, String> env, String... command) -> Process - Executes a command without waiting for completion, with optional environment variables\nsudoNoWait: sudoNoWait(Map<String, String> env, String... command) -> Process - Executes a command with root privileges (using su) without waiting for completion\nwaitFor: waitFor(String command, Process process) -> String - Waits for process completion and returns output, throws exception if process fails\nfindCommand: findCommand(String command) -> String - Searches for a command in common binary directories and returns full path if found",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\n\npublic class ShellUtils {\n    private final static String[] BINARY_PLACES = {\"/data/bin/\", \"/system/bin/\", \"/system/xbin/\", \"/sbin/\",\n            \"/data/local/xbin/\", \"/data/local/bin/\", \"/system/sd/xbin/\", \"/system/bin/failsafe/\",\n            \"/data/local/\"};\n    private final static String PYTHON_HOME = \"/data/data/fq.router2/python\";\n    public static File DATA_DIR = new File(\"/data/data/fq.router2\");\n    public static File BUSYBOX_FILE = new File(DATA_DIR, \"busybox\");\n    private static Boolean IS_ROOTED = null;\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        List<String> envp = new ArrayList<String>();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            envp.add(entry.getKey() + \"=\" + entry.getValue());\n        }\n        return Runtime.getRuntime().exec(command, envp.toArray(new String[envp.size()]));\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws Exception {\n        if (Boolean.FALSE.equals(IS_ROOTED)) {\n            return executeNoWait(env, command);\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        Process process = processBuilder\n                .command(findCommand(\"su\"))\n                .redirectErrorStream(true)\n                .start();\n        OutputStreamWriter stdin = new OutputStreamWriter(process.getOutputStream());\n        try {\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                stdin.write(entry.getKey());\n                stdin.write(\"=\");\n                stdin.write(entry.getValue());\n                stdin.write(\" \");\n            }\n            for (String c : command) {\n                stdin.write(c);\n                stdin.write(\" \");\n            }\n            stdin.write(\"\\nexit\\n\");\n        } finally {\n            stdin.close();\n        }\n        return process;\n    }\n\n    public static String waitFor(String command, Process process) throws Exception {\n        BufferedReader stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        try {\n            String line;\n            while (null != (line = stdout.readLine())) {\n                output.append(line);\n                output.append(\"\\n\");\n            }\n        } finally {\n            stdout.close();\n        }\n        process.waitFor();\n        int exitValue = process.exitValue();\n        if (0 != exitValue) {\n            throw new Exception(\"failed to execute: \" + command + \", exit value: \" + exitValue + \", output: \" + output);\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String binaryPlace : BINARY_PLACES) {\n            String path = binaryPlace + command;\n            if (new File(path).exists()) {\n                return path;\n            }\n        }\n        return command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class ShellUtils {\n    private static final String[] BINARY_PLACES = {\"/system/bin\", \"/system/xbin\", \"/vendor/bin\"};\n    private static final String PYTHON_HOME = \"/system/bin/python\";\n    private static final File DATA_DIR = new File(\"/data/data/com.example.app\");\n    private static final File BUSYBOX_FILE = new File(\"/system/xbin/busybox\");\n    private static Boolean IS_ROOTED = null;\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        if (env != null) {\n            pb.environment().putAll(env);\n        }\n        return pb.start();\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws IOException {\n        String[] fullCommand = new String[command.length + 1];\n        fullCommand[0] = \"su\";\n        System.arraycopy(command, 0, fullCommand, 1, command.length);\n        return executeNoWait(env, fullCommand);\n    }\n\n    public static String waitFor(String command, Process process) throws IOException, InterruptedException {\n        StringBuilder output = new StringBuilder();\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Command '\" + command + \"' failed with exit code \" + exitCode);\n        }\n        // Assuming we read from process.getInputStream() here for simplicity\n        // In real implementation, consider using BufferedReader\n        byte[] buffer = new byte[1024];\n        int nRead;\n        while ((nRead = process.getInputStream().read(buffer)) != -1) {\n            output.append(new String(buffer, 0, nRead));\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String dir : BINARY_PLACES) {\n            File file = new File(dir, command);\n            if (file.exists() && file.canExecute()) {\n                return file.getAbsolutePath();\n            }\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "wrong_result": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n    private static final String ROUTING_KEY = \"exampleQueue\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n    }\n\n    public void initializeConnection() throws Exception {\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Received '\" + message + \"'\");\n        };\n        channel.basicConsume(ROUTING_KEY, true, deliverCallback, consumerTag -> { });\n    }\n\n    public void close() throws Exception {\n        if (channel != null) {\n            channel.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        MessageConsumer consumer = new MessageConsumer();\n        try {\n            consumer.initializeConnection();\n            consumer.startConsuming();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a RabbitMQ message producer in Java that sends messages to a specified exchange.\n\nClass Description: A service class that handles the production and sending of messages to a RabbitMQ exchange using a fanout pattern. The class manages connection setup, message publishing, and resource cleanup.\n\nAttributes:\n- EXCHANGE_NAME: String - The name of the RabbitMQ exchange to which messages will be published.\n\nMethods:\n- produceMessage(String message) -> String - Publishes the given message to the configured RabbitMQ exchange. Returns a simple response string.\n  - Input Parameters:\n    - message: String - The message content to be published\n  - Return Type: String - A simple response string (\"response\") indicating completion",
    "Canonical_solution": "import com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.visualpathit.account.utils.RabbitMqUtil;\nimport com.rabbitmq.client.Channel;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n@Service\npublic class ProducerServiceImpl implements ProducerService {\n\n    private static final String EXCHANGE_NAME = \"messages\";\n\n    @Override\n    public String produceMessage(String message) {\n        try {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.setHost(RabbitMqUtil.getRabbitMqHost());\n            factory.setPort(Integer.parseInt(RabbitMqUtil.getRabbitMqPort()));\n            factory.setUsername(RabbitMqUtil.getRabbitMqUser());\n            factory.setPassword(RabbitMqUtil.getRabbitMqPassword());\n            Connection connection = factory.newConnection();\n            Channel channel = connection.createChannel();\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            channel.close();\n            connection.close();\n        } catch (IOException io) {\n            io.printStackTrace();\n        } catch (TimeoutException toe) {\n            toe.printStackTrace();\n        }\n        return \"response\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "wrong_result": "import com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMQProducer {\n    private static final String EXCHANGE_NAME = \"fanout_exchange\";\n\n    public String produceMessage(String message) {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        try (Connection connection = factory.newConnection();\n             Channel channel = connection.createChannel()) {\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"response\";\n    }\n}"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.support.ConnectionPoolSupport;\nimport org.apache.commons.pool2.impl.GenericObjectPool;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\npublic class LettuceRedisUtils {\n    private static final LettuceRedisUtils INSTANCE = new LettuceRedisUtils();\n    private final RedisClient REDIS_CLIENT;\n    private final GenericObjectPool<StatefulRedisConnection<String, String>> connectionPool;\n\n    private LettuceRedisUtils() {\n        RedisURI redisURI = RedisURI.Builder.redis(\"localhost\", 6379)\n                .withPassword(\"password\")\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisURI);\n        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = new GenericObjectPoolConfig<>();\n        poolConfig.setMaxTotal(10);\n        poolConfig.setMaxIdle(5);\n        poolConfig.setMinIdle(1);\n        connectionPool = ConnectionPoolSupport.createGenericObjectPool(() -> REDIS_CLIENT.connect(), poolConfig);\n    }\n\n    public static LettuceRedisUtils getInstance() {\n        return INSTANCE;\n    }\n\n    public void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<String, String> connection = null;\n        try {\n            connection = connectionPool.borrowObject();\n            RedisAsyncCommands<String, String> asyncCommands = connection.async();\n            List<CompletableFuture<?>> futures = pipelineCallBack.execute(asyncCommands);\n            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connectionPool.returnObject(connection);\n            }\n        }\n    }\n\n    @FunctionalInterface\n    public interface RedisPipelineCallBack {\n        List<CompletableFuture<?>> execute(RedisAsyncCommands<String, String> asyncCommands);\n    }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.concurrent.TimeUnit;\n\nimport org.xnio.ChannelExceptionHandler;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSinkConduit;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.WriteReadyHandler;\nimport io.undertow.server.HttpServerExchange;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = true;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel src, long position, long count) throws IOException {\n        return fileChannel.transferFrom(src, position, count);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {\n        long total = 0;\n        while (count > 0) {\n            int c = source.read(throughBuffer);\n            if (c == -1) break;\n            total += c;\n            count -= c;\n            throughBuffer.flip();\n            while (throughBuffer.hasRemaining()) {\n                fileChannel.write(throughBuffer);\n            }\n            throughBuffer.clear();\n        }\n        return total;\n    }\n\n    @Override\n    public int write(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return write(src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return write(srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n        if (writeReadyHandler != null) {\n            writeReadyHandler.writeReady();\n        }\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        resumeWrites();\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() {\n        // No-op implementation\n    }\n\n    @Override\n    public void awaitWritable(long time, TimeUnit timeUnit) {\n        // No-op implementation\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        this.writeReadyHandler = handler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n\n    @Override\n    public void setExceptionHandler(ChannelExceptionHandler<StreamSinkConduit> handler) {\n        // No-op implementation\n    }\n\n    @Override\n    public ChannelExceptionHandler<StreamSinkConduit> getExceptionHandler() {\n        return null;\n    }\n\n    @Override\n    public void terminateReads() {\n        // No-op implementation\n    }\n\n    @Override\n    public boolean isReadShutdown() {\n        return false;\n    }\n\n    @Override\n    public void resumeReads() {\n        // No-op implementation\n    }\n\n    @Override\n    public void suspendReads() {\n        // No-op implementation\n    }\n\n    @Override\n    public void wakeupReads() {\n        // No-op implementation\n    }\n\n    @Override\n    public boolean isReadResumed() {\n        return true;\n    }\n\n    @Override\n    public void awaitReadable() {\n        // No-op implementation\n    }\n\n    @Override\n    public void awaitReadable(long time, TimeUnit timeUnit) {\n        // No-op implementation\n    }\n\n    @Override\n    public XnioIoThread getReadThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setReadReadyHandler(ReadReadyHandler handler) {\n        // No-op implementation\n    }\n\n    @Override\n    public ReadReadyHandler getReadReadyHandler() {\n        return null;\n    }\n\n    @Override\n    public void truncateReads() {\n        // No-op implementation\n    }\n}"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a reliable Redis transaction handler class that manages MULTI/EXEC transactions, WATCH/UNWATCH operations, and connection handling in a Java application using Jedis client library.\n\nClass Description: The ReliableTransaction class provides a robust wrapper around Redis transactions, offering atomic operations, watch mechanisms for optimistic locking, and proper resource management. It handles the complete transaction lifecycle including initiation, command queuing, execution, and cleanup.\n\nAttributes:\n- pipelinedResponses: Queue<Response<?>> - Stores responses for queued commands in a transaction\n- connection: Connection - The Redis connection instance\n- closeConnection: boolean - Flag indicating whether to close the connection when done\n- broken: boolean - Indicates if the connection is in a broken state\n- inWatch: boolean - Tracks WATCH status\n- inMulti: boolean - Tracks MULTI status\n- commandObjects: CommandObjects - Provides command building functionality\n\nMethods:\n- ReliableTransaction(Connection, boolean, boolean, CommandObjects) -> void - Constructor that initializes the transaction handler\n- multi() -> void - Starts a Redis MULTI transaction\n- watch(String...) -> String - Watches given keys for changes (optimistic locking)\n- unwatch() -> String - Removes all watched keys\n- appendCommand(CommandObject<T>) -> Response<T> - Adds a command to the transaction queue\n- close() -> void - Cleans up and optionally closes the connection\n- clear() -> void - Clears current transaction or watch state\n- exec() -> List<Object> - Executes all queued commands atomically\n- discard() -> String - Discards all commands in the current transaction",
    "Canonical_solution": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.JedisConnectionException;\nimport redis.clients.jedis.JedisDataException;\nimport redis.clients.jedis.JedisException;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.graph.GraphCommandObjects;\nimport redis.clients.jedis.util.RedisProtocol;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ReliableTransaction {\n\n    private static final String QUEUED_STR = \"QUEUED\";\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    protected final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean doMulti, boolean closeConnection, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        GraphCommandObjects graphCommandObjects = new GraphCommandObjects(this.connection);\n        graphCommandObjects.setBaseCommandArgumentsCreator(protocolCommand -> commandObjects.commandArguments(protocolCommand));\n        if (doMulti) multi();\n    }\n\n    public void multi() {\n        connection.sendCommand(Command.MULTI);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"MULTI command failed. Received response: \" + status);\n        }\n        inMulti = true;\n    }\n\n    public String watch(final String... keys) {\n        String status = connection.executeCommand(commandObjects.watch(keys));\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        connection.sendCommand(Command.UNWATCH);\n        String status = connection.getStatusCodeReply();\n        inWatch = false;\n        return status;\n    }\n\n    protected <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        connection.sendCommand(commandObject.getArguments());\n        String status = connection.getStatusCodeReply();\n        if (!QUEUED_STR.equals(status)) {\n            throw new JedisException(status);\n        }\n        Response<T> response = new Response<>(commandObject.getBuilder());\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        try {\n            clear();\n        } finally {\n            if (closeConnection) {\n                connection.close();\n            }\n        }\n    }\n\n    public void clear() {\n        if (broken) return;\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) throw new IllegalStateException(\"EXEC without MULTI\");\n\n        try {\n            connection.sendCommand(Command.EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                pipelinedResponses.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size());\n            for (Object o : unformatted) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    response.set(o);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            connection.sendCommand(Command.DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.CommandObjects;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\nclass ReliableTransaction {\n    private Queue<Response<?>> pipelinedResponses;\n    private Connection connection;\n    private boolean closeConnection;\n    private boolean broken;\n    private boolean inWatch;\n    private boolean inMulti;\n    private CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean closeConnection, boolean broken, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.broken = broken;\n        this.commandObjects = commandObjects;\n        this.pipelinedResponses = new LinkedList<>();\n    }\n\n    public void multi() {\n        if (!inMulti) {\n            connection.sendCommand(commandObjects.multi());\n            inMulti = true;\n        }\n    }\n\n    public String watch(String... keys) {\n        if (!inWatch) {\n            connection.sendCommand(commandObjects.watch(keys));\n            inWatch = true;\n        }\n        return \"OK\";\n    }\n\n    public String unwatch() {\n        if (inWatch) {\n            connection.sendCommand(commandObjects.unwatch());\n            inWatch = false;\n        }\n        return \"OK\";\n    }\n\n    public <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        if (inMulti) {\n            Response<T> response = connection.getPipeline().getResponse();\n            pipelinedResponses.add(response);\n            connection.sendCommand(commandObject);\n            return response;\n        } else {\n            throw new IllegalStateException(\"Not in a transaction\");\n        }\n    }\n\n    public void close() {\n        if (closeConnection) {\n            connection.close();\n        }\n    }\n\n    public void clear() {\n        if (inWatch) {\n            unwatch();\n        }\n        if (inMulti) {\n            discard();\n        }\n    }\n\n    public List<Object> exec() {\n        if (inMulti) {\n            connection.sendCommand(commandObjects.exec());\n            List<Object> results = connection.getPipeline().syncAndReturnAll();\n            inMulti = false;\n            return results;\n        } else {\n            throw new IllegalStateException(\"Not in a transaction\");\n        }\n    }\n\n    public String discard() {\n        if (inMulti) {\n            connection.sendCommand(commandObjects.discard());\n            inMulti = false;\n            return \"OK\";\n        } else {\n            throw new IllegalStateException(\"Not in a transaction\");\n        }\n    }\n}"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Implement a Redis-based registry class for node registration and subscription in a distributed system, using Java with Jedis client library.\n\nClass Description: RedisRegistry is a class that provides node registration and subscription capabilities using Redis as the backend storage. It maintains connections to Redis servers, handles node registration, and manages subscription to node changes.\n\nAttributes:\n- jedisPools: ConcurrentHashMap<String, JedisPool> - A thread-safe map storing JedisPool instances for different Redis server addresses\n- clusterName: String - The name of the current cluster\n- replicate: boolean - Flag indicating whether operations should be replicated to all Redis servers\n- notifiers: ConcurrentMap<String, Notifier> - A thread-safe map storing Notifier instances for different node paths\n\nMethods:\n- RedisRegistry(AppContext appContext) - Constructor - Initializes the registry with configuration from AppContext\n  Input: appContext: AppContext - The application context containing configuration\n  Output: None\n\n- doRegister(Node node) - protected - Registers a node in Redis\n  Input: node: Node - The node to be registered\n  Output: None (throws NodeRegistryException on failure)\n\n- doSubscribe(Node node, NotifyListener listener) - protected - Subscribes to node changes\n  Input: \n    node: Node - The node that wants to subscribe\n    listener: NotifyListener - The listener to be notified of changes\n  Output: None\n\nNested Classes:\n- NotifySub extends JedisPubSub - Handles Redis pub/sub messages\n  Methods:\n    onMessage(String key, String msg) - Processes incoming messages\n      Input:\n        key: String - The channel/key of the message\n        msg: String - The message content\n      Output: None\n\n- Notifier extends Thread - Manages subscription thread\n  Methods:\n    run() - Main thread execution for subscription\n      Input: None\n      Output: None\n    shutdown() - Stops the subscription thread\n      Input: None\n      Output: None",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.cluster.Config;\nimport com.github.ltsopensource.core.cluster.Node;\nimport com.github.ltsopensource.core.cluster.NodeType;\nimport com.github.ltsopensource.core.commons.utils.CollectionUtils;\nimport com.github.ltsopensource.core.constant.Constants;\nimport com.github.ltsopensource.core.exception.NodeRegistryException;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport com.github.ltsopensource.core.registry.NotifyEvent;\nimport com.github.ltsopensource.core.registry.NotifyListener;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class RedisRegistry {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisRegistry.class);\n    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();\n    private String clusterName;\n    private boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();\n\n    public RedisRegistry(AppContext appContext) {\n        Config config = appContext.getConfig();\n        this.clusterName = config.getClusterName();\n\n        String address = NodeRegistryUtils.getRealRegistryAddress(config.getRegistryAddress());\n        String[] addrs = address.split(\",\");\n        for (String addr : addrs) {\n            int i = addr.indexOf(':');\n            String host = addr.substring(0, i);\n            int port = Integer.parseInt(addr.substring(i + 1));\n            this.jedisPools.put(addr, new JedisPool(new JedisPoolConfig(), host, port, Constants.DEFAULT_TIMEOUT));\n        }\n    }\n\n    protected void doRegister(Node node) {\n        String key = NodeRegistryUtils.getNodeTypePath(clusterName, node.getNodeType());\n        boolean success = false;\n        NodeRegistryException exception = null;\n        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n            JedisPool jedisPool = entry.getValue();\n            try {\n                Jedis jedis = jedisPool.getResource();\n                try {\n                    jedis.hset(key, node.toFullString(), String.valueOf(SystemClock.now() + Constants.DEFAULT_SESSION_TIMEOUT));\n                    jedis.publish(key, Constants.REGISTER);\n                    success = true;\n                    if (!replicate) {\n                        break;\n                    }\n                } finally {\n                    jedis.close();\n                }\n            } catch (Throwable t) {\n                exception = new NodeRegistryException(\"Failed to register node to redis registry. registry: \" + entry.getKey() + \", node: \" + node + \", cause: \" + t.getMessage(), t);\n            }\n        }\n        if (exception != null && !success) {\n            throw exception;\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        List<NodeType> listenNodeTypes = node.getListenNodeTypes();\n        if (CollectionUtils.isEmpty(listenNodeTypes)) {\n            return;\n        }\n        for (NodeType listenNodeType : listenNodeTypes) {\n            String listenNodePath = NodeRegistryUtils.getNodeTypePath(clusterName, listenNodeType);\n            Notifier notifier = notifiers.get(listenNodePath);\n            if (notifier == null) {\n                Notifier newNotifier = new Notifier(listenNodePath);\n                notifiers.putIfAbsent(listenNodePath, newNotifier);\n                notifier = notifiers.get(listenNodePath);\n                if (notifier == newNotifier) {\n                    notifier.start();\n                }\n            }\n        }\n    }\n\n    private class NotifySub extends JedisPubSub {\n        private final JedisPool jedisPool;\n\n        public NotifySub(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) {\n                try {\n                    Jedis jedis = jedisPool.getResource();\n                    try {\n                        doNotify(jedis, key);\n                    } finally {\n                        jedis.close();\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String listenNodePath;\n        private volatile Jedis jedis;\n        private volatile boolean running = true;\n\n        public Notifier(String listenNodePath) {\n            super.setDaemon(true);\n            super.setName(\"LTSRedisSubscribe\");\n            this.listenNodePath = listenNodePath;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (running) {\n                    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                        try {\n                            JedisPool jedisPool = entry.getValue();\n                            jedis = jedisPool.getResource();\n                            try {\n                                jedis.subscribe(new NotifySub(jedisPool), listenNodePath);\n                                break;\n                            } finally {\n                                jedis.close();\n                            }\n                        } catch (Throwable t) {\n                            LOGGER.warn(\"Failed to subscribe node from redis registry. registry: \" + entry.getKey(), t);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                LOGGER.error(t.getMessage(), t);\n            }\n        }\n\n        public void shutdown() {\n            try {\n                running = false;\n                jedis.disconnect();\n            } catch (Throwable t) {\n                LOGGER.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class RedisRegistry {\n    private final ConcurrentHashMap<String, JedisPool> jedisPools;\n    private final String clusterName;\n    private final boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers;\n\n    public RedisRegistry(AppContext appContext) {\n        this.jedisPools = new ConcurrentHashMap<>();\n        this.clusterName = appContext.getClusterName();\n        this.replicate = appContext.isReplicate();\n        this.notifiers = new ConcurrentHashMap<>();\n        // Initialize jedisPools based on appContext configuration\n    }\n\n    protected void doRegister(Node node) throws NodeRegistryException {\n        try (Jedis jedis = jedisPools.get(clusterName).getResource()) {\n            jedis.set(node.getPath(), node.getData());\n            if (replicate) {\n                // Logic to replicate to other servers if needed\n            }\n        } catch (Exception e) {\n            throw new NodeRegistryException(\"Failed to register node\", e);\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        Notifier notifier = notifiers.computeIfAbsent(node.getPath(), k -> new Notifier(node.getPath(), listener));\n        notifier.start();\n    }\n\n    private class NotifySub extends JedisPubSub {\n        @Override\n        public void onMessage(String key, String msg) {\n            // Process incoming messages\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String path;\n        private final NotifyListener listener;\n        private volatile boolean running = true;\n\n        public Notifier(String path, NotifyListener listener) {\n            this.path = path;\n            this.listener = listener;\n        }\n\n        @Override\n        public void run() {\n            try (Jedis jedis = jedisPools.get(clusterName).getResource()) {\n                NotifySub sub = new NotifySub();\n                jedis.subscribe(sub, path);\n            } finally {\n                shutdown();\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n            interrupt();\n        }\n    }\n}"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, management, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Lettuce client. It provides methods to establish a connection with configurable timeout options, retrieve the active connection, and properly close the connection when no longer needed.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte array codec\n\nMethods:\n- setupConnection(String host, int port) -> void - Initializes the Redis client and establishes a connection to the specified Redis server with a 10-second timeout configuration\n- closeConnection() -> void - Properly closes the active connection and shuts down the Redis client\n- getConnection() -> StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection instance",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        redisClient = RedisClient.create(RedisURI.create(host, port));\n        redisClient.setOptions(ClientOptions.builder()\n                .timeoutOptions(TimeoutOptions.builder().fixedTimeout(Duration.ofSeconds(10)).build()).build());\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown(0, 0, TimeUnit.SECONDS);\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        RedisURI redisURI = RedisURI.builder()\n                .withHost(host)\n                .withPort(port)\n                .withTimeout(java.time.Duration.ofSeconds(10))\n                .build();\n        redisClient = RedisClient.create(redisURI);\n        connection = redisClient.connect();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Implement a Redis connection class in Java that handles socket communication, authentication, and basic Redis operations while managing connection state and resources.\n\nClass Description: The Connection class represents a Redis client connection that manages socket communication with a Redis server. It handles connection establishment, command sending, response reading, and connection cleanup. The class implements Closeable for proper resource management.\n\nAttributes:\n- socketFactory: JedisSocketFactory - Factory for creating socket connections to Redis\n- socket: Socket - The underlying socket connection to Redis\n- outputStream: RedisOutputStream - Output stream for sending commands to Redis\n- inputStream: RedisInputStream - Input stream for reading responses from Redis\n- soTimeout: int - Socket timeout setting\n- broken: boolean - Flag indicating if the connection is in a broken state\n- currentCredentials: AtomicReference<RedisCredentials> - Current authentication credentials\n- authXManager: AuthXManager - Manager for authentication operations\n\nMethods:\n- Connection(JedisSocketFactory) -> void - Constructor that initializes with a socket factory\n- connect() -> void - Establishes connection to Redis server\n- disconnect() -> void - Closes the connection to Redis server\n- isConnected() -> boolean - Checks if connection is active\n- isBroken() -> boolean - Checks if connection is in broken state\n- setBroken() -> void - Marks connection as broken\n- sendCommand(ProtocolCommand, byte[]...) -> void - Sends a Redis command with arguments\n- getOne() -> Object - Reads and returns a single response from Redis\n- flush() -> void - Flushes the output stream\n- readProtocolWithCheckingBroken() -> Object - Reads protocol response while checking connection state\n- close() -> void - Implements Closeable interface to disconnect (alias for disconnect)",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Protocol.Keyword;\nimport redis.clients.jedis.args.Rawable;\nimport redis.clients.jedis.authentication.AuthXManager;\nimport redis.clients.jedis.commands.ProtocolCommand;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\nimport redis.clients.jedis.util.RedisInputStream;\nimport redis.clients.jedis.util.RedisOutputStream;\n\npublic class Connection implements Closeable {\n\n  private final JedisSocketFactory socketFactory;\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n  private int soTimeout = 0;\n  private boolean broken = false;\n  private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>(null);\n  private AuthXManager authXManager;\n\n  public Connection(final JedisSocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n  }\n\n  public void connect() throws JedisConnectionException {\n    if (!isConnected()) {\n      try {\n        socket = socketFactory.createSocket();\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n      } catch (JedisConnectionException jce) {\n        setBroken();\n        throw jce;\n      } catch (IOException ioe) {\n        setBroken();\n        throw new JedisConnectionException(\"Failed to create input/output stream\", ioe);\n      } finally {\n        if (broken) {\n          IOUtils.closeQuietly(socket);\n        }\n      }\n    }\n  }\n\n  public void disconnect() {\n    if (isConnected()) {\n      try {\n        outputStream.flush();\n        socket.close();\n      } catch (IOException ex) {\n        throw new JedisConnectionException(ex);\n      } finally {\n        IOUtils.closeQuietly(socket);\n        setBroken();\n      }\n    }\n  }\n\n  public boolean isConnected() {\n    return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()\n        && !socket.isInputShutdown() && !socket.isOutputShutdown();\n  }\n\n  public boolean isBroken() {\n    return broken;\n  }\n\n  public void setBroken() {\n    broken = true;\n  }\n\n  public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {\n    try {\n      connect();\n      Protocol.sendCommand(outputStream, new CommandArguments(cmd).addObjects((Object[]) args));\n    } catch (JedisConnectionException ex) {\n      setBroken();\n      throw ex;\n    }\n  }\n\n  public Object getOne() {\n    flush();\n    return readProtocolWithCheckingBroken();\n  }\n\n  protected void flush() {\n    try {\n      outputStream.flush();\n    } catch (IOException ex) {\n      setBroken();\n      throw new JedisConnectionException(ex);\n    }\n  }\n\n  protected Object readProtocolWithCheckingBroken() {\n    if (broken) {\n      throw new JedisConnectionException(\"Attempting to read from a broken connection.\");\n    }\n    try {\n      return Protocol.read(inputStream);\n    } catch (JedisConnectionException exc) {\n      broken = true;\n      throw exc;\n    }\n  }\n\n  @Override\n  public void close() {\n    disconnect();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class Connection implements Closeable {\n    private JedisSocketFactory socketFactory;\n    private Socket socket;\n    private RedisOutputStream outputStream;\n    private RedisInputStream inputStream;\n    private int soTimeout;\n    private boolean broken;\n    private AtomicReference<RedisCredentials> currentCredentials;\n    private AuthXManager authXManager;\n\n    public Connection(JedisSocketFactory socketFactory) {\n        this.socketFactory = socketFactory;\n        this.broken = false;\n        this.currentCredentials = new AtomicReference<>();\n    }\n\n    public void connect() throws IOException {\n        this.socket = socketFactory.createSocket();\n        this.outputStream = new RedisOutputStream(socket.getOutputStream());\n        this.inputStream = new RedisInputStream(socket.getInputStream());\n        this.socket.setSoTimeout(soTimeout);\n    }\n\n    public void disconnect() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            setBroken();\n        } finally {\n            socket = null;\n            outputStream = null;\n            inputStream = null;\n        }\n    }\n\n    public boolean isConnected() {\n        return socket != null && socket.isConnected();\n    }\n\n    public boolean isBroken() {\n        return broken;\n    }\n\n    public void setBroken() {\n        this.broken = true;\n    }\n\n    public void sendCommand(ProtocolCommand command, byte[]... args) throws IOException {\n        outputStream.write(command.getRaw(), 0, command.getRaw().length);\n        for (byte[] arg : args) {\n            outputStream.write(ASTERISK_BYTE);\n            outputStream.writeIntCrLf(arg.length);\n            outputStream.write(DOLLAR_BYTE);\n            outputStream.writeIntCrLf(arg.length);\n            outputStream.write(arg);\n            outputStream.writeCrLf();\n        }\n        outputStream.flush();\n    }\n\n    public Object getOne() throws IOException {\n        return readProtocolWithCheckingBroken();\n    }\n\n    public void flush() throws IOException {\n        outputStream.flush();\n    }\n\n    private Object readProtocolWithCheckingBroken() throws IOException {\n        try {\n            return Protocol.read(inputStream);\n        } catch (IOException e) {\n            setBroken();\n            throw e;\n        }\n    }\n\n    @Override\n    public void close() {\n        disconnect();\n    }\n}"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.support.TokenBasedRedisCredentialsProvider;\n\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) {\n        this.credentialsUser1 = new TokenBasedRedisCredentialsProvider(authority, scopes, user1ClientId, user1Secret);\n        this.credentialsUser2 = new TokenBasedRedisCredentialsProvider(authority, scopes, user2ClientId, user2Secret);\n        this.redisClient = RedisClient.create(RedisURI.builder().withHost(redisUri).build());\n        this.redisClusterClient = RedisClusterClient.create(RedisURI.builder().withHost(redisUri).build());\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(credentialsUser1);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        return redisClient.connect(credentialsUser2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return redisClusterClient.connect();\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel channel, Path path, TranslogHeader header) throws IOException {\n        super(channel, path, header);\n        this.checkpoint = checkpoint;\n        this.length = channel.size();\n        this.totalOperations = header.getTotalOperations();\n    }\n\n    public static TranslogReader open(FileChannel channel, Path path, Checkpoint checkpoint, String translogUUID) throws IOException {\n        TranslogHeader.readHeader(channel, translogUUID);\n        return new TranslogReader(checkpoint, channel, path, new TranslogHeader(translogUUID, checkpoint.getGeneration(), checkpoint.getSeqNo(), checkpoint.getPrimaryTerm()));\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            try (FileChannel channel = channelFactory.open(path)) {\n                return new TranslogReader(new Checkpoint(checkpoint.getGeneration(), aboveSeqNo, checkpoint.getPrimaryTerm()), channel, path, new TranslogHeader(checkpoint.getTranslogUUID(), checkpoint.getGeneration(), aboveSeqNo, checkpoint.getPrimaryTerm()));\n            }\n        } else {\n            throw new AlreadyClosedException(\"TranslogReader already closed\");\n        }\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) throws IOException {\n        ensureOpen();\n        if (position < 0 || position + buffer.remaining() > length) {\n            throw new IndexOutOfBoundsException(\"position=\" + position + \" len=\" + buffer.remaining() + \" but length=\" + length);\n        }\n        channel.position(position);\n        while (buffer.hasRemaining()) {\n            int bytesRead = channel.read(buffer);\n            if (bytesRead == -1) {\n                throw new EOFException(\"Read past EOF for [\" + path + \"]\");\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() throws AlreadyClosedException {\n        if (isClosed()) {\n            throw new AlreadyClosedException(\"TranslogReader already closed\");\n        }\n    }\n}"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.time.Duration;\nimport java.time.Instant;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\n\nclass ClusterCommandExecutor {\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public <T> T broadcastCommand(CommandObject<T> commandObject) {\n        return provider.broadcast(commandObject);\n    }\n\n    public <T> T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        int attemptsLeft = maxAttempts;\n        int consecutiveConnectionFailures = 0;\n        Instant doneDeadline = Instant.now().plus(maxTotalRetriesDuration);\n\n        while (attemptsLeft > 0) {\n            try (Connection connection = toReplica ? provider.getConnectionToReplica(commandObject.getKey()) : provider.getConnection(commandObject.getKey())) {\n                return execute(connection, commandObject);\n            } catch (ConnectionException e) {\n                log.warning(\"Connection problem: \" + e.getMessage());\n                if (!handleConnectionProblem(attemptsLeft, consecutiveConnectionFailures, doneDeadline)) {\n                    throw e;\n                }\n                consecutiveConnectionFailures++;\n            } catch (Exception e) {\n                log.severe(\"Command execution failed: \" + e.getMessage());\n                throw new RuntimeException(\"Command execution failed\", e);\n            }\n            attemptsLeft--;\n        }\n        throw new RuntimeException(\"Max attempts reached\");\n    }\n\n    private <T> T execute(Connection connection, CommandObject<T> commandObject) {\n        return connection.execute(commandObject);\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        if (Instant.now().isAfter(doneDeadline)) {\n            return false;\n        }\n        long sleepMillis = getBackoffSleepMillis(attemptsLeft, doneDeadline);\n        sleep(sleepMillis);\n        provider.renewSlotCache();\n        return true;\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        long remainingTime = Duration.between(Instant.now(), deadline).toMillis();\n        long baseSleep = Math.min(100 * (maxAttempts - attemptsLeft + 1), remainingTime);\n        return Math.min(baseSleep, remainingTime);\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Thread interrupted\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport io.protostuff.LinkedBuffer;\nimport io.protostuff.ProtostuffIOUtil;\nimport io.protostuff.runtime.RuntimeSchema;\n\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private final RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        this.jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return getSeckill(seckillId, jedis);\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        byte[] bytes = jedis.get(getSeckillRedisKey(seckillId).getBytes());\n        if (bytes != null) {\n            Seckill seckill = schema.newMessage();\n            ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n            return seckill;\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            String lockKey = \"lock:\" + getSeckillRedisKey(seckillId);\n            boolean acquiredLock = jedis.setnx(lockKey, \"locked\").equals(1L);\n            try {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill == null) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    if (seckill != null) {\n                        putSeckill(seckill, jedis);\n                    }\n                }\n                return seckill;\n            } finally {\n                if (acquiredLock) {\n                    jedis.del(lockKey);\n                }\n            }\n        }\n    }\n\n    public String putSeckill(Seckill seckill) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return putSeckill(seckill, jedis);\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n        int timeout = 60 * 60; // 1 hour\n        return jedis.setex(getSeckillRedisKey(seckill.getSeckillId()).getBytes(), timeout, bytes);\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import javax.net.ssl.*;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass DefaultJedisSocketFactory {\n    private HostAndPort hostAndPort;\n    private int connectionTimeout = 2000;\n    private int socketTimeout = 2000;\n    private boolean ssl = false;\n    private SSLSocketFactory sslSocketFactory;\n    private SSLParameters sslParameters;\n    private HostnameVerifier hostnameVerifier;\n    private HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this.hostAndPort = new HostAndPort(\"localhost\", 6379);\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this.hostAndPort = config.getHostAndPort();\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n        List<HostAndPort> hosts = new ArrayList<>();\n        hosts.add(hostAndPort);\n        if (hostAndPortMapper != null) {\n            hosts.addAll(hostAndPortMapper.getHostAndPorts(hostAndPort));\n        }\n        for (HostAndPort hp : hosts) {\n            try {\n                return createSocket(hp);\n            } catch (Exception e) {\n                // Log or handle exception as needed\n            }\n        }\n        throw new Exception(\"Failed to connect to any host\");\n    }\n\n    public Socket createSocket() throws Exception {\n        return createSocket(hostAndPort);\n    }\n\n    private Socket createSocket(HostAndPort hostAndPort) throws Exception {\n        Socket socket;\n        if (ssl) {\n            SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(hostAndPort.getHost(), hostAndPort.getPort());\n            sslSocket.setSoTimeout(socketTimeout);\n            sslSocket.setSSLParameters(sslParameters);\n            sslSocket.startHandshake();\n            if (!hostnameVerifier.verify(hostAndPort.getHost(), sslSocket.getSession())) {\n                throw new Exception(\"Hostname verification failed\");\n            }\n            socket = sslSocket;\n        } else {\n            socket = new Socket(hostAndPort.getHost(), hostAndPort.getPort());\n            socket.setSoTimeout(socketTimeout);\n        }\n        socket.connect(hostAndPort.toSocketAddress(), connectionTimeout);\n        return socket;\n    }\n\n    public HostAndPort getSocketHostAndPort() {\n        if (hostAndPortMapper != null) {\n            return hostAndPortMapper.getHostAndPort(hostAndPort);\n        }\n        return hostAndPort;\n    }\n}\n\nclass HostAndPort {\n    private final String host;\n    private final int port;\n\n    public HostAndPort(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public java.net.SocketAddress toSocketAddress() {\n        return new java.net.InetSocketAddress(host, port);\n    }\n}\n\ninterface HostAndPortMapper {\n    HostAndPort getHostAndPort(HostAndPort original);\n\n    List<HostAndPort> getHostAndPorts(HostAndPort original);\n}\n\nclass JedisClientConfig {\n    private HostAndPort hostAndPort;\n    private int connectionTimeout;\n    private int socketTimeout;\n    private boolean ssl;\n    private SSLSocketFactory sslSocketFactory;\n    private SSLParameters sslParameters;\n    private HostnameVerifier hostnameVerifier;\n    private HostAndPortMapper hostAndPortMapper;\n\n    public JedisClientConfig() {\n        this.hostAndPort = new HostAndPort(\"localhost\", 6379);\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        this.sslParameters = new SSLParameters();\n        this.hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();\n        this.hostAndPortMapper = null;\n    }\n\n    public HostAndPort getHostAndPort() {\n        return hostAndPort;\n    }\n\n    public int getConnectionTimeout() {\n        return connectionTimeout;\n    }\n\n    public int getSocketTimeout() {\n        return socketTimeout;\n    }\n\n    public boolean isSsl() {\n        return ssl;\n    }\n\n    public SSLSocketFactory getSslSocketFactory() {\n        return sslSocketFactory;\n    }\n\n    public SSLParameters getSslParameters() {\n        return sslParameters;\n    }\n\n    public HostnameVerifier getHostnameVerifier() {\n        return hostnameVerifier;\n    }\n\n    public HostAndPortMapper getHostAndPortMapper() {\n        return hostAndPortMapper;\n    }\n\n    public JedisClientConfig setHostAndPort(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        return this;\n    }\n\n    public JedisClientConfig setConnectionTimeout(int connectionTimeout) {\n        this.connectionTimeout = connectionTimeout;\n        return this;\n    }\n\n    public JedisClientConfig setSocketTimeout(int socketTimeout) {\n        this.socketTimeout = socketTimeout;\n        return this;\n    }\n\n    public JedisClientConfig setSsl(boolean ssl) {\n        this.ssl = ssl;\n        return this;\n    }\n\n    public JedisClientConfig setSslSocketFactory(SSLSocketFactory sslSocketFactory) {\n        this.sslSocketFactory = sslSocketFactory;\n        return this;\n    }\n\n    public JedisClientConfig setSslParameters(SSLParameters sslParameters) {\n        this.sslParameters = sslParameters;\n        return this;\n    }\n\n    public JedisClientConfig setHostnameVerifier(HostnameVerifier hostnameVerifier) {\n        this.hostnameVerifier = hostnameVerifier;\n        return this;\n    }\n\n    public JedisClientConfig setHostAndPortMapper(HostAndPortMapper hostAndPortMapper) {\n        this.hostAndPortMapper = hostAndPortMapper;\n        return this;\n    }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a Java class that utilizes Java NIO's FileChannel to map a file into memory for read-only access, providing methods to access the mapped memory address and file size, and properly closing the channel when done.\n\nClass Description: The FileChannelProcessor class provides functionality to open a file using FileChannel, map it into memory in read-only mode, and expose the memory address and file size. It ensures proper resource cleanup by implementing a close method.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedAddress: long - The memory address where the file is mapped\nfileSize: long - The size of the mapped file in bytes\n\nMethods:\nFileChannelProcessor: [Constructor](String filePath) throws IOException - Initializes the FileChannel, maps the file into memory in read-only mode, and stores the memory address and file size\ngetMappedAddress: () -> long - Returns the memory address where the file is mapped\ngetFileSize: () -> long - Returns the size of the mapped file\nclose: () throws IOException - Closes the FileChannel to release system resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mappedAddress = fileChannel.map(MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedByteBuffer;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        RandomAccessFile randomAccessFile = new RandomAccessFile(filePath, \"r\");\n        this.fileChannel = randomAccessFile.getChannel();\n        this.fileSize = fileChannel.size();\n        this.mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n    }\n\n    public long getMappedAddress() {\n        return mappedByteBuffer.address();\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a Java class for interacting with Redis using the Lettuce client, including connection management and data operations.\n\nClass Description: The RedisInteraction class provides functionality to establish and manage a connection to a Redis server, perform bulk data operations, and clean up resources. It uses the Lettuce client library for Redis interactions.\n\nAttributes:\n- client: RedisClient - The Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active connection to the Redis server\n\nMethods:\n- initializeConnection() -> void - Initializes the Redis client and establishes a connection to the Redis server. Also clears all existing data in Redis.\n- closeConnection() -> void - Closes the Redis connection and shuts down the client to release resources.\n- createRedisPublisher(long elements) -> Publisher<String> - Creates and returns a Publisher that streams Redis keys. Populates Redis with test data (number of elements specified by input parameter) before creating the publisher. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ScanStream;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public void closeConnection() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.flushall();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < elements; i++) {\n            String element = \"RedisInteraction-\" + i;\n            map.put(element, element);\n\n            if (i % 1000 - 2020 == 0 && !map.isEmpty()) {\n                sync.mset(map);\n                map.clear();\n            }\n        }\n\n        if (!map.isEmpty()) {\n            sync.mset(map);\n            map.clear();\n        }\n\n        return ScanStream.scan(connection.reactive());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport org.reactivestreams.Publisher;\n\nimport java.util.stream.LongStream;\n\npublic class RedisInteraction {\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(\"redis://localhost\");\n        connection = client.connect();\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.flushall();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n        RedisCommands<String, String> syncCommands = connection.sync();\n        LongStream.range(0, elements).forEach(i -> syncCommands.set(\"key:\" + i, \"value:\" + i));\n        return connection.reactive().keys(\"*\");\n    }\n}"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "@Configuration\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new GenericFastJsonRedisSerializer());\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        config.useSingleServer()\n              .setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort())\n              .setPassword(redisProperties.getPassword());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (o, method, params) -> {\n            StringBuilder sb = new StringBuilder();\n            sb.append(method.getName());\n            for (Object param : params) {\n                sb.append(param.toString());\n            }\n            return DigestUtils.sha256Hex(sb.toString());\n        };\n    }\n}"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Create a Java class that establishes and manages connections to a Redis master-replica setup using Lettuce client, with support for read operations from replicas and secure connection handling.\n\nClass Description: RedisMasterReplicaConnector is a utility class that provides methods to create, manage, and close connections to a Redis master-replica cluster. It supports read scaling by allowing read operations from replicas and includes secure connection handling with custom DNS resolution.\n\nAttributes:\n- clientResources: ClientResources - The Lettuce client resources configuration including custom socket address resolver\n\nMethods:\n- RedisMasterReplicaConnector(ClientResources) -> void - Constructor that initializes client resources with custom DNS resolution\n- createConnection(String host, String masterId) -> StatefulRedisMasterReplicaConnection<String, String> - Creates a connection to Redis master-replica setup with specified host and master ID\n- closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) -> void - Properly closes the Redis connection and shuts down the client\n- performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) -> void - Demonstrates basic Redis operations (set and get) using the established connection",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisMasterReplicaConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisClient client = RedisClient.create(clientResources);\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":26379?sentinelMasterId=\" + masterId);\n        redisURI.setVerifyPeer(false);\n        \n        StatefulRedisMasterReplicaConnection<String, String> connection = \n            MasterReplica.connect(client, StringCodec.UTF8, redisURI);\n        connection.setReadFrom(ReadFrom.REPLICA);\n        \n        return connection;\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null) {\n            connection.close();\n            FastShutdown.shutdown(connection.getRedisClient());\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        connection.sync().set(key, value);\n        connection.sync().get(key);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisMasterReplicaConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DefaultClientResources;\n\nimport java.net.SocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class RedisMasterReplicaConnector {\n\n    private ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources;\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisClient redisClient = RedisClient.create(clientResources, RedisURI.Builder.redis(host).build());\n        return redisClient.connectToMasterReplica();\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null) {\n            connection.close();\n            clientResources.shutdown();\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        // Write operation on master\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.set(key, value);\n\n        // Read operation on replica\n        String result = connection.getStatefulConnection().async().get(key).get();\n        System.out.println(\"Retrieved value: \" + result);\n    }\n}"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a Java class that implements Redis client functionality using Jedis for basic key-value operations, hash operations, and key expiration management.\n\nClass Description: JedisClientSingle is a Redis client wrapper class that provides simplified access to common Redis operations using connection pooling. It handles connection management, authentication, and resource cleanup automatically.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- password: String - The password for Redis authentication (optional)\n- port: int - The port number of the Redis server\n- host: String - The host address of the Redis server\n- logger: Logger - SLF4J logger instance for logging operations\n\nMethods:\n- getResource() -> Jedis - Internal method to get a Jedis instance from the pool and authenticate if needed\n- get(String key) -> String - Retrieves the value associated with the given key\n- set(String key, String value) -> String - Sets the value for the given key\n- hget(String hkey, String key) -> String - Gets the value of a field in a hash\n- hset(String hkey, String key, String value) -> long - Sets the value of a field in a hash\n- incr(String key) -> long - Increments the integer value of a key by 1\n- expire(String key, Integer second) -> long - Sets a timeout on a key\n- ttl(String key) -> long - Gets the remaining time to live of a key\n- del(String key) -> long - Deletes a key\n- hdel(String hkey, String key) -> long - Deletes a field from a hash",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisClientSingle {\n\n    private static final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n\n    private Jedis getResource() {\n        if(jedisPool==null) {\n            jedisPool = new JedisPool(host, port);\n        }\n        Jedis resource = jedisPool.getResource();\n        if (StringUtils.isBlank(password)) {\n            return resource;\n        } else {\n            resource.auth(password);\n            return resource;\n        }\n    }\n\n    public String get(String key) {\n        Jedis resource = getResource();\n        String string = resource.get(key);\n        resource.close();\n        return string;\n    }\n\n    public String set(String key, String value) {\n        Jedis resource = getResource();\n        String string = resource.set(key, value);\n        resource.close();\n        return string;\n    }\n\n    public String hget(String hkey, String key) {\n        Jedis resource = getResource();\n        String string = resource.hget(hkey, key);\n        resource.close();\n        return string;\n    }\n\n    public long hset(String hkey, String key, String value) {\n        Jedis resource = getResource();\n        Long hset = resource.hset(hkey, key, value);\n        resource.close();\n        return hset;\n    }\n\n    public long incr(String key) {\n        Jedis resource = getResource();\n        Long incr = resource.incr(key);\n        resource.close();\n        return incr;\n    }\n\n    public long expire(String key, Integer second) {\n        Jedis resource = getResource();\n        Long expire = resource.expire(key, second);\n        resource.close();\n        return expire;\n    }\n\n    public long ttl(String key) {\n        Jedis resource = getResource();\n        Long ttl = resource.ttl(key);\n        resource.close();\n        return ttl;\n    }\n\n    public long del(String key) {\n        Jedis resource = getResource();\n        Long del = resource.del(key);\n        resource.close();\n        return del;\n    }\n\n    public long hdel(String hkey, String key) {\n        Jedis resource = getResource();\n        Long hdel = resource.hdel(hkey, key);\n        resource.close();\n        return hdel;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class JedisClientSingle {\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n    private Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    public JedisClientSingle(String host, int port, String password) {\n        this.host = host;\n        this.port = port;\n        this.password = password;\n        initializePool();\n    }\n\n    private void initializePool() {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(128);\n        poolConfig.setMaxIdle(128);\n        poolConfig.setMinIdle(16);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n        poolConfig.setTestWhileIdle(true);\n        poolConfig.setMinEvictableIdleTimeMillis(Duration.ofSeconds(60).toMillis());\n        poolConfig.setTimeBetweenEvictionRunsMillis(Duration.ofSeconds(30).toMillis());\n        jedisPool = new JedisPool(poolConfig, host, port);\n    }\n\n    private Jedis getResource() {\n        Jedis jedis = jedisPool.getResource();\n        if (password != null && !password.isEmpty()) {\n            jedis.auth(password);\n        }\n        return jedis;\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.get(key);\n        } catch (Exception e) {\n            logger.error(\"Error getting key: \" + key, e);\n            return null;\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.set(key, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting key: \" + key, e);\n            return null;\n        }\n    }\n\n    public String hget(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hget(hkey, key);\n        } catch (Exception e) {\n            logger.error(\"Error getting hash field: \" + key + \" from hash: \" + hkey, e);\n            return null;\n        }\n    }\n\n    public long hset(String hkey, String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hset(hkey, key, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting hash field: \" + key + \" in hash: \" + hkey, e);\n            return 0;\n        }\n    }\n\n    public long incr(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.incr(key);\n        } catch (Exception e) {\n            logger.error(\"Error incrementing key: \" + key, e);\n            return 0;\n        }\n    }\n\n    public long expire(String key, Integer seconds) {\n        try (Jedis jedis = getResource()) {\n            return jedis.expire(key, seconds);\n        } catch (Exception e) {\n            logger.error(\"Error setting expiration for key: \" + key, e);\n            return 0;\n        }\n    }\n\n    public long ttl(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.ttl(key);\n        } catch (Exception e) {\n            logger.error(\"Error getting TTL for key: \" + key, e);\n            return 0;\n        }\n    }\n\n    public long del(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.del(key);\n        } catch (Exception e) {\n            logger.error(\"Error deleting key: \" + key, e);\n            return 0;\n        }\n    }\n\n    public long hdel(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hdel(hkey, key);\n        } catch (Exception e) {\n            logger.error(\"Error deleting hash field: \" + key + \" from hash: \" + hkey, e);\n            return 0;\n        }\n    }\n}"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\n\npublic class RedisConnectionFactory {\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig;\n\n    public RedisConnectionFactory() {\n        this.poolConfig = new JedisPoolConfig();\n    }\n\n    public void init() {\n        if (isCluster) {\n            createCluster();\n        } else {\n            createPool();\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.close();\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    private Jedis fetchJedisConnector() {\n        if (pool != null) {\n            return pool.getResource();\n        } else {\n            return new Jedis(hostName, port, timeout);\n        }\n    }\n\n    private void createPool() {\n        if (sentinelMaster != null) {\n            pool = createRedisSentinelPool();\n        } else {\n            pool = createRedisPool();\n        }\n    }\n\n    private Pool<Jedis> createRedisSentinelPool() {\n        return new JedisSentinelPool(sentinelMaster, redisServers, poolConfig, timeout, password);\n    }\n\n    private Pool<Jedis> createRedisPool() {\n        shardInfo = new JedisShardInfo(hostName, port, timeout);\n        shardInfo.setPassword(password);\n        shardInfo.setDb(dbIndex);\n        return new JedisPool(poolConfig, shardInfo);\n    }\n\n    private void createCluster() {\n        cluster = new JedisCluster(redisServers, timeout, poolConfig);\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (password != null && !password.isEmpty()) {\n            jedis.auth(password);\n        }\n        jedis.select(dbIndex);\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a Redis sharding client in Java that distributes keys across multiple Redis instances using consistent hashing, with support for basic CRUD operations and command execution.\n\nClass Description: JedisSharding is a Redis client wrapper that implements sharding across multiple Redis instances. It uses consistent hashing to distribute keys and automatically manages connections to the appropriate shard for each operation.\n\nAttributes:\n- shards: List<HostAndPort> - List of Redis server addresses and ports for sharding\n- clientConfig: JedisClientConfig - Configuration for Redis client connections\n- hashing: Hashing - Hashing algorithm used for key distribution (defaults to MURMUR_HASH)\n\nMethods:\n- JedisSharding(List<HostAndPort>, JedisClientConfig) -> void - Constructor with default hashing algorithm\n- JedisSharding(List<HostAndPort>, JedisClientConfig, Hashing) -> void - Constructor with custom hashing algorithm\n- set(String, String) -> String - Stores a key-value pair in the appropriate shard\n- get(String) -> String - Retrieves a value from the appropriate shard\n- sendCommand(String, Protocol.Command, String...) -> Object - Sends a raw Redis command to the appropriate shard\n- close() -> void - Cleans up resources (no-op as connections are managed per-operation)\n- getShard(String) -> Jedis - Internal method to get a connection to the correct shard\n- getShardIndex(String) -> int - Internal method to calculate shard index for a key",
    "Canonical_solution": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.util.Hashing;\nimport java.util.List;\n\npublic class JedisSharding implements AutoCloseable {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort shard = shards.get(shardIndex);\n        Jedis jedis = new Jedis(shard, clientConfig);\n        if (shard.getPassword() != null) {\n            jedis.auth(shard.getPassword());\n        }\n        return jedis;\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return (int) (hash % shards.size());\n    }\n\n    @Override\n    public void close() {\n        // Connection cleanup handled by try-with-resources in individual operations\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.Protocol;\n\nimport java.util.List;\n\npublic class JedisSharding {\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command cmd, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(cmd, args);\n        }\n    }\n\n    public void close() {\n        // No-op as connections are managed per-operation\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort hostAndPort = shards.get(shardIndex);\n        return new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), clientConfig);\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return Math.abs((int) (hash % shards.size()));\n    }\n\n    public enum Hashing {\n        MURMUR_HASH {\n            @Override\n            public long hash(String key) {\n                return MurmurHash.hash(key.getBytes());\n            }\n        };\n\n        public abstract long hash(String key);\n\n        private static class MurmurHash {\n            private static final int DEFAULT_SEED = 0x9747b28c;\n\n            public static long hash(byte[] data) {\n                int m = 0xc6a4a793;\n                int r = 24;\n                int len = data.length;\n                int seed = DEFAULT_SEED;\n                int h = seed ^ (len * m);\n                int index = 0;\n                while (len >= 4) {\n                    int k = (data[index] & 0xff) | ((data[index + 1] & 0xff) << 8) | ((data[index + 2] & 0xff) << 16) | ((data[index + 3] & 0xff) << 24);\n                    k *= m;\n                    k ^= k >>> r;\n                    k *= m;\n                    h *= m;\n                    h ^= k;\n                    index += 4;\n                    len -= 4;\n                }\n                switch (len) {\n                    case 3:\n                        h ^= (data[index + 2] & 0xff) << 16;\n                    case 2:\n                        h ^= (data[index + 1] & 0xff) << 8;\n                    case 1:\n                        h ^= (data[index] & 0xff);\n                        h *= m;\n                }\n                h ^= h >>> 13;\n                h *= m;\n                h ^= h >>> 15;\n                return h;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.JedisCluster;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n    private JedisCluster redis;\n    private Logger log = Logger.getLogger(JedisClusterCacheManager.class.getName());\n    private ISerializer<Object> serializer;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        this.redis = jedisCluster;\n        this.serializer = serializer;\n    }\n\n    @Override\n    public IRedis getRedis() {\n        return redis;\n    }\n\n    @Override\n    public void close() {\n        redis.close();\n    }\n\n    public void set(byte[] key, byte[] value) {\n        redis.set(key, value);\n    }\n\n    public void setex(byte[] key, int seconds, byte[] value) {\n        redis.setex(key, seconds, value);\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value) {\n        redis.hset(key, field, value);\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n        redis.hset(key, field, value);\n        redis.expire(key, seconds);\n    }\n\n    public void mset(Collection<MSetParam> params) {\n        redis.mset(params.stream().map(param -> new byte[][]{param.getKey(), param.getValue()}).toArray(byte[][][]::new));\n    }\n\n    public byte[] get(byte[] key) {\n        return redis.get(key);\n    }\n\n    public byte[] hget(byte[] key, byte[] field) {\n        return redis.hget(key, field);\n    }\n\n    public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type type, Set<CacheKeyTO> keys) {\n        // Implementation for batch get with deserialization\n        return null; // Placeholder\n    }\n\n    public void delete(Set<CacheKeyTO> keys) {\n        redis.del(keys.stream().map(CacheKeyTO::getKey).toArray(byte[][]::new));\n    }\n}"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with authentication support, including connection initialization, creation of different connection types, and proper resource cleanup.\n\nClass Description: The RedisConnectionManager class provides centralized management for Redis connections, supporting both standalone and cluster configurations with token-based authentication. It handles connection lifecycle management and provides methods to create different types of Redis connections.\n\nAttributes:\n\nclientOptions: [ClusterClientOptions] - Configuration options for Redis client connections\ncredentialsProvider: [TokenBasedRedisCredentialsProvider] - Provider for token-based authentication credentials\nclient: [RedisClient] - Client instance for standalone Redis connections\nclusterClient: [RedisClusterClient] - Client instance for Redis cluster connections\n\nMethods:\n\ninitializeConnection: [Name]([EntraIdTestContext testCtx]) -> [void] - Initializes Redis client instances with connection options and authentication configuration\ncreateStandaloneConnection: [Name]() -> [StatefulRedisConnection<String, String>] - Creates and returns a new standalone Redis connection\ncreateClusterConnection: [Name]() -> [StatefulRedisClusterConnection<String, String>] - Creates and returns a new Redis cluster connection\ncreatePubSubConnection: [Name]() -> [StatefulRedisPubSubConnection<String, String>] - Creates and returns a new Redis Pub/Sub connection\ncloseConnections: [Name]() -> [void] - Closes all active connections and releases resources",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.authentication.core.TokenBasedRedisCredentialsProvider;\n\npublic class RedisConnectionManager {\n\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        clientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(1)).build())\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        TokenAuthConfig tokenAuthConfig = EntraIDTokenAuthConfigBuilder.builder().clientId(testCtx.getClientId())\n                .secret(testCtx.getClientSecret()).authority(testCtx.getAuthority()).scopes(testCtx.getRedisScopes())\n                .expirationRefreshRatio(0.0000001F).build();\n\n        credentialsProvider = TokenBasedRedisCredentialsProvider.create(tokenAuthConfig);\n\n        RedisURI uri = RedisURI.builder().withHost(testCtx.host()).withPort(testCtx.port())\n                .withAuthentication(credentialsProvider).build();\n\n        client = RedisClient.create(uri);\n        client.setOptions(clientOptions);\n\n        RedisURI clusterUri = RedisURI.builder().withHost(testCtx.clusterHost().get(0)).withPort(testCtx.clusterPort())\n                .withAuthentication(credentialsProvider).build();\n        clusterClient = RedisClusterClient.create(clusterUri);\n        clusterClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (credentialsProvider != null) {\n            credentialsProvider.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n        if (clusterClient != null) {\n            clusterClient.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.StatefulRedisPubSubConnection;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnectionImpl;\nimport io.lettuce.core.support.ConnectionPoolSupport;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport javax.net.ssl.SSLParameters;\nimport java.util.List;\n\nclass TokenBasedRedisCredentialsProvider {\n    public String getToken() {\n        // Logic to fetch token\n        return \"your_token_here\";\n    }\n}\n\nclass RedisConnectionManager {\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        SSLParameters sslParams = new SSLParameters();\n        clientOptions = ClusterClientOptions.builder()\n                .sslOptions(SslOptions.builder().sslParameters(sslParams).build())\n                .build();\n\n        credentialsProvider = new TokenBasedRedisCredentialsProvider();\n        String token = credentialsProvider.getToken();\n\n        List<RedisURI> redisURIs = testCtx.getRedisURIs(); // Assuming EntraIdTestContext has this method\n        redisURIs.forEach(uri -> uri.setPassword(token));\n\n        client = RedisClient.create(clientOptions);\n        clusterClient = RedisClusterClient.create(clientOptions, redisURIs);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (client != null) {\n            client.shutdown();\n        }\n        if (clusterClient != null) {\n            clusterClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a RocketMQ consumer class in Java that can subscribe to a topic, consume messages asynchronously, and handle message consumption with configurable retry behavior.\n\nClass Description: The RocketMQConsumer class is responsible for consuming messages from a RocketMQ broker. It provides functionality to initialize the consumer, start message consumption with configurable retry behavior, and shutdown the consumer gracefully.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name\n- topic: String - The topic to subscribe to\n- subscription: String - The subscription expression (tags filter)\n- returnFailedHalf: boolean - Flag to control whether to return failure status for half of the messages\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the consumer instance with the specified group name and subscription\n- start() throws MQClientException -> void - Starts the consumer with a message listener that handles incoming messages and implements the retry logic\n- shutdown() -> void - Shuts down the consumer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.subscribe(topic, subscription != null ? subscription : \"*\");\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                long currentTimes = this.consumeTimes.incrementAndGet();\n                System.out.printf(\"%-8d %s%n\", currentTimes, msgs);\n                if (returnFailedHalf) {\n                    if ((currentTimes % 2) == 0) {\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.subscribe(topic, subscription);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            try {\n                for (MessageExt msg : msgs) {\n                    // Process the message\n                    if (!processMessage(msg)) {\n                        // Handle message processing failure\n                        if (returnFailedHalf) {\n                            return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                        }\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            } catch (Exception e) {\n                return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n            }\n        });\n        consumer.start();\n    }\n\n    private boolean processMessage(MessageExt msg) {\n        // Implement message processing logic here\n        return true; // Return true if message is processed successfully, false otherwise\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a Java class that manages a mark file for inter-process communication, allowing processes to check the status of another process through a shared memory-mapped file. The class should handle file creation, version checking, timestamp validation, and resource cleanup.\n\nClass Description: The MarkFile class provides a mechanism for processes to communicate their liveness status via a memory-mapped file. It supports checking version compatibility, monitoring heartbeat timestamps, and ensuring proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- markFile: File - The physical file used for marking process status\n- mappedBuffer: MappedByteBuffer - The memory-mapped buffer for file operations\n- buffer: UnsafeBuffer - Wrapper around mappedBuffer for atomic operations\n- isClosed: AtomicBoolean - Flag indicating whether resources have been released\n\nMethods:\n- MarkFile(File, boolean, int, int, int, long, EpochClock, IntConsumer, Consumer<String>) -> void - Constructor that initializes the mark file with version and timestamp fields\n- close() -> void - Releases resources and closes the file channel\n- mapNewOrExistingMarkFile(File, boolean, int, int, long, long, EpochClock, IntConsumer, Consumer<String>) -> MappedByteBuffer - Static method that maps the file into memory and performs version/timestamp validation\n- ensureMarkFileLink(File, File, String) -> void - Static method that manages symbolic links to the mark file directory",
    "Canonical_solution": "import org.agrona.concurrent.UnsafeBuffer;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.function.IntConsumer;\nimport static java.nio.channels.FileChannel.MapMode.READ_WRITE;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.nio.file.StandardOpenOption.WRITE;\n\npublic class MarkFile implements AutoCloseable\n{\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean();\n\n    public MarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final int totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        this.markFile = markFile;\n        this.mappedBuffer = mapNewOrExistingMarkFile(\n            markFile,\n            shouldPreExist,\n            versionFieldOffset,\n            timestampFieldOffset,\n            totalFileLength,\n            timeoutMs,\n            epochClock,\n            versionCheck,\n            logger);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    public void close()\n    {\n        if (isClosed.compareAndSet(false, true))\n        {\n            BufferUtil.free(mappedBuffer);\n        }\n    }\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final long totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        MappedByteBuffer byteBuffer = null;\n\n        try (FileChannel channel = FileChannel.open(markFile.toPath(), CREATE, READ, WRITE))\n        {\n            byteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, totalFileLength);\n            final UnsafeBuffer buffer = new UnsafeBuffer(byteBuffer);\n\n            if (shouldPreExist)\n            {\n                if (buffer.capacity() < (timestampFieldOffset + SIZE_OF_LONG))\n                {\n                    throw new IllegalStateException(\"active MarkFile too short capacity=\" + buffer.capacity() +\n                        \" < \" + (timestampFieldOffset + SIZE_OF_LONG));\n                }\n\n                final int version = buffer.getIntVolatile(versionFieldOffset);\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: Mark file exists: \" + markFile);\n                }\n\n                versionCheck.accept(version);\n\n                final long timestampMs = buffer.getLongVolatile(timestampFieldOffset);\n                final long timestampAgeMs = epochClock.time() - timestampMs;\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: heartbeat timestampMs=\" + timestampMs + \" ageMs=\" + timestampAgeMs);\n                }\n\n                if (timestampAgeMs < timeoutMs)\n                {\n                    throw new IllegalStateException(\"active Mark file detected\");\n                }\n            }\n        }\n        catch (final Exception ex)\n        {\n            if (null != byteBuffer)\n            {\n                BufferUtil.free(byteBuffer);\n            }\n\n            throw new RuntimeException(ex);\n        }\n\n        return byteBuffer;\n    }\n\n    public static void ensureMarkFileLink(final File serviceDir, final File actualFile, final String linkFilename)\n    {\n        final Path linkFile = new File(serviceDir, linkFilename).toPath();\n        if (serviceDir.equals(actualFile.getParentFile()))\n        {\n            try\n            {\n                Files.deleteIfExists(linkFile);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to remove old link file\", ex);\n            }\n        }\n        else\n        {\n            try\n            {\n                Files.write(\n                    linkFile,\n                    actualFile.getParent().getBytes(US_ASCII),\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.WRITE,\n                    StandardOpenOption.TRUNCATE_EXISTING);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to create link for mark file directory\", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.agrona.BufferUtil;\nimport org.agrona.UnsafeBuffer;\nimport org.agrona.concurrent.EpochClock;\n\npublic class MarkFile implements AutoCloseable {\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n\n    public MarkFile(\n            final File markFile,\n            final boolean createNewFile,\n            final int headerLength,\n            final int trailerLength,\n            final int metaDataLength,\n            final long timeoutMs,\n            final EpochClock epochClock,\n            final IntConsumer versionCheckHandler,\n            final Consumer<String> logger) throws IOException {\n        this.markFile = markFile;\n        this.mappedBuffer = mapNewOrExistingMarkFile(markFile, createNewFile, headerLength, trailerLength, metaDataLength, timeoutMs, epochClock, versionCheckHandler, logger);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            BufferUtil.unmap(mappedBuffer);\n        }\n    }\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(\n            final File markFile,\n            final boolean createNewFile,\n            final int headerLength,\n            final int trailerLength,\n            final int metaDataLength,\n            final long timeoutMs,\n            final EpochClock epochClock,\n            final IntConsumer versionCheckHandler,\n            final Consumer<String> logger) throws IOException {\n        final RandomAccessFile file = new RandomAccessFile(markFile, \"rw\");\n        final FileChannel fileChannel = file.getChannel();\n        final long length = headerLength + metaDataLength + trailerLength;\n\n        try {\n            if (createNewFile) {\n                file.setLength(length);\n            }\n\n            final MappedByteBuffer mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, length);\n            final UnsafeBuffer buffer = new UnsafeBuffer(mappedBuffer);\n\n            if (createNewFile) {\n                buffer.putInt(0, 1); // Example version number\n                buffer.putLong(headerLength + metaDataLength - 8, epochClock.time());\n            } else {\n                final int version = buffer.getInt(0);\n                versionCheckHandler.accept(version);\n                final long timestamp = buffer.getLong(headerLength + metaDataLength - 8);\n                if (epochClock.time() - timestamp > timeoutMs) {\n                    throw new IllegalStateException(\"Mark file is stale\");\n                }\n            }\n\n            return mappedBuffer;\n        } finally {\n            file.close();\n        }\n    }\n\n    public static void ensureMarkFileLink(final File markFileDir, final File markFile, final String linkName) throws IOException {\n        final File link = new File(markFileDir, linkName);\n        if (!link.exists()) {\n            if (!markFileDir.exists() && !markFileDir.mkdirs()) {\n                throw new IOException(\"Failed to create directory for mark file link\");\n            }\n            java.nio.file.Files.createSymbolicLink(link.toPath(), markFile.toPath());\n        }\n    }\n}"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic, process them using an orderly message listener, and manage the consumer lifecycle.\n\nClass Description: The Consumer class encapsulates the functionality of a RocketMQ push consumer that subscribes to a topic, processes messages in order, and provides methods to start and stop the consumer.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name for this consumer\n- topic: String - The topic to subscribe to\n- subExpression: String - The tag expression for message filtering\n\nMethods:\n- Consumer(String, String, String) -> None - Constructor that initializes the consumer group, topic, and subscription expression\n- initialize() -> None - Initializes the consumer instance with basic configuration and subscription\n- start() -> None - Registers the message listener and starts the consumer\n- shutdown() -> None - Gracefully shuts down the consumer",
    "Canonical_solution": "import java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerOrderly() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n                context.setAutoCommit(true);\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                this.consumeTimes.incrementAndGet();\n                if ((this.consumeTimes.get() % 2) == 0) {\n                    return ConsumeOrderlyStatus.SUCCESS;\n                } else if ((this.consumeTimes.get() % 5) == 0) {\n                    context.setSuspendCurrentQueueTimeMillis(3000);\n                    return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n                }\n                return ConsumeOrderlyStatus.SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class Consumer {\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() throws Exception {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void start() throws Exception {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.printf(\"Received message: %s%n\", new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n    private final RPCHook rpcHook;\n    private final String topicName;\n    private final String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup, rpcHook);\n    }\n\n    public void startConsumer() throws MQClientException {\n        defaultMQPushConsumer.subscribe(topicName, \"*\");\n        defaultMQPushConsumer.registerMessageListener(this);\n        defaultMQPushConsumer.start();\n        log.info(\"Consumer started for topic: {}\", topicName);\n    }\n\n    public void shutdown() {\n        defaultMQPushConsumer.shutdown();\n        log.info(\"Consumer shut down for topic: {}\", topicName);\n    }\n\n    public SendMessageRequestHeader buildSendMessageRequestHeader(MessageExt message, String brokerName, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(defaultMQPushConsumer.getConsumerGroup());\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(message.getProperty(Message.PROPERTY_DEFAULT_TOPIC));\n        requestHeader.setDefaultMsgFlag(Integer.parseInt(message.getProperty(Message.PROPERTY_DEFAULT_FLAG)));\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(message.getSysFlag());\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setBrokerName(brokerName);\n        return requestHeader;\n    }\n\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n        for (MessageExt msg : msgs) {\n            log.info(\"Received message: {} from topic: {}\", new String(msg.getBody()), msg.getTopic());\n            // Process the message here\n        }\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n    }\n}"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with configurable group, tags, and keys.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending, and shutdown operations. The class provides methods to start the producer, send messages synchronously, and gracefully shut down the producer.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- group: String - The producer group name\n- topic: String - The topic to which messages will be sent\n- tags: String - The tags for message categorization\n- keys: String - The keys for message identification\n\nMethods:\n- Producer(String group, String topic, String tags, String keys) -> void - Constructor that initializes the producer with given group, topic, tags, and keys\n- start() -> void - Starts the producer instance\n- sendMessage(String messageContent) -> SendResult - Synchronously sends a message with the given content and returns the send result\n- shutdown() -> void - Shuts down the producer instance\n- buildCommandline(String[] args) -> CommandLine - Static method that builds and parses command line arguments for producer configuration",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) throws MQClientException {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n        this.producer.setInstanceName(Long.toString(System.currentTimeMillis()));\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(\n            topic,\n            tags,\n            keys,\n            messageContent.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        final Options options = new Options();\n        Option opt = new Option(\"h\", \"help\", false, \"Print help\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"g\", \"producerGroup\", true, \"Producer Group Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Topic Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"a\", \"tags\", true, \"Tags Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"k\", \"keys\", true, \"Keys Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"msgCount\", true, \"Message Count\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        DefaultParser parser = new DefaultParser();\n        HelpFormatter hf = new HelpFormatter();\n        hf.setWidth(110);\n        CommandLine commandLine = null;\n        try {\n            commandLine = parser.parse(options, args);\n            if (commandLine.hasOption('h')) {\n                hf.printHelp(\"producer\", options, true);\n                return null;\n            }\n        } catch (ParseException e) {\n            hf.printHelp(\"producer\", options, true);\n            return null;\n        }\n\n        return commandLine;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Option;\n\n@Command(name = \"RocketMQProducer\", mixinStandardHelpOptions = true, version = \"1.0\")\nclass Producer implements Runnable {\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    @Option(names = {\"-g\", \"--group\"}, description = \"The producer group name\", required = true)\n    private String groupOption;\n\n    @Option(names = {\"-t\", \"--topic\"}, description = \"The topic to which messages will be sent\", required = true)\n    private String topicOption;\n\n    @Option(names = {\"--tags\"}, description = \"The tags for message categorization\", defaultValue = \"\")\n    private String tagsOption;\n\n    @Option(names = {\"--keys\"}, description = \"The keys for message identification\", defaultValue = \"\")\n    private String keysOption;\n\n    public Producer(String group, String topic, String tags, String keys) {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n    }\n\n    public void start() throws Exception {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(topic, tags, keys, messageContent.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        return new CommandLine(new Producer(\"\", \"\", \"\", \"\")).parseArgs(args);\n    }\n\n    @Override\n    public void run() {\n        try {\n            group = groupOption;\n            topic = topicOption;\n            tags = tagsOption;\n            keys = keysOption;\n            start();\n            SendResult result = sendMessage(\"Hello RocketMQ\");\n            System.out.printf(\"SendResult: %s%n\", result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public static void main(String[] args) {\n        CommandLine cmd = buildCommandline(args);\n        if (!cmd.isUsageHelpRequested()) {\n            ((Producer) cmd.getCommand()).run();\n        }\n    }\n}"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "import org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n    private final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n    private final NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession;\n    private final AtomicBoolean mConnecting = new AtomicBoolean(false);\n    private long mLastConnectionAttempt;\n    private final IcecastHTTPConfiguration mConfiguration;\n    private BroadcastState mBroadcastState;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        this.mConfiguration = configuration;\n        this.mSocketConnector = new NioSocketConnector();\n        this.mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n        this.mBroadcastState = BroadcastState.DISCONNECTED;\n    }\n\n    public boolean connect() {\n        if (!canConnect()) return false;\n        mConnecting.set(true);\n        mLastConnectionAttempt = System.currentTimeMillis();\n        try {\n            mStreamingSession = mSocketConnector.connect(mConfiguration.getServerAddress(), mConfiguration.getServerPort()).awaitUninterruptibly().getSession();\n            mConnecting.set(false);\n            setBroadcastState(BroadcastState.CONNECTING);\n            return true;\n        } catch (Exception e) {\n            mLog.error(\"Failed to connect to Icecast server\", e);\n            mConnecting.set(false);\n            setBroadcastState(BroadcastState.DISCONNECTED);\n            return false;\n        }\n    }\n\n    public void disconnect() {\n        if (mStreamingSession != null && mStreamingSession.isConnected()) {\n            mStreamingSession.closeNow();\n        }\n        mStreamingSession = null;\n        setBroadcastState(BroadcastState.DISCONNECTED);\n    }\n\n    public boolean connected() {\n        return mStreamingSession != null && mStreamingSession.isConnected();\n    }\n\n    public boolean canConnect() {\n        return !connected() && !mConnecting.get() && System.currentTimeMillis() - mLastConnectionAttempt > RECONNECT_INTERVAL_MILLISECONDS;\n    }\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        return mConfiguration;\n    }\n\n    public void setBroadcastState(BroadcastState state) {\n        this.mBroadcastState = state;\n    }\n\n    public BroadcastState getBroadcastState() {\n        return mBroadcastState;\n    }\n\n    public Map<String, String> getHTTPHeaders() {\n        return mConfiguration.getHeaders();\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        return mConfiguration;\n    }\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            super.sessionOpened(session);\n            session.write(getHTTPHeaders());\n            setBroadcastState(BroadcastState.CONNECTED);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            super.sessionClosed(session);\n            setBroadcastState(BroadcastState.DISCONNECTED);\n            mLog.info(\"Session closed\");\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable cause) throws Exception {\n            super.exceptionCaught(session, cause);\n            mLog.error(\"Exception caught\", cause);\n            session.closeNow();\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object message) throws Exception {\n            super.messageReceived(session, message);\n            mLog.info(\"Message received: {}\", message.toString());\n        }\n    }\n\n    public enum BroadcastState {\n        DISCONNECTED,\n        CONNECTING,\n        CONNECTED\n    }\n}"
  },
  {
    "Task_id": 402,
    "Instruction": "Task Description: Create an asynchronous task in Android that performs an HTTP GET request to a specified server using TCP socket communication, reads the response, and returns it to the caller via a callback mechanism.\n\nClass Description: HttpGetTask is an AsyncTask subclass that handles network operations in the background to prevent blocking the UI thread. It establishes a TCP connection to a server, sends an HTTP GET request, reads the response, and delivers it to a retained fragment through a weak reference.\n\nAttributes:\n- TAG: [String] - A constant for logging purposes\n- HOST: [String] - The hostname of the server to connect to\n- USER_NAME: [String] - The username for authentication\n- HTTP_GET_COMMAND: [String] - The formatted HTTP GET request string\n- mListener: [WeakReference<RetainedFragment>] - Weak reference to the fragment that will receive the result\n\nMethods:\n- HttpGetTask([RetainedFragment retainedFragment]) -> [void] - Constructor that initializes the task with a weak reference to the calling fragment\n- doInBackground([Void... params]) -> [String] - Performs the network operations in the background (opens socket, sends request, reads response)\n- onPostExecute([String result]) -> [void] - Delivers the result to the retained fragment after task completion\n- readStream([InputStream in]) -> [String] - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.ref.WeakReference;\nimport java.net.Socket;\n\npublic class HttpGetTask extends AsyncTask<Void, Void, String> {\n\n    private static final String TAG = \"HttpGetTask\";\n    private static final String HOST = \"api.geonames.org\";\n    private static final String USER_NAME = \"aporter\";\n    private static final String HTTP_GET_COMMAND = \"GET /earthquakesJSON?north=44.1&south=-9.9&east=-22.4&west=55.2&username=\"\n            + USER_NAME + \" HTTP/1.1\" + \"\\n\" + \"Host: \" + HOST + \"\\n\"\n            + \"Connection: close\" + \"\\n\\n\";\n\n    private final WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(HOST, 80);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(HTTP_GET_COMMAND);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        if (null != mListener.get()) {\n            mListener.get().onDownloadFinished(result);\n        }\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuilder data = new StringBuilder();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import android.os.AsyncTask;\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.lang.ref.WeakReference;\n\npublic class HttpGetTask extends AsyncTask<Void, Void, String> {\n    private static final String TAG = \"HttpGetTask\";\n    private static final String HOST = \"example.com\";\n    private static final int PORT = 80;\n    private static final String USER_NAME = \"username\";\n    private static final String HTTP_GET_COMMAND = \"GET / HTTP/1.1\\r\\nHost: \" + HOST + \"\\r\\nConnection: Close\\r\\n\\r\\n\";\n    private final WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        StringBuilder result = new StringBuilder();\n        try (Socket socket = new Socket(HOST, PORT)) {\n            OutputStream out = socket.getOutputStream();\n            out.write(HTTP_GET_COMMAND.getBytes());\n            out.flush();\n\n            InputStream inputStream = socket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"Error during network operation\", e);\n        }\n        return result.toString();\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        RetainedFragment listener = mListener.get();\n        if (listener != null) {\n            listener.onTaskCompleted(result);\n        }\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        StringBuilder result = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                result.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"Error reading stream\", e);\n        }\n        return result.toString();\n    }\n}"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import socket\n\ndef send_string_to_server(message):\n    host = 'example.com'\n    port = 12345\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((host, port))\n            s.sendall(message.encode('utf-8'))\n    except Exception as e:\n        print(f\"An error occurred: {e}\", file=sys.stderr)"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.Gauge;\n\npublic class Graphite {\n    private String host;\n    private int port;\n    private Logger logger = Logger.getLogger(Graphite.class.getName());\n    private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9._-]\");\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             OutputStream outputStream = socket.getOutputStream()) {\n            for (String name : registry.metricFamilySamples()) {\n                String sanitizedMetricName = sanitizeMetricName(name);\n                Gauge gauge = Gauge.build().name(sanitizedMetricName).help(\"\").register(registry);\n                double value = gauge.get();\n                String metricLine = sanitizedMetricName + \" \" + value + \" \" + System.currentTimeMillis() / 1000 + \"\\n\";\n                outputStream.write(metricLine.getBytes());\n            }\n        } catch (IOException e) {\n            logger.severe(\"Failed to push metrics to Graphite: \" + e.getMessage());\n            throw e;\n        }\n    }\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        Thread pushThread = new PushThread(registry, intervalSeconds);\n        pushThread.setDaemon(true);\n        pushThread.start();\n        return pushThread;\n    }\n\n    private String sanitizeMetricName(String name) {\n        return INVALID_GRAPHITE_CHARS.matcher(name).replaceAll(\"_\");\n    }\n\n    private class PushThread extends Thread {\n        private CollectorRegistry registry;\n        private int intervalSeconds;\n\n        public PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    push(registry);\n                    Thread.sleep(intervalSeconds * 1000L);\n                } catch (IOException | InterruptedException e) {\n                    logger.severe(\"Error in periodic push to Graphite: \" + e.getMessage());\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 406,
    "Instruction": "Task Description: Write a Java function that tests a server's handling of a malformed HTTP request by sending a bad request and verifying the server's response.\n\nFunction Description: The function `testBadRequest` attempts to send a deliberately malformed HTTP POST request to a server and verifies that the server responds with a \"400 Bad Request\" error. The function creates a TCP socket connection to the server, sends the malformed request, reads the server's response, and compares it to the expected response. If the response matches, the test passes; otherwise, it may throw an IOException if the connection is closed prematurely.\n\nInput: None (The server address and port are obtained from `DefaultServer.getDefaultServerAddress()` internally)\n\nOutput: None (The function asserts the server's response matches the expected \"400 Bad Request\" response. Any mismatch or IOException will result in a test failure or exception.)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Socket;\n\npublic void testBadRequest() throws IOException {\n    String request = \"POST /\\r HTTP/1.1\\r\\nTrailer:foo, bar\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n9\\r\\nabcdefghi\\r\\n0\\r\\nfoo: fooVal\\r\\n bar: barVal\\r\\n\\r\\n\";\n    String response1 = \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\";\n    Socket s = new Socket(DefaultServer.getDefaultServerAddress().getAddress(), DefaultServer.getDefaultServerAddress().getPort());\n    try {\n        s.getOutputStream().write(request.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        int read = 0;\n        byte[] buf = new byte[100];\n        while (read < response1.length()) {\n            int r = s.getInputStream().read(buf);\n            if (r <= 0) break;\n            if (r > 0) {\n                read += r;\n                sb.append(new String(buf, 0, r));\n            }\n        }\n        Assert.assertEquals(response1, sb.toString());\n\n    } catch (IOException expected) {\n        //this can happen as well, as in some cases we may not have fully consumed the read side\n        //before the connection is shutdown, namely when we are running in test.single\n    } finally {\n        s.close();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\n\npublic class BadRequestTest {\n    public static void testBadRequest() throws IOException {\n        String serverAddress = DefaultServer.getDefaultServerAddress();\n        int serverPort = DefaultServer.getDefaultServerPort();\n\n        try (Socket socket = new Socket(serverAddress, serverPort);\n             OutputStream outputStream = socket.getOutputStream();\n             InputStream inputStream = socket.getInputStream()) {\n\n            // Malformed HTTP request\n            String malformedRequest = \"POST / HTTP/1.1\\r\\n\" +\n                                      \"Host: example.com\\r\\n\" +\n                                      \"Content-Length: 10\\r\\n\" +\n                                      \"\\r\\n\" +\n                                      \"123456789\"; // Missing one character\n\n            outputStream.write(malformedRequest.getBytes());\n            outputStream.flush();\n\n            // Read the response\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String responseLine = reader.readLine();\n\n            // Check for 400 Bad Request\n            if (!responseLine.contains(\"400 Bad Request\")) {\n                throw new IOException(\"Unexpected response: \" + responseLine);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            testBadRequest();\n            System.out.println(\"Test passed.\");\n        } catch (IOException e) {\n            System.err.println(\"Test failed: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\n\npublic class TProfilerClient {\n\n    private static final String CRLF = \"\\r\\n\";\n\n    public void start(String server, int port) {\n        doSend(\"START\", server, port);\n    }\n\n    public void stop(String server, int port) {\n        doSend(\"STOP\", server, port);\n    }\n\n    public String status(String server, int port) {\n        return getStatus(\"STATUS\", server, port);\n    }\n\n    public void flushMethod(String server, int port) {\n        doSend(\"FLUSHMETHOD\", server, port);\n    }\n\n    private void doSend(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             OutputStream out = socket.getOutputStream()) {\n            PrintWriter writer = new PrintWriter(out, true);\n            writer.print(command + CRLF);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getStatus(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             InputStream in = socket.getInputStream();\n             OutputStream out = socket.getOutputStream()) {\n            PrintWriter writer = new PrintWriter(out, true);\n            writer.print(command + CRLF);\n            return read(in);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != '\\r') {\n            if (c == '\\n') continue;\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n    private static final String REMOTE_PATH = \"/data/local/tmp/\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n    private List<MinitouchListener> listenerList = new ArrayList<>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        forward = createForward();\n        if (forward != null) {\n            startInitialThread(forward.getHost(), forward.getPort());\n        }\n    }\n\n    public void kill() {\n        if (minitouchSocket != null) {\n            try {\n                minitouchSocket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        removeForward(forward);\n        onClose();\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream != null) {\n            try {\n                minitouchOutputStream.write(str.getBytes());\n                minitouchOutputStream.flush();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private AdbForward createForward() {\n        return generateForwardInfo();\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward != null) {\n            device.removeForward(forward);\n        }\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                minitouchSocket = new Socket(host, port);\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n                onStartup(true);\n            } catch (Exception e) {\n                onStartup(false);\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onConnectionStarted(success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onConnectionClosed();\n        }\n    }\n\n    private AdbForward generateForwardInfo() {\n        return device.createForward(\"tcp:19798\", \"localabstract:minitouch\");\n    }\n\n    public interface MinitouchListener {\n        void onConnectionStarted(boolean success);\n        void onConnectionClosed();\n    }\n}"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import socket\n\ndef send_message_to_server(str):\n    try:\n        server_address = ('localhost', 10000)\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n            sock.connect(server_address)\n            sock.sendall(str.encode('utf-8'))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a Java function that establishes a TCP client connection to a server, sends HTTP upgrade requests and echo messages, and verifies server responses.\n\nFunction Description: The function connects to a predefined server using TCP, sends an HTTP upgrade request followed by echo messages, and asserts the correctness of server responses. It handles basic client-server communication including connection establishment, data exchange, and connection termination.\n\nInput: \n- url: String - The URL path to be used in the HTTP GET request\n\nOutput: \n- None (void) - The function performs assertions to verify server responses but doesn't return any value. It throws IOException if any network communication fails.\n\nNote: The function uses predefined host address and port from DefaultServer class, and includes a helper method readBytes() (not shown) to read data from the input stream.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void runTest(final String url) throws IOException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET \" + url + \" HTTP/1.1\\r\\nHost:default\\r\\nConnection: upgrade\\r\\nUpgrade: servlet\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    Assert.assertTrue(readBytes(in).startsWith(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n\n    out.write(\"Echo Messages\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"Echo Messages2\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages2\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"exit\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    out.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\n\npublic class TcpClient {\n\n    private static final String HOST = DefaultServer.HOST;\n    private static final int PORT = DefaultServer.PORT;\n\n    public void connectAndEcho(String url) throws IOException {\n        try (Socket socket = new Socket(HOST, PORT);\n             OutputStream out = socket.getOutputStream();\n             InputStream in = socket.getInputStream()) {\n\n            // Send HTTP upgrade request\n            String request = \"GET \" + url + \" HTTP/1.1\\r\\n\" +\n                             \"Host: \" + HOST + \":\" + PORT + \"\\r\\n\" +\n                             \"Upgrade: echo\\r\\n\" +\n                             \"Connection: Upgrade\\r\\n\" +\n                             \"\\r\\n\";\n            out.write(request.getBytes(StandardCharsets.UTF_8));\n            out.flush();\n\n            // Read response from server\n            byte[] responseBytes = readBytes(in);\n            String response = new String(responseBytes, StandardCharsets.UTF_8);\n\n            // Assert HTTP 101 Switching Protocols\n            if (!response.startsWith(\"HTTP/1.1 101 Switching Protocols\")) {\n                throw new IOException(\"Unexpected response: \" + response);\n            }\n\n            // Send echo message\n            String echoMessage = \"Hello, Server!\";\n            out.write(echoMessage.getBytes(StandardCharsets.UTF_8));\n            out.flush();\n\n            // Read echo response\n            byte[] echoResponseBytes = readBytes(in);\n            String echoResponse = new String(echoResponseBytes, StandardCharsets.UTF_8);\n\n            // Assert echo response\n            if (!echoResponse.equals(echoMessage)) {\n                throw new IOException(\"Echo response mismatch: expected '\" + echoMessage + \"', got '\" + echoResponse + \"'\");\n            }\n        }\n    }\n\n    private byte[] readBytes(InputStream in) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[16384];\n        while ((nRead = in.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.Socket;\nimport org.json.JSONObject;\n\npublic class SocketClient {\n    private static final int SERVER_SOCKET_PORT = 12345;\n    private static final String HARDWARE_ID = \"sensor001\";\n\n    public void doSocketTest() {\n        try (Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n             OutputStream outputStream = socket.getOutputStream()) {\n\n            JSONObject jsonData = generateMeasurementData();\n            String jsonString = jsonData.toString();\n            outputStream.write(jsonString.getBytes());\n            outputStream.flush();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private JSONObject generateMeasurementData() {\n        JSONObject data = new JSONObject();\n        data.put(\"hardwareId\", HARDWARE_ID);\n        data.put(\"temperature\", 23.5);\n        data.put(\"humidity\", 48.0);\n        return data;\n    }\n\n    public static void main(String[] args) {\n        SocketClient client = new SocketClient();\n        client.doSocketTest();\n    }\n}"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection {\n    private static final int MTU = 16384;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20; // Assuming default IP and TCP header sizes\n    private StreamBuffer clientToNetwork;\n    private Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n    private SocketChannel channel;\n    private SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        this.clientToNetwork = new StreamBuffer(MAX_PAYLOAD_SIZE);\n        this.networkToClient = new Packetizer();\n        this.packetForClient = new IPv4Packet();\n        this.channel = createChannel();\n        this.channel.connect(new InetSocketAddress(\"example.com\", 80));\n        this.selectionKey = channel.register(selector, SelectionKey.OP_CONNECT);\n        this.interests = SelectionKey.OP_CONNECT;\n    }\n\n    public void disconnect() {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void processReceive() {\n        ByteBuffer buffer = ByteBuffer.allocate(MTU);\n        try {\n            int bytesRead = channel.read(buffer);\n            if (bytesRead > 0) {\n                buffer.flip();\n                networkToClient.process(buffer);\n                packetForClient = networkToClient.nextPacket();\n                // Handle packetForClient as needed\n            } else if (bytesRead == -1) {\n                disconnect();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            disconnect();\n        }\n    }\n\n    public void processSend() {\n        try {\n            if (clientToNetwork.hasRemaining()) {\n                ByteBuffer buffer = clientToNetwork.getBuffer();\n                channel.write(buffer);\n                if (!buffer.hasRemaining()) {\n                    clientToNetwork.clear();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            disconnect();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        return channel;\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        ByteBuffer buffer = packet.serialize();\n        clientToNetwork.put(buffer);\n        updateInterests();\n    }\n\n    public void updateInterests() {\n        interests = 0;\n        if (mayRead()) {\n            interests |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interests |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interests |= SelectionKey.OP_CONNECT;\n        }\n        selectionKey.interestOps(interests);\n    }\n\n    private boolean mayRead() {\n        return networkToClient.canProcess();\n    }\n\n    private boolean mayWrite() {\n        return clientToNetwork.hasRemaining();\n    }\n\n    private boolean mayConnect() {\n        return channel.isConnectionPending();\n    }\n}"
  },
  {
    "Task_id": 428,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) to send messages to a server. The client should support multiple sender threads, track total bytes and messages sent, and allow for both direct and heap byte buffers.\n\nClass Description: NioClientTest is a TCP client implementation that uses Java NIO's SocketChannel to communicate with a server. It manages multiple sender threads, tracks performance metrics, and provides interactive control via console input.\n\nAttributes:\n- running: boolean - Flag to control the main loop's execution\n- total_bytes_sent: LongAdder - Counter for total bytes sent to the server\n- total_msgs: LongAdder - Counter for total messages sent to the server\n- senders: Sender[] - Array of sender threads\n\nMethods:\n- create(int size, boolean direct) -> ByteBuffer - Creates a new ByteBuffer with specified size and type (direct or heap)\n- start(InetAddress host, boolean direct, int num_threads) -> void - Main method to start the client and handle user input\n- sendMessages(InetAddress host, boolean direct, int num_threads) -> void - Creates and starts sender threads\n- Sender(InetAddress host, boolean direct, CountDownLatch latch) -> void - Constructor for the inner Sender class\n- run() -> void - The Sender thread's main execution method (connects to server and sends data)\n\nInner Class: Sender extends Thread\nAttributes:\n- ch: SocketChannel - The channel used for communication\n- latch: CountDownLatch - Synchronization aid for thread coordination\n- host: InetAddress - The server's host address\n- direct: boolean - Flag for buffer type (direct or heap)\n- buf: ByteBuffer - The buffer used for message data\n\nMethods:\n- run() -> void - Connects to server, waits for latch, then sends messages until byte limit is reached",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    protected volatile boolean running=true;\n    protected final LongAdder total_bytes_sent=new LongAdder();\n    protected final LongAdder total_msgs=new LongAdder();\n    protected Sender[] senders;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(InetAddress host, boolean direct, int num_threads) throws Exception {\n        boolean looping=true;\n        while(looping) {\n            int c=Util.keyPress(\"[1] send [x] exit\");\n            switch(c) {\n                case '1':\n                    sendMessages(host, direct, num_threads);\n                    break;\n                case 'x':\n                case -1:\n                    looping=false;\n                    break;\n            }\n        }\n    }\n\n    protected void sendMessages(InetAddress host, boolean direct, int num_threads) throws Exception {\n        total_msgs.reset();\n        total_bytes_sent.reset();\n        senders=new Sender[num_threads];\n        final CountDownLatch latch=new CountDownLatch(1);\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(host, direct, latch);\n        for(Sender sender: senders)\n            sender.start();\n        latch.countDown();\n        for(Sender sender: senders)\n            sender.join();\n    }\n\n    protected class Sender extends Thread {\n        protected SocketChannel ch;\n        protected final CountDownLatch latch;\n        protected final InetAddress host;\n        protected final boolean direct;\n        protected final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.latch=latch;\n            this.host=host;\n            this.direct=direct;\n            buf=create(NioServerPerfTest.SIZE, direct);\n        }\n\n        public void run() {\n            try {\n                ch=SocketChannel.open();\n                ch.configureBlocking(true);\n                ch.connect(new InetSocketAddress(host, 7500));\n                latch.await();\n            }\n            catch(Exception e) {\n                e.printStackTrace();\n            }\n            for(;;) {\n                total_bytes_sent.add(NioServerPerfTest.SIZE);\n                if(total_bytes_sent.sum() > NioServerPerfTest.BYTES_TO_SEND)\n                    break;\n                buf.rewind();\n                try {\n                    ch.write(buf);\n                    total_msgs.increment();\n                }\n                catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(ch);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    private volatile boolean running = true;\n    private final LongAdder total_bytes_sent = new LongAdder();\n    private final LongAdder total_msgs = new LongAdder();\n    private Sender[] senders;\n\n    public ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    public void start(InetAddress host, boolean direct, int num_threads) throws IOException, InterruptedException {\n        sendMessages(host, direct, num_threads);\n        System.out.println(\"Press Enter to stop...\");\n        System.in.read();\n        running = false;\n        for (Sender sender : senders) {\n            sender.interrupt();\n        }\n        for (Sender sender : senders) {\n            sender.join();\n        }\n        System.out.println(\"Total bytes sent: \" + total_bytes_sent.sum());\n        System.out.println(\"Total messages sent: \" + total_msgs.sum());\n    }\n\n    private void sendMessages(InetAddress host, boolean direct, int num_threads) throws IOException {\n        CountDownLatch latch = new CountDownLatch(num_threads);\n        senders = new Sender[num_threads];\n        for (int i = 0; i < num_threads; i++) {\n            senders[i] = new Sender(host, direct, latch);\n            senders[i].start();\n        }\n        latch.await();\n    }\n\n    private class Sender extends Thread {\n        private final SocketChannel ch;\n        private final CountDownLatch latch;\n        private final InetAddress host;\n        private final boolean direct;\n        private final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) throws IOException {\n            this.ch = SocketChannel.open(new InetSocketAddress(host, 5454));\n            this.latch = latch;\n            this.host = host;\n            this.direct = direct;\n            this.buf = create(1024, direct);\n        }\n\n        @Override\n        public void run() {\n            try {\n                latch.countDown();\n                while (running) {\n                    buf.clear();\n                    buf.put((\"Hello from \" + Thread.currentThread().getName()).getBytes());\n                    buf.flip();\n                    ch.write(buf);\n                    total_bytes_sent.add(buf.limit());\n                    total_msgs.increment();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    ch.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class ReadSocketService implements Runnable {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024; // 1MB\n    private Selector selector;\n    private SocketChannel socketChannel;\n    private ByteBuffer byteBufferRead;\n    private AbstractHAReader haReader;\n    private int processPosition;\n    private long lastReadTimestamp;\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.socketChannel = socketChannel;\n        this.selector = Selector.open();\n        this.socketChannel.configureBlocking(false);\n        this.socketChannel.register(selector, SelectionKey.OP_READ);\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.haReader = new HAServerReader();\n        this.processPosition = 0;\n        this.lastReadTimestamp = System.currentTimeMillis();\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                if (selector.select(1000) > 0) {\n                    Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> iter = selectedKeys.iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        if (key.isReadable()) {\n                            readDataFromChannel(key);\n                        }\n                        iter.remove();\n                    }\n                } else {\n                    checkForTimeout();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            cleanupResources();\n        }\n    }\n\n    private void readDataFromChannel(SelectionKey key) throws IOException {\n        SocketChannel channel = (SocketChannel) key.channel();\n        int bytesRead = channel.read(byteBufferRead);\n        if (bytesRead == -1) {\n            key.cancel();\n            channel.close();\n        } else if (bytesRead > 0) {\n            lastReadTimestamp = System.currentTimeMillis();\n            processReadData();\n        }\n    }\n\n    private void processReadData() {\n        byteBufferRead.flip();\n        byteBufferRead.position(processPosition);\n        boolean success = haReader.processReadResult(byteBufferRead);\n        if (success) {\n            processPosition = byteBufferRead.position();\n            if (processPosition == byteBufferRead.limit()) {\n                compactByteBuffer();\n            }\n        } else {\n            resetAndReportError();\n        }\n    }\n\n    private void compactByteBuffer() {\n        byteBufferRead.compact();\n        processPosition = 0;\n    }\n\n    private void resetAndReportError() {\n        byteBufferRead.clear();\n        processPosition = 0;\n        reportErrorToHAService();\n    }\n\n    private void reportErrorToHAService() {\n        // Implementation to report error to HA service\n    }\n\n    private void checkForTimeout() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastReadTimestamp > 5000) { // 5 seconds timeout\n            try {\n                socketChannel.close();\n                selector.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void cleanupResources() {\n        try {\n            if (socketChannel != null && socketChannel.isOpen()) {\n                socketChannel.close();\n            }\n            if (selector != null && selector.isOpen()) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getServiceName() {\n        // Implementation to return service name with broker identifier if in container mode\n        return \"ReadSocketService\";\n    }\n}"
  },
  {
    "Task_id": 433,
    "Instruction": "Task Description: Implement a Java class that facilitates TCP-based communication using Java NIO (Non-blocking I/O) techniques, supporting both client and server modes with configurable options.\n\nClass Description: NioTransport is a class that provides TCP communication capabilities using Java NIO. It can operate in either server or client mode, supports direct buffers for performance optimization, and includes methods for starting/stopping communication, sending data, and receiving data through a callback mechanism.\n\nAttributes:\n- srv_channel: [ServerSocketChannel] - Server socket channel used in server mode\n- client_channel: [SocketChannel] - Client socket channel for communication\n- receiver_thread: [Receiver] - Thread handling incoming data reception\n- receiver: [RtReceiver] - Callback interface for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- server: [boolean] - Flag indicating if operating in server mode\n- direct_buffers: [boolean] - Flag indicating whether to use direct buffers\n- log: [Log] - Logger instance for logging messages\n\nMethods:\n- options(String... options) -> [void] - Configures transport options including server/client mode, host, port, and buffer type\n- receiver(RtReceiver receiver) -> [void] - Sets the receiver callback for incoming data\n- start(String... options) -> [void] - Starts the transport in either server or client mode based on configuration\n- stop() -> [void] - Stops the transport and releases resources\n- send(Object dest, byte[] buf, int offset, int length) -> [void] - Sends data through the established channel\n- Receiver.run() -> [void] - (Inner class method) Continuously receives data and forwards it to the registered receiver",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\n\npublic class NioTransport implements RtTransport {\n    protected ServerSocketChannel srv_channel;\n    protected SocketChannel       client_channel;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server, direct_buffers;\n    protected final Log           log=LogFactory.getLog(NioTransport.class);\n\n    public NioTransport() {\n    }\n\n    public void options(String... options) throws Exception {\n        if(options == null)\n            return;\n        for(int i=0; i < options.length; i++) {\n            if(options[i].equals(\"-server\")) {\n                server=true;\n                continue;\n            }\n            if(options[i].equals(\"-host\")) {\n                host=InetAddress.getByName(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-port\")) {\n                port=Integer.parseInt(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-direct\")) {\n                direct_buffers=Boolean.parseBoolean(options[++i]);\n            }\n        }\n        if(host == null)\n            host=InetAddress.getLocalHost();\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            srv_channel=ServerSocketChannel.open();\n            srv_channel.bind(new InetSocketAddress(host, port), 50);\n            System.out.println(\"server started (ctrl-c to kill)\");\n            for(;;) {\n                client_channel=srv_channel.accept();\n                receiver_thread=new Receiver();\n                receiver_thread.start();\n            }\n        }\n        else {\n            client_channel=SocketChannel.open();\n            client_channel.connect(new InetSocketAddress(host, port));\n            receiver_thread=new Receiver();\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(srv_channel, client_channel);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        ByteBuffer sbuf=ByteBuffer.wrap(buf, offset, length);\n        client_channel.write(sbuf);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            ByteBuffer buf=direct_buffers? ByteBuffer.allocateDirect(RoundTrip.PAYLOAD) : ByteBuffer.allocate(RoundTrip.PAYLOAD);\n            for(;;) {\n                try {\n                    buf.position(0);\n                    int num=client_channel.read(buf);\n                    if(num == -1)\n                        break;\n                    if(num != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + num);\n                    if(receiver != null) {\n                        buf.flip();\n                        int offset=buf.hasArray()? buf.arrayOffset() + buf.position() : buf.position(), len=buf.remaining();\n                        if(!buf.isDirect())\n                            receiver.receive(null, buf.array(), offset, len);\n                        else {\n                            byte[] tmp=new byte[len];\n                            buf.get(tmp, 0, len);\n                            receiver.receive(null, tmp, 0, len);\n                        }\n                    }\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(client_channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioTransport {\n    private ServerSocketChannel srv_channel;\n    private SocketChannel client_channel;\n    private Receiver receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private boolean direct_buffers;\n    private Log log;\n\n    public void options(String... options) {\n        for (String option : options) {\n            String[] parts = option.split(\"=\");\n            switch (parts[0]) {\n                case \"mode\":\n                    server = \"server\".equalsIgnoreCase(parts[1]);\n                    break;\n                case \"host\":\n                    try {\n                        host = InetAddress.getByName(parts[1]);\n                    } catch (IOException e) {\n                        log.error(\"Invalid host address: \" + parts[1]);\n                    }\n                    break;\n                case \"port\":\n                    port = Integer.parseInt(parts[1]);\n                    break;\n                case \"buffer_type\":\n                    direct_buffers = \"direct\".equalsIgnoreCase(parts[1]);\n                    break;\n            }\n        }\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public void start(String... options) {\n        options(options);\n        try {\n            Selector selector = Selector.open();\n            if (server) {\n                srv_channel = ServerSocketChannel.open();\n                srv_channel.bind(new InetSocketAddress(host, port));\n                srv_channel.configureBlocking(false);\n                srv_channel.register(selector, SelectionKey.OP_ACCEPT);\n            } else {\n                client_channel = SocketChannel.open(new InetSocketAddress(host, port));\n                client_channel.configureBlocking(false);\n                client_channel.register(selector, SelectionKey.OP_READ);\n            }\n            receiver_thread = new Receiver(selector);\n            new Thread(receiver_thread).start();\n        } catch (IOException e) {\n            log.error(\"Error starting transport: \" + e.getMessage());\n        }\n    }\n\n    public void stop() {\n        try {\n            if (srv_channel != null) srv_channel.close();\n            if (client_channel != null) client_channel.close();\n            if (receiver_thread != null) receiver_thread.stopRunning();\n        } catch (IOException e) {\n            log.error(\"Error stopping transport: \" + e.getMessage());\n        }\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) {\n        try {\n            ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);\n            buffer.put(buf, offset, length);\n            buffer.flip();\n            if (dest instanceof SocketChannel) {\n                ((SocketChannel) dest).write(buffer);\n            } else if (srv_channel != null) {\n                Set<SelectionKey> keys = srv_channel.keyFor(srv_channel.selector()).selector().keys();\n                for (SelectionKey key : keys) {\n                    if (key.channel() instanceof SocketChannel) {\n                        ((SocketChannel) key.channel()).write(buffer);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            log.error(\"Error sending data: \" + e.getMessage());\n        }\n    }\n\n    private class Receiver implements Runnable {\n        private final Selector selector;\n        private volatile boolean running = true;\n\n        public Receiver(Selector selector) {\n            this.selector = selector;\n        }\n\n        public void stopRunning() {\n            running = false;\n        }\n\n        @Override\n        public void run() {\n            while (running) {\n                try {\n                    selector.select();\n                    Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n                    while (keys.hasNext()) {\n                        SelectionKey key = keys.next();\n                        keys.remove();\n                        if (!key.isValid()) continue;\n                        if (key.isAcceptable()) {\n                            accept(key);\n                        } else if (key.isReadable()) {\n                            read(key);\n                        }\n                    }\n                } catch (IOException e) {\n                    log.error(\"Error in receiver thread: \" + e.getMessage());\n                }\n            }\n        }\n\n        private void accept(SelectionKey key) throws IOException {\n            ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n            SocketChannel clientChannel = serverChannel.accept();\n            clientChannel.configureBlocking(false);\n            clientChannel.register(selector, SelectionKey.OP_READ);\n        }\n\n        private void read(SelectionKey key) throws IOException {\n            SocketChannel channel = (SocketChannel) key.channel();\n            ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(1024) : ByteBuffer.allocate(1024);\n            int bytesRead = channel.read(buffer);\n            if (bytesRead == -1) {\n                channel.close();\n            } else {\n                buffer.flip();\n                byte[] data = new byte[buffer.remaining()];\n                buffer.get(data);\n                if (receiver != null) {\n                    receiver.onReceive(channel, data);\n                }\n            }\n        }\n    }\n\n    public interface RtReceiver {\n        void onReceive(SocketChannel channel, byte[] data);\n    }\n\n    public interface Log {\n        void error(String message);\n    }\n}"
  },
  {
    "Task_id": 434,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The client should handle connection establishment, data transmission with checksum verification, and proper resource management.\n\nClass Description: ClientController is a TCP client implementation that manages non-blocking communication with a server. It uses a producer-consumer pattern with an internal queue for packet handling and implements checksum verification for data integrity.\n\nAttributes:\n- inner: BlockingQueue<Packet> - Queue for storing packets to be sent to the server\n- lock: Object - Synchronization lock for thread-safe operations\n- remote: InetSocketAddress - Server address to connect to\n- thread: Thread - Worker thread for handling network operations\n- channel: SocketChannel - NIO channel for communication with the server\n\nMethods:\n- ClientController(String host, int port) -> None - Constructor that initializes the client with server address\n- start() -> void - Starts the client thread if not already running\n- put(Packet packet) -> boolean - Adds a packet to the send queue (non-blocking)\n- clear() -> void - Clears all pending packets from the queue\n- run() -> void - Main thread method that handles connection and I/O operations (internal to ClientThread)\n- write() -> void - Handles packet writing to the channel with checksum calculation (internal to ClientThread)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class ClientController {\n\n    private BlockingQueue<Packet> inner = new LinkedBlockingQueue<>(100);\n    private Object lock = new Object();\n    private InetSocketAddress remote;\n    private Thread thread = new ClientThread(remote);\n\n    public ClientController(String host, int port) {\n        remote = new InetSocketAddress(host, port);\n    }\n\n    public void start() {\n        if (thread.isAlive() || remote == null) {\n            return;\n        }\n        synchronized (lock) {\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        inner.clear();\n    }\n\n    class ClientThread extends Thread {\n        SocketAddress remote;\n        SocketChannel channel;\n\n        ClientThread(SocketAddress remote) {\n            this.remote = remote;\n        }\n\n        @Override\n        public void run() {\n            try {\n                channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                boolean isSuccess = channel.connect(new InetSocketAddress(30008));\n                if (!isSuccess) {\n                    while (!channel.finishConnect()) {\n                        System.out.println(\"Client is connecting...\");\n                    }\n                }\n                System.out.println(\"Client is connected.\");\n\n                Selector selector = Selector.open();\n                channel.register(selector, SelectionKey.OP_WRITE);\n                while (selector.isOpen()) {\n                    selector.select();\n                    Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        it.remove();\n                        if (!key.isValid()) {\n                            continue;\n                        }\n                        if (key.isWritable()) {\n                            write();\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (channel != null) {\n                    try {\n                        channel.close();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                inner.clear();\n            }\n        }\n\n        private void write() throws Exception {\n            Packet packet = inner.take();\n            synchronized (lock) {\n                ByteBuffer body = packet.getBuffer();\n                ByteBuffer head = ByteBuffer.allocate(4);\n                head.putInt(body.limit());\n                head.flip();\n                while (head.hasRemaining()) {\n                    channel.write(head);\n                }\n\n                Checksum checksum = new Adler32();\n                while (body.hasRemaining()) {\n                    checksum.update(body.get());\n                }\n\n                body.rewind();\n                while (body.hasRemaining()) {\n                    channel.write(body);\n                }\n\n                long cks = checksum.getValue();\n                ByteBuffer tail = ByteBuffer.allocate(8);\n                tail.putLong(cks);\n                tail.flip();\n                while (tail.hasRemaining()) {\n                    channel.write(tail);\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nclass Packet {\n    private byte[] data;\n    private int checksum;\n\n    public Packet(byte[] data) {\n        this.data = data;\n        this.checksum = calculateChecksum(data);\n    }\n\n    public byte[] getData() {\n        return data;\n    }\n\n    public int getChecksum() {\n        return checksum;\n    }\n\n    private int calculateChecksum(byte[] data) {\n        int sum = 0;\n        for (byte b : data) {\n            sum += b;\n        }\n        return sum;\n    }\n}\n\nclass ClientController implements Runnable {\n    private final BlockingQueue<Packet> inner = new LinkedBlockingQueue<>();\n    private final Object lock = new Object();\n    private final InetSocketAddress remote;\n    private Thread thread;\n    private SocketChannel channel;\n\n    public ClientController(String host, int port) {\n        this.remote = new InetSocketAddress(host, port);\n    }\n\n    public void start() {\n        synchronized (lock) {\n            if (thread == null || !thread.isAlive()) {\n                thread = new Thread(this);\n                thread.start();\n            }\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        inner.clear();\n    }\n\n    @Override\n    public void run() {\n        try {\n            channel = SocketChannel.open(remote);\n            channel.configureBlocking(false);\n\n            while (!Thread.currentThread().isInterrupted()) {\n                if (!inner.isEmpty()) {\n                    write();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (channel != null && channel.isOpen()) {\n                    channel.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void write() throws Exception {\n        Packet packet = inner.poll();\n        if (packet != null) {\n            byte[] data = packet.getData();\n            ByteBuffer buffer = ByteBuffer.allocate(data.length + Integer.BYTES);\n            buffer.putInt(packet.getChecksum());\n            buffer.put(data);\n            buffer.flip();\n\n            while (buffer.hasRemaining()) {\n                channel.write(buffer);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a Java class that manages TCP client connections using Java NIO (Non-blocking I/O) techniques, including connection establishment, data writing, and cleanup operations.\n\nClass Description: ConnectionWorker is a Runnable class that handles asynchronous TCP client connections using Java NIO. It manages connection tasks through a selector pattern, processes write operations, and performs periodic cleanup of stale connections. The class supports concurrent operations through queue-based task management.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging operations\n- stop: boolean - Volatile flag to control thread execution\n- selector: Selector - NIO selector for managing channels\n- myConnectQueue: BlockingQueue<ConnectTask> - Queue for pending connection tasks\n- myWriteQueue: BlockingQueue<WriteTask> - Queue for pending write operations\n- mySemaphore: Semaphore - Controls access to the worker thread\n- myKeyProcessors: List<KeyProcessor> - Processors for handling different channel operations\n- myTimeService: TimeService - Provides time-related functionality\n- lastCleanupTime: long - Timestamp of last cleanup operation\n- mySelectorTimeoutMillis: int - Timeout for selector operations\n- myCleanupTimeoutMillis: long - Timeout between cleanup operations\n- myCleanupProcessor: CleanupProcessor - Handles connection cleanup\n- myNewConnectionAllower: NewConnectionAllower - Controls new connection allowance\n\nMethods:\n- run(): void - Main execution method implementing Runnable interface\n- connectToPeersFromQueue(): void - Processes pending connection tasks from queue\n- processSelectedKeys(): void - Processes all ready selection keys\n- processSelectedKey(SelectionKey): void - Processes a single selection key\n- offerConnect(ConnectTask, int, TimeUnit): boolean - Adds new connection task to queue\n- addTaskToQueue(T, int, TimeUnit, BlockingQueue<T>): boolean - Generic method for adding tasks to queues\n- processWriteTasks(): void - Processes pending write operations (implied from code context)\n- cleanup(): void - Performs cleanup operations (implied from code context)\n- needRunCleanup(): boolean - Determines if cleanup is needed (implied from code context)",
    "Canonical_solution": "import com.turn.ttorrent.common.LoggerUtils;\nimport com.turn.ttorrent.common.TimeService;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.network.keyProcessors.CleanupProcessor;\nimport com.turn.ttorrent.network.keyProcessors.KeyProcessor;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n\n  private static final Logger logger = TorrentLoggerFactory.getLogger(ConnectionWorker.class);\n  private static final String SELECTOR_THREAD_NAME = \"Torrent channels manager thread\";\n  private volatile boolean stop = false;\n  private final Selector selector;\n  private final BlockingQueue<ConnectTask> myConnectQueue;\n  private final BlockingQueue<WriteTask> myWriteQueue;\n  private final Semaphore mySemaphore;\n  private final List<KeyProcessor> myKeyProcessors;\n  private final TimeService myTimeService;\n  private long lastCleanupTime;\n  private volatile int mySelectorTimeoutMillis;\n  private volatile long myCleanupTimeoutMillis;\n  private final CleanupProcessor myCleanupProcessor;\n  private final NewConnectionAllower myNewConnectionAllower;\n\n  public ConnectionWorker(Selector selector,\n                   List<KeyProcessor> keyProcessors,\n                   int selectorTimeoutMillis,\n                   int cleanupTimeoutMillis,\n                   TimeService timeService,\n                   CleanupProcessor cleanupProcessor,\n                   NewConnectionAllower myNewConnectionAllower) {\n    this.selector = selector;\n    this.myTimeService = timeService;\n    this.lastCleanupTime = timeService.now();\n    this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n    this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n    this.myCleanupProcessor = cleanupProcessor;\n    this.myNewConnectionAllower = myNewConnectionAllower;\n    this.mySemaphore = new Semaphore(1);\n    this.myConnectQueue = new LinkedBlockingQueue<ConnectTask>(100);\n    this.myKeyProcessors = keyProcessors;\n    this.myWriteQueue = new LinkedBlockingQueue<WriteTask>(5000);\n  }\n\n  @Override\n  public void run() {\n    try {\n      mySemaphore.acquire();\n    } catch (InterruptedException e) {\n      return;\n    }\n\n    final String oldName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(SELECTOR_THREAD_NAME);\n\n      while (!stop && (!Thread.currentThread().isInterrupted())) {\n        try {\n          logger.trace(\"try select keys from selector\");\n          int selected;\n          try {\n            selected = selector.select(mySelectorTimeoutMillis);\n          } catch (ClosedSelectorException e) {\n            break;\n          }\n          connectToPeersFromQueue();\n          processWriteTasks();\n          logger.trace(\"select keys from selector. Keys count is \" + selected);\n          if (selected != 0) {\n            processSelectedKeys();\n          }\n          if (needRunCleanup()) {\n            cleanup();\n          }\n        } catch (Throwable e) {\n          LoggerUtils.warnAndDebugDetails(logger, \"unable to select channel keys. Error message {}\", e.getMessage(), e);\n        }\n      }\n    } catch (Throwable e) {\n      LoggerUtils.errorAndDebugDetails(logger, \"exception on cycle iteration\", e);\n    } finally {\n      Thread.currentThread().setName(oldName);\n      mySemaphore.release();\n    }\n  }\n\n  private void connectToPeersFromQueue() {\n    ConnectTask connectTask;\n    while ((connectTask = myConnectQueue.poll()) != null) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      logger.debug(\"try connect to peer. Connect task is {}\", connectTask);\n      try {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_CONNECT, connectTask);\n        socketChannel.connect(new InetSocketAddress(connectTask.getHost(), connectTask.getPort()));\n      } catch (IOException e) {\n        LoggerUtils.warnAndDebugDetails(logger, \"unable connect. Connect task is {}\", connectTask, e);\n      }\n    }\n  }\n\n  private void processSelectedKeys() {\n    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n    for (SelectionKey key : selectionKeys) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      try {\n        processSelectedKey(key);\n      } catch (Exception e) {\n        logger.warn(\"error {} in processing key. Close channel {}\", e.getMessage(), key.channel());\n        logger.debug(\"\", e);\n        try {\n          key.channel().close();\n        } catch (IOException ioe) {\n          LoggerUtils.errorAndDebugDetails(logger, \"unable close bad channel\", ioe);\n        }\n      }\n    }\n    selectionKeys.clear();\n  }\n\n  private void processSelectedKey(SelectionKey key) throws IOException {\n    logger.trace(\"try process key for channel {}\", key.channel());\n    myCleanupProcessor.processSelected(key);\n    if (!key.channel().isOpen()) {\n      key.cancel();\n      return;\n    }\n    for (KeyProcessor keyProcessor : myKeyProcessors) {\n      if (keyProcessor.accept(key)) {\n        keyProcessor.process(key);\n      }\n    }\n  }\n\n  public boolean offerConnect(ConnectTask connectTask, int timeout, TimeUnit timeUnit) {\n    if (!myNewConnectionAllower.isNewConnectionAllowed()) {\n      logger.info(\"can not add connect task {} to queue. New connection is not allowed\", connectTask);\n      return false;\n    }\n    return addTaskToQueue(connectTask, timeout, timeUnit, myConnectQueue);\n  }\n\n  private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit timeUnit, BlockingQueue<T> queue) {\n    try {\n      if (queue.offer(task, timeout, timeUnit)) {\n        logger.trace(\"added task {}. Wake up selector\", task);\n        selector.wakeup();\n        return true;\n      }\n    } catch (InterruptedException e) {\n      logger.debug(\"Task {} interrupted before was added to queue\", task);\n    }\n    logger.debug(\"Task {} was not added\", task);\n    return false;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass ConnectionWorker implements Runnable {\n    private static final Logger logger = LoggerFactory.getLogger(ConnectionWorker.class);\n    private volatile boolean stop;\n    private Selector selector;\n    private BlockingQueue<ConnectTask> myConnectQueue = new LinkedBlockingQueue<>();\n    private BlockingQueue<WriteTask> myWriteQueue = new LinkedBlockingQueue<>();\n    private Semaphore mySemaphore = new Semaphore(1);\n    private List<KeyProcessor> myKeyProcessors = new ArrayList<>();\n    private TimeService myTimeService;\n    private long lastCleanupTime;\n    private int mySelectorTimeoutMillis;\n    private long myCleanupTimeoutMillis;\n    private CleanupProcessor myCleanupProcessor;\n    private NewConnectionAllower myNewConnectionAllower;\n\n    public ConnectionWorker(TimeService timeService, int selectorTimeoutMillis, long cleanupTimeoutMillis, CleanupProcessor cleanupProcessor, NewConnectionAllower newConnectionAllower) throws IOException {\n        this.selector = Selector.open();\n        this.myTimeService = timeService;\n        this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n        this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n        this.myCleanupProcessor = cleanupProcessor;\n        this.myNewConnectionAllower = newConnectionAllower;\n    }\n\n    @Override\n    public void run() {\n        while (!stop) {\n            try {\n                connectToPeersFromQueue();\n                processSelectedKeys();\n                processWriteTasks();\n                if (needRunCleanup()) {\n                    cleanup();\n                }\n                selector.select(mySelectorTimeoutMillis);\n            } catch (IOException e) {\n                logger.error(\"Error in selector loop\", e);\n            }\n        }\n    }\n\n    private void connectToPeersFromQueue() {\n        while (!myConnectQueue.isEmpty()) {\n            ConnectTask task = myConnectQueue.poll();\n            if (task != null && myNewConnectionAllower.allowNewConnection(task)) {\n                try {\n                    SocketChannel channel = SocketChannel.open();\n                    channel.configureBlocking(false);\n                    channel.connect(new InetSocketAddress(task.getHost(), task.getPort()));\n                    channel.register(selector, SelectionKey.OP_CONNECT, task);\n                } catch (IOException e) {\n                    logger.error(\"Failed to connect to peer\", e);\n                }\n            }\n        }\n    }\n\n    private void processSelectedKeys() {\n        Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n        while (keys.hasNext()) {\n            SelectionKey key = keys.next();\n            keys.remove();\n            processSelectedKey(key);\n        }\n    }\n\n    private void processSelectedKey(SelectionKey key) {\n        for (KeyProcessor processor : myKeyProcessors) {\n            if (processor.canProcess(key)) {\n                processor.process(key);\n            }\n        }\n    }\n\n    public boolean offerConnect(ConnectTask task, int timeout, TimeUnit unit) {\n        return addTaskToQueue(task, timeout, unit, myConnectQueue);\n    }\n\n    private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit unit, BlockingQueue<T> queue) {\n        try {\n            return queue.offer(task, timeout, unit);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            logger.warn(\"Interrupted while adding task to queue\", e);\n            return false;\n        }\n    }\n\n    private void processWriteTasks() {\n        while (!myWriteQueue.isEmpty()) {\n            WriteTask task = myWriteQueue.poll();\n            if (task != null) {\n                SelectionKey key = task.getChannel().keyFor(selector);\n                if (key != null && key.isValid() && key.isWritable()) {\n                    ByteBuffer buffer = ByteBuffer.wrap(task.getData());\n                    try {\n                        task.getChannel().write(buffer);\n                    } catch (IOException e) {\n                        logger.error(\"Failed to write data to channel\", e);\n                        key.cancel();\n                    }\n                }\n            }\n        }\n    }\n\n    private void cleanup() {\n        myCleanupProcessor.cleanup();\n        lastCleanupTime = myTimeService.getCurrentTimeMillis();\n    }\n\n    private boolean needRunCleanup() {\n        return myTimeService.getCurrentTimeMillis() - lastCleanupTime > myCleanupTimeoutMillis;\n    }\n\n    public void stop() {\n        this.stop = true;\n    }\n\n    interface KeyProcessor {\n        boolean canProcess(SelectionKey key);\n        void process(SelectionKey key);\n    }\n\n    interface TimeService {\n        long getCurrentTimeMillis();\n    }\n\n    interface CleanupProcessor {\n        void cleanup();\n    }\n\n    interface NewConnectionAllower {\n        boolean allowNewConnection(ConnectTask task);\n    }\n\n    static class ConnectTask {\n        private String host;\n        private int port;\n\n        public ConnectTask(String host, int port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        public String getHost() {\n            return host;\n        }\n\n        public int getPort() {\n            return port;\n        }\n    }\n\n    static class WriteTask {\n        private SocketChannel channel;\n        private byte[] data;\n\n        public WriteTask(SocketChannel channel, byte[] data) {\n            this.channel = channel;\n            this.data = data;\n        }\n\n        public SocketChannel getChannel() {\n            return channel;\n        }\n\n        public byte[] getData() {\n            return data;\n        }\n    }\n}"
  },
  {
    "Task_id": 437,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Apache MINA framework for RTMP (Real-Time Messaging Protocol) transport, with configurable network settings and JMX monitoring capabilities.\n\nClass Description: RTMPMinaTransport is a TCP server implementation using Apache MINA that handles RTMP connections. It provides configurable network parameters, thread pooling options, and JMX monitoring capabilities. The class manages server lifecycle (start/stop), connection handling, and performance statistics.\n\nAttributes:\n\n- log: Logger - Logger instance for the class\n- executor: ThreadPoolExecutor - Thread pool executor for custom acceptor mode\n- acceptor: SocketAcceptor - MINA socket acceptor instance\n- addresses: Set<String> - Set of IP addresses and ports to bind to\n- ioHandler: IoHandlerAdapter - Handler for IO events\n- ioThreads: int - Number of IO threads (default: 2 * available processors)\n- serviceManagerObjectName: ObjectName - JMX MBean object name\n- stats: IoServiceStatistics - MINA service statistics\n- enableMinaLogFilter: boolean - Flag to enable MINA logging filter\n- enableMinaMonitor: boolean - Flag to enable JMX monitoring\n- minaPollInterval: int - JMX poll interval in ms (default: 1000)\n- tcpNoDelay: boolean - TCP_NODELAY flag (default: true)\n- useHeapBuffers: boolean - Use heap buffers flag (default: true)\n- sendBufferSize: int - Socket send buffer size (default: 65536)\n- receiveBufferSize: int - Socket receive buffer size (default: 65536)\n- readerIdleTime: int - Reader idle time in seconds (default: 2)\n- trafficClass: int - IP traffic class (default: 0x08 | 0x10)\n- backlog: int - Connection backlog (default: 32)\n- thoughputCalcInterval: int - Throughput calculation interval (default: 1)\n- executorKeepAliveTime: long - Thread keep-alive time in ms (default: 60000)\n- enableDefaultAcceptor: boolean - Use default acceptor flag (default: true)\n- initialPoolSize: int - Initial thread pool size (default: 0)\n- maxPoolSize: int - Maximum thread pool size (default: processors + 1)\n- maxProcessorPoolSize: int - Maximum processor pool size (default: 16)\n- keepAlive: boolean - Socket keep-alive flag\n\nMethods:\n\n- start() throws Exception -> void - Starts the TCP server with configured settings\n- stop() -> void - Stops the TCP server and cleans up resources\n- setAddress(String address) -> void - Adds a single address to bind to\n- setAddresses(List<String> addrs) -> void - Adds multiple addresses to bind to\n- setIoHandler(IoHandlerAdapter rtmpIOHandler) -> void - Sets the IO handler\n- setIoThreads(int ioThreads) -> void - Sets number of IO threads\n- setSendBufferSize(int sendBufferSize) -> void - Sets send buffer size\n- setReceiveBufferSize(int receiveBufferSize) -> void - Sets receive buffer size\n- setTrafficClass(int trafficClass) -> void - Sets IP traffic class\n- setBacklog(int backlog) -> void - Sets connection backlog\n- setThoughputCalcInterval(int thoughputCalcInterval) -> void - Sets throughput calculation interval\n- setExecutorKeepAliveTime(long executorKeepAliveTime) -> void - Sets thread keep-alive time\n- setEnableDefaultAcceptor(boolean enableDefaultAcceptor) -> void - Sets default acceptor flag\n- setInitialPoolSize(int initialPoolSize) -> void - Sets initial thread pool size\n- setMaxPoolSize(int maxPoolSize) -> void - Sets maximum thread pool size\n- setMaxProcessorPoolSize(int maxProcessorPoolSize) -> void - Sets maximum processor pool size\n- setTcpNoDelay(boolean tcpNoDelay) -> void - Sets TCP_NODELAY flag\n- setKeepAlive(boolean keepAlive) -> void - Sets socket keep-alive flag\n- setUseHeapBuffers(boolean useHeapBuffers) -> void - Sets heap buffers flag\n- setEnableMinaLogFilter(boolean enableMinaLogFilter) -> void - Enables/disables MINA logging filter\n- setEnableMinaMonitor(boolean enableMinaMonitor) -> void - Enables/disables JMX monitoring\n- setMinaPollInterval(int minaPollInterval) -> void - Sets JMX poll interval\n- setReaderIdleTime(int readerIdleTime) -> void - Sets reader idle time\n- isEnableMinaLogFilter() -> boolean - Returns MINA logging filter status\n- getAddress() -> String - Returns bound addresses as string",
    "Canonical_solution": "import java.lang.management.ManagementFactory;\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.management.MBeanServer;\nimport javax.management.ObjectName;\nimport javax.management.StandardMBean;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.SimpleIoProcessorPool;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\nimport org.apache.mina.transport.socket.nio.NioProcessor;\nimport org.apache.mina.transport.socket.nio.NioSession;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.red5.server.jmx.mxbeans.RTMPMinaTransportMXBean;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RTMPMinaTransport implements RTMPMinaTransportMXBean {\n\n    private static final Logger log = LoggerFactory.getLogger(RTMPMinaTransport.class);\n\n    private ThreadPoolExecutor executor;\n\n    protected SocketAcceptor acceptor;\n\n    protected Set<String> addresses = new HashSet<String>();\n\n    protected IoHandlerAdapter ioHandler;\n\n    protected int ioThreads = Runtime.getRuntime().availableProcessors() * 2;\n\n    protected ObjectName serviceManagerObjectName;\n\n    protected IoServiceStatistics stats;\n\n    public void start() throws Exception {\n        IoBuffer.setUseDirectBuffer(!useHeapBuffers);\n        if (useHeapBuffers) {\n            IoBuffer.setAllocator(new SimpleBufferAllocator());\n        }\n        if (enableDefaultAcceptor) {\n            acceptor = new NioSocketAcceptor(ioThreads);\n        } else {\n            SimpleIoProcessorPool<NioSession> pool = new SimpleIoProcessorPool<NioSession>(NioProcessor.class, maxProcessorPoolSize);\n            executor = new ThreadPoolExecutor(initialPoolSize, maxPoolSize, executorKeepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(Short.MAX_VALUE));\n            acceptor = new NioSocketAcceptor(executor, pool);\n        }\n        if (enableMinaLogFilter) {\n            DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();\n            LoggingFilter logFilter = new LoggingFilter(RTMPMinaTransport.class);\n            chain.addLast(\"logger\", logFilter);\n        }\n        acceptor.setCloseOnDeactivation(true);\n        acceptor.setHandler(ioHandler);\n        acceptor.setBacklog(backlog);\n        SocketSessionConfig sessionConf = acceptor.getSessionConfig();\n        sessionConf.setReuseAddress(true);\n        sessionConf.setTcpNoDelay(tcpNoDelay);\n        sessionConf.setSendBufferSize(sendBufferSize);\n        sessionConf.setReceiveBufferSize(receiveBufferSize);\n        sessionConf.setMaxReadBufferSize(receiveBufferSize);\n        sessionConf.setThroughputCalculationInterval(thoughputCalcInterval);\n        sessionConf.setReaderIdleTime(readerIdleTime);\n        sessionConf.setKeepAlive(keepAlive);\n        if (trafficClass != -1) {\n            sessionConf.setTrafficClass(trafficClass);\n        }\n        acceptor.setReuseAddress(true);\n        Set<InetSocketAddress> socketAddresses = new HashSet<InetSocketAddress>();\n        for (String addr : addresses) {\n            if (addr.indexOf(':') != -1) {\n                String[] parts = addr.split(\":\");\n                socketAddresses.add(new InetSocketAddress(parts[0], Integer.valueOf(parts[1])));\n            } else {\n                socketAddresses.add(new InetSocketAddress(addr, 1935));\n            }\n        }\n        acceptor.bind(socketAddresses);\n        if (enableMinaMonitor) {\n            stats = new IoServiceStatistics((AbstractIoService) acceptor);\n            stats.setThroughputCalculationInterval(minaPollInterval);\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                serviceManagerObjectName = new ObjectName(\"org.red5.server:type=RTMPMinaTransport\");\n                mbs.registerMBean(new StandardMBean(this, RTMPMinaTransportMXBean.class, true), serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx registration\", e);\n            }\n        }\n    }\n\n    public void stop() {\n        acceptor.unbind();\n        if (!enableDefaultAcceptor) {\n            executor.shutdownNow();\n        }\n        acceptor.dispose(false);\n        if (serviceManagerObjectName != null) {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                mbs.unregisterMBean(serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx unregistration\", e);\n            }\n        }\n    }\n\n    public void setAddress(String address) {\n        addresses.add(address);\n    }\n\n    public void setAddresses(List<String> addrs) {\n        for (String addr : addrs) {\n            addresses.add(addr);\n        }\n    }\n\n    public void setIoHandler(IoHandlerAdapter rtmpIOHandler) {\n        this.ioHandler = rtmpIOHandler;\n    }\n\n    public void setIoThreads(int ioThreads) {\n        this.ioThreads = ioThreads;\n    }\n\n    protected boolean enableMinaLogFilter;\n\n    protected boolean enableMinaMonitor;\n\n    protected int minaPollInterval = 1000;\n\n    protected boolean tcpNoDelay = true;\n\n    protected boolean useHeapBuffers = true;\n\n    protected int sendBufferSize = 65536;\n\n    protected int receiveBufferSize = 65536;\n\n    private int readerIdleTime = 2;\n\n    private int trafficClass = 0x08 | 0x10;\n\n    private int backlog = 32;\n\n    private int thoughputCalcInterval = 1;\n\n    private long executorKeepAliveTime = 60000;\n\n    private boolean enableDefaultAcceptor = true;\n\n    private int initialPoolSize = 0;\n\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n\n    private int maxProcessorPoolSize = 16;\n\n    private boolean keepAlive;\n\n    public void setSendBufferSize(int sendBufferSize) {\n        this.sendBufferSize = sendBufferSize;\n    }\n\n    public void setReceiveBufferSize(int receiveBufferSize) {\n        this.receiveBufferSize = receiveBufferSize;\n    }\n\n    public void setTrafficClass(int trafficClass) {\n        this.trafficClass = trafficClass;\n    }\n\n    public void setBacklog(int backlog) {\n        this.backlog = backlog;\n    }\n\n    public void setThoughputCalcInterval(int thoughputCalcInterval) {\n        this.thoughputCalcInterval = thoughputCalcInterval;\n    }\n\n    public void setExecutorKeepAliveTime(long executorKeepAliveTime) {\n        this.executorKeepAliveTime = executorKeepAliveTime;\n    }\n\n    public void setEnableDefaultAcceptor(boolean enableDefaultAcceptor) {\n        this.enableDefaultAcceptor = enableDefaultAcceptor;\n    }\n\n    public void setInitialPoolSize(int initialPoolSize) {\n        this.initialPoolSize = initialPoolSize;\n    }\n\n    public void setMaxPoolSize(int maxPoolSize) {\n        this.maxPoolSize = maxPoolSize;\n    }\n\n    public void setMaxProcessorPoolSize(int maxProcessorPoolSize) {\n        this.maxProcessorPoolSize = maxProcessorPoolSize;\n    }\n\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        this.tcpNoDelay = tcpNoDelay;\n    }\n\n    public void setKeepAlive(boolean keepAlive) {\n        this.keepAlive = keepAlive;\n    }\n\n    public void setUseHeapBuffers(boolean useHeapBuffers) {\n        this.useHeapBuffers = useHeapBuffers;\n    }\n\n    public boolean isEnableMinaLogFilter() {\n        return enableMinaLogFilter;\n    }\n\n    public void setEnableMinaLogFilter(boolean enableMinaLogFilter) {\n        this.enableMinaLogFilter = enableMinaLogFilter;\n    }\n\n    public void setEnableMinaMonitor(boolean enableMinaMonitor) {\n        this.enableMinaMonitor = enableMinaMonitor;\n    }\n\n    public void setMinaPollInterval(int minaPollInterval) {\n        this.minaPollInterval = minaPollInterval;\n    }\n\n    public void setReaderIdleTime(int readerIdleTime) {\n        this.readerIdleTime = readerIdleTime;\n    }\n\n    public String getAddress() {\n        return addresses.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "wrong_result": "import org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\n\nimport javax.management.*;\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class RTMPMinaTransport {\n    private final Logger log = Logger.getLogger(RTMPMinaTransport.class);\n    private ThreadPoolExecutor executor;\n    private SocketAcceptor acceptor;\n    private final Set<String> addresses = new HashSet<>();\n    private IoHandlerAdapter ioHandler;\n    private int ioThreads = Runtime.getRuntime().availableProcessors() * 2;\n    private ObjectName serviceManagerObjectName;\n    private IoServiceStatistics stats;\n    private boolean enableMinaLogFilter = false;\n    private boolean enableMinaMonitor = false;\n    private int minaPollInterval = 1000;\n    private boolean tcpNoDelay = true;\n    private boolean useHeapBuffers = true;\n    private int sendBufferSize = 65536;\n    private int receiveBufferSize = 65536;\n    private int readerIdleTime = 2;\n    private int trafficClass = 0x08 | 0x10;\n    private int backlog = 32;\n    private int thoughputCalcInterval = 1;\n    private long executorKeepAliveTime = 60000;\n    private boolean enableDefaultAcceptor = true;\n    private int initialPoolSize = 0;\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n    private int maxProcessorPoolSize = 16;\n    private boolean keepAlive = false;\n\n    public void start() throws Exception {\n        acceptor = new NioSocketAcceptor();\n        if (enableDefaultAcceptor) {\n            acceptor.setHandler(ioHandler);\n        } else {\n            acceptor.setHandler(new IoHandlerAdapter() {\n                @Override\n                public void sessionCreated(org.apache.mina.core.session.IoSession session) throws Exception {\n                    super.sessionCreated(session);\n                    if (enableMinaLogFilter) {\n                        acceptor.getFilterChain().addLast(\"logger\", new LoggingFilter());\n                    }\n                }\n\n                @Override\n                public void sessionIdle(org.apache.mina.core.session.IoSession session, IdleStatus status) throws Exception {\n                    super.sessionIdle(session, status);\n                }\n            });\n        }\n\n        acceptor.getSessionConfig().setTcpNoDelay(tcpNoDelay);\n        acceptor.getSessionConfig().setUseReadOperation(true);\n        acceptor.getSessionConfig().setReadBufferSize(receiveBufferSize);\n        acceptor.getSessionConfig().setSendBufferSize(sendBufferSize);\n        acceptor.getSessionConfig().setTrafficClass(trafficClass);\n        acceptor.getSessionConfig().setSoLinger(-1);\n        acceptor.getSessionConfig().setSoTimeout(0);\n        acceptor.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE, readerIdleTime);\n        acceptor.getSessionConfig().setUseHeapBuffers(useHeapBuffers);\n        acceptor.setBacklog(backlog);\n\n        if (!enableDefaultAcceptor) {\n            executor = (ThreadPoolExecutor) Executors.newScheduledThreadPool(maxProcessorPoolSize);\n            acceptor.setExecutor(executor);\n        }\n\n        for (String address : addresses) {\n            String[] parts = address.split(\":\");\n            acceptor.bind(new InetSocketAddress(parts[0], Integer.parseInt(parts[1])));\n        }\n\n        stats = acceptor.getStatistics();\n\n        if (enableMinaMonitor) {\n            serviceManagerObjectName = new ObjectName(\"org.apache.mina:type=RTMPMinaTransport\");\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            mbs.registerMBean(this, serviceManagerObjectName);\n        }\n    }\n\n    public void stop() {\n        if (acceptor != null) {\n            acceptor.unbind();\n            acceptor.dispose();\n            if (executor != null) {\n                executor.shutdown();\n            }\n        }\n    }\n\n    public void setAddress(String address) {\n        addresses.add(address);\n    }\n\n    public void setAddresses(List<String> addrs) {\n        addresses.addAll(addrs);\n    }\n\n    public void setIoHandler(IoHandlerAdapter rtmpIOHandler) {\n        this.ioHandler = rtmpIOHandler;\n    }\n\n    public void setIoThreads(int ioThreads) {\n        this.ioThreads = ioThreads;\n    }\n\n    public void setSendBufferSize(int sendBufferSize) {\n        this.sendBufferSize = sendBufferSize;\n    }\n\n    public void setReceiveBufferSize(int receiveBufferSize) {\n        this.receiveBufferSize = receiveBufferSize;\n    }\n\n    public void setTrafficClass(int trafficClass) {\n        this.trafficClass = trafficClass;\n    }\n\n    public void setBacklog(int backlog) {\n        this.backlog = backlog;\n    }\n\n    public void setThoughputCalcInterval(int thoughputCalcInterval) {\n        this.thoughputCalcInterval = thoughputCalcInterval;\n    }\n\n    public void setExecutorKeepAliveTime(long executorKeepAliveTime) {\n        this.executorKeepAliveTime = executorKeepAliveTime;\n    }\n\n    public void setEnableDefaultAcceptor(boolean enableDefaultAcceptor) {\n        this.enableDefaultAcceptor = enableDefaultAcceptor;\n    }\n\n    public void setInitialPoolSize(int initialPoolSize) {\n        this.initialPoolSize = initialPoolSize;\n    }\n\n    public void setMaxPoolSize(int maxPoolSize) {\n        this.maxPoolSize = maxPoolSize;\n    }\n\n    public void setMaxProcessorPoolSize(int maxProcessorPoolSize) {\n        this.maxProcessorPoolSize = maxProcessorPoolSize;\n    }\n\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        this.tcpNoDelay = tcpNoDelay;\n    }\n\n    public void setKeepAlive(boolean keepAlive) {\n        this.keepAlive = keepAlive;\n    }\n\n    public void setUseHeapBuffers(boolean useHeapBuffers) {\n        this.useHeapBuffers = useHeapBuffers;\n    }\n\n    public void setEnableMinaLogFilter(boolean enableMinaLogFilter) {\n        this.enableMinaLogFilter = enableMinaLogFilter;\n    }\n\n    public void setEnableMinaMonitor(boolean enableMinaMonitor) {\n        this.enableMinaMonitor = enableMinaMonitor;\n    }\n\n    public void setMinaPollInterval(int minaPollInterval) {\n        this.minaPollInterval = minaPollInterval;\n    }\n\n    public void setReaderIdleTime(int readerIdleTime) {\n        this.readerIdleTime = readerIdleTime;\n    }\n\n    public boolean isEnableMinaLogFilter() {\n        return enableMinaLogFilter;\n    }\n\n    public String getAddress() {\n        return String.join(\", \", addresses);\n    }\n\n    public int getActiveSessionsCount() {\n        return stats.getActiveSessionsCount();\n    }\n\n    public int getReadMessages() {\n        return stats.getReadMessages();\n    }\n\n    public int getWrittenMessages() {\n        return stats.getWrittenMessages();\n    }\n\n    public long getReadBytes() {\n        return stats.getReadBytes();\n    }\n\n    public long getWrittenBytes() {\n        return stats.getWrittenBytes();\n    }\n\n    public int getThroughputCalcInterval() {\n        return thoughputCalcInterval;\n    }\n\n    public int getMaxReadBytes() {\n        return stats.getMaxReadBytes();\n    }\n\n    public int getMaxWrittenBytes() {\n        return stats.getMaxWrittenBytes();\n    }\n\n    public int getMaxReadMessages() {\n        return stats.getMaxReadMessages();\n    }\n\n    public int getMaxWrittenMessages() {\n        return stats.getMaxWrittenMessages();\n    }\n\n    public int getCumulativeReadMessages() {\n        return stats.getCumulativeReadMessages();\n    }\n\n    public int getCumulativeWrittenMessages() {\n        return stats.getCumulativeWrittenMessages();\n    }\n\n    public long getCumulativeReadBytes() {\n        return stats.getCumulativeReadBytes();\n    }\n\n    public long getCumulativeWrittenBytes() {\n        return stats.getCumulativeWrittenBytes();\n    }\n}"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass NIOAcceptor extends Thread {\n    private int port;\n    private Selector selector;\n    private ServerSocketChannel serverChannel;\n    private FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor = 0;\n    private long acceptCount = 0;\n    private AcceptIdGenerator idGenerator = new AcceptIdGenerator();\n\n    public NIOAcceptor(int port, FrontendConnectionFactory factory, NIOProcessor[] processors) throws IOException {\n        this.port = port;\n        this.factory = factory;\n        this.processors = processors;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                selector.select();\n                Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n                while (keys.hasNext()) {\n                    SelectionKey key = keys.next();\n                    if (key.isAcceptable()) {\n                        accept();\n                    }\n                    keys.remove();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void accept() {\n        try {\n            SocketChannel channel = serverChannel.accept();\n            if (channel != null) {\n                channel.configureBlocking(false);\n                long id = idGenerator.getId();\n                FrontendConnection conn = factory.create(channel, id);\n                NIOProcessor processor = nextProcessor();\n                processor.addConnection(conn);\n                acceptCount++;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n    public void closeChannel(SocketChannel channel) {\n        try {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class AcceptIdGenerator {\n        private AtomicLong acceptId = new AtomicLong(0);\n\n        public long getId() {\n            return acceptId.getAndIncrement();\n        }\n    }\n}\n\ninterface FrontendConnectionFactory {\n    FrontendConnection create(SocketChannel channel, long id);\n}\n\ninterface FrontendConnection {\n    // Define methods for handling connections\n}\n\ninterface NIOProcessor {\n    void addConnection(FrontendConnection conn);\n}"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.List;\n\npublic class MulticastSender {\n    private DatagramSocket sock;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n    private ProtocolFamily prot_family;\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) throws IOException {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n        this.prot_family = bind_addr instanceof Inet6Address ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n        this.sock = new DatagramSocket(null);\n        sock.setReuseAddress(true);\n        sock.bind(new InetSocketAddress(bind_addr, local_port));\n        sock.setTimeToLive(ttl);\n        sock.joinGroup(new InetSocketAddress(mcast_addr, mcast_port), NetworkInterface.getByInetAddress(bind_addr));\n    }\n\n    public void start() throws IOException {\n        DatagramChannel channel = sock.getChannel();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            ByteBuffer buffer = ByteBuffer.wrap(line.getBytes());\n            channel.send(buffer, new InetSocketAddress(mcast_addr, mcast_port));\n        }\n    }\n\n    public void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) throws IOException {\n        for (NetworkInterface iface : interfaces) {\n            if (iface.supportsMulticast()) {\n                s.joinGroup(new InetSocketAddress(mcast_addr, mcast_port), iface);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 449,
    "Instruction": "Task Description: Implement a TCP proxy server using Vert.x that forwards incoming connections to a remote server after writing a custom header.\n\nClass Description: The HAProxy class acts as a TCP proxy server that listens for incoming connections, establishes connections to a remote server, writes a specified header to the remote connection, and then pipes data bidirectionally between the client and server.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and error messages\n- HOST: String - The host address where the proxy server will listen (default: \"localhost\")\n- PORT: int - The port number where the proxy server will listen (default: 11080)\n- remoteAddress: SocketAddress - The address of the remote server to forward connections to\n- header: Buffer - The header data to write to the remote connection\n- server: NetServer - The Vert.x TCP server instance\n- client: NetClient - The Vert.x TCP client instance for connecting to remote server\n- connectionRemoteAddress: SocketAddress - Stores the remote address of the established connection\n- connectionLocalAddress: SocketAddress - Stores the local address of the established connection\n\nMethods:\n- HAProxy(SocketAddress remoteAddress, Buffer header) -> HAProxy - Constructor that initializes the proxy with remote server address and header data\n- start(Vertx vertx) -> HAProxy - Starts the proxy server, configures connection handling, and returns the instance (throws Exception if startup fails)\n- stop() -> void - Stops the proxy server and cleans up resources\n- getConnectionRemoteAddress() -> SocketAddress - Returns the remote address of the established connection\n- getConnectionLocalAddress() -> SocketAddress - Returns the local address of the established connection",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.net.SocketAddress;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class HAProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        NetServerOptions options = new NetServerOptions();\n        options.setHost(HOST).setPort(PORT);\n        server = vertx.createNetServer(options);\n        client = vertx.createNetClient();\n\n        server.connectHandler(socket -> {\n            socket.pause();\n            client.connect(remoteAddress).onComplete(result -> {\n                if (result.succeeded()) {\n                    log.debug(\"connected, writing header\");\n                    NetSocket clientSocket = result.result();\n                    connectionRemoteAddress = clientSocket.remoteAddress();\n                    connectionLocalAddress = clientSocket.localAddress();\n                    clientSocket.write(header).onSuccess(u -> {\n                        log.debug(\"starting pump\");\n                        socket.closeHandler(v -> clientSocket.close());\n                        clientSocket.closeHandler(v -> socket.close());\n                        socket.pipeTo(clientSocket);\n                        clientSocket.pipeTo(socket);\n                        socket.resume();\n                    }).onFailure(u -> {\n                        log.error(\"exception writing header\", result.cause());\n                        socket.close();\n                    });\n                } else {\n                    log.error(\"exception\", result.cause());\n                    socket.close();\n                }\n            });\n        });\n\n        CompletableFuture<Void> fut = new CompletableFuture<>();\n        server.listen().onComplete(ar -> {\n            if (ar.succeeded()) {\n                fut.complete(null);\n            } else {\n                fut.completeExceptionally(ar.cause());\n            }\n        });\n        fut.get(10, TimeUnit.SECONDS);\n        log.debug(\"HAProxy server started\");\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n            server = null;\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "import io.vertx.core.AbstractVerticle;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.logging.Logger;\nimport io.vertx.core.logging.LoggerFactory;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.SocketAddress;\n\npublic class HAProxy extends AbstractVerticle {\n\n    private static final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        client = vertx.createNetClient();\n        server = vertx.createNetServer();\n\n        server.connectHandler(clientSocket -> {\n            connectionLocalAddress = clientSocket.localAddress();\n            connectionRemoteAddress = clientSocket.remoteAddress();\n\n            client.connect(remoteAddress.port(), remoteAddress.host(), res -> {\n                if (res.succeeded()) {\n                    var serverSocket = res.result();\n                    serverSocket.write(header);\n\n                    clientSocket.handler(serverSocket::write);\n                    serverSocket.handler(clientSocket::write);\n\n                    clientSocket.closeHandler(v -> serverSocket.close());\n                    serverSocket.closeHandler(v -> clientSocket.close());\n\n                    clientSocket.exceptionHandler(err -> {\n                        log.error(\"Error on client socket\", err);\n                        serverSocket.close();\n                    });\n\n                    serverSocket.exceptionHandler(err -> {\n                        log.error(\"Error on server socket\", err);\n                        clientSocket.close();\n                    });\n                } else {\n                    log.error(\"Failed to connect to remote server\", res.cause());\n                    clientSocket.close();\n                }\n            });\n        });\n\n        server.listen(PORT, HOST, res -> {\n            if (res.succeeded()) {\n                log.info(\"HAProxy started on \" + HOST + \":\" + PORT);\n            } else {\n                log.error(\"Failed to start HAProxy\", res.cause());\n                throw new RuntimeException(res.cause());\n            }\n        });\n\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Vert.x framework to handle multiple client connections, process incoming data, and manage server lifecycle operations.\n\nClass Description: The VertxTcpServer class provides functionality to start, stop, and manage a TCP server using Vert.x. It handles client connections, processes incoming data with echo functionality, and manages connection events.\n\nAttributes:\n- server: [NetServer] - The Vert.x NetServer instance that manages TCP connections\n\nMethods:\n- startServer(Vertx vertx, int port, String host) -> void - Initializes and starts the TCP server on specified host and port\n- handleConnection(NetSocket socket) -> void - Handles incoming client connections, processes data, and manages connection events\n- stopServer() -> void - Gracefully shuts down the TCP server\n\nMethod Details:\n1. startServer(Vertx vertx, int port, String host) -> void\n   - Input Parameters:\n     - vertx: Vertx - The Vert.x instance\n     - port: int - The port number to listen on\n     - host: String - The host address to bind to\n   - Description: Configures server options, creates NetServer instance, sets up connection handler, and starts listening for connections\n\n2. handleConnection(NetSocket socket) -> void\n   - Input Parameters:\n     - socket: NetSocket - The client connection socket\n   - Description: Sets up handlers for incoming data (echoes back received data), connection closure, and exceptions\n\n3. stopServer() -> void\n   - Description: Closes the server and all active connections, with completion handler for success/failure notification",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.buffer.Buffer;\n\npublic class VertxTcpServer {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setPort(port).setHost(host);\n        server = vertx.createNetServer(options);\n\n        server.connectHandler(socket -> {\n            handleConnection(socket);\n        });\n\n        server.listen().onComplete(res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on port: \" + port);\n            } else {\n                System.out.println(\"Failed to bind: \" + res.cause().getMessage());\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.length() + \" bytes\");\n            socket.write(Buffer.buffer(\"Echo: \").appendBuffer(buffer));\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Connection error: \" + err.getMessage());\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close().onComplete(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server closed successfully\");\n                } else {\n                    System.err.println(\"Failed to close server: \" + res.cause().getMessage());\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetSocket;\n\npublic class VertxTcpServer {\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        server = vertx.createNetServer();\n        server.connectHandler(this::handleConnection);\n        server.listen(port, host, res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on \" + host + \":\" + port);\n            } else {\n                System.err.println(\"Failed to start server\");\n                res.cause().printStackTrace();\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.toString());\n            socket.write(buffer); // Echo back the received data\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Client disconnected\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Exception on socket: \" + err.getMessage());\n            socket.close();\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server stopped successfully\");\n                } else {\n                    System.err.println(\"Failed to stop server\");\n                    res.cause().printStackTrace();\n                }\n            });\n        }\n    }\n}"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "import io.vertx.core.AbstractVerticle;\nimport io.vertx.core.Promise;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.VertxOptions;\nimport io.vertx.core.eventbus.EventBusOptions;\nimport io.vertx.core.impl.VertxInternal;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.Handler;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n    private EventBusOptions options;\n    private NetServer server;\n\n    public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n        super(vertx);\n        this.options = options.getEventBusOptions();\n        this.server = vertx.createNetServer(getServerOptions());\n    }\n\n    private NetServerOptions getServerOptions() {\n        NetServerOptions netServerOptions = new NetServerOptions();\n        netServerOptions.setPort(getClusterPort());\n        netServerOptions.setHost(getClusterHost());\n        return netServerOptions;\n    }\n\n    public void start(Promise<Void> promise) {\n        server.connectHandler(getServerHandler()).listen(ar -> {\n            if (ar.succeeded()) {\n                promise.complete();\n            } else {\n                promise.fail(ar.cause());\n            }\n        });\n    }\n\n    private Handler<NetSocket> getServerHandler() {\n        return netSocket -> {\n            netSocket.handler(buffer -> {\n                // Process incoming messages and deliver them locally within the cluster\n                String message = buffer.toString();\n                // Example of delivering a message\n                this.send(\"address\", message);\n            });\n        };\n    }\n\n    public int getClusterPort() {\n        return options.getPort();\n    }\n\n    public String getClusterHost() {\n        return options.getHost() != null ? options.getHost() : \"0.0.0.0\";\n    }\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.CompletableFuture;\nimport org.apache.hc.client5.http.async.methods.SimpleHttpRequest;\nimport org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\nimport org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\nimport org.apache.hc.client5.http.impl.async.HttpAsyncClients;\nimport org.apache.hc.core5.http.ContentType;\nimport org.apache.hc.core5.http.ParseException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n    private final Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final CloseableHttpAsyncClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        this.mIcecastConfiguration = icecastConfiguration;\n        this.mHttpClient = HttpAsyncClients.createDefault();\n        this.mHttpClient.start();\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        String metadata = constructMetadataString(identifierCollection);\n        String url = constructUrl();\n\n        SimpleHttpRequest request = SimpleHttpRequest.post(url)\n                .setBody(metadata, ContentType.APPLICATION_FORM_URLENCODED)\n                .setHeader(\"Authorization\", \"Basic \" + encodeCredentials());\n\n        CompletableFuture.runAsync(() -> {\n            try {\n                SimpleHttpResponse response = mHttpClient.execute(request, null).get();\n                if (response.getCode() != 200) {\n                    mLog.error(\"Failed to update metadata: HTTP \" + response.getCode());\n                }\n            } catch (Exception e) {\n                if (!mConnectionLoggingSuppressed) {\n                    mLog.error(\"Error updating metadata\", e);\n                    mConnectionLoggingSuppressed = true;\n                }\n            }\n        });\n    }\n\n    private String constructMetadataString(IdentifierCollection identifierCollection) {\n        StringBuilder sb = new StringBuilder();\n        for (String key : identifierCollection.getKeys()) {\n            if (sb.length() > 0) {\n                sb.append(\"&\");\n            }\n            sb.append(key).append(\"=\").append(URLEncoder.encode(identifierCollection.getValue(key), StandardCharsets.UTF_8));\n        }\n        return sb.toString();\n    }\n\n    private String constructUrl() {\n        return String.format(\"http://%s:%d/admin/metadata?mount=/%s\",\n                mIcecastConfiguration.getHost(),\n                mIcecastConfiguration.getPort(),\n                mIcecastConfiguration.getMountPoint());\n    }\n\n    private String encodeCredentials() {\n        return Base64.getEncoder().encodeToString(\n                (mIcecastConfiguration.getUsername() + \":\" + mIcecastConfiguration.getPassword()).getBytes(StandardCharsets.UTF_8));\n    }\n}"
  },
  {
    "Task_id": 488,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, and disconnections, supporting both group broadcasting and private messaging.\n\nClass Description: WebSocket server endpoint class that manages client connections through WebSocket protocol, maintains active connections in a concurrent map, and provides message broadcasting and targeted messaging functionality.\n\nAttributes:\n- session: [Session] - The WebSocket session object representing a client connection\n- name: [String] - The identifier for the connected client\n- webSocketSet: [ConcurrentHashMap<String, WebSocket>] - Thread-safe map storing all active WebSocket connections with client names as keys\n\nMethods:\n- OnOpen([Session session, @PathParam(value = \"name\") String name]) -> [void] - Handles new client connections, stores the session and name, and notifies all clients\n- OnClose() -> [void] - Handles client disconnections, removes from active connections, and notifies all clients\n- OnMessage([String messageStr]) -> [void] - Processes incoming messages, routing to either private or group messaging based on message format\n- onError([Session session, Throwable error]) -> [void] - Handles any errors that occur during WebSocket communication\n- GroupSending([String message]) -> [void] - Broadcasts a message to all connected clients\n- AppointSending([String name, String message]) -> [void] - Sends a message to a specific client identified by name",
    "Canonical_solution": "import javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\n@ServerEndpoint(\"/websocket/{name}\")\npublic class WebSocket {\n    private Session session;\n    private String name;\n    private static ConcurrentHashMap<String, WebSocket> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void OnOpen(Session session, @PathParam(value = \"name\") String name) {\n        this.session = session;\n        this.name = name;\n        webSocketSet.put(name, this);\n        GroupSending(name + \" \u6765\u4e86\");\n    }\n\n    @OnClose\n    public void OnClose() {\n        webSocketSet.remove(this.name);\n        GroupSending(name + \" \u8d70\u4e86\");\n    }\n\n    @OnMessage\n    public void OnMessage(String messageStr) {\n        if (messageStr.indexOf(\"TOUSER\") == 0) {\n            String[] split = messageStr.split(\";\");\n            String[] split1 = split[0].split(\":\");\n            String[] split2 = split[1].split(\":\");\n            String name = split1[1];\n            String message = split2[1];\n            AppointSending(name, message);\n        } else {\n            GroupSending(messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void GroupSending(String message) {\n        for (String name : webSocketSet.keySet()) {\n            try {\n                webSocketSet.get(name).session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void AppointSending(String name, String message) {\n        try {\n            webSocketSet.get(name).session.getBasicRemote().sendText(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "import javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport java.io.IOException;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@ServerEndpoint(\"/websocket/{name}\")\npublic class WebSocketServer {\n    private Session session;\n    private String name;\n    private static final ConcurrentHashMap<String, WebSocketServer> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"name\") String name) {\n        this.session = session;\n        this.name = name;\n        webSocketSet.put(name, this);\n        groupSending(\"User \" + name + \" has joined the chat.\");\n    }\n\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(name);\n        groupSending(\"User \" + name + \" has left the chat.\");\n    }\n\n    @OnMessage\n    public void onMessage(String messageStr) {\n        if (messageStr.startsWith(\"@\")) {\n            String[] parts = messageStr.split(\" \", 2);\n            String targetName = parts[0].substring(1);\n            String message = parts.length > 1 ? parts[1] : \"\";\n            appointSending(targetName, message);\n        } else {\n            groupSending(name + \": \" + messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void groupSending(String message) {\n        for (WebSocketServer client : webSocketSet.values()) {\n            try {\n                client.session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void appointSending(String name, String message) {\n        WebSocketServer client = webSocketSet.get(name);\n        if (client != null) {\n            try {\n                client.session.getBasicRemote().sendText(name + \": \" + message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.function.Supplier;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url) {\n        return unchecked(() -> httpClient.send(HttpRequest.newBuilder(URI.create(baseUri + url)).GET().build(), HttpResponse.BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        return get(String.format(url, params));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        return unchecked(() -> httpClient.send(HttpRequest.newBuilder(URI.create(baseUri + String.format(url, params))).DELETE().build(), HttpResponse.BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        return unchecked(() -> httpClient.send(HttpRequest.newBuilder(URI.create(baseUri + String.format(url, params))).POST(HttpRequest.BodyPublishers.noBody()).build(), HttpResponse.BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Supplier<T> supplier) {\n        try {\n            return supplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "import io.grpc.*;\nimport io.grpc.stub.StreamObserver;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Predicate;\n\nabstract class AbstractClient {\n    protected final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel;\n    protected final ConcurrentMap<String, AbstractBlockingStub> stubs = new ConcurrentHashMap<>();\n\n    public AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy();\n        this.channel = createChannel(config.getLeaderHost());\n    }\n\n    public AbstractBlockingStub getBlockingStub() {\n        return stubs.computeIfAbsent(channel.authority(), k -> createBlockingStub(channel));\n    }\n\n    public AbstractStub getStub() {\n        return stubProxy.getStub(channel);\n    }\n\n    protected abstract AbstractStub createStub(ManagedChannel channel);\n\n    protected abstract AbstractBlockingStub createBlockingStub(ManagedChannel channel);\n\n    public String resetStub() {\n        closeChannel(channel);\n        String newLeader = config.findLeader();\n        channel = createChannel(newLeader);\n        stubs.clear();\n        stubProxy.resetStub(channel);\n        return newLeader;\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, config.getDefaultRetries());\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        for (int attempt = 0; attempt <= retry; attempt++) {\n            try {\n                return getBlockingStub().withDeadlineAfter(config.getTimeout(), java.util.concurrent.TimeUnit.MILLISECONDS)\n                        .newCall(method).blockingUnaryCall(req);\n            } catch (StatusRuntimeException e) {\n                if (attempt == retry) throw e;\n                resetStub();\n            }\n        }\n        throw new RuntimeException(\"Failed to complete the call after retries\");\n    }\n\n    public <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        for (String host : config.getHosts()) {\n            ManagedChannel tempChannel = createChannel(host);\n            AbstractBlockingStub stub = createBlockingStub(tempChannel);\n            try {\n                RespT response = stub.withDeadlineAfter(config.getTimeout(), java.util.concurrent.TimeUnit.MILLISECONDS)\n                        .newCall(method).blockingUnaryCall(req);\n                if (predicate.test(response)) {\n                    closeChannel(tempChannel);\n                    return new KVPair<>(true, response);\n                }\n            } catch (StatusRuntimeException ignored) {\n            } finally {\n                closeChannel(tempChannel);\n            }\n        }\n        return new KVPair<>(false, null);\n    }\n\n    public <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) {\n        for (int attempt = 0; attempt <= retry; attempt++) {\n            try {\n                getStub().withDeadlineAfter(config.getTimeout(), java.util.concurrent.TimeUnit.MILLISECONDS)\n                        .newCall(method).serverStreamingCall(request, responseObserver);\n                return;\n            } catch (StatusRuntimeException e) {\n                if (attempt == retry) throw e;\n                resetStub();\n            }\n        }\n    }\n\n    public void close() {\n        for (ManagedChannel ch : chs.values()) {\n            closeChannel(ch);\n        }\n        chs.clear();\n        stubs.clear();\n    }\n\n    protected ManagedChannel createChannel(String host) {\n        ManagedChannel channel = ManagedChannelBuilder.forTarget(host)\n                .usePlaintext()\n                .build();\n        chs.put(host, channel);\n        return channel;\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        if (channel != null && !channel.isShutdown()) {\n            channel.shutdownNow();\n            try {\n                channel.awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    static class KVPair<K, V> {\n        private final K key;\n        private final V value;\n\n        public KVPair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n}"
  },
  {
    "Task_id": 504,
    "Instruction": "Task Description: Implement a function to test the gRPC Server Reflection service by establishing a connection to a gRPC server, sending a reflection request, and processing the response.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 9090 using plaintext communication. It creates an asynchronous stub for the Server Reflection service, sends a request to list all available services, and processes the response. The function ensures proper cleanup by shutting down the channel after completion.\n\nInput: None (The target server address is hardcoded as \"localhost:9090\")\n\nOutput: None (The function processes the reflection response internally via the checkResult method, which is not shown in the reference code)",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc.ServerReflectionStub;\nimport io.grpc.reflection.v1alpha.ServerReflectionRequest;\nimport io.grpc.reflection.v1alpha.ServerReflectionResponse;\nimport io.grpc.stub.StreamObserver;\n\nvoid testReflectionService() {\n    final ManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:9090\").usePlaintext().build();\n    try {\n        final ServerReflectionStub stub = ServerReflectionGrpc.newStub(channel);\n\n        final AwaitableStreamObserver<ServerReflectionResponse> resultObserver = new AwaitableStreamObserver<>();\n        final StreamObserver<ServerReflectionRequest> requestObserver = stub.serverReflectionInfo(resultObserver);\n        requestObserver.onNext(ServerReflectionRequest.newBuilder()\n                .setListServices(\"\")\n                .build());\n        requestObserver.onCompleted();\n        checkResult(resultObserver);\n    } finally {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 23,
    "wrong_result": "import grpc\nfrom grpc_reflection.v1alpha import reflection_pb2\nfrom grpc_reflection.v1alpha import reflection_pb2_grpc\n\nasync def test_server_reflection():\n    async with grpc.aio.insecure_channel('localhost:9090') as channel:\n        stub = reflection_pb2_grpc.ServerReflectionStub(channel)\n        request = reflection_pb2.ServerReflectionRequest(list_services='')\n        response = await stub.ServerReflectionInfo(request)\n        checkResult(response)\n\ndef checkResult(response):\n    # Process the reflection response here\n    pass"
  },
  {
    "Task_id": 516,
    "Instruction": "Task Description: Implement a TCP server class that handles multiple client connections simultaneously, providing predefined chat responses to incoming messages.\n\nClass Description: TCPServer is a Java class that creates a TCP server listening on a specified port. It maintains a set of predefined messages and can handle multiple client connections concurrently, responding with random messages from its predefined set. The server can be started and stopped as needed.\n\nAttributes:\n- mIsServiceDestoryed: boolean - Flag indicating whether the server should stop running\n- mDefinedMessages: String[] - Array of predefined messages to send to clients\n\nMethods:\n- startServer() -> void - Starts the TCP server in a new thread\n- stopServer() -> void - Stops the TCP server by setting the termination flag\n- TcpServer (inner class) run() -> void - Main server loop that accepts client connections (implements Runnable)\n- responseClient(Socket client) -> void - Handles communication with an individual client\n  - Input: client: Socket - The client socket connection\n  - Output: (none) - Sends responses to client through the socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPServer {\n\n    private boolean mIsServiceDestoryed = false;\n    private String[] mDefinedMessages = new String[] {\n            \"\u4f60\u597d\u554a\uff0c\u54c8\u54c8\",\n            \"\u8bf7\u95ee\u4f60\u53eb\u4ec0\u4e48\u540d\u5b57\u5440\uff1f\",\n            \"\u4eca\u5929\u5317\u4eac\u5929\u6c14\u4e0d\u9519\u554a\uff0cshy\",\n            \"\u4f60\u77e5\u9053\u5417\uff1f\u6211\u53ef\u662f\u53ef\u4ee5\u548c\u591a\u4e2a\u4eba\u540c\u65f6\u804a\u5929\u7684\u54e6\",\n            \"\u7ed9\u4f60\u8bb2\u4e2a\u7b11\u8bdd\u5427\uff1a\u636e\u8bf4\u7231\u7b11\u7684\u4eba\u8fd0\u6c14\u4e0d\u4f1a\u592a\u5dee\uff0c\u4e0d\u77e5\u9053\u771f\u5047\u3002\"\n    };\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            ServerSocket serverSocket = null;\n            try {\n                serverSocket = new ServerSocket(8688);\n            } catch (IOException e) {\n                System.err.println(\"establish tcp server failed, port:8688\");\n                e.printStackTrace();\n                return;\n            }\n\n            while (!mIsServiceDestoryed) {\n                try {\n                    final Socket client = serverSocket.accept();\n                    System.out.println(\"accept\");\n                    new Thread() {\n                        @Override\n                        public void run() {\n                            try {\n                                responseClient(client);\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        };\n                    }.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                client.getInputStream()));\n        PrintWriter out = new PrintWriter(new BufferedWriter(\n                new OutputStreamWriter(client.getOutputStream())), true);\n        out.println(\"\u6b22\u8fce\u6765\u5230\u804a\u5929\u5ba4\uff01\");\n        while (!mIsServiceDestoryed) {\n            String str = in.readLine();\n            System.out.println(\"msg from client:\" + str);\n            if (str == null) {\n                break;\n            }\n            int i = new Random().nextInt(mDefinedMessages.length);\n            String msg = mDefinedMessages[i];\n            out.println(msg);\n            System.out.println(\"send :\" + msg);\n        }\n        System.out.println(\"client quit.\");\n        out.close();\n        in.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class TCPServer {\n    private boolean mIsServiceDestoryed = false;\n    private String[] mDefinedMessages = {\"Hello!\", \"How are you?\", \"Goodbye!\", \"Nice to meet you.\", \"What's up?\"};\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            ServerSocket serverSocket = null;\n            try {\n                serverSocket = new ServerSocket(8000);\n                while (!mIsServiceDestoryed) {\n                    final Socket client = serverSocket.accept();\n                    new Thread(() -> responseClient(client)).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (serverSocket != null) {\n                        serverSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n             PrintWriter out = new PrintWriter(client.getOutputStream(), true)) {\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(\"Received: \" + inputLine);\n                String response = getRandomMessage();\n                out.println(response);\n                System.out.println(\"Sent: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getRandomMessage() {\n        Random rand = new Random();\n        return mDefinedMessages[rand.nextInt(mDefinedMessages.length)];\n    }\n}"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.ArrayList;\n\ninterface VirtualCheckCallback {\n    void onSuspectFound(String message);\n}\n\nclass SocketCommunication {\n    private static final String TAG = \"SocketComm\";\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList;\n\n    public SocketCommunication(String secret, VirtualCheckCallback callback, ArrayList<Integer> portList) {\n        this.secret = secret;\n        this.callback = callback;\n        this.portList = portList;\n    }\n\n    public void checkByPortListening(String host) {\n        Thread serverThread = new Thread(() -> startServer(host, callback));\n        serverThread.start();\n        Thread clientThread = new Thread(() -> startClient(host));\n        clientThread.start();\n    }\n\n    private void startServer(String host, VirtualCheckCallback callback) {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            System.out.println(TAG + \": Server started on port \" + serverSocket.getLocalPort());\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(new ReadThread(secret, clientSocket, callback)).start();\n            }\n        } catch (IOException e) {\n            System.err.println(TAG + \": Server error: \" + e.getMessage());\n        }\n    }\n\n    private void startClient(String host) {\n        for (int port : portList) {\n            new Thread(new ClientThread(secret, host, port)).start();\n        }\n    }\n\n    private class ServerThread implements Runnable {\n        private String secret;\n        private VirtualCheckCallback callback;\n\n        public ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            startServer(\"localhost\", callback);\n        }\n    }\n\n    private class ReadThread implements Runnable {\n        private String secret;\n        private Socket socket;\n        private VirtualCheckCallback callback;\n\n        public ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.socket = socket;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n                String inputLine;\n                if ((inputLine = in.readLine()) != null && inputLine.equals(secret)) {\n                    callback.onSuspectFound(\"Connection verified with secret: \" + secret);\n                }\n            } catch (IOException e) {\n                System.err.println(TAG + \": Error reading from socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    private class ClientThread implements Runnable {\n        private String secret;\n        private String host;\n        private int port;\n\n        public ClientThread(String secret, String host, int port) {\n            this.secret = secret;\n            this.host = host;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            try (Socket socket = new Socket(host, port);\n                 PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n                out.println(secret);\n            } catch (IOException e) {\n                // Connection failed, expected behavior for closed ports\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 528,
    "Instruction": "Task Description: Implement a Java class that creates a TCP server using ServerSocket with GSSAPI (Generic Security Services API) authentication for secure client-server communication.\n\nClass Description: The GSSServer class establishes a secure TCP server that listens for incoming client connections, performs GSSAPI authentication, and enables secure message exchange between server and client.\n\nAttributes:\n- s: [ServerSocket] - The server socket that listens for incoming client connections on a specified port.\n\nMethods:\n- main([String[] args]) -> [void] - Entry point of the server application. Parses command line arguments (service name, port, and mechanism OID), creates server credentials, and starts listening for client connections.\n  Input: Command line arguments (optional: -port [portNumber], -mech [mechanismOID], serviceName)\n  Output: None (runs indefinitely until terminated)\n\n- processClient([GSSCredential server], [Socket client]) -> [void] - Handles an individual client connection by performing GSSAPI authentication and establishing a secure context.\n  Input: \n    - server: [GSSCredential] - Server's credentials for authentication\n    - client: [Socket] - Client connection socket\n  Output: None (closes connection when done)\n\n- exchangeWithPeer([GSSContext aCtxt], [DataInputStream dis], [DataOutputStream dos]) -> [void] - Performs secure message exchange with an authenticated client.\n  Input:\n    - aCtxt: [GSSContext] - Established security context\n    - dis: [DataInputStream] - Input stream from client\n    - dos: [DataOutputStream] - Output stream to client\n  Output: None (sends response and closes connection)\n\n- usage() -> [void] - Prints usage instructions for the server application.\n  Input: None\n  Output: None (prints to console)\n\n- print([String msg]) -> [void] - Helper method to print messages to console.\n  Input: msg [String] - Message to print\n  Output: None (prints to console)\n\n- exit([int status]) -> [void] - Cleanly shuts down the server by closing the server socket and exiting the application.\n  Input: status [int] - Exit status code\n  Output: None (terminates application)",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport com.sun.gssapi.*;\n\nclass GSSServer {\n\n    private static ServerSocket s;\n\n    public static void main(String args[]) {\n        int port = 4444;\n\n        if (args.length < 1) {\n            usage();\n            exit(-1);\n        }\n\n        try {\n            String serviceName = args[args.length-1];\n            Oid mechOid = GSSManager.getDefaultMech();\n\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].equals(\"-port\")) {\n                    if (i >= (args.length - 2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    port = Integer.parseInt(args[++i]);\n                } else if (args[i].equals(\"-mech\")) {\n                    if (i >= (args.length-2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    mechOid = new Oid(args[++i]);\n                }\n            }\n\n            GSSCredential server = new GSSCredential(new GSSName(serviceName,\n                GSSName.NT_HOSTBASED_SERVICE), GSSCredential.INDEFINITE,\n                mechOid, GSSCredential.ACCEPT_ONLY);\n\n            s = new ServerSocket(port);\n\n            while (true) {\n                Socket c = s.accept();\n                processClient(server, c);\n            }\n        } catch (IOException e) {\n            print(\"\\n**Communication ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        } catch (GSSException e) {\n            print(\"\\n**GSSAPI ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        }\n    }\n\n    private static void processClient(GSSCredential server, Socket client)\n            throws GSSException, IOException {\n        DataInputStream dis = new DataInputStream(new BufferedInputStream(client.getInputStream()));\n        DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n\n        int tokLen = dis.readInt();\n        byte []inTok = new byte[tokLen];\n        dis.readFully(inTok, 0, inTok.length);\n\n        GSSContext aCtxt = new GSSContext(server);\n\n        do {\n            byte []outTok = aCtxt.accept(inTok, 0, inTok.length);\n\n            if (outTok != null) {\n                dos.writeInt(outTok.length);\n                dos.write(outTok);\n            }\n\n            if (aCtxt.isEstablished())\n                break;\n\n            inTok = new byte[dis.readInt()];\n            dis.readFully(inTok, 0, inTok.length);\n        } while (true);\n\n        exchangeWithPeer(aCtxt, dis, dos);\n        aCtxt.dispose();\n        client.close();\n    }\n\n    private static void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis,\n            DataOutputStream dos) throws GSSException, IOException {\n        int len = dis.readInt();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        MessageProp mInfo = new MessageProp();\n\n        aCtxt.unwrap(dis, bos, mInfo);\n\n        mInfo.setQOP(0);\n        mInfo.setPrivacy(false);\n\n        byte []peerTok = bos.toByteArray();\n        byte []toPeer = aCtxt.getMIC(peerTok, 0, peerTok.length, mInfo);\n\n        dos.writeInt(toPeer.length);\n        dos.write(toPeer);\n        dos.close();\n    }\n\n    private static void usage() {\n        print(\"\\nUsage:\\tGSSServert [-mech 1.2.34] [-port port] serviceName\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        if (s != null) {\n            try {\n                s.close();\n            } catch (IOException e) {};\n        }\n        System.exit(status);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport org.ietf.jgss.*;\n\npublic class GSSServer {\n    private ServerSocket s;\n\n    public static void main(String[] args) {\n        int port = 4567;\n        String mech = \"1.2.840.113554.1.2.2\"; // Default to Kerberos v5\n        String serviceName = null;\n\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-port\")) {\n                port = Integer.parseInt(args[++i]);\n            } else if (args[i].equals(\"-mech\")) {\n                mech = args[++i];\n            } else {\n                serviceName = args[i];\n            }\n        }\n\n        if (serviceName == null) {\n            usage();\n            System.exit(1);\n        }\n\n        try {\n            Oid mechOid = new Oid(mech);\n            GSSManager manager = GSSManager.getInstance();\n            GSSName gssName = manager.createName(serviceName, GSSName.NT_HOSTBASED_SERVICE);\n            GSSCredential serverCreds = manager.createCredential(gssName, GSSCredential.INDEFINITE_LIFETIME, mechOid, GSSCredential.ACCEPT_ONLY);\n\n            GSSServer server = new GSSServer(port);\n            server.s.listen();\n            print(\"Listening on port \" + port);\n\n            while (true) {\n                Socket client = server.s.accept();\n                print(\"Accepted connection from \" + client.getInetAddress());\n                new Thread(() -> server.processClient(serverCreds, client)).start();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n\n    public GSSServer(int port) throws IOException {\n        this.s = new ServerSocket(port);\n    }\n\n    public void processClient(GSSCredential server, Socket client) {\n        try {\n            DataInputStream dis = new DataInputStream(client.getInputStream());\n            DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n\n            GSSManager manager = GSSManager.getInstance();\n            GSSContext aCtxt = manager.createContext((GSSCredential) null);\n\n            byte[] token = new byte[dis.readInt()];\n            dis.readFully(token);\n\n            token = aCtxt.acceptSecContext(token, 0, token.length);\n            while (!aCtxt.isEstablished()) {\n                dos.writeInt(token.length);\n                dos.write(token);\n                dos.flush();\n\n                token = new byte[dis.readInt()];\n                dis.readFully(token);\n                token = aCtxt.acceptSecContext(token, 0, token.length);\n            }\n\n            print(\"Context Established! \" + aCtxt.getSrcName());\n            exchangeWithPeer(aCtxt, dis, dos);\n\n            aCtxt.dispose();\n            client.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis, DataOutputStream dos) throws IOException {\n        String str = dis.readUTF();\n        print(\"Received: \" + str);\n\n        byte[] bytes = str.getBytes(\"UTF-8\");\n        byte[] token = aCtxt.wrap(bytes, 0, bytes.length, new MessageProp(false));\n\n        dos.writeInt(token.length);\n        dos.write(token);\n        dos.flush();\n    }\n\n    public static void usage() {\n        System.out.println(\"Usage: GSSServer [-port portNumber] [-mech mechanismOID] serviceName\");\n    }\n\n    public static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    public static void exit(int status) {\n        System.exit(status);\n    }\n}"
  },
  {
    "Task_id": 530,
    "Instruction": "Task Description: Implement a WebSocket server class in Java that handles WebSocket connections, performs the WebSocket handshake protocol, and manages client connections.\n\nClass Description: The WebSocketServer class represents a TCP server that implements the WebSocket protocol. It listens for incoming connections, handles the WebSocket handshake, and manages client connections. The server runs in a separate thread to avoid blocking the main thread.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- port: int - The port number on which the server listens\n- serverThread: Thread - The thread in which the server runs\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> None - Starts the server in a new thread and begins listening for connections\n- stop() -> None - Stops the server and releases all resources\n- handleClientConnection(Socket client) -> None - Handles the WebSocket handshake protocol for a connected client\n- generateFinalKey(String in) -> String - Generates the Sec-WebSocket-Accept key for the WebSocket handshake response",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket client = null;\n                    try {\n                        client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        // Handle client connection error\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        Scanner in = new Scanner(client.getInputStream());\n        OutputStream os = client.getOutputStream();\n        \n        // Read client handshake\n        String input = in.nextLine();\n        String testCase = input.split(\" \")[1];\n        String seckey = \"\";\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                break;\n            }\n        }\n\n        // Send response based on test case\n        String response = \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\" +\n                         \"Sec-WebSocket-Accept: \" + generateFinalKey(seckey) + \"\\r\\n\\r\\n\";\n        os.write(response.getBytes());\n        os.flush();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String seckey = in.trim();\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            java.security.MessageDigest sh1 = java.security.MessageDigest.getInstance(\"SHA1\");\n            return org.java_websocket.util.Base64.encodeBytes(sh1.digest(acc.getBytes()));\n        } catch (java.security.NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                while (!serverSocket.isClosed()) {\n                    Socket client = serverSocket.accept();\n                    handleClientConnection(client);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            OutputStream out = client.getOutputStream();\n\n            String line;\n            StringBuilder request = new StringBuilder();\n            while (!(line = in.readLine()).isBlank()) {\n                request.append(line).append(\"\\r\\n\");\n            }\n\n            String secWebSocketKey = \"\";\n            for (String header : request.toString().split(\"\\r\\n\")) {\n                if (header.contains(\"Sec-WebSocket-Key\")) {\n                    secWebSocketKey = header.split(\": \")[1];\n                }\n            }\n\n            String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                              \"Upgrade: websocket\\r\\n\" +\n                              \"Connection: Upgrade\\r\\n\" +\n                              \"Sec-WebSocket-Accept: \" + generateFinalKey(secWebSocketKey) + \"\\r\\n\\r\\n\";\n            out.write(response.getBytes());\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String guid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        byte[] hash;\n        try {\n            hash = MessageDigest.getInstance(\"SHA-1\").digest((in + guid).getBytes());\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        return Base64.getEncoder().encodeToString(hash);\n    }\n}"
  },
  {
    "Task_id": 534,
    "Instruction": "Task Description: Implement a WebSocket handshake server in Java that handles various test cases for WebSocket connection upgrades. The server should listen on a specified port, accept client connections, and respond with different HTTP responses based on the requested test case.\n\nClass Description: WebSocketHandshakeServer is a TCP server that simulates WebSocket handshake responses for testing purposes. It creates a ServerSocket to listen for incoming connections and handles each client connection in a separate thread, responding with different HTTP responses based on the requested test case path.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming client connections\n- port: int - The port number on which the server listens for connections\n- additionalHandshake: String - Constant string containing additional handshake headers required for WebSocket upgrade\n\nMethods:\n- WebSocketHandshakeServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server, creates a ServerSocket, and begins accepting client connections in a new thread\n- stop() -> void - Stops the server by closing the ServerSocket if it's open\n- handleClientConnection(Socket client) -> void - Handles an individual client connection, reads the request, and sends the appropriate response based on the test case\n- asciiBytes(String input) -> byte[] - Helper method that converts a string to ASCII bytes for network transmission",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class WebSocketHandshakeServer {\n\n    private static final String additionalHandshake = \"Upgrade: websocket\\r\\nConnection: Upgrade\\r\\n\\r\\n\";\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n        \n        new Thread(() -> {\n            while (!serverSocket.isClosed()) {\n                try {\n                    Socket client = serverSocket.accept();\n                    handleClientConnection(client);\n                } catch (IOException e) {\n                    if (!serverSocket.isClosed()) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        try (Scanner in = new Scanner(client.getInputStream());\n             OutputStream os = client.getOutputStream()) {\n            \n            String input = in.nextLine();\n            String testCase = input.split(\" \")[1];\n            \n            switch (testCase) {\n                case \"/0\":\n                    os.write(asciiBytes(\"HTTP/1.1 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/1\":\n                    os.write(asciiBytes(\"HTTP/1.0 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/2\":\n                    os.write(asciiBytes(\"HTTP 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/3\":\n                    os.write(asciiBytes(\"HTTP/1.1 200 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/4\":\n                    os.write(asciiBytes(\"HTTP 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/5\":\n                    os.write(asciiBytes(\"HTTP/1.1 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/6\":\n                    os.write(asciiBytes(\"HTTP/2.0 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/7\":\n                    os.write(asciiBytes(\"HTTP/1.1 500 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/8\":\n                    os.write(asciiBytes(\"GET 302 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/9\":\n                    os.write(asciiBytes(\"GET HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/10\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/11\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" + additionalHandshake));\n                    break;\n            }\n            os.flush();\n        } finally {\n            client.close();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n    }\n\n    private byte[] asciiBytes(String input) {\n        return input.getBytes(java.nio.charset.StandardCharsets.US_ASCII);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\nclass WebSocketHandshakeServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private final String additionalHandshake = \"Upgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\\r\\n\";\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            System.out.println(\"Server started on port \" + port);\n            while (!serverSocket.isClosed()) {\n                Socket client = serverSocket.accept();\n                new Thread(() -> handleClientConnection(client)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n             OutputStream out = client.getOutputStream()) {\n\n            StringBuilder request = new StringBuilder();\n            String line;\n            while (!(line = in.readLine()).isBlank()) {\n                request.append(line).append(\"\\r\\n\");\n            }\n\n            String response;\n            if (request.toString().contains(\"/echo\")) {\n                response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake + \"\\r\\n\";\n            } else if (request.toString().contains(\"/fail\")) {\n                response = \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\";\n            } else {\n                response = \"HTTP/1.1 404 Not Found\\r\\n\\r\\n\";\n            }\n\n            out.write(asciiBytes(response));\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private byte[] asciiBytes(String input) {\n        return input.getBytes(java.nio.charset.StandardCharsets.US_ASCII);\n    }\n}"
  },
  {
    "Task_id": 536,
    "Instruction": "Task Description: Demonstrate basic TCP socket communication between a server and client using Java's ServerSocket and Socket classes. The server should echo back any data received from the client.\n\nFunction Description: The function establishes a TCP server that listens on port 5678, accepts a client connection, reads data from the client, writes the same data back (echo), and then closes the connection. Simultaneously, it creates a client that connects to this server, sends a test message, and verifies the echoed response.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function performs communication internally and handles errors through fail() calls)\n\n---\n\nNote: Since the reference code shows a complete test scenario (both server and client) implemented as a single function with internal threading rather than separate reusable components, I've described it at the function level. If you'd prefer this to be split into proper class definitions for Server and Client components, please let me know and I can provide that alternative structure instead.",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic void testServerSocketCommunication() {\n    Thread listener = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            ServerSocket s = null;\n            try {\n                s = new ServerSocket(5678);\n            } catch (IOException e) {\n                fail(\"exception creating ServerSocket\");\n            }\n\n            byte[] recv = new byte[800];\n\n            Socket peer = null;\n            try {\n                peer = s.accept();\n            } catch (IOException e) {\n                fail(\"accept failed\");\n            }\n\n            InputStream is = peer.getInputStream();\n            OutputStream os = peer.getOutputStream();\n\n            int recvLen = 0;\n            try {\n                recvLen = is.read(recv);\n            } catch (IOException e) {\n                fail(\"read failed\");\n            }\n\n            try {\n                os.write(recv, 0, recvLen);\n            } catch (IOException e) {\n                fail(\"write failed\");\n            }\n\n            try {\n                peer.close();\n                s.close();\n            } catch (IOException e) {\n                fail(\"close failed\");\n            }\n        }\n    });\n    listener.start();\n\n    Socket s = null;\n    try {\n        s = new Socket();\n        s.bind(new InetSocketAddress(\"192.168.0.3\", 0));\n    } catch (IOException e) {\n        fail(\"new socket failed\");\n    }\n\n    try {\n        s.connect(new InetSocketAddress(\"192.168.0.3\", 5678));\n    } catch (IOException e) {\n        fail(\"connect failed\");\n    }\n\n    byte[] send = \"Hello, World!\".getBytes();\n    InputStream is = s.getInputStream();\n    OutputStream os = s.getOutputStream();\n\n    try {\n        os.write(send);\n    } catch (IOException e) {\n        fail(\"exception sending on Socket\");\n    }\n\n    byte[] recv = new byte[800];\n    int recvLen = 0;\n    try {\n        recvLen = is.read(recv);\n    } catch (IOException e) {\n        fail(\"exception receiving on DatagramSocket\");\n    }\n\n    try {\n        listener.join();\n    } catch (InterruptedException e) {\n    }\n\n    try {\n        s.close();\n    } catch (IOException e) {\n        fail(\"close failed\");\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class EchoServerClient {\n    public static void main(String[] args) throws IOException {\n        Thread serverThread = new Thread(() -> {\n            try (ServerSocket serverSocket = new ServerSocket(5678)) {\n                try (Socket clientSocket = serverSocket.accept();\n                     BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                     PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n                    String inputLine;\n                    while ((inputLine = in.readLine()) != null) {\n                        out.println(inputLine);\n                    }\n                }\n            } catch (IOException e) {\n                System.err.println(\"Server exception: \" + e.getMessage());\n                e.printStackTrace();\n            }\n        });\n\n        serverThread.start();\n\n        try (Socket socket = new Socket(\"localhost\", 5678);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n             BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                out.println(userInput);\n                System.out.println(\"echo: \" + in.readLine());\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"Don't know about host localhost.\");\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"Couldn't get I/O for the connection to localhost.\");\n            System.exit(1);\n        }\n\n        serverThread.interrupt();\n    }\n}"
  },
  {
    "Task_id": 539,
    "Instruction": "Task Description: Create a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections.\n\nClass Description: The ConnectionManipulationProxyServer class implements a TCP proxy server that listens on a local port, accepts client connections, and forwards traffic to a specified remote server. It provides thread-safe control over the proxy operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port number the proxy listens on\n- host: [String] - The hostname or IP address of the remote server\n- remotePort: [int] - The port number of the remote server\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization object for thread-safe control\n- enableProxy: [boolean] - Flag indicating whether proxy is enabled\n- running: [boolean] - Flag indicating whether proxy thread should continue running\n- client: [Socket] - Socket for client connection\n- server: [Socket] - Socket for server connection\n- serverSocket: [ServerSocket] - Server socket for accepting client connections\n\nMethods:\n- ConnectionManipulationProxyServer(String host, int remotePort, int localPort) -> [void] - Constructor that initializes the proxy server with target host and ports\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread implementation that handles connection forwarding\n- getLocalPort() -> [int] - Returns the local port number the proxy is listening on",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    Socket client = null, server = null;\n    ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            boolean canIrun = true;\n            \n            while (running) {\n                synchronized (enableLock) {\n                    canIrun = enableProxy;\n                }\n                \n                while (canIrun) {\n                    synchronized (enableLock) {\n                        canIrun = enableProxy;\n                        if (!enableProxy) {\n                            break;\n                        }\n                    }\n                    \n                    if (serverSocket == null || serverSocket.isClosed()) {\n                        serverSocket = new ServerSocket(localPort);\n                        localPort = serverSocket.getLocalPort();\n                    }\n                    \n                    log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    \n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\nclass ConnectionManipulationProxyServer implements Runnable {\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private boolean running = true;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                proxyThread = new Thread(this);\n                proxyThread.start();\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            if (enableProxy) {\n                enableProxy = false;\n            }\n        }\n        running = false;\n        killOpenSockets();\n        if (proxyThread != null && proxyThread.isAlive()) {\n            proxyThread.interrupt();\n        }\n    }\n\n    public void killOpenSockets() {\n        try {\n            if (client != null && !client.isClosed()) {\n                client.close();\n            }\n            if (server != null && !server.isClosed()) {\n                server.close();\n            }\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) {\n                        enableLock.wait();\n                    }\n                }\n                client = serverSocket.accept();\n                server = new Socket(host, remotePort);\n                new Thread(() -> forward(client.getInputStream(), server.getOutputStream())).start();\n                new Thread(() -> forward(server.getInputStream(), client.getOutputStream())).start();\n            }\n        } catch (IOException | InterruptedException e) {\n            if (running) {\n                e.printStackTrace();\n            }\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    private void forward(InputStream in, OutputStream out) {\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        try {\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        } catch (IOException e) {\n            // Connection closed or error occurred\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}"
  },
  {
    "Task_id": 540,
    "Instruction": "Task Description: Implement a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections dynamically.\n\nClass Description: The ConnectionManipulationProxyServer class acts as a TCP proxy that listens on a local port, accepts client connections, and forwards traffic to a specified remote host and port. It provides thread-safe control over the proxy's operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port on which the proxy listens for client connections\n- host: [String] - The remote host address to which traffic will be forwarded\n- remotePort: [int] - The remote port to which traffic will be forwarded\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization lock for thread-safe operation control\n- enableProxy: [boolean] - Flag indicating whether the proxy is currently enabled\n- running: [boolean] - Flag indicating whether the proxy thread should continue running\n- client: [Socket] - The client-side socket connection\n- server: [Socket] - The server-side socket connection\n- serverSocket: [ServerSocket] - The server socket listening for client connections\n\nMethods:\n- ConnectionManipulationProxyServer([String host, int remotePort, int localPort]) -> [void] - Constructor that initializes the proxy with target host and port information\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread execution method that handles connection setup and data forwarding\n- getLocalPort() -> [int] - Returns the local port on which the proxy is listening",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        this.proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            \n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) continue;\n                }\n\n                if (serverSocket == null || serverSocket.isClosed()) {\n                    serverSocket = new ServerSocket(localPort);\n                    localPort = serverSocket.getLocalPort();\n                }\n\n                log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                \n                try {\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                    \n                } catch (IOException ex) {\n                    log.warning(\"[CMPS Proxy] - General IO Exception caught in main Thread: \" + ex.getMessage());\n                    break;\n                } finally {\n                    try {\n                        if (server != null) {\n                            server.close();\n                        }\n                        if (client != null) {\n                            client.close();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException caught whilst closing proxy connection: \" + ex.getMessage());\n                    }\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            log.info(\"[CMPS Proxy] - Server Socket Closed, returning...\");\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy;\n    private boolean running;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n        this.enableProxy = false;\n        this.running = true;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                proxyThread = new Thread(this);\n                proxyThread.start();\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            if (enableProxy) {\n                enableProxy = false;\n                try {\n                    if (serverSocket != null && !serverSocket.isClosed()) {\n                        serverSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void killOpenSockets() {\n        try {\n            if (client != null && !client.isClosed()) {\n                client.close();\n            }\n            if (server != null && !server.isClosed()) {\n                server.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) {\n                        break;\n                    }\n                }\n                client = serverSocket.accept();\n                server = new Socket(host, remotePort);\n\n                new Thread(() -> forwardData(client.getInputStream(), server.getOutputStream())).start();\n                new Thread(() -> forwardData(server.getInputStream(), client.getOutputStream())).start();\n            }\n        } catch (IOException e) {\n            if (running) {\n                e.printStackTrace();\n            }\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    private void forwardData(InputStream in, OutputStream out) {\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        try {\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        } catch (IOException e) {\n            if (running) {\n                e.printStackTrace();\n            }\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}"
  },
  {
    "Task_id": 542,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles incoming client connections, processes commands, and interacts with a GUI frame. The server should support checking for existing instances, activating windows, and processing file operations.\n\nClass Description: TcpServer is a Thread subclass that creates a TCP server listening on a specified port. It communicates with clients to perform actions like getting window titles, activating windows, and opening files in the associated GUI frame.\n\nAttributes:\n- frame: IAppFrame - Reference to the application's GUI frame for window operations\n- port: int - The port number on which the server listens\n- file: String - File path to be processed (optional)\n\nMethods:\n- TcpServer(int port, IAppFrame frame) -> None - Constructor initializing server with port and frame reference\n- TcpServer(int port, IAppFrame frame, String file) -> None - Constructor with additional file parameter\n- checkExistInstance(int port) -> boolean - Static method checking if another instance is running on given port\n- ask(String host, String cmd, int port) -> boolean - Private static helper method for sending commands to existing instances\n- run() -> None - Main server thread method that listens for connections and processes client requests",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public static String GETWINDOWTITLE = \"GetWindowTitle\";\n    public static String ACTIVATE = \"ACTIVATE\";\n    public static String LOCALHOST = \"127.0.0.1\";\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(LOCALHOST, GETWINDOWTITLE, port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        Socket s = new Socket();\n        try {\n            InetSocketAddress isa = new InetSocketAddress(host, port);\n            s.connect(isa, 2000);\n            OutputStream os = s.getOutputStream();\n            os.write(cmd.getBytes());\n            InputStream is = s.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = is.read(buffer);\n            String res = new String(buffer, 0, len);\n            return res != null && !res.isEmpty();\n        } catch (Exception x) {\n            return false;\n        } finally {\n            try {\n                s.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    public void run() {\n        ServerSocket ss = null;\n        try {\n            ss = new ServerSocket(port, 10, InetAddress.getByName(LOCALHOST));\n            while (true) {\n                Socket s = ss.accept();\n                try {\n                    InputStream is = s.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    int len = is.read(buffer);\n                    String file = new String(buffer, 0, len);\n                    \n                    if (file.equals(GETWINDOWTITLE)) {\n                        OutputStream os = s.getOutputStream();\n                        String wTitle = ((JFrame) frame).getTitle();\n                        os.write(wTitle.getBytes());\n                    } else if (file.equals(ACTIVATE)) {\n                        ((JFrame) frame).toFront();\n                    } else {\n                        if (file.startsWith(\"\\\"\")) {\n                            file = file.substring(1, file.length() - 1);\n                        }\n                        final String sfile = file;\n                        SwingUtilities.invokeLater(() -> {\n                            try {\n                                frame.openSheetFile(sfile);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        });\n                    }\n                } finally {\n                    s.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport javax.swing.*;\n\ninterface IAppFrame {\n    void activateWindow(String title);\n    void openFile(String filePath);\n    String[] getWindowTitles();\n}\n\nclass TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n        this.file = null;\n    }\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this.port = port;\n        this.frame = frame;\n        this.file = file;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(\"localhost\", \"CHECK\", port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n            out.println(cmd);\n            return \"ACK\".equals(in.readLine());\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept();\n                     BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                     PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n                    String command = in.readLine();\n                    switch (command) {\n                        case \"CHECK\":\n                            out.println(\"ACK\");\n                            break;\n                        case \"GET_TITLES\":\n                            String[] titles = frame.getWindowTitles();\n                            out.println(String.join(\",\", titles));\n                            break;\n                        case \"ACTIVATE\":\n                            String title = in.readLine();\n                            frame.activateWindow(title);\n                            break;\n                        case \"OPEN_FILE\":\n                            String filePath = in.readLine();\n                            frame.openFile(filePath);\n                            break;\n                        default:\n                            out.println(\"UNKNOWN_COMMAND\");\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 549,
    "Instruction": "Task Description: Create a mock POP3 server class that simulates interactions with a client using TCP sockets for testing purposes.\n\nClass Description: The MockPop3Server class implements a simple POP3 server mock that can be used for testing email client implementations. It handles client connections, processes commands, and manages server shutdown. The server runs in a separate thread and maintains a queue of expected interactions.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of expected client-server interactions\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for connection closure\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- mockServerThread: MockServerThread - The thread running the server\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread\n- shutdown() -> void - Signals the server thread to stop and cleans up resources\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread\n- run() -> void - Main server thread execution that handles client connections and commands\n- handleInteractions() -> void - Processes the queued interactions with the client\n- readAdditionalCommands() -> void - Reads any additional unexpected commands from the client\n- readLine() -> String - Reads a line of input from the client socket\n- shouldStop() -> void - Signals the thread to stop execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockPop3Server {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    \n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        InetSocketAddress localSocketAddress = (InetSocketAddress) serverSocket.getLocalSocketAddress();\n        host = localSocketAddress.getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        \n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            super(\"MockPop3Server\");\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = readLine();\n            if (command == null) {\n                throw new IOException(\"Connection closed\");\n            }\n        }\n\n        private String readLine() throws IOException {\n            return clientSocket.getInputStream().read() != -1 ? \"command\" : null;\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\nclass MockPop3Server {\n    private final ConcurrentLinkedDeque<String> interactions;\n    private final CountDownLatch waitForConnectionClosed;\n    private final CountDownLatch waitForAllExpectedCommands;\n    private MockServerThread mockServerThread;\n    private final String host;\n    private final int port;\n\n    public MockPop3Server(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.interactions = new ConcurrentLinkedDeque<>();\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n    }\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(port);\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n        new Thread(mockServerThread).start();\n    }\n\n    public void shutdown() throws InterruptedException, IOException {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n            waitForConnectionClosed.await();\n            mockServerThread.getServerSocket().close();\n        }\n    }\n\n    private static class MockServerThread implements Runnable {\n        private final ServerSocket serverSocket;\n        private final ConcurrentLinkedDeque<String> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean stopRequested;\n\n        public MockServerThread(ServerSocket serverSocket, ConcurrentLinkedDeque<String> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.stopRequested = false;\n        }\n\n        @Override\n        public void run() {\n            try (Socket clientSocket = serverSocket.accept();\n                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n                out.println(\"+OK POP3 server ready\");\n\n                handleInteractions(in, out);\n\n                readAdditionalCommands(in, out);\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                waitForConnectionClosed.countDown();\n            }\n        }\n\n        private void handleInteractions(BufferedReader in, PrintWriter out) throws IOException {\n            while (!interactions.isEmpty() && !stopRequested) {\n                String expectedResponse = interactions.pollFirst();\n                String command = readLine(in);\n                out.println(expectedResponse);\n            }\n            waitForAllExpectedCommands.countDown();\n        }\n\n        private void readAdditionalCommands(BufferedReader in, PrintWriter out) throws IOException {\n            String command;\n            while ((command = readLine(in)) != null && !stopRequested) {\n                out.println(\"-ERR Unexpected command: \" + command);\n            }\n        }\n\n        private String readLine(BufferedReader in) throws IOException {\n            return in.readLine();\n        }\n\n        public void shouldStop() {\n            this.stopRequested = true;\n        }\n\n        public ServerSocket getServerSocket() {\n            return serverSocket;\n        }\n    }\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JavaHttpUtility {\n    public static final int CONNECT_TIMEOUT = 10000;\n    public static final int READ_TIMEOUT = 10000;\n\n    public static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (proxyHost != null && proxyPort != null) {\n            return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n        }\n        return Proxy.NO_PROXY;\n    }\n\n    public static String doPost(String urlAddress, Map<String, String> params) throws IOException {\n        URL url = new URL(urlAddress);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection(getProxy());\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        connection.setDoOutput(true);\n        connection.setConnectTimeout(CONNECT_TIMEOUT);\n        connection.setReadTimeout(READ_TIMEOUT);\n\n        try (DataOutputStream dos = new DataOutputStream(connection.getOutputStream())) {\n            StringBuilder postData = new StringBuilder();\n            for (Map.Entry<String, String> param : params.entrySet()) {\n                if (postData.length() != 0) postData.append('&');\n                postData.append(param.getKey()).append('=').append(param.getValue());\n            }\n            dos.writeBytes(postData.toString());\n        }\n\n        return handleResponse(connection);\n    }\n\n    private static String handleResponse(HttpURLConnection connection) throws IOException {\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_CREATED) {\n            return readResult(connection);\n        } else {\n            handleError(connection);\n            return null; // unreachable\n        }\n    }\n\n    private static String readResult(HttpURLConnection connection) throws IOException {\n        StringBuilder result = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                result.append(line);\n            }\n        }\n        return result.toString();\n    }\n\n    private static void handleError(HttpURLConnection connection) throws IOException {\n        String errorMessage;\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getErrorStream()))) {\n            StringBuilder error = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                error.append(line);\n            }\n            errorMessage = error.toString();\n        }\n        throw new IOException(\"HTTP error code : \" + connection.getResponseCode() + \" - \" + errorMessage);\n    }\n}"
  },
  {
    "Task_id": 550,
    "Instruction": "Task Description: Implement a simple embedded HTTP server class that can handle incoming HTTP requests, parse request information, and provide a framework for custom request handling.\n\nClass Description: The EmbedHttpServer class represents a basic HTTP server that listens on a specified port, accepts client connections, parses HTTP request headers and content, and provides hooks for custom request processing. It handles the low-level socket communication while delegating the actual request handling to subclasses or implementations.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n- serverSocket: ServerSocket - The server socket instance used to accept client connections\n\nMethods:\n- EmbedHttpServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> void - Starts the server by creating a ServerSocket and launching a dedicated thread for handling connections\n- stop() -> void - Stops the server by closing the ServerSocket and cleaning up resources\n- run() -> void - The main server loop that accepts connections and processes requests (runs in a separate thread)\n- handle(String method, String path, HashMap<String,String> headers, Map<String,String> queries, InputStream input, OutputStream response) -> void - Abstract method meant to be overridden for custom request handling (does nothing in base implementation)\n- parsePath(String path) -> Map<String,String> - Helper method that parses the request path and extracts query parameters",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.antfortune.freeline.router.ISchemaAction;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EmbedHttpServer {\n\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        if (serverSocket == null) {\n            serverSocket = new ServerSocket(port);\n            new Thread(this::run, \"embed-http-server\").start();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n            serverSocket = null;\n        }\n    }\n\n    private void run() {\n        final ServerSocket ss = serverSocket;\n        while (ss == serverSocket) {\n            Socket conn = null;\n            try {\n                conn = ss.accept();\n                String method = null;\n                String path = null;\n                HashMap<String, String> headers = new HashMap<>();\n\n                InputStream ins = conn.getInputStream();\n                StringBuilder sb = new StringBuilder(512);\n                int l;\n                while ((l = ins.read()) != -1) {\n                    if (l == '\\n') {\n                        if (sb.length() > 0 && sb.charAt(sb.length() - 1) == '\\r')\n                            sb.setLength(sb.length() - 1);\n                        if (sb.length() == 0) {\n                            break;\n                        } else if (method == null) {\n                            int i = sb.indexOf(\" \");\n                            method = sb.substring(0, i);\n                            int j = sb.lastIndexOf(\" HTTP/\");\n                            path = sb.substring(i + 1, j).trim();\n                        } else {\n                            int i = sb.indexOf(\":\");\n                            String name = sb.substring(0, i).trim();\n                            String val = sb.substring(i + 1).trim();\n                            headers.put(name, val);\n                        }\n                        sb.setLength(0);\n                    } else {\n                        sb.append((char) l);\n                    }\n                }\n                int contentLength = 0;\n                String str = headers.get(\"Content-Length\");\n                if (str != null) {\n                    contentLength = Integer.parseInt(str);\n                }\n                OutputStream os = conn.getOutputStream();\n                str = headers.get(\"Expect\");\n                if (\"100-Continue\".equalsIgnoreCase(str)) {\n                    os.write(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\".getBytes(\"ASCII\"));\n                    os.flush();\n                }\n                InputStream input = new BodyInputStream(ins, contentLength);\n                OutputStream response = new ResponseOutputStream(os);\n\n                Map<String, String> queries = parsePath(path);\n                handle(method, path, headers, queries, input, response);\n                response.close();\n\n                conn.close();\n            } catch (Exception e) {\n                if (conn != null) {\n                    try {\n                        conn.close();\n                    } catch (Exception ee) {}\n                }\n            }\n\n            if (!ss.isBound() || ss.isClosed()) {\n                serverSocket = null;\n            }\n        }\n    }\n\n    protected void handle(String method, String path,\n                         HashMap<String, String> headers, Map<String, String> queries, InputStream input,\n                         OutputStream response) throws Exception {\n    }\n\n    private static Map<String, String> parsePath(String path) {\n        if (TextUtils.isEmpty(path)) {\n            return null;\n        }\n        int descriptionIndex = path.indexOf(\"/\");\n        if (descriptionIndex == -1) {\n            return null;\n        }\n        String description = path.substring(descriptionIndex + 1);\n        Map<String, String> queries = new HashMap<>();\n        int queryIndex = description.indexOf(\"?\");\n        if (queryIndex == -1) {\n            queries.put(ISchemaAction.DESCRIPTION, description);\n        } else {\n            queries.put(ISchemaAction.DESCRIPTION, description.substring(0, queryIndex));\n            description = description.substring(queryIndex + 1);\n        }\n        String[] arr = description.split(\"&\");\n        for (String segment : arr) {\n            String[] query = segment.split(\"=\");\n            if (query.length == 2) {\n                queries.put(query[0], query[1]);\n            } else if (query.length == 1) {\n                queries.put(query[0], \"\");\n            }\n        }\n        return queries;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic abstract class EmbedHttpServer {\n    private int port;\n    private ServerSocket serverSocket;\n    private Thread serverThread;\n    private boolean running;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n        this.running = false;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            running = true;\n            serverThread = new Thread(this::run);\n            serverThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        running = false;\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            serverThread.join();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void run() {\n        while (running) {\n            try (Socket clientSocket = serverSocket.accept()) {\n                handleClient(clientSocket);\n            } catch (IOException e) {\n                if (running) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void handleClient(Socket clientSocket) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        OutputStream out = clientSocket.getOutputStream();\n\n        String requestLine = in.readLine();\n        if (requestLine == null) return;\n\n        String[] parts = requestLine.split(\" \");\n        if (parts.length < 3) return;\n\n        String method = parts[0];\n        String path = parts[1];\n\n        Map<String, String> headers = new HashMap<>();\n        String line;\n        while (!(line = in.readLine()).isEmpty()) {\n            String[] headerParts = line.split(\":\\\\s*\", 2);\n            if (headerParts.length == 2) {\n                headers.put(headerParts[0], headerParts[1]);\n            }\n        }\n\n        Map<String, String> queries = parsePath(path);\n        path = path.split(\"\\\\?\")[0];\n\n        handle(method, path, headers, queries, clientSocket.getInputStream(), out);\n    }\n\n    public abstract void handle(String method, String path, HashMap<String, String> headers, Map<String, String> queries, InputStream input, OutputStream response);\n\n    protected Map<String, String> parsePath(String path) {\n        Map<String, String> queries = new HashMap<>();\n        int queryIndex = path.indexOf('?');\n        if (queryIndex != -1) {\n            String queryString = path.substring(queryIndex + 1);\n            String[] pairs = queryString.split(\"&\");\n            for (String pair : pairs) {\n                int idx = pair.indexOf('=');\n                if (idx > 0) {\n                    queries.put(pair.substring(0, idx), pair.substring(idx + 1));\n                }\n            }\n        }\n        return queries;\n    }\n}"
  },
  {
    "Task_id": 559,
    "Instruction": "Task Description: Create a mock SMTP server implementation in Java that can simulate SMTP interactions, handle TLS upgrades, and manage client connections for testing purposes.\n\nClass Description: MockSmtpServer is a test utility class that simulates an SMTP server with support for plaintext and TLS connections. It maintains a queue of expected interactions and processes them sequentially when clients connect.\n\nAttributes:\n- interactions: Deque<SmtpInteraction> - A thread-safe queue of expected SMTP interactions (commands, responses, TLS upgrades)\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for client disconnection\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- keyStoreProvider: KeyStoreProvider - Provides SSL/TLS keystore information\n- logger: Logger - Logging interface for server activities\n- mockServerThread: MockServerThread - The server thread handling client connections\n- host: String - The server's host address\n- port: int - The server's listening port\n\nMethods:\n- start() -> void - Starts the server on a random available port and begins listening for connections\n- shutdown() -> void - Stops the server and closes all connections\n- MockServerThread(ServerSocket, Deque<SmtpInteraction>, CountDownLatch, CountDownLatch, Logger, KeyStoreProvider) -> void - Inner class constructor for the server thread\n- run() -> void - Main server thread execution handling client connections and SMTP protocol\n- readExpectedCommand(ExpectedCommand) -> void - Reads and verifies an expected command from the client\n- writeCannedResponse(CannedResponse) -> void - Writes a predefined response to the client\n- upgradeToTls(Socket) -> void - Upgrades the connection to TLS using the provided keystore\n- shouldStop() -> void - Signals the server thread to stop processing\n\nNested Classes/Interfaces:\n- SmtpInteraction: Interface - Marker interface for SMTP interaction types\n- ExpectedCommand: Class - Represents an expected SMTP command from the client\n- CannedResponse: Class - Represents a predefined server response\n- UpgradeToTls: Class - Marker for TLS upgrade interaction\n- Logger: Interface - Logging interface for server activities",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport okio.BufferedSink;\nimport okio.BufferedSource;\nimport okio.Okio;\n\npublic class MockSmtpServer {\n    private final Deque<SmtpInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger;\n\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider, Logger logger) {\n        this.keyStoreProvider = keyStoreProvider;\n        this.logger = logger;\n    }\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = serverSocket.getInetAddress().getHostAddress();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands, logger, keyStoreProvider);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n        private BufferedSource input;\n        private BufferedSink output;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger,\n                KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Socket socket = serverSocket.accept();\n                serverSocket.close();\n                clientSocket = socket;\n\n                input = Okio.buffer(Okio.source(socket));\n                output = Okio.buffer(Okio.sink(socket));\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    SmtpInteraction interaction = interactions.pop();\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(socket);\n                    }\n                }\n\n                waitForAllExpectedCommands.countDown();\n                waitForConnectionClosed.countDown();\n            } catch (IOException | KeyStoreException | NoSuchAlgorithmException | \n                    CertificateException | UnrecoverableKeyException | KeyManagementException e) {\n                if (!shouldStop) {\n                    logger.log(\"Exception: %s\", e);\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    logger.log(\"Error closing socket: %s\", e);\n                }\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand expectedCommand) throws IOException {\n            String command = input.readUtf8Line();\n            logger.log(\"C: %s\", command);\n        }\n\n        private void writeCannedResponse(CannedResponse cannedResponse) throws IOException {\n            String response = cannedResponse.getResponse();\n            logger.log(\"S: %s\", response);\n            output.writeUtf8(response);\n            output.writeUtf8(\"\\r\\n\");\n            output.flush();\n        }\n\n        private void upgradeToTls(Socket socket) throws KeyStoreException, IOException, NoSuchAlgorithmException,\n                CertificateException, UnrecoverableKeyException, KeyManagementException {\n            KeyStore keyStore = keyStoreProvider.getKeyStore();\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\n                    KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyStoreProvider.getPassword());\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), null, null);\n            SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(\n                    socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);\n            sslSocket.setUseClientMode(false);\n            sslSocket.startHandshake();\n\n            input = Okio.buffer(Okio.source(sslSocket.getInputStream()));\n            output = Okio.buffer(Okio.sink(sslSocket.getOutputStream()));\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                logger.log(\"Error closing socket: %s\", e);\n            }\n        }\n    }\n\n    private interface SmtpInteraction {}\n    private static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n    }\n    private static class CannedResponse implements SmtpInteraction {\n        private final String response;\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n    }\n    private static class UpgradeToTls implements SmtpInteraction {}\n    public interface Logger {\n        void log(String format, Object... args);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.file.Files;\nimport java.security.KeyStore;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.CountDownLatch;\nimport javax.net.ssl.*;\n\npublic class MockSmtpServer {\n    private final Deque<SmtpInteraction> interactions = new ArrayDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger;\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider, Logger logger) {\n        this.keyStoreProvider = keyStoreProvider;\n        this.logger = logger;\n    }\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(0);\n        host = serverSocket.getInetAddress().getHostAddress();\n        port = serverSocket.getLocalPort();\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands, logger, keyStoreProvider);\n        new Thread(mockServerThread).start();\n    }\n\n    public void shutdown() throws IOException {\n        mockServerThread.shouldStop();\n        try (Socket socket = new Socket(host, port)) {} // Trigger server shutdown\n        waitForConnectionClosed.await();\n        waitForAllExpectedCommands.await();\n    }\n\n    private static class MockServerThread implements Runnable {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n        private volatile boolean shouldStop = false;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger, KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try (Socket clientSocket = serverSocket.accept()) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                BufferedWriter out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));\n                while (!shouldStop && !interactions.isEmpty()) {\n                    SmtpInteraction interaction = interactions.poll();\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction, in);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction, out);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(clientSocket, in, out);\n                    }\n                }\n            } catch (IOException e) {\n                logger.log(\"Error in server thread: \" + e.getMessage());\n            } finally {\n                waitForConnectionClosed.countDown();\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand expectedCommand, BufferedReader in) throws IOException {\n            String command = in.readLine();\n            if (!command.equals(expectedCommand.getCommand())) {\n                throw new RuntimeException(\"Unexpected command: \" + command);\n            }\n            logger.log(\"Received command: \" + command);\n        }\n\n        private void writeCannedResponse(CannedResponse cannedResponse, BufferedWriter out) throws IOException {\n            out.write(cannedResponse.getResponse());\n            out.newLine();\n            out.flush();\n            logger.log(\"Sent response: \" + cannedResponse.getResponse());\n        }\n\n        private void upgradeToTls(Socket clientSocket, BufferedReader in, BufferedWriter out) throws IOException {\n            logger.log(\"Upgrading to TLS\");\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            KeyStore keyStore = keyStoreProvider.getKeyStore();\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(keyStore, keyStoreProvider.getKeyStorePassword().toCharArray());\n            sslContext.init(kmf.getKeyManagers(), null, null);\n            SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n            SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(clientSocket, host, port, true);\n            sslSocket.setUseClientMode(false);\n            sslSocket.startHandshake();\n            in = new BufferedReader(new InputStreamReader(sslSocket.getInputStream()));\n            out = new BufferedWriter(new OutputStreamWriter(sslSocket.getOutputStream()));\n            logger.log(\"TLS upgrade successful\");\n        }\n\n        public void shouldStop() {\n            this.shouldStop = true;\n        }\n    }\n\n    public interface SmtpInteraction {}\n\n    public static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n\n        public String getCommand() {\n            return command;\n        }\n    }\n\n    public static class CannedResponse implements SmtpInteraction {\n        private final String response;\n\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n\n        public String getResponse() {\n            return response;\n        }\n    }\n\n    public static class UpgradeToTls implements SmtpInteraction {}\n\n    public interface Logger {\n        void log(String message);\n    }\n\n    public interface KeyStoreProvider {\n        KeyStore getKeyStore() throws Exception;\n        char[] getKeyStorePassword();\n    }\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestTemplate;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n    public String uploadMedia(String type, String mediaFileUrl) throws IOException {\n        String accessToken = wechatAccessTokenUtil.getAccessToken();\n        String url = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n\n        URL urlObj = new URL(mediaFileUrl);\n        Path tempFile = Files.createTempFile(\"media\", \"\");\n        Files.copy(urlObj.openStream(), tempFile, StandardCopyOption.REPLACE_EXISTING);\n\n        FileSystemResource resource = new FileSystemResource(tempFile.toFile());\n        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();\n        body.add(\"media\", resource);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);\n        RestTemplate restTemplate = new RestTemplate();\n        String response = restTemplate.postForObject(url, requestEntity, String.class);\n\n        Files.deleteIfExists(tempFile);\n        return response; // Assuming the response contains the media_id directly\n    }\n\n    public String judgeType(String contentType) {\n        switch (contentType) {\n            case \"image/jpeg\":\n                return \".jpg\";\n            case \"image/png\":\n                return \".png\";\n            case \"voice/amr\":\n                return \".amr\";\n            case \"video/mp4\":\n                return \".mp4\";\n            default:\n                throw new IllegalArgumentException(\"Unsupported media type: \" + contentType);\n        }\n    }\n}"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.*;\nimport java.net.InetSocketAddress;\n\nclass SocketClient {\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocketFactory factory = clientSslContext.getSocketFactory();\n        try (SSLSocket sslSocket = (SSLSocket) factory.createSocket()) {\n            sslSocket.connect(address);\n            sslSocket.startHandshake();\n\n            OutputStream os = sslSocket.getOutputStream();\n            PrintWriter out = new PrintWriter(os, true);\n\n            out.println(\"GET / HTTP/1.1\");\n            out.println(\"Host: \" + address.getHostName());\n            out.println(\"Connection: close\");\n            out.println();\n\n            readResponse(sslSocket);\n        }\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = is.read()) != '\\n') {\n            if (c == '\\r') continue;\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream is = sslSocket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n\n        String line;\n        while (!(line = readLine(is)).isEmpty()) {\n            System.out.println(line);\n        }\n\n        StringBuilder body = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            body.append(line).append(\"\\n\");\n        }\n\n        System.out.println(\"Response Body:\\n\" + body.toString());\n    }\n}"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Random;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.os.Handler;\n\npublic class RouterSocketClient {\n    private static final String TAG = \"RouterSocketClient\";\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random random) {\n        this.mContext = context;\n        this.mConnectivityManager = connectivityManager;\n        this.mDelayedRestartHandler = new Handler(context.getMainLooper());\n        SSLContext sslContext;\n        try {\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, null, random);\n            mSSLSocketFactory = sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n        // Logic to determine if a proxy is needed and call appropriate method\n        return connectSocketNoProxy(host, port); // Simplified for example\n    }\n\n    public static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n        return socket;\n    }\n\n    public static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(proxyAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n        // Send HTTP CONNECT request here\n        return socket;\n    }\n\n    private void tryEnableSni(SSLSocket socket, String hostname) {\n        if (socket instanceof SSLSocket) {\n            socket.setEnabledProtocols(socket.getSupportedProtocols());\n            if (hostname != null) {\n                socket.startHandshake();\n                // SNI is automatically handled by the JDK for TLS 1.2+\n            }\n        }\n    }\n\n    private void tryEnableSessionTickets(SSLSocket socket) {\n        if (socket instanceof SSLSocket) {\n            socket.setEnabledProtocols(socket.getSupportedProtocols());\n            // Session ticket enabling logic would go here if necessary\n        }\n    }\n}"
  },
  {
    "Task_id": 563,
    "Instruction": "Task Description: Create a Java function that tests a client-server connection using Socket programming, including handling connection events and verifying successful communication.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP GET request, and verifies both connection establishment and message delivery. It uses CountDownLatch for synchronization between the main thread and callback handlers. The function fails if either the connection or message delivery doesn't complete within specified timeouts.\n\nInput: None (uses DefaultServer class for host configuration)\n\nOutput: None (throws exceptions or asserts failures for unsuccessful operations)\n\nKey Operations:\n1. Creates Socket connection to default server\n2. Sets up server event handlers with callbacks\n3. Obtains input/output streams for communication\n4. Sends HTTP GET request\n5. Verifies connection establishment within 10 seconds\n6. Verifies message delivery within 10 seconds\n7. Properly closes resources\n8. Uses synchronization primitives for thread coordination",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testConnectionFail() throws IOException, InterruptedException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch connected = new CountDownLatch(1);\n    DefaultServer.setRootHandler(new ServerSentEventHandler(new ServerSentEventConnectionCallback() {\n        @Override\n        public void connected(final ServerSentEventConnection connection, final String lastEventId) {\n            final XnioIoThread thread = (XnioIoThread) Thread.currentThread();\n            connected.countDown();\n            thread.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connection.send(\"hello\", new ServerSentEventConnection.EventCallback() {\n                        @Override\n                        public void done(ServerSentEventConnection connection, String data, String event, String id) {\n                        }\n\n                        @Override\n                        public void failed(ServerSentEventConnection connection, String data, String event, String id, IOException e) {\n                            latch.countDown();\n                        }\n                    });\n                    if(latch.getCount() > 0) {\n                        WorkerUtils.executeAfter(thread, this, 100, TimeUnit.MILLISECONDS);\n                    }\n                }\n            });\n        }\n    }));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET / HTTP/1.1\\r\\nHost:\" + DefaultServer.getHostAddress() +\"\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    if(!connected.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n    out.close();\n    in.close();\n    if(!latch.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic class SocketTest {\n\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 8080;\n    private static final String REQUEST = \"GET / HTTP/1.1\\r\\nHost: \" + HOST + \"\\r\\nConnection: close\\r\\n\\r\\n\";\n    private static final int TIMEOUT_SECONDS = 10;\n\n    public void testClientServerConnection() throws Exception {\n        CountDownLatch connectionLatch = new CountDownLatch(1);\n        CountDownLatch responseLatch = new CountDownLatch(1);\n\n        try (Socket socket = new Socket(HOST, PORT)) {\n            connectionLatch.countDown();\n\n            OutputStream out = socket.getOutputStream();\n            PrintWriter writer = new PrintWriter(out, true);\n            writer.print(REQUEST);\n\n            InputStream in = socket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            responseLatch.countDown();\n\n            if (!connectionLatch.await(TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n                throw new RuntimeException(\"Connection timed out\");\n            }\n            if (!responseLatch.await(TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n                throw new RuntimeException(\"Response timed out\");\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error during communication\", e);\n        }\n    }\n\n    public static void main(String[] args) {\n        SocketTest test = new SocketTest();\n        try {\n            test.testClientServerConnection();\n            System.out.println(\"Test passed\");\n        } catch (Exception e) {\n            System.err.println(\"Test failed: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 564,
    "Instruction": "Task Description: Write a function that tests abnormal request termination behavior in a client-server communication scenario using TCP sockets. The function should simulate sending a malformed HTTP request with incorrect content length and verify proper connection handling.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP POST request with intentionally incorrect Content-Length header, immediately closes the streams, and verifies if the completion listener is called within a timeout period. This tests the server's handling of abruptly terminated requests.\n\nInput: \n- None (uses class-level DefaultServer.getDefaultServerAddress() and completionListenerCalledLatch)\n- Implicit input through class attributes:\n  - DefaultServerAddress: Server endpoint address\n  - completionListenerCalledLatch: CountDownLatch for synchronization\n  - completionListenerCalled: boolean flag to verify listener invocation\n\nOutput: \n- None (void return type)\n- Side effects:\n  - Throws IOException if socket operations fail\n  - Throws InterruptedException if await is interrupted\n  - Asserts completionListenerCalled is true\n  - Closes socket resources in finally block",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(DefaultServer.getDefaultServerAddress());\n    try {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000; ++i) {\n            sb.append(\"hello world\\r\\n\");\n        }\n        String request = \"POST / HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n        OutputStream outputStream = socket.getOutputStream();\n\n        outputStream.write(request.getBytes(\"US-ASCII\"));\n        socket.getInputStream().close();\n        outputStream.close();\n\n        completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertTrue(completionListenerCalled);\n    } finally {\n        IoUtils.safeClose(socket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\n\npublic class AbnormalRequestTest {\n    private static final String DefaultServerAddress = \"localhost\";\n    private static final int SERVER_PORT = 8080;\n    private static CountDownLatch completionListenerCalledLatch = new CountDownLatch(1);\n    private static boolean completionListenerCalled = false;\n\n    public static void testAbnormalRequestTermination() throws IOException, InterruptedException {\n        Socket socket = null;\n        OutputStream out = null;\n        try {\n            socket = new Socket(DefaultServerAddress, SERVER_PORT);\n            out = socket.getOutputStream();\n\n            // Send a malformed HTTP POST request with incorrect Content-Length\n            String request = \"POST /test HTTP/1.1\\r\\n\" +\n                             \"Host: \" + DefaultServerAddress + \"\\r\\n\" +\n                             \"Content-Length: 100\\r\\n\" +\n                             \"\\r\\n\" +\n                             \"Short body\";\n\n            out.write(request.getBytes());\n            out.flush();\n\n            // Immediately close the streams\n            out.close();\n            socket.shutdownOutput();\n\n            // Verify if the completion listener is called within a timeout period\n            boolean completed = completionListenerCalledLatch.await(5, java.util.concurrent.TimeUnit.SECONDS);\n            assert completionListenerCalled : \"Completion listener was not called\";\n            assert completed : \"Timed out waiting for completion listener\";\n\n        } catch (IOException e) {\n            throw new IOException(\"Socket operation failed\", e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new InterruptedException(\"Await interrupted\");\n        } finally {\n            if (out != null) {\n                out.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.net.UnixDomainSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.channels.ClosedChannelException;\nimport java.net.SocketException;\n\nabstract class AbstractSocket {\n    // Placeholder for abstract methods or common functionality\n}\n\npublic class UnixSocket extends AbstractSocket {\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws IOException {\n        this.socketAddress = UnixDomainSocketAddress.of(path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    public InputStream getInputStream() throws IOException {\n        if (!socketChannel.isOpen()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        return new UnixSocketInputStream(socketChannel);\n    }\n\n    public OutputStream getOutputStream() throws IOException {\n        if (!socketChannel.isOpen()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        return new UnixSocketOutputStream(new WrappedWritableByteChannel(socketChannel));\n    }\n\n    public SocketAddress getLocalSocketAddress() {\n        return socketChannel.socket().getLocalSocketAddress();\n    }\n\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress; // For Unix domain sockets, local and remote addresses are the same\n    }\n\n    public void close() throws IOException {\n        socketChannel.close();\n    }\n\n    private static class WrappedWritableByteChannel implements WritableByteChannel {\n        private final SocketChannel socketChannel;\n\n        WrappedWritableByteChannel(SocketChannel socketChannel) {\n            this.socketChannel = socketChannel;\n        }\n\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            if (!isOpen()) {\n                throw new ClosedChannelException();\n            }\n            return socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            socketChannel.close();\n        }\n    }\n\n    private static class UnixSocketInputStream extends InputStream {\n        private final SocketChannel socketChannel;\n\n        UnixSocketInputStream(SocketChannel socketChannel) {\n            this.socketChannel = socketChannel;\n        }\n\n        @Override\n        public int read() throws IOException {\n            ByteBuffer buffer = ByteBuffer.allocate(1);\n            int bytesRead = socketChannel.read(buffer);\n            if (bytesRead == -1) {\n                return -1; // End of stream\n            }\n            buffer.flip();\n            return buffer.get() & 0xFF;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n            int bytesRead = socketChannel.read(buffer);\n            if (bytesRead == -1) {\n                return -1; // End of stream\n            }\n            return bytesRead;\n        }\n\n        @Override\n        public void close() throws IOException {\n            socketChannel.close();\n        }\n    }\n\n    private static class UnixSocketOutputStream extends OutputStream {\n        private final WritableByteChannel writableByteChannel;\n\n        UnixSocketOutputStream(WritableByteChannel writableByteChannel) {\n            this.writableByteChannel = writableByteChannel;\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            ByteBuffer buffer = ByteBuffer.allocate(1);\n            buffer.put((byte) b);\n            buffer.flip();\n            writableByteChannel.write(buffer);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n            writableByteChannel.write(buffer);\n        }\n\n        @Override\n        public void close() throws IOException {\n            writableByteChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 567,
    "Instruction": "Task Description: Implement a TCP client class in Java that handles network communication with a server, including connection management, data transmission, and reception with proper error handling and resource management.\n\nClass Description: The TcpClient class establishes and maintains a TCP connection to a specified server, sends data packets, and receives responses. It uses a custom protocol with 8-byte headers (4 bytes for type, 4 bytes for length) followed by the message body. The class runs network operations on a dedicated background thread and provides callback mechanisms for received data.\n\nAttributes:\n- TAG: String - Tag for logging purposes\n- PACKAGE_HEAD_LENGTH: int - Fixed length of packet header (8 bytes)\n- receiveListener: ReceiveListener - Callback interface for received data\n- hostip: String - Server IP address to connect to\n- port: int - Server port number\n- socketClient: Socket - The TCP socket instance\n- handler: Handler - Handler for background thread operations\n- receiveThread: Thread - Thread for receiving data\n\nMethods:\n- TcpClient() -> void - Constructor that initializes the background thread and attempts connection\n- tryConnect() -> void - Internal method to attempt server connection in a loop\n- connect() -> boolean - Establishes socket connection to server (returns success status)\n- send(byte[] data) -> void - Sends data to the server (runs on background thread)\n- onReceive(ReceiveListener receiveListener) -> void - Sets the receive callback listener\n- destroy() -> void - Cleans up resources and stops all network operations\n- closeAll() -> void - Safely closes socket and releases resources\n- startReceive() -> void - Starts the data receiving thread\n- getLengthFromHeadByte(byte[] b) -> int - Extracts message length from header bytes\n- getTypeFromHeadByte(byte[] b) -> int - Extracts message type from header bytes\n\nNested Classes:\n- Receiver implements Runnable - Background thread implementation for continuous data reception",
    "Canonical_solution": "import android.os.Handler;\nimport android.os.HandlerThread;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\npublic class TcpClient {\n    private static final String TAG = TcpClient.class.getSimpleName();\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n\n    private ReceiveListener receiveListener;\n    private String hostip = \"192.168.3.28\";\n    private int port = 2233;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        HandlerThread tcpThread = new HandlerThread(\"tcpThread\");\n        tcpThread.start();\n        handler = new Handler(tcpThread.getLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        handler.post(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n            }\n        });\n    }\n\n    private boolean connect() {\n        closeAll();\n        try {\n            socketClient = new Socket();\n            SocketAddress socAddress = new InetSocketAddress(hostip, port);\n            socketClient.connect(socAddress, 5000);\n            Log.i(TAG, \"socket connected successfully\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public void send(byte[] data) {\n        Log.d(TAG, \"send data len:\" + data.length);\n        handler.post(() -> {\n            try {\n                OutputStream outputStream = socketClient.getOutputStream();\n                outputStream.write(data);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient == null || socketClient.isClosed() || !socketClient.isConnected()) {\n            return;\n        }\n        try {\n            socketClient.shutdownInput();\n            socketClient.shutdownOutput();\n            socketClient.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                if (receiveThread.isInterrupted()) {\n                    break;\n                }\n                try {\n                    InputStream inputStream = socketClient.getInputStream();\n                    boolean badPackage = false;\n                    int countHeadBytesLength = 0;\n                    byte[] headData = new byte[PACKAGE_HEAD_LENGTH];\n                    while (countHeadBytesLength < PACKAGE_HEAD_LENGTH) {\n                        int result = inputStream.read(headData, countHeadBytesLength, PACKAGE_HEAD_LENGTH - countHeadBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countHeadBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    int packageType = getTypeFromHeadByte(headData);\n                    int packageBodyBytesLength = getLengthFromHeadByte(headData);\n                    Log.d(TAG, \"new data received type:\" + packageType + \" body len:\" + packageBodyBytesLength);\n\n                    int countBodyBytesLength = 0;\n                    byte[] bodyData = new byte[packageBodyBytesLength];\n                    while (countBodyBytesLength < packageBodyBytesLength) {\n                        int result = inputStream.read(bodyData, countBodyBytesLength, packageBodyBytesLength - countBodyBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countBodyBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceive(packageType, bodyData);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    if (receiveThread.isInterrupted()) {\n                        break;\n                    }\n                    tryConnect();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[4] & 0x00FF;\n        int ch2 = b[5] & 0x00FF;\n        int ch3 = b[6] & 0x00FF;\n        int ch4 = b[7] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n\n    private int getTypeFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[0] & 0x00FF;\n        int ch2 = b[1] & 0x00FF;\n        int ch3 = b[2] & 0x00FF;\n        int ch4 = b[3] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport android.os.Handler;\nimport android.os.Looper;\n\npublic class TcpClient {\n    private static final String TAG = \"TcpClient\";\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n    private ReceiveListener receiveListener;\n    private String hostip;\n    private int port;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient(String hostip, int port) {\n        this.hostip = hostip;\n        this.port = port;\n        this.handler = new Handler(Looper.getMainLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        new Thread(() -> {\n            while (!connect()) {\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            startReceive();\n        }).start();\n    }\n\n    private boolean connect() {\n        try {\n            socketClient = new Socket(hostip, port);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void send(byte[] data) {\n        if (socketClient == null || !socketClient.isConnected()) {\n            return;\n        }\n        new Thread(() -> {\n            try (OutputStream outputStream = socketClient.getOutputStream()) {\n                byte[] head = new byte[PACKAGE_HEAD_LENGTH];\n                int type = 1; // Example type\n                System.arraycopy(intToByteArray(type), 0, head, 0, 4);\n                System.arraycopy(intToByteArray(data.length), 0, head, 4, 4);\n                outputStream.write(head);\n                outputStream.write(data);\n            } catch (IOException e) {\n                e.printStackTrace();\n                destroy();\n            }\n        }).start();\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        closeAll();\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n    }\n\n    private void closeAll() {\n        if (socketClient != null) {\n            try {\n                socketClient.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startReceive() {\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private int getLengthFromHeadByte(byte[] b) {\n        return byteArrayToInt(b, 4);\n    }\n\n    private int getTypeFromHeadByte(byte[] b) {\n        return byteArrayToInt(b, 0);\n    }\n\n    private byte[] intToByteArray(int value) {\n        return new byte[]{\n                (byte) (value >>> 24),\n                (byte) (value >>> 16),\n                (byte) (value >>> 8),\n                (byte) value};\n    }\n\n    private int byteArrayToInt(byte[] bytes, int offset) {\n        return ((bytes[offset] & 0xFF) << 24) |\n               ((bytes[offset + 1] & 0xFF) << 16) |\n               ((bytes[offset + 2] & 0xFF) << 8) |\n               (bytes[offset + 3] & 0xFF);\n    }\n\n    public interface ReceiveListener {\n        void onDataReceived(int type, byte[] data);\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            try (InputStream inputStream = socketClient.getInputStream()) {\n                byte[] head = new byte[PACKAGE_HEAD_LENGTH];\n                while (inputStream.read(head) == PACKAGE_HEAD_LENGTH) {\n                    int length = getLengthFromHeadByte(head);\n                    int type = getTypeFromHeadByte(head);\n                    byte[] data = new byte[length];\n                    inputStream.read(data);\n                    final int finalType = type;\n                    final byte[] finalData = data;\n                    handler.post(() -> {\n                        if (receiveListener != null) {\n                            receiveListener.onDataReceived(finalType, finalData);\n                        }\n                    });\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                destroy();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 569,
    "Instruction": "Task Description: Create a Java class that implements an IRC client connection using TCP sockets, with built-in monitoring capabilities through Stetho for network event reporting.\n\nClass Description: The IRCClientConnection class establishes and manages a connection to an IRC server, handles message sending/receiving, and provides monitoring hooks for network events. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- mReporter: [StethoReporter] - Handles network event reporting to Stetho\n- mSocket: [Socket] - The TCP socket connection to the IRC server\n- mInput: [BufferedReader] - Stream for reading incoming messages\n- mOutput: [BufferedWriter] - Stream for sending outgoing messages\n\nMethods:\n- connect: [String host, int port] -> [IRCClientConnection] - Static factory method that establishes a connection to the specified IRC server\n- read: [] -> [String] - Reads a line from the server input stream and handles PING/PONG protocol\n- send: [String message] -> [void] - Sends a message to the server\n- maybeHandleIncomingMessage: [String message] -> [boolean] - Handles protocol-specific messages (like PING)\n- close: [] -> [void] - Closes all connection resources (implements Closeable)\n- StethoReporter (inner class): [] -> [] - Handles all Stetho-specific network event reporting",
    "Canonical_solution": "import com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.SimpleTextInspectorWebSocketFrame;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.annotation.Nullable;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        StethoReporter reporter = new StethoReporter();\n        Socket socket = new Socket();\n        reporter.onPreConnect(host, port);\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            reporter.onPostConnect();\n        } catch (IOException e) {\n            reporter.onError(e);\n            try {\n                socket.close();\n                throw e;\n            } finally {\n                reporter.onClosed();\n            }\n        }\n        return new IRCClientConnection(reporter, socket, \"UTF-8\");\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, String charset) throws IOException {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream(), charset));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));\n    }\n\n    @Nullable\n    public String read() throws IOException {\n        try {\n            String message = mInput.readLine();\n            if (message != null) {\n                mReporter.onReceive(message);\n                maybeHandleIncomingMessage(message);\n            }\n            return message;\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.onSend(message);\n        try {\n            mOutput.write(message + \"\\r\\n\");\n            mOutput.flush();\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(\"PING \".length()));\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws IOException {\n        try {\n            try {\n                mOutput.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            }\n        } finally {\n            try {\n                mSocket.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            } finally {\n                mReporter.onClosed();\n            }\n        }\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mReporter;\n        private final String mRequestId;\n\n        public StethoReporter() {\n            mReporter = NetworkEventReporterImpl.get();\n            mRequestId = mReporter.nextRequestId();\n        }\n\n        public void onPreConnect(String host, int port) {\n            mReporter.webSocketCreated(mRequestId, \"irc://\" + host + \":\" + port);\n        }\n\n        public void onPostConnect() {\n            // Sadly, nothing to report...\n        }\n\n        public void onError(IOException e) {\n            mReporter.webSocketFrameError(mRequestId, e.getMessage());\n        }\n\n        public void onClosed() {\n            mReporter.webSocketClosed(mRequestId);\n        }\n\n        public void onSend(String message) {\n            mReporter.webSocketFrameSent(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n\n        public void onReceive(String message) {\n            mReporter.webSocketFrameReceived(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\n\npublic class IRCClientConnection implements Closeable {\n    private NetworkEventReporter mReporter;\n    private Socket mSocket;\n    private BufferedReader mInput;\n    private BufferedWriter mOutput;\n\n    private IRCClientConnection(String host, int port) throws IOException {\n        mReporter = NetworkEventReporterImpl.get();\n        mSocket = new Socket(host, port);\n        mInput = new BufferedReader(new InputStreamReader(mSocket.getInputStream()));\n        mOutput = new BufferedWriter(new OutputStreamWriter(mSocket.getOutputStream()));\n    }\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        return new IRCClientConnection(host, port);\n    }\n\n    public String read() throws IOException {\n        String line = mInput.readLine();\n        if (line != null) {\n            mReporter.responseBody(line.getBytes());\n            if (maybeHandleIncomingMessage(line)) {\n                return null;\n            }\n        }\n        return line;\n    }\n\n    public void send(String message) throws IOException {\n        mOutput.write(message + \"\\r\\n\");\n        mOutput.flush();\n        mReporter.requestBody(message.getBytes());\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) {\n        if (message.startsWith(\"PING\")) {\n            try {\n                send(\"PONG \" + message.substring(5));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void close() throws IOException {\n        mInput.close();\n        mOutput.close();\n        mSocket.close();\n    }\n\n    private static class StethoReporter {\n        // Implementation of Stetho-specific network event reporting\n    }\n}"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch data from a given URL and process the response as a JSON object.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests. It uses Android's AsyncTask to perform network operations in the background and processes the response data.\n\nAttributes: None (This is a utility class with static methods and nested classes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, reads the response, and publishes the progress for JSON processing.\n\nMethod2: ConvertInputToStringNoChange(InputStream inputStream) -> String - A static helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.\n\nMethod Details:\n\nMyAsyncTaskgetNews:\n- Input Parameters: String... params (varargs where params[0] should be the URL string)\n- Return Type: String (though it primarily works through side effects)\n- Description: \n  1. Creates a URL object from the input string\n  2. Opens an HttpURLConnection with a 7-second timeout\n  3. Reads the input stream and converts it to a string\n  4. Publishes the result for JSON processing in onProgressUpdate\n  5. Disconnects the connection when done\n\nConvertInputToStringNoChange:\n- Input Parameters: InputStream inputStream (the stream to read from)\n- Return Type: String (the concatenated content of the stream)\n- Description:\n  1. Creates a BufferedReader from the InputStream\n  2. Reads all lines and concatenates them into a single string\n  3. Closes the input stream\n  4. Returns the concatenated string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n            } catch (Exception ex) {}\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.os.AsyncTask;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n                urlConnection.setRequestMethod(\"GET\");\n                InputStream in = urlConnection.getInputStream();\n                String result = ConvertInputToStringNoChange(in);\n                publishProgress(result);\n                return result;\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            super.onProgressUpdate(values);\n            // Process JSON here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 572,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data from an input stream, and verifies the successful transmission of data.\n\nFunction Description: The function should establish a connection to a server using a Socket, send data from an input stream to the server via an output stream, and ensure the data was transmitted successfully. It should also handle resource cleanup and verify the progress of the transmission.\n\nInput: \n- uri: [URI] - The URI object containing the host and port of the server to connect to.\n- inputStream: [InputStream] - The input stream containing the data to be sent to the server.\n- parser: [Object] - An object that manages the start and stop of the parsing process (assumed to have start() and stop() methods).\n\nOutput: \n- bytes: [long] - The number of bytes successfully transmitted to the server.\n- The function also asserts that the socket is connected, the number of bytes transmitted is greater than 0, and the progress of the transmission matches the expected progress. \n\nNote: The function may throw IOException, InterruptedException, or URISyntaxException.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URISyntaxException;\n\npublic void testNormal() throws IOException, InterruptedException, URISyntaxException {\n    parser.start();\n\n    Socket client = new Socket(uri.getHost(), uri.getPort());\n    assertTrue(\"Socket is connected\", client.isConnected());\n\n    InputStream inputStream = combineResource(Progresses.allFiles);\n    OutputStream outputStream = client.getOutputStream();\n\n    long bytes = ByteStreams.copy(inputStream, outputStream);\n\n    Thread.sleep(100);\n\n    client.close();\n    parser.stop();\n\n    assertThat(bytes, greaterThan(0L));\n    assertThat(progesses, equalTo(Progresses.allProgresses));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class TcpClient {\n\n    public static long sendData(URI uri, InputStream inputStream, Object parser) throws IOException, InterruptedException, URISyntaxException {\n        String host = uri.getHost();\n        int port = uri.getPort();\n        long bytesSent = 0;\n        try (Socket socket = new Socket(host, port);\n             OutputStream outputStream = socket.getOutputStream()) {\n\n            if (!socket.isConnected()) {\n                throw new IOException(\"Failed to connect to server\");\n            }\n\n            parser.getClass().getMethod(\"start\").invoke(parser);\n\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n                bytesSent += bytesRead;\n            }\n\n            parser.getClass().getMethod(\"stop\").invoke(parser);\n\n            if (bytesSent <= 0) {\n                throw new IOException(\"No bytes were sent to the server\");\n            }\n\n            // Assuming progress is verified by some method in parser\n            boolean isProgressValid = (boolean) parser.getClass().getMethod(\"isProgressValid\").invoke(parser);\n            if (!isProgressValid) {\n                throw new IOException(\"Transmission progress does not match expected progress\");\n            }\n\n        } catch (Exception e) {\n            if (e instanceof IOException) {\n                throw (IOException) e;\n            } else if (e instanceof InterruptedException) {\n                throw (InterruptedException) e;\n            } else if (e instanceof URISyntaxException) {\n                throw (URISyntaxException) e;\n            } else {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return bytesSent;\n    }\n}"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\n\npublic class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n        outputStream.flush();\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            for (int i = 0; i < bytesRead; i++) {\n                if (buffer[i] == 0x04) { // EOT character\n                    return;\n                }\n            }\n            destination.write(buffer, 0, bytesRead);\n        }\n    }\n\n    public void close() {\n        try {\n            if (outputStream != null) outputStream.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n        try {\n            if (inputStream != null) inputStream.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n        try {\n            if (socket != null) socket.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n    }\n}"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import com.netflix.discovery.EurekaClient;\nimport com.netflix.discovery.shared.Application;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\n\npublic class TcpClient {\n\n    public static void connectToService(EurekaClient eurekaClient, String vipAddress) {\n        try {\n            Application application = eurekaClient.getApplication(vipAddress);\n            if (application == null) {\n                System.err.println(\"No application found with name \" + vipAddress);\n                return;\n            }\n            List<com.netflix.appinfo.InstanceInfo> instances = application.getInstances();\n            if (instances.isEmpty()) {\n                System.err.println(\"No instances available for \" + vipAddress);\n                return;\n            }\n\n            com.netflix.appinfo.InstanceInfo instanceInfo = instances.get(0);\n            String host = instanceInfo.getIPAddr();\n            int port = instanceInfo.getPort();\n\n            Socket socket = new Socket(host, port);\n            OutputStream outputStream = socket.getOutputStream();\n            PrintWriter out = new PrintWriter(outputStream, true);\n\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String request = \"Request at \" + sdf.format(new Date());\n            out.println(request);\n\n            InputStream inputStream = socket.getInputStream();\n            BufferedReader in = new BufferedReader(new InputStreamReader(inputStream));\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(\"Server response: \" + response);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            System.err.println(\"IO Exception: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\n\nclass FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        Socket client = null;\n        OutputStream out = null;\n        InputStream in = null;\n        try {\n            client = new Socket(host, port);\n            out = client.getOutputStream();\n            in = client.getInputStream();\n\n            out.write(command.getBytes());\n            out.flush();\n\n            return response(client);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            cleanup(out);\n            cleanup(in);\n            cleanup(client);\n        }\n    }\n\n    private String response(Socket client) throws IOException {\n        InputStream in = client.getInputStream();\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) != -1) {\n            result.write(buffer, 0, length);\n        }\n        return result.toString(\"UTF-8\");\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.util.logging.Logger;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024; // 10MB\n    private static final int READ_BUFFER_SIZE = 5 * 1024; // 5KB\n    private final Logger log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final ScrcpyLocalThread scrcpyLocalThread;\n    private final Session session;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.log = Logger.getLogger(ScrcpyInputSocketThread.class.getName());\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        Socket socket = null;\n        InputStream inputStream = null;\n        try {\n            int localPort = 27183;\n            iDevice.createForward(localPort, \"localabstract:scrcpy\");\n            socket = new Socket(\"localhost\", localPort);\n            inputStream = socket.getInputStream();\n\n            // Send device screen dimensions via WebSocket\n            String dimensions = getDeviceScreenDimensions();\n            session.sendMessage(dimensions);\n\n            byte[] buffer = new byte[READ_BUFFER_SIZE];\n            int bytesRead;\n            while (!Thread.currentThread().isInterrupted() && (bytesRead = inputStream.read(buffer)) != -1) {\n                byte[] data = new byte[bytesRead];\n                System.arraycopy(buffer, 0, data, 0, bytesRead);\n                processNALUnits(data);\n                dataQueue.put(data);\n            }\n        } catch (IOException | InterruptedException e) {\n            log.severe(\"Error in ScrcpyInputSocketThread: \" + e.getMessage());\n        } finally {\n            try {\n                if (inputStream != null) inputStream.close();\n                if (socket != null) socket.close();\n                iDevice.removeForward(27183);\n                if (session.isOpen()) session.close();\n                scrcpyLocalThread.interrupt();\n                if (androidTestTaskBootThread != null) androidTestTaskBootThread.interrupt();\n            } catch (IOException e) {\n                log.severe(\"Error closing resources in ScrcpyInputSocketThread: \" + e.getMessage());\n            }\n        }\n    }\n\n    private String getDeviceScreenDimensions() {\n        // Implement logic to retrieve device screen dimensions\n        return \"{\\\"width\\\": 1920, \\\"height\\\": 1080}\";\n    }\n\n    private void processNALUnits(byte[] data) {\n        // Implement logic to detect and process NAL units\n    }\n\n    public void setAndroidTestTaskBootThread(AndroidTestTaskBootThread androidTestTaskBootThread) {\n        this.androidTestTaskBootThread = androidTestTaskBootThread;\n    }\n}"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass HTTPPacket {\n    protected Map<String, String> headers;\n    protected String body;\n\n    public HTTPPacket() {\n        this.headers = new HashMap<>();\n        this.body = \"\";\n    }\n\n    public void addHeader(String key, String value) {\n        headers.put(key, value);\n    }\n\n    public void setBody(String body) {\n        this.body = body;\n    }\n\n    public String getHeadersAsString() {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\r\\n\");\n        }\n        return sb.toString();\n    }\n}\n\nclass HTTPResponse extends HTTPPacket {\n    private int statusCode;\n    private String statusMessage;\n\n    public HTTPResponse(int statusCode, String statusMessage) {\n        super();\n        this.statusCode = statusCode;\n        this.statusMessage = statusMessage;\n    }\n\n    public int getStatusCode() {\n        return statusCode;\n    }\n\n    public String getStatusMessage() {\n        return statusMessage;\n    }\n}\n\nclass HTTPRequest extends HTTPPacket {\n    private Socket postSocket;\n\n    public HTTPRequest() {\n        super();\n    }\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        postSocket = new Socket(host, port);\n        OutputStream out = postSocket.getOutputStream();\n        PrintWriter writer = new PrintWriter(out, true);\n\n        // Prepare the request\n        StringBuilder request = new StringBuilder();\n        request.append(\"POST / HTTP/1.1\\r\\n\");\n        request.append(\"Host: \").append(host).append(\"\\r\\n\");\n        request.append(getHeadersAsString());\n        if (!isKeepAlive) {\n            request.append(\"Connection: close\\r\\n\");\n        }\n        request.append(\"Content-Length: \").append(body.length()).append(\"\\r\\n\");\n        request.append(\"\\r\\n\");\n        request.append(body);\n\n        // Send the request\n        writer.print(request.toString());\n\n        // Read the response\n        InputStream in = postSocket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line = reader.readLine();\n        String[] statusParts = line.split(\" \");\n        int statusCode = Integer.parseInt(statusParts[1]);\n        String statusMessage = statusParts[2];\n\n        HTTPResponse response = new HTTPResponse(statusCode, statusMessage);\n        while ((line = reader.readLine()) != null && !line.isEmpty()) {\n            String[] headerParts = line.split(\": \", 2);\n            response.addHeader(headerParts[0], headerParts[1]);\n        }\n\n        StringBuilder responseBody = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            responseBody.append(line).append(\"\\n\");\n        }\n        response.setBody(responseBody.toString());\n\n        if (!isKeepAlive) {\n            postSocket.close();\n        }\n\n        return response;\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n}"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n\n            String response;\n            while ((response = mBufferedReader.readLine()) != null) {\n                System.out.println(\"Server: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mBufferedReader != null) mBufferedReader.close();\n            if (mPrintWriter != null) mPrintWriter.close();\n            if (mClientSocket != null && !mClientSocket.isClosed()) mClientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\nclass Networker {\n    private static final Networker sInstance = new Networker();\n    private final Executor sExecutor = Executors.newFixedThreadPool(5);\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    public static Networker get() {\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private final HttpRequest request;\n        private final Callback callback;\n\n        HttpRequestTask(HttpRequest request, Callback callback) {\n            this.request = request;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                HttpResponse response = doFetch();\n                callback.onResponse(response);\n            } catch (IOException e) {\n                callback.onFailure(e);\n            }\n        }\n\n        private HttpResponse doFetch() throws IOException {\n            HttpURLConnection conn = configureAndConnectRequest();\n            try (InputStream in = applyDecompressionIfApplicable(conn, conn.getInputStream())) {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                copy(in, out, new byte[4096]);\n                return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n            } finally {\n                conn.disconnect();\n            }\n        }\n\n        private HttpURLConnection configureAndConnectRequest() throws IOException {\n            HttpURLConnection conn = (HttpURLConnection) new URL(request.url).openConnection();\n            conn.setRequestMethod(request.method.name());\n            requestDecompression(conn);\n            conn.setReadTimeout(READ_TIMEOUT_MS);\n            conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n            if (request.body != null) {\n                conn.setDoOutput(true);\n                try (OutputStream os = conn.getOutputStream()) {\n                    os.write(request.body);\n                }\n            }\n            return conn;\n        }\n\n        private void requestDecompression(HttpURLConnection conn) {\n            conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n        }\n\n        private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n            String encoding = conn.getContentEncoding();\n            if (GZIP_ENCODING.equals(encoding)) {\n                return new GZIPInputStream(in);\n            }\n            return in;\n        }\n\n        private void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n            int len;\n            while ((len = in.read(buf)) != -1) {\n                out.write(buf, 0, len);\n            }\n        }\n    }\n\n    public static class HttpRequest {\n        private final String friendlyName;\n        private final HttpMethod method;\n        private final String url;\n        private final byte[] body;\n\n        private HttpRequest(Builder b) {\n            this.friendlyName = b.friendlyName;\n            this.method = b.method;\n            this.url = b.url;\n            this.body = b.body;\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        public static class Builder {\n            private String friendlyName;\n            private HttpMethod method;\n            private String url;\n            private byte[] body;\n\n            public Builder friendlyName(String friendlyName) {\n                this.friendlyName = friendlyName;\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                this.method = method;\n                return this;\n            }\n\n            public Builder url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                this.body = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public static class HttpResponse {\n        private final int statusCode;\n        private final byte[] body;\n\n        public HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n\n        void onFailure(IOException e);\n    }\n\n    public enum HttpMethod {\n        GET,\n        POST,\n        PUT,\n        DELETE\n    }\n}"
  },
  {
    "Task_id": 580,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data, and receives a response.\n\nFunction Description: The function `showText` establishes a TCP connection to a specified server using the provided IP address and port. It sends a sequence of bytes (`seq`) to the server and reads the response. The response is parsed into a `BxResp` object. The function handles connection timeouts and IO exceptions.\n\nInput:\n- `ip`: [String] - The IP address of the server to connect to.\n- `port`: [Integer] - The port number of the server to connect to.\n- `contents`: [List<String>] - A list of strings representing the data to be sent (Note: The reference code uses `seq` for sending data, but `contents` is not directly used in the provided snippet. Clarification may be needed on how `contents` maps to `seq`).\n\nOutput:\n- The function does not explicitly return a value but processes the server's response into a `BxResp` object. If an error occurs, it prints the stack trace.\n\nNote: The reference code snippet references a variable `seq` that is not defined in the provided code. Ensure `seq` is properly initialized from `contents` or another source before calling `out.write(seq)`.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\n\npublic static void showText(String ip, Integer port, List<String> contents) throws Exception {\n    // Create Socket\n    Socket client = new Socket();\n    // Create socket address\n    SocketAddress address = new InetSocketAddress(ip, port);\n    \n    try {\n        // Establish TCP connection\n        client.connect(address, 3000);\n        // Set read timeout\n        client.setSoTimeout(3000);\n        \n        // Create output stream\n        OutputStream out = client.getOutputStream();\n        // Create input stream\n        InputStream in = client.getInputStream();\n        \n        // Write data\n        out.write(seq);\n        \n        // Read response\n        byte[] resp = new byte[1024];\n        int len = in.read(resp);\n        \n        // Parse response\n        BxResp bxResp = BxResp.parse(resp, len);\n        \n        // Close resources\n        out.close();\n        in.close();\n        client.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\nclass BxResp {\n    // Assuming BxResp has some fields and a constructor to parse data\n    public BxResp(byte[] data) {\n        // Parse data into BxResp fields\n    }\n}\n\npublic class TcpClient {\n\n    public static void showText(String ip, int port, List<String> contents) {\n        Socket socket = null;\n        try {\n            socket = new Socket(ip, port);\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n\n            // Convert contents to byte array for sending\n            StringBuilder sb = new StringBuilder();\n            for (String content : contents) {\n                sb.append(content);\n            }\n            byte[] seq = sb.toString().getBytes();\n\n            out.write(seq);\n            out.flush();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            byte[] response = new byte[bytesRead];\n            System.arraycopy(buffer, 0, response, 0, bytesRead);\n\n            BxResp resp = new BxResp(response);\n            // Process resp as needed\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        List<String> contents = List.of(\"Hello\", \" \", \"World\");\n        showText(\"127.0.0.1\", 12345, contents);\n    }\n}"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.*;\n\nclass UnicastTestTcpSlow {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private final Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws IOException {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n\n        srv_sock = new ServerSocket(local_port);\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        try {\n            sock = new Socket();\n            sock.connect(remote);\n            output = new DataOutputStream(sock.getOutputStream());\n        } catch (IOException e) {\n            System.err.println(\"Failed to connect to remote host: \" + e.getMessage());\n        }\n    }\n\n    public void receive(Message msg) {\n        System.out.println(\"Received message of type: \" + msg.getType());\n    }\n\n    public static Message readMessage(byte[] buf, int offset, int length) {\n        // Deserialize message from byte array\n        return new Message(buf, offset, length);\n    }\n\n    private class Acceptor extends Thread {\n        @Override\n        public void run() {\n            while (true) {\n                try (Socket clientSock = srv_sock.accept();\n                     DataInputStream in = new DataInputStream(clientSock.getInputStream())) {\n                    handleRequest(in);\n                } catch (IOException e) {\n                    System.err.println(\"Error handling request: \" + e.getMessage());\n                }\n            }\n        }\n\n        private void handleRequest(DataInputStream in) throws IOException {\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            if (bytesRead > 0) {\n                Message msg = readMessage(buffer, 0, bytesRead);\n                receive(msg);\n            }\n        }\n    }\n\n    static class Message {\n        private final byte[] data;\n        private final int offset;\n        private final int length;\n\n        public Message(byte[] data, int offset, int length) {\n            this.data = data;\n            this.offset = offset;\n            this.length = length;\n        }\n\n        public String getType() {\n            // Assuming first byte represents message type\n            return String.valueOf(data[offset]);\n        }\n    }\n}"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class QmpClient {\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{\\\"execute\\\": \\\"qmp_capabilities\\\"}\";\n    private boolean external = false;\n    private String unixSocketPath = \"/tmp/qmp-sock\";\n    private String host = \"localhost\";\n    private int port = 4444;\n\n    public void setExternal(boolean value) {\n        external = value;\n    }\n\n    public String sendCommand(String command) {\n        try {\n            if (external) {\n                try (Socket socket = new Socket(host, port);\n                     PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                     BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n                    sendRequest(out, requestCommandMode);\n                    getResponse(in);\n                    sendRequest(out, command);\n                    return getResponse(in);\n                }\n            } else {\n                try (SocketChannel channel = SocketChannel.open(Paths.get(unixSocketPath));\n                     OutputStream os = Channels.newOutputStream(channel);\n                     PrintWriter out = new PrintWriter(os, true);\n                     InputStream is = Channels.newInputStream(channel);\n                     BufferedReader in = new BufferedReader(new InputStreamReader(is))) {\n                    sendRequest(out, requestCommandMode);\n                    getResponse(in);\n                    sendRequest(out, command);\n                    return getResponse(in);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private String tryGetResponse(BufferedReader in) {\n        int retries = 5;\n        while (retries > 0) {\n            try {\n                return in.readLine();\n            } catch (IOException e) {\n                retries--;\n                if (retries == 0) throw new RuntimeException(\"Failed to read response\", e);\n            }\n        }\n        return null;\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n    }\n\n    private String getResponse(BufferedReader in) {\n        String response = tryGetResponse(in);\n        if (response == null) {\n            throw new RuntimeException(\"No response received\");\n        }\n        return response;\n    }\n}"
  },
  {
    "Task_id": 587,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that enables message exchange between a client and server, supporting both sending and receiving of messages with proper resource management.\n\nClass Description: UnicastTestTcp is a class that establishes TCP connections for unicast communication between two endpoints. It acts as both a client (connecting to a remote server) and a server (accepting connections from remote clients). The class handles message serialization/deserialization and provides thread-safe operations for sending messages.\n\nAttributes:\n- local: InetSocketAddress - The local address and port for server socket binding\n- remote: InetSocketAddress - The remote address and port for client connection\n- sock: Socket - The client socket for outgoing connections\n- output: DataOutputStream - The output stream for sending data to the remote endpoint\n- output_lock: Lock - A reentrant lock for thread-safe output operations\n- srv_sock: ServerSocket - The server socket for accepting incoming connections\n- acceptor: Acceptor - A thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up both server and client sockets. Throws Exception if initialization fails.\n- writeMessage(Message msg, DataOutputStream out) -> static void - Serializes and writes a message to the output stream. Throws Exception if writing fails.\n- readMessage(DataInput in) -> static Message - Reads and deserializes a message from the input stream. Throws Exception if reading fails.\n- receive(Message msg) -> void - Processes received messages based on their type (START or DATA)\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Continuously accepts new connections and processes incoming messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from an established connection. Throws Exception if processing fails.",
    "Canonical_solution": "import org.jgroups.*;\nimport org.jgroups.stack.IpAddress;\nimport org.jgroups.util.DefaultSocketFactory;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    protected InetSocketAddress local, remote;\n    protected Socket sock;\n    protected DataOutputStream output;\n    protected final Lock output_lock = new ReentrantLock();\n    protected ServerSocket srv_sock;\n    protected Acceptor acceptor;\n\n    protected static final boolean TCP_NODELAY = false;\n    protected static final int SOCK_SEND_BUF_SIZE = 200 * 1000;\n    protected static final int SOCK_RECV_BUF_SIZE = 200 * 1000;\n    protected static final byte START = 1;\n    protected static final byte DATA = 2;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(),\n                                         local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected static final void writeMessage(final Message msg, DataOutputStream out) throws Exception {\n        byte flags = 0;\n        if(msg.getDest() == null)\n            flags += (byte)2;\n        out.writeShort(Version.version);\n        out.writeByte(flags);\n        msg.writeTo(out);\n    }\n\n    protected static final Message readMessage(DataInput in) throws Exception {\n        short ver = in.readShort();\n        byte flags = in.readByte();\n        Message msg = new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    protected class Acceptor extends Thread {\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in = new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    public void receive(Message msg) {\n        byte[] buf = msg.getArray();\n        byte type = buf[msg.getOffset()];\n\n        switch(type) {\n            case START:\n                ByteBuffer tmp = ByteBuffer.wrap(buf, 1+msg.getOffset(), Global.LONG_SIZE);\n                int num_msgs = (int)tmp.getLong();\n                System.out.println(\"Received START message with \" + num_msgs + \" messages\");\n                break;\n            case DATA:\n                System.out.println(\"Received DATA message\");\n                break;\n            default:\n                System.err.println(\"Type \" + type + \" is invalid\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass UnicastTestTcp {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private final Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = new ServerSocket(local_port);\n        acceptor = new Acceptor();\n        acceptor.start();\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n    }\n\n    public static void writeMessage(Message msg, DataOutputStream out) throws Exception {\n        out.writeInt(msg.getType().ordinal());\n        out.writeUTF(msg.getContent());\n        out.flush();\n    }\n\n    public static Message readMessage(DataInput in) throws Exception {\n        MessageType type = MessageType.values()[in.readInt()];\n        String content = in.readUTF();\n        return new Message(type, content);\n    }\n\n    public void receive(Message msg) {\n        switch (msg.getType()) {\n            case START:\n                System.out.println(\"Received start message: \" + msg.getContent());\n                break;\n            case DATA:\n                System.out.println(\"Received data message: \" + msg.getContent());\n                break;\n        }\n    }\n\n    private class Acceptor extends Thread {\n        @Override\n        public void run() {\n            while (!srv_sock.isClosed()) {\n                try (Socket client = srv_sock.accept();\n                     DataInputStream in = new DataInputStream(client.getInputStream())) {\n                    handleRequest(in);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    enum MessageType {\n        START,\n        DATA\n    }\n\n    static class Message {\n        private final MessageType type;\n        private final String content;\n\n        public Message(MessageType type, String content) {\n            this.type = type;\n            this.content = content;\n        }\n\n        public MessageType getType() {\n            return type;\n        }\n\n        public String getContent() {\n            return content;\n        }\n    }\n}"
  },
  {
    "Task_id": 589,
    "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n    private String proxyHost;\n    private int proxyPort;\n    private String proxyUser;\n    private String proxyPass;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException {\n        return createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        Socket socket = new Socket(new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort)));\n        if (localHost != null) {\n            socket.bind(new InetSocketAddress(localHost, localPort));\n        }\n        socket.connect(new InetSocketAddress(host, port));\n        if (proxyType == Proxy.Type.HTTP) {\n            connectToProxy(socket, host, port);\n        }\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return createSocket(host.getHostName(), port);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n        return createSocket(address.getHostName(), port, localAddress, localPort);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return new Socket(new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort)));\n    }\n\n    private void connectToProxy(Socket socket, String host, int port) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        PrintWriter writer = new PrintWriter(new OutputStreamWriter(out, StandardCharsets.US_ASCII), true);\n        InputStream in = socket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.US_ASCII));\n\n        writer.println(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\");\n        writer.println(\"Host: \" + host + \":\" + port);\n        if (proxyUser != null && proxyPass != null) {\n            writer.println(\"Proxy-Authorization: Basic \" + getBasicAuthStr());\n        }\n        writer.println();\n\n        String statusLine = readLine(reader);\n        int statusCode = getResponseCode(statusLine);\n        if (statusCode != 200) {\n            throw new IOException(\"Failed to connect to proxy. Status code: \" + statusCode);\n        }\n    }\n\n    private String getBasicAuthStr() {\n        String auth = proxyUser + \":\" + proxyPass;\n        return Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.US_ASCII));\n    }\n\n    private String readLine(BufferedReader reader) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while ((ch = reader.read()) != -1) {\n            if (ch == '\\r') {\n                continue;\n            } else if (ch == '\\n') {\n                break;\n            }\n            sb.append((char) ch);\n        }\n        return sb.toString();\n    }\n\n    private static int getResponseCode(String statusLine) {\n        String[] parts = statusLine.split(\"\\\\s+\");\n        if (parts.length < 2) {\n            return -1;\n        }\n        try {\n            return Integer.parseInt(parts[1]);\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n}"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.Socket;\nimport org.junit.Test;\nimport static org.junit.Assert.assertTrue;\n\npublic class ServletHandlingTest {\n\n    @Test\n    public void testServletInputStreamEarlyClose() throws Exception {\n        DefaultServer server = new DefaultServer();\n        server.start(EarlyCloseClientServlet.class);\n\n        try (Socket socket = new Socket(\"localhost\", server.getAddress().getPort())) {\n            OutputStream os = socket.getOutputStream();\n            os.write(\"POST /early-close HTTP/1.1\\r\\n\".getBytes());\n            os.write(\"Host: localhost\\r\\n\".getBytes());\n            os.write(\"Content-Length: 1048576\\r\\n\".getBytes());\n            os.write(\"\\r\\n\".getBytes());\n            os.write(new byte[524288]); // Send half of the content\n            os.flush();\n            socket.close(); // Close the socket early\n        }\n\n        assertTrue(\"Servlet should have detected early close\", EarlyCloseClientServlet.wasExceptionCaught());\n        server.stop();\n    }\n}"
  },
  {
    "Task_id": 595,
    "Instruction": "Task Description: Implement a Java class that handles SNTP (Simple Network Time Protocol) requests to synchronize time with an NTP server using UDP communication. The class should validate server responses and provide accurate time synchronization while handling potential errors.\n\nClass Description: The SntpImpl class implements the Sntp interface and provides functionality to request time from an NTP server. It uses UDP communication to send and receive NTP packets, validates server responses against specified thresholds, and calculates time offsets. The class includes helper methods for reading/writing NTP protocol fields and converting between different time representations.\n\nAttributes:\n- NTP_PORT: int - The standard NTP port (123)\n- NTP_MODE: int - The NTP mode (3 for client)\n- NTP_VERSION: int - The NTP version (3)\n- NTP_PACKET_SIZE: int - The size of NTP packets (48 bytes)\n- OFFSET_1900_TO_1970: long - The seconds offset between 1900 and 1970 epochs\n\nMethods:\n- requestTime(InetAddress, float, float, int, int, SntpEventListener) -> SntpResult - Requests time from specified NTP server with validation parameters and timeout\n- writeNtpVersion(byte[]) -> void - Writes NTP version and mode into the buffer\n- writeTimeStamp(byte[], int, long) -> void - Writes a timestamp into the buffer at specified offset\n- readTimeStamp(byte[], int) -> long - Reads a timestamp from the buffer at specified offset\n- read(byte[], int) -> long - Reads 4 bytes from buffer as a long value\n- ui(byte) -> int - Converts byte to unsigned integer\n- doubleMillis(long) -> double - Converts fixed-point NTP format to milliseconds",
    "Canonical_solution": "import android.os.SystemClock;\nimport com.instacart.truetime.InvalidNtpServerResponseException;\nimport com.instacart.truetime.SntpEventListener;\nimport org.jetbrains.annotations.NotNull;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class SntpImpl implements Sntp {\n\n    private static final int NTP_PORT = 123;\n    private static final int NTP_MODE = 3;\n    private static final int NTP_VERSION = 3;\n    private static final int NTP_PACKET_SIZE = 48;\n    private static final long OFFSET_1900_TO_1970 = ((365L * 70L) + 17L) * 24L * 60L * 60L;\n\n    @NotNull\n    @Override\n    public synchronized SntpResult requestTime(\n            InetAddress address,\n            float rootDelayMax,\n            float rootDispersionMax,\n            int serverResponseDelayMax,\n            int timeoutInMillis,\n            SntpEventListener listener\n    ) throws IOException {\n\n        listener.sntpRequest(address);\n        DatagramSocket socket = null;\n\n        try {\n            socket = new DatagramSocket();\n            socket.setSoTimeout(timeoutInMillis);\n            byte[] buffer = new byte[NTP_PACKET_SIZE];\n            DatagramPacket request = new DatagramPacket(buffer, buffer.length, address, NTP_PORT);\n\n            writeNtpVersion(buffer);\n            long requestTime = System.currentTimeMillis();\n            long requestTicks = SystemClock.elapsedRealtime();\n            writeTimeStamp(buffer, INDEX_TRANSMIT_TIME, requestTime);\n            socket.send(request);\n\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n            long responseTicks = SystemClock.elapsedRealtime();\n\n            long originateTime = readTimeStamp(buffer, INDEX_ORIGINATE_TIME);\n            long receiveTime = readTimeStamp(buffer, INDEX_RECEIVE_TIME);\n            long transmitTime = readTimeStamp(buffer, INDEX_TRANSMIT_TIME);\n            long responseTime = requestTime + (responseTicks - requestTicks);\n\n            double rootDelay = doubleMillis(read(buffer, INDEX_ROOT_DELAY));\n            if (rootDelay > rootDelayMax) {\n                throw new InvalidNtpServerResponseException(\n                        \"Invalid response from NTP server. %s violation. %f [actual] > %f [expected]\",\n                        \"root_delay\",\n                        (float) rootDelay,\n                        rootDelayMax);\n            }\n\n            double rootDispersion = doubleMillis(read(buffer, INDEX_ROOT_DISPERSION));\n            if (rootDispersion > rootDispersionMax) {\n                throw new InvalidNtpServerResponseException(\n                        \"Invalid response from NTP server. %s violation. %f [actual] > %f [expected]\",\n                        \"root_dispersion\",\n                        (float) rootDispersion,\n                        rootDispersionMax);\n            }\n\n            listener.sntpRequestSuccessful(address);\n            return new SntpResult(new long[]{\n                    originateTime,\n                    receiveTime,\n                    transmitTime,\n                    responseTime,\n                    read(buffer, INDEX_ROOT_DELAY),\n                    read(buffer, INDEX_ROOT_DISPERSION),\n                    buffer[1] & 0xff,\n                    responseTicks\n            });\n\n        } catch (Exception e) {\n            listener.sntpRequestFailed(address, e);\n            throw e;\n        } finally {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n\n    private void writeNtpVersion(byte[] buffer) {\n        buffer[0] = NTP_MODE | (NTP_VERSION << 3);\n    }\n\n    private void writeTimeStamp(byte[] buffer, int offset, long time) {\n        long seconds = time / 1000L;\n        long milliseconds = time - seconds * 1000L;\n        seconds += OFFSET_1900_TO_1970;\n\n        buffer[offset++] = (byte) (seconds >> 24);\n        buffer[offset++] = (byte) (seconds >> 16);\n        buffer[offset++] = (byte) (seconds >> 8);\n        buffer[offset++] = (byte) (seconds >> 0);\n\n        long fraction = milliseconds * 0x100000000L / 1000L;\n        buffer[offset++] = (byte) (fraction >> 24);\n        buffer[offset++] = (byte) (fraction >> 16);\n        buffer[offset++] = (byte) (fraction >> 8);\n        buffer[offset] = (byte) (Math.random() * 255.0);\n    }\n\n    private long readTimeStamp(byte[] buffer, int offset) {\n        long seconds = read(buffer, offset);\n        long fraction = read(buffer, offset + 4);\n        return ((seconds - OFFSET_1900_TO_1970) * 1000) + ((fraction * 1000L) / 0x100000000L);\n    }\n\n    private long read(byte[] buffer, int offset) {\n        return ((long) ui(buffer[offset]) << 24) +\n               ((long) ui(buffer[offset + 1]) << 16) +\n               ((long) ui(buffer[offset + 2]) << 8) +\n               (long) ui(buffer[offset + 3]);\n    }\n\n    private int ui(byte b) {\n        return b & 0xFF;\n    }\n\n    private double doubleMillis(long fix) {\n        return fix / 65.536D;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketTimeoutException;\n\npublic class SntpImpl implements Sntp {\n    private static final int NTP_PORT = 123;\n    private static final int NTP_MODE = 3;\n    private static final int NTP_VERSION = 3;\n    private static final int NTP_PACKET_SIZE = 48;\n    private static final long OFFSET_1900_TO_1970 = 2208988800L;\n\n    @Override\n    public SntpResult requestTime(InetAddress serverAddress, float minPollInterval, float maxPollInterval, int retries, int timeout, SntpEventListener listener) {\n        byte[] buffer = new byte[NTP_PACKET_SIZE];\n        DatagramPacket requestPacket = new DatagramPacket(buffer, buffer.length, serverAddress, NTP_PORT);\n        DatagramPacket responsePacket = new DatagramPacket(buffer, buffer.length);\n\n        try (DatagramSocket socket = new DatagramSocket()) {\n            socket.setSoTimeout(timeout);\n            writeNtpVersion(buffer);\n            for (int attempt = 0; attempt < retries; attempt++) {\n                socket.send(requestPacket);\n                try {\n                    socket.receive(responsePacket);\n                    if (responsePacket.getAddress().equals(serverAddress)) {\n                        long serverTime = readTimeStamp(buffer, 40);\n                        long localTime = System.currentTimeMillis();\n                        double roundTripDelay = (System.currentTimeMillis() - localTime) * 2.0;\n                        double localClockOffset = (serverTime - OFFSET_1900_TO_1970 * 1000) - (localTime + roundTripDelay / 2.0);\n                        return new SntpResult(localClockOffset, roundTripDelay);\n                    }\n                } catch (SocketTimeoutException e) {\n                    if (attempt == retries - 1) throw e;\n                }\n            }\n        } catch (IOException e) {\n            listener.onError(e.getMessage());\n        }\n        return null;\n    }\n\n    private void writeNtpVersion(byte[] buffer) {\n        buffer[0] = (byte) (NTP_VERSION << 3 | NTP_MODE);\n    }\n\n    private void writeTimeStamp(byte[] buffer, int offset, long ntpTime) {\n        long seconds = ntpTime / 1000 + OFFSET_1900_TO_1970;\n        long fraction = ((ntpTime % 1000) * 0x100000000L) / 1000;\n        write(buffer, offset, seconds);\n        write(buffer, offset + 4, fraction);\n    }\n\n    private long readTimeStamp(byte[] buffer, int offset) {\n        long seconds = read(buffer, offset);\n        long fraction = read(buffer, offset + 4);\n        return (seconds - OFFSET_1900_TO_1970) * 1000 + (fraction * 1000) / 0x100000000L;\n    }\n\n    private long read(byte[] buffer, int offset) {\n        return ((buffer[offset] & 0xFFL) << 24) |\n               ((buffer[offset + 1] & 0xFFL) << 16) |\n               ((buffer[offset + 2] & 0xFFL) << 8) |\n               (buffer[offset + 3] & 0xFFL);\n    }\n\n    private int ui(byte b) {\n        return b & 0xFF;\n    }\n\n    private double doubleMillis(long ntpTime) {\n        long seconds = ntpTime >> 32;\n        long fraction = ntpTime & 0xFFFFFFFFL;\n        return (seconds - OFFSET_1900_TO_1970) * 1000.0 + (fraction * 1000.0) / 0x100000000L;\n    }\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nclass HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private final String delimiter = \"--\";\n    private final String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        boundary = delimiter + System.currentTimeMillis();\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        URL obj = new URL(url);\n        con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            os.write((\"name=\" + imgName).getBytes(StandardCharsets.UTF_8));\n        }\n        try (InputStream is = con.getInputStream()) {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            int nRead;\n            byte[] data = new byte[16384];\n            while ((nRead = is.read(data, 0, data.length)) != -1) {\n                buffer.write(data, 0, nRead);\n            }\n            return buffer.toByteArray();\n        }\n    }\n\n    public void connectForMultipart() throws IOException {\n        URL obj = new URL(url);\n        con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.setDoOutput(true);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write((\"Content-Type: application/octet-stream\\r\\n\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws IOException {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), StandardCharsets.UTF_8))) {\n            String responseLine;\n            while ((responseLine = br.readLine()) != null) {\n                response.append(responseLine.trim());\n            }\n        }\n        return response.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write((\"Content-Type: text/plain; charset=UTF-8\\r\\n\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        os.write(value.getBytes(StandardCharsets.UTF_8));\n        os.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n    }\n}"
  },
  {
    "Task_id": 609,
    "Instruction": "Task Description: Implement a UDP client function that sends a message to a server and waits for a response.\n\nFunction Description: The function establishes a UDP connection, sends a predefined message (\"hello world\") to a specified server (localhost on port 9876), waits for a response, prints the server's reply, and then closes the connection. This demonstrates basic UDP client-server communication.\n\nInput: None (The target address and port are hardcoded as \"localhost\" and 9876 respectively)\n\nOutput: None (The function prints the server's response to the console but doesn't return any value)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\n\nprivate void sendWifiInfoToClient() throws Exception {\n    DatagramSocket clientSocket = new DatagramSocket();\n    InetAddress IPAddress = InetAddress.getByName(\"localhost\");\n    byte[] sendData = new byte[1024];\n    byte[] receiveData = new byte[1024];\n    String sentence = \"hello world\";\n    sendData = sentence.getBytes();\n    DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 9876);\n    clientSocket.send(sendPacket);\n    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n    clientSocket.receive(receivePacket);\n    String modifiedSentence = new String(receivePacket.getData());\n    System.out.println(\"FROM SERVER:\" + modifiedSentence);\n    clientSocket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "import socket\n\ndef udp_client():\n    server_address = 'localhost'\n    server_port = 9876\n    message = b'hello world'\n\n    # Create a UDP socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    try:\n        # Send data\n        print(f'Sending \"{message}\"')\n        sent = sock.sendto(message, (server_address, server_port))\n\n        # Receive response\n        print('Waiting to receive')\n        data, server = sock.recvfrom(4096)\n        print(f'Received \"{data.decode()}\"')\n\n    finally:\n        # Close the socket\n        print('Closing socket')\n        sock.close()"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static class Error {\n        public int responseCode;\n        public String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n\n    public interface LineRead {\n        void readLine(String line);\n    }\n\n    public static String post(String request) throws IOException {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n\n        try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n            wr.writeBytes(body);\n            wr.flush();\n        }\n\n        return handleResponse(conn, null);\n    }\n\n    public static String get(String request) throws IOException {\n        return get(request, null, 5000);\n    }\n\n    public static String get(String request, LineRead callback, int timeout) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setConnectTimeout(timeout);\n        conn.setReadTimeout(timeout);\n\n        return handleResponse(conn, callback);\n    }\n\n    private static String handleResponse(HttpURLConnection connection, LineRead callback) throws IOException {\n        int responseCode = connection.getResponseCode();\n        StringBuilder response = new StringBuilder();\n\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n                if (callback != null) {\n                    callback.readLine(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            if (responseCode >= 400) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getErrorStream()))) {\n                    String inputLine;\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                }\n            } else {\n                throw e;\n            }\n        }\n\n        if (responseCode >= 400) {\n            throw new IOException(new Error(responseCode, response.toString()).toString());\n        }\n\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 614,
    "Instruction": "Task Description: Implement a UDP server function that continuously listens for incoming packets, processes the received data by converting it to uppercase, and sends the modified data back to the client.\n\nFunction Description: The function sets up a UDP server that binds to a specific port (9876) and enters an infinite loop to receive incoming packets. Upon receiving a packet, it extracts the data, converts it to uppercase, and sends the modified data back to the client's address and port. The function handles all necessary UDP communication steps including socket creation, packet reception, data processing, and response transmission.\n\nInput: None (The function takes no parameters as it binds to a fixed port and processes incoming UDP packets)\n\nOutput: None (The function does not return any value but prints received messages to the console and sends responses back to clients)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\n\nprivate void receiveServerUdpInfo() throws Exception {\n    DatagramSocket serverSocket = new DatagramSocket(9876);\n    byte[] receiveData = new byte[1024];\n    byte[] sendData = new byte[1024];\n    while(true) {\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.receive(receivePacket);\n        String sentence = new String(receivePacket.getData());\n        System.out.println(\"RECEIVED: \" + sentence);\n        InetAddress IPAddress = receivePacket.getAddress();\n        int port = receivePacket.getPort();\n        String capitalizedSentence = sentence.toUpperCase();\n        sendData = capitalizedSentence.getBytes();\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n        serverSocket.send(sendPacket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "import socket\n\ndef udp_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_address = ('localhost', 9876)\n    server_socket.bind(server_address)\n\n    while True:\n        data, address = server_socket.recvfrom(4096)\n        print(f\"Received message: {data.decode('utf-8')} from {address}\")\n        response = data.upper()\n        server_socket.sendto(response, address)\n\nudp_server()"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class URLChecker {\n    public static boolean isURLAccessible(String url) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"HEAD\");\n            int responseCode = con.getResponseCode();\n            return responseCode == HttpURLConnection.HTTP_OK;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isURLAccessible(\"http://example.com\"));\n        System.out.println(isURLAccessible(\"http://invalid-url\"));\n    }\n}"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\nclass HttpFeedbackClient {\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"http://example.com/feedback\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setDoOutput(true);\n\n            String urlParameters = \"content=\" + encode(content) + \"&env=\" + encode(env);\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = urlParameters.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);           \n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"Failed with response code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    private String encode(String value) {\n        return java.net.URLEncoder.encode(value, StandardCharsets.UTF_8);\n    }\n\n    interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection to make GET requests and handle responses.\n\nClass Description: The HttpClient class provides functionality to send HTTP GET requests to a specified URL and retrieve the response. It handles connection timeouts, sets appropriate request headers, and processes the response stream.\n\nAttributes: None\n\nMethods:\n- request: [Name](String url) -> String - Sends a GET request to the specified URL and returns the response body as a string. Sets connection timeout to 3 seconds, read timeout to 90 seconds, and configures appropriate request headers including content type and character encoding. Returns null if the request fails or response code is not 200.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n\n    public String request(String url) {\n        HttpURLConnection connection = null;\n        BufferedReader reader = null;\n        try {\n            URL getUrl = new URL(url);\n            connection = (HttpURLConnection) getUrl.openConnection();\n            connection.setReadTimeout(90000);\n            connection.setConnectTimeout(3000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            \n            if (200 == connection.getResponseCode()) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    public String request(String url) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setConnectTimeout(3000); // 3 seconds\n            con.setReadTimeout(90000); // 90 seconds\n            con.setRequestProperty(\"Content-Type\", \"application/json\");\n            con.setRequestProperty(\"Accept-Charset\", \"UTF-8\");\n\n            int responseCode = con.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) { // success\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class PreloadTask implements Runnable {\n    private final String mRawUrl;\n    private final int mPosition;\n    private final HttpProxyCacheServer mCacheServer;\n    private final AtomicBoolean mIsCanceled = new AtomicBoolean(false);\n    private final AtomicBoolean mIsExecuted = new AtomicBoolean(false);\n    private static final List<String> blackList = new CopyOnWriteArrayList<>();\n\n    public PreloadTask(String rawUrl, int position, HttpProxyCacheServer cacheServer) {\n        this.mRawUrl = rawUrl;\n        this.mPosition = position;\n        this.mCacheServer = cacheServer;\n    }\n\n    @Override\n    public void run() {\n        if (!mIsCanceled.get()) {\n            mIsExecuted.set(true);\n            start();\n        }\n    }\n\n    private void start() {\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setRequestMethod(\"GET\");\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                byte[] buffer = new byte[4096];\n                while (inputStream.read(buffer) != -1 && !mIsCanceled.get()) {\n                    // Read data to cache it\n                }\n                inputStream.close();\n            } else {\n                blackList.add(mRawUrl);\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted.get() && !mIsCanceled.get()) {\n            mIsCanceled.set(true);\n        }\n    }\n}"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n    public static final Map<Long, Integer> XSTS_ERRORS = new HashMap<>();\n\n    static {\n        XSTS_ERRORS.put(2148916233L, 1000); // Example error mapping\n        XSTS_ERRORS.put(2148916235L, 1001); // Example error mapping\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException {\n        URL url = new URL(authTokenUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n\n        String formData;\n        if (isRefresh) {\n            formData = convertToFormData(\"client_id\", \"your-client-id\", \"scope\", \"XboxLive.signin offline_access\", \"refresh_token\", authcode, \"grant_type\", \"refresh_token\");\n        } else {\n            formData = convertToFormData(\"client_id\", \"your-client-id\", \"scope\", \"XboxLive.signin offline_access\", \"code\", authcode, \"redirect_uri\", \"your-redirect-uri\", \"grant_type\", \"authorization_code\");\n        }\n\n        setCommonProperties(conn, formData);\n        try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n            wr.writeBytes(formData);\n            wr.flush();\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw getResponseThrowable(conn);\n        }\n\n        return parseResponseForToken(conn);\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException {\n        URL url = new URL(xblAuthUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n\n        String requestBody = \"{\\\"Properties\\\": {\\\"AuthMethod\\\": \\\"RPS\\\", \\\"SiteName\\\": \\\"user.auth.xboxlive.com\\\", \\\"RpsTicket\\\": \\\"d=\" + accessToken + \"\\\"}, \\\"RelyingParty\\\": \\\"http://auth.xboxlive.com\\\", \\\"TokenType\\\": \\\"JWT\\\"}\";\n        setCommonProperties(conn, requestBody);\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n\n        try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n            wr.writeBytes(requestBody);\n            wr.flush();\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw getResponseThrowable(conn);\n        }\n\n        return parseResponseForToken(conn);\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException {\n        URL url = new URL(xstsAuthUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n\n        String requestBody = \"{\\\"Properties\\\": {\\\"SandboxId\\\": \\\"RETAIL\\\", \\\"UserTokens\\\": [\\\"\" + xblToken + \"\\\"]}, \\\"RelyingParty\\\": \\\"rp://api.minecraftservices.com/\\\", \\\"TokenType\\\": \\\"JWT\\\"}\";\n        setCommonProperties(conn, requestBody);\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n\n        try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n            wr.writeBytes(requestBody);\n            wr.flush();\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw getResponseThrowable(conn);\n        }\n\n        return parseResponseForXsts(conn);\n    }\n\n    private void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"Content-Length\", String.valueOf(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"User-Agent\", \"ProjectInfinity/1.0\");\n    }\n\n    private String convertToFormData(String... data) {\n        StringBuilder formData = new StringBuilder();\n        for (int i = 0; i < data.length; i += 2) {\n            if (formData.length() > 0) formData.append(\"&\");\n            formData.append(data[i]).append(\"=\").append(Base64.getUrlEncoder().encodeToString(data[i + 1].getBytes(StandardCharsets.UTF_8)));\n        }\n        return formData.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        String responseMessage = conn.getResponseMessage();\n        return new RuntimeException(\"HTTP error code : \" + responseCode + \" - \" + responseMessage);\n    }\n\n    private String parseResponseForToken(HttpURLConnection conn) throws IOException {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            String json = content.toString();\n            String token = json.split(\"\\\"access_token\\\":\\\"\")[1].split(\"\\\"\")[0];\n            return token;\n        }\n    }\n\n    private String[] parseResponseForXsts(HttpURLConnection conn) throws IOException {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            String json = content.toString();\n            String token = json.split(\"\\\"Token\\\":\\\"\")[1].split(\"\\\"\")[0];\n            String uhs = json.split(\"\\\"uhs\\\":\\\"\")[1].split(\"\\\"\")[0];\n            return new String[]{uhs, token};\n        }\n    }\n}"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.json.JsonObject;\nimport javax.json.Json;\nimport javax.json.JsonObjectBuilder;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        int queryIndex = responseUrl.indexOf('?');\n        if (queryIndex != -1) {\n            String baseUrl = responseUrl.substring(0, queryIndex);\n            String queryString = responseUrl.substring(queryIndex + 1);\n            String[] pairs = queryString.split(\"&\");\n            for (String pair : pairs) {\n                int idx = pair.indexOf(\"=\");\n                try {\n                    String key = idx > 0 ? pair.substring(0, idx) : pair;\n                    String value = idx > 0 && pair.length() > idx + 1 ? pair.substring(idx + 1) : \"\";\n                    jsonObject.add(key, value);\n                } catch (Exception e) {\n                    // Handle decoding errors or malformed pairs\n                }\n            }\n            return baseUrl;\n        }\n        return responseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        URL url = new URL(httpUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        if (content != null && !content.isEmpty()) {\n            try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {\n                wr.writeBytes(content);\n                wr.flush();\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new Exception(\"HTTP error code : \" + responseCode);\n        }\n\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n        }\n\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function that retrieves JSON data from a Twitter URL based on a given tweet ID using Java's HttpURLConnection.\n\nFunction Description: The function makes an HTTP GET request to a Twitter URL constructed with the provided tweet ID, reads the response, and returns it as a JSONObject. It handles HTTPS connections, sets appropriate request headers, and manages the connection lifecycle.\n\nInput: \n- tweetId: long - The ID of the tweet for which to retrieve favorited popup data\n\nOutput: \n- JSONObject - The JSON response from the Twitter URL, or null if an error occurs",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic JSONObject getJson(long tweetId) {\n    try {\n        String url = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        URL obj = new URL(url);\n\n        HttpsURLConnection connection = (HttpsURLConnection) obj.openConnection();\n        connection.setRequestProperty(\"Content-Type\", \"text/html\");\n        connection.setRequestProperty(\"charset\", \"utf-8\");\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36\");\n        connection.connect();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line + \"\\n\");\n        }\n\n        String docHtml = sb.toString();\n\n        try {\n            connection.disconnect();\n        } catch (Exception e) {\n\n        }\n\n        return new JSONObject(docHtml);\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.json.JSONObject;\n\npublic class TwitterDataFetcher {\n    public static JSONObject getTweetData(long tweetId) {\n        String urlString = \"https://api.twitter.com/2/tweets/\" + tweetId;\n        try {\n            URL url = new URL(urlString);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Authorization\", \"Bearer YOUR_BEARER_TOKEN\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder content = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n                in.close();\n                return new JSONObject(content.toString());\n            } else {\n                System.out.println(\"GET request failed with response code: \" + responseCode);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for MMS (Multimedia Messaging Service) operations, supporting both HTTP and HTTPS protocols with configurable proxy settings and connection parameters.\n\nClass Description: MmsHttpClient is a specialized HTTP client designed for MMS operations that handles both GET and POST requests. It manages network connections, proxy configurations, request/response handling, and includes MMS-specific header management. The class uses OkHttp internally for connection management.\n\nAttributes:\n- mContext: Context - Android application context\n- mSocketFactory: SocketFactory - Factory for creating sockets\n- mHostResolver: MmsNetworkManager - Network host resolver for connection management\n- mConnectionPool: ConnectionPool - Pool of HTTP connections for reuse\n\nMethods:\n- execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) -> byte[] - Executes an HTTP request to the specified URL with given PDU data. Handles both GET and POST methods with proxy support. Returns the response body as byte array.\n- openConnection(URL url, Proxy proxy) -> HttpURLConnection - Creates and configures an appropriate HttpURLConnection (HTTP or HTTPS) with the given URL and proxy settings. Throws MalformedURLException for invalid protocols.\n- checkMethod(String method) -> void - Validates that the HTTP method is either GET or POST (helper method)\n- getCurrentAcceptLanguage(Locale locale) -> String - Generates Accept-Language header value from locale (helper method)\n- addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) -> void - Adds additional MMS-specific headers to the request (helper method)\n- logHttpHeaders(Map<String, List<String>> headers) -> void - Logs HTTP headers for debugging (helper method)",
    "Canonical_solution": "import android.content.Context;\nimport com.android.mms.service_alt.exception.MmsHttpException;\nimport com.squareup.okhttp.ConnectionPool;\nimport com.squareup.okhttp.ConnectionSpec;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Protocol;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.internal.Internal;\nimport com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;\nimport com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;\nimport timber.log.Timber;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MmsHttpClient {\n\n    public static final String METHOD_POST = \"POST\";\n    public static final String METHOD_GET = \"GET\";\n\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n    private static final String HEADER_ACCEPT = \"Accept\";\n    private static final String HEADER_ACCEPT_LANGUAGE = \"Accept-Language\";\n    private static final String HEADER_USER_AGENT = \"User-Agent\";\n\n    private static final String HEADER_VALUE_ACCEPT =\n            \"*/*, application/vnd.wap.mms-message, application/vnd.wap.sic\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET =\n            \"application/vnd.wap.mms-message; charset=utf-8\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET =\n            \"application/vnd.wap.mms-message\";\n\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver,\n            ConnectionPool connectionPool) {\n        mContext = context;\n        mSocketFactory = socketFactory;\n        mHostResolver = hostResolver;\n        mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet,\n            String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig)\n            throws MmsHttpException {\n        Timber.d(\"HTTP: \" + method + \" \" + urlString\n                + (isProxySet ? (\", proxy=\" + proxyHost + \":\" + proxyPort) : \"\")\n                + \", PDU size=\" + (pdu != null ? pdu.length : 0));\n        checkMethod(method);\n        HttpURLConnection connection = null;\n        try {\n            Proxy proxy = null;\n            if (isProxySet) {\n                proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n            }\n            final URL url = new URL(urlString);\n            connection = openConnection(url, proxy);\n            connection.setDoInput(true);\n            connection.setConnectTimeout(mmsConfig.getHttpSocketTimeout());\n            connection.setRequestProperty(HEADER_ACCEPT, HEADER_VALUE_ACCEPT);\n            connection.setRequestProperty(\n                    HEADER_ACCEPT_LANGUAGE, getCurrentAcceptLanguage(Locale.getDefault()));\n            final String userAgent = mmsConfig.getUserAgent();\n            Timber.i(\"HTTP: User-Agent=\" + userAgent);\n            connection.setRequestProperty(HEADER_USER_AGENT, userAgent);\n            final String uaProfUrlTagName = mmsConfig.getUaProfTagName();\n            final String uaProfUrl = mmsConfig.getUaProfUrl();\n            if (uaProfUrl != null) {\n                Timber.i(\"HTTP: UaProfUrl=\" + uaProfUrl);\n                connection.setRequestProperty(uaProfUrlTagName, uaProfUrl);\n            }\n            addExtraHeaders(connection, mmsConfig);\n            if (METHOD_POST.equals(method)) {\n                if (pdu == null || pdu.length < 1) {\n                    Timber.e(\"HTTP: empty pdu\");\n                    throw new MmsHttpException(0/*statusCode*/, \"Sending empty PDU\");\n                }\n                connection.setDoOutput(true);\n                connection.setRequestMethod(METHOD_POST);\n                if (mmsConfig.getSupportHttpCharsetHeader()) {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET);\n                } else {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET);\n                }\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setFixedLengthStreamingMode(pdu.length);\n                final OutputStream out = new BufferedOutputStream(connection.getOutputStream());\n                out.write(pdu);\n                out.flush();\n                out.close();\n            } else if (METHOD_GET.equals(method)) {\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setRequestMethod(METHOD_GET);\n            }\n            final int responseCode = connection.getResponseCode();\n            final String responseMessage = connection.getResponseMessage();\n            Timber.d(\"HTTP: \" + responseCode + \" \" + responseMessage);\n            logHttpHeaders(connection.getHeaderFields());\n            if (responseCode / 100 != 2) {\n                throw new MmsHttpException(responseCode, responseMessage);\n            }\n            final InputStream in = new BufferedInputStream(connection.getInputStream());\n            final ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n            final byte[] buf = new byte[4096];\n            int count = 0;\n            while ((count = in.read(buf)) > 0) {\n                byteOut.write(buf, 0, count);\n            }\n            in.close();\n            final byte[] responseBody = byteOut.toByteArray();\n            Timber.d(\"HTTP: response size=\"\n                    + (responseBody != null ? responseBody.length : 0));\n            return responseBody;\n        } catch (MalformedURLException e) {\n            Timber.e(e, \"HTTP: invalid URL \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL \" + urlString, e);\n        } catch (ProtocolException e) {\n            Timber.e(e, \"HTTP: invalid URL protocol \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL protocol \" + urlString, e);\n        } catch (IOException e) {\n            Timber.e(e, \"HTTP: IO failure\");\n            throw new MmsHttpException(0/*statusCode*/, e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, final Proxy proxy) throws MalformedURLException {\n        final String protocol = url.getProtocol();\n        OkHttpClient okHttpClient;\n        if (protocol.equals(\"http\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setFollowRedirects(false);\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    if (proxy != null) {\n                        return Arrays.asList(proxy);\n                    } else {\n                        return new ArrayList<Proxy>();\n                    }\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            okHttpClient.setSocketFactory(SocketFactory.getDefault());\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            if (proxy != null) {\n                okHttpClient.setProxy(proxy);\n            }\n\n            return new HttpURLConnectionImpl(url, okHttpClient);\n        } else if (protocol.equals(\"https\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();\n            okHttpClient.setHostnameVerifier(verifier);\n            okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    return Arrays.asList(proxy);\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            return new HttpsURLConnectionImpl(url, okHttpClient);\n        } else {\n            throw new MalformedURLException(\"Invalid URL or unrecognized protocol \" + protocol);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.content.Context;\nimport android.net.http.X509TrustManagerExtensions;\nimport android.util.Log;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport okhttp3.ConnectionPool;\nimport okhttp3.OkHttpClient;\n\npublic class MmsHttpClient {\n    private Context mContext;\n    private SocketFactory mSocketFactory;\n    private MmsNetworkManager mHostResolver;\n    private ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver, ConnectionPool connectionPool) {\n        this.mContext = context;\n        this.mSocketFactory = socketFactory;\n        this.mHostResolver = hostResolver;\n        this.mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) throws IOException {\n        checkMethod(method);\n        URL url = new URL(urlString);\n        Proxy proxy = isProxySet ? new Proxy(Proxy.Type.HTTP, new java.net.InetSocketAddress(proxyHost, proxyPort)) : null;\n        HttpURLConnection connection = openConnection(url, proxy);\n        connection.setRequestMethod(method);\n        addExtraHeaders(connection, mmsConfig);\n        if (\"POST\".equals(method)) {\n            connection.setDoOutput(true);\n            connection.getOutputStream().write(pdu);\n        }\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            InputStream inputStream = connection.getInputStream();\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, length);\n            }\n            return outputStream.toByteArray();\n        } else {\n            throw new IOException(\"Unexpected response code \" + responseCode);\n        }\n    }\n\n    public HttpURLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        String protocol = url.getProtocol();\n        if (!\"http\".equals(protocol) && !\"https\".equals(protocol)) {\n            throw new MalformedURLException(\"Unsupported protocol: \" + protocol);\n        }\n        HttpURLConnection connection = (HttpURLConnection) (proxy != null ? url.openConnection(proxy) : url.openConnection());\n        if (connection instanceof HttpsURLConnection) {\n            HttpsURLConnection httpsConnection = (HttpsURLConnection) connection;\n            httpsConnection.setSSLSocketFactory(createSSLSocketFactory());\n            httpsConnection.setHostnameVerifier((hostname, session) -> true);\n        }\n        return connection;\n    }\n\n    private void checkMethod(String method) {\n        if (!\"GET\".equals(method) && !\"POST\".equals(method)) {\n            throw new IllegalArgumentException(\"Invalid HTTP method: \" + method);\n        }\n    }\n\n    private String getCurrentAcceptLanguage(Locale locale) {\n        StringBuilder acceptLanguage = new StringBuilder(locale.getLanguage());\n        if (locale.getCountry() != null && !locale.getCountry().isEmpty()) {\n            acceptLanguage.append(\"-\").append(locale.getCountry());\n        }\n        return acceptLanguage.toString();\n    }\n\n    private void addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) {\n        connection.setRequestProperty(\"Accept-Language\", getCurrentAcceptLanguage(Locale.getDefault()));\n        connection.setRequestProperty(\"X-Mms-Transaction-Id\", mmsConfig.getTransactionId());\n        // Add more headers as needed\n    }\n\n    private void logHttpHeaders(Map<String, List<String>> headers) {\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            Log.d(\"MmsHttpClient\", entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n\n    private SSLSocketFactory createSSLSocketFactory() {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new TrustManager[]{new X509TrustManager() {\n                @Override\n                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                @Override\n                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                @Override\n                public X509Certificate[] getAcceptedIssuers() {\n                    return new X509Certificate[0];\n                }\n            }}, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static class MmsNetworkManager {\n        public InetAddress getInetAddress(String host) throws UnknownHostException {\n            return InetAddress.getByName(host);\n        }\n    }\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "package com.example.network;\n\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpRequestHandler {\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://example.com/api\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setDoOutput(true);\n\n            String postParams = \"packageName=\" + packageName;\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = postParams.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);           \n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode < 400) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"Failed with response code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostRequest {\n\n    public static void sendPost(String message, String url) throws IOException {\n        String baseUrl = \"http://example.com\"; // Replace with your base URL\n        URL obj = new URL(baseUrl + url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n\n        try (DataOutputStream wr = new DataOutputStream(con.getOutputStream())) {\n            wr.writeBytes(message);\n            wr.flush();\n        }\n\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            StringBuilder response = new StringBuilder();\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n            }\n            String responseString = response.toString();\n            if (!responseString.equals(message)) {\n                System.out.println(\"Response does not match the message. Hex dump:\");\n                for (byte b : responseString.getBytes()) {\n                    System.out.printf(\"%02x \", b);\n                }\n                System.out.println();\n            }\n        } else {\n            throw new IOException(\"Unexpected response code: \" + responseCode);\n        }\n    }\n}"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for streaming content with support for caching, custom headers, and SSL verification.\n\nClass Description: HttpUrlSource is a class that provides HTTP content streaming functionality with features like range requests, redirect handling, SSL customization, and header injection. It's designed to work with a caching system and stores source information (URL, length, MIME type) persistently.\n\nAttributes:\n- sourceInfoStorage: SourceInfoStorage - Stores and retrieves source information (URL, length, MIME type)\n- headerInjector: HeaderInjector - Injects custom headers into HTTP requests\n- v: HostnameVerifier - Custom hostname verifier for SSL connections\n- trustAllCerts: TrustManager[] - Custom trust managers for SSL connections\n- sourceInfo: SourceInfo - Contains URL, content length and MIME type information\n- connection: HttpURLConnection - Active HTTP connection\n- inputStream: InputStream - Stream for reading content\n\nMethods:\n- HttpUrlSource(String, HostnameVerifier, TrustManager[]) -> void - Constructor with URL, hostname verifier and trust managers\n- HttpUrlSource(String, SourceInfoStorage, HostnameVerifier, TrustManager[]) -> void - Constructor with additional source info storage\n- HttpUrlSource(String, SourceInfoStorage, HeaderInjector, HostnameVerifier, TrustManager[]) -> void - Full constructor with all dependencies\n- length() -> long - Returns content length, fetches if not known\n- open(long) -> void - Opens connection at specified offset\n- close() -> void - Closes current connection\n- read(byte[]) -> int - Reads data into buffer\n- getMime() -> String - Returns MIME type, fetches if not known\n- getUrl() -> String - Returns source URL\n- openConnection(long, int) -> HttpURLConnection - Internal method to open connection with offset and timeout\n- injectCustomHeaders(HttpURLConnection, String) -> void - Injects custom headers into connection\n- readSourceAvailableBytes(HttpURLConnection, long, int) -> long - Calculates available bytes based on response\n- getContentLength(HttpURLConnection) -> long - Extracts content length from headers\n- fetchContentInfo() -> void - Fetches content information (length and MIME type)",
    "Canonical_solution": "import com.danikula.videocache.headers.EmptyHeadersInjector;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorageFactory;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Map;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\n\npublic class HttpUrlSource implements Source {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private final HostnameVerifier v;\n    private final TrustManager[] trustAllCerts;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, SourceInfoStorageFactory.newEmptySourceInfoStorage(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, sourceInfoStorage, new EmptyHeadersInjector(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n        this.v = v;\n        this.trustAllCerts = trustAllCerts;\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n            new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    @Override\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    @Override\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n            : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    @Override\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    @Override\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            if (url.startsWith(\"https\") && v != null && trustAllCerts != null) {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n                ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                try {\n                    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n                    ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                } catch (NoSuchAlgorithmException | KeyManagementException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n            }\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        if (extraHeaders == null) {\n            return;\n        }\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\n\nclass HttpUrlSource {\n    private SourceInfoStorage sourceInfoStorage;\n    private HeaderInjector headerInjector;\n    private HostnameVerifier v;\n    private TrustManager[] trustAllCerts;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, null, null, v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, sourceInfoStorage, null, v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n        this.v = v;\n        this.trustAllCerts = trustAllCerts;\n        this.sourceInfo = new SourceInfo(url);\n        if (sourceInfoStorage != null) {\n            sourceInfoStorage.load(sourceInfo);\n        }\n    }\n\n    public long length() {\n        if (sourceInfo.getLength() == -1) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getLength();\n    }\n\n    public void open(long offset) throws Exception {\n        close();\n        connection = openConnection(offset, 5000);\n        inputStream = connection.getInputStream();\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) inputStream.close();\n            if (connection != null) connection.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int read(byte[] buffer) throws Exception {\n        if (inputStream == null) throw new IllegalStateException(\"Connection is not open\");\n        return inputStream.read(buffer);\n    }\n\n    public String getMime() {\n        if (sourceInfo.getMimeType() == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getMimeType();\n    }\n\n    public String getUrl() {\n        return sourceInfo.getUrl();\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws Exception {\n        URL url = new URL(sourceInfo.getUrl());\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        if (connection instanceof HttpsURLConnection) {\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            ((HttpsURLConnection) connection).setSSLSocketFactory(sc.getSocketFactory());\n            ((HttpsURLConnection) connection).setHostnameVerifier(v);\n        }\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        if (offset > 0) {\n            connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n        }\n        injectCustomHeaders(connection, sourceInfo.getUrl());\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        if (headerInjector != null) {\n            headerInjector.inject(connection, url);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int timeout) {\n        long contentLength = getContentLength(connection);\n        return contentLength - offset;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n        return contentLengthHeader != null ? Long.parseLong(contentLengthHeader) : -1;\n    }\n\n    private void fetchContentInfo() {\n        try {\n            HttpURLConnection connection = openConnection(0, 5000);\n            sourceInfo.setMimeType(connection.getContentType());\n            sourceInfo.setLength(getContentLength(connection));\n            if (sourceInfoStorage != null) {\n                sourceInfoStorage.save(sourceInfo);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class SourceInfo {\n        private String url;\n        private long length;\n        private String mimeType;\n\n        public SourceInfo(String url) {\n            this.url = url;\n            this.length = -1;\n            this.mimeType = null;\n        }\n\n        public String getUrl() {\n            return url;\n        }\n\n        public long getLength() {\n            return length;\n        }\n\n        public void setLength(long length) {\n            this.length = length;\n        }\n\n        public String getMimeType() {\n            return mimeType;\n        }\n\n        public void setMimeType(String mimeType) {\n            this.mimeType = mimeType;\n        }\n    }\n\n    interface SourceInfoStorage {\n        void load(SourceInfo sourceInfo);\n        void save(SourceInfo sourceInfo);\n    }\n\n    interface HeaderInjector {\n        void inject(HttpURLConnection connection, String url);\n    }\n}"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RestClient {\n    public enum Protocol { HTTP, HTTPS }\n    public enum Method { GET, POST, PUT, DELETE }\n\n    public static class Param {\n        private final String name;\n        private final String value;\n\n        public Param(String name, String value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getValue() {\n            return value;\n        }\n    }\n\n    public static class Option {\n        private final String name;\n        private final String value;\n\n        public Option(String name, String value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getValue() {\n            return value;\n        }\n    }\n\n    @FunctionalInterface\n    public interface StreamConsumer {\n        void accept(OutputStream os) throws IOException;\n    }\n\n    public static class SingletonIterator<T> {\n        private final T element;\n        private boolean hasNext = true;\n\n        public SingletonIterator(T element) {\n            this.element = element;\n        }\n\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        public T next() {\n            if (!hasNext) throw new IllegalStateException(\"No more elements\");\n            hasNext = false;\n            return element;\n        }\n    }\n\n    public static class Response {\n        private final int statusCode;\n        private final String responseText;\n        private final Map<String, String> headers;\n\n        public Response(int statusCode, String responseText, Map<String, String> headers) {\n            this.statusCode = statusCode;\n            this.responseText = responseText;\n            this.headers = headers;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public String getResponseText() {\n            return responseText;\n        }\n\n        public Map<String, String> getHeaders() {\n            return headers;\n        }\n    }\n\n    public static class RestException extends Exception {\n        public RestException(String message) {\n            super(message);\n        }\n\n        public RestException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    public RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = protocol;\n        this.host = host;\n        this.port = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    public URL getUrl(String path, Param... params) throws MalformedURLException {\n        StringBuilder query = new StringBuilder();\n        for (Param param : params) {\n            if (query.length() > 0) query.append(\"&\");\n            query.append(param.getName()).append(\"=\").append(param.getValue());\n        }\n        String urlString = protocol.toString().toLowerCase() + \"://\" + host + \":\" + port + path;\n        if (query.length() > 0) urlString += \"?\" + query.toString();\n        return new URL(urlString);\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                URL url = getUrl(path);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method.name());\n\n                if (username != null && password != null) {\n                    String auth = username + \":\" + password;\n                    String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encodedAuth);\n                }\n\n                for (Option option : options) {\n                    conn.setRequestProperty(option.getName(), option.getValue());\n                }\n\n                if (method == Method.POST || method == Method.PUT) {\n                    conn.setDoOutput(true);\n                    try (OutputStream os = conn.getOutputStream()) {\n                        outStreamConsumer.accept(os);\n                    }\n                }\n\n                int statusCode = getResponseCodeFrom(conn);\n                String responseText = tryGetResponseTextFrom(conn, statusCode);\n\n                Map<String, String> headers = new HashMap<>();\n                for (int i = 0; ; i++) {\n                    String headerName = conn.getHeaderFieldKey(i);\n                    String headerValue = conn.getHeaderField(i);\n                    if (headerName == null && headerValue == null) break;\n                    if (headerName != null) {\n                        headers.put(headerName, headerValue);\n                    }\n                }\n\n                return new Response(statusCode, responseText, headers);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n    private String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        InputStream is = status < 400 ? conn.getInputStream() : conn.getErrorStream();\n        if (is == null) return null;\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        if (responseCode == 404) {\n            throw new RestException(\"Resource not found\");\n        }\n        return responseCode;\n    }\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously in an Android environment, using HttpURLConnection for network operations and AsyncTask for background processing.\n\nClass Description: HttpRequestHandler is a utility class designed to perform HTTP GET requests asynchronously. It contains an inner AsyncTask class for background network operations and a helper method for converting InputStream to String.\n\nAttributes: (None - this is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - An AsyncTask subclass that performs HTTP GET requests in the background. Takes a URL string as input and processes the response.\n  - onPreExecute(): void - Empty preparation method (can be overridden)\n  - doInBackground(String...): String - Performs the network request, reads response, and publishes progress\n  - onProgressUpdate(String...): void - Shows the response in a Toast message\n  - onPostExecute(String): void - Empty completion method (can be overridden)\n\nMethod2: ConvertInputToStringNoChange(InputStream) -> String - Helper method that converts an InputStream to a String by reading all lines.\n  - Input: InputStream - The input stream to convert\n  - Output: String - The concatenated string from the input stream",
    "Canonical_solution": "import android.content.Intent;\nimport android.os.AsyncTask;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            //before works\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                Toast.makeText(getApplicationContext(), progress[0], Toast.LENGTH_LONG).show();\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {}\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.os.AsyncTask;\nimport android.widget.Toast;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n        }\n\n        @Override\n        protected String doInBackground(String... urls) {\n            String result = null;\n            try {\n                URL url = new URL(urls[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n\n                if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = connection.getInputStream();\n                    result = ConvertInputToStringNoChange(inputStream);\n                    publishProgress(result);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return result;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            super.onProgressUpdate(values);\n            Toast.makeText(MyApplication.getAppContext(), values[0], Toast.LENGTH_SHORT).show();\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a utility class in Java that handles HTTP requests using HttpURLConnection, with support for custom headers and timeouts.\n\nClass Description: HttpHelper is a final utility class that provides static methods for making HTTP requests. It encapsulates the complexity of HttpURLConnection and provides error handling. The class cannot be instantiated.\n\nAttributes: None (This is a utility class with only static methods)\n\nMethods:\nMethod1: getHttpContents(String method, String endpoint, Map<String, String> headers) -> String - Makes an HTTP request to the specified endpoint using the given method and headers. Returns the response content as a String.\n  - Parameters:\n    - method: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n    - endpoint: String - The URL to send the request to\n    - headers: Map<String, String> - Optional map of request headers (can be null)\n  - Returns: String - The response content from the server\n  - Throws: MongoClientException if an IOException occurs during the request",
    "Canonical_solution": "import com.mongodb.MongoClientException;\nimport com.mongodb.lang.NonNull;\nimport com.mongodb.lang.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nfinal class HttpHelper {\n\n    private HttpHelper() {\n    }\n\n    @NonNull\n    public static String getHttpContents(final String method, final String endpoint, @Nullable final Map<String, String> headers) {\n        StringBuilder content = new StringBuilder();\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(endpoint).openConnection();\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(method);\n            if (headers != null) {\n                for (Map.Entry<String, String> kvp : headers.entrySet()) {\n                    conn.setRequestProperty(kvp.getKey(), kvp.getValue());\n                }\n            }\n\n            int status = conn.getResponseCode();\n            if (status != HttpURLConnection.HTTP_OK) {\n                throw new IOException(String.format(\"%d %s\", status, conn.getResponseMessage()));\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"Unexpected IOException from endpoint \" + endpoint + \".\", e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return content.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpHelper {\n\n    private HttpHelper() {\n        throw new UnsupportedOperationException(\"Utility class cannot be instantiated\");\n    }\n\n    public static String getHttpContents(String method, String endpoint, Map<String, String> headers) throws MongoClientException {\n        try {\n            URL url = new URL(endpoint);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setConnectTimeout(5000); // 5 seconds\n            connection.setReadTimeout(5000); // 5 seconds\n\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder content = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n                in.close();\n                return content.toString();\n            } else {\n                throw new MongoClientException(\"Failed to fetch data: HTTP error code : \" + responseCode);\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"IO Exception occurred while fetching data\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostClient {\n    public static String sendPost(String url, String name) {\n        StringBuilder response = new StringBuilder();\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n            String urlParameters = \"name=\" + name;\n            try(OutputStream os = con.getOutputStream()) {\n                byte[] input = urlParameters.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);           \n            }\n            int responseCode = con.getResponseCode();\n            try(BufferedReader in = new BufferedReader(\n                    new InputStreamReader(con.getInputStream(), \"utf-8\"))) {\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    private HttpRequestCallback callback;\n\n    public HttpRequestHandler(HttpRequestCallback callback) {\n        this.callback = callback;\n    }\n\n    public void execute(String url) {\n        new MyAsyncTask().execute(url);\n    }\n\n    private class MyAsyncTask extends android.os.AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... urls) {\n            StringBuilder result = new StringBuilder();\n            try {\n                URL url = new URL(urls[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                    publishProgress(line);\n                }\n                reader.close();\n            } catch (Exception e) {\n                return \"Error: \" + e.getMessage();\n            }\n            return result.toString();\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making network requests, with support for gzip compression, proxy interaction, and error handling.\n\nClass Description: The HttpService class provides HTTP client capabilities for making POST requests to specified endpoints. It handles request construction, connection management, response processing, and includes features like gzip compression, SSL socket configuration, proxy server interaction, and automatic retries for failed requests.\n\nAttributes:\n\nshouldGzipRequestPayload: boolean - Determines whether request payload should be gzip compressed\nMIN_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Minimum HTTP response code considered as service unavailable (500)\nMAX_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Maximum HTTP response code considered as service unavailable (599)\nLOGTAG: String - Tag used for logging messages\nHTTP_OUTPUT_STREAM_BUFFER_SIZE: int - Buffer size for output streams (8192 bytes)\nCONTENT_ENCODING_HEADER: String - Header key for content encoding\nGZIP_CONTENT_TYPE_HEADER: String - Value for gzip content encoding\n\nMethods:\n\nperformRequest: performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) -> byte[] - Makes an HTTP POST request to the specified endpoint with optional parameters and SSL configuration. Handles retries for failed requests and returns the response body as bytes. Throws ServiceUnavailableException for 5xx responses and IOException for other failures.\n\ngetBufferedOutputStream: getBufferedOutputStream(OutputStream out) -> OutputStream - Creates a buffered output stream, optionally wrapped in a GZIPOutputStream based on shouldGzipRequestPayload.\n\nisProxyRequest: isProxyRequest(String endpointUrl) -> boolean - Determines if the request is a proxy request by checking the endpoint URL.\n\nslurp: slurp(InputStream inputStream) -> byte[] - Reads all bytes from an input stream and returns them as a byte array.",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService implements RemoteService {\n\n    private final boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = HttpURLConnection.HTTP_INTERNAL_ERROR;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"MixpanelAPI.Message\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    @Override\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        MPLog.v(LOGTAG, \"Attempting request to \" + endpointUrl);\n\n        byte[] response = null;\n        int retries = 0;\n        boolean succeeded = false;\n        while (retries < 3 && !succeeded) {\n            InputStream in = null;\n            OutputStream out = null;\n            OutputStream bout = null;\n            HttpURLConnection connection = null;\n\n            try {\n                final URL url = new URL(endpointUrl);\n                connection = (HttpURLConnection) url.openConnection();\n                if (null != socketFactory && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    Map<String,String> headers = interactor.getProxyRequestHeaders();\n                    if (headers != null) {\n                        for (Map.Entry<String, String> entry : headers.entrySet()) {\n                            connection.setRequestProperty(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n\n                connection.setConnectTimeout(2000);\n                connection.setReadTimeout(30000);\n                if (null != params) {\n                    Uri.Builder builder = new Uri.Builder();\n                    for (Map.Entry<String, Object> param : params.entrySet()) {\n                        builder.appendQueryParameter(param.getKey(), param.getValue().toString());\n                    }\n                    String query = builder.build().getEncodedQuery();\n                    if (shouldGzipRequestPayload) {\n                        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                    } else {\n                        connection.setFixedLengthStreamingMode(query.getBytes().length);\n                    }\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    out = connection.getOutputStream();\n                    bout = getBufferedOutputStream(out);\n                    bout.write(query.getBytes(\"UTF-8\"));\n                    bout.flush();\n                    bout.close();\n                    bout = null;\n                    out.close();\n                    out = null;\n                }\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    interactor.onProxyResponse(endpointUrl, connection.getResponseCode());\n                }\n                in = connection.getInputStream();\n                response = slurp(in);\n                in.close();\n                in = null;\n                succeeded = true;\n            } catch (final EOFException e) {\n                MPLog.d(LOGTAG, \"Failure to connect, likely caused by a known issue with Android lib. Retrying.\");\n                retries = retries + 1;\n            } catch (final IOException e) {\n                if (connection != null && connection.getResponseCode() >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && connection.getResponseCode() <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service Unavailable\", connection.getHeaderField(\"Retry-After\"));\n                } else {\n                    throw e;\n                }\n            }\n            finally {\n                if (null != bout)\n                    try { bout.close(); } catch (final IOException e) {}\n                if (null != out)\n                    try { out.close(); } catch (final IOException e) {}\n                if (null != in)\n                    try { in.close(); } catch (final IOException e) {}\n                if (null != connection)\n                    connection.disconnect();\n            }\n        }\n        if (retries >= 3) {\n            MPLog.v(LOGTAG, \"Could not connect to Mixpanel service after three retries.\");\n        }\n        return response;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if(shouldGzipRequestPayload) {\n          return new GZIPOutputStream(new BufferedOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private static boolean isProxyRequest(String endpointUrl) {\n        return !endpointUrl.toLowerCase().contains(MIXPANEL_API.toLowerCase());\n    }\n\n    private static byte[] slurp(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[8192];\n\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.util.zip.GZIPOutputStream;\n\nclass HttpService {\n    private boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = 500;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"HttpService\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws IOException {\n        URL url = new URL(endpointUrl);\n        HttpURLConnection connection = null;\n        if (\"https\".equals(url.getProtocol())) {\n            HttpsURLConnection httpsConnection = (HttpsURLConnection) url.openConnection();\n            httpsConnection.setSSLSocketFactory(socketFactory);\n            connection = httpsConnection;\n        } else {\n            connection = (HttpURLConnection) url.openConnection();\n        }\n\n        if (interactor != null && interactor.isProxyConfigured()) {\n            connection = (HttpURLConnection) interactor.configureProxy(connection);\n        }\n\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setDoInput(true);\n        connection.setUseCaches(false);\n        connection.setRequestProperty(\"Accept\", \"*/*\");\n        connection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n\n        if (shouldGzipRequestPayload) {\n            connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n        }\n\n        try (OutputStream os = getBufferedOutputStream(connection.getOutputStream());\n             PrintWriter writer = new PrintWriter(new OutputStreamWriter(os, \"UTF-8\"), true)) {\n\n            StringBuilder postData = new StringBuilder();\n            for (Map.Entry<String, Object> param : params.entrySet()) {\n                if (postData.length() != 0) postData.append('&');\n                postData.append(URLEncoder.encode(param.getKey(), \"UTF-8\"));\n                postData.append('=');\n                postData.append(URLEncoder.encode(String.valueOf(param.getValue()), \"UTF-8\"));\n            }\n            writer.print(postData.toString());\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && responseCode <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n            throw new ServiceUnavailableException(\"Server returned HTTP response code: \" + responseCode);\n        }\n\n        try (InputStream inputStream = connection.getInputStream()) {\n            return slurp(inputStream);\n        } catch (IOException e) {\n            throw new IOException(\"Failed to read response from server\", e);\n        }\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        OutputStream result = new BufferedOutputStream(out, HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        if (shouldGzipRequestPayload) {\n            result = new GZIPOutputStream(result);\n        }\n        return result;\n    }\n\n    private boolean isProxyRequest(String endpointUrl) {\n        // Implement logic to determine if the request is a proxy request\n        // For example, check if the URL contains a specific pattern or host\n        return false; // Placeholder implementation\n    }\n\n    private byte[] slurp(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[HTTP_OUTPUT_STREAM_BUFFER_SIZE];\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}\n\nclass ProxyServerInteractor {\n    private boolean proxyConfigured;\n    private Proxy proxy;\n\n    public ProxyServerInteractor(boolean proxyConfigured, Proxy proxy) {\n        this.proxyConfigured = proxyConfigured;\n        this.proxy = proxy;\n    }\n\n    public boolean isProxyConfigured() {\n        return proxyConfigured;\n    }\n\n    public HttpURLConnection configureProxy(HttpURLConnection connection) {\n        if (proxyConfigured) {\n            connection = (HttpURLConnection) new URL(connection.getURL().toString()).openConnection(proxy);\n        }\n        return connection;\n    }\n}\n\nclass ServiceUnavailableException extends Exception {\n    public ServiceUnavailableException(String message) {\n        super(message);\n    }\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using HttpURLConnection, supporting both GET and POST methods asynchronously, with callback mechanisms for handling responses and errors. The class should also include functionality to retrieve network time from a server.\n\nClass Description: HttpURLConnectionUtils is a utility class that provides asynchronous HTTP request capabilities using Java's HttpURLConnection. It supports GET and POST methods, allows setting custom headers, and provides callback interfaces for handling responses and errors. Additionally, it includes functionality to fetch network time from a specified URL.\n\nAttributes:\n- TAG: String - Class tag for logging purposes\n- TIMEOUT_IN_MILLIONS: int - Default timeout for connections in milliseconds (5000ms)\n- BAIDU_URL: String - Default URL for network time requests (https://www.baidu.com)\n\nMethods:\n- doGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous GET request to the specified URL and invokes the callback with the response or error\n- doPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous POST request to the specified URL with given parameters and invokes the callback\n- getNetTime(TimeCallback callback) -> void - Retrieves network time from the default BAIDU_URL using the provided callback\n- getNetTime(String urlStr, TimeCallback callback) -> void - Retrieves network time from the specified URL using the provided callback\n- request(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic\n- reqNetTime(String urlStr, TimeCallback callback) -> void - Internal method that handles network time retrieval\n\nCallback Interfaces:\n- Callback: \n  - onResponse(String result, long response) -> void - Called when request succeeds\n  - onFail(Throwable error) -> void - Called when request fails\n- TimeCallback:\n  - onResponse(long millis) -> void - Called when network time retrieval succeeds\n  - onFail(Throwable error) -> void - Called when network time retrieval fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final String TAG = HttpURLConnectionUtils.class.getSimpleName();\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(final String urlStr, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(final String urlStr, final String params, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void getNetTime(final TimeCallback callback) {\n        getNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(final String urlStr, final TimeCallback callback) {\n        new Thread(() -> reqNetTime(urlStr, callback)).start();\n    }\n\n    private static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n            \n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1)) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n\n    private static void reqNetTime(final String urlStr, final TimeCallback callback) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            long date = connection.getDate();\n            if (date <= 0) {\n                date = -1L;\n            }\n            if (callback != null) {\n                callback.onResponse(date);\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class HttpURLConnectionUtils {\n\n    public static final String TAG = \"HttpURLConnectionUtils\";\n    public static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long responseTime);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    public static void getNetTime(TimeCallback callback) {\n        reqNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(String urlStr, TimeCallback callback) {\n        reqNetTime(urlStr, callback);\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(method);\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        connection.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (\"POST\".equals(method) && params != null) {\n                    connection.setDoOutput(true);\n                    try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {\n                        wr.writeBytes(params);\n                        wr.flush();\n                    }\n                }\n\n                long startTime = System.currentTimeMillis();\n                int responseCode = connection.getResponseCode();\n                long endTime = System.currentTimeMillis();\n\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    StringBuilder response = new StringBuilder();\n                    try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                        String inputLine;\n                        while ((inputLine = in.readLine()) != null) {\n                            response.append(inputLine);\n                        }\n                    }\n                    callback.onResponse(response.toString(), endTime - startTime);\n                } else {\n                    callback.onFail(new IOException(\"HTTP error code: \" + responseCode));\n                }\n            } catch (IOException e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n\n    private static void reqNetTime(String urlStr, TimeCallback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                long startTime = System.currentTimeMillis();\n                int responseCode = connection.getResponseCode();\n                long endTime = System.currentTimeMillis();\n\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    callback.onResponse(endTime);\n                } else {\n                    callback.onFail(new IOException(\"HTTP error code: \" + responseCode));\n                }\n            } catch (IOException e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.*;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\npublic class SSRFChecker {\n    private static final Logger logger = Logger.getLogger(SSRFChecker.class.getName());\n    private String decimalIp;\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        for (int i = 0; i < checkTimes; i++) {\n            String host = url2host(url);\n            if (host.isEmpty()) {\n                logger.info(\"Invalid URL: \" + url);\n                return false;\n            }\n            String ip = host2ip(host);\n            if (ip.isEmpty()) {\n                logger.info(\"Failed to resolve host: \" + host);\n                return false;\n            }\n            if (isInternalIp(ip)) {\n                logger.info(\"Internal IP detected: \" + ip);\n                return false;\n            }\n            try {\n                URL newUrl = new URL(url);\n                if (newUrl.getProtocol().equalsIgnoreCase(\"http\") || newUrl.getProtocol().equalsIgnoreCase(\"https\")) {\n                    HttpURLConnection connection = (HttpURLConnection) newUrl.openConnection();\n                    connection.setInstanceFollowRedirects(true);\n                    connection.connect();\n                    int responseCode = connection.getResponseCode();\n                    if (responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_MOVED_PERM) {\n                        String location = connection.getHeaderField(\"Location\");\n                        if (location != null) {\n                            url = location;\n                            continue;\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                logger.severe(\"Error checking URL: \" + url + \", Exception: \" + e.getMessage());\n                return false;\n            }\n            break;\n        }\n        return true;\n    }\n\n    public boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.isEmpty()) {\n            return false;\n        }\n        String ip = host2ip(host);\n        return !ip.isEmpty() && isInternalIp(ip);\n    }\n\n    public boolean isInternalIp(String strIP) {\n        long ip = ipToLong(strIP);\n        return (ip >= ipToLong(\"10.0.0.0\") && ip <= ipToLong(\"10.255.255.255\"))\n                || (ip >= ipToLong(\"172.16.0.0\") && ip <= ipToLong(\"172.31.255.255\"))\n                || (ip >= ipToLong(\"192.168.0.0\") && ip <= ipToLong(\"192.168.255.255\"));\n    }\n\n    public String host2ip(String host) {\n        if (isOctalIP(host)) {\n            logger.info(\"Octal IP format detected: \" + host);\n            return \"\";\n        }\n        try {\n            InetAddress inetAddress = InetAddress.getByName(host);\n            decimalIp = inetAddress.getHostAddress();\n            return decimalIp;\n        } catch (UnknownHostException e) {\n            logger.severe(\"Failed to resolve host: \" + host + \", Exception: \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    public String url2host(String url) {\n        try {\n            URL u = new URL(url);\n            return u.getHost();\n        } catch (MalformedURLException e) {\n            logger.severe(\"Invalid URL: \" + url + \", Exception: \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private boolean isOctalIP(String host) {\n        Pattern pattern = Pattern.compile(\"^\\\\d+(\\\\.\\\\d+){3}$\");\n        if (!pattern.matcher(host).matches()) {\n            return false;\n        }\n        String[] parts = host.split(\"\\\\.\");\n        for (String part : parts) {\n            if (part.length() > 3 || Integer.parseInt(part) > 255) {\n                return false;\n            }\n            if (part.length() > 1 && part.startsWith(\"0\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private long ipToLong(String ipAddress) {\n        String[] parts = ipAddress.split(\"\\\\.\");\n        long ip = 0;\n        for (int i = 0; i < parts.length; i++) {\n            ip |= Long.parseLong(parts[i]) << (24 - (i * 8));\n        }\n        return ip;\n    }\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        this.mProxyOn = proxyOn;\n        this.mProxyHost = proxyHost;\n        this.mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection;\n            if (mProxyOn) {\n                Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(mProxyHost, (int) mProxyPort));\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                String response = readStringFromStream(inputStream);\n                callback.onSuccess(new String(Base64.getDecoder().decode(response)));\n            } else {\n                callback.onFailed();\n            }\n        } catch (Exception e) {\n            callback.onFailed();\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.List;\n\npublic class HttpTinyClient {\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        String encodedParams = encodingParams(paramValues, encoding);\n        URL obj = new URL(url + \"?\" + encodedParams);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"GET\");\n        setHeaders(con, headers, encoding);\n        con.setReadTimeout((int) readTimeoutMs);\n\n        return getResponse(con);\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        String encodedParams = encodingParams(paramValues, encoding);\n        URL obj = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"POST\");\n        setHeaders(con, headers, encoding);\n        con.setDoOutput(true);\n        con.setReadTimeout((int) readTimeoutMs);\n\n        try (DataOutputStream wr = new DataOutputStream(con.getOutputStream())) {\n            wr.writeBytes(encodedParams);\n            wr.flush();\n        }\n\n        return getResponse(con);\n    }\n\n    private static String encodingParams(List<String> paramValues, String encoding) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        for (String param : paramValues) {\n            if (sb.length() > 0) {\n                sb.append(\"&\");\n            }\n            sb.append(URLEncoder.encode(param.split(\"=\")[0], encoding));\n            sb.append(\"=\");\n            sb.append(URLEncoder.encode(param.split(\"=\")[1], encoding));\n        }\n        return sb.toString();\n    }\n\n    private static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        conn.setRequestProperty(\"Accept-Charset\", encoding);\n        conn.setRequestProperty(\"User-Agent\", \"HttpTinyClient/1.0\");\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n        if (headers != null) {\n            for (String header : headers) {\n                String[] keyValue = header.split(\":\");\n                conn.setRequestProperty(keyValue[0].trim(), keyValue[1].trim());\n            }\n        }\n    }\n\n    private static HttpResult getResponse(HttpURLConnection con) throws IOException {\n        int responseCode = con.getResponseCode();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        return new HttpResult(responseCode, response.toString());\n    }\n\n    public static class HttpResult {\n        public int code;\n        public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\npublic class HttpPostUploadUtil {\n    private static final Logger logger = Logger.getLogger(HttpPostUploadUtil.class.getName());\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, File> fileMap) throws IOException {\n        final String BOUNDARY = \"----WebKitFormBoundary7MA4YWxkTrZu0gW\";\n        final String PREFIX = \"--\";\n        final String LINE_END = \"\\r\\n\";\n\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setConnectTimeout(connectTimeout);\n        conn.setReadTimeout(readTimeout);\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n        conn.setDoOutput(true);\n\n        OutputStream os = conn.getOutputStream();\n        PrintWriter writer = new PrintWriter(new OutputStreamWriter(os, \"UTF-8\"), true);\n\n        if (textMap != null) {\n            for (Map.Entry<String, String> entry : textMap.entrySet()) {\n                writer.append(PREFIX).append(BOUNDARY).append(LINE_END);\n                writer.append(\"Content-Disposition: form-data; name=\\\"\").append(entry.getKey()).append(\"\\\"\").append(LINE_END);\n                writer.append(\"Content-Type: text/plain; charset=UTF-8\").append(LINE_END);\n                writer.append(LINE_END);\n                writer.append(entry.getValue()).append(LINE_END);\n            }\n        }\n\n        if (fileMap != null) {\n            for (Map.Entry<String, File> entry : fileMap.entrySet()) {\n                File file = entry.getValue();\n                writer.append(PREFIX).append(BOUNDARY).append(LINE_END);\n                writer.append(\"Content-Disposition: form-data; name=\\\"\").append(entry.getKey()).append(\"\\\"; filename=\\\"\").append(file.getName()).append(\"\\\"\").append(LINE_END);\n                writer.append(\"Content-Type: \").append(getMimeType(file)).append(LINE_END);\n                writer.append(\"Content-Transfer-Encoding: binary\").append(LINE_END);\n                writer.append(LINE_END);\n                writer.flush();\n\n                FileInputStream fis = new FileInputStream(file);\n                byte[] buffer = new byte[4096];\n                int length;\n                while ((length = fis.read(buffer)) != -1) {\n                    os.write(buffer, 0, length);\n                }\n                os.flush();\n                closeStream(fis);\n\n                writer.append(LINE_END);\n            }\n        }\n\n        writer.append(PREFIX).append(BOUNDARY).append(PREFIX).append(LINE_END);\n        writer.close();\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"UTF-8\"));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n            }\n            br.close();\n            return response.toString();\n        } else {\n            throw new IOException(\"Server returned non-OK status: \" + responseCode);\n        }\n    }\n\n    private static String getMimeType(File file) {\n        String type = URLConnection.guessContentTypeFromName(file.getName());\n        if (type == null) {\n            type = \"application/octet-stream\";\n        }\n        return type;\n    }\n\n    public static void closeStream(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                logger.severe(\"Failed to close stream: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.google.gson.Gson;\n\npublic class ApiHandler {\n    private String baseUrl;\n    private Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n        this.additionalHeaders.put(\"Authorization\", \"Bearer \" + apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) throws IOException {\n        return get(endpoint, new HashMap<>(), tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        String url = baseUrl + endpoint + parseQueries(query);\n        return getFullUrl(additionalHeaders, url, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) throws IOException {\n        return post(endpoint, new HashMap<>(), body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        String url = baseUrl + endpoint + parseQueries(query);\n        return postFullUrl(additionalHeaders, url, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"GET\");\n        addHeaders(connection, headers);\n        return readResponse(connection);\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        addHeaders(connection, headers);\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            os.write(input, 0, input.length);\n        }\n        return readResponse(connection);\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder sb = new StringBuilder();\n        if (!query.isEmpty()) {\n            sb.append(\"?\");\n            for (Map.Entry<String, Object> entry : query.entrySet()) {\n                if (sb.length() > 1) sb.append(\"&\");\n                sb.append(urlEncodeUTF8(entry.getKey())).append(\"=\").append(urlEncodeUTF8(entry.getValue().toString()));\n            }\n        }\n        return sb.toString();\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) throws IOException {\n        String response = getRaw(headers, url);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        String fullUrl = url + parseQueries(query);\n        return getFullUrl(headers, fullUrl, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) throws IOException {\n        String jsonBody = new Gson().toJson(body);\n        String response = postRaw(headers, url, jsonBody);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        String fullUrl = url + parseQueries(query);\n        return postFullUrl(headers, fullUrl, body, tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        return URLEncoder.encode(input, StandardCharsets.UTF_8);\n    }\n\n    private static String readResponse(HttpURLConnection connection) throws IOException {\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) {\n            StringBuilder response = new StringBuilder();\n            String responseLine;\n            while ((responseLine = br.readLine()) != null) {\n                response.append(responseLine.trim());\n            }\n            return response.toString();\n        }\n    }\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.app.DownloadManager;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.webkit.MimeTypeMap;\nimport io.reactivex.Single;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class FetchUrlMimeType {\n    private DownloadManager.Request mRequest;\n    private DownloadManager mDownloadManager;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        this.mDownloadManager = downloadManager;\n        this.mRequest = request;\n        this.mUri = uri;\n        this.mCookies = cookies;\n        this.mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.fromCallable(() -> {\n            try {\n                URL url = new URL(mUri);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.setRequestProperty(\"Cookie\", mCookies);\n                }\n                if (mUserAgent != null && !mUserAgent.isEmpty()) {\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n\n                String mimeType = connection.getContentType();\n                String contentDisposition = connection.getHeaderField(\"Content-Disposition\");\n\n                String fileName = getFileNameFromContentDisposition(contentDisposition);\n                if (fileName == null) {\n                    fileName = Uri.parse(mUri).getLastPathSegment();\n                }\n                if (fileName == null) {\n                    fileName = \"downloaded_file\";\n                }\n\n                if (mimeType == null) {\n                    String extension = MimeTypeMap.getFileExtensionFromUrl(mUri);\n                    mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);\n                }\n\n                mRequest.setMimeType(mimeType);\n                mRequest.setDestinationInExternalPublicDir(\"/Download/\", fileName);\n\n                long enqueueId = mDownloadManager.enqueue(mRequest);\n                if (enqueueId != DownloadManager.Request.ERROR_UNKNOWN) {\n                    return Result.SUCCESS;\n                } else {\n                    return Result.FAILURE_ENQUEUE;\n                }\n            } catch (IOException e) {\n                return Result.FAILURE_LOCATION;\n            }\n        });\n    }\n\n    private String getFileNameFromContentDisposition(String contentDisposition) {\n        if (contentDisposition != null) {\n            String[] parts = contentDisposition.split(\";\");\n            for (String part : parts) {\n                part = part.trim();\n                if (part.startsWith(\"filename=\")) {\n                    return part.substring(\"filename=\".length()).replace(\"\\\"\", \"\");\n                }\n            }\n        }\n        return null;\n    }\n}"
  }
]