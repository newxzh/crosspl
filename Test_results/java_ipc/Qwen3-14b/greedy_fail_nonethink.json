[
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n    private static HttpClient me;\n\n    private HttpClient() {\n        this.handler = new HttpConnectionRetryHandler();\n    }\n\n    public static HttpClient getInstance() {\n        if (me == null) {\n            me = new HttpClient();\n        }\n        return me;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        int retryCount = 0;\n        while (retryCount < handler.getMaxRetries()) {\n            try {\n                doConnection(method, props);\n                return;\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount >= handler.getMaxRetries()) {\n                    throw new HttpClientException(\"Failed to connect after \" + retryCount + \" retries\", e);\n                }\n                handler.handleRetry(retryCount);\n            }\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL targetUrl = new URL(url);\n        Proxy proxy = null;\n        if (proxyHost != null && proxyPort != null) {\n            proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n        }\n        con = (HttpURLConnection) (proxy == null ? targetUrl.openConnection() : targetUrl.openConnection(proxy));\n        con.setRequestMethod(method);\n        con.setUseCaches(false);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n\n        Enumeration<?> propNames = props.propertyNames();\n        while (propNames.hasMoreElements()) {\n            String propName = (String) propNames.nextElement();\n            con.setRequestProperty(propName, props.getProperty(propName));\n        }\n    }\n\n    public byte[] downloadImage(String imgName) throws Exception {\n        setUrl(\"http://example.com/images/\" + imgName);\n        connect(\"GET\", new Properties());\n        InputStream is = con.getInputStream();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int len;\n        while ((len = is.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        boundary = \"===\" + System.currentTimeMillis() + \"===\";\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter).getBytes());\n        os.flush();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = br.readLine()) != null) {\n            sb.append(line).append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}\n\nclass HttpClientException extends Exception {\n    public HttpClientException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\nclass HttpConnectionRetryHandler {\n    private int maxRetries = 3;\n\n    public int getMaxRetries() {\n        return maxRetries;\n    }\n\n    public void handleRetry(int retryCount) {\n        System.out.println(\"Connection attempt \" + retryCount + \" failed. Retrying...\");\n    }\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Java class that asynchronously fetches weather data from a remote API using HTTP URL connection and processes the JSON response to extract sunrise and sunset times.\n\nClass Description: HttpWeatherClient is an Android utility class that performs asynchronous HTTP requests to fetch weather data and parse the JSON response. It uses AsyncTask to handle network operations off the main thread.\n\nAttributes: None (All variables are local to methods)\n\nMethods:\n1: WeatherAsyncTask(String... params) -> String - AsyncTask subclass that handles the background HTTP request. Takes URL string as input and returns null (results are processed via progress updates).\n2: onProgressUpdate(String... progress) -> void - Processes the JSON response to extract sunrise and sunset times from the astronomy data.\n3: convertStreamToString(InputStream inputStream) -> String - Helper method that converts an InputStream to a String for JSON parsing. Takes InputStream as input and returns the converted String.\n\nNote: All methods include basic exception handling with empty catch blocks as shown in the reference code. The class is designed for Android platform (uses android.os.AsyncTask).",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String weatherData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    weatherData = convertStreamToString(in);\n                    publishProgress(weatherData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                JSONObject query = json.getJSONObject(\"query\");\n                JSONObject results = query.getJSONObject(\"results\");\n                JSONObject channel = results.getJSONObject(\"channel\");\n                JSONObject astronomy = channel.getJSONObject(\"astronomy\");\n                String sunset = astronomy.getString(\"sunset\");\n                String sunrise = astronomy.getString(\"sunrise\");\n            } catch (Exception ex) {}\n        }\n    }\n\n    private static String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String result = \"\";\n\n        try {\n            while ((line = reader.readLine()) != null) {\n                result += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpWeatherClient extends AsyncTask<String, String, String> {\n    @Override\n    protected String doInBackground(String... params) {\n        try {\n            URL url = new URL(params[0]);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            if (conn.getResponseCode() == 200) {\n                InputStream inputStream = conn.getInputStream();\n                String response = convertStreamToString(inputStream);\n                publishProgress(response);\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    @Override\n    protected void onProgressUpdate(String... progress) {\n        super.onProgressUpdate(progress);\n        try {\n            String json = progress[0];\n            JSONObject jsonObject = new JSONObject(json);\n            JSONObject astronomy = jsonObject.getJSONObject(\"astronomy\");\n            JSONObject sunrise = astronomy.getJSONObject(\"sunrise\");\n            JSONObject sunset = astronomy.getJSONObject(\"sunset\");\n            String sunriseTime = sunrise.getString(\"time\");\n            String sunsetTime = sunset.getString(\"time\");\n            // Process sunrise and sunset times as needed\n        } catch (Exception e) {\n        }\n    }\n\n    private String convertStreamToString(InputStream inputStream) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder stringBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line).append('\\n');\n            }\n            return stringBuilder.toString();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection for making HTTP requests and handling responses.\n\nClass Description: The Http class provides a static method for sending HTTP requests to a specified URL with configurable request methods and payloads. It handles connection setup, request sending, response reading, and resource cleanup.\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String requestMethod, String outputStr) -> String - Sends an HTTP request to the specified URL using the given method and optional request body, then returns the response as a string.\n  - requestUrl: String - The target URL for the HTTP request\n  - requestMethod: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n  - outputStr: String - The request body to send (can be null for requests without body)\n  - Returns: String - The response body from the server, or null if an error occurs\n\nThe method handles:\n1. Creating and configuring HttpURLConnection\n2. Setting request headers (content-type: text/xml; charset=UTF-8)\n3. Sending request body if provided\n4. Reading and concatenating response\n5. Proper resource cleanup\n6. Error handling and logging",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport com.scudata.common.Logger;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {    \n        try {    \n            URL url = new URL(requestUrl);    \n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();    \n              \n            conn.setDoOutput(true);    \n            conn.setDoInput(true);    \n            conn.setUseCaches(false);    \n            conn.setRequestMethod(requestMethod);    \n            conn.setRequestProperty(\"content-type\", \"text/xml; charset=UTF-8\");\n            \n            if (null != outputStr) {    \n                OutputStream outputStream = conn.getOutputStream();    \n                outputStream.write(outputStr.getBytes(\"UTF-8\"));    \n                outputStream.close();    \n            }    \n            \n            InputStream inputStream = conn.getInputStream();    \n            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"utf-8\");    \n            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);    \n            String str = null;  \n            StringBuffer buffer = new StringBuffer();    \n            while ((str = bufferedReader.readLine()) != null) {    \n                buffer.append(str);    \n            }    \n            \n            bufferedReader.close();    \n            inputStreamReader.close();    \n            inputStream.close();    \n            inputStream = null;    \n            conn.disconnect();    \n            return buffer.toString();    \n        } catch (Exception e) {    \n            System.out.println(\"http exception{}\"+ e);\n            Logger.error(e.getMessage());\n        }    \n        return null;    \n    }    \n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(requestMethod);\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n            conn.setDoOutput(true);\n\n            if (outputStr != null && !outputStr.isEmpty()) {\n                OutputStream os = conn.getOutputStream();\n                os.write(outputStr.getBytes(\"UTF-8\"));\n                os.flush();\n                os.close();\n            }\n\n            int responseCode = conn.getResponseCode();\n            BufferedReader reader;\n            if (responseCode >= 200 && responseCode < 300) {\n                reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            } else {\n                reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));\n            }\n\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            // Resource cleanup is handled by the try-with-resources or explicit close in the code\n        }\n    }\n}"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private static class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                java.net.URL obj = new java.net.URL(url);\n                java.net.HttpURLConnection con = (java.net.HttpURLConnection) obj.openConnection();\n                con.setRequestMethod(\"GET\");\n                int responseCode = con.getResponseCode();\n                if (responseCode == 200) {\n                    java.io.InputStream inputStream = con.getInputStream();\n                    String result = ConvertInputToStringNoChange(inputStream);\n                    publishProgress(result);\n                    return result;\n                } else {\n                    return \"Error: \" + responseCode;\n                }\n            } catch (Exception e) {\n                return \"Exception: \" + e.getMessage();\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            String jsonData = progress[0];\n            try {\n                org.json.JSONArray jsonArray = new org.json.JSONArray(jsonData);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    org.json.JSONObject jsonObject = jsonArray.getJSONObject(i);\n                    // Process each JSON object here\n                }\n            } catch (org.json.JSONException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result2) {\n            super.onPostExecute(result2);\n            // Handle the result after task completion\n        }\n    }\n\n    public static MyAsyncTask getNews(String... params) {\n        return new MyAsyncTask().execute(params);\n    }\n\n    private static String ConvertInputToStringNoChange(InputStream inputStream) {\n        java.util.Scanner s = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n        return s.hasNext() ? s.next() : \"\";\n    }\n}"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.logging.Logger;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.Optional;\n\npublic class HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        if (path == null || targetUrlString == null || userAgent == null) {\n            throw new IllegalArgumentException(\"Arguments cannot be null\");\n        }\n\n        URI uri = new URI(targetUrlString);\n        String currentUrl = targetUrlString;\n        int redirectCount = 0;\n\n        while (redirectCount <= MAXIMUM_REDIRECTS) {\n            Optional<String> nextUrl = getDownloadedOrNextUrl(currentUrl, path, userAgent);\n            if (nextUrl.isPresent()) {\n                currentUrl = nextUrl.get();\n                redirectCount++;\n                continue;\n            }\n            break;\n        }\n    }\n\n    private Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        URL url = new URL(urlString);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestProperty(\"User-Agent\", userAgent);\n        connection.setInstanceFollowRedirects(false);\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 300 && responseCode < 400) {\n            String location = connection.getHeaderField(\"Location\");\n            if (location != null) {\n                logger.info(\"Redirecting to: {}\", location);\n                return Optional.of(location);\n            }\n        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (InputStream in = connection.getInputStream();\n                 OutputStream out = Files.newOutputStream(path)) {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesRead);\n                }\n                logger.info(\"Download completed successfully to: {}\", path);\n                return Optional.empty();\n            }\n        } else {\n            logger.error(\"Failed to download from {}: HTTP error code {}\", urlString, responseCode);\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n        return Optional.empty();\n    }\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.file.Files;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class WebUtils {\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public static String getBody(String reqURL) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            return connectionToString(con);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error fetching URL: \" + reqURL, e);\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) {\n        try {\n            String body = getBody(reqURL);\n            return objectMapper.readTree(body);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error parsing JSON from URL: \" + reqURL, e);\n        }\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream inputStream = con.getInputStream();\n            Files.copy(inputStream, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error downloading file from URL: \" + reqURL, e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setDoOutput(true);\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = postContent.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            return connectionToString(con);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error posting to URL: \" + reqURL, e);\n        }\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) {\n        try {\n            StringBuilder postData = new StringBuilder();\n            for (Map.Entry<String, String> param : fields.entrySet()) {\n                if (postData.length() != 0) postData.append('&');\n                postData.append(URLEncoder.encode(param.getKey(), \"UTF-8\"));\n                postData.append('=');\n                postData.append(URLEncoder.encode(param.getValue(), \"UTF-8\"));\n            }\n            byte[] postDataBytes = postData.toString().getBytes(\"UTF-8\");\n\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            con.setDoOutput(true);\n            try (OutputStream os = con.getOutputStream()) {\n                os.write(postDataBytes);\n            }\n            return connectionToString(con);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error submitting form to URL: \" + reqURL, e);\n        }\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            return reader.lines();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error getting line stream from URL: \" + reqURL, e);\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/5311 (KHTML, like Gecko) Chrome/99.0.4515.102 Safari/537.36\";\n    }\n\n    public static String connectionToString(HttpURLConnection con) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            return reader.lines().collect(Collectors.joining(\"\\n\"));\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error reading HTTP connection response\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class RealRequest {\n    public static String sRequestURL;\n    protected HttpConfig httpConfig;\n    protected static final String TAG = \"SA.HttpRequest\";\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n        setHeader(conn, headerMap);\n        try {\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n        setHeader(conn, headerMap);\n        try {\n            conn.setRequestProperty(\"Content-Type\", bodyType);\n            conn.setDoOutput(true);\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(body.getBytes());\n                os.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    protected HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) {\n        try {\n            URL url = new URL(requestURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(requestMethod);\n            conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n            conn.setReadTimeout(httpConfig.getReadTimeout());\n            conn.setUseCaches(false);\n            return conn;\n        } catch (Exception e) {\n            throw new RuntimeException(TAG + \": Error creating connection\", e);\n        }\n    }\n\n    protected void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    protected RealResponse getRealResponse(HttpURLConnection conn) throws Exception {\n        int responseCode = conn.getResponseCode();\n        BufferedReader reader;\n        if (responseCode >= 200 && responseCode < 300) {\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));\n        }\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return new RealResponse(response.toString(), responseCode, conn.getResponseMessage());\n    }\n\n    protected RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(e.getMessage(), -1, \"ERROR\");\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}\n\nclass RealResponse {\n    private String data;\n    private int code;\n    private String message;\n\n    public RealResponse(String data, int code, String message) {\n        this.data = data;\n        this.code = code;\n        this.message = message;\n    }\n\n    public String getData() {\n        return data;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\n\nclass HttpConfig {\n    private int connectionTimeout = 5000;\n    private int readTimeout = 10000;\n\n    public int getConnectionTimeout() {\n        return connectionTimeout;\n    }\n\n    public HttpConfig setConnectionTimeout(int connectionTimeout) {\n        this.connectionTimeout = connectionTimeout;\n        return this;\n    }\n\n    public int getReadTimeout() {\n        return readTimeout;\n    }\n\n    public HttpConfig setReadTimeout(int readTimeout) {\n        this.readTimeout = readTimeout;\n        return this;\n    }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\r\n    private final boolean allowCrossProtocolRedirects;\r\n    private final int connectTimeoutMillis;\r\n    private final int readTimeoutMillis;\r\n    private final RequestProperties requestProperties;\r\n    private DataSpec dataSpec;\r\n    private HttpURLConnection connection;\r\n    private InputStream inputStream;\r\n    private boolean opened;\r\n\r\n    public YoutubeHttpDataSource(boolean allowCrossProtocolRedirects, int connectTimeoutMillis, int readTimeoutMillis, RequestProperties requestProperties) {\r\n        this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;\r\n        this.connectTimeoutMillis = connectTimeoutMillis;\r\n        this.readTimeoutMillis = readTimeoutMillis;\r\n        this.requestProperties = requestProperties;\r\n    }\r\n\r\n    @Override\r\n    public long open(DataSpec dataSpecParameter) throws HttpDataSourceException {\r\n        if (opened) {\r\n            throw new IllegalStateException(\"Already opened\");\r\n        }\r\n        dataSpec = dataSpecParameter;\r\n        try {\r\n            connection = makeConnection(dataSpec);\r\n            if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\r\n                inputStream = connection.getInputStream();\r\n            } else {\r\n                inputStream = connection.getErrorStream();\r\n            }\r\n            opened = true;\r\n            return connection.getContentLengthLong();\r\n        } catch (IOException e) {\r\n            throw new HttpDataSourceException(\"Unable to connect to \" + dataSpec.uri, e, dataSpec);\r\n        }\r\n    }\r\n\r\n    protected HttpURLConnection makeConnection(DataSpec dataSpecToUse) throws IOException {\r\n        URL url = dataSpecToUse.uri;\r\n        HttpURLConnection connection = openConnection(url);\r\n        connection.setConnectTimeout(connectTimeoutMillis);\r\n        connection.setReadTimeout(readTimeoutMillis);\r\n        for (Map.Entry<String, String> entry : requestProperties.headers().entrySet()) {\r\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\r\n        }\r\n        if (dataSpecToUse.position > 0) {\r\n            connection.setRequestProperty(\"Range\", \"bytes=\" + dataSpecToUse.position + \"-\");\r\n        }\r\n        int responseCode = connection.getResponseCode();\r\n        if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\r\n            String location = connection.getHeaderField(\"Location\");\r\n            if (location == null) {\r\n                throw new IOException(\"Received redirect response but no location header was present\");\r\n            }\r\n            URL newUrl = new URL(location);\r\n            if (!allowCrossProtocolRedirects && !url.getProtocol().equals(newUrl.getProtocol())) {\r\n                throw new IOException(\"Received cross-protocol redirect from \" + url + \" to \" + newUrl);\r\n            }\r\n            url = handleRedirect(url, location, dataSpecToUse);\r\n            connection = makeConnection(new DataSpec(dataSpecToUse.uri, dataSpecToUse.position, dataSpecToUse.length, dataSpecToUse.flags));\r\n        }\r\n        return connection;\r\n    }\r\n\r\n    protected HttpURLConnection openConnection(URL url) throws IOException {\r\n        return (HttpURLConnection) url.openConnection();\r\n    }\r\n\r\n    protected URL handleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) throws IOException {\r\n        URL newUrl = new URL(originalUrl, location);\r\n        return newUrl;\r\n    }\r\n\r\n    @Override\r\n    public void close() {\r\n        if (!opened) {\r\n            return;\r\n        }\r\n        opened = false;\r\n        maybeTerminateInputStream(connection, dataSpec.length);\r\n        closeConnectionQuietly();\r\n        inputStream = null;\r\n        dataSpec = null;\r\n    }\r\n\r\n    protected void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\r\n            if (bytesRemaining > 0) {\r\n                try {\r\n                    connection.getInputStream().close();\r\n                } catch (IOException e) {\r\n                    // Ignore\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void closeConnectionQuietly() {\r\n        if (connection != null) {\r\n            try {\r\n                connection.disconnect();\r\n            } catch (Exception e) {\r\n                // Ignore\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {\r\n        try {\r\n            int bytesRead = inputStream.read(buffer, offset, readLength);\r\n            if (bytesRead == -1) {\r\n                return -1;\r\n            }\r\n            return bytesRead;\r\n        } catch (IOException e) {\r\n            throw new HttpDataSourceException(\"Error while reading\", e, dataSpec);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void reset() {\r\n        // Not implemented\r\n    }\r\n\r\n    @Override\r\n    public boolean isOpen() {\r\n        return opened;\r\n    }\r\n\r\n    @Override\r\n    public void setRequestProperty(String key, String value) {\r\n        requestProperties.set(key, value);\r\n    }\r\n}"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Java class that implements a RESTful client using HttpURLConnection to perform HTTP requests (GET, POST, PUT) and handle responses.\n\nClass Description: The `RestfulClient` class provides methods to execute HTTP requests (GET, POST, PUT) to a specified URL and process the responses. It handles connection setup, request parameter configuration, input/output stream management, and connection cleanup.\n\nAttributes: None\n\nMethods:\n\nMethod1: `get(String path) -> String` - Executes a GET request to the specified URL path and returns the response as a String.  \nMethod2: `post(String path, String requestBody) -> String` - Executes a POST request to the specified URL path with the provided request body and returns the response as a String.  \nMethod3: `put(String path, String requestBody) -> String` - Executes a PUT request to the specified URL path with the provided request body and returns the response as a String.  \nMethod4: `executeRequest(String method, String path, String requestBody) -> String` - Internal helper method that handles the common logic for executing HTTP requests (connection setup, request configuration, and response processing).  \nMethod5: `getVal(RestfulRequest request) -> String` - Executes a custom HTTP request based on the provided `RestfulRequest` object (containing URL, method, and parameters) and returns the response as a String.  \n\nInput:  \n- For `get`, `post`, and `put`:  \n  - `path` (String): The target URL for the HTTP request.  \n  - `requestBody` (String, optional for POST/PUT): The request payload in JSON format.  \n- For `getVal`:  \n  - `request` (RestfulRequest): An object encapsulating the request details (URL, HTTP method, and parameters).  \n\nOutput:  \n- String: The response body from the HTTP request, or `null` if an error occurs.",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody){\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(path);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes();\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            if (connection.getResponseCode() == 200) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String inputLine;\n                    StringBuilder response = new StringBuilder();\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                    return response.toString();\n                }\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n    public String getVal(RestfulRequest request) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(request.getUrl());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(request.getMethod());\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \" application/json\");\n            byte[] content = request.getParam().getBytes();\n            connection.setRequestProperty(\"Content-Length\", content.length + \"\");\n\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.connect();\n            OutputStream out = connection.getOutputStream();\n            out.write(content);\n            out.flush();\n            out.close();\n\n            if (connection.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class RestfulClient {\n    private static final String USER_AGENT = \"Mozilla/5.0\";\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody) {\n        try {\n            URL url = new URL(path);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(method);\n            conn.setRequestProperty(\"User-Agent\", USER_AGENT);\n            conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n\n            if (requestBody != null) {\n                conn.setDoOutput(true);\n                try (OutputStream os = conn.getOutputStream()) {\n                    byte[] input = requestBody.getBytes(\"utf-8\");\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getVal(RestfulRequest request) {\n        try {\n            URL url = new URL(request.getUrl());\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(request.getMethod());\n            conn.setRequestProperty(\"User-Agent\", USER_AGENT);\n            conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n\n            if (request.getParameter() != null) {\n                conn.setDoOutput(true);\n                try (OutputStream os = conn.getOutputStream()) {\n                    byte[] input = request.getParameter().getBytes(\"utf-8\");\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Java utility class for making HTTPS requests using HttpURLConnection with custom SSL socket factory configuration.\n\nClass Description: HttpClientUtil is a utility class that provides methods for making HTTPS requests with custom SSL/TLS configuration. It handles both GET and POST methods, manages connection settings, and includes proper error handling and resource cleanup.\n\nAttributes: (None - this is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String method, String outputStr) -> HttpResponse - Makes an HTTPS request to the specified URL using the given HTTP method. Handles request body for POST methods and returns the server response.\n\nMethod2: httpsRequest2(String requestUrl, String method, String outputStr) -> HttpResponse - Alternative implementation that uses a different URL constructor with protocol handler, otherwise similar to httpsRequest.\n\nMethod3: createSSLSocketFactory() -> SSLSocketFactory - Private helper method that creates and configures an SSLSocketFactory with custom TrustManager for SSL/TLS connections. Throws IOException if SSL context creation fails.\n\nInput Parameters:\n- requestUrl: String - The HTTPS URL to connect to\n- method: String - HTTP method (GET/POST)\n- outputStr: String - Request body content (for POST requests)\n\nOutput:\n- Returns HttpResponse object containing the server response\n- Throws IOException for connection or SSL configuration errors",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\n\npublic class HttpClientUtil {\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(requestUrl);\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] tm = { new MyX509TrustManager() };\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n            sslContext.init(null, tm, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            throw new IOException(\"\u5b9e\u4f8b\u5316SSLContext\u5931\u8d25\", e);\n        } catch (KeyManagementException e) {\n            throw new IOException(\"\u521d\u59cb\u5316SSLContext\u5931\u8d25\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class HttpClientUtil {\n    private static final int CONNECT_TIMEOUT = 10000;\n    private static final int READ_TIMEOUT = 10000;\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        SSLSocketFactory sslSocketFactory = createSSLSocketFactory();\n        HttpsURLConnection.setDefaultSSLSocketFactory(sslSocketFactory);\n        URL url = new URL(requestUrl);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setRequestMethod(method);\n        connection.setConnectTimeout(CONNECT_TIMEOUT);\n        connection.setReadTimeout(READ_TIMEOUT);\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n        connection.setDoOutput(true);\n\n        if (method.equalsIgnoreCase(\"POST\")) {\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] inputBytes = outputStr.getBytes(\"UTF-8\");\n                os.write(inputBytes);\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        String responseMessage = connection.getResponseMessage();\n        String responseContent = readResponse(connection.getInputStream());\n\n        return new HttpResponse(responseCode, responseMessage, responseContent);\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setRequestMethod(method);\n        connection.setConnectTimeout(CONNECT_TIMEOUT);\n        connection.setReadTimeout(READ_TIMEOUT);\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n        connection.setDoOutput(true);\n        SSLSocketFactory sslSocketFactory = createSSLSocketFactory();\n        connection.setSSLSocketFactory(sslSocketFactory);\n\n        if (method.equalsIgnoreCase(\"POST\")) {\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] inputBytes = outputStr.getBytes(\"UTF-8\");\n                os.write(inputBytes);\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        String responseMessage = connection.getResponseMessage();\n        String responseContent = readResponse(connection.getInputStream());\n\n        return new HttpResponse(responseCode, responseMessage, responseContent);\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            TrustManager[] trustAllCerts = new TrustManager[]{\n                new X509TrustManager() {\n                    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n                    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return new X509Certificate[0];\n                    }\n                }\n            };\n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new IOException(\"Failed to create SSL context\", e);\n        }\n    }\n\n    private static String readResponse(InputStream inputStream) throws IOException {\n        if (inputStream == null) {\n            return \"\";\n        }\n        StringBuilder response = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return response.toString();\n    }\n\n    public static class HttpResponse {\n        private final int code;\n        private final String message;\n        private final String content;\n\n        public HttpResponse(int code, String message, String content) {\n            this.code = code;\n            this.message = message;\n            this.content = content;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n\n        public String getContent() {\n            return content;\n        }\n    }\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using Netty framework for making GET and POST requests to a remote server, with support for timeout handling and asynchronous response processing.\n\nClass Description: TestHttpClient is a Netty-based HTTP client that handles both GET and POST requests asynchronously. It manages connection pooling, request/response processing, and timeout handling. The class uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- host: String - The target server hostname or IP address\n- port: int - The target server port number\n- defaultTimeout: int - Default timeout in milliseconds for request completion\n- workerGroup: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- b: Bootstrap - Netty bootstrap for client configuration\n- results: ConcurrentHashMap<String, CompletableFuture<String>> - Map for tracking pending requests and their futures\n\nMethods:\n- init(): void - Initializes the Netty client configuration including pipeline setup\n- close(): void - Shuts down the client gracefully and releases resources\n- get(String uri) -> String - Sends an HTTP GET request to the specified URI\n- post(String uri, Map<String, String> params, Map<String, String> headers) -> String - Sends an HTTP POST request with parameters and headers\n- send(HttpRequest request) -> String - Internal method for sending requests and handling responses",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private Map<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b = new Bootstrap();\n        workerGroup = new NioEventLoopGroup();\n        b.group(workerGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\"http-decoder\", new HttpResponseDecoder());\n                ch.pipeline().addLast(\"http-encoder\", new HttpRequestEncoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(1024 * 1024));\n                ch.pipeline().addLast(\"clientHandler\", new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpResponse httpResponse) {\n                        CompletableFuture<String> future = results.get(ctx.channel().id().asLongText());\n                        if (future != null) {\n                            future.complete(httpResponse.content().toString(CharsetUtil.UTF_8));\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void close() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        results.clear();\n    }\n\n    public String get(String uri) throws Exception {\n        DefaultHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, new URI(uri).toASCIIString());\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws Exception {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(uri).toASCIIString());\n        if (params != null && !params.isEmpty()) {\n            HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(new DefaultHttpDataFactory(), request, false);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encoder.addBodyAttribute(entry.getKey(), entry.getValue());\n            }\n            request = encoder.finalizeRequest();\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) throws Exception {\n        ChannelFuture f = b.connect(host, port).sync();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(f.channel().id().asLongText(), future);\n        String result;\n        try {\n            f.channel().writeAndFlush(request).sync();\n            result = future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } finally {\n            results.remove(f.channel().id().asLongText());\n            f.channel().closeFuture().sync();\n        }\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.ReadTimeoutHandler;\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private final String host;\n    private final int port;\n    private final int defaultTimeout;\n    private final NioEventLoopGroup workerGroup;\n    private final Bootstrap b;\n    private final ConcurrentHashMap<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        this.workerGroup = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        init();\n    }\n\n    private void init() {\n        b.group(workerGroup)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, defaultTimeout)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) {\n                 ch.pipeline().addLast(new HttpClientCodec());\n                 ch.pipeline().addLast(new ReadTimeoutHandler(defaultTimeout, TimeUnit.MILLISECONDS));\n                 ch.pipeline().addLast(new HttpResponseDecoder());\n                 ch.pipeline().addLast(new HttpRequestEncoder());\n                 ch.pipeline().addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n                     @Override\n                     protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse response) {\n                         String id = ctx.channel().id().asLongText();\n                         CompletableFuture<String> future = results.remove(id);\n                         if (future != null) {\n                             future.complete(response.content().toString(io.netty.util.CharsetUtil.UTF_8));\n                         }\n                         ctx.close();\n                     }\n\n                     @Override\n                     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                         String id = ctx.channel().id().asLongText();\n                         CompletableFuture<String> future = results.remove(id);\n                         if (future != null) {\n                             future.completeExceptionally(cause);\n                         }\n                         ctx.close();\n                     }\n                 });\n             }\n         });\n    }\n\n    public void close() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public String get(String uri) {\n        return send(buildGetRequest(uri));\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) {\n        return send(buildPostRequest(uri, params, headers));\n    }\n\n    private String send(HttpRequest request) {\n        String id = String.valueOf(System.currentTimeMillis());\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(id, future);\n\n        try {\n            ChannelFuture channelFuture = b.connect(host, port).sync();\n            channelFuture.addListener(future1 -> {\n                if (future1.isSuccess()) {\n                    Channel channel = future1.channel();\n                    channel.writeAndFlush(request);\n                } else {\n                    future.completeExceptionally(future1.cause());\n                }\n            });\n        } catch (InterruptedException e) {\n            future.completeExceptionally(e);\n        }\n\n        try {\n            return future.get();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Request failed\", e);\n        }\n    }\n\n    private FullHttpRequest buildGetRequest(String uri) {\n        URI url = new URI(uri);\n        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, url.getPath());\n        request.headers().set(HttpHeaderNames.HOST, host + \":\" + port);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        return request;\n    }\n\n    private FullHttpRequest buildPostRequest(String uri, Map<String, String> params, Map<String, String> headers) {\n        URI url = new URI(uri);\n        StringBuilder paramBuilder = new StringBuilder();\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            if (paramBuilder.length() > 0) paramBuilder.append('&');\n            paramBuilder.append(entry.getKey()).append('=').append(entry.getValue());\n        }\n        byte[] content = paramBuilder.toString().getBytes();\n        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, url.getPath(), Unpooled.wrappedBuffer(content));\n        request.headers().set(HttpHeaderNames.HOST, host + \":\" + port);\n        request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.length);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return request;\n    }\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Implement a Java class that reads and processes PMTiles archives, providing access to individual tiles and their metadata using Java NIO's FileChannel for efficient file operations.\n\nClass Description: ReadablePmtiles is a concrete implementation of the ReadableTileArchive interface that enables reading and navigating through a PMTiles archive format. It uses FileChannel for efficient random access to file contents and handles compressed directory structures within the archive.\n\nAttributes:\n- channel: [SeekableByteChannel] - The underlying byte channel for reading the PMTiles file\n- header: [Pmtiles.Header] - The parsed header information from the PMTiles archive\n\nMethods:\n- newReadFromFile: [static](Path path) -> [ReadableTileArchive] - Static factory method that creates a new instance by opening a file channel to the specified path\n- getTile: [int x, int y, int z] -> [byte[]] - Retrieves the tile data at the specified coordinates (x,y,z) or returns null if not found\n- close: [] -> [void] - Closes the underlying file channel and releases system resources\n- getAllTiles: [] -> [CloseableIterator<Tile>] - Returns an iterator over all tiles in the archive\n- getBytes: [private](long start, int length) -> [byte[]] - Internal method to read bytes from the channel at specified position\n- readDir: [private](long offset, int length) -> [List<Pmtiles.Entry>] - Reads and parses a directory from the archive\n- getTiles: [private](List<Pmtiles.Entry> dir) -> [Stream<Tile>] - Converts directory entries into a stream of tiles",
    "Canonical_solution": "import com.onthegomap.planetiler.archive.ReadableTileArchive;\nimport com.onthegomap.planetiler.archive.Tile;\nimport com.onthegomap.planetiler.archive.TileArchiveMetadata;\nimport com.onthegomap.planetiler.archive.TileCompression;\nimport com.onthegomap.planetiler.geo.TileCoord;\nimport com.onthegomap.planetiler.util.CloseableIterator;\nimport com.onthegomap.planetiler.util.Gzip;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.locationtech.jts.geom.Coordinate;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n  private final SeekableByteChannel channel;\n  private final Pmtiles.Header header;\n\n  public ReadablePmtiles(SeekableByteChannel channel) throws IOException {\n    this.channel = channel;\n    this.header = Pmtiles.Header.fromBytes(getBytes(0, Pmtiles.HEADER_LEN));\n  }\n\n  public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n    return new ReadablePmtiles(FileChannel.open(path, StandardOpenOption.READ));\n  }\n\n  private synchronized byte[] getBytes(long start, int length) throws IOException {\n    channel.position(start);\n    var buf = ByteBuffer.allocate(length);\n    channel.read(buf);\n    return buf.array();\n  }\n\n  @Override\n  @SuppressWarnings(\"java:S1168\")\n  public byte[] getTile(int x, int y, int z) {\n    try {\n      var tileId = TileCoord.ofXYZ(x, y, z).hilbertEncoded();\n      long dirOffset = header.rootDirOffset();\n      int dirLength = (int) header.rootDirLength();\n\n      for (int depth = 0; depth <= 3; depth++) {\n        byte[] dirBytes = getBytes(dirOffset, dirLength);\n        if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n          dirBytes = Gzip.gunzip(dirBytes);\n        }\n\n        var dir = Pmtiles.directoryFromBytes(dirBytes);\n        var entry = findTile(dir, tileId);\n        if (entry != null) {\n          if (entry.runLength() > 0) {\n            return getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          } else {\n            dirOffset = header.leafDirectoriesOffset() + entry.offset();\n            dirLength = entry.length();\n          }\n        } else {\n          return null;\n        }\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not get tile\", e);\n    }\n    return null;\n  }\n\n  @Override\n  public void close() throws IOException {\n    channel.close();\n  }\n\n  private List<Pmtiles.Entry> readDir(long offset, int length) {\n    try {\n      var buf = getBytes(offset, length);\n      if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n        buf = Gzip.gunzip(buf);\n      }\n      return Pmtiles.directoryFromBytes(buf);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public CloseableIterator<Tile> getAllTiles() {\n    List<Pmtiles.Entry> rootDir = readDir(header.rootDirOffset(), (int) header.rootDirLength());\n    return CloseableIterator.of(getTiles(rootDir));\n  }\n\n  private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n    return dir.stream().mapMulti((entry, next) -> {\n      try {\n        if (entry.runLength == 0) {\n          getTiles(readDir(header.leafDirectoriesOffset() + entry.offset(), entry.length())).forEach(next);\n        } else {\n          var data = getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          for (int i = 0; i < entry.runLength(); i++) {\n            next.accept(new Tile(TileCoord.hilbertDecode((int) (entry.tileId() + i)), data));\n          }\n        }\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to iterate through pmtiles archive \", e);\n      }\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\nimport java.util.stream.Collectors;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n    private final SeekableByteChannel channel;\n    private final Pmtiles.Header header;\n\n    public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n        try (SeekableByteChannel channel = Files.newByteChannel(path)) {\n            return new ReadablePmtiles(channel);\n        }\n    }\n\n    private ReadablePmtiles(SeekableByteChannel channel) throws IOException {\n        this.channel = channel;\n        this.header = parseHeader();\n    }\n\n    private Pmtiles.Header parseHeader() throws IOException {\n        byte[] headerBytes = getBytes(0, Pmtiles.HEADER_SIZE);\n        return Pmtiles.Header.parseFrom(headerBytes);\n    }\n\n    private byte[] getBytes(long start, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.position(start);\n        channel.read(buffer);\n        return buffer.array();\n    }\n\n    private List<Pmtiles.Entry> readDir(long offset, int length) throws IOException {\n        byte[] dirBytes = getBytes(offset, length);\n        return Pmtiles.Directory.parseFrom(dirBytes).getEntriesList();\n    }\n\n    private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n        return dir.stream().map(entry -> new Tile(entry.getX(), entry.getY(), entry.getZ(), entry.getData().toByteArray()));\n    }\n\n    @Override\n    public byte[] getTile(int x, int y, int z) {\n        try {\n            long dirOffset = header.getDirectoryOffset();\n            int dirLength = header.getDirectoryLength();\n            List<Pmtiles.Entry> entries = readDir(dirOffset, dirLength);\n            for (Pmtiles.Entry entry : entries) {\n                if (entry.getX() == x && entry.getY() == y && entry.getZ() == z) {\n                    return entry.getData().toByteArray();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    @Override\n    public void close() throws IOException {\n        channel.close();\n    }\n\n    @Override\n    public CloseableIterator<Tile> getAllTiles() {\n        return new CloseableIterator<Tile>() {\n            private final List<Pmtiles.Entry> entries;\n            private final Iterator<Pmtiles.Entry> iterator;\n\n            {\n                try {\n                    long dirOffset = header.getDirectoryOffset();\n                    int dirLength = header.getDirectoryLength();\n                    entries = readDir(dirOffset, dirLength);\n                    iterator = entries.iterator();\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Failed to read directory\", e);\n                }\n            }\n\n            @Override\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public Tile next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                Pmtiles.Entry entry = iterator.next();\n                return new Tile(entry.getX(), entry.getY(), entry.getZ(), entry.getData().toByteArray());\n            }\n\n            @Override\n            public void close() throws IOException {\n                channel.close();\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for network communication, capable of establishing connections, sending/receiving messages, and gracefully shutting down.\n\nClass Description: NettyRemotingClient is a Netty-based TCP client implementation that handles network communication with a remote server. It manages connection lifecycle, message encoding/decoding, and provides synchronous invocation capabilities.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty's Bootstrap instance for client configuration\n- eventLoopGroupWorker: [EventLoopGroup] - Manages client-side I/O threads\n\nMethods:\n- NettyRemotingClient(): [Constructor] -> [void] - Initializes the client with NioEventLoopGroup and configures Bootstrap with NioSocketChannel, TCP_NODELAY option, and pipeline handlers (encoder, decoder, and client handler)\n- createChannel(String addr): [String addr (host:port format)] -> [ChannelFuture] - Creates a channel connection to the specified address, throws RemotingConnectException if connection fails\n- invokeSync(Channel channel, RemotingCommand request, long timeoutMillis): [Channel channel, RemotingCommand request, long timeoutMillis] -> [CompletableFuture<RemotingCommand>] - Sends a request synchronously through the channel and returns a CompletableFuture for the response\n- shutdown(): [void] -> [void] - Gracefully shuts down the event loop group and releases resources\n- NettyClientHandler: [Inner Class] -> [void] - Handles incoming messages from the server (extends SimpleChannelInboundHandler<RemotingCommand>)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.apache.rocketmq.remoting.exception.RemotingConnectException;\nimport org.apache.rocketmq.remoting.protocol.RemotingCommand;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class NettyRemotingClient {\n\n    private final Bootstrap bootstrap = new Bootstrap();\n    private final EventLoopGroup eventLoopGroupWorker;\n\n    public NettyRemotingClient() {\n        this.eventLoopGroupWorker = new NioEventLoopGroup();\n        this.bootstrap.group(this.eventLoopGroupWorker)\n            .channel(NioSocketChannel.class)\n            .option(ChannelOption.TCP_NODELAY, true)\n            .option(ChannelOption.SO_KEEPALIVE, false)\n            .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(\n                        new NettyEncoder(),\n                        new NettyDecoder(),\n                        new NettyClientHandler());\n                }\n            });\n    }\n\n    public ChannelFuture createChannel(String addr) throws InterruptedException, RemotingConnectException {\n        String[] hostAndPort = addr.split(\":\");\n        ChannelFuture channelFuture = bootstrap.connect(hostAndPort[0], Integer.parseInt(hostAndPort[1])).sync();\n        if (!channelFuture.isSuccess()) {\n            throw new RemotingConnectException(addr);\n        }\n        return channelFuture;\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        try {\n            channel.writeAndFlush(request).addListener(f -> {\n                if (f.isSuccess()) {\n                    // Handle response logic here\n                } else {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n        }\n        return future;\n    }\n\n    public void shutdown() {\n        this.eventLoopGroupWorker.shutdownGracefully();\n    }\n\n    class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            // Process incoming messages\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyRemotingClient {\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroupWorker;\n\n    public NettyRemotingClient() {\n        eventLoopGroupWorker = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroupWorker)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new RemotingCommandEncoder());\n                        ch.pipeline().addLast(new RemotingCommandDecoder());\n                        ch.pipeline().addLast(new NettyClientHandler());\n                    }\n                });\n    }\n\n    public ChannelFuture createChannel(String addr) throws RemotingConnectException {\n        String[] arr = addr.split(\":\");\n        if (arr.length != 2) {\n            throw new RemotingConnectException(\"Address format is incorrect: \" + addr);\n        }\n        String host = arr[0];\n        int port = Integer.parseInt(arr[1]);\n        try {\n            return bootstrap.connect(host, port).sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RemotingConnectException(\"Failed to connect to \" + addr, e);\n        }\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        channel.writeAndFlush(request).addListener(future1 -> {\n            if (future1.isSuccess()) {\n                channel.closeFuture().addListener(future2 -> {\n                    if (future2.isSuccess()) {\n                        future.completeExceptionally(new RemotingConnectException(\"Channel closed\"));\n                    }\n                });\n            } else {\n                future.completeExceptionally(new RemotingConnectException(\"Failed to send request\", future1.cause()));\n            }\n        });\n        return future;\n    }\n\n    public void shutdown() {\n        if (eventLoopGroupWorker != null) {\n            eventLoopGroupWorker.shutdownGracefully();\n        }\n    }\n\n    private class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            // Handle incoming message\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.Promise;\n\nimport javax.net.ssl.SSLException;\nimport java.net.InetSocketAddress;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient {\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group = new NioEventLoopGroup();\n    private final Bootstrap b = new Bootstrap();\n    private final Queue<HttpObject> responseParts = new ConcurrentLinkedQueue<>();\n    private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n    private final CommunicationHandler communicationHandler = new CommunicationHandler();\n    private final AtomicBoolean isOpen = new AtomicBoolean(false);\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private FutureResult<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n\n    public NettyClient(String hostname, int port, SSLFactory sslFactory) {\n        this.hostname = hostname;\n        this.port = port;\n        configureBootstrap(sslFactory);\n    }\n\n    private void configureBootstrap(SSLFactory sslFactory) {\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             protected void initChannel(SocketChannel ch) throws Exception {\n                 ChannelPipeline pipeline = ch.pipeline();\n                 if (sslFactory != null) {\n                     SslContext sslContext = sslFactory.createSslContext();\n                     pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                 }\n                 pipeline.addLast(new HttpClientCodec());\n                 pipeline.addLast(new HttpObjectAggregator(65536));\n                 pipeline.addLast(communicationHandler);\n             }\n         });\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        resetState();\n        this.request = request;\n        this.content = content;\n        this.callback = callback;\n        responseFuture = new FutureResult<>();\n        createChannel();\n        return responseFuture;\n    }\n\n    public void close() {\n        if (isOpen.get()) {\n            isOpen.set(false);\n            group.shutdownGracefully();\n        }\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        callbackInvoked.set(false);\n        isKeepAlive = false;\n        exception = null;\n    }\n\n    private void createChannel() {\n        channelConnectFuture = b.connect(new InetSocketAddress(hostname, port));\n        channelConnectFuture.addListener((GenericFutureListener<ChannelFuture>) future -> {\n            if (future.isSuccess()) {\n                isOpen.set(true);\n                sendHttpRequest(future.channel());\n            } else {\n                exception = future.cause();\n                invokeFutureAndCallback(\"Connection failed: \" + exception.getMessage());\n            }\n        });\n    }\n\n    private void sendHttpRequest(Channel channel) {\n        channel.writeAndFlush(request).addListener((GenericFutureListener<Future<Void>>) future -> {\n            if (future.isSuccess()) {\n                if (content != null) {\n                    channel.writeAndFlush(content).addListener((GenericFutureListener<Future<Void>>) f -> {\n                        if (f.isSuccess()) {\n                            channel.flush();\n                        } else {\n                            exception = f.cause();\n                            invokeFutureAndCallback(\"Request content sending failed: \" + exception.getMessage());\n                        }\n                    });\n                } else {\n                    channel.flush();\n                }\n            } else {\n                exception = future.cause();\n                invokeFutureAndCallback(\"Request sending failed: \" + exception.getMessage());\n            }\n        });\n    }\n\n    private void invokeFutureAndCallback(String message) {\n        if (callbackInvoked.compareAndSet(false, true)) {\n            ResponseParts responsePartsWrapper = new ResponseParts(this.responseParts, isKeepAlive, exception);\n            if (exception != null) {\n                callback.onFailure(exception);\n            } else {\n                callback.onSuccess(responsePartsWrapper);\n            }\n            responseFuture.setResult(responsePartsWrapper);\n        }\n    }\n\n    public static class ResponseParts {\n        private final Queue<HttpObject> parts;\n        private final boolean keepAlive;\n        private final Exception exception;\n\n        public ResponseParts(Queue<HttpObject> parts, boolean keepAlive, Exception exception) {\n            this.parts = parts;\n            this.keepAlive = keepAlive;\n            this.exception = exception;\n        }\n\n        public Queue<HttpObject> getParts() {\n            return parts;\n        }\n\n        public boolean isKeepAlive() {\n            return keepAlive;\n        }\n\n        public Exception getException() {\n            return exception;\n        }\n    }\n\n    public interface Callback<T> {\n        void onSuccess(T result);\n        void onFailure(Exception e);\n    }\n\n    public interface SSLFactory {\n        SslContext createSslContext() throws SSLException;\n    }\n\n    private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                isKeepAlive = response.isKeepAlive();\n            }\n            if (msg instanceof HttpContent) {\n                responseParts.add(msg);\n            }\n            if (msg instanceof LastHttpContent) {\n                invokeFutureAndCallback(null);\n                if (!isKeepAlive) {\n                    ctx.close();\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            exception = cause;\n            invokeFutureAndCallback(\"Exception caught: \" + cause.getMessage());\n            ctx.close();\n        }\n    }\n\n    private static class FutureResult<T> extends DefaultPromise<Void> implements Future<T> {\n        private T result;\n\n        public FutureResult() {\n            super(GlobalEventExecutor.INSTANCE);\n        }\n\n        public void setResult(T result) {\n            this.result = result;\n            try {\n                super.setSuccess(null);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public T get() throws InterruptedException {\n            await();\n            return result;\n        }\n\n        @Override\n        public T get(long timeout, java.util.concurrent.TimeUnit unit) throws InterruptedException {\n            await(timeout, unit);\n            return result;\n        }\n    }\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Java class that implements a transactional log writer for Elasticsearch, handling file operations using Java NIO's FileChannel for efficient I/O operations. The class should manage writing operations, buffer management, and resource cleanup.\n\nClass Description: TranslogWriter is a transactional log writer that extends BaseTranslogReader and implements Closeable. It provides functionality to write operations to a log file using FileChannel, manage buffers, and handle synchronization. The class includes mechanisms for checkpointing, thread-safe operations, and resource management.\n\nAttributes:\n- channel: [FileChannel] - The main file channel for writing transaction log entries\n- checkpointChannel: [FileChannel] - File channel for writing checkpoint information\n- checkpointPath: [Path] - Path to the checkpoint file\n- bigArrays: [BigArrays] - Helper for managing large arrays\n- totalOffset: [long] - Current offset in the log file\n- closed: [AtomicBoolean] - Flag indicating whether the writer is closed\n- writeLock: [ReleasableLock] - Lock for thread-safe write operations\n- syncLock: [Object] - Synchronization lock object\n- buffer: [ReleasableBytesStreamOutput] - Buffer for holding data before writing\n- globalCheckpointSupplier: [LongSupplier] - Supplier for global checkpoint information\n- minTranslogGenerationSupplier: [LongSupplier] - Supplier for minimum translog generation\n- persistedSequenceNumberConsumer: [LongConsumer] - Consumer for persisted sequence numbers\n\nMethods:\n- TranslogWriter([ShardId, Checkpoint, FileChannel, FileChannel, Path, Path, ByteSizeValue, LongSupplier, LongSupplier, TranslogHeader, TragicExceptionHolder, LongConsumer, BigArrays]) -> [void] - Constructor that initializes the translog writer with all required components\n- writeAndReleaseOps([ReleasableBytesReference]) -> [void] - Writes the given bytes reference to the file and releases it\n- writeToFile([ByteBuffer]) -> [void] - Helper method that writes buffer contents to the file channel\n- readBytes([ByteBuffer, long]) -> [void] - Reads bytes from the specified position into the target buffer\n- writeCheckpoint([FileChannel, Path, Checkpoint]) -> [void] - Static helper method to write checkpoint information\n- close() -> [void] - Closes all resources and marks the writer as closed",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefIterator;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.DiskIoBufferPool;\nimport org.elasticsearch.common.lease.Releasables;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\n\nimport io.crate.common.SuppressForbidden;\nimport io.crate.common.io.IOUtils;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private volatile long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(\n        final ShardId shardId,\n        final Checkpoint initialCheckpoint,\n        final FileChannel channel,\n        final FileChannel checkpointChannel,\n        final Path path,\n        final Path checkpointPath,\n        final ByteSizeValue bufferSize,\n        final LongSupplier globalCheckpointSupplier,\n        LongSupplier minTranslogGenerationSupplier,\n        TranslogHeader header,\n        final TragicExceptionHolder tragedy,\n        final LongConsumer persistedSequenceNumberConsumer,\n        final BigArrays bigArrays) throws IOException {\n        super(initialCheckpoint.generation, channel, path, header);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = initialCheckpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    private void writeAndReleaseOps(ReleasableBytesReference toWrite) throws IOException {\n        try (ReleasableBytesReference toClose = toWrite) {\n            assert writeLock.isHeldByCurrentThread();\n            ByteBuffer ioBuffer = DiskIoBufferPool.getIoBuffer();\n\n            BytesRefIterator iterator = toWrite.iterator();\n            BytesRef current;\n            while ((current = iterator.next()) != null) {\n                int currentBytesConsumed = 0;\n                while (currentBytesConsumed != current.length) {\n                    int nBytesToWrite = Math.min(current.length - currentBytesConsumed, ioBuffer.remaining());\n                    ioBuffer.put(current.bytes, current.offset + currentBytesConsumed, nBytesToWrite);\n                    currentBytesConsumed += nBytesToWrite;\n                    if (ioBuffer.hasRemaining() == false) {\n                        ioBuffer.flip();\n                        writeToFile(ioBuffer);\n                        ioBuffer.clear();\n                    }\n                }\n            }\n            ioBuffer.flip();\n            writeToFile(ioBuffer);\n        }\n    }\n\n    @SuppressForbidden(reason = \"Channel#write\")\n    private void writeToFile(ByteBuffer ioBuffer) throws IOException {\n        while (ioBuffer.remaining() > 0) {\n            channel.write(ioBuffer);\n        }\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        try {\n            if (position + targetBuffer.remaining() > getWrittenOffset()) {\n                writeBufferedOps(position + targetBuffer.remaining(), true);\n            }\n        } catch (final Exception ex) {\n            closeWithTragicEvent(ex);\n            throw ex;\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, targetBuffer);\n    }\n\n    private static void writeCheckpoint(\n        final FileChannel fileChannel,\n        final Path checkpointFile,\n        final Checkpoint checkpoint) throws IOException {\n        Checkpoint.write(fileChannel, checkpointFile, checkpoint);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            synchronized (this) {\n                Releasables.closeIgnoringException(buffer);\n                buffer = null;\n            }\n            IOUtils.close(checkpointChannel, channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.elasticsearch.common.io.stream.ReleasableBytesStreamOutput;\nimport org.elasticsearch.common.io.stream.ReleasableBytesReference;\nimport org.elasticsearch.index.translog.TranslogHeader;\nimport org.elasticsearch.index.translog.Checkpoint;\nimport org.elasticsearch.index.translog.ShardId;\nimport org.elasticsearch.index.translog.TragicExceptionHolder;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\n\npublic class TranslogWriter extends BaseTranslogReader implements AutoCloseable {\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock;\n    private final Object syncLock = new Object();\n    private final ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(ShardId shardId, Checkpoint initialCheckpoint, FileChannel channel, FileChannel checkpointChannel,\n                          Path checkpointPath, Path translogPath, ByteSizeValue bufferSize, LongSupplier globalCheckpointSupplier,\n                          LongSupplier minTranslogGenerationSupplier, TranslogHeader header, TragicExceptionHolder tragicExceptionHolder,\n                          LongConsumer persistedSequenceNumberConsumer, BigArrays bigArrays) {\n        super(shardId, initialCheckpoint, translogPath, header, tragicExceptionHolder, bigArrays);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n        this.buffer = new ReleasableBytesStreamOutput(bufferSize.getBytes());\n        this.writeLock = new ReleasableLock();\n    }\n\n    public void writeAndReleaseOps(ReleasableBytesReference ops) {\n        if (closed.get()) {\n            throw new IllegalStateException(\"Cannot write to a closed translog writer\");\n        }\n        try (ReleasableBytesReference ref = ops) {\n            buffer.reset();\n            buffer.writeBytes(ref.bytes(), ref.length());\n            writeToFile(buffer.buffer());\n            totalOffset += buffer.length();\n            persistedSequenceNumberConsumer.accept(totalOffset);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to write operations to translog\", e);\n        }\n    }\n\n    private void writeToFile(ByteBuffer buffer) {\n        synchronized (syncLock) {\n            try {\n                while (buffer.hasRemaining()) {\n                    channel.write(buffer);\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to write to file channel\", e);\n            }\n        }\n    }\n\n    public void readBytes(ByteBuffer target, long position) {\n        try {\n            channel.position(position);\n            channel.read(target);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to read bytes from position \" + position, e);\n        }\n    }\n\n    public static void writeCheckpoint(FileChannel channel, Path path, Checkpoint checkpoint) {\n        try {\n            channel.position(0);\n            checkpoint.writeTo(channel);\n            channel.force(true);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to write checkpoint to \" + path, e);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                writeLock.release();\n                buffer.close();\n                channel.close();\n                checkpointChannel.close();\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to close translog writer\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement an asynchronous file handling class in Java using NIO's AsynchronousFileChannel for non-blocking file operations, supporting both reading and writing with various file opening options.\n\nClass Description: AsyncFileImpl is an implementation of AsyncFile interface that provides asynchronous file operations using Java NIO. It handles file reading, writing, and closing operations in a non-blocking manner, with support for various file opening modes and permissions.\n\nAttributes:\n- vertx: VertxInternal - The Vert.x instance for asynchronous operations\n- ch: AsynchronousFileChannel - The NIO asynchronous file channel\n- context: ContextInternal - The Vert.x context for operation execution\n- closed: boolean - Flag indicating if the file is closed\n- writePos: long - Current write position in the file\n- readBufferSize: int - Size of the read buffer (default 8192)\n- handler: Handler<Buffer> - Handler for read operations\n- endHandler: Handler<Void> - Handler for end of file operations\n- readPos: long - Current read position in the file\n- readLength: long - Maximum length to read (default Long.MAX_VALUE)\n\nMethods:\n- AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) -> [Constructor] - Initializes the file channel with specified path and options\n- close() -> Future<Void> - Closes the file channel and releases resources\n- read(Buffer buffer, int offset, long position, int length) -> Future<Buffer> - Reads data from file into buffer at specified position\n- write(Buffer buffer, long position) -> Future<Void> - Writes buffer content to file at specified position\n- doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for write operation\n- doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing multiple buffers\n- doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing buffer content\n- writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) -> void - Core write implementation using CompletionHandler\n- doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) -> void - Internal method for read operation\n- check() -> void - Verifies if file is not closed\n- closeInternal(Promise<Void> handler) -> void - Internal method for closing the file channel",
    "Canonical_solution": "import io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Promise;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.buffer.BufferInternal;\nimport io.vertx.core.file.AsyncFile;\nimport io.vertx.core.file.FileSystemException;\nimport io.vertx.core.file.OpenOptions;\nimport io.vertx.core.impl.Arguments;\nimport io.vertx.core.internal.ContextInternal;\nimport io.vertx.core.internal.VertxInternal;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.streams.impl.InboundBuffer;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AsyncFileImpl implements AsyncFile {\n\n    private static final Logger log = LoggerFactory.getLogger(AsyncFile.class);\n\n    private final VertxInternal vertx;\n    private final AsynchronousFileChannel ch;\n    private final ContextInternal context;\n    private boolean closed;\n    private long writePos;\n    private int readBufferSize = 8192;\n    private Handler<Buffer> handler;\n    private Handler<Void> endHandler;\n    private long readPos;\n    private long readLength = Long.MAX_VALUE;\n\n    public AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) {\n        this.vertx = vertx;\n        Path file = Paths.get(path);\n        HashSet<OpenOption> opts = new HashSet<>();\n        if (options.isRead()) opts.add(StandardOpenOption.READ);\n        if (options.isWrite()) opts.add(StandardOpenOption.WRITE);\n        if (options.isCreate()) opts.add(StandardOpenOption.CREATE);\n        if (options.isCreateNew()) opts.add(StandardOpenOption.CREATE_NEW);\n        if (options.isSync()) opts.add(StandardOpenOption.SYNC);\n        if (options.isDsync()) opts.add(StandardOpenOption.DSYNC);\n        if (options.isDeleteOnClose()) opts.add(StandardOpenOption.DELETE_ON_CLOSE);\n        if (options.isSparse()) opts.add(StandardOpenOption.SPARSE);\n        if (options.isTruncateExisting()) opts.add(StandardOpenOption.TRUNCATE_EXISTING);\n        try {\n            if (options.getPerms() != null) {\n                FileAttribute<?> attrs = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(options.getPerms()));\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor(), attrs);\n            } else {\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor());\n            }\n            if (options.isAppend()) writePos = ch.size();\n        } catch (IOException e) {\n            throw new FileSystemException(e);\n        }\n        this.context = context;\n    }\n\n    @Override\n    public Future<Void> close() {\n        Promise<Void> promise = context.promise();\n        closeInternal(promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Buffer> read(Buffer buffer, int offset, long position, int length) {\n        Promise<Buffer> promise = context.promise();\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(offset >= 0, \"offset must be >= 0\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        Arguments.require(length >= 0, \"length must be >= 0\");\n        check();\n        ByteBuffer bb = ByteBuffer.allocate(length);\n        doRead(buffer, offset, bb, position, promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Void> write(Buffer buffer, long position) {\n        Promise<Void> promise = context.promise();\n        doWrite(buffer, position, promise::handle);\n        return promise.future();\n    }\n\n    private void doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) {\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        check();\n        ByteBuf buf = ((BufferInternal)buffer).getByteBuf();\n        if (buf.nioBufferCount() > 1) {\n            doWrite(buf.nioBuffers(), position, handler);\n        } else {\n            ByteBuffer bb = buf.nioBuffer();\n            doWrite(bb, position, bb.limit(), handler);\n        }\n    }\n\n    private void doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) {\n        AtomicInteger cnt = new AtomicInteger();\n        AtomicBoolean sentFailure = new AtomicBoolean();\n        for (ByteBuffer b: buffers) {\n            int limit = b.limit();\n            doWrite(b, position, limit, ar -> {\n                if (ar.succeeded()) {\n                    if (cnt.incrementAndGet() == buffers.length) {\n                        handler.handle(ar);\n                    }\n                } else {\n                    if (sentFailure.compareAndSet(false, true)) {\n                        handler.handle(ar);\n                    }\n                }\n            });\n            position += limit;\n        }\n    }\n\n    private void doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) {\n        if (toWrite > 0) {\n            writeInternal(buff, position, handler);\n        } else {\n            handler.handle(Future.succeededFuture());\n        }\n    }\n\n    private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n        ch.write(buff, position, null, new CompletionHandler<Integer, Object>() {\n            public void completed(Integer bytesWritten, Object attachment) {\n                long pos = position;\n                if (buff.hasRemaining()) {\n                    pos += bytesWritten;\n                    writeInternal(buff, pos, handler);\n                } else {\n                    context.runOnContext((v) -> {\n                        handler.handle(Future.succeededFuture());\n                    });\n                }\n            }\n\n            public void failed(Throwable exc, Object attachment) {\n                context.runOnContext((v) -> {\n                    handler.handle(Future.failedFuture(exc));\n                });\n            }\n        });\n    }\n\n    private void doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) {\n        ch.read(buff, position, null, new CompletionHandler<Integer, Object>() {\n            long pos = position;\n\n            private void done() {\n                buff.flip();\n                writeBuff.setBytes(offset, buff);\n                buff.compact();\n                promise.complete(writeBuff);\n            }\n\n            public void completed(Integer bytesRead, Object attachment) {\n                if (bytesRead == -1) {\n                    done();\n                } else if (buff.hasRemaining()) {\n                    pos += bytesRead;\n                    doRead(writeBuff, offset, buff, pos, promise);\n                } else {\n                    done();\n                }\n            }\n\n            public void failed(Throwable t, Object attachment) {\n                promise.fail(t);\n            }\n        });\n    }\n\n    private void check() {\n        if (closed) {\n            throw new IllegalStateException(\"File handle is closed\");\n        }\n    }\n\n    private void closeInternal(Promise<Void> handler) {\n        check();\n        closed = true;\n        context.<Void>executeBlockingInternal(() -> {\n            ch.close();\n            return null;\n        }).onComplete(handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import io.vertx.core.buffer.Buffer;\nimport io.vertx.core.file.OpenOptions;\nimport io.vertx.core.impl.ContextInternal;\nimport io.vertx.core.impl.VertxInternal;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Future;\nimport io.vertx.core.Promise;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.concurrent.CompletionHandler;\n\npublic class AsyncFileImpl implements AsyncFile {\n  protected final VertxInternal vertx;\n  protected final AsynchronousFileChannel ch;\n  protected final ContextInternal context;\n  protected boolean closed = false;\n  protected long writePos = 0;\n  protected int readBufferSize = 8192;\n  protected Handler<Buffer> handler;\n  protected Handler<Void> endHandler;\n  protected long readPos = 0;\n  protected long readLength = Long.MAX_VALUE;\n\n  public AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) throws IOException {\n    this.vertx = vertx;\n    this.context = context;\n    this.ch = AsynchronousFileChannel.open(Paths.get(path), options.getRead() ? FileChannel.OpenOption.READ : FileChannel.OpenOption.WRITE, options.getWrite() ? FileChannel.OpenOption.WRITE : FileChannel.OpenOption.READ, options.isAppend() ? FileChannel.OpenOption.APPEND : null, options.isCreate() ? FileChannel.OpenOption.CREATE : null, options.isCreateNew() ? FileChannel.OpenOption.CREATE_NEW : null);\n  }\n\n  @Override\n  public Future<Void> close() {\n    Promise<Void> promise = Promise.promise();\n    closeInternal(promise);\n    return promise.future();\n  }\n\n  @Override\n  public Future<Buffer> read(Buffer buffer, int offset, long position, int length) {\n    Promise<Buffer> promise = Promise.promise();\n    check();\n    if (length <= 0) {\n      promise.complete(buffer);\n      return promise.future();\n    }\n    ByteBuffer buff = buffer.toByteBuffer();\n    doRead(buffer, offset, buff, position, promise);\n    return promise.future();\n  }\n\n  @Override\n  public Future<Void> write(Buffer buffer, long position) {\n    Promise<Void> promise = Promise.promise();\n    check();\n    doWrite(buffer.toByteBuffer(), position, promise);\n    return promise.future();\n  }\n\n  protected void doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) {\n    doWrite(buffer.toByteBuffer(), position, handler);\n  }\n\n  protected void doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) {\n    doWrite(buffers[0], position, buffers.length, handler);\n  }\n\n  protected void doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) {\n    writeInternal(buff, position, handler);\n  }\n\n  protected void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n    ch.write(buff, position, new CompletionHandler<Integer, Void>() {\n      @Override\n      public void completed(Integer result, Void attachment) {\n        handler.handle(Future.succeededFuture());\n      }\n\n      @Override\n      public void failed(Throwable exc, Void attachment) {\n        handler.handle(Future.failedFuture(exc));\n      }\n    }, null);\n  }\n\n  protected void doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) {\n    ch.read(buff, position, new CompletionHandler<Integer, Void>() {\n      @Override\n      public void completed(Integer result, Void attachment) {\n        if (result > 0) {\n          writeBuff.setBytes(offset, buff.array(), 0, result);\n          if (readLength > 0) {\n            readLength -= result;\n            if (readLength == 0) {\n              endHandler.handle(null);\n            } else {\n              doRead(writeBuff, offset + result, buff, position + result, promise);\n            }\n          } else {\n            doRead(writeBuff, offset + result, buff, position + result, promise);\n          }\n        } else {\n          promise.complete(writeBuff);\n        }\n      }\n\n      @Override\n      public void failed(Throwable exc, Void attachment) {\n        promise.fail(exc);\n      }\n    }, null);\n  }\n\n  protected void check() {\n    if (closed) {\n      throw new IllegalStateException(\"File is already closed\");\n    }\n  }\n\n  protected void closeInternal(Promise<Void> handler) {\n    if (closed) {\n      handler.complete();\n      return;\n    }\n    try {\n      ch.close();\n      closed = true;\n      handler.complete();\n    } catch (IOException e) {\n      handler.fail(e);\n    }\n  }\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n    private final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        for (long i = 0; i < chunkSize; i += 4) {\n            int value = chunk.getInt((int) i);\n            ByteBuffer key = ByteBuffer.allocate(4).putInt((int) i).flip();\n            if (value < mins.getOrDefault(key, Integer.MAX_VALUE)) {\n                mins.put(key, value);\n            }\n            if (value > maxs.getOrDefault(key, Integer.MIN_VALUE)) {\n                maxs.put(key, value);\n            }\n            sums.merge(key, value, Integer::sum);\n            counts.merge(key, 1, Integer::sum);\n        }\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n            long fileSize = fileChannel.size();\n            int chunkSize = 1024 * 1024; // 1MB chunks\n            for (long position = 0; position < fileSize; position += chunkSize) {\n                MappedByteBuffer chunk = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, Math.min(chunkSize, fileSize - position));\n                processChunk(chunk, Math.min(chunkSize, fileSize - position));\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n    private static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        boolean supported = true;\n        try {\n            File tempFile = File.createTempFile(\"anon\", \".tmp\");\n            RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n            FileChannel channel = raf.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n            channel.map(FileChannel.MapMode.READ_WRITE, 0, buffer.capacity());\n            channel.close();\n            raf.close();\n            Files.delete(tempFile.toPath());\n        } catch (Exception e) {\n            supported = false;\n        }\n        MAP_AND_UNLINK_SUPPORTED = supported;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path tempPath = Files.createTempFile(\"anon\", \".tmp\");\n                try (RandomAccessFile raf = new RandomAccessFile(tempPath.toFile(), \"rw\");\n                     FileChannel channel = raf.getChannel()) {\n                    ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    Files.delete(tempPath);\n                    return buffer;\n                }\n            } catch (Exception e) {\n                // Fallback to direct buffer if mapping fails\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\npublic abstract class TransferType {\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n    public TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = file.length();\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncSize();\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        long remaining = fileSize - offset;\n        return Math.min(bufferSize, remaining);\n    }\n\n    public boolean isSync(long position) {\n        return (position % syncSize) == 0;\n    }\n\n    public List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable) {\n        List<CompletableFuture<DataStreamReply>> futures = null;\n        try (FileChannel in = FileChannel.open(file.toPath())) {\n            futures = write(in, client.getOutputStream(), 0, futures);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return futures;\n    }\n\n    public abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures);\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n                \"path='\" + path + '\\'' +\n                \", fileSize=\" + fileSize +\n                \", bufferSize=\" + bufferSize +\n                \", syncSize=\" + syncSize +\n                '}';\n    }\n}"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a Java class for writing FLV (Flash Video) files using Java NIO's FileChannel and ByteBuffer for efficient file operations. The class should handle both new file creation and appending to existing files, including metadata management.\n\nClass Description: The FLVWriter class provides functionality to write FLV video files with proper headers, metadata tags, and media data tags. It uses Java NIO channels and buffers for efficient file operations, supporting both new file creation and appending to existing files while maintaining FLV format specifications.\n\nAttributes:\n- fileChannel: [SeekableByteChannel] - Channel for writing the final FLV output file\n- dataChannel: [SeekableByteChannel] - Temporary channel for storing tags before finalization\n- filePath: [String] - Path to the output FLV file\n- append: [boolean] - Flag indicating whether to append to an existing file\n- appendOffset: [long] - Position in existing file where new data should be appended\n- meta: [Map<String, ?>] - Metadata extracted from existing FLV file when appending\n\nMethods:\n- FLVWriter(String filePath) -> [void] - Constructor that initializes the writer with a file path for new file creation\n- FLVWriter(Path path, boolean append) -> [void] - Constructor that initializes the writer with append mode and handles existing file metadata\n- getMetaData(Path path, int maxTags) -> [Map<String, ?>] - Extracts metadata from an existing FLV file (private method)\n- createDataFile() -> [void] - Creates a temporary data file for storing tags (private method)\n- createOutputFile() -> [void] - Creates the final output FLV file (private method)\n- writeTag(ITag tag) -> [boolean] - Writes a media tag to the temporary data file\n- close() -> [void] - Finalizes the FLV file and cleans up resources\n- finalizeFlv() -> [long] - Combines temporary data with existing file (if appending) and writes final FLV file (private method)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Map;\n\npublic class FLVWriter {\n\n    private static final Logger log = LoggerFactory.getLogger(FLVWriter.class);\n\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset = 13L;\n    private Map<String, ?> meta;\n\n    public FLVWriter(String filePath) {\n        this.filePath = filePath;\n        try {\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    public FLVWriter(Path path, boolean append) {\n        filePath = path.toFile().getAbsolutePath();\n        this.append = append;\n        try {\n            if (append) {\n                meta = getMetaData(path, 5);\n                Files.move(path, path.resolveSibling(path.toFile().getName().replace(\".flv\", \".old\")));\n            }\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    private Map<String, ?> getMetaData(Path path, int maxTags) throws IOException {\n        Map<String, ?> meta = null;\n        try (SeekableByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n            long size = channel.size();\n            if (size > 0L) {\n                channel.position(appendOffset);\n                ByteBuffer dst = ByteBuffer.allocate(11);\n                do {\n                    int read = channel.read(dst);\n                    if (read > 0) {\n                        dst.flip();\n                        byte tagType = (byte) (dst.get() & 31);\n                        int bodySize = IOUtils.readUnsignedMediumInt(dst);\n                        if (tagType == ITag.TYPE_METADATA) {\n                            ByteBuffer buf = ByteBuffer.allocate(bodySize);\n                            read = channel.read(buf);\n                            if (read > 0) {\n                                buf.flip();\n                                Input input = new Input(IoBuffer.wrap(buf));\n                                String metaType = Deserializer.deserialize(input, String.class);\n                                meta = Deserializer.deserialize(input, Map.class);\n                                if (meta.containsKey(\"duration\")) {\n                                    appendOffset = channel.position() + 4L;\n                                    break;\n                                }\n                            }\n                            buf.compact();\n                        }\n                        channel.position(channel.position() + 4L);\n                        dst.compact();\n                    }\n                } while (--maxTags > 0);\n            }\n        }\n        return meta;\n    }\n\n    private void createDataFile() throws IOException {\n        Path path = Paths.get(filePath + \".ser\");\n        if (Files.deleteIfExists(path)) {\n            log.debug(\"Previous flv data file existed and was removed\");\n        }\n        this.dataChannel = Files.newByteChannel(path, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE, StandardOpenOption.READ);\n    }\n\n    private void createOutputFile() throws IOException {\n        this.fileChannel = Files.newByteChannel(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n    }\n\n    public boolean writeTag(ITag tag) throws IOException {\n        try {\n            int bodySize = tag.getBodySize();\n            byte dataType = tag.getDataType();\n            IoBuffer tagBody = tag.getBody();\n            int totalTagSize = 11 + bodySize + 4;\n            ByteBuffer tagBuffer = ByteBuffer.allocate(totalTagSize);\n            int timestamp = tag.getTimestamp();\n            byte[] bodyBuf = new byte[bodySize];\n            tagBody.get(bodyBuf);\n            IOUtils.writeUnsignedByte(tagBuffer, dataType);\n            IOUtils.writeMediumInt(tagBuffer, bodySize);\n            IOUtils.writeExtendedMediumInt(tagBuffer, timestamp);\n            tagBuffer.put(new byte[] {0, 0, 0});\n            tagBuffer.put(bodyBuf);\n            tagBuffer.putInt(11 + bodySize);\n            tagBuffer.flip();\n            dataChannel.write(tagBuffer);\n            return true;\n        } catch (Exception e) {\n            log.error(\"Failed to write tag\", e);\n            return false;\n        }\n    }\n\n    public void close() {\n        try {\n            finalizeFlv();\n        } catch (Exception e) {\n            log.error(\"Failed to finalize FLV\", e);\n        } finally {\n            try {\n                if (dataChannel != null) dataChannel.close();\n                if (fileChannel != null) fileChannel.close();\n            } catch (IOException e) {\n                log.error(\"Failed to close channels\", e);\n            }\n        }\n    }\n\n    private long finalizeFlv() throws IOException {\n        createOutputFile();\n        writeHeader();\n        writeMetadataTag();\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n        if (append) {\n            Path prevFlv = Paths.get(filePath.replace(\".flv\", \".old\"));\n            if (Files.exists(prevFlv)) {\n                try (SeekableByteChannel prevChannel = Files.newByteChannel(prevFlv, StandardOpenOption.READ)) {\n                    prevChannel.position(appendOffset);\n                    int read;\n                    do {\n                        read = prevChannel.read(dst);\n                        if (read > 0) {\n                            dst.flip();\n                            fileChannel.write(dst);\n                            dst.compact();\n                        }\n                    } while (read > 0);\n                }\n                Files.deleteIfExists(prevFlv);\n            }\n        }\n        dataChannel.position(0L);\n        int read;\n        do {\n            read = dataChannel.read(dst);\n            if (read > 0) {\n                dst.flip();\n                fileChannel.write(dst);\n                dst.compact();\n            }\n        } while (read > 0);\n        Files.deleteIfExists(Paths.get(filePath + \".ser\"));\n        return fileChannel.position();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.*;\nimport java.util.Map;\n\npublic class FLVWriter {\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset;\n    private Map<String, ?> meta;\n\n    public FLVWriter(String filePath) {\n        this.filePath = filePath;\n        this.append = false;\n        createOutputFile();\n    }\n\n    public FLVWriter(Path path, boolean append) {\n        this.filePath = path.toString();\n        this.append = append;\n        if (append) {\n            try {\n                meta = getMetaData(path, 10);\n                appendOffset = Files.size(path);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        createOutputFile();\n        createDataFile();\n    }\n\n    private Map<String, ?> getMetaData(Path path, int maxTags) {\n        // Implementation for extracting metadata\n        return null;\n    }\n\n    private void createDataFile() {\n        try {\n            Path tempPath = Files.createTempFile(\"flvdata\", \".tmp\");\n            dataChannel = FileChannel.open(tempPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void createOutputFile() {\n        try {\n            if (append) {\n                fileChannel = FileChannel.open(Paths.get(filePath), StandardOpenOption.APPEND);\n            } else {\n                fileChannel = FileChannel.open(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean writeTag(ITag tag) {\n        try {\n            ByteBuffer buffer = tag.toByteBuffer();\n            dataChannel.write(buffer);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void close() {\n        try {\n            finalizeFlv();\n            if (dataChannel != null) {\n                dataChannel.close();\n            }\n            if (fileChannel != null) {\n                fileChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private long finalizeFlv() {\n        try {\n            if (append) {\n                // Logic to combine temporary data with existing file\n            } else {\n                // Write final FLV header and tags\n            }\n            return 0;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n}"
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework for backup communication in a distributed system. The server should handle incoming UDP packets, decode them, and process messages while managing resources efficiently.\n\nClass Description: BackupServer is an AutoCloseable class that establishes a Netty-based UDP server for backup communication. It manages network connections, message handling, and graceful shutdown procedures.\n\nAttributes:\n- commonParameter: [CommonParameter] - Configuration parameters for the backup server\n- port: [int] - Port number to bind the UDP server\n- backupManager: [BackupManager] - Manager for backup operations\n- channel: [Channel] - Netty channel for UDP communication\n- shutdown: [boolean] - Flag indicating server shutdown status\n- executor: [ExecutorService] - Thread executor for server operations\n\nMethods:\n- initServer(): [void]() -> [void] - Initializes and starts the backup server in a separate thread if conditions are met\n- start(): [void]() throws [Exception] - Configures and starts the Netty UDP server with proper handlers\n- close(): [void]() -> [void] - Implements AutoCloseable to gracefully shutdown the server and release resources\n\nConstructor:\n- BackupServer([BackupManager backupManager]) - Creates a new instance with the specified BackupManager",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.common.backup.BackupManager;\nimport org.tron.common.es.ExecutorServiceManager;\nimport org.tron.common.parameter.CommonParameter;\nimport org.tron.p2p.stats.TrafficStats;\n\npublic class BackupServer implements AutoCloseable {\n\n  private CommonParameter commonParameter = CommonParameter.getInstance();\n  private int port = commonParameter.getBackupPort();\n  private BackupManager backupManager;\n  private Channel channel;\n  private volatile boolean shutdown = false;\n  private ExecutorService executor;\n\n  public BackupServer(final BackupManager backupManager) {\n    this.backupManager = backupManager;\n  }\n\n  public void initServer() {\n    if (port > 0 && commonParameter.getBackupMembers().size() > 0) {\n      executor = ExecutorServiceManager.newSingleThreadExecutor(\"BackupServer\");\n      executor.submit(() -> {\n        try {\n          start();\n        } catch (Exception e) {\n          logger.error(\"Start backup server failed, {}\", e);\n        }\n      });\n    }\n  }\n\n  private void start() throws Exception {\n    NioEventLoopGroup group = new NioEventLoopGroup(1);\n    try {\n      while (!shutdown) {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n            .channel(NioDatagramChannel.class)\n            .handler(new ChannelInitializer<NioDatagramChannel>() {\n              @Override\n              public void initChannel(NioDatagramChannel ch) throws Exception {\n                ch.pipeline().addLast(TrafficStats.udp);\n                ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());\n                ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());\n                ch.pipeline().addLast(new PacketDecoder());\n                MessageHandler messageHandler = new MessageHandler(ch, backupManager);\n                backupManager.setMessageHandler(messageHandler);\n                ch.pipeline().addLast(messageHandler);\n              }\n            });\n\n        channel = b.bind(port).sync().channel();\n        channel.closeFuture().sync();\n        if (shutdown) {\n          break;\n        }\n      }\n    } finally {\n      group.shutdownGracefully().sync();\n    }\n  }\n\n  @Override\n  public void close() {\n    shutdown = true;\n    backupManager.stop();\n    if (channel != null) {\n      try {\n        channel.close().await(10, TimeUnit.SECONDS);\n      } catch (Exception e) {\n        logger.warn(\"Closing backup server failed.\", e);\n      }\n    }\n    ExecutorServiceManager.shutdownAndAwaitTermination(executor, \"BackupServer\");\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioDatagramChannel;\nimport io.netty.handler.codec.MessageToMessageDecoder;\nimport io.netty.util.concurrent.DefaultThreadFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class BackupServer implements AutoCloseable {\n    private final CommonParameter commonParameter;\n    private final int port;\n    private final BackupManager backupManager;\n    private Channel channel;\n    private boolean shutdown = false;\n    private final ExecutorService executor;\n\n    public BackupServer(BackupManager backupManager) {\n        this.backupManager = backupManager;\n        this.commonParameter = backupManager.getCommonParameter();\n        this.port = commonParameter.getPort();\n        this.executor = Executors.newSingleThreadExecutor(new DefaultThreadFactory(\"BackupServer-Thread\"));\n    }\n\n    public void initServer() {\n        if (!shutdown) {\n            executor.submit(this::start);\n        }\n    }\n\n    public void start() throws Exception {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(Executors.newNioEventLoopGroup())\n                .channel(NioDatagramChannel.class)\n                .option(ChannelOption.SO_BROADCAST, true)\n                .handler(new ChannelInitializer<NioDatagramChannel>() {\n                    @Override\n                    protected void initChannel(NioDatagramChannel ch) {\n                        ch.pipeline().addLast(new MessageToMessageDecoder<ByteBuf>() {\n                            @Override\n                            protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {\n                                byte[] data = new byte[msg.readableBytes()];\n                                msg.readBytes(data);\n                                out.add(data);\n                            }\n                        });\n                        ch.pipeline().addLast(new SimpleChannelInboundHandler<byte[]>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, byte[] message) {\n                                try {\n                                    backupManager.processBackupMessage(message);\n                                } catch (Exception e) {\n                                    e.printStackTrace();\n                                }\n                            }\n                        });\n                    }\n                });\n\n        channel = bootstrap.bind(new InetSocketAddress(port)).sync().channel();\n        shutdown = false;\n    }\n\n    @Override\n    public void close() {\n        if (channel != null && !shutdown) {\n            shutdown = true;\n            channel.close().awaitUninterruptibly();\n            executor.shutdownNow();\n        }\n    }\n}"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework, with support for multiple transport types (NIO, Epoll, KQueue, IOUring) and graceful shutdown capabilities.\n\nClass Description: GeyserServer is a Netty-based UDP server implementation that handles network communication using the most optimal transport available on the system. It manages server lifecycle including binding to ports and graceful shutdown.\n\nAttributes:\n- TRANSPORT: [Transport] - Static final field holding the best available transport type\n- SHUTDOWN_QUIET_PERIOD_MS: [int] - Milliseconds to wait for quiet period during shutdown\n- SHUTDOWN_TIMEOUT_MS: [int] - Maximum milliseconds to wait for shutdown\n- geyser: [GeyserImpl] - Reference to the main Geyser implementation\n- group: [EventLoopGroup] - Parent event loop group for the server\n- childGroup: [EventLoopGroup] - Child event loop group for handling connections\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- playerGroup: [EventLoopGroup] - Event loop group for player connections\n- bootstrapFutures: [ChannelFuture[]] - Array of channel futures for server binding\n\nMethods:\n- GeyserServer([GeyserImpl geyser, int threadCount]) -> [void] - Constructor that initializes the server with specified thread count\n- bind([InetSocketAddress address]) -> [CompletableFuture<Void>] - Binds the server to the specified address and returns a future\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- createBootstrap() -> [ServerBootstrap] - Private method that creates and configures the server bootstrap\n- compatibleTransport() -> [Transport] - Static private method that detects the best available transport\n- isClassAvailable([String className]) -> [boolean] - Static private helper method to check class availability\n\nNested Types:\n- Transport: [record] - Holds transport-specific channel class and event loop group factory",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollDatagramChannel;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.kqueue.KQueue;\nimport io.netty.channel.kqueue.KQueueDatagramChannel;\nimport io.netty.channel.kqueue.KQueueEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUring;\nimport io.netty.incubator.channel.uring.IOUringDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUringEventLoopGroup;\nimport io.netty.util.concurrent.Future;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.IntFunction;\n\npublic final class GeyserServer {\n    private static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 100;\n    private static final int SHUTDOWN_TIMEOUT_MS = 500;\n\n    private final GeyserImpl geyser;\n    private EventLoopGroup group;\n    private EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private EventLoopGroup playerGroup;\n    private ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = TRANSPORT.eventLoopGroupFactory().apply(1);\n        this.childGroup = TRANSPORT.eventLoopGroupFactory().apply(threadCount);\n        this.bootstrap = this.createBootstrap();\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        bootstrapFutures = new ChannelFuture[1];\n        ChannelFuture future = bootstrap.bind(address);\n        bootstrapFutures[0] = future;\n        return Bootstraps.allOf(bootstrapFutures);\n    }\n\n    public void shutdown() {\n        try {\n            Future<?> futureChildGroup = this.childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.childGroup = null;\n            Future<?> futureGroup = this.group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.group = null;\n            Future<?> futurePlayerGroup = this.playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.playerGroup = null;\n\n            futureChildGroup.sync();\n            futureGroup.sync();\n            futurePlayerGroup.sync();\n        } catch (InterruptedException e) {\n            GeyserImpl.getInstance().getLogger().severe(\"Exception in shutdown process\", e);\n        }\n        for (ChannelFuture f : bootstrapFutures) {\n            f.channel().closeFuture().syncUninterruptibly();\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        GeyserServerInitializer serverInitializer = new GeyserServerInitializer(this.geyser);\n        playerGroup = serverInitializer.getEventLoopGroup();\n\n        return new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(TRANSPORT.datagramChannel()))\n                .group(group, childGroup)\n                .childHandler(serverInitializer);\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.incubator.channel.uring.IOUring\")\n                && IOUring.isAvailable()\n                && Boolean.parseBoolean(System.getProperty(\"Geyser.io_uring\"))) {\n            return new Transport(IOUringDatagramChannel.class, IOUringEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\") && Epoll.isAvailable()) {\n            return new Transport(EpollDatagramChannel.class, EpollEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\") && KQueue.isAvailable()) {\n            return new Transport(KQueueDatagramChannel.class, KQueueEventLoopGroup::new);\n        }\n\n        return new Transport(NioDatagramChannel.class, NioEventLoopGroup::new);\n    }\n\n    private record Transport(Class<? extends DatagramChannel> datagramChannel, IntFunction<EventLoopGroup> eventLoopGroupFactory) {\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollDatagramChannel;\nimport io.netty.channel.kqueue.KQueue;\nimport io.netty.channel.kqueue.KQueueDatagramChannel;\nimport io.netty.channel.nio.NioDatagramChannel;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.unix.DomainSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class GeyserServer {\n    public static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 1000;\n    private static final int SHUTDOWN_TIMEOUT_MS = 30000;\n    private final GeyserImpl geyser;\n    private final EventLoopGroup group;\n    private final EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private final EventLoopGroup playerGroup;\n    private final ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = new DefaultEventLoopGroup(threadCount);\n        this.childGroup = new DefaultEventLoopGroup(threadCount);\n        this.playerGroup = new DefaultEventLoopGroup(threadCount);\n        this.bootstrap = createBootstrap();\n        this.bootstrapFutures = new ChannelFuture[1];\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        bootstrap.bind(address).addListener((ChannelFutureListener) channelFuture -> {\n            if (channelFuture.isSuccess()) {\n                bootstrapFutures[0] = channelFuture;\n                future.complete(null);\n            } else {\n                future.completeExceptionally(channelFuture.cause());\n            }\n        });\n        return future;\n    }\n\n    public void shutdown() {\n        shutdownGroup(group, SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS);\n        shutdownGroup(childGroup, SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS);\n        shutdownGroup(playerGroup, SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS);\n        if (bootstrapFutures[0] != null) {\n            bootstrapFutures[0].channel().close();\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(group, childGroup)\n         .channel(TRANSPORT.channelClass())\n         .option(ChannelOption.SO_REUSEADDR, true)\n         .handler(new ChannelInitializer<DatagramChannel>() {\n             @Override\n             protected void initChannel(DatagramChannel ch) {\n                 ch.pipeline().addLast(geyser);\n             }\n         });\n        return b;\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\")) {\n            return new Transport(EpollDatagramChannel.class, Epoll::newDatagramChannel);\n        } else if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\")) {\n            return new Transport(KQueueDatagramChannel.class, KQueue::newDatagramChannel);\n        } else if (isClassAvailable(\"io.netty.channel.nio.NioDatagramChannel\")) {\n            return new Transport(NioDatagramChannel.class, NioEventLoopGroup::new);\n        } else {\n            return new Transport(DomainSocketChannel.class, DefaultEventLoopGroup::new);\n        }\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n\n    private static void shutdownGroup(EventLoopGroup group, int quietPeriod, int timeout) {\n        if (group == null) {\n            return;\n        }\n        group.shutdownGracefully(quietPeriod, timeout, TimeUnit.MILLISECONDS);\n    }\n\n    public record Transport(Class<? extends DatagramChannel> channelClass, EventLoopGroupFactory eventLoopGroupFactory) {\n        @FunctionalInterface\n        public interface EventLoopGroupFactory {\n            EventLoopGroup newGroup(int threads);\n        }\n    }\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class WidgetUtil {\n    private static final String WIDGET_URL = \"https://discord.com/api/guilds/%d/widget.json\";\n\n    public static Widget getWidget(long guildId) {\n        try {\n            String url = String.format(WIDGET_URL, guildId);\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                try (InputStream inputStream = connection.getInputStream()) {\n                    return new Gson().fromJson(new InputStreamReader(inputStream), Widget.class);\n                }\n            } else if (responseCode == 404) {\n                return null;\n            } else if (responseCode == 403) {\n                return null;\n            } else if (responseCode == 429) {\n                throw new RateLimitedException(\"Rate limited while fetching widget for guild: \" + guildId);\n            } else {\n                throw new UncheckedIOException(\"Unexpected HTTP response code: \" + responseCode + \" while fetching widget for guild: \" + guildId);\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"IO error while fetching widget for guild: \" + guildId, e);\n        }\n    }\n\n    public static class RateLimitedException extends RuntimeException {\n        public RateLimitedException(String message) {\n            super(message);\n        }\n    }\n\n    public static class UncheckedIOException extends RuntimeException {\n        public UncheckedIOException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    public static class Widget {\n        // Assume this class has appropriate fields and getters/setters\n    }\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh = false;\n\n    static {\n        // Initialize DNS resolver with fallback\n        fallbackDNS = new FallBackDNS();\n\n        // Configure HTTP client without cache\n        httpClient = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .proxy(Proxy.NO_PROXY)\n                .dns(fallbackDNS)\n                .followRedirects(true)\n                .build();\n\n        // Configure HTTP client with DoH support\n        httpClientDoH = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .proxy(Proxy.NO_PROXY)\n                .dns(new DnsOverHttps(fallbackDNS))\n                .followRedirects(true)\n                .build();\n\n        // Configure HTTP client with caching\n        httpClientWithCache = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .proxy(Proxy.NO_PROXY)\n                .dns(fallbackDNS)\n                .cache(new Cache(new File(System.getProperty(\"java.io.tmpdir\"), \"http-cache\"), 10 * 1024 * 1024))\n                .followRedirects(true)\n                .build();\n\n        // Configure HTTP client with both caching and DoH\n        httpClientWithCacheDoH = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .proxy(Proxy.NO_PROXY)\n                .dns(new DnsOverHttps(fallbackDNS))\n                .cache(new Cache(new File(System.getProperty(\"java.io.tmpdir\"), \"http-cache-doh\"), 10 * 1024 * 1024))\n                .followRedirects(true)\n                .build();\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        Request request = new Request.Builder().url(url).build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            return response.body().bytes();\n        }\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        RequestBody body = new JsonRequestBody(data);\n        Request request = new Request.Builder().url(url).post(body).build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            return response.body().bytes();\n        }\n    }\n\n    public static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        builder.followRedirects(followRedirects);\n        return builder;\n    }\n\n    public static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        // Implementation for checking if Androidacy URL requires a CAPTCHA\n    }\n\n    public static class JsonRequestBody extends RequestBody {\n        private final String json;\n\n        public JsonRequestBody(String json) {\n            this.json = json;\n        }\n\n        @Override\n        public MediaType contentType() {\n            return MediaType.get(\"application/json; charset=utf-8\");\n        }\n\n        @Override\n        public long contentLength() throws IOException {\n            return json.getBytes(\"UTF-8\").length;\n        }\n\n        @Override\n        public void writeTo(BufferedSink sink) throws IOException {\n            sink.write(json.getBytes(\"UTF-8\"));\n        }\n    }\n\n    private static class FallBackDNS implements Dns {\n        @Override\n        public List<InetAddress> lookup(String hostname) throws UnknownHostException {\n            try {\n                return InetAddress.getAllByName(hostname);\n            } catch (UnknownHostException e) {\n                return fallbackDNS.lookup(hostname);\n            }\n        }\n    }\n\n    private static class DnsOverHttps implements Dns {\n        private final Dns fallbackDns;\n\n        public DnsOverHttps(Dns fallbackDns) {\n            this.fallbackDns = fallbackDns;\n        }\n\n        @Override\n        public List<InetAddress> lookup(String hostname) throws UnknownHostException {\n            try {\n                // Simulate DoH by using fallback DNS for demonstration purposes\n                return fallbackDns.lookup(hostname);\n            } catch (UnknownHostException e) {\n                return fallbackDns.lookup(hostname);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport org.apache.hadoop.conf.Configuration;\nimport org.slf4j.Logger;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class VaultClient implements KmsClient {\n    private static final Logger LOG = org.slf4j.LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper;\n    private final String kmsToken;\n    private final Configuration hadoopConfiguration;\n    private final String endPointPrefix;\n    private final OkHttpClient httpClient;\n\n    public VaultClient(ObjectMapper objectMapper, String kmsToken, Configuration hadoopConfiguration, String endPointPrefix, OkHttpClient httpClient) {\n        this.objectMapper = objectMapper;\n        this.kmsToken = kmsToken;\n        this.hadoopConfiguration = hadoopConfiguration;\n        this.endPointPrefix = endPointPrefix;\n        this.httpClient = httpClient;\n    }\n\n    private String getContentFromTransitEngine(String payload, String path, String masterKeyId) throws IOException {\n        RequestBody body = RequestBody.create(payload, JSON_MEDIA_TYPE);\n        Request request = new Request.Builder()\n                .url(endPointPrefix + path)\n                .header(\"X-Vault-Token\", kmsToken)\n                .header(\"Content-Type\", \"application/json\")\n                .post(body)\n                .build();\n        return executeAndGetResponse(masterKeyId, request);\n    }\n\n    private String executeAndGetResponse(String masterKeyId, Request request) throws IOException {\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            String responseBody = response.body().string();\n            return parseReturn(masterKeyId, responseBody);\n        } catch (IOException e) {\n            LOG.error(\"Error executing request to Vault: {}\", e.getMessage());\n            throw e;\n        }\n    }\n\n    private String buildPayload(Map<String, String> parameters) throws IOException {\n        return objectMapper.writeValueAsString(parameters);\n    }\n\n    @Override\n    public String wrapKey(byte[] keyBytes, String masterKeyId) throws IOException {\n        Map<String, String> payload = Map.of(\"plaintext\", Base64.getEncoder().encodeToString(keyBytes));\n        String jsonPayload = buildPayload(payload);\n        return getContentFromTransitEngine(jsonPayload, \"/v1/transit/encrypt/\" + masterKeyId, masterKeyId);\n    }\n\n    @Override\n    public byte[] unwrapKey(String wrappedKey, String masterKeyId) throws IOException {\n        Map<String, String> payload = Map.of(\"ciphertext\", wrappedKey);\n        String jsonPayload = buildPayload(payload);\n        String response = getContentFromTransitEngine(jsonPayload, \"/v1/transit/decrypt/\" + masterKeyId, masterKeyId);\n        return Base64.getDecoder().decode(parseReturn(masterKeyId, response));\n    }\n\n    private String parseReturn(String masterKeyId, String responseBody) {\n        try {\n            JsonNode jsonNode = objectMapper.readTree(responseBody);\n            JsonNode dataNode = jsonNode.path(\"data\");\n            return dataNode.path(\"ciphertext\").asText();\n        } catch (IOException e) {\n            LOG.error(\"Error parsing response from Vault for master key {}: {}\", masterKeyId, e.getMessage());\n            throw new RuntimeException(\"Failed to parse response from Vault\", e);\n        }\n    }\n\n    public void refreshToken() {\n        // Implementation not shown\n    }\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport okhttp3.*;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class GraphHopperGeocoding {\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl = \"https://graphhopper.com/api/1/geocode\";\n    private String key;\n    private static final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this.objectMapper = new ObjectMapper();\n        this.downloader = new OkHttpClient.Builder()\n                .connectTimeout(DEFAULT_TIMEOUT, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .readTimeout(DEFAULT_TIMEOUT, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .writeTimeout(DEFAULT_TIMEOUT, java.util.concurrent.TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this();\n        this.routeServiceUrl = serviceUrl;\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        Request httpRequest = new Request.Builder().url(url).build();\n\n        try (Response response = downloader.newCall(httpRequest).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            String responseBody = response.body().string();\n            JsonObject json = JsonParser.parseString(responseBody).getAsJsonObject();\n            return new GHGeocodingResponse(json);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Geocoding failed: \" + e.getMessage(), e);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    protected OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        return downloader.newBuilder().build();\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        StringBuilder urlBuilder = new StringBuilder(routeServiceUrl);\n        urlBuilder.append(\"?\");\n\n        if (request.getQuery() != null) {\n            urlBuilder.append(\"q=\").append(encodeURL(request.getQuery()));\n        }\n\n        if (request.getLatitude() != null && request.getLongitude() != null) {\n            urlBuilder.append(\"&lat=\").append(request.getLatitude()).append(\"&lon=\").append(request.getLongitude());\n        }\n\n        if (request.getLocale() != null) {\n            urlBuilder.append(\"&locale=\").append(request.getLocale());\n        }\n\n        if (request.getLimit() != null) {\n            urlBuilder.append(\"&limit=\").append(request.getLimit());\n        }\n\n        if (key != null) {\n            urlBuilder.append(\"&key=\").append(key);\n        }\n\n        return urlBuilder.toString();\n    }\n\n    private String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, StandardCharsets.UTF_8.toString());\n        } catch (Exception e) {\n            return str;\n        }\n    }\n}\n\nclass GHGeocodingRequest {\n    private String query;\n    private Double latitude;\n    private Double longitude;\n    private String locale;\n    private Integer limit;\n\n    public String getQuery() {\n        return query;\n    }\n\n    public GHGeocodingRequest setQuery(String query) {\n        this.query = query;\n        return this;\n    }\n\n    public Double getLatitude() {\n        return latitude;\n    }\n\n    public GHGeocodingRequest setLatitude(Double latitude) {\n        this.latitude = latitude;\n        return this;\n    }\n\n    public Double getLongitude() {\n        return longitude;\n    }\n\n    public GHGeocodingRequest setLongitude(Double longitude) {\n        this.longitude = longitude;\n        return this;\n    }\n\n    public String getLocale() {\n        return locale;\n    }\n\n    public GHGeocodingRequest setLocale(String locale) {\n        this.locale = locale;\n        return this;\n    }\n\n    public Integer getLimit() {\n        return limit;\n    }\n\n    public GHGeocodingRequest setLimit(Integer limit) {\n        this.limit = limit;\n        return this;\n    }\n}\n\nclass GHGeocodingResponse {\n    private JsonObject json;\n\n    public GHGeocodingResponse(JsonObject json) {\n        this.json = json;\n    }\n\n    public JsonObject getJson() {\n        return json;\n    }\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.net.URL;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport org.json.JSONObject;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"https://danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private final Pattern gidPattern;\n    private int currentPageNum;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n        this.gidPattern = Pattern.compile(\"tags/(.*?)/\");\n        this.currentPageNum = 1;\n    }\n\n    public JSONObject getPage(int pageNum) throws Exception {\n        String url = DOMAIN + \"/posts.json?page=\" + pageNum;\n        Request request = new Request.Builder().url(url).build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new Exception(\"Unexpected code \" + response);\n            }\n            String responseBody = response.body().string();\n            return new JSONObject(responseBody);\n        }\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        return null; // Implementation not provided\n    }\n\n    public String getTagFromUrl(URL url) throws java.net.MalformedURLException {\n        String path = url.getPath();\n        java.util.regex.Matcher matcher = gidPattern.matcher(path);\n        if (matcher.find()) {\n            return matcher.group(1);\n        } else {\n            throw new java.net.MalformedURLException(\"Invalid URL format: \" + url);\n        }\n    }\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private final OkHttpClient client;\n    private final UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient() {\n        this.client = new OkHttpClient();\n        this.urlValidator = new UrlValidator(new String[]{\"http\", \"https\"});\n    }\n\n    public void setBaseUrl(String url) {\n        if (urlValidator.isValid(url)) {\n            this.expandBaseUrl = url + \"/ValueSet/$expand\";\n        } else {\n            throw new IllegalArgumentException(\"Invalid URL format\");\n        }\n    }\n\n    public Response expandValueSet(String valueSetUri) {\n        if (valueSetUri == null || valueSetUri.isEmpty()) {\n            throw new IllegalArgumentException(\"Value set URI cannot be null or empty\");\n        }\n\n        String url = expandBaseUrl + \"?url=\" + valueSetUri;\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        try {\n            return client.newCall(request).execute();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error expanding value set: \" + e.getMessage(), e);\n        }\n    }\n}"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) {\n        return executeRequest(\"https://api.github.com/copilot-token\", \"POST\", \"{\\\"apiKey\\\": \\\"\" + apiKey + \"\\\"}\", createHeaders(null)).body().string();\n    }\n\n    public String getCoCoToken(String apiKey) {\n        return executeRequest(\"https://api.cocopilot.ai/token\", \"POST\", \"{\\\"apiKey\\\": \\\"\" + apiKey + \"\\\"}\", createHeaders(null)).body().string();\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, body == null ? null : RequestBody.create(body, MediaType.get(\"application/json; charset=utf-8\")));\n\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                requestBuilder.addHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        Request request = requestBuilder.build();\n        return client.newCall(request).execute();\n    }\n\n    private Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"User-Agent\", \"ApiClient/1.0\");\n        headers.put(\"X-Machine-Id\", machineId);\n        if (chatToken != null) {\n            headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        }\n        return headers;\n    }\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests to a RESTful API using the OkHttp client library, with support for both GET and POST methods, including timeout configuration and proper resource cleanup.\n\nClass Description: GHMatrixBatchRequester is a utility class designed to make HTTP requests to a GraphHopper matrix API. It provides methods for sending GET and POST requests, handles response processing, and includes timeout configurations for network operations.\n\nAttributes:\n- logger: Logger - Used for logging debug and error information\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Constructor: GHMatrixBatchRequester() -> void - Initializes the HTTP client with default timeout settings (5 seconds for connect and read)\n- Constructor: GHMatrixBatchRequester(OkHttpClient) -> void - Allows injection of a custom configured OkHttpClient instance\n- getJson: getJson(String url) -> JsonResult - Sends a GET request to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers\n- postJson: postJson(String url, JsonNode requestJson) -> JsonResult - Sends a POST request with JSON payload to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    protected JsonResult getJson(String url) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n\n    protected JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .post(createRequestBody(requestJson))\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport com.fasterxml.jackson.databind.JsonNode;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class GHMatrixBatchRequester {\n    private static final Logger logger = LogManager.getLogger(GHMatrixBatchRequester.class);\n    private final OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this(new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .writeTimeout(5, TimeUnit.SECONDS)\n                .build());\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    public JsonResult getJson(String url) {\n        Request request = new Request.Builder().url(url).build();\n        return executeRequest(request);\n    }\n\n    public JsonResult postJson(String url, JsonNode requestJson) {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        String json = requestJson.toString();\n        RequestBody body = RequestBody.create(json, JSON);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n        return executeRequest(request);\n    }\n\n    private JsonResult executeRequest(Request request) {\n        Response response = null;\n        try {\n            response = client.newCall(request).execute();\n            if (!response.isSuccessful()) {\n                logger.warn(\"Unsuccessful HTTP response: {}\", response.code());\n            }\n            return new JsonResult(response.body().string(), response.code(), response.headers());\n        } catch (IOException e) {\n            logger.error(\"IOException occurred during HTTP request\", e);\n            return new JsonResult(null, -1, null);\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n    }\n\n    public static class JsonResult {\n        private final String responseBody;\n        private final int statusCode;\n        private final Headers headers;\n\n        public JsonResult(String responseBody, int statusCode, Headers headers) {\n            this.responseBody = responseBody;\n            this.statusCode = statusCode;\n            this.headers = headers;\n        }\n\n        public String getResponseBody() {\n            return responseBody;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public Headers getHeaders() {\n            return headers;\n        }\n    }\n}"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: Create a Java class that implements a web scraper using the OkHttp library to make HTTP requests, handle authentication, and process responses with retry logic for failed attempts.\n\nClass Description: The Scraper class provides functionality to scrape content from web URLs using HTTP requests. It supports basic authentication and includes timeout handling with retry logic for failed requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Scraper() -> None - Constructor that initializes the OkHttpClient instance\n- scrape(String url, long timeoutMillis) -> List<String> - Scrapes content from the given URL without authentication, with a specified timeout\n- scrape(String url, String user, String password, long timeoutMillis) -> List<String> - Scrapes content from the given URL with basic authentication, with a specified timeout",
    "Canonical_solution": "import okhttp3.Credentials;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Scraper {\n\n    private OkHttpClient client;\n    \n    public Scraper() {\n        this.client = new OkHttpClient();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        return scrape(url, null, null, timeoutMillis);\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        long start = System.currentTimeMillis();\n        Exception exception = null;\n        while (System.currentTimeMillis() - start < timeoutMillis) {\n            try {\n                Request.Builder requestBuilder = new Request.Builder()\n                        .header(\"Accept\", \"application/openmetrics-text; version=1.0.0; charset=utf-8\")\n                        .url(url);\n                if (user != null && password != null) {\n                    requestBuilder.header(\"Authorization\", Credentials.basic(user, password));\n                }\n                Request request = requestBuilder.build();\n                try (Response response = client.newCall(request).execute()) {\n                    if (response.code() != 200) {\n                        throw new IOException(\"Received HTTP Status \" + response.code() + \": \" + response.body().string());\n                    }\n                    return Arrays.asList(response.body().string().split(\"\\\\n\"));\n                }\n            } catch (Exception e) {\n                exception = e;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n        if (exception != null) {\n            exception.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport okhttp3.Authenticator;\nimport okhttp3.Credentials;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.Route;\n\npublic class Scraper {\n    private final OkHttpClient client;\n\n    public Scraper() {\n        this.client = new OkHttpClient.Builder()\n                .authenticator(new Authenticator() {\n                    @Override\n                    public Request authenticate(Route route, Response response) throws IOException {\n                        String credential = Credentials.basic(\"user\", \"password\");\n                        return response.request().newBuilder()\n                                .header(\"Authorization\", credential)\n                                .build();\n                    }\n                })\n                .retryOnConnectionFailure(true)\n                .build();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        return sendRequest(url, timeoutMillis, null, null);\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        OkHttpClient authClient = new OkHttpClient.Builder()\n                .authenticator(new Authenticator() {\n                    @Override\n                    public Request authenticate(Route route, Response response) throws IOException {\n                        String credential = Credentials.basic(user, password);\n                        return response.request().newBuilder()\n                                .header(\"Authorization\", credential)\n                                .build();\n                    }\n                })\n                .retryOnConnectionFailure(true)\n                .build();\n        return sendRequest(url, timeoutMillis, authClient, null);\n    }\n\n    private List<String> sendRequest(String url, long timeoutMillis, OkHttpClient client, Integer maxRetries) {\n        List<String> result = new ArrayList<>();\n        int retryCount = 0;\n        while (retryCount <= (maxRetries != null ? maxRetries : 3)) {\n            try {\n                Request request = new Request.Builder()\n                        .url(url)\n                        .timeout(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS)\n                        .build();\n                Response response = client.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    String body = response.body().string();\n                    result.add(body);\n                    return result;\n                } else {\n                    retryCount++;\n                }\n            } catch (IOException e) {\n                retryCount++;\n            }\n        }\n        return result;\n    }\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "import org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ExecutionContext;\n\nimport java.time.Duration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class KafkaItemReader<K, V> implements ItemReader<V> {\n    public static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    public static final long DEFAULT_POLL_TIMEOUT = 30000;\n    private List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets = new ConcurrentHashMap<>();\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofMillis(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState;\n\n    public KafkaItemReader(Properties consumerProperties, String topic, Integer... partitions) {\n        this.consumerProperties = consumerProperties;\n        this.topicPartitions = createTopicPartitions(topic, partitions);\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, List<Integer> partitions) {\n        this.consumerProperties = consumerProperties;\n        this.topicPartitions = createTopicPartitions(topic, partitions);\n    }\n\n    private List<TopicPartition> createTopicPartitions(String topic, Integer[] partitions) {\n        // Implementation to create TopicPartition list\n        return null;\n    }\n\n    private List<TopicPartition> createTopicPartitions(String topic, List<Integer> partitions) {\n        // Implementation to create TopicPartition list\n        return null;\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        kafkaConsumer = new KafkaConsumer<>(consumerProperties);\n        kafkaConsumer.subscribe(topicPartitions);\n        if (executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            @SuppressWarnings(\"unchecked\")\n            Map<TopicPartition, Long> storedOffsets = (Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS);\n            partitionOffsets.putAll(storedOffsets);\n            for (Map.Entry<TopicPartition, Long> entry : partitionOffsets.entrySet()) {\n                kafkaConsumer.seek(entry.getKey(), entry.getValue());\n            }\n        }\n        poll();\n    }\n\n    @Override\n    public V read() {\n        if (consumerRecords == null || !consumerRecords.hasNext()) {\n            poll();\n        }\n        if (consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = consumerRecords.next();\n            return record.value();\n        }\n        return null;\n    }\n\n    private void poll() {\n        consumerRecords = kafkaConsumer.poll(pollTimeout).iterator();\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (saveState) {\n            Map<TopicPartition, Long> currentOffsets = kafkaConsumer.committed(topicPartitions);\n            executionContext.put(TOPIC_PARTITION_OFFSETS, currentOffsets);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (kafkaConsumer != null) {\n            kafkaConsumer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaSink<T> implements Sink<Observable<T>> {\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef;\n    private Subscription subscription;\n\n    public KafkaSink(Func1<T, byte[]> encoder, Registry registry) {\n        this.encoder = encoder;\n        this.registry = registry;\n        this.kafkaProducerAtomicRef = new AtomicReference<>();\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.get();\n        if (producer == null) {\n            Properties props = new Properties();\n            props.put(\"bootstrap.servers\", \"localhost:9092\");\n            props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n            props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n            producer = new KafkaProducer<>(props);\n            kafkaProducerAtomicRef.set(producer);\n        }\n\n        subscription = dataO.subscribe(item -> {\n            byte[] key = \"key\".getBytes();\n            byte[] value = encoder.call(item);\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(\"default-topic\", key, value);\n            producer.send(record);\n        });\n    }\n\n    public List<ParameterDefinition<?>> getParameters() {\n        List<ParameterDefinition<?>> parameters = new ArrayList<>();\n        parameters.add(new ParameterDefinition<>(\"kafka.bootstrap.servers\", String.class, \"localhost:9092\", \"Kafka bootstrap servers\"));\n        parameters.add(new ParameterDefinition<>(\"kafka.topic\", String.class, \"default-topic\", \"Kafka topic name\"));\n        return parameters;\n    }\n\n    @Override\n    public Metadata metadata() {\n        return new Metadata(\"KafkaSink\", \"Writes data to a Kafka topic\");\n    }\n\n    @Override\n    public void close() {\n        Subscription sub = subscription;\n        if (sub != null) {\n            sub.unsubscribe();\n        }\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.getAndSet(null);\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.slf4j.Logger;\n\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.TimeUnit;\n\npublic class KafkaSampleProducer {\n    public static final long PRODUCER_CLOSE_TIMEOUT = 30;\n    private boolean _shutdown = false;\n    private Producer<byte[], byte[]> _producer;\n\n    public void createProducer(Map<String, Object> config, String producerClientId) {\n        config.put(\"client.id\", producerClientId);\n        _producer = new KafkaProducer<>(config);\n    }\n\n    public AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log) {\n        AtomicInteger successCount = new AtomicInteger(0);\n        for (MetricSampler.Sample sample : samples.getSamples()) {\n            try {\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(partitionMetricSampleStoreTopic, sample.getKey().getBytes(), sample.getValue().getBytes());\n                RecordMetadata metadata = producer.send(record).get();\n                successCount.incrementAndGet();\n                log.info(\"Sent sample to topic: {} partition: {} offset: {}\", metadata.topic(), metadata.partition(), metadata.offset());\n            } catch (Exception e) {\n                log.error(\"Failed to send sample: {}\", sample, e);\n            }\n        }\n        return successCount;\n    }\n\n    public void close() {\n        if (!_shutdown) {\n            try {\n                _producer.close(PRODUCER_CLOSE_TIMEOUT, TimeUnit.SECONDS);\n            } catch (Exception e) {\n                // Handle exception during shutdown\n            } finally {\n                _shutdown = true;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class KafkaTemplate<K, V> {\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush, boolean transactional) {\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = transactional;\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return doSend(new ProducerRecord<>(topic, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, partition, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> producerRecord) {\n        Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        ProducerCallback<K, V> callback = new ProducerCallback<>();\n        producer.send(producerRecord, callback);\n        if (autoFlush) {\n            producer.flush();\n        }\n        return callback.getFuture();\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer(topic);\n        return producer.partitionsFor(topic);\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        return producer.metrics();\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.createProducer();\n    }\n\n    protected boolean inTransaction() {\n        return transactional;\n    }\n\n    private static class ProducerCallback<K, V> implements Callback {\n        private final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n\n        @Override\n        public void onCompletion(RecordMetadata metadata, Exception exception) {\n            if (exception != null) {\n                future.completeExceptionally(exception);\n            } else {\n                future.complete(new SendResult<>(metadata, null));\n            }\n        }\n\n        public CompletableFuture<SendResult<K, V>> getFuture() {\n            return future;\n        }\n    }\n}"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class JobPrefixFile implements AutoCloseable {\n    private final String prefix;\n    private final Path file;\n    private FileChannel channel;\n    private FileLock lock;\n\n    private JobPrefixFile(String prefix, Path file) {\n        this.prefix = prefix;\n        this.file = file;\n    }\n\n    public static JobPrefixFile create(Path directory) {\n        return create(\"job-\", directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) {\n        try {\n            Path file = directory.resolve(prefix + System.currentTimeMillis() + \".tmp\");\n            Files.createFile(file);\n            FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE);\n            FileLock lock = channel.tryLock();\n            if (lock == null) {\n                throw new IOException(\"Could not lock file: \" + file);\n            }\n            return new JobPrefixFile(prefix, file).withChannelAndLock(channel, lock);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create JobPrefixFile\", e);\n        }\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) {\n        try {\n            FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE);\n            FileLock lock = channel.tryLock();\n            if (lock == null) {\n                throw new IOException(\"Could not lock existing file: \" + file);\n            }\n            String prefix = file.getFileName().toString().replaceFirst(\"\\\\d+\\\\.tmp$\", \"\");\n            return new JobPrefixFile(prefix, file).withChannelAndLock(channel, lock);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create JobPrefixFile from existing file\", e);\n        }\n    }\n\n    private JobPrefixFile withChannelAndLock(FileChannel channel, FileLock lock) {\n        this.channel = channel;\n        this.lock = lock;\n        return this;\n    }\n\n    public void delete() {\n        release();\n        deleteIfExists(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() {\n        close(lock);\n        close(channel);\n    }\n\n    @Override\n    public void close() {\n        release();\n    }\n\n    private static void deleteIfExists(Path file) {\n        try {\n            Files.deleteIfExists(file);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to delete file: \" + file, e);\n        }\n    }\n\n    private static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to close resource\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\n\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private final KafkaProducer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n\n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        ProducerRecord<String, MaintenancePlan> record = new ProducerRecord<>(topic, maintenancePlan);\n        _producer.send(record);\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaProducerWrapper<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a Java class that manages non-blocking HTTP connections using Java NIO (New I/O) capabilities. The class should handle connection establishment, connection queue management, and distribute connections across multiple processors for load balancing.\n\nClass Description: NIOConnector is a thread-based class that manages asynchronous HTTP connections using Java NIO. It maintains a queue of pending connections, establishes them asynchronously, and distributes successfully established connections to a pool of NIOProcessor instances for further processing.\n\nAttributes:\n- name: String - The name identifier for this connector thread\n- selector: Selector - The NIO selector used for monitoring connection events\n- connectQueue: BlockingQueue<BackendConnection> - Queue holding pending connection requests\n- processors: NIOProcessor[] - Array of processors for handling established connections\n- nextProcessor: int - Index for round-robin processor selection\n- connectCount: long - Counter for tracking connection attempts\n\nMethods:\n- NIOConnector(String name) -> void - Constructor that initializes the connector with a name and opens a new selector\n- setProcessors(NIOProcessor[] processors) -> void - Sets the array of processors for connection distribution\n- postConnect(BackendConnection c) -> void - Adds a new connection request to the queue and wakes up the selector\n- run() -> void - Main thread loop that handles connection establishment and event processing\n- connect(Selector selector) -> void - Processes pending connections from the queue\n- finishConnect(SelectionKey key, Object att) -> void - Completes the connection process for a channel\n- clearSelectionKey(SelectionKey key) -> void - Cleans up a selection key after processing\n- nextProcessor() -> NIOProcessor - Selects the next processor in round-robin fashion\n\nInner Class:\n- ConnectIdGenerator - Generates unique IDs for established connections with thread-safe incrementing",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOConnector extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOConnector.class);\n    private static final ConnectIdGenerator ID_GENERATOR = new ConnectIdGenerator();\n\n    private final String name;\n    private final Selector selector;\n    private final BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n    public NIOConnector(String name) throws IOException {\n        super.setName(name);\n        this.name = name;\n        this.selector = Selector.open();\n        this.connectQueue = new LinkedBlockingQueue<BackendConnection>();\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.offer(c);\n        selector.wakeup();\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++connectCount;\n            try {\n                selector.select(1000L);\n                connect(selector);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        Object att = key.attachment();\n                        if (att != null && key.isValid() && key.isConnectable()) {\n                            finishConnect(key, att);\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(name, e);\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        BackendConnection c = null;\n        while ((c = connectQueue.poll()) != null) {\n            try {\n                c.connect(selector);\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_CONNECT_SOCKET, e);\n            }\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection c = (BackendConnection) att;\n        try {\n            if (c.finishConnect()) {\n                clearSelectionKey(key);\n                c.setId(ID_GENERATOR.getId());\n                NIOProcessor processor = nextProcessor();\n                c.setProcessor(processor);\n                processor.postRegister(c);\n            }\n        } catch (Throwable e) {\n            clearSelectionKey(key);\n            c.error(ErrorCode.ERR_FINISH_CONNECT, e);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        if (key.isValid()) {\n            key.attach(null);\n            key.cancel();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static class ConnectIdGenerator {\n        private static final long MAX_VALUE = Long.MAX_VALUE;\n        private long connectId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (connectId >= MAX_VALUE) {\n                    connectId = 0L;\n                }\n                return ++connectId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 20,
    "wrong_result": "public class NIOConnector extends Thread {\n    private final String name;\n    private final Selector selector;\n    private final BlockingQueue<BackendConnection> connectQueue;\n    private final NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n    public NIOConnector(String name) {\n        this.name = name;\n        this.selector = null;\n        this.connectQueue = new LinkedBlockingQueue<>();\n        this.processors = null;\n        this.nextProcessor = 0;\n        this.connectCount = 0;\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        try {\n            connectQueue.put(c);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        selector.wakeup();\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!isInterrupted()) {\n                connect();\n                selector.select();\n                Set<SelectionKey> keys = selector.selectedKeys();\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    iter.remove();\n                    if (key.isConnectable()) {\n                        finishConnect(key, key.attachment());\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                selector.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        try {\n            while (!connectQueue.isEmpty()) {\n                BackendConnection connection = connectQueue.poll();\n                if (connection != null) {\n                    SocketChannel channel = SocketChannel.open();\n                    channel.configureBlocking(false);\n                    channel.connect(connection.getAddress());\n                    SelectionKey key = channel.register(selector, SelectionKey.OP_CONNECT);\n                    key.attach(connection);\n                    connectCount++;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection connection = (BackendConnection) att;\n        SocketChannel channel = (SocketChannel) key.channel();\n        try {\n            if (channel.finishConnect()) {\n                key.interestOps(0);\n                clearSelectionKey(key);\n                NIOProcessor processor = nextProcessor();\n                processor.handleConnection(connection, channel);\n            } else {\n                connection.fail(\"Connection failed\");\n                clearSelectionKey(key);\n            }\n        } catch (IOException e) {\n            connection.fail(\"Connection failed: \" + e.getMessage());\n            clearSelectionKey(key);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        key.cancel();\n        try {\n            key.channel().close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n    public static class ConnectIdGenerator {\n        private static final AtomicLong idCounter = new AtomicLong(0);\n\n        public static long generateId() {\n            return idCounter.incrementAndGet();\n        }\n    }\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic abstract class RpcServer {\n    protected final Logger logger;\n    protected ServerBootstrap bootstrap;\n    protected ChannelFuture channelFuture;\n    protected final ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>();\n    protected final EventLoopGroup bossGroup;\n    protected final EventLoopGroup workerGroup;\n    protected final RemotingAddressParser addressParser;\n    protected final DefaultServerConnectionManager connectionManager;\n    protected final RpcRemoting rpcRemoting;\n    protected final Codec codec;\n    protected int port;\n    protected boolean manageConnection;\n\n    public RpcServer(int port, boolean manageConnection) {\n        this.port = port;\n        this.manageConnection = manageConnection;\n        this.logger = LoggerFactory.getLogger(RpcServer.class);\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.addressParser = new RemotingAddressParser();\n        this.connectionManager = new DefaultServerConnectionManager();\n        this.rpcRemoting = new RpcRemoting();\n        this.codec = new Codec();\n    }\n\n    protected void doInit() {\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(codec);\n                        pipeline.addLast(rpcRemoting);\n                    }\n                });\n    }\n\n    public boolean doStart() {\n        try {\n            channelFuture = bootstrap.bind(port).sync();\n            logger.info(\"RPC server started on port {}\", port);\n            return true;\n        } catch (InterruptedException e) {\n            logger.error(\"Failed to start RPC server\", e);\n            return false;\n        }\n    }\n\n    public boolean doStop() {\n        try {\n            if (channelFuture != null) {\n                channelFuture.channel().closeFuture().sync();\n            }\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            logger.info(\"RPC server stopped\");\n            return true;\n        } catch (InterruptedException e) {\n            logger.error(\"Failed to stop RPC server\", e);\n            return false;\n        }\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        userProcessors.put(processor.getCommand(), processor);\n    }\n\n    public Object invokeSync(Connection conn, Object request, int timeoutMillis) {\n        try {\n            ChannelFuture future = conn.getChannel().writeAndFlush(request);\n            return future.await(timeoutMillis, TimeUnit.MILLISECONDS).getNow(null);\n        } catch (Exception e) {\n            logger.error(\"RPC invocation failed\", e);\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class Deobfuscator {\n    public static String deobfuscate(Throwable t) {\n        if (!canDeobfuscate()) {\n            return getStackTrace(t);\n        }\n\n        String mappingPath = System.getenv(\"XPIPE_MAPPING\");\n        if (mappingPath == null || mappingPath.isEmpty()) {\n            return getStackTrace(t);\n        }\n\n        try {\n            String inputStackTrace = getStackTrace(t);\n            Path tempInputFile = Files.createTempFile(\"stacktrace\", \".txt\");\n            Files.write(tempInputFile, inputStackTrace.getBytes());\n\n            ProcessBuilder processBuilder;\n            if (isWindows()) {\n                processBuilder = new ProcessBuilder(\"retrace.bat\", mappingPath, tempInputFile.toString());\n            } else {\n                processBuilder = new ProcessBuilder(\"retrace.sh\", mappingPath, tempInputFile.toString());\n            }\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                return getStackTrace(t);\n            }\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n\n            return output.toString().trim();\n        } catch (Exception e) {\n            return getStackTrace(t);\n        }\n    }\n\n    private static boolean isWindows() {\n        return System.getProperty(\"os.name\").toLowerCase().contains(\"win\");\n    }\n\n    private static String getStackTrace(Throwable t) {\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        t.printStackTrace(pw);\n        return sw.toString();\n    }\n\n    private static boolean canDeobfuscate() {\n        // Implementation not shown\n        return true;\n    }\n}"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\n\npublic class FileReader extends Reader {\n    private InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        boolean success = false;\n        try {\n            File f = new File(file);\n            if (f.exists() && f.canRead()) {\n                mStream = new InputStreamReader(new FileInputStream(f));\n                success = true;\n            } else {\n                ProcessBuilder pb = new ProcessBuilder();\n                if (shell != null) {\n                    String command = shell.findCommand(\"cat\");\n                    if (command != null) {\n                        pb.command(command, file);\n                    } else {\n                        pb.command(\"toolbox\", \"cat\", file);\n                    }\n                } else {\n                    pb.command(\"cat\", file);\n                }\n                Process process = pb.start();\n                mStream = new InputStreamReader(process.getInputStream());\n                success = true;\n            }\n        } catch (IOException e) {\n            throw new FileNotFoundException(\"Unable to read file: \" + file);\n        } finally {\n            if (!success) {\n                throw new FileNotFoundException(\"Unable to read file: \" + file);\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mStream != null) {\n            mStream.close();\n        }\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class ProcessShell extends AbstractShell {\n    protected Process mProcess;\n    protected DataOutputStream mCommandOutputStream;\n    protected BufferedReader mSucceedReader;\n    protected BufferedReader mErrorReader;\n    protected StringBuilder mSucceedOutput;\n    protected StringBuilder mErrorOutput;\n\n    public void init(String initialCommand) {\n        try {\n            mProcess = Runtime.getRuntime().exec(initialCommand);\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n            mSucceedOutput = new StringBuilder();\n            mErrorOutput = new StringBuilder();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command + \"\\n\");\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exit() {\n        try {\n            if (mProcess != null) {\n                mProcess.destroy();\n                mProcess = null;\n            }\n            if (mCommandOutputStream != null) {\n                mCommandOutputStream.close();\n                mCommandOutputStream = null;\n            }\n            if (mSucceedReader != null) {\n                mSucceedReader.close();\n                mSucceedReader = null;\n            }\n            if (mErrorReader != null) {\n                mErrorReader.close();\n                mErrorReader = null;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exitAndWaitFor() {\n        exit();\n        waitFor();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public ProcessShell readAll() {\n        String line;\n        try {\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() {\n        String line;\n        try {\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() {\n        String line;\n        try {\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a Java class that manages external processes, handling their input/output streams and providing control over process execution, including starting, stopping, and monitoring.\n\nClass Description: The DaemonHandler class is designed to manage external processes executed via ProcessBuilder. It provides functionality to start processes with either delimited or undelimited output handling, stop processes (either gracefully or forcibly), and retrieve process exit codes. The class maintains separate threads for handling standard output and error streams, with output being captured and placed into a shared blocking deque.\n\nAttributes:\n- processBuilder: ProcessBuilder - Configures and starts external processes\n- process: Process - Represents the currently running external process\n- outThread: Thread - Thread handling standard output stream\n- errThread: Thread - Thread handling error output stream\n- errProxy: OutputProxy - Proxy for handling error stream output\n- outProxy: OutputProxy - Proxy for handling standard output stream\n- deque: BlockingDeque<Event> - Shared queue for process output events\n- stdOut: boolean - Flag indicating whether to capture standard output\n\nMethods:\n- DaemonHandler(BlockingDeque<Event>, String...) -> void - Constructor that initializes the process handler with output queue and command\n- setStdOutListener(boolean) -> void - Sets whether to capture standard output\n- startDelimited() -> Process - Starts process with delimited output handling (using default delimiter)\n- startDelimited(byte) -> Process - Starts process with custom delimiter for output handling\n- startUndelimited() -> Process - Starts process with undelimited output handling (default buffer size)\n- startUndelimited(int) -> Process - Starts process with undelimited output handling (custom buffer size)\n- stop(boolean) -> void - Stops the managed process (optionally forcibly)\n- getExitCode() -> int - Retrieves the exit code of the process (or PROCESS_STOPPED if not running)",
    "Canonical_solution": "import com.linbit.extproc.OutputProxy.Event;\nimport java.io.IOException;\nimport java.lang.ProcessBuilder.Redirect;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\n\npublic class DaemonHandler\n{\n    public static final int PROCESS_STOPPED = Integer.MAX_VALUE;\n    private static final byte DELIMITER = '\\n';\n\n    private final ProcessBuilder processBuilder;\n    private Process process;\n\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(final BlockingDeque<Event> dequeRef, final String... command)\n    {\n        deque = dequeRef;\n        processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectError(Redirect.PIPE);\n        stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOutRef)\n    {\n        stdOut = stdOutRef;\n    }\n\n    public Process startDelimited() throws IOException\n    {\n        return startDelimited(DELIMITER);\n    }\n\n    public Process startDelimited(byte delimiterRef) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxyDelimited(process.getErrorStream(), deque, delimiterRef, false);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxyDelimited(process.getInputStream(), deque, delimiterRef, true);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException\n    {\n        return startUndelimited(OutputProxy.DFLT_BUFFER_SIZE);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxy(process.getErrorStream(), deque, false, bufferSize);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxy(process.getInputStream(), deque, true, bufferSize);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force)\n    {\n        if (process != null)\n        {\n            if (outProxy != null)\n            {\n                outProxy.expectShutdown();\n            }\n            errProxy.expectShutdown();\n            if (force)\n            {\n                process.destroyForcibly();\n            }\n            else\n            {\n                process.destroy();\n            }\n            if (outThread != null)\n            {\n                outThread.interrupt();\n            }\n            errThread.interrupt();\n            process = null;\n        }\n    }\n\n    public int getExitCode()\n    {\n        int exitValue;\n        Process proc = process;\n        if (proc != null)\n        {\n            if (proc.isAlive())\n            {\n                try\n                {\n                    proc.waitFor(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException ignored)\n                {\n                }\n                if (proc.isAlive())\n                {\n                    throw new ImplementationError(\"Process is still running\");\n                }\n            }\n            exitValue = proc.exitValue();\n        }\n        else\n        {\n            exitValue = PROCESS_STOPPED;\n        }\n        return exitValue;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.LinkedBlockingDeque;\n\npublic class DaemonHandler {\n    private ProcessBuilder processBuilder;\n    private Process process;\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n    private BlockingDeque<Event> deque;\n    private boolean stdOut = true;\n\n    public DaemonHandler(BlockingDeque<Event> deque, String... command) {\n        this.deque = deque;\n        this.processBuilder = new ProcessBuilder(command);\n    }\n\n    public void setStdOutListener(boolean stdOut) {\n        this.stdOut = stdOut;\n    }\n\n    public Process startDelimited() {\n        return startDelimited((byte) 0);\n    }\n\n    public Process startDelimited(byte delimiter) {\n        process = executeProcess();\n        outProxy = new OutputProxy(deque, delimiter, true);\n        errProxy = new OutputProxy(deque, delimiter, false);\n        outThread = new Thread(outProxy);\n        errThread = new Thread(errProxy);\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() {\n        return startUndelimited(8192);\n    }\n\n    public Process startUndelimited(int bufferSize) {\n        process = executeProcess();\n        outProxy = new OutputProxy(deque, bufferSize, true);\n        errProxy = new OutputProxy(deque, bufferSize, false);\n        outThread = new Thread(outProxy);\n        errThread = new Thread(errProxy);\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    private Process executeProcess() {\n        try {\n            return processBuilder.start();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start process\", e);\n        }\n    }\n\n    public void stop(boolean force) {\n        if (process != null) {\n            if (force) {\n                process.destroyForcibly();\n            } else {\n                process.destroy();\n            }\n            try {\n                process.waitFor();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public int getExitCode() {\n        if (process == null) {\n            return -1;\n        }\n        try {\n            return process.exitValue();\n        } catch (IllegalThreadStateException e) {\n            return -1;\n        }\n    }\n\n    private static class OutputProxy implements Runnable {\n        private final BlockingDeque<Event> deque;\n        private final byte delimiter;\n        private final int bufferSize;\n        private final boolean stdout;\n        private final InputStream inputStream;\n\n        public OutputProxy(BlockingDeque<Event> deque, byte delimiter, boolean stdout) {\n            this.deque = deque;\n            this.delimiter = delimiter;\n            this.stdout = stdout;\n            this.inputStream = stdout ? process.getInputStream() : process.getErrorStream();\n        }\n\n        public OutputProxy(BlockingDeque<Event> deque, int bufferSize, boolean stdout) {\n            this.deque = deque;\n            this.bufferSize = bufferSize;\n            this.stdout = stdout;\n            this.inputStream = stdout ? process.getInputStream() : process.getErrorStream();\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[bufferSize];\n                int bytesRead;\n                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    byteArrayOutputStream.write(buffer, 0, bytesRead);\n                    if (delimiter != 0) {\n                        byte[] data = byteArrayOutputStream.toByteArray();\n                        int index = 0;\n                        while ((index = findDelimiter(data, index, delimiter)) != -1) {\n                            byte[] eventBytes = new byte[index];\n                            System.arraycopy(data, 0, eventBytes, 0, index);\n                            deque.add(new Event(eventBytes, stdout));\n                            System.arraycopy(data, index + 1, data, 0, data.length - index - 1);\n                            byteArrayOutputStream.reset();\n                            byteArrayOutputStream.write(data, 0, data.length - index - 1);\n                            index = 0;\n                        }\n                    } else {\n                        deque.add(new Event(byteArrayOutputStream.toByteArray(), stdout));\n                        byteArrayOutputStream.reset();\n                    }\n                }\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n\n        private int findDelimiter(byte[] data, int fromIndex, byte delimiter) {\n            for (int i = fromIndex; i < data.length; i++) {\n                if (data[i] == delimiter) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    public static class Event {\n        private final byte[] data;\n        private final boolean stdout;\n\n        public Event(byte[] data, boolean stdout) {\n            this.data = data;\n            this.stdout = stdout;\n        }\n\n        public byte[] getData() {\n            return data;\n        }\n\n        public boolean isStdout() {\n            return stdout;\n        }\n    }\n}"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a Java function that executes an FFmpeg process to convert a video file into NUT format with raw video and audio codecs, then reads and processes the output using a NutReader.\n\nFunction Description: The function testNutReader() configures and executes an FFmpeg process to convert an input video file into NUT format with specific codec settings (rawvideo for video, pcm_s32le for audio). It then reads and processes the output stream using a NutReader with custom handlers for stream and frame events. The function ensures proper process synchronization by waiting for the FFmpeg process to complete.\n\nInput: None (uses a predefined input file Samples.big_buck_bunny_720p_1mb)\n\nOutput: None (void return type), but the function:\n1. Executes an FFmpeg conversion process\n2. Processes the output through NutReader callbacks\n3. Asserts the process completed successfully (exit code 0)\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the process\n- ExecutionException: If there's an error in process execution\n- IOException: If there's an I/O error during process handling\n- LineUnavailableException: If there's an audio line availability issue",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic void testNutReader()\n    throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n\n    List<String> args =\n        new FFmpegBuilder()\n            .setInput(Samples.big_buck_bunny_720p_1mb)\n            .done()\n            .addStdoutOutput()\n            .setFormat(\"nut\")\n            .setVideoCodec(\"rawvideo\")\n            .setVideoPixelFormat(\"argb\")\n            .setAudioCodec(\"pcm_s32le\")\n            .done()\n            .build();\n\n    List<String> newArgs =\n        ImmutableList.<String>builder().add(FFmpeg.DEFAULT_PATH).addAll(args).build();\n\n    ProcessBuilder builder = new ProcessBuilder(newArgs);\n    Process p = builder.start();\n\n    new NutReader(\n            p.getInputStream(),\n            new NutReaderListener() {\n                @Override\n                public void stream(Stream stream) {\n                    // Audio stream handling logic\n                }\n\n                @Override\n                public void frame(Frame frame) {\n                    // Frame processing logic\n                }\n            })\n        .read();\n\n    assertEquals(0, p.waitFor());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.concurrent.*;\nimport javax.sound.sampled.*;\n\npublic class NutReaderTest {\n    public static void testNutReader() throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n        String input = \"Samples.big_buck_bunny_720p_1mb.mp4\";\n        String output = \"output.nut\";\n\n        ProcessBuilder pb = new ProcessBuilder(\n            \"ffmpeg\",\n            \"-i\", input,\n            \"-c:v\", \"rawvideo\",\n            \"-pix_fmt\", \"yuv420p\",\n            \"-c:a\", \"pcm_s32le\",\n            output\n        );\n        pb.redirectErrorStream(true);\n\n        Process process = pb.start();\n        int exitCode = process.waitFor();\n\n        if (exitCode != 0) {\n            throw new RuntimeException(\"FFmpeg process failed with exit code: \" + exitCode);\n        }\n\n        NutReader reader = new NutReader(new File(output));\n        reader.setStreamHandler((streamIndex, streamType, codec, format) -> {\n            System.out.println(\"Stream handler: Index=\" + streamIndex + \", Type=\" + streamType + \", Codec=\" + codec + \", Format=\" + format);\n        });\n\n        reader.setFrameHandler((frameIndex, pts, duration, data) -> {\n            System.out.println(\"Frame handler: Index=\" + frameIndex + \", PTS=\" + pts + \", Duration=\" + duration + \", Data length=\" + data.length);\n        });\n\n        reader.read();\n        reader.close();\n    }\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create utility functions for working with FileChannel in Java NIO to provide OutputStream functionality with optional force-write capability at close.\n\nFunction Description: The provided code consists of three utility functions that work together to create an OutputStream wrapper around a FileChannel, with control over whether changes are forcibly written to disk when closing the stream.\n\nInput:\n1. For newOutputStream:\n   - channel: FileChannel - The FileChannel to wrap with OutputStream functionality\n   - forceAtClose: boolean - Whether to force write changes to disk when closing\n\n2. For newOutputStreamForceAtClose:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\n3. For newFileChannel:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\nOutput:\n1. For newOutputStream: OutputStream - A new OutputStream instance that writes to the provided FileChannel\n2. For newOutputStreamForceAtClose: OutputStream - A new OutputStream instance that forces writes to disk when closed\n3. For newFileChannel: FileChannel - A new FileChannel instance for the specified path with given options",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\nstatic OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n    final byte[] single = {0};\n    return new OutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n            single[0] = (byte) b;\n            write(single);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            for(; len > 0; ) {\n                final int written = channel.write(ByteBuffer.wrap(b, off, len));\n                off += written;\n                len -= written;\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            try (FileChannel c = channel) {\n                if (forceAtClose) {\n                    c.force(true);\n                }\n            }\n        }\n    };\n}\n\nstatic OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n    return newOutputStream(newFileChannel(p, options), true);\n}\n\nstatic FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n    return LogUtils.supplyAndLog(LOG,\n        () -> FileChannel.open(p, options),\n        () -> \"FileChannel.open \" + p + \" with options \" + Arrays.asList(options));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelUtils {\n    public static OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n        return new OutputStream() {\n            private final FileChannel fc = channel;\n            private final ByteBuffer buf = ByteBuffer.allocate(8192);\n\n            @Override\n            public void write(int b) throws IOException {\n                buf.put((byte) b);\n                if (buf.remaining() == 0) {\n                    flush();\n                }\n            }\n\n            @Override\n            public void write(byte[] b, int off, int len) throws IOException {\n                if (len <= buf.remaining()) {\n                    buf.put(b, off, len);\n                } else {\n                    int remaining = buf.remaining();\n                    if (remaining > 0) {\n                        buf.put(b, off, remaining);\n                        flush();\n                    }\n                    int pos = 0;\n                    while (len - pos > 0) {\n                        int chunk = Math.min(8192, len - pos);\n                        fc.write(ByteBuffer.wrap(b, pos, chunk));\n                        pos += chunk;\n                    }\n                }\n            }\n\n            @Override\n            public void flush() throws IOException {\n                if (buf.position() > 0) {\n                    buf.flip();\n                    fc.write(buf);\n                    buf.clear();\n                }\n            }\n\n            @Override\n            public void close() throws IOException {\n                flush();\n                if (forceAtClose) {\n                    fc.force(true);\n                }\n                fc.close();\n            }\n        };\n    }\n\n    public static OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n        try (FileChannel fc = FileChannel.open(p, options)) {\n            return newOutputStream(fc, true);\n        }\n    }\n\n    public static FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n        return FileChannel.open(p, options);\n    }\n}"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a Java function that executes a shell command with root privileges using ProcessBuilder, handles input/output streams, and properly manages process lifecycle and error handling.\n\nFunction Description: The function executes a given shell command with root privileges by spawning a new process through ProcessBuilder. It uses 'su' to gain root access and 'nsenter' to enter the root namespace. The function handles command safety checks, process I/O streams, error redirection, and proper resource cleanup. It returns the command output or error messages.\n\nInput: \n- cmd: String - The shell command to be executed with root privileges\n\nOutput: \n- String - The output of the executed command (stdout) or error message if execution fails. The output string is cleaned to remove trailing newlines and unnecessary error prefixes.\n\nNote: The function includes a safety check (isSafeCommand) to prevent dangerous operations, though its implementation isn't shown in the reference code.",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\n\npublic static String rootExecCmd(String cmd) {\n    if (!isSafeCommand(cmd)) return \"Cannot exec this command: Dangerous operation\";\n    StringBuilder result = new StringBuilder();\n    ProcessBuilder pb = new ProcessBuilder(\"su\");\n    Process p;\n    DataOutputStream dos = null;\n    DataInputStream dis = null;\n    try {\n        pb.redirectErrorStream(true);\n        p = pb.start();\n        dos = new DataOutputStream(p.getOutputStream());\n        dis = new DataInputStream(p.getInputStream());\n        dos.writeBytes(\"nsenter --mount=/proc/1/ns/mnt -- \" + cmd + \"\\n\");\n        dos.flush();\n        dos.writeBytes(\"exit\\n\");\n        dos.flush();\n        String line;\n        while ((line = dis.readLine()) != null) {\n            result.append(line).append(\"\\n\");\n        }\n        p.waitFor();\n    } catch (Exception e) {\n        if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n            return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n        } else {\n            return String.valueOf(e);\n        }\n    } finally {\n        if (dos != null) {\n            try {\n                dos.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n        if (dis != null) {\n            try {\n                dis.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n    }\n    if (result.length() > 0) {\n        result = new StringBuilder(result.substring(0, result.length() - 1));\n    }\n    if (!cmd.contains(\"nsenter\") && result.toString().contains(\"nsenter: exec \")) {\n        return result.toString().replace(\"nsenter: exec \", \"\");\n    } else {\n        return result.toString();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public String executeRootCommand(String cmd) {\n    try {\n        if (!isSafeCommand(cmd)) {\n            return \"Command not allowed due to safety restrictions.\";\n        }\n\n        ProcessBuilder pb = new ProcessBuilder(\"su\", \"-\", \"root\", \"-c\", \"nsenter -t 1 -n \" + cmd);\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        String line;\n\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            return output.toString().trim();\n        }\n\n        return output.toString().trim();\n    } catch (Exception e) {\n        return \"Error executing command: \" + e.getMessage();\n    }\n}"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Create a function that executes an external process, captures its output (including error streams redirected to standard output), and returns the output as a string.\n\nFunction Description: The function uses Java's ProcessBuilder to start an external process specified by the given command. It redirects the error stream to the standard output stream to capture all output in one place. The function reads the process's output stream line by line, collects it into a string, and waits for the process to complete before returning the collected output.\n\nInput: \n- cmd: String[] - An array of strings representing the command to execute and its arguments.\n\nOutput: \n- String - The combined standard output and error output of the executed process, trimmed of any leading or trailing whitespace.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getProcessOutput(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    StringBuilder processOutput = new StringBuilder();\n    try (BufferedReader processOutputReader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));) {\n        String readLine;\n        while ((readLine = processOutputReader.readLine()) != null) {\n            processOutput.append(readLine + System.lineSeparator());\n        }\n        process.waitFor();\n    }\n    return processOutput.toString().trim();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public static String executeProcess(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n    StringBuilder output = new StringBuilder();\n    String line;\n    while ((line = reader.readLine()) != null) {\n        output.append(line).append(System.lineSeparator());\n    }\n    int exitCode = process.waitFor();\n    return output.toString().trim();\n}"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a Java function that executes an external process using ProcessBuilder, captures its output, and handles errors appropriately.\n\nFunction Description: The function executes a shell command constructed from configuration parameters, captures the process's standard output and error streams (merged), waits for the process to complete, and returns the exit status or throws an exception if the process fails. The function handles process initialization, stream reading, and error management.\n\nInput:\n- job: Job<Object> - A job object containing configuration details\n- parameters: Map<String, Object> - A map of parameters used to construct the shell command\n\nOutput:\n- Object - Returns 0 if the process exits successfully, otherwise throws a HugeException containing the exit code and process output\n\nNote: The function includes error handling for process initialization, execution, and stream reading, with all exceptions wrapped in HugeException. The process's working directory is set to executeDir(), and error streams are redirected to standard output.",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic Object call(Job<Object> job, Map<String, Object> parameters) {\n    this.checkAndCollectParameters(parameters);\n    try {\n        this.initializeConfig((ComputerJob) job);\n    } catch (Exception e) {\n        throw new HugeException(\n                \"Failed to initialize computer config file\", e);\n    }\n\n    Map<String, Object> configs = new HashMap<>();\n    configs.putAll(this.commonConfig);\n    configs.putAll(this.checkAndCollectParameters(parameters));\n\n    String[] command = this.constructShellCommands(configs);\n    LOG.info(\"Execute computer job: {}\", String.join(SPACE, command));\n\n    try {\n        ProcessBuilder builder = new ProcessBuilder(command);\n        builder.redirectErrorStream(true);\n        builder.directory(new File(executeDir()));\n\n        Process process = builder.start();\n\n        StringBuilder output = new StringBuilder();\n        try (LineNumberReader reader = new LineNumberReader(\n                new InputStreamReader(\n                        process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            return 0;\n        }\n\n        throw new HugeException(\"The computer job exit with code %s: %s\",\n                                exitCode, output);\n    } catch (HugeException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new HugeException(\"Failed to execute computer job\", e);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public Object executeProcess(Job<Object> job, Map<String, Object> parameters) throws HugeException {\n    try {\n        List<String> command = new ArrayList<>();\n        command.add(\"sh\");\n        command.add(\"-c\");\n        String cmd = constructCommand(parameters);\n        command.add(cmd);\n\n        ProcessBuilder processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectErrorStream(true);\n        processBuilder.directory(new File(executeDir()));\n\n        Process process = processBuilder.start();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new HugeException(\"Process failed with exit code: \" + exitCode + \"\\nOutput: \" + output.toString(), exitCode, output.toString());\n        }\n\n        return 0;\n    } catch (IOException | InterruptedException e) {\n        throw new HugeException(\"Error executing process: \" + e.getMessage(), -1, e.getMessage());\n    }\n}"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class JavaVersionChecker {\n    public static String getJavaCompilerVersion() {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"javac\", \"-version\");\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            java.util.Scanner scanner = new java.util.Scanner(process.getInputStream()).useDelimiter(\"\\\\A\");\n            String output = scanner.hasNext() ? scanner.next() : \"\";\n            if (output.trim().startsWith(\"javac\")) {\n                return output.trim();\n            }\n        } catch (Exception e) {\n            // Handle exceptions\n        }\n        return \"unknown\";\n    }\n}"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter;\n    private Object mLock;\n    private boolean mIsActive;\n    private boolean mIsRoot;\n    private String mCommandEnd = \"EOF\";\n\n    public interface OnStreamListener {\n        void onStreamStart();\n        void onStreamInput(String line);\n        void onStreamStop(Integer exitCode);\n        void onStreamDied();\n    }\n\n    private class Counter {\n        private AtomicInteger count = new AtomicInteger(0);\n\n        public int size() {\n            return count.get();\n        }\n\n        public int encrease() {\n            return count.incrementAndGet();\n        }\n\n        public int decrease() {\n            return count.decrementAndGet();\n        }\n\n        public void reset() {\n            count.set(0);\n        }\n    }\n\n    public ShellStream(boolean requestRoot, OnStreamListener listener) {\n        mListener = listener;\n        mCounter = new Counter();\n        mLock = new Object();\n        mIsActive = true;\n        mIsRoot = requestRoot;\n\n        try {\n            if (mIsRoot) {\n                mConnection = Runtime.getRuntime().exec(\"su\");\n            } else {\n                mConnection = Runtime.getRuntime().exec(\"sh\");\n            }\n\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            mStdOutputWorker = new Thread(() -> {\n                String line;\n                try {\n                    while ((line = mStdOutput.readLine()) != null) {\n                        mListener.onStreamInput(line);\n                    }\n                } catch (IOException e) {\n                    mListener.onStreamDied();\n                }\n            });\n            mStdOutputWorker.start();\n\n            mListener.onStreamStart();\n        } catch (IOException e) {\n            mListener.onStreamDied();\n            mIsActive = false;\n        }\n    }\n\n    public void execute(String command) {\n        synchronized (mLock) {\n            if (!mIsActive) {\n                return;\n            }\n\n            mCounter.encrease();\n            try {\n                mStdInput.writeBytes(command + \"\\n\" + mCommandEnd + \"\\n\");\n                mStdInput.flush();\n            } catch (IOException e) {\n                mListener.onStreamDied();\n                mIsActive = false;\n            }\n        }\n    }\n\n    public boolean waitFor() {\n        return waitFor(Integer.MAX_VALUE);\n    }\n\n    public boolean waitFor(int timeout) {\n        long startTime = System.currentTimeMillis();\n        while (mCounter.size() > 0) {\n            if (timeout < System.currentTimeMillis() - startTime) {\n                return false;\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean waitFor(int timeout, int index) {\n        long startTime = System.currentTimeMillis();\n        while (mCounter.size() > index) {\n            if (timeout < System.currentTimeMillis() - startTime) {\n                return false;\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        synchronized (mLock) {\n            if (!mIsActive) {\n                return;\n            }\n            mIsActive = false;\n            mCounter.reset();\n            try {\n                mStdInput.close();\n                mStdOutput.close();\n                mConnection.destroy();\n            } catch (IOException e) {\n                mListener.onStreamDied();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    private Runtime rt;\n    private String[] command;\n    private String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error;\n    private int exitval = -1;\n\n    public ShellCommand(String[] command) {\n        this(command, \"ShellCommand\");\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.command = command;\n        this.tag = tag;\n        this.rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            if (waitForExit) {\n                waitForExit();\n            }\n        } catch (IOException e) {\n            Log.e(tag, \"Error executing command: \" + e.getMessage());\n            error = e.getMessage();\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            exitval = process.waitFor();\n            readAllStdout();\n        } catch (InterruptedException e) {\n            Log.e(tag, \"Interrupted while waiting for command exit: \" + e.getMessage());\n            error = e.getMessage();\n        }\n    }\n\n    public void finish() {\n        if (process != null) {\n            try {\n                process.destroy();\n                process.waitFor();\n            } catch (InterruptedException e) {\n                Log.e(tag, \"Interrupted while finishing process: \" + e.getMessage());\n            }\n        }\n        if (stdout != null) {\n            try {\n                stdout.close();\n            } catch (IOException e) {\n                Log.e(tag, \"Error closing stdout: \" + e.getMessage());\n            }\n        }\n    }\n\n    public boolean checkForExit() {\n        if (process == null) return true;\n        try {\n            exitval = process.exitValue();\n            return true;\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (IOException e) {\n            Log.e(tag, \"Error checking stdout availability: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            Log.e(tag, \"Error reading stdout: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        if (!stdoutAvailable()) {\n            return null;\n        }\n        return readStdoutBlocking();\n    }\n\n    private void readAllStdout() {\n        String line;\n        try {\n            while ((line = stdout.readLine()) != null) {\n                Log.d(tag, \"STDOUT: \" + line);\n            }\n        } catch (IOException e) {\n            Log.e(tag, \"Error reading all stdout: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic class SystemInfoUtil {\n\n    public static String getHostName() {\n        if (isWindows()) {\n            String computerName = System.getenv(\"COMPUTERNAME\");\n            if (computerName != null && !computerName.isEmpty()) {\n                return computerName;\n            }\n            return executeCommand(\"hostname\");\n        } else {\n            return getUname(\"-n\");\n        }\n    }\n\n    private static boolean isWindows() {\n        return System.getProperty(\"os.name\").toLowerCase().contains(\"windows\");\n    }\n\n    private static String executeCommand(String command) {\n        try {\n            Process process = new ProcessBuilder(command).start();\n            process.waitFor(5, TimeUnit.SECONDS);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            return output.toString().trim();\n        } catch (IOException | InterruptedException e) {\n            return \"\";\n        }\n    }\n\n    public static String getUname(String param) {\n        if (isWindows()) {\n            return \"\";\n        }\n        return executeCommand(\"uname\" + param);\n    }\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TemporaryPorts {\n    public static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports = new ArrayList<>();\n\n    public TemporaryPorts(Path lockDirectory) {\n        this.lockDirectory = lockDirectory != null ? lockDirectory : DEFAULT_LOCK_DIRECTORY;\n        if (!Files.exists(this.lockDirectory)) {\n            try {\n                Files.createDirectories(this.lockDirectory);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to create lock directory: \" + this.lockDirectory, e);\n            }\n        }\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) {\n        try {\n            return lock(port, name);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private AllocatedPort lock(int port, String name) throws IOException {\n        Path lockFile = lockDirectory.resolve(name + \"-\" + port + \".lock\");\n        FileChannel fileChannel = FileChannel.open(lockFile, java.nio.file.StandardOpenOption.CREATE_NEW, java.nio.file.StandardOpenOption.WRITE);\n        FileLock lock = fileChannel.tryLock();\n        if (lock == null) {\n            fileChannel.close();\n            return null;\n        }\n        AllocatedPort allocatedPort = new AllocatedPort(port, lockFile, fileChannel, lock);\n        ports.add(allocatedPort);\n        return allocatedPort;\n    }\n\n    public static class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        public AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n        public void release() {\n            try {\n                lock.release();\n                file.close();\n                Files.delete(path);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to release port lock for port: \" + port, e);\n            }\n        }\n    }\n\n    public void release() {\n        for (AllocatedPort port : ports) {\n            port.release();\n        }\n        ports.clear();\n    }\n}"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableMap;\n\npublic class CliDockerClient {\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    private static final Path DEFAULT_DOCKER_CLIENT = Path.of(\"/usr/bin/docker\");\n    private static final Long DOCKER_OUTPUT_TIMEOUT = 600L;\n\n    public CliDockerClient(Path dockerPath, Map<String, String> environment) {\n        this.processBuilderFactory = defaultProcessBuilderFactory(dockerPath.toString(), ImmutableMap.copyOf(environment));\n    }\n\n    protected CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n        this.processBuilderFactory = processBuilderFactory;\n    }\n\n    private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(String dockerBinary, Map<String, String> environment) {\n        return (command) -> {\n            List<String> fullCommand = new ArrayList<>();\n            fullCommand.add(dockerBinary);\n            fullCommand.addAll(command);\n            ProcessBuilder builder = new ProcessBuilder(fullCommand);\n            if (environment != null && !environment.isEmpty()) {\n                builder.environment().putAll(environment);\n            }\n            return builder;\n        };\n    }\n\n    private String getStderrOutput(Process process) throws IOException {\n        InputStream stderr = process.getErrorStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(stderr));\n        StringBuilder errorOutput = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            errorOutput.append(line).append(\"\\n\");\n        }\n        return errorOutput.toString();\n    }\n\n    public Process docker(String... args) throws IOException, InterruptedException {\n        List<String> command = Arrays.asList(args);\n        ProcessBuilder builder = processBuilderFactory.apply(command);\n        Process process = builder.start();\n        try {\n            if (!process.waitFor(DOCKER_OUTPUT_TIMEOUT, TimeUnit.SECONDS)) {\n                process.destroyForcibly();\n                throw new RuntimeException(\"Docker command timed out after \" + DOCKER_OUTPUT_TIMEOUT + \" seconds\");\n            }\n        } catch (InterruptedException e) {\n            process.destroyForcibly();\n            Thread.currentThread().interrupt();\n            throw e;\n        }\n        return process;\n    }\n\n    public DockerInfoDetails info() throws IOException, InterruptedException {\n        Process process = docker(\"info\");\n        return fetchInfoDetails(process);\n    }\n\n    private DockerInfoDetails fetchInfoDetails(Process process) throws IOException {\n        InputStream inputStream = process.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        Map<String, String> infoMap = new HashMap<>();\n        while ((line = reader.readLine()) != null) {\n            if (line.contains(\": \")) {\n                String[] parts = line.split(\": \", 2);\n                if (parts.length == 2) {\n                    String key = parts[0].trim();\n                    String value = parts[1].trim();\n                    infoMap.put(key, value);\n                }\n            }\n        }\n        return new DockerInfoDetails(infoMap);\n    }\n\n    public static class DockerInfoDetails {\n        private final Map<String, String> details;\n\n        public DockerInfoDetails(Map<String, String> details) {\n            this.details = details;\n        }\n\n        public String get(String key) {\n            return details.get(key);\n        }\n\n        public boolean containsKey(String key) {\n            return details.containsKey(key);\n        }\n    }\n}"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Verify and ensure the Java Virtual Machine (JVM) is running on the first thread on macOS, relaunching the process if necessary with the correct arguments.\n\nFunction Description: This function checks if the JVM is running on the first thread on macOS, which is required for proper execution of certain applications. If not, it attempts to relaunch the process with the \"-XstartOnFirstThread\" argument. The function handles process creation, stream redirection, and output/error handling during the relaunch.\n\nInput: \n- args: String[] - Command-line arguments to be passed to the relaunched process (if needed)\n\nOutput: \n- boolean - Returns true if the JVM is already in a valid state (either not on macOS or already running on first thread), or false if a relaunch was attempted (the original process should exit in this case)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.lang.management.ManagementFactory;\n\npublic static boolean verifyValidJVMState(String[] args){\n    if (SharedLibraryLoader.isMac){\n        if (\"1\".equals(System.getenv(\"JAVA_STARTED_ON_FIRST_THREAD_\" +\n                ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0]))) {\n            return true;\n        }\n\n        if (\"true\".equals(System.getProperty(\"shpdRelaunched\"))){\n            System.err.println(\"Error: Could not verify new process is running on the first thread. Trying to run the game anyway...\");\n            return true;\n        }\n\n        String sep = System.getProperty(\"file.separator\");\n\n        ArrayList<String> jvmArgs = new ArrayList<>();\n        jvmArgs.add(System.getProperty(\"java.home\") + sep + \"bin\" + sep + \"java\");\n        jvmArgs.add(\"-XstartOnFirstThread\");\n        jvmArgs.add(\"-DshpdRelaunched=true\");\n        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        jvmArgs.add(\"-cp\");\n        jvmArgs.add(System.getProperty(\"java.class.path\"));\n        jvmArgs.add(DesktopLauncher.class.getName());\n\n        System.err.println(\"Error: ShatteredPD must start on the first thread in order to work on macOS.\");\n        System.err.println(\"  To avoid this error, run the game with the \\\"-XstartOnFirstThread\\\" argument\");\n        System.err.println(\"  Now attempting to relaunch the game on the first thread automatically:\\n\");\n\n        try {\n            Process process = new ProcessBuilder(jvmArgs).redirectErrorStream(true).start();\n            BufferedReader out = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = out.readLine()) != null) {\n                if (line.toLowerCase().startsWith(\"error\")){\n                    System.err.println(line);\n                } else {\n                    System.out.println(line);\n                }\n            }\n\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.IOException;\n\npublic class JVMThreadChecker {\n    public static boolean checkAndRelaunchIfNeeded(String[] args) {\n        if (!isMacOS()) {\n            return true;\n        }\n\n        if (isRunningOnFirstThread()) {\n            return true;\n        }\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-XstartOnFirstThread\", \"-cp\", System.getProperty(\"java.class.path\"), JVMThreadChecker.class.getName());\n            pb.inheritIO();\n            Process process = pb.start();\n            process.waitFor();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n            return false;\n        }\n\n        return false;\n    }\n\n    private static boolean isMacOS() {\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        return osName.contains(\"mac\");\n    }\n\n    private static boolean isRunningOnFirstThread() {\n        return java.awt.EventQueue.isDispatchThread();\n    }\n}\n```"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Implement a utility class for executing external processes synchronously and asynchronously in Java, handling input/output streams properly to prevent deadlocks, and collecting process output.\n\nClass Description: A ProcessExecutor utility class that provides methods to run external processes either synchronously (blocking until completion) or asynchronously (returning immediately), while properly managing process streams and errors.\n\nMethods:\n\nMethod1: runWith(List<String> cmd) -> Collection<String> - Executes a command synchronously and returns its output as a collection of strings. Handles both stdout and stderr streams by draining them concurrently to prevent deadlocks. The method blocks until the process completes.\n\nMethod2: runAsync(String... cmd) -> Process - Executes a command asynchronously and returns the Process object immediately without waiting for completion. The caller is responsible for handling the process streams and termination.\n\nMethod3: InputStreamDrainer(InputStream, OutputStream) -> void - [Internal helper class] A thread class that continuously reads from an input stream and writes to an output stream until EOF is reached. Used internally by runWith() to drain process streams.",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic static Collection<String> runWith(List<String> cmd) {\n    Collection<String> messages = new ArrayList<>();\n    try {\n        Process p = new ProcessBuilder(cmd).start();\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        // drain streams, else we might lock up\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), baos);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), baos);\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int err = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        messages.add(baos.toString());\n    } catch (IOException ex) {\n        return Collections.singleton(ex.getMessage());\n    } catch (InterruptedException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return messages;\n}\n\npublic static Process runAsync(String... cmd) {\n    try {\n        return new ProcessBuilder(cmd).start();\n    } catch (IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    public static Collection<String> runWith(List<String> cmd) throws IOException, InterruptedException {\n        ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n        Process process = processBuilder.start();\n        \n        InputStreamDrainer stdoutDrainer = new InputStreamDrainer(process.getInputStream(), System.out);\n        InputStreamDrainer stderrDrainer = new InputStreamDrainer(process.getErrorStream(), System.err);\n        \n        stdoutDrainer.start();\n        stderrDrainer.start();\n        \n        int exitCode = process.waitFor();\n        stdoutDrainer.join();\n        stderrDrainer.join();\n        \n        return Collections.emptyList(); // Placeholder; actual output collection would be built from streams\n    }\n    \n    public static Process runAsync(String... cmd) throws IOException {\n        ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n        return processBuilder.start();\n    }\n    \n    private static class InputStreamDrainer extends Thread {\n        private final InputStream inputStream;\n        private final OutputStream outputStream;\n        \n        public InputStreamDrainer(InputStream inputStream, OutputStream outputStream) {\n            this.inputStream = inputStream;\n            this.outputStream = outputStream;\n        }\n        \n        @Override\n        public void run() {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            try {\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, bytesRead);\n                }\n                outputStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 296,
    "Instruction": "Task Description: Create a function that executes an external diff tool to compare two files and generate a difference file, while capturing and logging the tool's output.\n\nFunction Description: The function `diffFile` executes an external diff utility specified by its path and arguments, comparing two input files (old and new versions) and generating a difference file. It captures the standard output and error streams of the external process, logs them, and waits for the process to complete before returning.\n\nInput:\n- `mCustomDiffPath`: String - Path to the external diff tool executable\n- `mCustomDiffPathArgs`: String - Arguments to pass to the diff tool (space-separated)\n- `oldFile`: File - The original file to compare against\n- `newFile`: File - The modified file to compare\n- `diffFile`: File - The output file where differences will be written\n\nOutput:\n- None (void) - The function doesn't return any value but writes the diff output to the specified file and logs the process output\n- Throws IOException if process execution fails\n- Throws InterruptedException if the process is interrupted while waiting",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic static void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException {\n    String outPath = diffFile.getAbsolutePath();\n    String cmd = mCustomDiffPath;\n    List<String> cmds = new ArrayList<>();\n    for (String s : cmd.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    for (String s : mCustomDiffPathArgs.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    cmds.add(oldFile.getAbsolutePath());\n    cmds.add(newFile.getAbsolutePath());\n    cmds.add(outPath);\n\n    ProcessBuilder pb = new ProcessBuilder(cmds);\n    pb.redirectErrorStream(true);\n    Process process = pb.start();\n    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n    String line;\n    while ((line = br.readLine()) != null) {\n        Logger.d(line);\n    }\n    int exitCode = process.waitFor();\n    process.destroy();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException, InterruptedException {\n    List<String> command = new ArrayList<>();\n    command.add(mCustomDiffPath);\n    command.addAll(Arrays.asList(mCustomDiffPathArgs.split(\"\\\\s+\")));\n    command.add(oldFile.getAbsolutePath());\n    command.add(newFile.getAbsolutePath());\n    command.add(diffFile.getAbsolutePath());\n\n    ProcessBuilder processBuilder = new ProcessBuilder(command);\n    processBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n    processBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n\n    Process process = processBuilder.start();\n\n    BufferedReader stdOutReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n    BufferedReader stdErrReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n\n    String line;\n    while ((line = stdOutReader.readLine()) != null) {\n        System.out.println(\"STDOUT: \" + line);\n    }\n    while ((line = stdErrReader.readLine()) != null) {\n        System.err.println(\"STDERR: \" + line);\n    }\n\n    int exitCode = process.waitFor();\n    if (exitCode != 0) {\n        throw new IOException(\"Diff tool exited with code: \" + exitCode);\n    }\n}"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.*;\n\npublic class ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), System.err);\n        StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), System.out);\n        errorGobbler.start();\n        outputGobbler.start();\n        process.waitFor();\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        if (builders.length == 0) {\n            return;\n        }\n        File tempFile = File.createTempFile(\"pipe\", \".tmp\", processRoot);\n        tempFile.deleteOnExit();\n        try (OutputStream tempOut = new FileOutputStream(tempFile)) {\n            new AsyncPipe(is, tempOut).start();\n            for (int i = 0; i < builders.length; i++) {\n                ProcessBuilder currentBuilder = builders[i];\n                currentBuilder.directory(processRoot);\n                Process process = currentBuilder.start();\n                InputStream processIn = process.getInputStream();\n                if (i == builders.length - 1) {\n                    new AsyncPipe(new FileInputStream(tempFile), os).start();\n                } else {\n                    File nextTempFile = File.createTempFile(\"pipe\", \".tmp\", processRoot);\n                    nextTempFile.deleteOnExit();\n                    try (OutputStream nextOut = new FileOutputStream(nextTempFile)) {\n                        new AsyncPipe(processIn, nextOut).start();\n                        process.waitFor();\n                        tempFile = nextTempFile;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class AsyncPipe extends Thread {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            try {\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                }\n                if (closeStreams) {\n                    is.close();\n                    os.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class StreamGobbler extends Thread {\n        private final InputStream is;\n        private final PrintStream ps;\n\n        public StreamGobbler(InputStream is, PrintStream ps) {\n            this.is = is;\n            this.ps = ps;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    ps.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ProcessExecutor {\n    public static List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr, boolean printOut, boolean printErr) throws BenchmarkException {\n        List<IterationResult> results = new ArrayList<>();\n        ProcessBuilder processBuilder = new ProcessBuilder(commandString);\n        processBuilder.redirectOutput(stdOut);\n        processBuilder.redirectError(stdErr);\n\n        try {\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n\n            if (exitCode != 0) {\n                throw new BenchmarkException(\"Process exited with non-zero code: \" + exitCode);\n            }\n\n            if (printOut) {\n                BufferedReader outReader = new BufferedReader(new InputStreamReader(new File(stdOut).toPath().toFile().getInputStream()));\n                String line;\n                while ((line = outReader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                outReader.close();\n            }\n\n            if (printErr) {\n                BufferedReader errReader = new BufferedReader(new InputStreamReader(new File(stdErr).toPath().toFile().getInputStream()));\n                String line;\n                while ((line = errReader.readLine()) != null) {\n                    System.err.println(line);\n                }\n                errReader.close();\n            }\n\n            results = reader.getResults();\n        } catch (IOException | InterruptedException e) {\n            throw new BenchmarkException(\"Error executing process: \" + e.getMessage(), e);\n        }\n\n        return results;\n    }\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Create a Java class that manages the execution of external commands, handles their input/output streams, and provides synchronization capabilities for waiting until the command completes.\n\nClass Description: The ExtCmd class provides functionality to execute external system commands, manage their input/output streams, and wait for their completion. It includes features for logging, condition checking before execution, and notification listeners for process completion.\n\nAttributes:\n\nconditionsWithDescriptions: Map<ExtCmdCondition, String> - Stores conditions that must be met before command execution along with their descriptions\nextCmdEndedListenerSet: Set<ExtCmdEndedListener> - Collection of listeners to be notified when command execution ends\noutReceiver: OutputReceiver - Handles the standard output stream from the executed command\nerrReceiver: OutputReceiver - Handles the error output stream from the executed command\nerrLog: ErrorReporter - Logger for command execution information\nstartTime: long - Timestamp when command execution started\nexecCommand: String[] - The command to be executed\nexecCommandStr: String - String representation of the command\nlogExecution: boolean - Flag to enable/disable execution logging\n\nMethods:\n\nexec(ProcessBuilder.Redirect, File, String...) -> OutputStream - Executes an external command with specified input redirection, working directory, and command arguments. Returns the process's output stream for writing input.\nsyncProcess() -> OutputData - Waits for the command to complete and returns its output data including stdout, stderr, and exit code.\ncheckForConditions() -> void - Internal method to verify all execution conditions are met before starting a command.\n\nNested Classes:\n\nOutputData: Contains the results of command execution including stdout, stderr, and exit code\nExtCmdCondition: Interface for defining pre-execution conditions\nExtCmdEndedListener: Interface for command completion notification callbacks",
    "Canonical_solution": "import com.linbit.ChildProcessTimeoutException;\nimport com.linbit.linstor.logging.ErrorReporter;\nimport com.linbit.timer.Action;\nimport com.linbit.timer.Timer;\nimport com.linbit.utils.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.slf4j.MDC;\n\npublic class ExtCmd extends ChildProcessHandler\n{\n    private final Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private final Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n\n    private String[] execCommand;\n    private String execCommandStr;\n\n    private boolean logExecution = true;\n\n    public ExtCmd(Timer<String, Action<String>> timer, ErrorReporter errLogRef)\n    {\n        super(timer);\n        conditionsWithDescriptions = new HashMap<>();\n        outReceiver = null;\n        errReceiver = null;\n        errLog = errLogRef;\n        extCmdEndedListenerSet = new HashSet<>();\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect stdinRedirect, File directory, String... command)\n        throws IOException\n    {\n        execCommand = command;\n        execCommandStr = StringUtils.joinShellQuote(command);\n\n        if (logExecution)\n        {\n            errLog.logDebug(\"Executing command: %s\", execCommandStr);\n        }\n\n        ProcessBuilder pBuilder = new ProcessBuilder();\n        pBuilder.directory(directory);\n        pBuilder.command(command);\n        pBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectInput(stdinRedirect);\n        Process child;\n        synchronized (conditionsWithDescriptions)\n        {\n            checkForConditions();\n            child = pBuilder.start();\n            startTime = System.currentTimeMillis();\n            setChild(child);\n            outReceiver = new OutputReceiver(\n                child.getInputStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n            errReceiver = new OutputReceiver(\n                child.getErrorStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n        }\n        new Thread(outReceiver).start();\n        new Thread(errReceiver).start();\n\n        return child.getOutputStream();\n    }\n\n    private void checkForConditions()\n    {\n        for (Entry<ExtCmdCondition, String> entry : conditionsWithDescriptions.entrySet())\n        {\n            if (!entry.getKey().isMet(this))\n            {\n                throw new ExtCmdConditionNotFullfilledException(entry.getValue() + \", command: \" + this.execCommandStr);\n            }\n        }\n    }\n\n    public OutputData syncProcess() throws IOException, ChildProcessTimeoutException\n    {\n        OutputData outData;\n        try\n        {\n            int exitCode = waitFor();\n            outReceiver.finish();\n            errReceiver.finish();\n            outData = new OutputData(\n                execCommand,\n                outReceiver.getData(),\n                errReceiver.getData(),\n                exitCode\n            );\n\n            if (logExecution)\n            {\n                errLog.logTrace(\n                    \"External command finished in %dms: %s\",\n                    (System.currentTimeMillis() - startTime),\n                    execCommandStr\n                );\n            }\n\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this);\n            }\n        }\n        catch (IOException | ChildProcessTimeoutException exc)\n        {\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this, exc);\n            }\n            throw exc;\n        }\n        return outData;\n    }\n\n    public static class OutputData\n    {\n        public final String[] executedCommand;\n        public final byte[] stdoutData;\n        public final byte[] stderrData;\n        public final int exitCode;\n\n        public OutputData(String[] executeCmd, byte[] out, byte[] err, int retCode)\n        {\n            executedCommand = executeCmd;\n            stdoutData = out;\n            stderrData = err;\n            exitCode = retCode;\n        }\n    }\n\n    public interface ExtCmdCondition\n    {\n        boolean isMet(ExtCmd extCmd);\n    }\n\n    public interface ExtCmdEndedListener\n    {\n        void extCmdEnded(ExtCmd extCmd);\n        void extCmdEnded(ExtCmd extCmd, Exception exc);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.File;\nimport java.io.OutputStream;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\npublic class ExtCmd {\n    protected Map<ExtCmdCondition, String> conditionsWithDescriptions = new ConcurrentHashMap<>();\n    protected Set<ExtCmdEndedListener> extCmdEndedListenerSet = new CopyOnWriteArraySet<>();\n    protected OutputReceiver outReceiver;\n    protected OutputReceiver errReceiver;\n    protected ErrorReporter errLog;\n    protected long startTime;\n    protected String[] execCommand;\n    protected String execCommandStr;\n    protected boolean logExecution;\n\n    public interface ExtCmdCondition {\n        boolean check();\n    }\n\n    public interface ExtCmdEndedListener {\n        void onEnd(OutputData data);\n    }\n\n    public static class OutputData {\n        public final String stdout;\n        public final String stderr;\n        public final int exitCode;\n\n        public OutputData(String stdout, String stderr, int exitCode) {\n            this.stdout = stdout;\n            this.stderr = stderr;\n            this.exitCode = exitCode;\n        }\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect redirect, File workingDir, String... args) {\n        // Implementation of exec method\n        return null;\n    }\n\n    public OutputData syncProcess() {\n        // Implementation of syncProcess method\n        return null;\n    }\n\n    protected void checkForConditions() {\n        // Implementation of checkForConditions method\n    }\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "wrong_result": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n    private static final String ROUTING_KEY = \"example_queue\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n    }\n\n    public void initializeConnection() throws Exception {\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Received: \" + message);\n        };\n        channel.basicConsume(ROUTING_KEY, true, deliverCallback, consumerTag -> {});\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class LettuceRedisUtils {\n    private static final RedisClient REDIS_CLIENT = RedisClient.create(\"redis://localhost:6379\");\n    private static final LettuceRedisUtils INSTANCE = new LettuceRedisUtils();\n\n    private LettuceRedisUtils() {}\n\n    public static LettuceRedisUtils getInstance() {\n        return INSTANCE;\n    }\n\n    public void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<String, String> connection = REDIS_CLIENT.connect();\n        RedisPipeline pipeline = connection.pipeline();\n        List<RedisFuture<?>> futures = pipelineCallBack.execute(pipeline);\n        connection.close();\n        for (RedisFuture<?> future : futures) {\n            try {\n                future.get();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public interface RedisPipelineCallBack {\n        List<RedisFuture<?>> execute(RedisPipeline pipeline);\n    }\n}"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing methods to establish, close, and create new connections with configurable protocols.\n\nClass Description: The RedisConnectionManager class handles Redis connection management using Jedis, allowing for protocol configuration and providing essential connection operations. It encapsulates connection details and offers methods for connection lifecycle management.\n\nAttributes:\n\nendpoint: [EndpointConfig] - Configuration for Redis connection endpoint (host, port, etc.)\nprotocol: [RedisProtocol] - The Redis protocol to be used for connections\njedis: [Jedis] - The Jedis client instance for Redis operations\n\nMethods:\n\nsetUpConnection: [void]() -> [void] - Establishes a new Redis connection with the configured protocol and timeout, and flushes all existing data\ncloseConnection: [void]() -> [void] - Closes the current Redis connection and releases resources\ncreateNewConnection: [Jedis]() -> [Jedis] - Creates and returns a new Jedis connection instance with the configured protocol",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.HostAndPorts;\nimport redis.clients.jedis.RedisProtocol;\nimport redis.clients.jedis.EndpointConfig;\n\npublic class RedisConnectionManager {\n\n    protected static final EndpointConfig endpoint = HostAndPorts.getRedisEndpoint(\"standalone0\");\n    protected final RedisProtocol protocol;\n    protected Jedis jedis;\n\n    public RedisConnectionManager(RedisProtocol protocol) {\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() throws Exception {\n        jedis = new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).timeoutMillis(500).build());\n        jedis.flushAll();\n    }\n\n    public void closeConnection() throws Exception {\n        jedis.close();\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).build());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private EndpointConfig endpoint;\n    private RedisProtocol protocol;\n    private Jedis jedis;\n\n    public RedisConnectionManager(EndpointConfig endpoint, RedisProtocol protocol) {\n        this.endpoint = endpoint;\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() {\n        closeConnection();\n        jedis = createNewConnection();\n        jedis.flushAll();\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n            jedis = null;\n        }\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHost(), endpoint.getPort(), endpoint.getTimeout(), protocol.getProtocol());\n    }\n\n    public Jedis getJedis() {\n        return jedis;\n    }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.concurrent.TimeUnit;\n\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.util.WriteReadyHandler;\nimport io.undertow.conduits.StreamSinkConduit;\nimport io.undertow.io.XnioIoThread;\nimport io.undertow.io.XnioWorker;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = true;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel src, long position, long count) throws IOException {\n        return fileChannel.transferFrom(src, position, count);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel src, long count, ByteBuffer throughBuffer) throws IOException {\n        return fileChannel.transferFrom(src, count, throughBuffer);\n    }\n\n    @Override\n    public int write(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() {\n        try {\n            fileChannel.close();\n        } catch (IOException e) {\n            // Handle exception if needed\n        }\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        try {\n            return fileChannel.isOpen();\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n        if (writeReadyHandler != null) {\n            writeReadyHandler.writeReady();\n        }\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writeReadyHandler.writeReady();\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n        // No-op implementation\n    }\n\n    @Override\n    public void awaitWritable(long timeout, TimeUnit unit) throws IOException {\n        // No-op implementation\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getConnection().getWorker().getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        this.writeReadyHandler = handler;\n    }\n\n    @Override\n    public void truncateWrites() {\n        terminateWrites();\n    }\n\n    @Override\n    public boolean flush() {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a reliable Redis transaction handler class that manages MULTI/EXEC transactions, WATCH/UNWATCH operations, and connection handling in a Java application using Jedis client library.\n\nClass Description: The ReliableTransaction class provides a robust wrapper around Redis transactions, offering atomic operations, watch mechanisms for optimistic locking, and proper resource management. It handles the complete transaction lifecycle including initiation, command queuing, execution, and cleanup.\n\nAttributes:\n- pipelinedResponses: Queue<Response<?>> - Stores responses for queued commands in a transaction\n- connection: Connection - The Redis connection instance\n- closeConnection: boolean - Flag indicating whether to close the connection when done\n- broken: boolean - Indicates if the connection is in a broken state\n- inWatch: boolean - Tracks WATCH status\n- inMulti: boolean - Tracks MULTI status\n- commandObjects: CommandObjects - Provides command building functionality\n\nMethods:\n- ReliableTransaction(Connection, boolean, boolean, CommandObjects) -> void - Constructor that initializes the transaction handler\n- multi() -> void - Starts a Redis MULTI transaction\n- watch(String...) -> String - Watches given keys for changes (optimistic locking)\n- unwatch() -> String - Removes all watched keys\n- appendCommand(CommandObject<T>) -> Response<T> - Adds a command to the transaction queue\n- close() -> void - Cleans up and optionally closes the connection\n- clear() -> void - Clears current transaction or watch state\n- exec() -> List<Object> - Executes all queued commands atomically\n- discard() -> String - Discards all commands in the current transaction",
    "Canonical_solution": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.JedisConnectionException;\nimport redis.clients.jedis.JedisDataException;\nimport redis.clients.jedis.JedisException;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.graph.GraphCommandObjects;\nimport redis.clients.jedis.util.RedisProtocol;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ReliableTransaction {\n\n    private static final String QUEUED_STR = \"QUEUED\";\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    protected final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean doMulti, boolean closeConnection, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        GraphCommandObjects graphCommandObjects = new GraphCommandObjects(this.connection);\n        graphCommandObjects.setBaseCommandArgumentsCreator(protocolCommand -> commandObjects.commandArguments(protocolCommand));\n        if (doMulti) multi();\n    }\n\n    public void multi() {\n        connection.sendCommand(Command.MULTI);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"MULTI command failed. Received response: \" + status);\n        }\n        inMulti = true;\n    }\n\n    public String watch(final String... keys) {\n        String status = connection.executeCommand(commandObjects.watch(keys));\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        connection.sendCommand(Command.UNWATCH);\n        String status = connection.getStatusCodeReply();\n        inWatch = false;\n        return status;\n    }\n\n    protected <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        connection.sendCommand(commandObject.getArguments());\n        String status = connection.getStatusCodeReply();\n        if (!QUEUED_STR.equals(status)) {\n            throw new JedisException(status);\n        }\n        Response<T> response = new Response<>(commandObject.getBuilder());\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        try {\n            clear();\n        } finally {\n            if (closeConnection) {\n                connection.close();\n            }\n        }\n    }\n\n    public void clear() {\n        if (broken) return;\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) throw new IllegalStateException(\"EXEC without MULTI\");\n\n        try {\n            connection.sendCommand(Command.EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                pipelinedResponses.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size());\n            for (Object o : unformatted) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    response.set(o);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            connection.sendCommand(Command.DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.CommandObject;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class ReliableTransaction {\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    private final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken;\n    private boolean inWatch;\n    private boolean inMulti;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean closeConnection, boolean broken, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.broken = broken;\n        this.commandObjects = commandObjects;\n    }\n\n    public void multi() {\n        if (inMulti || broken) return;\n        inMulti = true;\n        connection.sendCommand(commandObjects.getMulti());\n    }\n\n    public String watch(String... keys) {\n        if (broken) return null;\n        if (!inWatch) {\n            connection.sendCommand(commandObjects.getWatch());\n            inWatch = true;\n        }\n        for (String key : keys) {\n            connection.sendCommand(commandObjects.getWatchKey(), key);\n        }\n        return \"WATCH\";\n    }\n\n    public String unwatch() {\n        if (broken) return null;\n        if (inWatch) {\n            connection.sendCommand(commandObjects.getUnwatch());\n            inWatch = false;\n        }\n        return \"UNWATCH\";\n    }\n\n    public <T> Response<T> appendCommand(CommandObject<T> command) {\n        if (broken || !inMulti) return null;\n        Response<T> response = new Response<>(command.getCommandName());\n        pipelinedResponses.add(response);\n        connection.sendCommand(command);\n        return response;\n    }\n\n    public void close() {\n        if (closeConnection) {\n            connection.close();\n        }\n    }\n\n    public void clear() {\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (broken || !inMulti) return null;\n        List<Object> results = new LinkedList<>();\n        connection.sendCommand(commandObjects.getExec());\n        for (Response<?> response : pipelinedResponses) {\n            results.add(response.get());\n        }\n        inMulti = false;\n        return results;\n    }\n\n    public String discard() {\n        if (broken || !inMulti) return null;\n        connection.sendCommand(commandObjects.getDiscard());\n        pipelinedResponses.clear();\n        inMulti = false;\n        return \"DISCARD\";\n    }\n}"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Implement a Redis-based registry class for node registration and subscription in a distributed system, using Java with Jedis client library.\n\nClass Description: RedisRegistry is a class that provides node registration and subscription capabilities using Redis as the backend storage. It maintains connections to Redis servers, handles node registration, and manages subscription to node changes.\n\nAttributes:\n- jedisPools: ConcurrentHashMap<String, JedisPool> - A thread-safe map storing JedisPool instances for different Redis server addresses\n- clusterName: String - The name of the current cluster\n- replicate: boolean - Flag indicating whether operations should be replicated to all Redis servers\n- notifiers: ConcurrentMap<String, Notifier> - A thread-safe map storing Notifier instances for different node paths\n\nMethods:\n- RedisRegistry(AppContext appContext) - Constructor - Initializes the registry with configuration from AppContext\n  Input: appContext: AppContext - The application context containing configuration\n  Output: None\n\n- doRegister(Node node) - protected - Registers a node in Redis\n  Input: node: Node - The node to be registered\n  Output: None (throws NodeRegistryException on failure)\n\n- doSubscribe(Node node, NotifyListener listener) - protected - Subscribes to node changes\n  Input: \n    node: Node - The node that wants to subscribe\n    listener: NotifyListener - The listener to be notified of changes\n  Output: None\n\nNested Classes:\n- NotifySub extends JedisPubSub - Handles Redis pub/sub messages\n  Methods:\n    onMessage(String key, String msg) - Processes incoming messages\n      Input:\n        key: String - The channel/key of the message\n        msg: String - The message content\n      Output: None\n\n- Notifier extends Thread - Manages subscription thread\n  Methods:\n    run() - Main thread execution for subscription\n      Input: None\n      Output: None\n    shutdown() - Stops the subscription thread\n      Input: None\n      Output: None",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.cluster.Config;\nimport com.github.ltsopensource.core.cluster.Node;\nimport com.github.ltsopensource.core.cluster.NodeType;\nimport com.github.ltsopensource.core.commons.utils.CollectionUtils;\nimport com.github.ltsopensource.core.constant.Constants;\nimport com.github.ltsopensource.core.exception.NodeRegistryException;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport com.github.ltsopensource.core.registry.NotifyEvent;\nimport com.github.ltsopensource.core.registry.NotifyListener;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class RedisRegistry {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisRegistry.class);\n    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();\n    private String clusterName;\n    private boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();\n\n    public RedisRegistry(AppContext appContext) {\n        Config config = appContext.getConfig();\n        this.clusterName = config.getClusterName();\n\n        String address = NodeRegistryUtils.getRealRegistryAddress(config.getRegistryAddress());\n        String[] addrs = address.split(\",\");\n        for (String addr : addrs) {\n            int i = addr.indexOf(':');\n            String host = addr.substring(0, i);\n            int port = Integer.parseInt(addr.substring(i + 1));\n            this.jedisPools.put(addr, new JedisPool(new JedisPoolConfig(), host, port, Constants.DEFAULT_TIMEOUT));\n        }\n    }\n\n    protected void doRegister(Node node) {\n        String key = NodeRegistryUtils.getNodeTypePath(clusterName, node.getNodeType());\n        boolean success = false;\n        NodeRegistryException exception = null;\n        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n            JedisPool jedisPool = entry.getValue();\n            try {\n                Jedis jedis = jedisPool.getResource();\n                try {\n                    jedis.hset(key, node.toFullString(), String.valueOf(SystemClock.now() + Constants.DEFAULT_SESSION_TIMEOUT));\n                    jedis.publish(key, Constants.REGISTER);\n                    success = true;\n                    if (!replicate) {\n                        break;\n                    }\n                } finally {\n                    jedis.close();\n                }\n            } catch (Throwable t) {\n                exception = new NodeRegistryException(\"Failed to register node to redis registry. registry: \" + entry.getKey() + \", node: \" + node + \", cause: \" + t.getMessage(), t);\n            }\n        }\n        if (exception != null && !success) {\n            throw exception;\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        List<NodeType> listenNodeTypes = node.getListenNodeTypes();\n        if (CollectionUtils.isEmpty(listenNodeTypes)) {\n            return;\n        }\n        for (NodeType listenNodeType : listenNodeTypes) {\n            String listenNodePath = NodeRegistryUtils.getNodeTypePath(clusterName, listenNodeType);\n            Notifier notifier = notifiers.get(listenNodePath);\n            if (notifier == null) {\n                Notifier newNotifier = new Notifier(listenNodePath);\n                notifiers.putIfAbsent(listenNodePath, newNotifier);\n                notifier = notifiers.get(listenNodePath);\n                if (notifier == newNotifier) {\n                    notifier.start();\n                }\n            }\n        }\n    }\n\n    private class NotifySub extends JedisPubSub {\n        private final JedisPool jedisPool;\n\n        public NotifySub(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) {\n                try {\n                    Jedis jedis = jedisPool.getResource();\n                    try {\n                        doNotify(jedis, key);\n                    } finally {\n                        jedis.close();\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String listenNodePath;\n        private volatile Jedis jedis;\n        private volatile boolean running = true;\n\n        public Notifier(String listenNodePath) {\n            super.setDaemon(true);\n            super.setName(\"LTSRedisSubscribe\");\n            this.listenNodePath = listenNodePath;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (running) {\n                    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                        try {\n                            JedisPool jedisPool = entry.getValue();\n                            jedis = jedisPool.getResource();\n                            try {\n                                jedis.subscribe(new NotifySub(jedisPool), listenNodePath);\n                                break;\n                            } finally {\n                                jedis.close();\n                            }\n                        } catch (Throwable t) {\n                            LOGGER.warn(\"Failed to subscribe node from redis registry. registry: \" + entry.getKey(), t);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                LOGGER.error(t.getMessage(), t);\n            }\n        }\n\n        public void shutdown() {\n            try {\n                running = false;\n                jedis.disconnect();\n            } catch (Throwable t) {\n                LOGGER.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class RedisRegistry {\n    protected ConcurrentHashMap<String, JedisPool> jedisPools;\n    protected String clusterName;\n    protected boolean replicate;\n    protected ConcurrentMap<String, Notifier> notifiers;\n\n    public RedisRegistry(AppContext appContext) {\n        this.jedisPools = new ConcurrentHashMap<>();\n        this.clusterName = appContext.getClusterName();\n        this.replicate = appContext.isReplicate();\n        this.notifiers = new ConcurrentHashMap<>();\n    }\n\n    protected void doRegister(Node node) throws NodeRegistryException {\n        for (String redisServer : jedisPools.keySet()) {\n            try (Jedis jedis = jedisPools.get(redisServer).getResource()) {\n                String key = \"node:\" + node.getId();\n                jedis.set(key, node.toString());\n                if (replicate) {\n                    jedis.publish(\"node:register\", key);\n                }\n            } catch (Exception e) {\n                throw new NodeRegistryException(\"Failed to register node: \" + node.getId(), e);\n            }\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        String channel = \"node:\" + node.getPath();\n        Notifier notifier = notifiers.computeIfAbsent(channel, k -> new Notifier(k, listener));\n        notifier.start();\n    }\n\n    protected class NotifySub extends JedisPubSub {\n        @Override\n        public void onMessage(String key, String msg) {\n            // Process incoming messages\n        }\n    }\n\n    protected class Notifier extends Thread {\n        private final String channel;\n        private final NotifyListener listener;\n        private volatile boolean running = true;\n\n        public Notifier(String channel, NotifyListener listener) {\n            this.channel = channel;\n            this.listener = listener;\n        }\n\n        @Override\n        public void run() {\n            while (running) {\n                try (Jedis jedis = jedisPools.values().iterator().next().getResource()) {\n                    jedis.subscribe(new NotifySub(), channel);\n                } catch (Exception e) {\n                    // Handle exception\n                }\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n            interrupt();\n        }\n    }\n}\n\nclass AppContext {\n    public String getClusterName() {\n        return \"default-cluster\";\n    }\n\n    public boolean isReplicate() {\n        return true;\n    }\n}\n\nclass Node {\n    private String id;\n    private String path;\n\n    public Node(String id, String path) {\n        this.id = id;\n        this.path = path;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"id='\" + id + '\\'' +\n                \", path='\" + path + '\\'' +\n                '}';\n    }\n}\n\ninterface NotifyListener {\n    void onNotify(String message);\n}\n\nclass NodeRegistryException extends Exception {\n    public NodeRegistryException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Implement a Redis connection class in Java that handles socket communication, authentication, and basic Redis operations while managing connection state and resources.\n\nClass Description: The Connection class represents a Redis client connection that manages socket communication with a Redis server. It handles connection establishment, command sending, response reading, and connection cleanup. The class implements Closeable for proper resource management.\n\nAttributes:\n- socketFactory: JedisSocketFactory - Factory for creating socket connections to Redis\n- socket: Socket - The underlying socket connection to Redis\n- outputStream: RedisOutputStream - Output stream for sending commands to Redis\n- inputStream: RedisInputStream - Input stream for reading responses from Redis\n- soTimeout: int - Socket timeout setting\n- broken: boolean - Flag indicating if the connection is in a broken state\n- currentCredentials: AtomicReference<RedisCredentials> - Current authentication credentials\n- authXManager: AuthXManager - Manager for authentication operations\n\nMethods:\n- Connection(JedisSocketFactory) -> void - Constructor that initializes with a socket factory\n- connect() -> void - Establishes connection to Redis server\n- disconnect() -> void - Closes the connection to Redis server\n- isConnected() -> boolean - Checks if connection is active\n- isBroken() -> boolean - Checks if connection is in broken state\n- setBroken() -> void - Marks connection as broken\n- sendCommand(ProtocolCommand, byte[]...) -> void - Sends a Redis command with arguments\n- getOne() -> Object - Reads and returns a single response from Redis\n- flush() -> void - Flushes the output stream\n- readProtocolWithCheckingBroken() -> Object - Reads protocol response while checking connection state\n- close() -> void - Implements Closeable interface to disconnect (alias for disconnect)",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Protocol.Keyword;\nimport redis.clients.jedis.args.Rawable;\nimport redis.clients.jedis.authentication.AuthXManager;\nimport redis.clients.jedis.commands.ProtocolCommand;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\nimport redis.clients.jedis.util.RedisInputStream;\nimport redis.clients.jedis.util.RedisOutputStream;\n\npublic class Connection implements Closeable {\n\n  private final JedisSocketFactory socketFactory;\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n  private int soTimeout = 0;\n  private boolean broken = false;\n  private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>(null);\n  private AuthXManager authXManager;\n\n  public Connection(final JedisSocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n  }\n\n  public void connect() throws JedisConnectionException {\n    if (!isConnected()) {\n      try {\n        socket = socketFactory.createSocket();\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n      } catch (JedisConnectionException jce) {\n        setBroken();\n        throw jce;\n      } catch (IOException ioe) {\n        setBroken();\n        throw new JedisConnectionException(\"Failed to create input/output stream\", ioe);\n      } finally {\n        if (broken) {\n          IOUtils.closeQuietly(socket);\n        }\n      }\n    }\n  }\n\n  public void disconnect() {\n    if (isConnected()) {\n      try {\n        outputStream.flush();\n        socket.close();\n      } catch (IOException ex) {\n        throw new JedisConnectionException(ex);\n      } finally {\n        IOUtils.closeQuietly(socket);\n        setBroken();\n      }\n    }\n  }\n\n  public boolean isConnected() {\n    return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()\n        && !socket.isInputShutdown() && !socket.isOutputShutdown();\n  }\n\n  public boolean isBroken() {\n    return broken;\n  }\n\n  public void setBroken() {\n    broken = true;\n  }\n\n  public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {\n    try {\n      connect();\n      Protocol.sendCommand(outputStream, new CommandArguments(cmd).addObjects((Object[]) args));\n    } catch (JedisConnectionException ex) {\n      setBroken();\n      throw ex;\n    }\n  }\n\n  public Object getOne() {\n    flush();\n    return readProtocolWithCheckingBroken();\n  }\n\n  protected void flush() {\n    try {\n      outputStream.flush();\n    } catch (IOException ex) {\n      setBroken();\n      throw new JedisConnectionException(ex);\n    }\n  }\n\n  protected Object readProtocolWithCheckingBroken() {\n    if (broken) {\n      throw new JedisConnectionException(\"Attempting to read from a broken connection.\");\n    }\n    try {\n      return Protocol.read(inputStream);\n    } catch (JedisConnectionException exc) {\n      broken = true;\n      throw exc;\n    }\n  }\n\n  @Override\n  public void close() {\n    disconnect();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.io.IOException;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class Connection implements AutoCloseable {\n    protected JedisSocketFactory socketFactory;\n    protected Socket socket;\n    protected RedisOutputStream outputStream;\n    protected RedisInputStream inputStream;\n    protected int soTimeout;\n    protected boolean broken;\n    protected AtomicReference<RedisCredentials> currentCredentials;\n    protected AuthXManager authXManager;\n\n    public Connection(JedisSocketFactory socketFactory) {\n        this.socketFactory = socketFactory;\n        this.currentCredentials = new AtomicReference<>();\n        this.authXManager = new AuthXManager();\n    }\n\n    public void connect() throws IOException {\n        if (socket != null && !socket.isClosed()) {\n            return;\n        }\n        socket = socketFactory.createSocket();\n        socket.setSoTimeout(soTimeout);\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n    }\n\n    public void disconnect() {\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                // Handle exception\n            } finally {\n                socket = null;\n                outputStream = null;\n                inputStream = null;\n            }\n        }\n    }\n\n    public boolean isConnected() {\n        return socket != null && !socket.isClosed() && !broken;\n    }\n\n    public boolean isBroken() {\n        return broken;\n    }\n\n    public void setBroken() {\n        broken = true;\n    }\n\n    public void sendCommand(ProtocolCommand command, byte[]... args) throws IOException {\n        if (!isConnected()) {\n            throw new IOException(\"Connection is not active\");\n        }\n        outputStream.writeCommand(command, args);\n    }\n\n    public Object getOne() throws IOException {\n        return readProtocolWithCheckingBroken();\n    }\n\n    public void flush() throws IOException {\n        outputStream.flush();\n    }\n\n    protected Object readProtocolWithCheckingBroken() throws IOException {\n        if (isBroken()) {\n            throw new IOException(\"Connection is broken\");\n        }\n        return inputStream.readProtocol();\n    }\n\n    @Override\n    public void close() {\n        disconnect();\n    }\n}"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Create a singleton Redis client class that manages a single Redis connection instance throughout the application lifecycle, with automatic shutdown handling.\n\nClass Description: DefaultRedisClient is a singleton class that provides centralized Redis client management. It creates and maintains a single RedisClient instance, configures default timeout settings, and ensures proper resource cleanup during JVM shutdown.\n\nAttributes:\n- instance: DefaultRedisClient - The singleton instance of the class\n- redisClient: RedisClient - The underlying Redis client connection instance\n\nMethods:\n- get() -> RedisClient - Returns the singleton RedisClient instance after setting a default timeout of 60 seconds\n- DefaultRedisClient() (constructor) - Private constructor that initializes the RedisClient with connection settings and registers a shutdown hook\n- run() (in anonymous Thread class) - Shutdown hook method that cleans up Redis client resources during JVM shutdown",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.TimeUnit;\n\npublic class DefaultRedisClient {\n\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(RedisURI.Builder.redis(TestSettings.host(), TestSettings.port()).build());\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                FastShutdown.shutdown(redisClient);\n            }\n        });\n    }\n\n    public static RedisClient get() {\n        instance.redisClient.setDefaultTimeout(60, TimeUnit.SECONDS);\n        return instance.redisClient;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class DefaultRedisClient {\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(\"redis://localhost:6379\");\n        redisClient.setOptions(\n            RedisClient.create()\n                .setSocketTimeout(Duration.ofSeconds(60))\n                .setConnectTimeout(Duration.ofSeconds(60))\n        );\n        Runtime.getRuntime().addShutdownHook(new Thread(this::run));\n    }\n\n    public static DefaultRedisClient get() {\n        return instance;\n    }\n\n    public RedisClient getRedisClient() {\n        return redisClient;\n    }\n\n    private void run() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class TranslogReader extends BaseTranslogReader implements Closeable {\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel fileChannel, Path path, TranslogHeader header) {\n        super(fileChannel, path, header);\n        this.checkpoint = checkpoint;\n        this.length = fileChannel.size();\n        this.totalOperations = calculateTotalOperations();\n    }\n\n    public static TranslogReader open(FileChannel fileChannel, Path path, Checkpoint checkpoint, String id) {\n        return new TranslogReader(checkpoint, fileChannel, path, new TranslogHeader(id));\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long sequenceNumber, ChannelFactory channelFactory) {\n        if (closed.get()) {\n            throw new AlreadyClosedException(\"Cannot trim a closed reader\");\n        }\n        try {\n            fileChannel.close();\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"Failed to close file channel\", e);\n        }\n        Path trimmedPath = path.resolveSibling(path.getFileName() + \"-trimmed\");\n        try (FileChannel newChannel = channelFactory.open(trimmedPath, StandardOpenOption.CREATE_NEW)) {\n            // Trim logic here\n            Checkpoint newCheckpoint = checkpoint.update(sequenceNumber);\n            return new TranslogReader(newCheckpoint, newChannel, trimmedPath, header);\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"Failed to create trimmed translog reader\", e);\n        }\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) {\n        ensureOpen();\n        if (position < 0 || position >= length) {\n            throw new IndexOutOfBoundsException(\"Position \" + position + \" is out of bounds for translog of length \" + length);\n        }\n        try {\n            fileChannel.read(buffer, position);\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"Failed to read bytes from translog at position \" + position, e);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                fileChannel.close();\n            } catch (IOException e) {\n                throw new ElasticsearchException(\"Failed to close translog reader\", e);\n            }\n        }\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (closed.get()) {\n            throw new AlreadyClosedException(\"Translog reader is already closed\");\n        }\n    }\n\n    private int calculateTotalOperations() {\n        // Logic to compute the number of operations based on the header and log content\n        return 0;\n    }\n}"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.time.Duration;\nimport java.time.Instant;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Logger;\n\npublic class ClusterCommandExecutor<T> {\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public T broadcastCommand(CommandObject<T> commandObject) {\n        // Implementation for broadcasting a command to all nodes\n        return null;\n    }\n\n    public T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        int attempts = 0;\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n        AtomicInteger consecutiveConnectionFailures = new AtomicInteger(0);\n\n        while (attempts < maxAttempts) {\n            try {\n                Connection connection = provider.getConnection(toReplica);\n                T result = execute(connection, commandObject);\n                return result;\n            } catch (Exception e) {\n                log.severe(\"Error executing command: \" + e.getMessage());\n                if (!handleConnectionProblem(maxAttempts - attempts, consecutiveConnectionFailures.get(), deadline)) {\n                    throw new RuntimeException(\"Failed to execute command after retries\", e);\n                }\n                attempts++;\n            }\n        }\n        throw new RuntimeException(\"Max retry attempts exceeded\");\n    }\n\n    private T execute(Connection connection, CommandObject<T> commandObject) {\n        // Implementation for executing a command on a specific connection\n        return null;\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        if (consecutiveConnectionFailures > 3) {\n            log.warning(\"Too many consecutive connection failures, renewing slot cache\");\n            provider.renewSlotCache();\n            consecutiveConnectionFailures = 0;\n        }\n        long sleepMillis = getBackoffSleepMillis(attemptsLeft, doneDeadline);\n        sleep(sleepMillis);\n        return true;\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        long remainingTime = Duration.between(Instant.now(), deadline).toMillis();\n        if (remainingTime <= 0) {\n            return 0;\n        }\n        long sleepMillis = (long) Math.min(1000 * Math.pow(2, maxAttempts - attemptsLeft), remainingTime);\n        return sleepMillis;\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Sleep interrupted\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport io.protostuff.Schema;\nimport io.protostuff.runtime.RuntimeSchema;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private final Schema<Seckill> schema = RuntimeSchema.getSchema(Seckill.class);\n    private final Lock lock = new ReentrantLock();\n\n    public RedisDao(String ip, int port) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return getSeckill(seckillId, jedis);\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        String key = getSeckillRedisKey(seckillId);\n        byte[] data = jedis.get(key.getBytes());\n        if (data != null) {\n            Seckill seckill = schema.newMessage();\n            schema.merge(data, seckill);\n            return seckill;\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        lock.lock();\n        try (Jedis jedis = jedisPool.getResource()) {\n            String key = getSeckillRedisKey(seckillId);\n            if (jedis.exists(key.getBytes())) {\n                return getSeckill(seckillId, jedis);\n            }\n            Seckill seckill = getDataFromDb.apply(seckillId);\n            if (seckill != null) {\n                putSeckill(seckill, jedis);\n            }\n            return seckill;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String putSeckill(Seckill seckill) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return putSeckill(seckill, jedis);\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        String key = getSeckillRedisKey(seckill.getSeckillId());\n        byte[] data = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n        return jedis.setex(key.getBytes(), 60, data);\n    }\n\n    public String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSession;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.HostAndPortMapper;\nimport redis.clients.jedis.JedisClientConfig;\n\npublic class DefaultJedisSocketFactory {\n    private HostAndPort hostAndPort;\n    private int connectionTimeout;\n    private int socketTimeout;\n    private boolean ssl;\n    private SSLSocketFactory sslSocketFactory;\n    private SSLParameters sslParameters;\n    private HostnameVerifier hostnameVerifier;\n    private HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this.hostAndPort = new HostAndPort(\"localhost\", 6379);\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = null;\n        this.hostnameVerifier = (hostname, session) -> true;\n        this.hostAndPortMapper = (hostAndPort) -> hostAndPort;\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = null;\n        this.hostnameVerifier = (hostname, session) -> true;\n        this.hostAndPortMapper = (hostAndPort) -> hostAndPort;\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this.hostAndPort = config.getHost();\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getSslHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getSslHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) {\n        HostAndPort mappedHost = hostAndPortMapper.map(hostAndPort);\n        String host = mappedHost.getHost();\n        int port = mappedHost.getPort();\n\n        try {\n            Socket socket = createSocket();\n            socket.connect(new InetSocketAddress(host, port), connectionTimeout);\n            socket.setSoTimeout(socketTimeout);\n            return socket;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Could not connect to Redis server at \" + host + \":\" + port, e);\n        }\n    }\n\n    private Socket createSocket() {\n        if (ssl) {\n            try {\n                SSLSocketFactory factory = sslSocketFactory != null ? sslSocketFactory : (SSLSocketFactory) SSLSocketFactory.getDefault();\n                Socket socket = factory.createSocket();\n                SSLParameters params = sslParameters != null ? sslParameters : new SSLParameters();\n                socket.setEnabledSSLParameters(params);\n                ((javax.net.ssl.SSLSocket) socket).setHostnameVerifier(hostnameVerifier);\n                return socket;\n            } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException e) {\n                throw new RuntimeException(\"Failed to create SSL socket\", e);\n            }\n        } else {\n            try {\n                return new Socket();\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to create plain socket\", e);\n            }\n        }\n    }\n\n    public HostAndPort getSocketHostAndPort() {\n        return hostAndPortMapper.map(hostAndPort);\n    }\n}"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a Java class for interacting with Redis using the Lettuce client, including connection management and data operations.\n\nClass Description: The RedisInteraction class provides functionality to establish and manage a connection to a Redis server, perform bulk data operations, and clean up resources. It uses the Lettuce client library for Redis interactions.\n\nAttributes:\n- client: RedisClient - The Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active connection to the Redis server\n\nMethods:\n- initializeConnection() -> void - Initializes the Redis client and establishes a connection to the Redis server. Also clears all existing data in Redis.\n- closeConnection() -> void - Closes the Redis connection and shuts down the client to release resources.\n- createRedisPublisher(long elements) -> Publisher<String> - Creates and returns a Publisher that streams Redis keys. Populates Redis with test data (number of elements specified by input parameter) before creating the publisher. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ScanStream;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public void closeConnection() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.flushall();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < elements; i++) {\n            String element = \"RedisInteraction-\" + i;\n            map.put(element, element);\n\n            if (i % 1000 - 2020 == 0 && !map.isEmpty()) {\n                sync.mset(map);\n                map.clear();\n            }\n        }\n\n        if (!map.isEmpty()) {\n            sync.mset(map);\n            map.clear();\n        }\n\n        return ScanStream.scan(connection.reactive());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisInteraction {\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(\"redis://localhost:6379\");\n        connection = client.connect();\n        RedisCommands<String, String> commands = connection.sync();\n        commands.flushall();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n        RedisCommands<String, String> commands = connection.sync();\n        for (long i = 0; i < elements; i++) {\n            commands.set(\"key\" + i, \"value\" + i);\n        }\n        return connection.async().keys(\"*\");\n    }\n}"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "@Configuration\n@EnableRedisRepositories\npublic class RedisConfig {\n\n    public static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer()\n                .setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort())\n                .setTimeout(3000)\n                .setPassword(redisProperties.getPassword());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            StringBuilder sb = new StringBuilder();\n            sb.append(target.getClass().getName()).append(\":\").append(method.getName());\n            if (params != null) {\n                for (Object param : params) {\n                    sb.append(\":\").append(param.toString());\n                }\n            }\n            return DigestUtils.sha256Hex(sb.toString());\n        };\n    }\n}"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a Java class that implements Redis client functionality using Jedis for basic key-value operations, hash operations, and key expiration management.\n\nClass Description: JedisClientSingle is a Redis client wrapper class that provides simplified access to common Redis operations using connection pooling. It handles connection management, authentication, and resource cleanup automatically.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- password: String - The password for Redis authentication (optional)\n- port: int - The port number of the Redis server\n- host: String - The host address of the Redis server\n- logger: Logger - SLF4J logger instance for logging operations\n\nMethods:\n- getResource() -> Jedis - Internal method to get a Jedis instance from the pool and authenticate if needed\n- get(String key) -> String - Retrieves the value associated with the given key\n- set(String key, String value) -> String - Sets the value for the given key\n- hget(String hkey, String key) -> String - Gets the value of a field in a hash\n- hset(String hkey, String key, String value) -> long - Sets the value of a field in a hash\n- incr(String key) -> long - Increments the integer value of a key by 1\n- expire(String key, Integer second) -> long - Sets a timeout on a key\n- ttl(String key) -> long - Gets the remaining time to live of a key\n- del(String key) -> long - Deletes a key\n- hdel(String hkey, String key) -> long - Deletes a field from a hash",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisClientSingle {\n\n    private static final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n\n    private Jedis getResource() {\n        if(jedisPool==null) {\n            jedisPool = new JedisPool(host, port);\n        }\n        Jedis resource = jedisPool.getResource();\n        if (StringUtils.isBlank(password)) {\n            return resource;\n        } else {\n            resource.auth(password);\n            return resource;\n        }\n    }\n\n    public String get(String key) {\n        Jedis resource = getResource();\n        String string = resource.get(key);\n        resource.close();\n        return string;\n    }\n\n    public String set(String key, String value) {\n        Jedis resource = getResource();\n        String string = resource.set(key, value);\n        resource.close();\n        return string;\n    }\n\n    public String hget(String hkey, String key) {\n        Jedis resource = getResource();\n        String string = resource.hget(hkey, key);\n        resource.close();\n        return string;\n    }\n\n    public long hset(String hkey, String key, String value) {\n        Jedis resource = getResource();\n        Long hset = resource.hset(hkey, key, value);\n        resource.close();\n        return hset;\n    }\n\n    public long incr(String key) {\n        Jedis resource = getResource();\n        Long incr = resource.incr(key);\n        resource.close();\n        return incr;\n    }\n\n    public long expire(String key, Integer second) {\n        Jedis resource = getResource();\n        Long expire = resource.expire(key, second);\n        resource.close();\n        return expire;\n    }\n\n    public long ttl(String key) {\n        Jedis resource = getResource();\n        Long ttl = resource.ttl(key);\n        resource.close();\n        return ttl;\n    }\n\n    public long del(String key) {\n        Jedis resource = getResource();\n        Long del = resource.del(key);\n        resource.close();\n        return del;\n    }\n\n    public long hdel(String hkey, String key) {\n        Jedis resource = getResource();\n        Long hdel = resource.hdel(hkey, key);\n        resource.close();\n        return hdel;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class JedisClientSingle {\n    private final JedisPool jedisPool;\n    private final String password;\n    private final int port;\n    private final String host;\n    private final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    public JedisClientSingle(String host, int port, String password) {\n        this.host = host;\n        this.port = port;\n        this.password = password;\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port);\n    }\n\n    private Jedis getResource() {\n        Jedis jedis = jedisPool.getResource();\n        if (password != null && !password.isEmpty()) {\n            jedis.auth(password);\n        }\n        return jedis;\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.get(key);\n        } catch (Exception e) {\n            logger.error(\"Error getting key: {}\", key, e);\n            return null;\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.set(key, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting key: {}\", key, e);\n            return null;\n        }\n    }\n\n    public String hget(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hget(hkey, key);\n        } catch (Exception e) {\n            logger.error(\"Error getting hash field: {} in hash: {}\", key, hkey, e);\n            return null;\n        }\n    }\n\n    public long hset(String hkey, String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hset(hkey, key, value);\n        } catch (Exception e) {\n            logger.error(\"Error setting hash field: {} in hash: {}\", key, hkey, e);\n            return -1;\n        }\n    }\n\n    public long incr(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.incr(key);\n        } catch (Exception e) {\n            logger.error(\"Error incrementing key: {}\", key, e);\n            return -1;\n        }\n    }\n\n    public long expire(String key, Integer second) {\n        try (Jedis jedis = getResource()) {\n            return jedis.expire(key, second);\n        } catch (Exception e) {\n            logger.error(\"Error setting expiration on key: {}\", key, e);\n            return -1;\n        }\n    }\n\n    public long ttl(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.ttl(key);\n        } catch (Exception e) {\n            logger.error(\"Error getting TTL for key: {}\", key, e);\n            return -1;\n        }\n    }\n\n    public long del(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.del(key);\n        } catch (Exception e) {\n            logger.error(\"Error deleting key: {}\", key, e);\n            return -1;\n        }\n    }\n\n    public long hdel(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hdel(hkey, key);\n        } catch (Exception e) {\n            logger.error(\"Error deleting hash field: {} in hash: {}\", key, hkey, e);\n            return -1;\n        }\n    }\n}"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class RedisConnectionFactory {\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers = new ArrayList<>();\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public void init() {\n        if (isCluster) {\n            cluster = createCluster();\n        } else {\n            if (redisServers.isEmpty()) {\n                pool = createRedisPool();\n            } else {\n                pool = createRedisSentinelPool();\n            }\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    private Jedis fetchJedisConnector() {\n        try {\n            return pool.getResource();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to fetch Jedis connection from pool\", e);\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (redisServers.isEmpty()) {\n            return createRedisPool();\n        } else {\n            return createRedisSentinelPool();\n        }\n    }\n\n    private Pool<Jedis> createRedisSentinelPool() {\n        List<JedisShardInfo> shardInfos = new ArrayList<>();\n        for (RedisNode node : redisServers) {\n            JedisShardInfo info = new JedisShardInfo(node.getHost(), node.getPort());\n            if (password != null) {\n                info.setPassword(password);\n            }\n            shardInfos.add(info);\n        }\n        return new JedisPool(poolConfig, shardInfos);\n    }\n\n    private Pool<Jedis> createRedisPool() {\n        JedisShardInfo info = new JedisShardInfo(hostName, port);\n        if (password != null) {\n            info.setPassword(password);\n        }\n        return new JedisPool(poolConfig, info);\n    }\n\n    private JedisCluster createCluster() {\n        List<HostAndPort> nodes = new ArrayList<>();\n        for (RedisNode node : redisServers) {\n            nodes.add(new HostAndPort(node.getHost(), node.getPort()));\n        }\n        return new JedisCluster(nodes, timeout, timeout, 5, password, dbIndex);\n    }\n\n    public Jedis getJedisConnection() {\n        return fetchJedisConnector();\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n\n    // Getters and setters\n    public String getHostName() {\n        return hostName;\n    }\n\n    public void setHostName(String hostName) {\n        this.hostName = hostName;\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public void setPort(int port) {\n        this.port = port;\n    }\n\n    public int getTimeout() {\n        return timeout;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getSentinelMaster() {\n        return sentinelMaster;\n    }\n\n    public void setSentinelMaster(String sentinelMaster) {\n        this.sentinelMaster = sentinelMaster;\n    }\n\n    public List<RedisNode> getRedisServers() {\n        return redisServers;\n    }\n\n    public void setRedisServers(List<RedisNode> redisServers) {\n        this.redisServers = redisServers;\n    }\n\n    public boolean isCluster() {\n        return isCluster;\n    }\n\n    public void setCluster(boolean cluster) {\n        isCluster = cluster;\n    }\n\n    public int getDbIndex() {\n        return dbIndex;\n    }\n\n    public void setDbIndex(int dbIndex) {\n        this.dbIndex = dbIndex;\n    }\n\n    public JedisShardInfo getShardInfo() {\n        return shardInfo;\n    }\n\n    public void setShardInfo(JedisShardInfo shardInfo) {\n        this.shardInfo = shardInfo;\n    }\n\n    public JedisPoolConfig getPoolConfig() {\n        return poolConfig;\n    }\n\n    public void setPoolConfig(JedisPoolConfig poolConfig) {\n        this.poolConfig = poolConfig;\n    }\n}"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a Redis sharding client in Java that distributes keys across multiple Redis instances using consistent hashing, with support for basic CRUD operations and command execution.\n\nClass Description: JedisSharding is a Redis client wrapper that implements sharding across multiple Redis instances. It uses consistent hashing to distribute keys and automatically manages connections to the appropriate shard for each operation.\n\nAttributes:\n- shards: List<HostAndPort> - List of Redis server addresses and ports for sharding\n- clientConfig: JedisClientConfig - Configuration for Redis client connections\n- hashing: Hashing - Hashing algorithm used for key distribution (defaults to MURMUR_HASH)\n\nMethods:\n- JedisSharding(List<HostAndPort>, JedisClientConfig) -> void - Constructor with default hashing algorithm\n- JedisSharding(List<HostAndPort>, JedisClientConfig, Hashing) -> void - Constructor with custom hashing algorithm\n- set(String, String) -> String - Stores a key-value pair in the appropriate shard\n- get(String) -> String - Retrieves a value from the appropriate shard\n- sendCommand(String, Protocol.Command, String...) -> Object - Sends a raw Redis command to the appropriate shard\n- close() -> void - Cleans up resources (no-op as connections are managed per-operation)\n- getShard(String) -> Jedis - Internal method to get a connection to the correct shard\n- getShardIndex(String) -> int - Internal method to calculate shard index for a key",
    "Canonical_solution": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.util.Hashing;\nimport java.util.List;\n\npublic class JedisSharding implements AutoCloseable {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort shard = shards.get(shardIndex);\n        Jedis jedis = new Jedis(shard, clientConfig);\n        if (shard.getPassword() != null) {\n            jedis.auth(shard.getPassword());\n        }\n        return jedis;\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return (int) (hash % shards.size());\n    }\n\n    @Override\n    public void close() {\n        // Connection cleanup handled by try-with-resources in individual operations\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.*;\nimport redis.clients.jedis.sharding.*;\nimport java.util.*;\n\npublic class JedisSharding {\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = Hashing.MURMUR_HASH;\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = getShard(key);\n        try {\n            return jedis.get(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public Object sendCommand(String command, Protocol.Command protocolCommand, String... args) {\n        Jedis jedis = getShard(command);\n        try {\n            return jedis.sendCommand(protocolCommand, args);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public void close() {\n        // No-op as connections are managed per-operation\n    }\n\n    protected Jedis getShard(String key) {\n        int index = getShardIndex(key);\n        HostAndPort hostAndPort = shards.get(index);\n        return new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), clientConfig);\n    }\n\n    protected int getShardIndex(String key) {\n        int hash = hashing.hash(key);\n        int virtualNodes = shards.size();\n        return Math.abs(hash % virtualNodes);\n    }\n}"
  },
  {
    "Task_id": 347,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, operations, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections and provides basic Redis operations. It handles connection lifecycle and ensures proper resource cleanup.\n\nAttributes:\n- client: RedisClient - The Redis client instance used for connections\n- redis: RedisCommands<String, String> - Synchronous Redis commands interface for string operations\n\nMethods:\n- setupClient(): void - Static method to initialize the default Redis client with default options\n- newRedisClient(): RedisClient - Static method to create a new Redis client with test resources (host and port should be defined elsewhere)\n- connect(): RedisCommands<String, String> - Establishes and returns a synchronous Redis connection\n- openConnection(): void - Opens a connection, configures client options, and ensures Redis is in a clean state by flushing data and killing any running scripts\n- closeConnection(): void - Closes the active Redis connection and releases resources",
    "Canonical_solution": "import io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.resource.DefaultRedisClient;\nimport io.lettuce.test.resource.TestClientResources;\n\npublic class RedisConnectionManager {\n\n    protected static RedisClient client;\n    protected RedisCommands<String, String> redis;\n\n    public static void setupClient() {\n        client = DefaultRedisClient.get();\n        client.setOptions(ClientOptions.create());\n    }\n\n    private static RedisClient newRedisClient() {\n        return RedisClient.create(TestClientResources.get(), RedisURI.Builder.redis(host, port).build());\n    }\n\n    public RedisCommands<String, String> connect() {\n        RedisCommands<String, String> connect = client.connect().sync();\n        return connect;\n    }\n\n    public void openConnection() throws Exception {\n        client.setOptions(ClientOptions.builder().build());\n        redis = connect();\n        boolean scriptRunning;\n        do {\n            scriptRunning = false;\n            try {\n                redis.flushall();\n                redis.flushdb();\n            } catch (RedisBusyException e) {\n                scriptRunning = true;\n                try {\n                    redis.scriptKill();\n                } catch (RedisException e1) {\n                    // Script might have ended between BUSY check and KILL attempt\n                }\n            }\n        } while (scriptRunning);\n    }\n\n    public void closeConnection() throws Exception {\n        if (redis != null) {\n            redis.getStatefulConnection().close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.support.CommandArgs;\n\npublic class RedisConnectionManager {\n    private static RedisClient client;\n    private static RedisCommands<String, String> redis;\n\n    public static void setupClient() {\n        client = RedisClient.create(\"redis://localhost:6379\");\n    }\n\n    public static RedisClient newRedisClient() {\n        return RedisClient.create(\"redis://localhost:6379\");\n    }\n\n    public RedisCommands<String, String> connect() {\n        StatefulRedisConnection<String, String> connection = client.connect();\n        redis = connection.sync();\n        openConnection();\n        return redis;\n    }\n\n    private void openConnection() {\n        redis.flushall();\n        redis.scriptKill();\n    }\n\n    public void closeConnection() {\n        if (redis != null) {\n            redis.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.JedisCluster;\nimport java.util.*;\nimport java.util.logging.Logger;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n    private final JedisCluster jedisCluster;\n    private final Logger log;\n    private final ISerializer<Object> serializer;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        this.jedisCluster = jedisCluster;\n        this.serializer = serializer;\n        this.log = Logger.getLogger(JedisClusterCacheManager.class.getName());\n    }\n\n    @Override\n    public IRedis getRedis() {\n        return new JedisClusterClient(jedisCluster);\n    }\n\n    @Override\n    public void close() {\n        if (jedisCluster != null) {\n            jedisCluster.close();\n        }\n    }\n\n    public void set(byte[] key, byte[] value) {\n        try {\n            jedisCluster.set(key, value);\n        } catch (Exception e) {\n            log.severe(\"Error setting key: \" + Arrays.toString(key) + \", \" + e.getMessage());\n        }\n    }\n\n    public void setex(byte[] key, int seconds, byte[] value) {\n        try {\n            jedisCluster.setex(key, seconds, value);\n        } catch (Exception e) {\n            log.severe(\"Error settingex key: \" + Arrays.toString(key) + \", \" + e.getMessage());\n        }\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value) {\n        try {\n            jedisCluster.hset(key, field, value);\n        } catch (Exception e) {\n            log.severe(\"Error hset key: \" + Arrays.toString(key) + \", field: \" + Arrays.toString(field) + \", \" + e.getMessage());\n        }\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n        try {\n            jedisCluster.hset(key, field, value);\n            jedisCluster.expire(key, seconds);\n        } catch (Exception e) {\n            log.severe(\"Error hset with expire key: \" + Arrays.toString(key) + \", field: \" + Arrays.toString(field) + \", \" + e.getMessage());\n        }\n    }\n\n    public void mset(Collection<MSetParam> params) {\n        Map<byte[], byte[]> map = new HashMap<>();\n        for (MSetParam param : params) {\n            map.put(param.getKey(), param.getValue());\n        }\n        try {\n            jedisCluster.mset(map);\n        } catch (Exception e) {\n            log.severe(\"Error mset: \" + e.getMessage());\n        }\n    }\n\n    public byte[] get(byte[] key) {\n        try {\n            return jedisCluster.get(key);\n        } catch (Exception e) {\n            log.severe(\"Error getting key: \" + Arrays.toString(key) + \", \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public byte[] hget(byte[] key, byte[] field) {\n        try {\n            return jedisCluster.hget(key, field);\n        } catch (Exception e) {\n            log.severe(\"Error hget key: \" + Arrays.toString(key) + \", field: \" + Arrays.toString(field) + \", \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public <T> Map<CacheKeyTO, CacheWrapper<T>> mget(Class<T> type, Set<CacheKeyTO> keys) {\n        Map<CacheKeyTO, CacheWrapper<T>> result = new HashMap<>();\n        List<byte[]> byteKeys = new ArrayList<>();\n        for (CacheKeyTO key : keys) {\n            byteKeys.add(key.getBytes());\n        }\n        try {\n            List<byte[]> values = jedisCluster.mget(byteKeys.toArray(new byte[0][]));\n            for (int i = 0; i < values.size(); i++) {\n                byte[] valueBytes = values.get(i);\n                CacheKeyTO key = keys.toArray(new CacheKeyTO[0])[i];\n                T value = valueBytes != null ? serializer.deserialize(valueBytes, type) : null;\n                result.put(key, new CacheWrapper<>(value));\n            }\n        } catch (Exception e) {\n            log.severe(\"Error mget: \" + e.getMessage());\n        }\n        return result;\n    }\n\n    public void delete(Set<CacheKeyTO> keys) {\n        List<byte[]> byteKeys = new ArrayList<>();\n        for (CacheKeyTO key : keys) {\n            byteKeys.add(key.getBytes());\n        }\n        try {\n            jedisCluster.del(byteKeys.toArray(new byte[0][]));\n        } catch (Exception e) {\n            log.severe(\"Error deleting keys: \" + e.getMessage());\n        }\n    }\n\n    private static class JedisClusterClient implements IRedis {\n        private final JedisCluster jedisCluster;\n\n        public JedisClusterClient(JedisCluster jedisCluster) {\n            this.jedisCluster = jedisCluster;\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            jedisCluster.hset(key, field, value);\n            jedisCluster.expire(key, seconds);\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            Map<byte[], byte[]> map = new HashMap<>();\n            for (MSetParam param : params) {\n                map.put(param.getKey(), param.getValue());\n            }\n            jedisCluster.mset(map);\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public <T> Map<CacheKeyTO, CacheWrapper<T>> mget(Class<T> type, Set<CacheKeyTO> keys) {\n            Map<CacheKeyTO, CacheWrapper<T>> result = new HashMap<>();\n            List<byte[]> byteKeys = new ArrayList<>();\n            for (CacheKeyTO key : keys) {\n                byteKeys.add(key.getBytes());\n            }\n            List<byte[]> values = jedisCluster.mget(byteKeys.toArray(new byte[0][]));\n            for (int i = 0; i < values.size(); i++) {\n                byte[] valueBytes = values.get(i);\n                CacheKeyTO key = keys.toArray(new CacheKeyTO[0])[i];\n                T value = valueBytes != null ? (T) valueBytes : null;\n                result.put(key, new CacheWrapper<>(value));\n            }\n            return result;\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            List<byte[]> byteKeys = new ArrayList<>();\n            for (CacheKeyTO key : keys) {\n                byteKeys.add(key.getBytes());\n            }\n            jedisCluster.del(byteKeys.toArray(new byte[0][]));\n        }\n    }\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Create a Java class that implements a writable tile archive using Java NIO's FileChannel for efficient file operations, supporting both file-based and in-memory storage options.\n\nClass Description: WriteablePmtiles is a class that provides functionality to write and manage tile archive data using Java NIO channels. It supports writing to either a physical file or an in-memory buffer, tracks bytes written, and handles proper resource cleanup.\n\nAttributes:\n- out: [SeekableByteChannel] - The channel used for writing data (either FileChannel or in-memory channel)\n- bytesWritten: [LongSupplier] - A supplier that provides the number of bytes written to the channel\n\nMethods:\n- newWriteToFile(Path path) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to a physical file at the specified path\n- newWriteToMemory(SeekableInMemoryByteChannel bytes) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to an in-memory byte channel\n- finish(TileArchiveMetadata tileArchiveMetadata) -> [void] - Finalizes the archive by writing metadata and directory information\n- bytesWritten() -> [long] - Returns the number of bytes written to the archive\n- close() -> [void] - Closes the underlying channel and releases system resources\n- DeduplicatingTileWriter.write(TileEncodingResult encodingResult) -> [void] - Inner class method that writes tile data to the channel\n- DeduplicatingTileWriter.close() -> [void] - Inner class method that performs any necessary cleanup (none in this implementation)",
    "Canonical_solution": "import com.onthegomap.planetiler.util.FileUtils;\nimport com.onthegomap.planetiler.util.SeekableInMemoryByteChannel;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.function.LongSupplier;\n\npublic final class WriteablePmtiles implements WriteableTileArchive {\n\n  private final SeekableByteChannel out;\n  private final LongSupplier bytesWritten;\n\n  private WriteablePmtiles(SeekableByteChannel channel, LongSupplier bytesWritten) throws IOException {\n    this.out = channel;\n    out.write(ByteBuffer.allocate(INIT_SECTION));\n    this.bytesWritten = bytesWritten;\n  }\n\n  public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n    return new WriteablePmtiles(\n      FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE),\n      () -> FileUtils.size(path)\n    );\n  }\n\n  public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) throws IOException {\n    return new WriteablePmtiles(bytes, () -> 0);\n  }\n\n  @Override\n  public void finish(TileArchiveMetadata tileArchiveMetadata) {\n    try {\n      out.write(ByteBuffer.wrap(jsonBytes));\n      out.write(ByteBuffer.wrap(directories.leaves));\n      out.position(0);\n      out.write(ByteBuffer.wrap(header.toBytes()));\n      out.write(ByteBuffer.wrap(directories.root));\n    } catch (IOException e) {\n      LOGGER.error(e.getMessage());\n    }\n  }\n\n  @Override\n  public long bytesWritten() {\n    return bytesWritten.getAsLong();\n  }\n\n  @Override\n  public void close() throws IOException {\n    out.close();\n  }\n\n  private class DeduplicatingTileWriter implements TileWriter {\n    @Override\n    public void write(TileEncodingResult encodingResult) {\n      try {\n        out.write(ByteBuffer.wrap(data));\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      currentOffset += data.length;\n    }\n\n    @Override\n    public void close() {\n      // no cleanup needed.\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.LongSupplier;\n\npublic class WriteablePmtiles {\n    private final SeekableByteChannel out;\n    private final LongSupplier bytesWritten;\n\n    private WriteablePmtiles(SeekableByteChannel out, LongSupplier bytesWritten) {\n        this.out = out;\n        this.bytesWritten = bytesWritten;\n    }\n\n    public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n        SeekableByteChannel channel = Files.newByteChannel(path);\n        LongSupplier supplier = () -> 0L;\n        return new WriteablePmtiles(channel, supplier);\n    }\n\n    public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) {\n        return new WriteablePmtiles(bytes, () -> bytes.position());\n    }\n\n    public void finish(TileArchiveMetadata tileArchiveMetadata) throws IOException {\n        // Implementation to write metadata and directory information\n    }\n\n    public long bytesWritten() {\n        return bytesWritten.getAsLong();\n    }\n\n    public void close() throws IOException {\n        out.close();\n    }\n\n    public class DeduplicatingTileWriter {\n        public void write(TileEncodingResult encodingResult) throws IOException {\n            ByteBuffer buffer = encodingResult.getData();\n            while (buffer.hasRemaining()) {\n                out.write(buffer);\n            }\n            bytesWritten = () -> out.position();\n        }\n\n        public void close() throws IOException {\n            // No cleanup needed\n        }\n    }\n}"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Implement a distributed lock mechanism using Redis in Java to ensure thread-safe operations across multiple processes or systems.\n\nClass Description: RedisDistributeLock is a class that provides distributed locking functionality using Redis as the backend storage. It manages lock acquisition, release, and timeout handling to coordinate access to shared resources in a distributed environment.\n\nAttributes:\n- pool: [JedisPool] - The connection pool for Redis connections\n- jedisLock: [JedisLock] - The lock implementation instance\n- lockKey: [String] - The key used for locking in Redis\n- jedis: [Jedis] - The Redis client instance\n- timeoutMsecs: [int] - Maximum time to wait for lock acquisition in milliseconds\n- expireMsecs: [int] - Time after which the lock automatically expires in milliseconds\n\nMethods:\n- RedisDistributeLock([String] lockKey) -> [void] - Constructor with default timeout (3000ms) and expire (300000ms) values\n- RedisDistributeLock([String] lockKey, [int] timeoutMsecs, [int] expireMsecs) -> [void] - Constructor with custom timeout and expire values\n- wrap([Runnable] runnable) -> [void] - Executes the given runnable within the acquired lock context\n- lockRelease([JedisLock] lock, [Jedis] jedis) -> [void] - Releases the lock and closes the Redis connection\n- getPool() -> [JedisPool] - Static getter for the Redis connection pool\n- setPool([JedisPool] pool) -> [void] - Static setter for the Redis connection pool",
    "Canonical_solution": "import com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedisDistributeLock {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(RedisDistributeLock.class);\n\n    private static JedisPool pool;\n    private JedisLock jedisLock;\n    private String lockKey;\n    private Jedis jedis;\n    private int timeoutMsecs;\n    private int expireMsecs;\n\n    public RedisDistributeLock(String lockKey) {\n        this(lockKey, 3000, 300000);\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.jedis = pool.getResource();\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n        this.jedisLock = new JedisLock(jedis, lockKey.intern(), timeoutMsecs, expireMsecs);\n    }\n\n    public void wrap(Runnable runnable) {\n        long begin = System.currentTimeMillis();\n        try {\n            LOGGER.info(\"begin logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n            if (jedisLock.acquire()) {\n                runnable.run();\n            } else {\n                LOGGER.info(\"The time wait for lock more than [{}] ms \", timeoutMsecs);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(t.getMessage(), t);\n        } finally {\n            this.lockRelease(jedisLock, jedis);\n        }\n        LOGGER.info(\"[{}]cost={}\", lockKey, System.currentTimeMillis() - begin);\n    }\n\n    private void lockRelease(JedisLock lock, Jedis jedis) {\n        if (lock != null) {\n            try {\n                lock.release();\n            } catch (Exception e) {\n            }\n        }\n        if (jedis != null) {\n            jedis.close();\n        }\n        LOGGER.info(\"release logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static synchronized void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisDistributeLock {\n    private static JedisPool pool;\n    private JedisLock jedisLock;\n    private String lockKey;\n    private Jedis jedis;\n    private int timeoutMsecs;\n    private int expireMsecs;\n\n    public RedisDistributeLock(String lockKey) {\n        this(lockKey, 3000, 300000);\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n        this.jedis = getPool().getResource();\n        this.jedisLock = new JedisLock(jedis, lockKey, expireMsecs);\n    }\n\n    public void wrap(Runnable runnable) {\n        if (jedisLock.tryLock(timeoutMsecs)) {\n            try {\n                runnable.run();\n            } finally {\n                lockRelease(jedisLock, jedis);\n            }\n        }\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n\n    private void lockRelease(JedisLock lock, Jedis jedis) {\n        if (lock != null && jedis != null) {\n            lock.unlock();\n            jedis.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 357,
    "Instruction": "Task Description: Implement a Redis-based broadcast service for inter-process communication that allows sending and receiving messages between different instances of an application.\n\nClass Description: RedisBroadcastService is a class that provides publish-subscribe functionality using Redis as the message broker. It handles message serialization/deserialization and ensures messages are only processed by other instances (not the sender).\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization of messages\n- executorService: ExecutorService - Handles message reception in a separate thread\n- channel: String - The Redis channel name for pub/sub communication\n- subscriber: Jedis - Redis client for subscribing to messages\n- publisher: Jedis - Redis client for publishing messages\n- id: String - Unique identifier for this service instance to avoid processing own messages\n\nMethods:\n- RedisBroadcastService(Config config, ExecutorService executorService, ObjectMapper objectMapper) -> void - Constructor that initializes Redis connections\n- sendMessage(BroadcastMessage message) -> void - Publishes a message to the Redis channel\n- start() -> void - Starts the message receiver in a separate thread\n- stop() -> void - Closes Redis connections and cleans up resources\n- receiver: Runnable - Internal thread that handles incoming messages from Redis",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class RedisBroadcastService extends BaseBroadcastService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisBroadcastService.class);\n\n    private final ObjectMapper objectMapper;\n    private final ExecutorService executorService;\n    private final String channel = \"traccar\";\n    private Jedis subscriber;\n    private Jedis publisher;\n    private final String id = UUID.randomUUID().toString();\n\n    public RedisBroadcastService(\n            Config config, ExecutorService executorService, ObjectMapper objectMapper) throws IOException {\n        this.executorService = executorService;\n        this.objectMapper = objectMapper;\n        String url = config.getString(Keys.BROADCAST_ADDRESS);\n\n        try {\n            subscriber = new Jedis(url);\n            publisher = new Jedis(url);\n            subscriber.connect();\n        } catch (JedisConnectionException e) {\n            throw new IOException(e);\n        }\n    }\n\n    @Override\n    protected void sendMessage(BroadcastMessage message) {\n        try {\n            String payload = id  + \":\" + objectMapper.writeValueAsString(message);\n            publisher.publish(channel, payload);\n        } catch (IOException | JedisConnectionException e) {\n            LOGGER.warn(\"Broadcast failed\", e);\n        }\n    }\n\n    @Override\n    public void start() throws IOException {\n        executorService.submit(receiver);\n    }\n\n    @Override\n    public void stop() {\n        try {\n            if (subscriber != null) {\n                subscriber.close();\n                subscriber = null;\n            }\n        } catch (JedisException e) {\n            LOGGER.warn(\"Subscriber close failed\", e);\n        }\n        try {\n            if (publisher != null) {\n                publisher.close();\n                publisher = null;\n            }\n        } catch (JedisException e) {\n            LOGGER.warn(\"Publisher close failed\", e);\n        }\n    }\n\n    private final Runnable receiver = new Runnable() {\n        @Override\n        public void run() {\n            try {\n                subscriber.subscribe(new JedisPubSub() {\n                    @Override\n                    public void onMessage(String messageChannel, String message) {\n                        try {\n                            String[] parts = message.split(\":\", 2);\n                            if (messageChannel.equals(channel) && parts.length == 2 && !id.equals(parts[0])) {\n                                handleMessage(objectMapper.readValue(parts[1], BroadcastMessage.class));\n                            }\n                        } catch (Exception e) {\n                            LOGGER.warn(\"Broadcast handleMessage failed\", e);\n                        }\n                    }\n                }, channel);\n            } catch (JedisException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    };\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisBroadcastService {\n    private final ObjectMapper objectMapper;\n    private final ExecutorService executorService;\n    private final String channel;\n    private final Jedis subscriber;\n    private final Jedis publisher;\n    private final String id;\n\n    public RedisBroadcastService(Config config, ExecutorService executorService, ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n        this.executorService = executorService;\n        this.channel = config.getChannel();\n        this.id = config.getInstanceId();\n        this.subscriber = new Jedis(config.getHost(), config.getPort());\n        this.publisher = new Jedis(config.getHost(), config.getPort());\n    }\n\n    public void sendMessage(BroadcastMessage message) {\n        try {\n            String json = objectMapper.writeValueAsString(message);\n            publisher.publish(channel, json);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        executorService.submit(receiver);\n    }\n\n    public void stop() {\n        subscriber.close();\n        publisher.close();\n    }\n\n    private final Runnable receiver = () -> {\n        Jedis jedis = subscriber;\n        Set<String> channels = Collections.singleton(channel);\n        jedis.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n                try {\n                    BroadcastMessage receivedMessage = objectMapper.readValue(message, BroadcastMessage.class);\n                    if (!receivedMessage.getId().equals(id)) {\n                        // Handle the message\n                    }\n                } catch (JsonProcessingException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, channels.toArray(new String[0]));\n    };\n}"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with authentication support, including connection initialization, creation of different connection types, and proper resource cleanup.\n\nClass Description: The RedisConnectionManager class provides centralized management for Redis connections, supporting both standalone and cluster configurations with token-based authentication. It handles connection lifecycle management and provides methods to create different types of Redis connections.\n\nAttributes:\n\nclientOptions: [ClusterClientOptions] - Configuration options for Redis client connections\ncredentialsProvider: [TokenBasedRedisCredentialsProvider] - Provider for token-based authentication credentials\nclient: [RedisClient] - Client instance for standalone Redis connections\nclusterClient: [RedisClusterClient] - Client instance for Redis cluster connections\n\nMethods:\n\ninitializeConnection: [Name]([EntraIdTestContext testCtx]) -> [void] - Initializes Redis client instances with connection options and authentication configuration\ncreateStandaloneConnection: [Name]() -> [StatefulRedisConnection<String, String>] - Creates and returns a new standalone Redis connection\ncreateClusterConnection: [Name]() -> [StatefulRedisClusterConnection<String, String>] - Creates and returns a new Redis cluster connection\ncreatePubSubConnection: [Name]() -> [StatefulRedisPubSubConnection<String, String>] - Creates and returns a new Redis Pub/Sub connection\ncloseConnections: [Name]() -> [void] - Closes all active connections and releases resources",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.authentication.core.TokenBasedRedisCredentialsProvider;\n\npublic class RedisConnectionManager {\n\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        clientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(1)).build())\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        TokenAuthConfig tokenAuthConfig = EntraIDTokenAuthConfigBuilder.builder().clientId(testCtx.getClientId())\n                .secret(testCtx.getClientSecret()).authority(testCtx.getAuthority()).scopes(testCtx.getRedisScopes())\n                .expirationRefreshRatio(0.0000001F).build();\n\n        credentialsProvider = TokenBasedRedisCredentialsProvider.create(tokenAuthConfig);\n\n        RedisURI uri = RedisURI.builder().withHost(testCtx.host()).withPort(testCtx.port())\n                .withAuthentication(credentialsProvider).build();\n\n        client = RedisClient.create(uri);\n        client.setOptions(clientOptions);\n\n        RedisURI clusterUri = RedisURI.builder().withHost(testCtx.clusterHost().get(0)).withPort(testCtx.clusterPort())\n                .withAuthentication(credentialsProvider).build();\n        clusterClient = RedisClusterClient.create(clusterUri);\n        clusterClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (credentialsProvider != null) {\n            credentialsProvider.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n        if (clusterClient != null) {\n            clusterClient.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        this.clientOptions = new ClusterClientOptions.Builder()\n                .build();\n        this.credentialsProvider = new TokenBasedRedisCredentialsProvider(testCtx.getToken());\n        this.client = RedisClient.create(\"redis://localhost:6379\");\n        this.clusterClient = RedisClusterClient.create(\"redis://localhost:6379\");\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connectCluster();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (client != null) {\n            client.shutdown();\n        }\n        if (clusterClient != null) {\n            clusterClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer for processing order-related messages. The consumer should be initialized with Spring and configured to consume messages from a specified topic.\n\nClass Description: The OrderPushConsumer class is a Spring component that initializes and manages a RocketMQ push consumer. It subscribes to a specified topic, configures consumption settings, and processes incoming messages asynchronously.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- topicName: String - The name of the topic to subscribe to (injected from properties)\n- namesrvAddr: String - The address of the NameServer (injected from properties)\n\nMethods:\n- init(): void - Initializes the consumer with configuration settings and starts it. This method is automatically called after construction due to the @PostConstruct annotation.\n  - Input: None\n  - Output: None\n  - Description: Configures the consumer with NameServer address, subscription details, batch size, and consumption strategy. Registers a message listener and starts the consumer.\n\n- (implicit) MessageListenerConcurrently.consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Handles incoming messages\n  - Input: \n    - msgs: List<MessageExt> - List of received messages\n    - context: ConsumeConcurrentlyContext - Context for concurrent consumption\n  - Output: ConsumeConcurrentlyStatus - Status indicating whether message processing was successful\n  - Description: The anonymous implementation of MessageListenerConcurrently that processes batches of messages. Currently returns CONSUME_SUCCESS for all messages.",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class OrderPushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n\n    @Value(\"${rocketmq.nameserver.addr}\")\n    private String namesrvAddr;\n\n    @PostConstruct\n    public void init() throws Exception {\n        consumer = new DefaultMQPushConsumer(\"create_order_consumer_group2\");\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(topicName,\"*\");\n        consumer.setConsumeMessageBatchMaxSize(100);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class OrderPushConsumer {\n\n    @Value(\"${rocketmq.namesrv.addr}\")\n    private String namesrvAddr;\n\n    @Value(\"${rocketmq.topic.order}\")\n    private String topicName;\n\n    private DefaultMQPushConsumer consumer;\n\n    @PostConstruct\n    public void init() throws Exception {\n        consumer = new DefaultMQPushConsumer(\"OrderConsumerGroup\");\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(topicName, \"*\");\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMaxBatchSize(10);\n        consumer.setMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    // Process message here\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n    }\n}"
  },
  {
    "Task_id": 364,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer capable of subscribing to topics, filtering messages, and processing them asynchronously.\n\nClass Description: The RocketMQConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify consumer setup and message handling. It supports both tag-based and SQL92 filtering, configurable threading, and various RocketMQ features like message tracing and ACL.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n- topic: String - The topic to subscribe to\n- group: String - The consumer group name\n- threadCount: int - Number of threads for message processing\n- filterType: String - Type of message filtering (TAG or SQL92)\n- expression: String - Filter expression (either tag or SQL condition)\n- msgTraceEnable: boolean - Whether to enable message tracing\n- aclEnable: boolean - Whether to enable access control\n- clientRebalanceEnable: boolean - Whether to enable client-side rebalancing\n- rpcHook: RPCHook - Custom RPC hook for authentication\n\nMethods:\n- initialize(): void - Initializes the consumer with configured settings and subscribes to the topic\n- setMessageListener(MessageListenerConcurrently listener): void - Registers a message listener for concurrent message processing\n- start(): void - Starts the consumer to begin receiving messages\n- shutdown(): void - Gracefully shuts down the consumer\n- setNamesrvAddr(String namesrvAddr): void - Sets the NameServer address for broker discovery",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String topic, String group, int threadCount, String filterType, \n                          String expression, boolean msgTraceEnable, boolean aclEnable, \n                          boolean clientRebalanceEnable, RPCHook rpcHook) {\n        this.topic = topic;\n        this.group = group;\n        this.threadCount = threadCount;\n        this.filterType = filterType;\n        this.expression = expression;\n        this.msgTraceEnable = msgTraceEnable;\n        this.aclEnable = aclEnable;\n        this.clientRebalanceEnable = clientRebalanceEnable;\n        this.rpcHook = rpcHook;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(group, rpcHook, new AllocateMessageQueueAveragely(), msgTraceEnable, null);\n        consumer.setConsumeThreadMin(threadCount);\n        consumer.setConsumeThreadMax(threadCount);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setClientRebalance(clientRebalanceEnable);\n\n        if (filterType == null || expression == null) {\n            consumer.subscribe(topic, \"*\");\n        } else {\n            if (ExpressionType.TAG.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.byTag(expr));\n            } else if (ExpressionType.SQL92.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.bySql(expr));\n            } else {\n                throw new IllegalArgumentException(\"Not support filter type! \" + filterType);\n            }\n        }\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.hook.RPCHook;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public void initialize() throws Exception {\n        consumer = new DefaultMQPushConsumer(group);\n        consumer.setNamesrvAddr(\"localhost:9876\");\n        consumer.setThreadCount(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMessageModel(DefaultMQPushConsumer.CLUSTERING);\n        consumer.setConsumeTimeout(3000);\n        consumer.setPullBatchSize(32);\n        consumer.setPostMaxInterval(500);\n        consumer.setMaxReconsumeTimes(16);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setClientCallbackExecutorThreads(4);\n        consumer.setNamesrvAddr(\"localhost:9876\");\n        consumer.setInstanceName(\"DEFAULT_CONSUMER\");\n        consumer.setConsumerGroup(group);\n        consumer.setVipChannelEnabled(false);\n        consumer.setNamespace(\"DEFAULT\");\n        consumer.setUnitMode(false);\n        consumer.setSendMsgTimeout(3000);\n        consumer.setPollNameServerInteval(3000);\n        consumer.setHeartbeatBrokerInterval(30000);\n        consumer.setCheckForbiddenListPeriod(30000);\n        consumer.setFilterMessageFlag(true);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");\n        consumer.setConsumeConcurrentlyMaxSpan(2000);\n        consumer.setConsumeOrderly(false);\n        consumer.setAllocateMQStrategy(DefaultMQPushConsumer.ROUND_ROBIN);\n        consumer.setConsumeMessageBatchMaxSize(1);\n        consumer.setConsumeConcurrentlyThreadNum(threadCount);\n        consumer.setConsumeFromWhere(DefaultMQPushConsumer.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimestamp(System.currentTimeMillis() + \"\");"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class responsible for setting up a RocketMQ push consumer. It configures the consumer with NameServer address, consumption strategy, topic subscriptions, and message listeners. The consumer is started asynchronously after a short delay to ensure proper initialization.\n\nAttributes:\n- `uacPushMessageListener`: [UacPushMessageListener] - The message listener implementation that handles incoming messages\n- `paascloudProperties`: [PaascloudProperties] - Configuration properties containing RocketMQ settings\n- `taskExecutor`: [TaskExecutor] - Executor service for asynchronous consumer startup\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer with the following steps:\n  1. Creates a new DefaultMQPushConsumer instance with the consumer group from properties\n  2. Sets the NameServer address from properties\n  3. Configures consumption to start from the last offset\n  4. Parses and subscribes to topics and tags from constants\n  5. Registers the message listener\n  6. Sets thread pool size for message consumption\n  7. Starts the consumer asynchronously after a 5-second delay\n  8. Returns the configured consumer instance",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.mq.consumer.listener.UacPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.core.task.TaskExecutor;\n\n@Configuration\npublic class AliyunMqConfiguration {\n    @Resource\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.UAC.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                log.error(\"RocketMq OpcPushConsumer, Exception={}\", e.getMessage(), e);\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getMq().getNameServer());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String topics = paascloudProperties.getMq().getTopic();\n        String[] topicArray = topics.split(\",\");\n        for (String topic : topicArray) {\n            consumer.subscribe(topic, \"*\");\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMin(1);\n        consumer.setConsumeThreadMax(10);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Failed to start RocketMQ consumer\", e);\n            }\n        });\n\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ ordered message consumer using the DefaultMQPushConsumer for push-based message consumption with ordered message processing.\n\nClass Description: The RocketMQOrderedConsumer class provides functionality to consume messages from RocketMQ in an ordered manner. It handles consumer initialization, topic subscription, message listening, and consumer lifecycle management. The class includes an inner class for ordered message processing.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The main consumer instance that handles message consumption from RocketMQ\n\nMethods:\n- RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) -> void - Constructor that initializes the consumer with NameServer address and consumer group\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerOrderly listener) -> void - Registers an ordered message listener for processing incoming messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n\nInner Class:\n- OrderedMessageListener: MessageListenerOrderly - Implements ordered message processing logic with consumeMessage method\n  - consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) -> ConsumeOrderlyStatus - Processes a batch of messages and returns consumption status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQOrderedConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            System.out.printf(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeOrderlyStatus.SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class RocketMQOrderedConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        try {\n            consumer.subscribe(topic, subExpression);\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        try {\n            consumer.start();\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeOrderlyStatus.SUCCESS;\n        }\n    }\n}"
  },
  {
    "Task_id": 374,
    "Instruction": "Task Description: Implement a RocketMQ consumer class that handles message consumption from a Logical Message Queue (LMQ) using POP mode, with proper initialization, message processing, and cleanup functionality.\n\nClass Description: LMQPushPopConsumer is a Java class that demonstrates how to consume messages from a RocketMQ Logical Message Queue (LMQ) using POP (Pull-on-Poll) mode. It handles consumer initialization, topic subscription, message processing, and resource cleanup.\n\nAttributes:\n- CLUSTER_NAME: [String] - The name of the RocketMQ cluster\n- BROKER_NAME: [String] - The name of the target broker\n- TOPIC: [String] - The parent topic name\n- LMQ_TOPIC: [String] - The Logical Message Queue topic name (prefixed with LMQ_PREFIX)\n- NAMESRV_ADDR: [String] - The NameServer address\n- CONSUMER_GROUP: [String] - The consumer group name\n- BROKER_ADDR_MAP: [HashMap<Long, String>] - Mapping of broker IDs to their addresses\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n- mqAdminExt: [DefaultMQAdminExt] - The RocketMQ admin tool instance\n\nMethods:\n- initializeConsumer(): [void] -> [void] - Initializes the consumer by setting up POP mode, configuring consumer properties, subscribing to the topic, and registering a message listener\n- switchPop(): [void] -> [void] - Configures the broker to use POP mode for message consumption\n- shutdown(): [void] -> [void] - Shuts down the consumer and admin instances to release resources",
    "Canonical_solution": "import com.google.common.collect.Lists;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageRequestMode;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.tools.admin.DefaultMQAdminExt;\n\npublic class LMQPushPopConsumer {\n    public static final String CLUSTER_NAME = \"DefaultCluster\";\n    public static final String BROKER_NAME = \"broker-a\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String LMQ_TOPIC = MixAll.LMQ_PREFIX + \"456\";\n    public static final String NAMESRV_ADDR = \"127.0.0.1:9876\";\n    public static final String CONSUMER_GROUP = \"CID_LMQ_POP_1\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<Long, String>() {\n        {\n            put(MixAll.MASTER_ID, \"127.0.0.1:10911\");\n        }\n    };\n\n    private DefaultMQPushConsumer consumer;\n    private DefaultMQAdminExt mqAdminExt;\n\n    public void initializeConsumer() throws Exception {\n        switchPop();\n\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.setClientRebalance(false);\n        consumer.start();\n\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(TOPIC);\n\n        final TopicRouteData topicRouteData = new TopicRouteData();\n        final BrokerData brokerData = new BrokerData();\n        brokerData.setCluster(CLUSTER_NAME);\n        brokerData.setBrokerName(BROKER_NAME);\n        brokerData.setBrokerAddrs(BROKER_ADDR_MAP);\n        topicRouteData.setBrokerDatas(Lists.newArrayList(brokerData));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getTopicRouteTable().put(LMQ_TOPIC, topicRouteData);\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().doRebalance();\n    }\n\n    private void switchPop() throws Exception {\n        mqAdminExt = new DefaultMQAdminExt();\n        mqAdminExt.setNamesrvAddr(NAMESRV_ADDR);\n        mqAdminExt.start();\n        List<BrokerData> brokerDatas = mqAdminExt.examineTopicRouteInfo(TOPIC).getBrokerDatas();\n        for (BrokerData brokerData : brokerDatas) {\n            Set<String> brokerAddrs = new HashSet<>(brokerData.getBrokerAddrs().values());\n            for (String brokerAddr : brokerAddrs) {\n                mqAdminExt.setMessageRequestMode(brokerAddr, LMQ_TOPIC, CONSUMER_GROUP, MessageRequestMode.POP, 8,\n                    3_000);\n            }\n        }\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n        if (mqAdminExt != null) {\n            mqAdminExt.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.tools.admin.DefaultMQAdminExt;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LMQPushPopConsumer {\n    public static final String CLUSTER_NAME = \"YourClusterName\";\n    public static final String BROKER_NAME = \"YourBrokerName\";\n    public static final String TOPIC = \"YourTopic\";\n    public static final String LMQ_TOPIC = \"LMQ_PREFIX_YourLogicalTopic\";\n    public static final String NAMESRV_ADDR = \"localhost:9876\";\n    public static final String CONSUMER_GROUP = \"LMQ_CONSUMER_GROUP\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<>();\n    private DefaultMQPushConsumer consumer;\n    private DefaultMQAdminExt mqAdminExt;\n\n    public void initializeConsumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setConsumeTimeout(30000);\n        consumer.setPullInterval(1000);\n        consumer.setPullBatchSize(100);\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                // Process message\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.start();\n        switchPop();\n    }\n\n    public void switchPop() {\n        mqAdminExt = new DefaultMQAdminExt();\n        mqAdminExt.setNamesrvAddr(NAMESRV_ADDR);\n        try {\n            mqAdminExt.start();\n            Map<String, String> brokerAddrs = mqAdminExt.examineBrokerAddrByTopic(TOPIC);\n            for (Map.Entry<String, String> entry : brokerAddrs.entrySet()) {\n                Long brokerId = Long.valueOf(entry.getKey());\n                BROKER_ADDR_MAP.put(brokerId, entry.getValue());\n            }\n            mqAdminExt.updateBrokerConfig(BROKER_NAME, \"POP_MODE\", \"true\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n        if (mqAdminExt != null) {\n            mqAdminExt.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n    private final RPCHook rpcHook;\n    private final String topicName;\n    private final String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        this.defaultMQPushConsumer.setNamesrvAddr(\"localhost:9876\");\n        this.defaultMQPushConsumer.setConsumeFromWhere(org.apache.rocketmq.client.consumer.listener.ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        this.defaultMQPushConsumer.setMessageListener(this);\n    }\n\n    public void startConsumer() throws MQClientException {\n        if (rpcHook != null) {\n            defaultMQPushConsumer.setRPCHook(rpcHook);\n        }\n        defaultMQPushConsumer.subscribe(topicName, \"*\");\n        defaultMQPushConsumer.start();\n        log.info(\"RocketMQ consumer started for topic: {}\", topicName);\n    }\n\n    public void shutdown() {\n        if (defaultMQPushConsumer != null) {\n            defaultMQPushConsumer.shutdown();\n            log.info(\"RocketMQ consumer shutdown for topic: {}\", topicName);\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(MessageExt message, String producerGroup, int flag) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setFlag(flag);\n        return requestHeader;\n    }\n\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n        for (MessageExt message : messages) {\n            log.info(\"Received message: {} from topic: {}\", new String(message.getBody()), message.getTopic());\n        }\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n    }\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a resource handler class that serves file content from a specified path, supporting both full file serving and range requests, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: PathResource is a file resource handler that serves content from a file system path, supporting standard and ranged requests. It utilizes FileChannel for efficient reading and implements resource management through a PathResourceManager.\n\nAttributes:\n- file: Path - The file path to serve content from\n- manager: PathResourceManager - Manages resource access and transfer size thresholds\n\nMethods:\n- serve(Sender, HttpServerExchange, IoCallback) -> void - Serves the entire file content to the client\n- serveRange(Sender, HttpServerExchange, long, long, IoCallback) -> void - Serves a specific byte range of the file content\n- getContentLength() -> Long - Returns the size of the file in bytes or null if unavailable\n- serveImpl(Sender, HttpServerExchange, long, long, IoCallback, boolean) -> void - Internal implementation handling both full and ranged requests\n\nThe class uses nested BaseFileTask, ServerTask, and TransferTask classes to handle different serving strategies:\n- ServerTask: Reads file content in chunks using pooled buffers\n- TransferTask: Uses zero-copy transfer for efficient large file serving\n\nThe implementation demonstrates proper FileChannel usage including:\n1. Opening channels with StandardOpenOption.READ\n2. Position manipulation for range requests\n3. Proper resource cleanup with safeClose\n4. Buffer management with PooledByteBuffer\n5. Error handling for file operations",
    "Canonical_solution": "import io.undertow.io.IoCallback;\nimport io.undertow.io.Sender;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.connector.PooledByteBuffer;\nimport org.xnio.IoUtils;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class PathResource implements RangeAwareResource {\n\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(final Path file, final PathResourceManager manager, String path) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    @Override\n    public void serve(final Sender sender, final HttpServerExchange exchange, final IoCallback callback) {\n        serveImpl(sender, exchange, -1, -1, callback, false);\n    }\n\n    @Override\n    public void serveRange(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    private void serveImpl(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback, final boolean range) {\n        abstract class BaseFileTask implements Runnable {\n            protected volatile FileChannel fileChannel;\n\n            protected boolean openFile() {\n                try {\n                    fileChannel = FileChannel.open(file, StandardOpenOption.READ);\n                    if(range) {\n                        fileChannel.position(start);\n                    }\n                } catch (NoSuchFileException e) {\n                    exchange.setStatusCode(StatusCodes.NOT_FOUND);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                } catch (IOException e) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                }\n                return true;\n            }\n        }\n\n        class ServerTask extends BaseFileTask implements IoCallback {\n            private PooledByteBuffer pooled;\n            long remaining = end - start + 1;\n\n            @Override\n            public void run() {\n                if(range && remaining == 0) {\n                    if (pooled != null) {\n                        pooled.close();\n                        pooled = null;\n                    }\n                    IoUtils.safeClose(fileChannel);\n                    callback.onComplete(exchange, sender);\n                    return;\n                }\n                if (fileChannel == null) {\n                    if (!openFile()) {\n                        return;\n                    }\n                    pooled = exchange.getConnection().getByteBufferPool().allocate();\n                }\n                if (pooled != null) {\n                    ByteBuffer buffer = pooled.getBuffer();\n                    try {\n                        buffer.clear();\n                        int res = fileChannel.read(buffer);\n                        if (res == -1) {\n                            pooled.close();\n                            IoUtils.safeClose(fileChannel);\n                            callback.onComplete(exchange, sender);\n                            return;\n                        }\n                        buffer.flip();\n                        if(range) {\n                            if(buffer.remaining() > remaining) {\n                                buffer.limit((int) (buffer.position() + remaining));\n                            }\n                            remaining -= buffer.remaining();\n                        }\n                        sender.send(buffer, this);\n                    } catch (IOException e) {\n                        onException(exchange, sender, e);\n                    }\n                }\n            }\n\n            @Override\n            public void onComplete(final HttpServerExchange exchange, final Sender sender) {\n                if (exchange.isInIoThread()) {\n                    exchange.dispatch(this);\n                } else {\n                    run();\n                }\n            }\n\n            @Override\n            public void onException(final HttpServerExchange exchange, final Sender sender, final IOException exception) {\n                if (pooled != null) {\n                    pooled.close();\n                    pooled = null;\n                }\n                IoUtils.safeClose(fileChannel);\n                if (!exchange.isResponseStarted()) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                }\n                callback.onException(exchange, sender, exception);\n            }\n        }\n\n        class TransferTask extends BaseFileTask {\n            @Override\n            public void run() {\n                if (!openFile()) {\n                    return;\n                }\n                sender.transferFrom(fileChannel, new IoCallback() {\n                    @Override\n                    public void onComplete(HttpServerExchange exchange, Sender sender) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onComplete(exchange, sender);\n                        }\n                    }\n\n                    @Override\n                    public void onException(HttpServerExchange exchange, Sender sender, IOException exception) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onException(exchange, sender, exception);\n                        }\n                    }\n                });\n            }\n        }\n\n        BaseFileTask task;\n        try {\n            task = manager.getTransferMinSize() > Files.size(file) || range ? new ServerTask() : new TransferTask();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        if (exchange.isInIoThread()) {\n            exchange.dispatch(task);\n        } else {\n            task.run();\n        }\n    }\n\n    @Override\n    public Long getContentLength() {\n        try {\n            if (Files.isSymbolicLink(file) && Files.notExists(file)) {\n                return null;\n            }\n            return Files.size(file);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class PathResource {\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(Path file, PathResourceManager manager) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    public void serve(Sender sender, HttpServerExchange exchange, IoCallback callback) {\n        serveImpl(sender, exchange, 0, getContentLength(), callback, false);\n    }\n\n    public void serveRange(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    public Long getContentLength() {\n        try {\n            return Files.size(file);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private void serveImpl(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback, boolean isRange) {\n        if (!Files.exists(file)) {\n            callback.onError(new IOException(\"File not found: \" + file));\n            return;\n        }\n\n        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n            long fileSize = getContentLength();\n            if (fileSize == null || fileSize <= 0) {\n                callback.onError(new IOException(\"File size unavailable or invalid\"));\n                return;\n            }\n\n            if (start < 0 || start > fileSize) {\n                callback.onError(new IllegalArgumentException(\"Invalid start position\"));\n                return;\n            }\n\n            if (end < start || end >= fileSize) {\n                callback.onError(new IllegalArgumentException(\"Invalid end position\"));\n                return;\n            }\n\n            if (isRange) {\n                exchange.getResponseHeaders().add(\"Content-Range\", \"bytes \" + start + \"-\" + end + \"/\" + fileSize);\n                exchange.getResponseHeaders().add(\"Content-Length\", String.valueOf(end - start + 1));\n            }\n\n            if (manager.isZeroCopyTransferEnabled()) {\n                new TransferTask(channel, sender, exchange, start, end, callback).execute();\n            } else {\n                new ServerTask(channel, sender, exchange, start, end, callback).execute();\n            }\n        } catch (IOException e) {\n            callback.onError(e);\n        }\n    }\n\n    private abstract class BaseFileTask implements Runnable {\n        protected final FileChannel channel;\n        protected final Sender sender;\n        protected final HttpServerExchange exchange;\n        protected final long start;\n        protected final long end;\n        protected final IoCallback callback;\n\n        protected BaseFileTask(FileChannel channel, Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n            this.channel = channel;\n            this.sender = sender;\n            this.exchange = exchange;\n            this.start = start;\n            this.end = end;\n            this.callback = callback;\n        }\n\n        protected abstract void readChunk(ByteBuffer buffer) throws IOException;\n\n        protected void sendResponse() {\n            try {\n                ByteBuffer buffer = PooledByteBuffer.allocate(manager.getBufferSize());\n                while (channel.position() <= end) {\n                    buffer.clear();\n                    int bytesRead = channel.read(buffer);\n                    if (bytesRead == -1) break;\n                    buffer.flip();\n                    readChunk(buffer);\n                }\n                sender.flush();\n            } catch (IOException e) {\n                callback.onError(e);\n            } finally {\n                safeClose(channel);\n            }\n        }\n\n        protected void safeClose(Closeable closeable) {\n            if (closeable != null) {\n                try {\n                    closeable.close();\n                } catch (IOException e) {\n                    callback.onError(e);\n                }\n            }\n        }\n    }\n\n    private class ServerTask extends BaseFileTask {\n        public ServerTask(FileChannel channel, Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n            super(channel, sender, exchange, start, end, callback);\n        }\n\n        @Override\n        protected void readChunk(ByteBuffer buffer) throws IOException {\n            sender.send(buffer);\n        }\n    }\n\n    private class TransferTask extends BaseFileTask {\n        public TransferTask(FileChannel channel, Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n            super(channel, sender, exchange, start, end, callback);\n        }\n\n        @Override\n        protected void readChunk(ByteBuffer buffer) throws IOException {\n            sender.transferTo(buffer);\n        }\n    }\n}"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message producer sink for sending messages to RocketMQ topics, supporting both synchronous and asynchronous message delivery, batch processing, and configurable message delay levels.\n\nClass Description: The RocketMQSink class is a Flink-compatible sink that sends messages to RocketMQ. It handles message serialization, topic selection, and provides configurable message delivery options including synchronous/asynchronous sending, batch processing, and delayed message delivery.\n\nAttributes:\n- LOG: Logger - Logger instance for logging debug and error messages\n- producer: DefaultMQProducer - RocketMQ producer instance for sending messages\n- async: boolean - Flag indicating whether to use asynchronous message sending\n- props: Properties - Configuration properties for the producer\n- topicSelector: TopicSelector<IN> - Selector for determining message topics and tags\n- serializationSchema: KeyValueSerializationSchema<IN> - Schema for serializing input data\n- batchFlushOnCheckpoint: boolean - Flag indicating whether to use batch processing\n- batchSize: int - Maximum batch size for batch processing\n- batchList: List<Message> - Buffer for batch messages\n- messageDeliveryDelayLevel: int - Configuration for delayed message delivery\n\nMethods:\n- RocketMQSink(KeyValueSerializationSchema<IN>, TopicSelector<IN>, Properties) -> void - Constructor that initializes the sink with serialization schema, topic selector, and configuration properties\n- open(Configuration) -> void - Initializes the RocketMQ producer and prepares for message sending\n- invoke(IN) -> void - Processes and sends a single message (either immediately or adds to batch)\n- prepareMessage(IN) -> Message - Creates a RocketMQ Message object from input data\n- close() -> void - Cleans up resources and shuts down the producer\n- flushSync() -> void - Sends all batched messages synchronously (used when batch processing is enabled)",
    "Canonical_solution": "import com.zhisheng.connectors.rocketmq.common.selector.TopicSelector;\nimport com.zhisheng.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> {\n    private static final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n\n    private transient DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize = 1000;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> schema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = schema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n        this.messageDeliveryDelayLevel = RocketMQUtils.getInteger(this.props, RocketMQConfig.MSG_DELAY_LEVEL,\n                RocketMQConfig.MSG_DELAY_LEVEL00);\n        if (this.messageDeliveryDelayLevel < RocketMQConfig.MSG_DELAY_LEVEL00) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL00;\n        } else if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL18) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL18;\n        }\n    }\n\n    public void open(Configuration parameters) throws Exception {\n        Validate.notEmpty(props, \"Producer properties can not be empty\");\n        Validate.notNull(topicSelector, \"TopicSelector can not be null\");\n        Validate.notNull(serializationSchema, \"KeyValueSerializationSchema can not be null\");\n\n        producer = new DefaultMQProducer();\n        producer.setInstanceName(String.valueOf(getRuntimeContext().getIndexOfThisSubtask()));\n        RocketMQConfig.buildProducerConfigs(props, producer);\n        batchList = new LinkedList<>();\n\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void invoke(IN input) throws Exception {\n        Message msg = prepareMessage(input);\n\n        if (batchFlushOnCheckpoint) {\n            batchList.add(msg);\n            if (batchList.size() >= batchSize) {\n                flushSync();\n            }\n            return;\n        }\n\n        if (async) {\n            try {\n                producer.send(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        LOG.debug(\"Async send message success! result: {}\", sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable throwable) {\n                        if (throwable != null) {\n                            LOG.error(\"Async send message failure!\", throwable);\n                        }\n                    }\n                });\n            } catch (Exception e) {\n                LOG.error(\"Async send message failure!\", e);\n            }\n        } else {\n            try {\n                SendResult result = producer.send(msg);\n                LOG.debug(\"Sync send message result: {}\", result);\n            } catch (Exception e) {\n                LOG.error(\"Sync send message failure!\", e);\n            }\n        }\n    }\n\n    private Message prepareMessage(IN input) {\n        String topic = topicSelector.getTopic(input);\n        String tag = topicSelector.getTag(input) != null ? topicSelector.getTag(input) : \"\";\n\n        byte[] k = serializationSchema.serializeKey(input);\n        String key = k != null ? new String(k, StandardCharsets.UTF_8) : \"\";\n        byte[] value = serializationSchema.serializeValue(input);\n\n        Validate.notNull(topic, \"the message topic is null\");\n        Validate.notNull(value, \"the message body is null\");\n\n        Message msg = new Message(topic, tag, key, value);\n        if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL00) {\n            msg.setDelayTimeLevel(this.messageDeliveryDelayLevel);\n        }\n        return msg;\n    }\n\n    public void close() throws Exception {\n        if (producer != null) {\n            flushSync();\n            producer.shutdown();\n        }\n    }\n\n    private void flushSync() throws Exception {\n        if (batchFlushOnCheckpoint) {\n            synchronized (batchList) {\n                if (batchList.size() > 0) {\n                    producer.send(batchList);\n                    batchList.clear();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "import org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.connectors.rocketmq.RocketMQSink;\nimport org.apache.flink.streaming.connectors.rocketmq.common.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleTopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.TopicSelector;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.Message;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleKeyValueSerializationSchema;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization.SimpleMessage;\nimport org.apache.flink.streaming.connectors.rocketmq.common.serialization"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with configurable group, tags, and keys.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending, and shutdown operations. The class provides methods to start the producer, send messages synchronously, and gracefully shut down the producer.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- group: String - The producer group name\n- topic: String - The topic to which messages will be sent\n- tags: String - The tags for message categorization\n- keys: String - The keys for message identification\n\nMethods:\n- Producer(String group, String topic, String tags, String keys) -> void - Constructor that initializes the producer with given group, topic, tags, and keys\n- start() -> void - Starts the producer instance\n- sendMessage(String messageContent) -> SendResult - Synchronously sends a message with the given content and returns the send result\n- shutdown() -> void - Shuts down the producer instance\n- buildCommandline(String[] args) -> CommandLine - Static method that builds and parses command line arguments for producer configuration",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) throws MQClientException {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n        this.producer.setInstanceName(Long.toString(System.currentTimeMillis()));\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(\n            topic,\n            tags,\n            keys,\n            messageContent.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        final Options options = new Options();\n        Option opt = new Option(\"h\", \"help\", false, \"Print help\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"g\", \"producerGroup\", true, \"Producer Group Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Topic Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"a\", \"tags\", true, \"Tags Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"k\", \"keys\", true, \"Keys Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"msgCount\", true, \"Message Count\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        DefaultParser parser = new DefaultParser();\n        HelpFormatter hf = new HelpFormatter();\n        hf.setWidth(110);\n        CommandLine commandLine = null;\n        try {\n            commandLine = parser.parse(options, args);\n            if (commandLine.hasOption('h')) {\n                hf.printHelp(\"producer\", options, true);\n                return null;\n            }\n        } catch (ParseException e) {\n            hf.printHelp(\"producer\", options, true);\n            return null;\n        }\n\n        return commandLine;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws MQClientException {\n        Message msg = new Message(topic, tags, keys, messageContent.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) throws ParseException {\n        Options options = new Options();\n        options.addOption(\"g\", \"group\", true, \"Producer group name\");\n        options.addOption(\"t\", \"topic\", true, \"Topic to send messages to\");\n        options.addOption(\"a\", \"tags\", true, \"Tags for message categorization\");\n        options.addOption(\"k\", \"keys\", true, \"Keys for message identification\");\n\n        CommandLineParser parser = new DefaultParser();\n        return parser.parse(options, args);\n    }\n}"
  },
  {
    "Task_id": 395,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to specified topics with callback handling for success and failure cases.\n\nClass Description: RMQAsyncSendProducer is a RocketMQ asynchronous message producer that sends messages to a specified topic and handles responses through callbacks. It tracks successful sends and exceptions, and provides methods for waiting for responses and shutting down the producer.\n\nAttributes:\n- nsAddr: String - The NameServer address for RocketMQ\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- sendCallback: SendCallback - Callback handler for message send results\n- successSendResult: List<SendResult> - Thread-safe list of successful send results\n- exceptionMsgCount: AtomicInteger - Counter for messages that failed to send\n- msgSize: int - The number of messages to send\n- logger: Logger - SLF4J logger instance\n- topic: String - The topic to which messages will be sent (inherited from AbstractMQProducer)\n- msgBodys: [Data Structure] - Stores message bodies (inherited from AbstractMQProducer)\n- originMsgs: [Data Structure] - Stores original messages (inherited from AbstractMQProducer)\n\nMethods:\n- RMQAsyncSendProducer(String nsAddr, String topic) -> void - Constructor that initializes the producer with NameServer address and topic\n- create() -> void - Creates and configures the DefaultMQProducer instance\n- start() -> void - Starts the producer instance\n- asyncSend(Object msg) -> void - Asynchronously sends a single message\n- asyncSend(int msgSize) -> void - Asynchronously sends multiple messages (quantity specified by msgSize)\n- asyncSend(Object msg, MessageQueueSelector selector, Object arg) -> void - Asynchronously sends a message with queue selection\n- waitForResponse(int timeoutMills) -> void - Waits for all responses until timeout\n- shutdown() -> void - Shuts down the producer (overrides AbstractMQProducer method)",
    "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.test.clientinterface.AbstractMQProducer;\nimport org.apache.rocketmq.test.sendresult.ResultWrapper;\nimport org.apache.rocketmq.test.util.RandomUtil;\nimport org.apache.rocketmq.test.util.TestUtil;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private static Logger logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n    private String nsAddr = null;\n    private DefaultMQProducer producer = null;\n    private SendCallback sendCallback = null;\n    private List<SendResult> successSendResult = Collections.synchronizedList(new ArrayList<SendResult>());\n    private AtomicInteger exceptionMsgCount = new AtomicInteger(0);\n    private int msgSize = 0;\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        super(topic);\n        this.nsAddr = nsAddr;\n        sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n            }\n            @Override\n            public void onException(Throwable throwable) {\n                exceptionMsgCount.getAndIncrement();\n            }\n        };\n        create();\n        start();\n    }\n\n    private void create() {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(RandomUtil.getStringByUUID());\n        producer.setInstanceName(RandomUtil.getStringByUUID());\n        if (nsAddr != null) {\n            producer.setNamesrvAddr(nsAddr);\n        }\n    }\n\n    private void start() {\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            logger.error(\"producer start failed!\");\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(Object msg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(int msgSize) {\n        this.msgSize = msgSize;\n        for (int i = 0; i < msgSize; i++) {\n            Message msg = new Message(topic, RandomUtil.getStringByUUID().getBytes(StandardCharsets.UTF_8));\n            this.asyncSend(msg);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, selector, arg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        long startTime = System.currentTimeMillis();\n        while (this.successSendResult.size() != this.msgSize) {\n            if (System.currentTimeMillis() - startTime < timeoutMills) {\n                TestUtil.waitForMonment(100);\n            } else {\n                logger.info(\"timeout but still not recv all response!\");\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueueSelector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private final String nsAddr;\n    private final DefaultMQProducer producer;\n    private final SendCallback sendCallback;\n    private final List<SendResult> successSendResult;\n    private final AtomicInteger exceptionMsgCount;\n    private final Logger logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        super(topic);\n        this.nsAddr = nsAddr;\n        this.producer = new DefaultMQProducer();\n        this.sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n                logger.info(\"Message sent successfully: {}\", sendResult);\n            }\n\n            @Override\n            public void onException(Throwable throwable) {\n                exceptionMsgCount.incrementAndGet();\n                logger.error(\"Failed to send message: \", throwable);\n            }\n        };\n        this.successSendResult = new CopyOnWriteArrayList<>();\n        this.exceptionMsgCount = new AtomicInteger(0);\n    }\n\n    public void create() {\n        producer.setNamesrvAddr(nsAddr);\n        producer.setProducerGroup(\"RMQAsyncSendProducerGroup\");\n        try {\n            producer.start();\n            logger.info(\"RocketMQ producer started successfully.\");\n        } catch (MQClientException e) {\n            logger.error(\"Failed to start RocketMQ producer.\", e);\n        }\n    }\n\n    @Override\n    public void start() {\n        create();\n    }\n\n    public void asyncSend(Object msg) {\n        Message message = buildMessage(msg);\n        producer.send(message, sendCallback);\n    }\n\n    public void asyncSend(int msgSize) {\n        for (int i = 0; i < msgSize; i++) {\n            Object msg = getMsgBody(i);\n            asyncSend(msg);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message message = buildMessage(msg);\n        producer.send(message, selector, arg, sendCallback);\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        try {\n            Thread.sleep(timeoutMills);\n        } catch (InterruptedException e) {\n            logger.warn(\"Wait for response interrupted.\", e);\n        }\n        logger.info(\"Total successful sends: {}, Failed sends: {}\", successSendResult.size(), exceptionMsgCount.get());\n    }\n\n    @Override\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n            logger.info(\"RocketMQ producer shutdown completed.\");\n        }\n    }\n\n    private Message buildMessage(Object msg) {\n        return new Message(topic, msg.toString().getBytes());\n    }\n}"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "import org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n    private final Logger mLog;\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n    private final NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession;\n    private final AtomicBoolean mConnecting = new AtomicBoolean(false);\n    private long mLastConnectionAttempt;\n    private final IcecastHTTPConfiguration configuration;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        this.configuration = configuration;\n        mLog = configuration.getLogger();\n        mSocketConnector = new NioSocketConnector();\n        mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n    }\n\n    public boolean connect() {\n        if (mConnecting.get()) {\n            return false;\n        }\n\n        if (!canConnect()) {\n            return false;\n        }\n\n        mConnecting.set(true);\n        mLastConnectionAttempt = System.currentTimeMillis();\n\n        try {\n            mSocketConnector.connect(configuration.getHost(), configuration.getPort());\n            return true;\n        } catch (IOException e) {\n            mLog.error(\"Failed to connect to Icecast server\", e);\n            mConnecting.set(false);\n            return false;\n        }\n    }\n\n    public void disconnect() {\n        if (mStreamingSession != null && mStreamingSession.isConnected()) {\n            mStreamingSession.closeNow();\n            mStreamingSession = null;\n        }\n    }\n\n    public boolean connected() {\n        return mStreamingSession != null && mStreamingSession.isConnected();\n    }\n\n    public boolean canConnect() {\n        return !mConnecting.get() && System.currentTimeMillis() - mLastConnectionAttempt >= RECONNECT_INTERVAL_MILLISECONDS;\n    }\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        return configuration;\n    }\n\n    public void setBroadcastState(BroadcastState state) {\n        // Implementation for setting broadcast state\n    }\n\n    public BroadcastState getBroadcastState() {\n        // Implementation for getting broadcast state\n        return null;\n    }\n\n    public Map<String, String> getHTTPHeaders() {\n        // Implementation for returning HTTP headers\n        return null;\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) {\n            mStreamingSession = session;\n            mConnecting.set(false);\n            try {\n                session.write(buildHTTPPutRequest());\n            } catch (Exception e) {\n                mLog.error(\"Failed to send HTTP PUT request\", e);\n                session.closeNow();\n            }\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) {\n            mStreamingSession = null;\n            mLog.info(\"Session closed with Icecast server\");\n            if (canConnect()) {\n                connect();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) {\n            mLog.error(\"Exception caught in Icecast session\", throwable);\n            session.closeNow();\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) {\n            // Handle server responses\n        }\n\n        private String buildHTTPPutRequest() {\n            StringBuilder request = new StringBuilder();\n            request.append(\"PUT /\").append(configuration.getMountPoint()).append(\" HTTP/1.1\\r\\n\");\n            request.append(\"Host: \").append(configuration.getHost()).append(\":\").append(configuration.getPort()).append(\"\\r\\n\");\n            request.append(\"User-Agent: IcecastHTTPAudioBroadcaster\\r\\n\");\n            request.append(\"Content-Type: audio/mpeg\\r\\n\");\n            request.append(\"Transfer-Encoding: chunked\\r\\n\");\n            request.append(\"Authorization: Basic \").append(java.util.Base64.getEncoder().encodeToString((configuration.getUsername() + \":\" + configuration.getPassword()).getBytes())).append(\"\\r\\n\");\n            request.append(\"Icy-Metadata: 1\\r\\n\");\n            request.append(\"Content-Length: 0\\r\\n\");\n            request.append(\"\\r\\n\");\n            return request.toString();\n        }\n    }\n}"
  },
  {
    "Task_id": 402,
    "Instruction": "Task Description: Create an asynchronous task in Android that performs an HTTP GET request to a specified server using TCP socket communication, reads the response, and returns it to the caller via a callback mechanism.\n\nClass Description: HttpGetTask is an AsyncTask subclass that handles network operations in the background to prevent blocking the UI thread. It establishes a TCP connection to a server, sends an HTTP GET request, reads the response, and delivers it to a retained fragment through a weak reference.\n\nAttributes:\n- TAG: [String] - A constant for logging purposes\n- HOST: [String] - The hostname of the server to connect to\n- USER_NAME: [String] - The username for authentication\n- HTTP_GET_COMMAND: [String] - The formatted HTTP GET request string\n- mListener: [WeakReference<RetainedFragment>] - Weak reference to the fragment that will receive the result\n\nMethods:\n- HttpGetTask([RetainedFragment retainedFragment]) -> [void] - Constructor that initializes the task with a weak reference to the calling fragment\n- doInBackground([Void... params]) -> [String] - Performs the network operations in the background (opens socket, sends request, reads response)\n- onPostExecute([String result]) -> [void] - Delivers the result to the retained fragment after task completion\n- readStream([InputStream in]) -> [String] - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.ref.WeakReference;\nimport java.net.Socket;\n\npublic class HttpGetTask extends AsyncTask<Void, Void, String> {\n\n    private static final String TAG = \"HttpGetTask\";\n    private static final String HOST = \"api.geonames.org\";\n    private static final String USER_NAME = \"aporter\";\n    private static final String HTTP_GET_COMMAND = \"GET /earthquakesJSON?north=44.1&south=-9.9&east=-22.4&west=55.2&username=\"\n            + USER_NAME + \" HTTP/1.1\" + \"\\n\" + \"Host: \" + HOST + \"\\n\"\n            + \"Connection: close\" + \"\\n\\n\";\n\n    private final WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(HOST, 80);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(HTTP_GET_COMMAND);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        if (null != mListener.get()) {\n            mListener.get().onDownloadFinished(result);\n        }\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuilder data = new StringBuilder();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import android.os.AsyncTask;\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\n\npublic class HttpGetTask extends AsyncTask<Void, Void, String> {\n    private static final String TAG = \"HttpGetTask\";\n    private static final String HOST = \"example.com\";\n    private static final String USER_NAME = \"user\";\n    private static final String HTTP_GET_COMMAND = \"GET / HTTP/1.1\\r\\nHost: \" + HOST + \"\\r\\nAuthorization: Basic \" + USER_NAME + \"\\r\\nConnection: close\\r\\n\\r\\n\";\n    private WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        try (Socket socket = new Socket(HOST, 80)) {\n            OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream());\n            writer.write(HTTP_GET_COMMAND);\n            writer.flush();\n\n            return readStream(new BufferedReader(new InputStreamReader(socket.getInputStream())));\n        } catch (Exception e) {\n            Log.e(TAG, \"Error during HTTP GET request\", e);\n            return null;\n        }\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        RetainedFragment fragment = mListener.get();\n        if (fragment != null) {\n            fragment.onHttpResult(result);\n        }\n    }\n\n    private String readStream(BufferedReader reader) throws Exception {\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line).append(\"\\n\");\n        }\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TCPSender {\n    public static void sendString(String str) {\n        try (Socket socket = new Socket(\"localhost\", 12345)) {\n            OutputStream output = socket.getOutputStream();\n            output.write(str.getBytes());\n            output.flush();\n        } catch (Exception e) {\n            System.err.println(\"Error sending message: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 404,
    "Instruction": "Task Description: Create a TCP client class in Java that can establish a connection to a server, send requests, and receive responses.\n\nClass Description: The TcpClient class provides functionality to connect to a TCP server, send string requests, and receive string responses. It handles socket creation, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n- TAG: String - A constant for logging purposes (default value: \"HttpGet\")\n\nMethods:\n- TcpClient(String host, int port) -> None - Constructor that initializes the host and port attributes\n- sendRequest(String request) -> String - Sends the request string to the server and returns the response\n- readStream(InputStream in) -> String - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TcpClient {\n\n    private static final String TAG = \"HttpGet\";\n    private String host;\n    private int port;\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(host, port);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(request);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (UnknownHostException exception) {\n            exception.printStackTrace();\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuffer data = new StringBuffer();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TcpClient {\n    private String host;\n    private int port;\n    private static final String TAG = \"HttpGet\";\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) {\n        try (Socket socket = new Socket(host, port);\n             OutputStream out = socket.getOutputStream();\n             InputStream in = socket.getInputStream()) {\n\n            out.write(request.getBytes());\n            out.flush();\n\n            return readStream(in);\n        } catch (IOException e) {\n            System.err.println(TAG + \": Error sending request - \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private String readStream(InputStream in) {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            System.err.println(TAG + \": Error reading stream - \" + e.getMessage());\n        }\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport com.codahale.metrics.CollectorRegistry;\n\npublic class Graphite {\n    private final String host;\n    private final int port;\n    private final Logger logger;\n    private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9._\\\\-]\");\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.logger = Logger.getLogger(Graphite.class.getName());\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))) {\n            for (String name : registry.getMetricNames()) {\n                String sanitizedName = sanitize(name);\n                String value = registry.getMetricValue(name).toString();\n                writer.write(sanitizedName + \" \" + value + \"\\n\");\n            }\n            writer.flush();\n        } catch (IOException e) {\n            logger.severe(\"Failed to push metrics to Graphite: \" + e.getMessage());\n            throw e;\n        }\n    }\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        return new PushThread(registry, intervalSeconds);\n    }\n\n    private class PushThread extends Thread {\n        private final CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n            setDaemon(true);\n            setName(\"Graphite-Metrics-Pusher\");\n        }\n\n        @Override\n        public void run() {\n            while (!isInterrupted()) {\n                try {\n                    push(registry);\n                } catch (IOException e) {\n                    logger.severe(\"Error pushing metrics: \" + e.getMessage());\n                }\n                try {\n                    Thread.sleep(intervalSeconds * 1000);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n    }\n\n    private String sanitize(String name) {\n        return INVALID_GRAPHITE_CHARS.matcher(name).replaceAll(\"_\");\n    }\n}"
  },
  {
    "Task_id": 406,
    "Instruction": "Task Description: Write a Java function that tests a server's handling of a malformed HTTP request by sending a bad request and verifying the server's response.\n\nFunction Description: The function `testBadRequest` attempts to send a deliberately malformed HTTP POST request to a server and verifies that the server responds with a \"400 Bad Request\" error. The function creates a TCP socket connection to the server, sends the malformed request, reads the server's response, and compares it to the expected response. If the response matches, the test passes; otherwise, it may throw an IOException if the connection is closed prematurely.\n\nInput: None (The server address and port are obtained from `DefaultServer.getDefaultServerAddress()` internally)\n\nOutput: None (The function asserts the server's response matches the expected \"400 Bad Request\" response. Any mismatch or IOException will result in a test failure or exception.)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Socket;\n\npublic void testBadRequest() throws IOException {\n    String request = \"POST /\\r HTTP/1.1\\r\\nTrailer:foo, bar\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n9\\r\\nabcdefghi\\r\\n0\\r\\nfoo: fooVal\\r\\n bar: barVal\\r\\n\\r\\n\";\n    String response1 = \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\";\n    Socket s = new Socket(DefaultServer.getDefaultServerAddress().getAddress(), DefaultServer.getDefaultServerAddress().getPort());\n    try {\n        s.getOutputStream().write(request.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        int read = 0;\n        byte[] buf = new byte[100];\n        while (read < response1.length()) {\n            int r = s.getInputStream().read(buf);\n            if (r <= 0) break;\n            if (r > 0) {\n                read += r;\n                sb.append(new String(buf, 0, r));\n            }\n        }\n        Assert.assertEquals(response1, sb.toString());\n\n    } catch (IOException expected) {\n        //this can happen as well, as in some cases we may not have fully consumed the read side\n        //before the connection is shutdown, namely when we are running in test.single\n    } finally {\n        s.close();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class HttpTest {\n    public static void testBadRequest() throws IOException {\n        String serverAddress = DefaultServer.getDefaultServerAddress();\n        int port = 8080; // Assuming default port\n\n        try (Socket socket = new Socket(serverAddress, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            // Send a malformed HTTP POST request\n            out.println(\"POST / HTTP/1.1\");\n            out.println(\"Host: \" + serverAddress);\n            out.println(\"Content-Length: 10\");\n            out.println(\"InvalidHeader: Value\");\n            out.println(\"\");\n            out.println(\"MalformedBody\");\n\n            // Read the response from the server\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n            }\n\n            // Check if the response contains \"400 Bad Request\"\n            if (!response.toString().contains(\"400 Bad Request\")) {\n                throw new IOException(\"Expected 400 Bad Request, but got: \" + response.toString());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 407,
    "Instruction": "Task Description: Create a Java class that acts as a TCP client within a servlet context, handling HTTP requests by forwarding them to a specified server via TCP and returning the server's response.\n\nClass Description: The Lisplet class extends HttpServlet to handle HTTP POST requests. It establishes a TCP connection to a specified host and port, sends the HTTP request data in a custom format, processes the server's response, and returns it to the client.\n\nAttributes:\n- host: String - The hostname or IP address of the TCP server to connect to\n- port: int - The port number of the TCP server to connect to\n\nMethods:\n- doPost(HttpServletRequest req, HttpServletResponse resp) -> void - Handles HTTP POST requests by establishing a TCP connection, sending the request, processing the response, and closing the connection\n- transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) -> void - Transfers the response body from the server to the HTTP response output stream\n- getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) -> boolean - Reads and processes the response header from the server\n- sendRequest(HttpServletRequest req, Writer writer) -> void - Formats and sends the HTTP request data to the server\n- writeTagValuePair(Writer writer, String tag, String value) -> void - Helper method to write tag-value pairs in the custom request format",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.http.*;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        Socket socket = new Socket(host, port);\n        try {\n            Writer writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            sendRequest(req, writer);\n            PushbackInputStream strm = new PushbackInputStream(\n                    new BufferedInputStream(socket.getInputStream()));\n            if(getResponseHeader(req, resp, strm))\n                transferResponseBody(resp, strm);\n        } finally {\n            socket.close();\n        }\n    }\n\n    protected void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm)\n            throws ServletException, IOException {\n        OutputStream outs = resp.getOutputStream();\n        int b;\n        while((b = strm.read()) != -1)\n            outs.write(b);\n        outs.flush();\n    }\n\n    protected boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm)\n        throws ServletException, IOException {\n        ArrayList list = readSexpr(strm);\n        return processResponse(req, resp, list);\n    }\n\n    protected void sendRequest(HttpServletRequest req, Writer writer)\n            throws IOException {\n        writer.write(\"(\");\n        writeTagValuePair(writer, \"method\", req.getMethod());\n        writeTagValuePair(writer, \"uri\", req.getRequestURI());\n        writeTagValuePair(writer, \"protocol\", req.getProtocol());\n        writer.write(\")\");\n        writer.flush();\n    }\n\n    protected void writeTagValuePair(Writer writer, String tag, String value)\n            throws IOException {\n        writer.write(\"(\");\n        writer.write(tag);\n        writer.write(\" \");\n        writer.write(\"\\\"\");\n        writer.write(value.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\",\"\\\\\\\\\\\"\"));\n        writer.write(\"\\\"\");\n        writer.write(\")\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.net.Socket;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    public Lisplet(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             OutputStream outStream = socket.getOutputStream();\n             InputStream inStream = socket.getInputStream();\n             Writer writer = new OutputStreamWriter(outStream);\n             PushbackInputStream strm = new PushbackInputStream(inStream)) {\n\n            sendRequest(req, writer);\n            writer.flush();\n\n            if (!getResponseHeader(req, resp, strm)) {\n                return;\n            }\n\n            transferResponseBody(resp, strm);\n        }\n    }\n\n    private void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = strm.read(buffer)) != -1) {\n            resp.getOutputStream().write(buffer, 0, bytesRead);\n        }\n    }\n\n    private boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(strm));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\": \", 2);\n            if (parts.length == 2) {\n                String headerName = parts[0];\n                String headerValue = parts[1];\n                resp.setHeader(headerName, headerValue);\n            }\n        }\n        return true;\n    }\n\n    private void sendRequest(HttpServletRequest req, Writer writer) throws IOException {\n        writer.write(\"POST / HTTP/1.1\\r\\n\");\n        writer.write(\"Host: \" + req.getServerName() + \":\" + req.getServerPort() + \"\\r\\n\");\n        writer.write(\"Content-Type: \" + req.getContentType() + \"\\r\\n\");\n        writer.write(\"Content-Length: \" + req.getContentLength() + \"\\r\\n\");\n        writer.write(\"\\r\\n\");\n\n        if (req.getContentLength() > 0) {\n            byte[] content = new byte[req.getContentLength()];\n            InputStream inputStream = req.getInputStream();\n            inputStream.read(content);\n            writer.write(new String(content));\n        }\n    }\n\n    private void writeTagValuePair(Writer writer, String tag, String value) throws IOException {\n        writer.write(tag + \": \" + value + \"\\r\\n\");\n    }\n}"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with the OpenMHz API, including methods for testing connection authorization and uploading audio recordings with metadata.\n\nClass Description: OpenMHzHttpClient is a utility class that provides HTTP client operations for the OpenMHz API. It handles both synchronous and asynchronous requests, manages connection settings, and processes API responses. The class includes error handling and logging capabilities.\n\nAttributes:\n- mLog: Logger - SLF4J logger instance for error and debug logging\n- mHttpClient: HttpClient - Configured HTTP client instance with HTTP/2 support, redirect policy, and timeout settings\n\nMethods:\n- testConnection(String host, String systemName, String apiKey) -> String - Tests API connection and authorization by sending a POST request to the authorize endpoint. Returns status messages based on response code.\n  Input:\n    - host: String - Base URL of the OpenMHz server\n    - systemName: String - Name of the target system\n    - apiKey: String - API key for authentication\n  Output:\n    - String - Status message (\"OK\", \"Invalid API Key\", \"Invalid System Name\", \"No Response\", or \"Unknown Exception\")\n\n- sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) -> void - Asynchronously uploads an audio recording with metadata to the OpenMHz API using multipart/form-data format.\n  Input:\n    - uri: String - Target endpoint URL\n    - audioBytes: byte[] - Audio file data to upload\n    - boundary: String - Multipart boundary string\n    - apiKey: String - API key for authentication\n    - frequency: long - Frequency value in Hz\n    - timestampSeconds: long - Recording start time in seconds\n    - durationSeconds: int - Recording duration in seconds\n    - talkgroup: String - Talkgroup identifier\n    - radioId: String - Radio source identifier\n  Output: None (asynchronous operation with error logging)",
    "Canonical_solution": "import com.google.common.net.HttpHeaders;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OpenMHzHttpClient {\n\n    private final static Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String uri = host + \"/\" + systemName + \"/authorize\";\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"application/x-www-form-urlencoded\")\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(HttpRequest.BodyPublishers.ofString(\"api_key=\" + apiKey))\n            .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) {\n                return \"OK\";\n            } else if(response.statusCode() == 403) {\n                return \"Invalid API Key\";\n            } else if(response.statusCode() == 500) {\n                return \"Invalid System Name\";\n            }\n\n            return \"No Response\";\n        }\n        catch(Exception e) {  \n            Throwable throwableCause = e.getCause();\n\n            if(throwableCause instanceof ConnectException) {\n                return \"No Response\";\n            }\n\n            mLog.error(\"Exception connecting to OpenMHz server [\" + e.toString() + \"]\");\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, \n                                  long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        OpenMHzBuilder bodyBuilder = new OpenMHzBuilder();\n        bodyBuilder\n            .addFile(audioBytes)\n            .addPart(FormField.FREQ, frequency)\n            .addPart(FormField.START_TIME, timestampSeconds)\n            .addPart(FormField.STOP_TIME, timestampSeconds)\n            .addPart(FormField.CALL_LENGTH, durationSeconds)\n            .addPart(FormField.TALKGROUP_NUM, talkgroup)\n            .addPart(FormField.EMERGENCY, 0)\n            .addPart(FormField.API_KEY, apiKey)\n            .addPart(FormField.SOURCE_LIST, \"[{ \\\"pos\\\": 0.00, \\\"src\\\": \" + radioId + \"}]\");\n\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"multipart/form-data; boundary=\" + boundary)\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                    else {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.ContentType;\nimport org.apache.http.entity.mime.MultipartEntityBuilder;\nimport org.apache.http.entity.mime.content.ByteArrayBody;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class OpenMHzHttpClient {\n    private static final Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private final CloseableHttpClient mHttpClient;\n\n    public OpenMHzHttpClient() {\n        mHttpClient = HttpClients.custom()\n                .setSSLSocketFactory(new SSLContextBuilder().loadTrustMaterial(null, (chain, authType) -> true).build())\n                .setUserAgent(\"OpenMHz-Client/1.0\")\n                .setDefaultRequestConfig(RequestConfig.custom()\n                        .setSocketTimeout(30000)\n                        .setConnectTimeout(30000)\n                        .setConnectionRequestTimeout(30000)\n                        .build())\n                .setMaxConnTotal(100)\n                .setMaxConnPerRoute(20)\n                .setUseSystemProperties(true)\n                .build();\n    }\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        try {\n            String url = host + \"/api/v1/authorize\";\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setHeader(\"Content-Type\", \"application/json\");\n            httpPost.setHeader(\"Authorization\", \"Bearer \" + apiKey);\n\n            String json = String.format(\"{\\\"system_name\\\":\\\"%s\\\"}\", systemName);\n            httpPost.setEntity(new StringEntity(json, StandardCharsets.UTF_8));\n\n            CloseableHttpResponse response = mHttpClient.execute(httpPost);\n            int statusCode = response.getStatusLine().getStatusCode();\n\n            if (statusCode == 200) {\n                return \"OK\";\n            } else if (statusCode == 401) {\n                return \"Invalid API Key\";\n            } else if (statusCode == 403) {\n                return \"Invalid System Name\";\n            } else {\n                return \"No Response\";\n            }\n        } catch (IOException e) {\n            mLog.error(\"Exception during connection test: \", e);\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        try {\n            HttpPost httpPost = new HttpPost(uri);\n            httpPost.setHeader(\"Authorization\", \"Bearer \" + apiKey);\n            httpPost.setHeader(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n            MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n            builder.addPart(\"audio\", new ByteArrayBody(audioBytes, ContentType.APPLICATION_OCTET_STREAM, \"recording.wav\"));\n            builder.addTextBody(\"frequency\", String.valueOf(frequency), ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"timestamp_seconds\", String.valueOf(timestampSeconds), ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"duration_seconds\", String.valueOf(durationSeconds), ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"talkgroup\", talkgroup, ContentType.TEXT_PLAIN);\n            builder.addTextBody(\"radio_id\", radioId, ContentType.TEXT_PLAIN);\n\n            HttpEntity entity = builder.build();\n            httpPost.setEntity(entity);\n\n            mHttpClient.execute(httpPost);\n        } catch (IOException e) {\n            mLog.error(\"Error uploading audio recording: \", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TProfilerClient {\n    private static final String START_COMMAND = \"START\";\n    private static final String STOP_COMMAND = \"STOP\";\n    private static final String STATUS_COMMAND = \"STATUS\";\n    private static final String FLUSHMETHOD_COMMAND = \"FLUSHMETHOD\";\n\n    private void doSend(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             OutputStream out = socket.getOutputStream();\n             PrintWriter writer = new PrintWriter(out, true)) {\n            writer.println(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getStatus(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             InputStream in = socket.getInputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n            PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n            writer.println(command);\n            return read(in);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private String read(InputStream in) {\n        StringBuilder sb = new StringBuilder();\n        int data;\n        try {\n            while ((data = in.read()) != -1) {\n                if (data == '\\r') {\n                    break;\n                }\n                sb.append((char) data);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return sb.toString();\n    }\n\n    public void start(String server, int port) {\n        doSend(START_COMMAND, server, port);\n    }\n\n    public void stop(String server, int port) {\n        doSend(STOP_COMMAND, server, port);\n    }\n\n    public String status(String server, int port) {\n        return getStatus(STATUS_COMMAND, server, port);\n    }\n\n    public void flushMethod(String server, int port) {\n        doSend(FLUSHMETHOD_COMMAND, server, port);\n    }\n}"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.List;\n\npublic class Minitouch {\n    public static final String REMOTE_PATH = \"/data/local/tmp/\";\n    public static final String MINITOUCH_BIN = \"minitouch\";\n    private List<MinitouchListener> listenerList;\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n        this.listenerList = new java.util.ArrayList<>();\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        forward = createForward();\n        if (forward != null) {\n            new Thread(() -> startInitialThread(\"localhost\", forward.getLocalPort())).start();\n        }\n    }\n\n    public void kill() {\n        try {\n            if (minitouchSocket != null && !minitouchSocket.isClosed()) {\n                minitouchSocket.close();\n            }\n            if (forward != null) {\n                removeForward(forward);\n            }\n            onClose();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendEvent(String str) {\n        try {\n            if (minitouchOutputStream != null) {\n                minitouchOutputStream.write(str.getBytes());\n                minitouchOutputStream.flush();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        return generateForwardInfo();\n    }\n\n    private void removeForward(AdbForward forward) {\n        // Implementation to remove ADB forward\n    }\n\n    private void startInitialThread(String host, int port) {\n        try {\n            minitouchSocket = new Socket(host, port);\n            minitouchOutputStream = minitouchSocket.getOutputStream();\n            onStartup(true);\n        } catch (Exception e) {\n            onStartup(false);\n        }\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose();\n        }\n    }\n\n    private AdbForward generateForwardInfo() {\n        // Implementation to generate ADB forward info\n        return new AdbForward(5555, 5555);\n    }\n\n    public interface MinitouchListener {\n        void onStartup(boolean success);\n        void onClose();\n    }\n\n    public static class AdbDevice {\n        // Placeholder for ADB device implementation\n    }\n\n    public static class AdbForward {\n        private int localPort;\n        private int remotePort;\n\n        public AdbForward(int localPort, int remotePort) {\n            this.localPort = localPort;\n            this.remotePort = remotePort;\n        }\n\n        public int getLocalPort() {\n            return localPort;\n        }\n    }\n}"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making various types of HTTP requests and handling responses.\n\nClass Description: The HttpCommunicationClient class provides methods for performing HTTP operations (GET, POST) and handling redirects. It manages an HTTP client instance and supports custom headers and browser-like requests.\n\nAttributes:\naddress: [InetSocketAddress] - The target server address (host and port) for HTTP requests\nhttpClient: [HttpClient] - The underlying HTTP client instance used for making requests\n\nMethods:\nsetupHttpClient: [setupHttpClient(ThreadPool threadPool)] -> [void] - Initializes the HTTP client with redirect policy and thread pool\ncloseClient: [closeClient()] -> [void] - Closes the HTTP client resources\nexecuteAndDefaultAssertions: [executeAndDefaultAssertions(HttpRequest request)] -> [HttpResponse<String>] - Internal method to execute requests and handle responses\nget: [get(String path, String[]... headers)] -> [HttpResponse<String>] - Performs a GET request to specified path with optional headers\nbrowserGet: [browserGet(String uri)] -> [HttpResponse<String>] - Performs a GET request with browser-like User-Agent header\npost: [post(String path)] -> [HttpResponse<String>] - Performs a POST request to specified path\ngetAllRedirectLocations: [getAllRedirectLocations(String path, String[]... headers)] -> [List<String>] - Retrieves all redirect locations for a request\nbrowserHeader: [static browserHeader()] -> [String[]] - Returns browser-like User-Agent header (static utility method)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpCommunicationClient {\n\n    protected InetSocketAddress address;\n    protected HttpClient httpClient;\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .executor(threadPool.generic())\n            .build();\n    }\n\n    public void closeClient() {\n        httpClient.close();\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        var resp = httpClient.send(request, BodyHandlers.ofString());\n        return resp;\n    }\n\n    public HttpResponse<String> get(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        return executeAndDefaultAssertions(builder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        return get(uri, browserHeader());\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(BodyPublishers.noBody())\n            .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        var response = httpClient.send(builder.build(), BodyHandlers.discarding());\n        response = response.previousResponse().orElse(null);\n        List<String> redirects = new ArrayList<>();\n        while (response != null) {\n            redirects.addAll(response.headers().allValues(\"location\"));\n            response = response.previousResponse().orElse(null);\n        }\n        return redirects;\n    }\n\n    static String[] browserHeader() {\n        return new String[] {\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\"\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class HttpCommunicationClient {\n    private final InetSocketAddress address;\n    private HttpClient httpClient;\n\n    public HttpCommunicationClient(InetSocketAddress address) {\n        this.address = address;\n    }\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        ExecutorService executor = Executors.newFixedThreadPool(threadPool.getCorePoolSize());\n        httpClient = HttpClient.newBuilder()\n                .executor(executor)\n                .followRedirects(HttpClient.Redirect.ALWAYS)\n                .build();\n    }\n\n    public void closeClient() {\n        if (httpClient != null) {\n            ((ThreadPoolExecutor) httpClient.executor()).shutdownNow();\n        }\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(String path, String[]... headers) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(new URI(\"http\", null, address.getHostString(), address.getPort(), path, null, null))\n                .GET()\n                .headers(headers.length > 0 ? headers[0] : new String[]{})\n                .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(uri))\n                .GET()\n                .header(\"User-Agent\", \"Mozilla/5.0\")\n                .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(new URI(\"http\", null, address.getHostString(), address.getPort(), path, null, null))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[]... headers) throws Exception {\n        List<String> redirectLocations = new ArrayList<>();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(new URI(\"http\", null, address.getHostString(), address.getPort(), path, null, null))\n                .GET()\n                .headers(headers.length > 0 ? headers[0] : new String[]{})\n                .build();\n\n        HttpResponse<String> response = executeAndDefaultAssertions(request);\n        if (response.statusCode() == 301 || response.statusCode() == 302) {\n            redirectLocations.add(response.headerString(\"Location\"));\n        }\n        return redirectLocations;\n    }\n\n    public static String[] browserHeader() {\n        return new String[]{\"User-Agent: Mozilla/5.0\"};\n    }\n\n    public static class ThreadPool {\n        private final int corePoolSize;\n\n        public ThreadPool(int corePoolSize) {\n            this.corePoolSize = corePoolSize;\n        }\n\n        public int getCorePoolSize() {\n            return corePoolSize;\n        }\n    }\n}"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TCPSender {\n    public static void sendString(String str) {\n        try (Socket socket = new Socket(\"localhost\", 12345)) {\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(str.getBytes());\n            outputStream.flush();\n        } catch (Exception e) {\n            System.err.println(\"Error sending string: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport org.json.JSONObject;\n\npublic class SocketTest {\n    private static final int SERVER_SOCKET_PORT = 12345;\n    private static final String HARDWARE_ID = \"HW001\";\n\n    public static void doSocketTest() {\n        try (Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n             OutputStream outputStream = socket.getOutputStream()) {\n\n            JSONObject measurementData = new JSONObject();\n            measurementData.put(\"hardwareId\", HARDWARE_ID);\n            measurementData.put(\"temperature\", 25.5);\n            measurementData.put(\"humidity\", 60.3);\n\n            String jsonMessage = measurementData.toString();\n            outputStream.write(jsonMessage.getBytes());\n            outputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 426,
    "Instruction": "Task Description: Implement a Java class that provides TCP client functionality using Java NIO (Non-blocking I/O) for efficient network communication. The class should support both plaintext and SSL connections, manage multiple connections, and handle connection lifecycle operations.\n\nClass Description: The NioTcpClient class is a non-blocking TCP client implementation using Java NIO. It manages multiple socket connections, handles connection establishment, and provides methods for connection management. It supports both plaintext and SSL connections through a configurable transmission mechanism.\n\nAttributes:\n- nioSelector: Selector - The NIO selector used for managing multiple channels\n- keyMap: Map<String, SelectionKey> - Maps connection IDs to their corresponding selection keys\n- time: Time - Provides time-related functionality\n- sslFactory: SSLFactory - Handles SSL-related operations if SSL connections are used\n- networkConfig: NetworkConfig - Contains network configuration parameters\n\nMethods:\n- NioTcpClient(Time, SSLFactory, NetworkConfig) -> NioTcpClient - Constructor that initializes the selector, time, SSL factory, and network configuration\n- connect(InetSocketAddress, int, int, PortType) -> String - Establishes a new connection to the specified address with given buffer sizes and port type, returns a connection ID\n- generateConnectionId(SocketChannel) -> String - Generates a unique connection ID based on local and remote socket addresses\n- createTransmission(String, SelectionKey, String, int, PortType, SSLFactory.Mode) -> Transmission - Creates an appropriate transmission object (plaintext or SSL) for the connection\n- disconnect(String) -> void - Disconnects the connection with the specified ID\n- close() -> void - Closes all connections and releases all resources",
    "Canonical_solution": "import com.github.ambry.network.NetworkSend;\nimport com.github.ambry.network.NetworkReceive;\nimport com.github.ambry.network.PortType;\nimport com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.config.NetworkConfig;\nimport com.github.ambry.utils.Time;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NioTcpClient {\n\n  private final java.nio.channels.Selector nioSelector;\n  private final Map<String, SelectionKey> keyMap;\n  private final Time time;\n  private final SSLFactory sslFactory;\n  private final NetworkConfig networkConfig;\n\n  public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n    this.nioSelector = java.nio.channels.Selector.open();\n    this.time = time;\n    this.keyMap = new HashMap<>();\n    this.sslFactory = sslFactory;\n    this.networkConfig = networkConfig;\n  }\n\n  public String connect(InetSocketAddress address, int sendBufferSize, int receiveBufferSize, PortType portType)\n      throws IOException {\n    SocketChannel channel = SocketChannel.open();\n    channel.configureBlocking(false);\n    channel.socket().setKeepAlive(true);\n    channel.socket().setSendBufferSize(sendBufferSize);\n    channel.socket().setReceiveBufferSize(receiveBufferSize);\n    channel.socket().setTcpNoDelay(true);\n    try {\n      channel.connect(address);\n    } catch (IOException e) {\n      channel.close();\n      throw e;\n    }\n    String connectionId = generateConnectionId(channel);\n    SelectionKey key = channel.register(this.nioSelector, SelectionKey.OP_CONNECT);\n    Transmission transmission = createTransmission(connectionId, key, address.getHostName(), address.getPort(), portType,\n        SSLFactory.Mode.CLIENT);\n    key.attach(transmission);\n    this.keyMap.put(connectionId, key);\n    return connectionId;\n  }\n\n  private String generateConnectionId(SocketChannel channel) {\n    return channel.socket().getLocalAddress().getHostAddress() + \":\" + channel.socket().getLocalPort() + \"-\" +\n        channel.socket().getInetAddress().getHostAddress() + \":\" + channel.socket().getPort();\n  }\n\n  protected Transmission createTransmission(String connectionId, SelectionKey key, String hostname, int port,\n      PortType portType, SSLFactory.Mode mode) throws IOException {\n    if (portType == PortType.PLAINTEXT) {\n      return new PlainTextTransmission(connectionId, (SocketChannel) key.channel(), key, time, null, networkConfig);\n    } else if (portType == PortType.SSL) {\n      return new SSLTransmission(sslFactory, connectionId, (SocketChannel) key.channel(), key, hostname, port, time,\n          null, mode, networkConfig);\n    } else {\n      throw new IllegalArgumentException(\"Unsupported portType \" + portType);\n    }\n  }\n\n  public void disconnect(String connectionId) {\n    SelectionKey key = this.keyMap.get(connectionId);\n    if (key != null) {\n      key.cancel();\n    }\n  }\n\n  public void close() throws IOException {\n    for (SelectionKey key : this.nioSelector.keys()) {\n      Transmission transmission = (Transmission) key.attachment();\n      if (transmission != null) {\n        transmission.close();\n      }\n      key.channel().close();\n    }\n    this.nioSelector.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class NioTcpClient {\n    private final Selector nioSelector;\n    private final Map<String, SelectionKey> keyMap;\n    private final Time time;\n    private final SSLFactory sslFactory;\n    private final NetworkConfig networkConfig;\n\n    public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n        this.nioSelector = Selector.open();\n        this.keyMap = new ConcurrentHashMap<>();\n        this.time = time;\n        this.sslFactory = sslFactory;\n        this.networkConfig = networkConfig;\n    }\n\n    public String connect(InetSocketAddress address, int sendBufferSize, int receiveBufferSize, PortType portType) throws IOException {\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        channel.socket().setSendBufferSize(sendBufferSize);\n        channel.socket().setReceiveBufferSize(receiveBufferSize);\n        channel.connect(address);\n\n        SelectionKey key = channel.register(nioSelector, SelectionKey.OP_CONNECT);\n        key.attach(createTransmission(generateConnectionId(channel), key, address.toString(), sendBufferSize, receiveBufferSize, portType, sslFactory.getMode()));\n        return generateConnectionId(channel);\n    }\n\n    private String generateConnectionId(SocketChannel channel) {\n        return channel.socket().getLocalAddress() + \"-\" + channel.socket().getRemoteAddress();\n    }\n\n    private Transmission createTransmission(String connectionId, SelectionKey key, String remoteAddress, int sendBufferSize, int receiveBufferSize, PortType portType, SSLFactory.Mode sslMode) {\n        if (portType == PortType.SSL) {\n            return sslFactory.createTransmission(connectionId, key, remoteAddress, sendBufferSize, receiveBufferSize, sslMode);\n        } else {\n            return new PlaintextTransmission(connectionId, key, remoteAddress, sendBufferSize, receiveBufferSize);\n        }\n    }\n\n    public void disconnect(String connectionId) {\n        SelectionKey key = keyMap.remove(connectionId);\n        if (key != null) {\n            key.cancel();\n            try {\n                key.channel().close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() throws IOException {\n        for (SelectionKey key : keyMap.values()) {\n            key.cancel();\n            try {\n                key.channel().close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        nioSelector.close();\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                nioSelector.select();\n                for (SelectionKey key : nioSelector.selectedKeys()) {\n                    keyMap.get(key.attachment().getConnectionId()).interestOps(0);\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class TCPConnection {\n    public static final int MTU = 16384;\n    public static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20; // IPv4 (20) + TCP (20)\n    private final StreamBuffer clientToNetwork;\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private final AtomicBoolean connected = new AtomicBoolean(false);\n    private final ConnectionId id;\n    private final Client client;\n    private final Selector selector;\n    private final IPv4Header ipv4Header;\n    private final TCPHeader tcpHeader;\n    private final int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        this.id = id;\n        this.client = client;\n        this.selector = selector;\n        this.ipv4Header = ipv4Header;\n        this.tcpHeader = tcpHeader;\n        this.channel = createChannel();\n        this.selectionKey = channel.register(selector, 0, this);\n        this.interests = 0;\n        this.clientToNetwork = new StreamBuffer();\n        this.networkToClient = new Packetizer();\n    }\n\n    public void disconnect() {\n        if (connected.get()) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            connected.set(false);\n            updateInterests();\n        }\n    }\n\n    public void processReceive() {\n        if (!connected.get()) return;\n        ByteBuffer buffer = ByteBuffer.allocate(MTU);\n        try {\n            int bytesRead = channel.read(buffer);\n            if (bytesRead > 0) {\n                buffer.flip();\n                networkToClient.addData(buffer.array(), buffer.position());\n                while (networkToClient.hasData()) {\n                    packetForClient = networkToClient.nextPacket();\n                    if (packetForClient != null) {\n                        client.handlePacket(packetForClient);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            disconnect();\n        }\n    }\n\n    public void processSend() {\n        if (!connected.get()) return;\n        if (clientToNetwork.isEmpty()) {\n            updateInterests();\n            return;\n        }\n        ByteBuffer buffer = ByteBuffer.allocate(MTU);\n        int bytesToWrite = Math.min(clientToNetwork.remaining(), MTU);\n        byte[] data = new byte[bytesToWrite];\n        clientToNetwork.read(data, 0, bytesToWrite);\n        buffer.put(data);\n        buffer.flip();\n        try {\n            channel.write(buffer);\n            if (buffer.hasRemaining()) {\n                clientToNetwork.write(buffer.array(), buffer.position());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            disconnect();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        return channel;\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        if (connected.get()) {\n            clientToNetwork.write(packet.getBytes(), packet.getLength());\n            updateInterests();\n        }\n    }\n\n    public void updateInterests() {\n        int newOps = 0;\n        if (mayRead()) newOps |= SelectionKey.OP_READ;\n        if (mayWrite()) newOps |= SelectionKey.OP_WRITE;\n        if (mayConnect()) newOps |= SelectionKey.OP_CONNECT;\n        selectionKey.interestOps(newOps);\n    }\n\n    private boolean mayRead() {\n        return connected.get() && !networkToClient.isFull();\n    }\n\n    private boolean mayWrite() {\n        return connected.get() && !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return !connected.get() && channel.isConnected();\n    }\n}"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class ReadSocketService extends Thread {\n    public static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead;\n    private final AbstractHAReader haReader;\n    private final AtomicBoolean running = new AtomicBoolean(true);\n    private int processPosition;\n    private long lastReadTimestamp;\n\n    public ReadSocketService(SocketChannel socketChannel, AbstractHAReader haReader) throws IOException {\n        this.socketChannel = socketChannel;\n        this.haReader = haReader;\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.selector = Selector.open();\n        this.socketChannel.configureBlocking(false);\n        this.socketChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    @Override\n    public void run() {\n        while (running.get()) {\n            try {\n                selector.select(1000);\n                for (SelectionKey key : selector.selectedKeys()) {\n                    if (!key.isValid()) {\n                        continue;\n                    }\n                    if (key.isReadable()) {\n                        readFromSocket();\n                    }\n                }\n                checkTimeout();\n            } catch (IOException e) {\n                handleIOException(e);\n            }\n        }\n        cleanup();\n    }\n\n    private void readFromSocket() throws IOException {\n        int bytesRead = socketChannel.read(byteBufferRead);\n        if (bytesRead > 0) {\n            byteBufferRead.flip();\n            boolean processed = haReader.processReadResult(byteBufferRead);\n            if (processed) {\n                byteBufferRead.compact();\n                processPosition = 0;\n                lastReadTimestamp = System.currentTimeMillis();\n            } else {\n                byteBufferRead.compact();\n            }\n        } else if (bytesRead == 0) {\n            return;\n        } else {\n            throw new IOException(\"SocketChannel closed prematurely\");\n        }\n    }\n\n    private void checkTimeout() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastReadTimestamp > 30000) {\n            handleTimeout();\n        }\n    }\n\n    private void handleTimeout() {\n        running.set(false);\n        try {\n            socketChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleIOException(IOException e) {\n        e.printStackTrace();\n        running.set(false);\n        try {\n            socketChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private void cleanup() {\n        try {\n            selector.close();\n            socketChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getServiceName() {\n        return \"ReadSocketService\";\n    }\n\n    public void stopService() {\n        running.set(false);\n    }\n}"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a Java class that manages TCP client connections using Java NIO (Non-blocking I/O) techniques, including connection establishment, data writing, and cleanup operations.\n\nClass Description: ConnectionWorker is a Runnable class that handles asynchronous TCP client connections using Java NIO. It manages connection tasks through a selector pattern, processes write operations, and performs periodic cleanup of stale connections. The class supports concurrent operations through queue-based task management.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging operations\n- stop: boolean - Volatile flag to control thread execution\n- selector: Selector - NIO selector for managing channels\n- myConnectQueue: BlockingQueue<ConnectTask> - Queue for pending connection tasks\n- myWriteQueue: BlockingQueue<WriteTask> - Queue for pending write operations\n- mySemaphore: Semaphore - Controls access to the worker thread\n- myKeyProcessors: List<KeyProcessor> - Processors for handling different channel operations\n- myTimeService: TimeService - Provides time-related functionality\n- lastCleanupTime: long - Timestamp of last cleanup operation\n- mySelectorTimeoutMillis: int - Timeout for selector operations\n- myCleanupTimeoutMillis: long - Timeout between cleanup operations\n- myCleanupProcessor: CleanupProcessor - Handles connection cleanup\n- myNewConnectionAllower: NewConnectionAllower - Controls new connection allowance\n\nMethods:\n- run(): void - Main execution method implementing Runnable interface\n- connectToPeersFromQueue(): void - Processes pending connection tasks from queue\n- processSelectedKeys(): void - Processes all ready selection keys\n- processSelectedKey(SelectionKey): void - Processes a single selection key\n- offerConnect(ConnectTask, int, TimeUnit): boolean - Adds new connection task to queue\n- addTaskToQueue(T, int, TimeUnit, BlockingQueue<T>): boolean - Generic method for adding tasks to queues\n- processWriteTasks(): void - Processes pending write operations (implied from code context)\n- cleanup(): void - Performs cleanup operations (implied from code context)\n- needRunCleanup(): boolean - Determines if cleanup is needed (implied from code context)",
    "Canonical_solution": "import com.turn.ttorrent.common.LoggerUtils;\nimport com.turn.ttorrent.common.TimeService;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.network.keyProcessors.CleanupProcessor;\nimport com.turn.ttorrent.network.keyProcessors.KeyProcessor;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n\n  private static final Logger logger = TorrentLoggerFactory.getLogger(ConnectionWorker.class);\n  private static final String SELECTOR_THREAD_NAME = \"Torrent channels manager thread\";\n  private volatile boolean stop = false;\n  private final Selector selector;\n  private final BlockingQueue<ConnectTask> myConnectQueue;\n  private final BlockingQueue<WriteTask> myWriteQueue;\n  private final Semaphore mySemaphore;\n  private final List<KeyProcessor> myKeyProcessors;\n  private final TimeService myTimeService;\n  private long lastCleanupTime;\n  private volatile int mySelectorTimeoutMillis;\n  private volatile long myCleanupTimeoutMillis;\n  private final CleanupProcessor myCleanupProcessor;\n  private final NewConnectionAllower myNewConnectionAllower;\n\n  public ConnectionWorker(Selector selector,\n                   List<KeyProcessor> keyProcessors,\n                   int selectorTimeoutMillis,\n                   int cleanupTimeoutMillis,\n                   TimeService timeService,\n                   CleanupProcessor cleanupProcessor,\n                   NewConnectionAllower myNewConnectionAllower) {\n    this.selector = selector;\n    this.myTimeService = timeService;\n    this.lastCleanupTime = timeService.now();\n    this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n    this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n    this.myCleanupProcessor = cleanupProcessor;\n    this.myNewConnectionAllower = myNewConnectionAllower;\n    this.mySemaphore = new Semaphore(1);\n    this.myConnectQueue = new LinkedBlockingQueue<ConnectTask>(100);\n    this.myKeyProcessors = keyProcessors;\n    this.myWriteQueue = new LinkedBlockingQueue<WriteTask>(5000);\n  }\n\n  @Override\n  public void run() {\n    try {\n      mySemaphore.acquire();\n    } catch (InterruptedException e) {\n      return;\n    }\n\n    final String oldName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(SELECTOR_THREAD_NAME);\n\n      while (!stop && (!Thread.currentThread().isInterrupted())) {\n        try {\n          logger.trace(\"try select keys from selector\");\n          int selected;\n          try {\n            selected = selector.select(mySelectorTimeoutMillis);\n          } catch (ClosedSelectorException e) {\n            break;\n          }\n          connectToPeersFromQueue();\n          processWriteTasks();\n          logger.trace(\"select keys from selector. Keys count is \" + selected);\n          if (selected != 0) {\n            processSelectedKeys();\n          }\n          if (needRunCleanup()) {\n            cleanup();\n          }\n        } catch (Throwable e) {\n          LoggerUtils.warnAndDebugDetails(logger, \"unable to select channel keys. Error message {}\", e.getMessage(), e);\n        }\n      }\n    } catch (Throwable e) {\n      LoggerUtils.errorAndDebugDetails(logger, \"exception on cycle iteration\", e);\n    } finally {\n      Thread.currentThread().setName(oldName);\n      mySemaphore.release();\n    }\n  }\n\n  private void connectToPeersFromQueue() {\n    ConnectTask connectTask;\n    while ((connectTask = myConnectQueue.poll()) != null) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      logger.debug(\"try connect to peer. Connect task is {}\", connectTask);\n      try {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_CONNECT, connectTask);\n        socketChannel.connect(new InetSocketAddress(connectTask.getHost(), connectTask.getPort()));\n      } catch (IOException e) {\n        LoggerUtils.warnAndDebugDetails(logger, \"unable connect. Connect task is {}\", connectTask, e);\n      }\n    }\n  }\n\n  private void processSelectedKeys() {\n    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n    for (SelectionKey key : selectionKeys) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      try {\n        processSelectedKey(key);\n      } catch (Exception e) {\n        logger.warn(\"error {} in processing key. Close channel {}\", e.getMessage(), key.channel());\n        logger.debug(\"\", e);\n        try {\n          key.channel().close();\n        } catch (IOException ioe) {\n          LoggerUtils.errorAndDebugDetails(logger, \"unable close bad channel\", ioe);\n        }\n      }\n    }\n    selectionKeys.clear();\n  }\n\n  private void processSelectedKey(SelectionKey key) throws IOException {\n    logger.trace(\"try process key for channel {}\", key.channel());\n    myCleanupProcessor.processSelected(key);\n    if (!key.channel().isOpen()) {\n      key.cancel();\n      return;\n    }\n    for (KeyProcessor keyProcessor : myKeyProcessors) {\n      if (keyProcessor.accept(key)) {\n        keyProcessor.process(key);\n      }\n    }\n  }\n\n  public boolean offerConnect(ConnectTask connectTask, int timeout, TimeUnit timeUnit) {\n    if (!myNewConnectionAllower.isNewConnectionAllowed()) {\n      logger.info(\"can not add connect task {} to queue. New connection is not allowed\", connectTask);\n      return false;\n    }\n    return addTaskToQueue(connectTask, timeout, timeUnit, myConnectQueue);\n  }\n\n  private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit timeUnit, BlockingQueue<T> queue) {\n    try {\n      if (queue.offer(task, timeout, timeUnit)) {\n        logger.trace(\"added task {}. Wake up selector\", task);\n        selector.wakeup();\n        return true;\n      }\n    } catch (InterruptedException e) {\n      logger.debug(\"Task {} interrupted before was added to queue\", task);\n    }\n    logger.debug(\"Task {} was not added\", task);\n    return false;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\n\npublic class ConnectionWorker implements Runnable {\n    private final Logger logger;\n    private volatile boolean stop;\n    private final Selector selector;\n    private final BlockingQueue<ConnectTask> myConnectQueue;\n    private final BlockingQueue<WriteTask> myWriteQueue;\n    private final Semaphore mySemaphore;\n    private final List<KeyProcessor> myKeyProcessors;\n    private final TimeService myTimeService;\n    private long lastCleanupTime;\n    private final int mySelectorTimeoutMillis;\n    private final long myCleanupTimeoutMillis;\n    private final CleanupProcessor myCleanupProcessor;\n    private final NewConnectionAllower myNewConnectionAllower;\n\n    public ConnectionWorker(Logger logger, Selector selector, BlockingQueue<ConnectTask> myConnectQueue,\n                            BlockingQueue<WriteTask> myWriteQueue, Semaphore mySemaphore,\n                            List<KeyProcessor> myKeyProcessors, TimeService myTimeService,\n                            int mySelectorTimeoutMillis, long myCleanupTimeoutMillis,\n                            CleanupProcessor myCleanupProcessor, NewConnectionAllower myNewConnectionAllower) {\n        this.logger = logger;\n        this.stop = false;\n        this.selector = selector;\n        this.myConnectQueue = myConnectQueue;\n        this.myWriteQueue = myWriteQueue;\n        this.mySemaphore = mySemaphore;\n        this.myKeyProcessors = myKeyProcessors;\n        this.myTimeService = myTimeService;\n        this.lastCleanupTime = myTimeService.currentTimeMillis();\n        this.mySelectorTimeoutMillis = mySelectorTimeoutMillis;\n        this.myCleanupTimeoutMillis = myCleanupTimeoutMillis;\n        this.myCleanupProcessor = myCleanupProcessor;\n        this.myNewConnectionAllower = myNewConnectionAllower;\n    }\n\n    @Override\n    public void run() {\n        while (!stop) {\n            try {\n                connectToPeersFromQueue();\n                processSelectedKeys();\n                if (needRunCleanup()) {\n                    cleanup();\n                }\n                Thread.sleep(100);\n            } catch (Exception e) {\n                logger.error(\"Error in ConnectionWorker thread\", e);\n            }\n        }\n    }\n\n    private void connectToPeersFromQueue() {\n        try {\n            ConnectTask task;\n            while ((task = myConnectQueue.poll(100, TimeUnit.MILLISECONDS)) != null) {\n                if (myNewConnectionAllower.allowNewConnection()) {\n                    SocketChannel channel = SocketChannel.open();\n                    channel.configureBlocking(false);\n                    channel.connect(new InetSocketAddress(task.getHost(), task.getPort()));\n                    channel.register(selector, SelectionKey.OP_CONNECT, task);\n                } else {\n                    logger.warn(\"New connection not allowed\");\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error connecting to peers from queue\", e);\n        }\n    }\n\n    private void processSelectedKeys() {\n        try {\n            selector.select(mySelectorTimeoutMillis);\n            for (SelectionKey key : selector.selectedKeys()) {\n                processSelectedKey(key);\n                key.cancel();\n            }\n            selector.selectedKeys().clear();\n        } catch (IOException e) {\n            logger.error(\"Error processing selected keys\", e);\n        }\n    }\n\n    private void processSelectedKey(SelectionKey key) {\n        for (KeyProcessor processor : myKeyProcessors) {\n            if (processor.processKey(key)) {\n                return;\n            }\n        }\n        logger.warn(\"No processor found for selection key\");\n    }\n\n    public boolean offerConnect(ConnectTask task, int timeout, TimeUnit unit) {\n        return addTaskToQueue(task, timeout, unit, myConnectQueue);\n    }\n\n    private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit unit, BlockingQueue<T> queue) {\n        try {\n            return queue.offer(task, timeout, unit);\n        } catch (InterruptedException e) {\n            logger.error(\"Interrupted while adding task to queue\", e);\n            Thread.currentThread().interrupt();\n            return false;\n        }\n    }\n\n    private void processWriteTasks() {\n        WriteTask task;\n        while ((task = myWriteQueue.poll(100, TimeUnit.MILLISECONDS)) != null) {\n            // Process write task logic\n        }\n    }\n\n    private void cleanup() {\n        myCleanupProcessor.cleanupConnections();\n        lastCleanupTime = myTimeService.currentTimeMillis();\n    }\n\n    private boolean needRunCleanup() {\n        return myTimeService.currentTimeMillis() - lastCleanupTime >= myCleanupTimeoutMillis;\n    }\n}"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data, and sends responses back to clients.\n\nClass Description: The Server class implements a Component interface and provides non-blocking TCP server functionality using Java NIO channels and selectors. It manages client connections, reads incoming data in a length-prefixed format, processes commands, and writes responses back to clients.\n\nAttributes:\n- SERVER_PORT: [int] - The port number on which the server listens for incoming connections\n- conMan: [NIOConnectionManager] - Manages NIO connections and selection operations\n- acceptor: [ServerSocketChannel] - The main server socket channel that accepts incoming connections\n- dhts: [Collection<DHT>] - Collection of DHT instances used for command processing\n\nMethods:\n- start([Collection<DHT> dhts, ConfigReader config]) -> [void] - Initializes the server by creating a non-blocking ServerSocketChannel, binding it to the specified port, and registering it with the connection manager\n- stop() -> [void] - Stops the server by closing the ServerSocketChannel and releasing resources\n- accept() -> [void] - Accepts new client connections, configures them as non-blocking, and registers them with the connection manager for read/write operations\n- read() -> [void] - Reads data from a client channel in a length-prefixed format (4-byte header followed by payload)\n- process([ByteBuffer buf]) -> [void] - Processes the received data buffer by decoding it and executing the appropriate command\n- write() -> [void] - Writes response data back to the client channel\n- calcInterestOps() -> [int] - Calculates the current interest operations (OP_READ/OP_WRITE) for the selection key\n- selectionEvent([SelectionKey key]) -> [void] - Handles selection events (readable/writable) for client channels\n- registrationEvent([NIOConnectionManager manager, SelectionKey key]) -> [void] - Handles registration events with the connection manager\n- getChannel() -> [SelectableChannel] - Returns the associated channel (either server or client channel)\n- doStateChecks([long now]) -> [void] - Performs periodic state checks (currently empty implementation)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\n\nimport lbms.plugins.mldht.kad.DHT;\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.bencode.BDecoder;\nimport the8472.mldht.Component;\nimport the8472.utils.ConfigReader;\n\npublic class Server implements Component {\n\t\n\tpublic static int SERVER_PORT = 33348;\n\t\n\tNIOConnectionManager conMan = new NIOConnectionManager(\"CLI-server\");\n\tServerSocketChannel acceptor;\n\tCollection<DHT> dhts;\n\t\n\t@Override\n\tpublic void start(Collection<DHT> dhts, ConfigReader config) {\n\t\tthis.dhts = dhts;\n\t\t\n\t\ttry {\n\t\t\tacceptor = ServerSocketChannel.open();\n\t\t\tacceptor.configureBlocking(false);\n\t\t\tacceptor.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tacceptor.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), SERVER_PORT));\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(key.isAcceptable())\n\t\t\t\t\t\taccept();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn acceptor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\treturn SelectionKey.OP_ACCEPT;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid accept() {\n\t\ttry {\n\t\t\tSocketChannel chan = acceptor.accept();\n\t\t\tchan.configureBlocking(false);\n\t\t\tchan.socket().setSoTimeout(0);\n\t\t\tchan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\tByteBuffer header = ByteBuffer.allocate(4);\n\t\t\t\tByteBuffer payload = null;\n\t\t\t\tByteBuffer currentReadTarget = header;\n\t\t\t\tDeque<ByteBuffer> writes = new ConcurrentLinkedDeque<>();\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(!chan.isOpen()) {\n\t\t\t\t\t\tconMan.deRegister(this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(key.isValid() && key.isReadable())\n\t\t\t\t\t\tread();\n\t\t\t\t\tif(key.isValid() && key.isWritable())\n\t\t\t\t\t\twrite();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid read() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint read = chan.read(currentReadTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(read == -1) {\n\t\t\t\t\t\t\theader = null;\n\t\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(currentReadTarget.remaining() == 0) {\n\t\t\t\t\t\t\tcurrentReadTarget.flip();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(currentReadTarget == header) {\n\t\t\t\t\t\t\t\tpayload = ByteBuffer.allocate(header.getInt(0));\n\t\t\t\t\t\t\t\tcurrentReadTarget = payload;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocess(payload);\n\t\t\t\t\t\t\t\tpayload = null;\n\t\t\t\t\t\t\t\theader.clear();\n\t\t\t\t\t\t\t\tcurrentReadTarget = header;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid process(ByteBuffer buf) {\n\t\t\t\t\tBDecoder decoder = new BDecoder();\n\t\t\t\t\tMap<String, Object> map = decoder.decode(buf);\n\t\t\t\t\tList<byte[]> args = (List<byte[]>) map.get(\"arguments\");\n\t\t\t\t\tCommandProcessor processor = CommandProcessor.from(args, (b) -> {\n\t\t\t\t\t\tByteBuffer h = ByteBuffer.allocate(4);\n\t\t\t\t\t\th.putInt(0, b.remaining());\n\t\t\t\t\t\tsynchronized (writes) {\n\t\t\t\t\t\t\twrites.add(h);\n\t\t\t\t\t\t\twrites.add(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t}, dhts);\n\t\t\t\t\tprocessor.currentWorkDir = Paths.get(new String((byte[])map.get(\"cwd\"), StandardCharsets.UTF_8));\n\t\t\t\t\tprocessor.active = chan::isOpen;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.process();\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tprocessor.handleException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid write() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (!writes.isEmpty()) {\n\t\t\t\t\t\t\tif (!writes.peekFirst().hasRemaining()) {\n\t\t\t\t\t\t\t\twrites.removeFirst();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong written = chan.write(writes.stream().toArray(ByteBuffer[]::new));\n\t\t\t\t\t\t\tif (written == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(writes.isEmpty())\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn chan;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\tint ops = 0;\n\t\t\t\t\tif(header != null)\n\t\t\t\t\t\tops = SelectionKey.OP_READ;\n\t\t\t\t\tif(writes.peek() != null)\n\t\t\t\t\t\tops |= SelectionKey.OP_WRITE;\n\t\t\t\t\treturn ops;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\ttry {\n\t\t\tacceptor.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class Server implements Component {\n    public static final int SERVER_PORT = 8080;\n    private NIOConnectionManager conMan;\n    private ServerSocketChannel acceptor;\n    private Collection<DHT> dhts;\n\n    public void start(Collection<DHT> dhts, ConfigReader config) throws IOException {\n        this.dhts = dhts;\n        this.conMan = new NIOConnectionManager();\n        this.acceptor = ServerSocketChannel.open();\n        this.acceptor.configureBlocking(false);\n        this.acceptor.bind(new InetSocketAddress(SERVER_PORT));\n        this.conMan.register(this.acceptor, SelectionKey.OP_ACCEPT);\n    }\n\n    public void stop() throws IOException {\n        if (acceptor != null) {\n            acceptor.close();\n        }\n        conMan.close();\n    }\n\n    public void accept() throws IOException {\n        SocketChannel clientChannel = acceptor.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            conMan.register(clientChannel, SelectionKey.OP_READ);\n        }\n    }\n\n    public void read() {\n        ByteBuffer headerBuffer = ByteBuffer.allocate(4);\n        Iterator<SelectionKey> keys = conMan.getSelectionKeys();\n        while (keys.hasNext()) {\n            SelectionKey key = keys.next();\n            if (key.isReadable()) {\n                try {\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    int bytesRead = channel.read(headerBuffer);\n                    if (bytesRead == -1) {\n                        key.cancel();\n                        continue;\n                    }\n                    if (headerBuffer.remaining() == 0) {\n                        headerBuffer.flip();\n                        int length = headerBuffer.getInt();\n                        ByteBuffer payloadBuffer = ByteBuffer.allocate(length);\n                        int payloadBytesRead = channel.read(payloadBuffer);\n                        if (payloadBytesRead == -1 || payloadBytesRead != length) {\n                            key.cancel();\n                            continue;\n                        }\n                        payloadBuffer.flip();\n                        process(payloadBuffer);\n                        headerBuffer.clear();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();\n                }\n            }\n        }\n    }\n\n    public void process(ByteBuffer buf) {\n        // Placeholder for decoding and processing the command\n        byte[] data = new byte[buf.remaining()];\n        buf.get(data);\n        String command = new String(data);\n        System.out.println(\"Received command: \" + command);\n        // Execute appropriate command using DHT instances\n    }\n\n    public void write() {\n        Iterator<SelectionKey> keys = conMan.getSelectionKeys();\n        while (keys.hasNext()) {\n            SelectionKey key = keys.next();\n            if (key.isWritable()) {\n                try {\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    String response = \"Command processed successfully\";\n                    ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());\n                    channel.write(buffer);\n                    key.interestOps(SelectionKey.OP_READ);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();\n                }\n            }\n        }\n    }\n\n    public int calcInterestOps() {\n        return SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n    }\n\n    public void selectionEvent(SelectionKey key) {\n        if (key.isAcceptable()) {\n            try {\n                accept();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else if (key.isReadable()) {\n            read();\n        } else if (key.isWritable()) {\n            write();\n        }\n    }\n\n    public void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n        // Handle registration event with the connection manager\n    }\n\n    public SelectableChannel getChannel() {\n        return acceptor;\n    }\n\n    public void doStateChecks(long now) {\n        // Periodic state checks (currently empty)\n    }\n}"
  },
  {
    "Task_id": 441,
    "Instruction": "Task Description: Implement a Unix domain socket-based IPC server using Java NIO that can listen for incoming messages and send responses asynchronously.\n\nClass Description: The Server class implements an IPC communicator that establishes a Unix domain socket server. It handles client connections asynchronously, processes incoming messages through a listener callback, and sends responses. The server manages its socket resources and cleans up the socket file on termination.\n\nAttributes:\n- serverSocketChannel: [ServerSocketChannel] - The NIO channel for accepting client connections on the Unix domain socket\n- socketPath: [Path] - Filesystem path where the Unix domain socket is created\n- LOG: [Logger] - Logger instance for recording server events and errors\n\nMethods:\n- create: [static](Path socketPath) -> [Server] - Factory method that creates and binds a Unix domain socket server at the specified path. Throws IOException if binding fails.\n- isClient: []() -> [boolean] - Returns false indicating this is a server-side communicator (always returns false for Server instances)\n- listen: [](IpcMessageListener listener, Executor executor) -> [void] - Starts listening for incoming messages asynchronously using the provided executor. Each message is delivered to the listener callback.\n- send: [](IpcMessage message, Executor executor) -> [void] - Sends a message to a connected client asynchronously using the provided executor.\n- close: []() -> [void] - Closes the server socket channel and deletes the socket file. Throws IOException if cleanup fails.",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.net.StandardProtocolFamily;\nimport java.net.UnixDomainSocketAddress;\nimport java.nio.channels.AlreadyBoundException;\nimport java.nio.channels.AsynchronousCloseException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\n\nclass Server implements IpcCommunicator {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Server.class);\n\n\tprivate final ServerSocketChannel serverSocketChannel;\n\tprivate final Path socketPath;\n\n\tprivate Server(ServerSocketChannel serverSocketChannel, Path socketPath) {\n\t\tthis.serverSocketChannel = serverSocketChannel;\n\t\tthis.socketPath = socketPath;\n\t}\n\n\tpublic static Server create(Path socketPath) throws IOException {\n\t\tFiles.createDirectories(socketPath.getParent());\n\t\tvar address = UnixDomainSocketAddress.of(socketPath);\n\t\tServerSocketChannel ch = null;\n\t\ttry {\n\t\t\tch = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n\t\t\tch.bind(address);\n\t\t\tLOG.info(\"Spawning IPC server listening on socket {}\", socketPath);\n\t\t\treturn new Server(ch, socketPath);\n\t\t} catch (IOException | AlreadyBoundException | UnsupportedAddressTypeException e) {\n\t\t\tif (ch != null) {\n\t\t\t\tch.close();\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isClient() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void listen(IpcMessageListener listener, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\twhile (serverSocketChannel.isOpen()) {\n\t\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\t\twhile (ch.isConnected()) {\n\t\t\t\t\t\tvar msg = IpcMessage.receive(ch);\n\t\t\t\t\t\tlistener.handleMessage(msg);\n\t\t\t\t\t}\n\t\t\t\t} catch (AsynchronousCloseException e) {\n\t\t\t\t\treturn;\n\t\t\t\t} catch (EOFException | ClosedChannelException e) {\n\t\t\t\t\t// continue with next connected client\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOG.error(\"Failed to read IPC message\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void send(IpcMessage message, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\tmessage.send(ch);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.error(\"Failed to send IPC message\", e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\ttry {\n\t\t\tserverSocketChannel.close();\n\t\t} finally {\n\t\t\tFiles.deleteIfExists(socketPath);\n\t\t\tLOG.debug(\"IPC server closed\");\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Logger;\n\npublic class Server {\n    private final ServerSocketChannel serverSocketChannel;\n    private final Path socketPath;\n    private final Logger LOG = Logger.getLogger(Server.class.getName());\n\n    private Server(Path socketPath) throws IOException {\n        this.socketPath = socketPath;\n        this.serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.bind(socketPath.toFile().toPath().toUri());\n    }\n\n    public static Server create(Path socketPath) throws IOException {\n        if (Files.exists(socketPath)) {\n            Files.delete(socketPath);\n        }\n        return new Server(socketPath);\n    }\n\n    public boolean isClient() {\n        return false;\n    }\n\n    public void listen(IpcMessageListener listener, Executor executor) {\n        executor.execute(() -> {\n            try {\n                while (true) {\n                    SocketChannel clientChannel = serverSocketChannel.accept();\n                    if (clientChannel == null) {\n                        continue;\n                    }\n                    clientChannel.configureBlocking(false);\n                    // Process message from client\n                    // Assuming IpcMessage is a custom class with read/write methods\n                    IpcMessage message = new IpcMessage();\n                    // Read message from clientChannel\n                    // ...\n                    listener.onMessageReceived(message);\n                }\n            } catch (IOException e) {\n                LOG.severe(\"Error listening for messages: \" + e.getMessage());\n            }\n        });\n    }\n\n    public void send(IpcMessage message, Executor executor) {\n        executor.execute(() -> {\n            try {\n                // Assuming there's a connected client channel to send the message to\n                // This would typically involve maintaining a reference to the client channel\n                // For example:\n                // SocketChannel clientChannel = ...;\n                // message.writeTo(clientChannel);\n            } catch (IOException e) {\n                LOG.severe(\"Error sending message: \" + e.getMessage());\n            }\n        });\n    }\n\n    public void close() throws IOException {\n        try {\n            serverSocketChannel.close();\n        } finally {\n            if (Files.exists(socketPath)) {\n                Files.delete(socketPath);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 442,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data packets with checksum verification, and manages resources efficiently.\n\nClass Description: NIOServer - A non-blocking TCP server implementation using Java NIO that handles multiple client connections through a single selector thread.\n\nAttributes:\n- serverChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The multiplexor that manages multiple client connections\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port and begins accepting connections\n  - Input: port (int) - The port number to bind the server to\n  - Output: None (throws Exception if startup fails)\n  \n- stop() -> void - Shuts down the server and releases all resources\n  - Input: None\n  - Output: None (handles exceptions internally)\n  \n- handleAccept(SelectionKey key) -> void - Handles new client connection acceptance\n  - Input: key (SelectionKey) - The selection key representing the accept event\n  - Output: None (throws Exception if connection acceptance fails)\n  \n- handleRead(SelectionKey key) -> void - Handles incoming data from clients with checksum verification\n  - Input: key (SelectionKey) - The selection key representing the read event\n  - Output: None (handles exceptions internally)\n  \n- isFull(ByteBuffer buffer) -> boolean - Helper method to check if a buffer is full\n  - Input: buffer (ByteBuffer) - The buffer to check\n  - Output: boolean - True if buffer is full, false otherwise",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n\n    public void start(int port) throws Exception {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.socket().setReuseAddress(true);\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        \n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        \n        while (selector.isOpen()) {\n            if (selector.select(3000) == 0) {\n                continue;\n            }\n            \n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                it.remove();\n                \n                if (!key.isValid()) {\n                    continue;\n                }\n                \n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                } else if (key.isReadable()) {\n                    handleRead(key);\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws Exception {\n        SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(key.selector(), SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key) {\n        SocketChannel channel = (SocketChannel) key.channel();\n        try {\n            ByteBuffer head = ByteBuffer.allocate(4);\n            while (!isFull(head)) {\n                if (channel.read(head) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            head.flip();\n            int dataSize = head.getInt();\n            \n            ByteBuffer body = ByteBuffer.allocate(dataSize);\n            while (!isFull(body)) {\n                if (channel.read(body) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            \n            ByteBuffer tail = ByteBuffer.allocate(8);\n            while (!isFull(tail)) {\n                if (channel.read(tail) == -1) {\n                    break;\n                }\n            }\n            tail.flip();\n            \n            Checksum checksum = new Adler32();\n            checksum.update(body.array(), 0, dataSize);\n            if (tail.getLong() != checksum.getValue()) {\n                throw new RuntimeException(\"Data corrupted\");\n            }\n            \n            body.flip();\n            // Process packet here\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                channel.close();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    private boolean isFull(ByteBuffer buffer) {\n        return buffer.position() == buffer.capacity();\n    }\n\n    public void stop() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n\n    public void start(int port) throws Exception {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            selector.select();\n            for (SelectionKey key : selector.selectedKeys()) {\n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                } else if (key.isReadable()) {\n                    handleRead(key);\n                }\n                key.cancel();\n            }\n        }\n    }\n\n    public void stop() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverSocketChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            clientChannel.register(selector, SelectionKey.OP_READ);\n        }\n    }\n\n    private void handleRead(SelectionKey key) {\n        try {\n            SocketChannel clientChannel = (SocketChannel) key.channel();\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            int bytesRead;\n            while ((bytesRead = clientChannel.read(buffer)) > 0) {\n                buffer.flip();\n                if (isFull(buffer)) {\n                    byte[] data = new byte[buffer.remaining()];\n                    buffer.get(data);\n                    int checksum = calculateChecksum(data);\n                    if (verifyChecksum(data, checksum)) {\n                        System.out.println(\"Received valid data: \" + new String(data));\n                    } else {\n                        System.out.println(\"Received invalid data with incorrect checksum.\");\n                    }\n                }\n                buffer.clear();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean isFull(ByteBuffer buffer) {\n        return buffer.position() == buffer.capacity();\n    }\n\n    private int calculateChecksum(byte[] data) {\n        int checksum = 0;\n        for (byte b : data) {\n            checksum += b & 0xFF;\n        }\n        return checksum;\n    }\n\n    private boolean verifyChecksum(byte[] data, int expectedChecksum) {\n        return calculateChecksum(data) == expectedChecksum;\n    }\n}"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NIOAcceptor implements Runnable {\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private final NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n    private static final AtomicLong acceptId = new AtomicLong(0);\n\n    public NIOAcceptor(int port, FrontendConnectionFactory factory, NIOProcessor[] processors) throws IOException {\n        this.port = port;\n        this.factory = factory;\n        this.processors = processors;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.bind(new InetSocketAddress(port));\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.nextProcessor = 0;\n        this.acceptCount = 0;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                selector.select();\n                for (SelectionKey key : selector.selectedKeys()) {\n                    if (key.isAcceptable()) {\n                        accept();\n                    }\n                    key.cancel();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void accept() throws IOException {\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            NIOProcessor processor = nextProcessor();\n            FrontendConnection connection = factory.createConnection(clientChannel, processor);\n            processor.register(connection);\n            acceptCount++;\n            System.out.println(\"Accepted connection \" + getAcceptId() + \" on port \" + port);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n    public static long getAcceptId() {\n        return acceptId.incrementAndGet();\n    }\n\n    public long getAcceptCount() {\n        return acceptCount;\n    }\n\n    public void closeChannel(SocketChannel channel) {\n        try {\n            if (channel != null && channel.isOpen()) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (serverChannel != null && serverChannel.isOpen()) {\n                serverChannel.close();\n            }\n            if (selector != null) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static class AcceptIdGenerator {\n        private static final AtomicLong acceptId = new AtomicLong(0);\n\n        public static long getId() {\n            return acceptId.incrementAndGet();\n        }\n    }\n}"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "import java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.List;\n\npublic class MulticastSender {\n    private DatagramSocket sock;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n    private ProtocolFamily prot_family;\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) throws SocketException, IOException {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n        this.prot_family = determineProtocolFamily(bind_addr);\n        configureSocket();\n    }\n\n    private ProtocolFamily determineProtocolFamily(InetAddress addr) {\n        if (addr instanceof Inet6Address) {\n            return ProtocolFamily.INET6;\n        } else {\n            return ProtocolFamily.INET;\n        }\n    }\n\n    private void configureSocket() throws SocketException, IOException {\n        if (prot_family == ProtocolFamily.INET6) {\n            sock = new DatagramSocket(local_port, bind_addr);\n        } else {\n            sock = new DatagramSocket(local_port, bind_addr);\n        }\n        sock.setBroadcast(false);\n        sock.setReuseAddress(true);\n        ((MulticastSocket) sock).setTimeToLive(ttl);\n    }\n\n    public void start() {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                byte[] data = line.getBytes();\n                DatagramPacket packet = new DatagramPacket(data, data.length, mcast_addr, mcast_port);\n                sock.send(packet);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            sock.close();\n        }\n    }\n\n    public void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) throws IOException {\n        for (NetworkInterface ni : interfaces) {\n            s.joinGroup(new InetSocketAddress(mcast_addr, mcast_port), ni);\n        }\n    }\n\n    private enum ProtocolFamily {\n        INET, INET6\n    }\n}"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Vert.x framework to handle multiple client connections, process incoming data, and manage server lifecycle operations.\n\nClass Description: The VertxTcpServer class provides functionality to start, stop, and manage a TCP server using Vert.x. It handles client connections, processes incoming data with echo functionality, and manages connection events.\n\nAttributes:\n- server: [NetServer] - The Vert.x NetServer instance that manages TCP connections\n\nMethods:\n- startServer(Vertx vertx, int port, String host) -> void - Initializes and starts the TCP server on specified host and port\n- handleConnection(NetSocket socket) -> void - Handles incoming client connections, processes data, and manages connection events\n- stopServer() -> void - Gracefully shuts down the TCP server\n\nMethod Details:\n1. startServer(Vertx vertx, int port, String host) -> void\n   - Input Parameters:\n     - vertx: Vertx - The Vert.x instance\n     - port: int - The port number to listen on\n     - host: String - The host address to bind to\n   - Description: Configures server options, creates NetServer instance, sets up connection handler, and starts listening for connections\n\n2. handleConnection(NetSocket socket) -> void\n   - Input Parameters:\n     - socket: NetSocket - The client connection socket\n   - Description: Sets up handlers for incoming data (echoes back received data), connection closure, and exceptions\n\n3. stopServer() -> void\n   - Description: Closes the server and all active connections, with completion handler for success/failure notification",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.buffer.Buffer;\n\npublic class VertxTcpServer {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setPort(port).setHost(host);\n        server = vertx.createNetServer(options);\n\n        server.connectHandler(socket -> {\n            handleConnection(socket);\n        });\n\n        server.listen().onComplete(res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on port: \" + port);\n            } else {\n                System.out.println(\"Failed to bind: \" + res.cause().getMessage());\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.length() + \" bytes\");\n            socket.write(Buffer.buffer(\"Echo: \").appendBuffer(buffer));\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Connection error: \" + err.getMessage());\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close().onComplete(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server closed successfully\");\n                } else {\n                    System.err.println(\"Failed to close server: \" + res.cause().getMessage());\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class VertxTcpServer {\n  private NetServer server;\n\n  public void startServer(Vertx vertx, int port, String host) {\n    server = vertx.createNetServer();\n    server.connectHandler(socket -> handleConnection(socket))\n        .listen(port, host, result -> {\n          if (result.succeeded()) {\n            System.out.println(\"Server started on \" + host + \":\" + port);\n          } else {\n            System.err.println(\"Failed to start server: \" + result.cause().getMessage());\n          }\n        });\n  }\n\n  public void handleConnection(NetSocket socket) {\n    socket.handler(buffer -> {\n      String data = buffer.toString(\"UTF-8\");\n      System.out.println(\"Received data: \" + data);\n      socket.write(data);\n    });\n\n    socket.closeHandler(v -> System.out.println(\"Client disconnected\"));\n\n    socket.exceptionHandler(err -> {\n      System.err.println(\"Connection error: \" + err.getMessage());\n      socket.close();\n    });\n  }\n\n  public void stopServer() {\n    if (server != null) {\n      server.close(result -> {\n        if (result.succeeded()) {\n          System.out.println(\"Server stopped successfully\");\n        } else {\n          System.err.println(\"Failed to stop server: \" + result.cause().getMessage());\n        }\n      });\n    }\n  }\n}"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class ClusteredEventBus extends EventBusImpl {\n    protected final EventBusOptions options;\n    protected NetServer server;\n\n    public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n        super(vertx, options);\n        this.options = (EventBusOptions) options;\n    }\n\n    protected NetServerOptions getServerOptions() {\n        NetServerOptions serverOptions = new NetServerOptions();\n        serverOptions.setPort(options.getClusterPort());\n        serverOptions.setHost(options.getClusterHost());\n        return serverOptions;\n    }\n\n    @Override\n    public void start(Promise<Void> promise) {\n        server = vertx.createNetServer(getServerOptions());\n        server.connectHandler(getServerHandler()).listen(ar -> {\n            if (ar.succeeded()) {\n                promise.complete();\n            } else {\n                promise.fail(ar.cause());\n            }\n        });\n    }\n\n    protected Handler<NetSocket> getServerHandler() {\n        return socket -> {\n            socket.handler(buffer -> {\n                String message = buffer.toString(\"UTF-8\");\n                processMessage(message, socket);\n            });\n        };\n    }\n\n    public int getClusterPort() {\n        return options.getClusterPort();\n    }\n\n    public String getClusterHost() {\n        return options.getClusterHost() != null ? options.getClusterHost() : \"0.0.0.0\";\n    }\n}"
  },
  {
    "Task_id": 453,
    "Instruction": "Task Description: Implement a function that demonstrates UDP communication using Vert.x in Java, allowing sending of data packets to a specified target address and port, with success/failure notification.\n\nFunction Description: The function creates a UDP socket using Vert.x, configures it with default options, and demonstrates two ways to send data: using a Buffer object and directly using a String. It includes asynchronous result handling to report whether each send operation succeeded.\n\nInput:\n- vertx: Vertx - The Vert.x instance used to create the UDP socket\n\nOutput: None (The function's output is the side effect of sending UDP packets and printing success/failure messages to the console)",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic void example2(Vertx vertx) {\n    DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());\n    Buffer buffer = Buffer.buffer(\"content\");\n    socket\n      .send(buffer, 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n    socket\n      .send(\"A string used as content\", 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 14,
    "wrong_result": "public void sendUdpPackets(Vertx vertx) {\n  UdpSocket socket = UdpSocket.create(vertx, new UdpSocketOptions());\n  String targetAddress = \"127.0.0.1\";\n  int targetPort = 8080;\n\n  // Send using Buffer\n  socket.send(Buffer.buffer(\"Hello from Vert.x UDP!\"), targetAddress, targetPort, result -> {\n    if (result.succeeded()) {\n      System.out.println(\"Buffer message sent successfully.\");\n    } else {\n      System.out.println(\"Failed to send buffer message: \" + result.cause().getMessage());\n    }\n  });\n\n  // Send using String\n  socket.send(\"Hello from Vert.x UDP String!\", targetAddress, targetPort, result -> {\n    if (result.succeeded()) {\n      System.out.println(\"String message sent successfully.\");\n    } else {\n      System.out.println(\"Failed to send string message: \" + result.cause().getMessage());\n    }\n  });\n}"
  },
  {
    "Task_id": 456,
    "Instruction": "Task Description: Create a Java class that provides administrative operations for Kafka topics, including retrieving configurations for individual topics, multiple topics, and all topics in a Kafka cluster.\n\nClass Description: The KafkaAdminTopicConfigProvider class is designed to interact with Kafka's AdminClient to perform topic configuration operations. It provides methods to fetch topic configurations either for a single topic, a set of topics, or all topics in the cluster. The class handles timeouts and errors gracefully and converts Kafka Config objects into standard Java Properties objects.\n\nAttributes:\n- _clusterConfigs: [Properties] - Stores configuration properties for the Kafka cluster\n- _adminClient: [AdminClient] - The Kafka AdminClient instance used to perform administrative operations\n- DESCRIBE_CLUSTER_CONFIGS_TIMEOUT: [Duration] - Constant defining the timeout duration for describeConfigs operations (90 seconds)\n- LOG: [Logger] - Logger instance for logging debug and warning messages\n\nMethods:\n- topicConfigs: [String topic] -> [Properties] - Retrieves configuration properties for a single specified topic. Returns empty Properties if retrieval fails.\n- topicConfigs: [Set<String> topics] -> [Map<String, Properties>] - Retrieves configurations for multiple topics specified in the input set. Returns a map of topic names to their configurations.\n- allTopicConfigs: [] -> [Map<String, Properties>] - Retrieves configurations for all topics in the Kafka cluster. Returns an empty map if retrieval fails.\n- convertConfigToProperties: [Config config] -> [Properties] - Helper method that converts a Kafka Config object into a Java Properties object, filtering out null entries.",
    "Canonical_solution": "import java.time.Duration;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigEntry;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class KafkaAdminTopicConfigProvider {\n  private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n  public static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n  protected Properties _clusterConfigs;\n  protected AdminClient _adminClient;\n\n  public Properties topicConfigs(String topic) {\n    Config topicConfig = null;\n    ConfigResource topicResource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n    try {\n      LOG.debug(\"Requesting details for topic '{}'\", topic);\n      topicConfig = _adminClient\n              .describeConfigs(Collections.singletonList(topicResource))\n              .all()\n              .get()\n              .get(topicResource);\n    } catch (ExecutionException ee) {\n      if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n        LOG.warn(\"Failed to retrieve configuration for topic '{}' due to describeConfigs request time out.\", topic);\n      } else {\n        LOG.warn(\"Cannot retrieve configuration for topic '{}'.\", topic, ee);\n      }\n    } catch (InterruptedException ie) {\n      LOG.debug(\"Interrupted while getting configuration for topic '{}'.\", topic, ie);\n    }\n\n    if (topicConfig != null) {\n      return convertConfigToProperties(topicConfig);\n    } else {\n      LOG.warn(\"The configuration for topic '{}' could not be retrieved, returning empty Properties instance.\", topic);\n      return new Properties();\n    }\n  }\n\n  public Map<String, Properties> topicConfigs(Set<String> topics) {\n    Map<ConfigResource, KafkaFuture<Config>> topicConfigs;\n    topicConfigs = _adminClient.describeConfigs(\n            topics.stream().map(name -> new ConfigResource(ConfigResource.Type.TOPIC, name)).collect(Collectors.toList())\n    ).values();\n\n    Map<String, Properties> propsMap = new HashMap<>();\n    if (topicConfigs != null) {\n      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : topicConfigs.entrySet()) {\n        try {\n          Config config = entry.getValue().get();\n          propsMap.put(entry.getKey().name(), convertConfigToProperties(config));\n        } catch (ExecutionException ee) {\n          if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n            LOG.warn(\"Failed to retrieve config for topics due to describeConfigs request timing out.\");\n            break;\n          } else {\n            LOG.debug(\"Cannot retrieve config for topic {}.\", entry.getKey().name(), ee);\n          }\n        } catch (InterruptedException ie) {\n          LOG.debug(\"Interrupted while getting config for topic {}.\", entry.getKey().name(), ie);\n        }\n      }\n    }\n    return propsMap;\n  }\n\n  public Map<String, Properties> allTopicConfigs() {\n    LOG.debug(\"Requesting configurations for all topics\");\n    Set<String> topicNames = null;\n    try {\n      topicNames = _adminClient.listTopics().names().get();\n    } catch (InterruptedException | ExecutionException e) {\n      LOG.warn(\"Unable to obtain list of all topic names from the Kafka Cluster\");\n    }\n\n    if (topicNames == null) {\n      return Collections.emptyMap();\n    } else {\n      return topicConfigs(topicNames);\n    }\n  }\n\n  protected static Properties convertConfigToProperties(Config config) {\n    Properties props = new Properties();\n    for (ConfigEntry entry : config.entries()) {\n      if (entry.name() == null || entry.value() == null) {\n        continue;\n      }\n      props.put(entry.name(), entry.value());\n    }\n    return props;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "wrong_result": "import org.apache.kafka.clients.admin.*;\nimport org.apache.kafka.common.config.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.*;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaAdminTopicConfigProvider {\n    private final Properties _clusterConfigs;\n    private final AdminClient _adminClient;\n    private static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n    private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n\n    public KafkaAdminTopicConfigProvider(Properties clusterConfigs, AdminClient adminClient) {\n        this._clusterConfigs = clusterConfigs;\n        this._adminClient = adminClient;\n    }\n\n    public Properties topicConfigs(String topic) {\n        try {\n            DescribeConfigsResult describeConfigsResult = _adminClient.describeConfigs(Collections.singletonList(new ConfigResource(ConfigResource.Type.TOPIC, topic)), DESCRIBE_CLUSTER_CONFIGS_TIMEOUT);\n            Map<ConfigResource, Config> configs = describeConfigsResult.all().get();\n            if (configs.containsKey(new ConfigResource(ConfigResource.Type.TOPIC, topic))) {\n                return convertConfigToProperties(configs.get(new ConfigResource(ConfigResource.Type.TOPIC, topic)));\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            LOG.warn(\"Failed to retrieve configurations for topic: {}\", topic, e);\n        }\n        return new Properties();\n    }\n\n    public Map<String, Properties> topicConfigs(Set<String> topics) {\n        Map<String, Properties> result = new HashMap<>();\n        try {\n            List<ConfigResource> configResources = new ArrayList<>();\n            for (String topic : topics) {\n                configResources.add(new ConfigResource(ConfigResource.Type.TOPIC, topic));\n            }\n            DescribeConfigsResult describeConfigsResult = _adminClient.describeConfigs(configResources, DESCRIBE_CLUSTER_CONFIGS_TIMEOUT);\n            Map<ConfigResource, Config> configs = describeConfigsResult.all().get();\n            for (Map.Entry<ConfigResource, Config> entry : configs.entrySet()) {\n                String topic = entry.getKey().name();\n                result.put(topic, convertConfigToProperties(entry.getValue()));\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            LOG.warn(\"Failed to retrieve configurations for topics: {}\", topics, e);\n        }\n        return result;\n    }\n\n    public Map<String, Properties> allTopicConfigs() {\n        Map<String, Properties> result = new HashMap<>();\n        try {\n            DescribeConfigsResult describeConfigsResult = _adminClient.describeConfigs(Collections.singletonList(new ConfigResource(ConfigResource.Type.TOPIC, \"*\")), DESCRIBE_CLUSTER_CONFIGS_TIMEOUT);\n            Map<ConfigResource, Config> configs = describeConfigsResult.all().get();\n            for (Map.Entry<ConfigResource, Config> entry : configs.entrySet()) {\n                String topic = entry.getKey().name();\n                result.put(topic, convertConfigToProperties(entry.getValue()));\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            LOG.warn(\"Failed to retrieve configurations for all topics in the cluster\", e);\n        }\n        return result;\n    }\n\n    private Properties convertConfigToProperties(Config config) {\n        Properties properties = new Properties();\n        for (ConfigEntry entry : config.entries()) {\n            if (entry.value() != null) {\n                properties.put(entry.name(), entry.value());\n            }\n        }\n        return properties;\n    }\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.ContentType;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n    private final Logger mLog;\n    private final CloseableHttpClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private final boolean mConnectionLoggingSuppressed;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        this.mLog = org.slf4j.LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n        this.mHttpClient = HttpClients.createDefault();\n        this.mIcecastConfiguration = icecastConfiguration;\n        this.mConnectionLoggingSuppressed = false;\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {\n            try {\n                String mountPoint = mIcecastConfiguration.getMountPoint();\n                String host = mIcecastConfiguration.getHost();\n                int port = mIcecastConfiguration.getPort();\n                String username = mIcecastConfiguration.getUsername();\n                String password = mIcecastConfiguration.getPassword();\n\n                String metadataUrl = String.format(\"http://%s:%d%s\", host, port, mountPoint);\n                HttpPost httpPost = new HttpPost(metadataUrl);\n\n                String metadata = buildMetadataString(identifierCollection);\n                StringEntity entity = new StringEntity(metadata, ContentType.TEXT_XML);\n                httpPost.setEntity(entity);\n\n                httpPost.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                httpPost.setHeader(\"User-Agent\", \"IcecastBroadcastMetadataUpdater\");\n\n                if (username != null && !username.isEmpty()) {\n                    String auth = username + \":\" + password;\n                    String encodedAuth = java.util.Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));\n                    httpPost.setHeader(\"Authorization\", \"Basic \" + encodedAuth);\n                }\n\n                try (CloseableHttpResponse response = mHttpClient.execute(httpPost)) {\n                    HttpEntity responseEntity = response.getEntity();\n                    if (responseEntity != null) {\n                        String responseString = EntityUtils.toString(responseEntity);\n                        mLog.info(\"Metadata update response: {}\", responseString);\n                    }\n                } catch (IOException e) {\n                    if (!mConnectionLoggingSuppressed) {\n                        mLog.error(\"Failed to send metadata update to Icecast server: {}\", e.getMessage());\n                    }\n                }\n            } catch (Exception e) {\n                mLog.error(\"Unexpected error during metadata update: {}\", e.getMessage());\n            } finally {\n                executor.shutdown();\n            }\n        });\n    }\n\n    private String buildMetadataString(IdentifierCollection identifiers) {\n        StringBuilder sb = new StringBuilder();\n        for (String key : identifiers.keySet()) {\n            String value = identifiers.get(key);\n            sb.append(String.format(\"%s=%s&\", key, value));\n        }\n        if (sb.length() > 0) {\n            sb.setLength(sb.length() - 1); // Remove the trailing '&'\n        }\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 483,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for secure shell terminal communication, handling client connections, message exchange, and session management.\n\nClass Description: SecureShellWS is a Java EE WebSocket endpoint that facilitates secure shell terminal interactions between clients and servers. It manages terminal sessions, processes keyboard input commands, and handles connection lifecycle events.\n\nAttributes:\n- log: [Logger] - Logger instance for error and debug logging\n- keyMap: [Map<Integer, byte[]>] - Static mapping of key codes to their corresponding byte sequences for terminal control\n- httpSession: [HttpSession] - HTTP session associated with the WebSocket connection\n- session: [Session] - WebSocket session object for the current connection\n- sessionId: [Long] - Unique identifier for the terminal session\n\nMethods:\n- onOpen: [onOpen](Session session, EndpointConfig config) -> void - Handles new WebSocket connections, initializes session parameters, and starts output thread\n- onMessage: [onMessage](String message) -> void - Processes incoming JSON messages containing terminal commands or key inputs\n- onError: [onError](Session session, Throwable t) -> void - Handles WebSocket communication errors\n- onClose: [onClose]() -> void - Cleans up resources when WebSocket connection is closed, terminating all associated terminal sessions",
    "Canonical_solution": "import com.google.gson.Gson;\nimport io.bastillion.common.util.AppConfig;\nimport io.bastillion.common.util.AuthUtil;\nimport io.bastillion.manage.control.SecureShellKtrl;\nimport io.bastillion.manage.db.UserDB;\nimport io.bastillion.manage.model.SchSession;\nimport io.bastillion.manage.model.UserSchSessions;\nimport io.bastillion.manage.task.SentOutputTask;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpSession;\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ServerEndpoint(value = \"/admin/terms.ws\", configurator = GetHttpSessionConfigurator.class)\npublic class SecureShellWS {\n\n    private static final Logger log = LoggerFactory.getLogger(SecureShellWS.class);\n    private static final Map<Integer, byte[]> keyMap = new HashMap<>();\n\n    static {\n        keyMap.put(27, new byte[]{(byte) 0x1b});\n        keyMap.put(13, new byte[]{(byte) 0x0d});\n        keyMap.put(37, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x44});\n        keyMap.put(38, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x41});\n        keyMap.put(39, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x43});\n        keyMap.put(40, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x42});\n        keyMap.put(8, new byte[]{(byte) 0x7f});\n        keyMap.put(9, new byte[]{(byte) 0x09});\n        keyMap.put(17, new byte[]{});\n        keyMap.put(46, \"\\033[3~\".getBytes());\n        keyMap.put(45, \"\\033[2~\".getBytes());\n        keyMap.put(33, \"\\033[5~\".getBytes());\n        keyMap.put(34, \"\\033[6~\".getBytes());\n        keyMap.put(35, \"\\033[4~\".getBytes());\n        keyMap.put(36, \"\\033[1~\".getBytes());\n    }\n\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        if (StringUtils.isNotEmpty(AppConfig.getProperty(\"websocketTimeout\"))) {\n            session.setMaxIdleTimeout(Long.parseLong(AppConfig.getProperty(\"websocketTimeout\")) * 60000);\n        } else {\n            session.setMaxIdleTimeout(0);\n        }\n\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        try {\n            this.sessionId = AuthUtil.getSessionId(httpSession);\n            this.session = session;\n            new Thread(new SentOutputTask(sessionId, session, UserDB.getUser(AuthUtil.getUserId(httpSession)))).start();\n        } catch (GeneralSecurityException | SQLException ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        if (session.isOpen() && StringUtils.isNotEmpty(message) && !\"heartbeat\".equals(message)) {\n            try {\n                Map jsonRoot = new Gson().fromJson(message, Map.class);\n                String command = (String) jsonRoot.get(\"command\");\n                Integer keyCode = null;\n                Double keyCodeDbl = (Double) jsonRoot.get(\"keyCode\");\n                if (keyCodeDbl != null) {\n                    keyCode = keyCodeDbl.intValue();\n                }\n\n                for (String idStr : (ArrayList<String>) jsonRoot.get(\"id\")) {\n                    Integer id = Integer.parseInt(idStr);\n                    UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n                    if (userSchSessions != null) {\n                        SchSession schSession = userSchSessions.getSchSessionMap().get(id);\n                        if (keyCode != null && keyMap.containsKey(keyCode)) {\n                            schSession.getCommander().write(keyMap.get(keyCode));\n                        } else {\n                            schSession.getCommander().print(command);\n                        }\n                    }\n                }\n                AuthUtil.setTimeout(httpSession);\n            } catch (IOException ex) {\n                log.error(ex.toString(), ex);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.error(t.toString(), t);\n    }\n\n    @OnClose\n    public void onClose() {\n        UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n        if (userSchSessions != null) {\n            Map<Integer, SchSession> schSessionMap = userSchSessions.getSchSessionMap();\n            for (Integer sessionKey : schSessionMap.keySet()) {\n                SchSession schSession = schSessionMap.get(sessionKey);\n                schSession.getChannel().disconnect();\n                schSession.getSession().disconnect();\n                schSessionMap.remove(sessionKey);\n            }\n            schSessionMap.clear();\n            SecureShellKtrl.getUserSchSessionMap().remove(sessionId);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "import javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.EndpointConfig;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Logger;\n\npublic class SecureShellWS {\n    private static final Logger log = Logger.getLogger(SecureShellWS.class.getName());\n    private static final Map<Integer, byte[]> keyMap = new ConcurrentHashMap<>();\n    protected HttpSession httpSession;\n    protected Session session;\n    protected Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        this.session = session;\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        this.sessionId = generateSessionId();\n        startOutputThread();\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        try {\n            // Process incoming JSON message\n            if (message.contains(\"command\")) {\n                String command = extractCommand(message);\n                executeCommand(command);\n            } else if (message.contains(\"key\")) {\n                int keyCode = extractKeyCode(message);\n                byte[] bytes = keyMap.getOrDefault(keyCode, new byte[0]);\n                sendBytesToTerminal(bytes);\n            }\n        } catch (Exception e) {\n            log.severe(\"Error processing message: \" + e.getMessage());\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.severe(\"WebSocket error: \" + t.getMessage());\n        terminateSession();\n    }\n\n    @OnClose\n    public void onClose() {\n        terminateSession();\n    }\n\n    private Long generateSessionId() {\n        return System.currentTimeMillis();\n    }\n\n    private void startOutputThread() {\n        new Thread(() -> {\n            while (!session.isClosed()) {\n                try {\n                    byte[] data = readFromTerminal();\n                    session.getBasicRemote().sendBinary(data);\n                } catch (IOException e) {\n                    log.severe(\"Error sending data to client: \" + e.getMessage());\n                    break;\n                }\n            }\n        }).start();\n    }\n\n    private String extractCommand(String message) {\n        return message.split(\"\\\"command\\\":\\\"\")[1].split(\"\\\"\")[0];\n    }\n\n    private int extractKeyCode(String message) {\n        return Integer.parseInt(message.split(\"\\\"keyCode\\\":\")[1].split(\",\")[0]);\n    }\n\n    private void executeCommand(String command) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"/bin/bash\", \"-c\", command);\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = process.getInputStream().read(buffer)) != -1) {\n                sendBytesToTerminal(buffer, bytesRead);\n            }\n            process.waitFor();\n        } catch (Exception e) {\n            log.severe(\"Command execution failed: \" + e.getMessage());\n        }\n    }\n\n    private void sendBytesToTerminal(byte[] data, int length) {\n        try {\n            session.getBasicRemote().sendBinary(java.nio.ByteBuffer.wrap(data, 0, length));\n        } catch (IOException e) {\n            log.severe(\"Failed to send bytes to terminal: \" + e.getMessage());\n        }\n    }\n\n    private void sendBytesToTerminal(byte[] data) {\n        sendBytesToTerminal(data, data.length);\n    }\n\n    private byte[] readFromTerminal() {\n        // Simulated terminal output reading logic\n        return new byte[0];\n    }\n\n    private void terminateSession() {\n        if (session != null && !session.isClosed()) {\n            try {\n                session.close();\n            } catch (IOException e) {\n                log.severe(\"Error closing WebSocket session: \" + e.getMessage());\n            }\n        }\n        // Additional cleanup logic here\n    }\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url) throws Exception {\n        return sendRequest(\"GET\", buildUrl(url), null);\n    }\n\n    public HttpResponse<String> get(String url, Object... params) throws Exception {\n        return sendRequest(\"GET\", buildUrlWithParams(url, params), null);\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) throws Exception {\n        return sendRequest(\"DELETE\", buildUrlWithParams(url, params), null);\n    }\n\n    public HttpResponse<String> post(String url, Object... params) throws Exception {\n        String body = params.length > 0 ? params[0].toString() : \"\";\n        return sendRequest(\"POST\", buildUrlWithParams(url, params), body);\n    }\n\n    private String buildUrl(String url) {\n        return baseUri + url;\n    }\n\n    private String buildUrlWithParams(String url, Object... params) {\n        return String.format(baseUri + url, params);\n    }\n\n    private HttpResponse<String> sendRequest(String method, String uri, String body) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(uri))\n                .method(method, body == null ? HttpRequest.BodyPublishers.noBody() : HttpRequest.BodyPublishers.ofString(body))\n                .build();\n\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public static <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Java utility class for making HTTP/HTTPS requests with support for custom timeouts, request methods, content types, and handling of both successful and error responses.\n\nClass Description: HttpUtil is a utility class that provides methods for making HTTP/HTTPS requests. It handles both secure (HTTPS) and non-secure (HTTP) connections, supports various request methods (GET, POST, etc.), and includes proper error handling and resource cleanup.\n\nAttributes:\n- Timeout: [int] - Default timeout value for connections (5000ms)\n- DefalutEncoding: [String] - Default character encoding for requests/responses (\"UTF-8\")\n- currentProxy: [Map] - Storage for proxy configuration (currently unused in the reference implementation)\n- allHostsValid: [HostnameVerifier] - Custom hostname verifier that accepts all HTTPS hosts\n\nMethods:\n- httpRequest: [httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding)] -> [String] - Makes an HTTP/HTTPS request with specified parameters and returns the response as a string\n- readString: [readString(InputStream inputStream, String encoding)] -> [String] - Helper method to read an InputStream into a String with specified encoding\n- X509TrustUtiil: [Nested class implementing X509TrustManager] - Custom trust manager that accepts all certificates for HTTPS connections\n\nThe class handles:\n1. Both HTTP and HTTPS connections\n2. Custom timeouts for connect and read operations\n3. Various request methods (GET, POST, etc.)\n4. Request headers (particularly Content-Type)\n5. Request body for POST requests\n6. Proper error stream handling\n7. Resource cleanup (connection closing, stream closing)\n8. SSL certificate verification bypass for HTTPS\n9. Character encoding for requests and responses",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy = new HashMap();\n    public static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        if (\"\".equals(encoding) || encoding == null) {\n            encoding = DefalutEncoding;\n        }\n\n        URLConnection httpUrlConn = null;\n        HttpsURLConnection hsc = null;\n        HttpURLConnection hc = null;\n        InputStream inputStream = null;\n\n        String result;\n        try {\n            URL url = new URL(requestUrl);\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                TrustManager[] tm = new TrustManager[]{new X509TrustUtiil()};\n                sslContext.init(null, tm, new SecureRandom());\n                SSLSocketFactory ssf = sslContext.getSocketFactory();\n                hsc = (HttpsURLConnection) url.openConnection();\n                hsc.setSSLSocketFactory(ssf);\n                hsc.setHostnameVerifier(allHostsValid);\n                httpUrlConn = hsc;\n            } else {\n                hc = (HttpURLConnection) url.openConnection();\n                hc.setRequestMethod(requestMethod);\n                hc.setInstanceFollowRedirects(false);\n                httpUrlConn = hc;\n            }\n\n            httpUrlConn.setConnectTimeout(timeOut);\n            httpUrlConn.setReadTimeout(timeOut);\n            if (contentType != null && !\"\".equals(contentType)) {\n                httpUrlConn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            httpUrlConn.setDoOutput(true);\n            httpUrlConn.setDoInput(true);\n            httpUrlConn.connect();\n            if (null != postString && !\"\".equals(postString)) {\n                OutputStream outputStream = httpUrlConn.getOutputStream();\n                outputStream.write(postString.getBytes(encoding));\n                outputStream.flush();\n                outputStream.close();\n            }\n\n            inputStream = httpUrlConn.getInputStream();\n            result = readString(inputStream, encoding);\n            return result;\n        } catch (IOException var18) {\n            if (hsc == null) {\n                if (hc != null) {\n                    result = readString(hc.getErrorStream(), encoding);\n                    return result;\n                }\n                result = \"\";\n                return result;\n            }\n            result = readString(hsc.getErrorStream(), encoding);\n        } finally {\n            if (hsc != null) {\n                hsc.disconnect();\n            }\n            if (hc != null) {\n                hc.disconnect();\n            }\n        }\n        return result;\n    }\n\n    public static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedInputStream bis = null;\n        ByteArrayOutputStream baos = null;\n\n        try {\n            bis = new BufferedInputStream(inputStream);\n            baos = new ByteArrayOutputStream();\n            byte[] arr = new byte[1];\n\n            int len;\n            while ((len = bis.read(arr)) != -1) {\n                baos.write(arr, 0, len);\n            }\n        } finally {\n            if (baos != null) {\n                baos.flush();\n                baos.close();\n            }\n            if (bis != null) {\n                bis.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            return baos.toString(encoding);\n        }\n    }\n\n    static class X509TrustUtiil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.security.cert.X509Certificate;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefaultEncoding = \"UTF-8\";\n    private static final Map<String, String> currentProxy = new HashMap<>();\n    private static final HostnameVerifier allHostsValid = (hostname, session) -> true;\n\n    static {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustUtil()};\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            if (url.getProtocol().toLowerCase().equals(\"https\")) {\n                ((HttpsURLConnection) connection).setHostnameVerifier(allHostsValid);\n            }\n            connection.setRequestMethod(requestMethod);\n            connection.setConnectTimeout(timeOut);\n            connection.setReadTimeout(timeOut);\n            connection.setRequestProperty(\"Content-Type\", contentType);\n            connection.setDoOutput(true);\n\n            if (postString != null && !postString.isEmpty()) {\n                try (OutputStream os = connection.getOutputStream()) {\n                    os.write(postString.getBytes(encoding != null ? encoding : DefaultEncoding));\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            InputStream inputStream;\n            if (responseCode >= 200 && responseCode < 300) {\n                inputStream = connection.getInputStream();\n            } else {\n                inputStream = connection.getErrorStream();\n            }\n\n            return readString(inputStream, encoding != null ? encoding : DefaultEncoding);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private static String readString(InputStream inputStream, String encoding) {\n        if (inputStream == null) {\n            return null;\n        }\n        try {\n            Reader reader = new InputStreamReader(inputStream, encoding);\n            char[] buffer = new char[1024];\n            StringBuilder sb = new StringBuilder();\n            int length;\n            while ((length = reader.read(buffer)) > 0) {\n                sb.append(buffer, 0, length);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private static class X509TrustUtil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n}"
  },
  {
    "Task_id": 509,
    "Instruction": "Task Description: Create a gRPC server in Java that handles incoming requests with configurable delays and traces request contexts using Brave propagation. The server should intercept calls to collect headers and propagation data, and allow for graceful shutdown.\n\nClass Description: TestServer is a gRPC server implementation that intercepts incoming calls to collect tracing information and headers. It supports configurable response delays and maintains queues for request processing.\n\nAttributes:\n- delayQueue: BlockingQueue<Long> - Queue for storing artificial delay durations (milliseconds) to be applied to requests\n- headers: BlockingQueue<Metadata> - Queue for storing metadata headers from incoming requests\n- requests: BlockingQueue<TraceContextOrSamplingFlags> - Queue for storing extracted trace contexts from requests\n- extractor: Extractor<GrpcServerRequest> - Brave propagation extractor for trace context extraction\n- server: Server - The gRPC server instance\n\nMethods:\n- TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) -> void - Constructor that initializes the server with propagation configuration\n- start() -> void - Starts the gRPC server\n- stop() -> void - Stops the server gracefully and awaits termination\n- port() -> int - Returns the port number the server is listening on\n- takeRequest() -> TraceContextOrSamplingFlags - Retrieves the next request context from the queue (waits up to 3 seconds)\n- enqueueDelay(long millis) -> void - Adds a delay duration to be applied to the next request",
    "Canonical_solution": "import brave.propagation.Propagation;\nimport brave.propagation.TraceContext.Extractor;\nimport brave.propagation.TraceContextOrSamplingFlags;\nimport io.grpc.Metadata;\nimport io.grpc.Metadata.Key;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerCall;\nimport io.grpc.ServerCall.Listener;\nimport io.grpc.ServerCallHandler;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerInterceptors;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\nclass TestServer {\n  static final Key<String> CUSTOM_KEY = Key.of(\"custom\", Metadata.ASCII_STRING_MARSHALLER);\n  final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n  final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n  final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n  final Extractor<GrpcServerRequest> extractor;\n  final Server server;\n\n  TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n    extractor = propagation.extractor(GrpcServerRequest::propagationField);\n    server = ServerBuilder.forPort(PickUnusedPort.get())\n        .addService(ServerInterceptors.intercept(\n            new GreeterImpl(null),\n            new ServerInterceptor() {\n              @Override\n              public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n                  Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n                Long delay = delayQueue.poll();\n                if (delay != null) {\n                  try {\n                    Thread.sleep(delay);\n                  } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new AssertionError(\"interrupted sleeping \" + delay);\n                  }\n                }\n                TestServer.this.headers.add(headers);\n                requests.add(extractor.extract(new GrpcServerRequest(nameToKey, call, headers)));\n                return next.startCall(new SimpleForwardingServerCall<ReqT, RespT>(call) {\n                  @Override public void sendHeaders(Metadata headers) {\n                    headers.put(CUSTOM_KEY, \"brave\");\n                    super.sendHeaders(headers);\n                  }\n                }, headers);\n              }\n            }))\n        .build();\n  }\n\n  void start() throws IOException {\n    server.start();\n  }\n\n  void stop() {\n    server.shutdown();\n    try {\n      server.awaitTermination();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  int port() {\n    return server.getPort();\n  }\n\n  TraceContextOrSamplingFlags takeRequest() {\n    try {\n      return requests.poll(3, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  void enqueueDelay(long millis) {\n    this.delayQueue.add(millis);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "import io.grpc.*;\nimport io.grpc.netty.NettyServerBuilder;\nimport brave.propagation.Extractor;\nimport brave.propagation.Propagation;\nimport brave.propagation.TraceContext;\nimport brave.propagation.TraceContextOrSamplingFlags;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestServer {\n    private final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n    private final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n    private final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n    private final Extractor<GrpcServerRequest> extractor;\n    private final Server server;\n    private final int port;\n\n    public TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n        this.extractor = propagation.newExtractor(GrpcServerRequest::new);\n        this.server = NettyServerBuilder.forPort(0)\n                .addService(new ServerInterceptor())\n                .build();\n        this.port = server.getPort();\n    }\n\n    public void start() {\n        try {\n            server.start();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start gRPC server\", e);\n        }\n    }\n\n    public void stop() {\n        server.shutdown();\n        try {\n            if (!server.awaitTermination(5, TimeUnit.SECONDS)) {\n                server.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public int port() {\n        return port;\n    }\n\n    public TraceContextOrSamplingFlags takeRequest() {\n        try {\n            return requests.poll(3, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return null;\n        }\n    }\n\n    public void enqueueDelay(long millis) {\n        delayQueue.offer(millis);\n    }\n\n    private class ServerInterceptor extends ServerInterceptorAdapter {\n        @Override\n        public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n            TraceContextOrSamplingFlags context = extractor.extract(new GrpcServerRequest(headers));\n            requests.offer(context);\n            long delay = delayQueue.poll(1, TimeUnit.SECONDS);\n            if (delay > 0) {\n                try {\n                    Thread.sleep(delay);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n            return next.startCall(call, headers);\n        }\n    }\n\n    private static class GrpcServerRequest {\n        private final Metadata headers;\n\n        GrpcServerRequest(Metadata headers) {\n            this.headers = headers;\n        }\n\n        public Metadata getHeaders() {\n            return headers;\n        }\n    }\n}"
  },
  {
    "Task_id": 513,
    "Instruction": "Task Description: Create a gRPC server in Java that handles data requests, including synchronous, streaming, and bidirectional streaming operations, with Prometheus monitoring integration.\n\nClass Description: DataHandler is a gRPC server implementation that processes various types of data requests. It includes metrics collection through Prometheus and provides three main service methods for data operations.\n\nAttributes:\n- LOG: [Logger] - Logger instance for server operations logging\n- PORT: [int] - Port number for the gRPC server (1111)\n- syncRequests: [Counter] - Prometheus counter for tracking synchronous requests\n- streamingRequests: [Counter] - Prometheus counter for tracking streaming requests\n- grpcServer: [Server] - gRPC server instance\n- prometheusHttpServer: [HTTPServer] - Prometheus HTTP server for metrics exposure\n\nMethods:\n- start() -> [void] - Initializes and starts the gRPC server with Prometheus monitoring interceptor\n- blockUntilShutdown() -> [void] - Blocks the main thread until server shutdown\n- stop() -> [void] - Gracefully shuts down the gRPC server\n\nNested Class: DataImpl extends DataServiceGrpc.DataServiceImplBase and implements three service methods:\n- get([DataRequest], [StreamObserver<DataResponse>]) -> [void] - Handles synchronous data requests (converts input to uppercase)\n- streamingGet([EmptyRequest], [StreamObserver<DataResponse>]) -> [void] - Streams 10 sequential responses\n- streamingPut([StreamObserver<DataRequest>]) -> [StreamObserver<DataResponse>] - Handles bidirectional streaming (modifies and collects input data)",
    "Canonical_solution": "import colossus.data.Data;\nimport colossus.data.DataServiceGrpc;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptors;\nimport io.grpc.stub.StreamObserver;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.Counter;\nimport io.prometheus.client.exporter.HTTPServer;\nimport me.dinowernli.grpc.prometheus.Configuration;\nimport me.dinowernli.grpc.prometheus.MonitoringServerInterceptor;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport java.util.stream.IntStream;\n\npublic class DataHandler {\n    private static final Logger LOG = Logger.getLogger(DataHandler.class.getName());\n    private static final int PORT = 1111;\n    private static final Counter syncRequests = Counter.build()\n            .name(\"data_svc_sync_requests\")\n            .help(\"Sync requests to the data service\")\n            .labelNames(\"request_key\")\n            .register();\n\n    private static final Counter streamingRequests = Counter.build()\n            .name(\"data_svc_streaming_requests\")\n            .help(\"Streaming requests to the data service\")\n            .register();\n\n    private Server grpcServer;\n    private static HTTPServer prometheusHttpServer;\n\n    static class DataImpl extends DataServiceGrpc.DataServiceImplBase {\n        private static final Logger LOG = Logger.getLogger(DataImpl.class.getName());\n\n        @Override\n        public void get(Data.DataRequest req, StreamObserver<Data.DataResponse> resObserver) {\n            String request = req.getRequest();\n            LOG.info(String.format(\"Request received for the string: \\\"%s\\\"\", request));\n            String computedValue = request.toUpperCase();\n            LOG.info(String.format(\"Computed value: \\\"%s\\\"\", computedValue));\n            Data.DataResponse res = Data.DataResponse.newBuilder()\n                    .setValue(computedValue)\n                    .build();\n\n            syncRequests.labels(request).inc();\n\n            resObserver.onNext(res);\n            resObserver.onCompleted();\n        }\n\n        @Override\n        public void streamingGet(Data.EmptyRequest req, StreamObserver<Data.DataResponse> resObserver) {\n            LOG.info(\"Request received for streaming data\");\n\n            Data.DataResponse.Builder resBldr = Data.DataResponse.newBuilder();\n\n            IntStream.range(0, 10).forEach(i -> {\n                String value = String.format(\"Response %d\", i);\n\n                streamingRequests.inc();\n\n                resObserver.onNext(resBldr.setValue(value).build());\n            });\n\n            resObserver.onCompleted();\n        }\n\n        @Override\n        public StreamObserver<Data.DataRequest> streamingPut(final StreamObserver<Data.DataResponse> resObserver) {\n            return new StreamObserver<Data.DataRequest>() {\n                private List<String> items = new ArrayList<>();\n\n                @Override\n                public void onNext(Data.DataRequest req) {\n                    items.add(req.getRequest().replace(\"f\", \"9\").toUpperCase());\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    resObserver.onError(t);\n                }\n\n                @Override\n                public void onCompleted() {\n                    Data.DataResponse res = Data.DataResponse.newBuilder()\n                            .setValue(items.toString())\n                            .build();\n\n                    resObserver.onNext(res);\n                    resObserver.onCompleted();\n                }\n            };\n        }\n    }\n\n    private void start() throws IOException {\n        Configuration monitoringConfig = Configuration.cheapMetricsOnly();\n        MonitoringServerInterceptor prometheusInterceptor = MonitoringServerInterceptor.create(\n            monitoringConfig.withCollectorRegistry(new CollectorRegistry()));\n\n        grpcServer = ServerBuilder.forPort(PORT)\n            .addService(ServerInterceptors.intercept(new DataImpl().bindService(), prometheusInterceptor))\n            .build()\n            .start();\n        LOG.info(String.format(\"gRPC server successfully started on port %d\", PORT));\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (grpcServer != null) {\n            grpcServer.awaitTermination();\n        }\n    }\n\n    private void stop() {\n        if (grpcServer != null) grpcServer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "import io.grpc.*;\nimport io.grpc.netty.NettyServerBuilder;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.exporter.HTTPServer;\nimport io.prometheus.client.hotspot.DefaultExports;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class DataHandler {\n    private static final Logger LOG = LoggerFactory.getLogger(DataHandler.class);\n    private static final int PORT = 1111;\n    private final Counter syncRequests = Counter.build().name(\"sync_requests_total\").help(\"Total synchronous requests\").register();\n    private final Counter streamingRequests = Counter.build().name(\"streaming_requests_total\").help(\"Total streaming requests\").register();\n    private Server grpcServer;\n    private HTTPServer prometheusHttpServer;\n\n    public void start() {\n        try {\n            DefaultExports.initialize();\n            prometheusHttpServer = new HTTPServer(8080);\n            grpcServer = NettyServerBuilder.forPort(PORT)\n                    .addService(new DataImpl())\n                    .intercept(new PrometheusMonitoringInterceptor())\n                    .build()\n                    .start();\n            LOG.info(\"gRPC server started on port {}\", PORT);\n            LOG.info(\"Prometheus metrics available at http://localhost:8080/metrics\");\n        } catch (IOException e) {\n            LOG.error(\"Failed to start server\", e);\n        }\n    }\n\n    public void blockUntilShutdown() {\n        if (grpcServer != null) {\n            try {\n                grpcServer.awaitTermination();\n            } catch (InterruptedException e) {\n                LOG.error(\"Server interrupted\", e);\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public void stop() {\n        if (grpcServer != null) {\n            grpcServer.shutdown();\n            try {\n                if (!grpcServer.awaitTermination(30, TimeUnit.SECONDS)) {\n                    grpcServer.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                grpcServer.shutdownNow();\n                Thread.currentThread().interrupt();\n            }\n        }\n        if (prometheusHttpServer != null) {\n            prometheusHttpServer.stop();\n        }\n    }\n\n    private class PrometheusMonitoringInterceptor implements ServerInterceptor {\n        @Override\n        public <ReqT, RespT> ServerCall<ReqT, RespT> interceptCall(ServerCall<ReqT, RespT> next, Metadata metadata, ServerCallHandler<ReqT, RespT> handler) {\n            return new ForwardingServerCall.SimpleForwardingServerCall<ReqT, RespT>(next) {\n                @Override\n                public void start(@Nullable ServerCall.Listener<RespT> responseListener, Metadata headers) {\n                    String methodName = getMethodName();\n                    if (methodName.equals(\"get\")) {\n                        syncRequests.inc();\n                    } else if (methodName.equals(\"streamingGet\") || methodName.equals(\"streamingPut\")) {\n                        streamingRequests.inc();\n                    }\n                    super.start(responseListener, headers);\n                }\n            };\n        }\n\n        private String getMethodName() {\n            // This is a simplified method to extract the method name; in a real scenario, you would use metadata or context\n            return \"get\";\n        }\n    }\n\n    private class DataImpl extends DataServiceGrpc.DataServiceImplBase {\n        @Override\n        public void get(DataRequest request, StreamObserver<DataResponse> responseObserver) {\n            String input = request.getData();\n            String output = input.toUpperCase();\n            responseObserver.onNext(DataResponse.newBuilder().setData(output).build());\n            responseObserver.onCompleted();\n        }\n\n        @Override\n        public void streamingGet(EmptyRequest request, StreamObserver<DataResponse> responseObserver) {\n            for (int i = 1; i <= 10; i++) {\n                responseObserver.onNext(DataResponse.newBuilder().setData(\"Streamed data \" + i).build());\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    LOG.error(\"Streaming interrupted\", e);\n                }\n            }\n            responseObserver.onCompleted();\n        }\n\n        @Override\n        public StreamObserver<DataRequest> streamingPut(StreamObserver<DataResponse> responseObserver) {\n            return new StreamObserver<DataRequest>() {\n                private StringBuilder collectedData = new StringBuilder();\n\n                @Override\n                public void onNext(DataRequest value) {\n                    String input = value.getData();\n                    String modified = input.toLowerCase();\n                    collectedData.append(modified).append(\" \");\n                    responseObserver.onNext(DataResponse.newBuilder().setData(\"Received: \" + modified).build());\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    LOG.error(\"Error in bidirectional stream\", t);\n                    responseObserver.onError(t);\n                }\n\n                @Override\n                public void onCompleted() {\n                    responseObserver.onNext(DataResponse.newBuilder().setData(\"Collected data: \" + collectedData.toString()).build());\n                    responseObserver.onCompleted();\n                }\n            };\n        }\n    }\n}"
  },
  {
    "Task_id": 519,
    "Instruction": "Task Description: Create a mock IMAP server implementation in Java that simulates IMAP server behavior for testing purposes, handling client connections and interactions through TCP sockets.\n\nClass Description: MockImapServer is a test utility class that simulates an IMAP server by listening on a local port, accepting client connections, and processing predefined interactions. It manages server lifecycle and provides synchronization mechanisms for test coordination.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of predefined IMAP interactions to simulate\n- waitForConnectionClosed: CountDownLatch - Synchronization primitive for waiting until client connection closes\n- waitForAllExpectedCommands: CountDownLatch - Synchronization primitive for waiting until all expected commands are processed\n- mockServerThread: MockServerThread - The thread running the server operations\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread. Binds to an available port on localhost.\n- shutdown() -> void - Stops the server thread and cleans up resources, with a 500ms timeout for graceful shutdown.\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread implementation\n- run() -> void - Main server thread logic that accepts connections, processes interactions, and handles cleanup\n- handleInteractions() -> void - Processes the next interaction from the queue (internal method)\n- readAdditionalCommands() -> void - Reads additional unexpected commands from client (internal method)\n- shouldStop() -> void - Signals the server thread to stop and closes client socket",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = ((java.net.InetSocketAddress) serverSocket.getLocalSocketAddress()).getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n        try {\n            mockServerThread.join(500L);\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                              CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    if (clientSocket != null) {\n                        clientSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = new java.io.BufferedReader(\n                    new java.io.InputStreamReader(clientSocket.getInputStream())).readLine();\n            if (command == null) {\n                throw new java.io.EOFException();\n            }\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                if (clientSocket != null) {\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions;\n    private final CountDownLatch waitForConnectionClosed;\n    private final CountDownLatch waitForAllExpectedCommands;\n    private final MockServerThread mockServerThread;\n    private final String host;\n    private final int port;\n\n    public MockImapServer() {\n        this.interactions = new LinkedBlockingDeque<>();\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n        this.host = \"localhost\";\n        this.port = findAvailablePort();\n        this.mockServerThread = new MockServerThread(createServerSocket(), interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n    }\n\n    private int findAvailablePort() {\n        try (ServerSocket socket = new ServerSocket(0)) {\n            return socket.getLocalPort();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to find available port\", e);\n        }\n    }\n\n    private ServerSocket createServerSocket() {\n        try {\n            return new ServerSocket(port, 1, InetAddress.getByName(host));\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create server socket\", e);\n        }\n    }\n\n    public void start() {\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.interrupt();\n        try {\n            mockServerThread.join(500);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try (Socket clientSocket = serverSocket.accept()) {\n                handleInteractions(clientSocket);\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void handleInteractions(Socket clientSocket) {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n                while (!isInterrupted() && !interactions.isEmpty()) {\n                    ImapInteraction interaction = interactions.pollFirst();\n                    if (interaction != null) {\n                        String command = in.readLine();\n                        if (command != null && command.equals(interaction.getCommand())) {\n                            out.println(interaction.getResponse());\n                        } else {\n                            out.println(\"NO Unexpected command\");\n                        }\n                    }\n                }\n\n                readAdditionalCommands(in);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private void readAdditionalCommands(BufferedReader in) {\n            try {\n                String line;\n                while ((line = in.readLine()) != null) {\n                    // Ignore additional commands\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void addInteraction(String command, String response) {\n        interactions.addLast(new ImapInteraction(command, response));\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public static class ImapInteraction {\n        private final String command;\n        private final String response;\n\n        public ImapInteraction(String command, String response) {\n            this.command = command;\n            this.response = response;\n        }\n\n        public String getCommand() {\n            return command;\n        }\n\n        public String getResponse() {\n            return response;\n        }\n    }\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a function that sends an OCSP (Online Certificate Status Protocol) request to a specified URL and processes the response.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends an OCSP request, reads the response, and constructs an OCSPResp object from the received data. It handles the connection lifecycle and ensures proper resource cleanup.\n\nInput:\n- url: [String] - The URL to which the OCSP request will be sent\n- ocspReq: [OCSPReq] - The OCSP request object containing the encoded request data\n\nOutput:\n- [OCSPResp] - The OCSP response object constructed from the server's response data\n- Throws [IOException] - If any I/O error occurs during the request/response process",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.apache.commons.io.IOUtils;\n\nprivate OCSPResp requestOCSPResponse(String url, OCSPReq ocspReq) throws IOException {\n    byte[] ocspReqData = ocspReq.getEncoded();\n\n    HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();\n    try {\n        con.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n        con.setRequestProperty(\"Accept\", \"application/ocsp-response\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setUseCaches(false);\n        try (OutputStream out = con.getOutputStream()) {\n            IOUtils.write(ocspReqData, out);\n            out.flush();\n        }\n        byte[] responseBytes = IOUtils.toByteArray(con.getInputStream());\n        OCSPResp ocspResp = new OCSPResp(responseBytes);\n        return ocspResp;\n    } finally {\n        if (con != null) {\n            con.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.cert.CertificateException;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport org.bouncycastle.ocsp.OCSPResp;\n\npublic class OCSPRequestHandler {\n    public static OCSPResp sendOCSPRequest(String url, byte[] ocspReq) throws IOException {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            if (conn instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) conn).setSSLSocketFactory(getSSLContext().getSocketFactory());\n                ((HttpsURLConnection) conn).setHostnameVerifier((hostname, session) -> true);\n            }\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(ocspReq);\n            int responseCode = conn.getResponseCode();\n            if (responseCode != 200) {\n                throw new IOException(\"Server returned HTTP response code: \" + responseCode);\n            }\n            InputStream is = conn.getInputStream();\n            byte[] responseData = readStream(is);\n            return new OCSPResp(responseData);\n        } catch (CertificateException e) {\n            throw new IOException(\"Certificate exception occurred: \" + e.getMessage(), e);\n        } finally {\n            // Resource cleanup handled by the JVM\n        }\n    }\n\n    private static SSLContext getSSLContext() throws CertificateException {\n        TrustManager[] trustAllCerts = new TrustManager[]{\n            new X509TrustManager() {\n                public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {}\n                public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {}\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return new java.security.cert.X509Certificate[0];\n                }\n            }\n        };\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n        return sslContext;\n    }\n\n    private static byte[] readStream(InputStream is) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();\n        while ((bytesRead = is.read(buffer)) != -1) {\n            baos.write(buffer, 0, bytesRead);\n        }\n        return baos.toByteArray();\n    }\n}"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class SocketCommunication {\n    public static final String TAG = \"SocketCommunication\";\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList;\n\n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        this.secret = secret;\n        this.callback = callback;\n        startServer(secret, callback);\n        startClient(secret);\n    }\n\n    public void startServer(String secret, VirtualCheckCallback callback) {\n        new ServerThread(secret, callback).start();\n    }\n\n    public void startClient(String secret) {\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ServerThread extends Thread {\n        private String secret;\n        private VirtualCheckCallback callback;\n\n        public ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(0)) {\n                int port = serverSocket.getLocalPort();\n                System.out.println(\"Server started on port: \" + port);\n                while (true) {\n                    Socket clientSocket = serverSocket.accept();\n                    new ReadThread(secret, clientSocket, callback).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private String secret;\n        private Socket socket;\n        private VirtualCheckCallback callback;\n\n        public ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.socket = socket;\n            this.callback = callback;\n        }\n\n        public void run() {\n            try (InputStream input = socket.getInputStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(input))) {\n                String receivedSecret = reader.readLine();\n                if (receivedSecret != null && receivedSecret.equals(secret)) {\n                    callback.onSuspectFound(\"Secret matched\");\n                } else {\n                    callback.onSuspectFound(\"Secret mismatch\");\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ClientThread extends Thread {\n        private String secret;\n        private int port;\n\n        public ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        public void run() {\n            try (Socket socket = new Socket(\"localhost\", port);\n                 OutputStream output = socket.getOutputStream();\n                 PrintWriter writer = new PrintWriter(output, true)) {\n                writer.println(secret);\n                System.out.println(\"Sent secret to port: \" + port);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public interface VirtualCheckCallback {\n        void onSuspectFound(String message);\n    }\n}"
  },
  {
    "Task_id": 521,
    "Instruction": "Task Description: Create a Java class that implements Kubernetes port forwarding functionality, allowing local ports to be forwarded to target ports in a Kubernetes pod. The class should handle multiple port forwards simultaneously and provide error handling capabilities.\n\nClass Description: KubectlPortForward is a Kubernetes client utility that establishes TCP port forwarding between local ports and target ports in a specified pod. It extends Kubectl's ResourceAndContainerBuilder and implements Executable<Boolean> interface. The class manages multiple port forwarding connections in separate threads and provides shutdown capability.\n\nAttributes:\n- localPorts: List<Integer> - Stores local port numbers to be forwarded\n- targetPorts: List<Integer> - Stores target port numbers in the pod\n- running: boolean - Flag indicating whether port forwarding is active\n- onUnhandledError: Consumer<Throwable> - Callback for handling uncaught exceptions\n\nMethods:\n- ports(int localPort, int targetPort) -> KubectlPortForward - Adds a port forwarding pair (local and target ports)\n- onUnhandledError(Consumer<Throwable> onUnhandledError) -> KubectlPortForward - Sets the error handler callback\n- execute() -> Boolean - Starts the port forwarding operation (implements Kubectl.Executable)\n- shutdown() -> void - Stops all port forwarding operations\n- executeInternal() -> void - Internal implementation of port forwarding (throws ApiException, KubectlException, IOException, InterruptedException)\n- portForward(PortForward pf, ServerSocket server, int targetPort) -> Thread - Creates and starts a thread for a single port forwarding connection\n- copyAsync(InputStream, OutputStream, Consumer<Throwable>) -> Thread - Helper method for asynchronous stream copying (not shown in reference code)",
    "Canonical_solution": "import io.kubernetes.client.PortForward;\nimport io.kubernetes.client.extended.kubectl.Kubectl;\nimport io.kubernetes.client.extended.kubectl.exception.KubectlException;\nimport io.kubernetes.client.openapi.ApiException;\nimport io.kubernetes.client.openapi.models.V1Pod;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward\n    extends Kubectl.ResourceAndContainerBuilder<V1Pod, KubectlPortForward>\n    implements Kubectl.Executable<Boolean> {\n  private List<Integer> localPorts;\n  private List<Integer> targetPorts;\n  private boolean running;\n  private Consumer<Throwable> onUnhandledError = Throwable::printStackTrace;\n\n  public KubectlPortForward() {\n    super(V1Pod.class);\n    localPorts = new ArrayList<>();\n    targetPorts = new ArrayList<>();\n  }\n\n  public KubectlPortForward ports(int localPort, int targetPort) {\n    localPorts.add(localPort);\n    targetPorts.add(targetPort);\n    return this;\n  }\n\n  public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n    this.onUnhandledError = onUnhandledError;\n    return this;\n  }\n\n  @Override\n  public Boolean execute() throws KubectlException {\n    running = true;\n    try {\n      executeInternal();\n      return true;\n    } catch (ApiException | IOException | InterruptedException ex) {\n      throw new KubectlException(ex);\n    }\n  }\n\n  public void shutdown() {\n    running = false;\n  }\n\n  private void executeInternal()\n      throws ApiException, KubectlException, IOException, InterruptedException {\n    PortForward pf = new PortForward(apiClient);\n    List<Thread> threads = new ArrayList<>();\n    for (int i = 0; i < localPorts.size(); i++) {\n      int targetPort = targetPorts.get(i);\n      threads.add(portForward(pf, new ServerSocket(localPorts.get(i)), targetPort));\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n  }\n\n  private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n    Thread t = new Thread(\n        () -> {\n          while (running) {\n            try (Socket sock = server.accept()) {\n              PortForward.PortForwardResult result = pf.forward(namespace, name, Arrays.asList(targetPort));\n              if (result == null) {\n                throw new KubectlException(\"PortForward failed!\");\n              }\n              InputStream in = result.getInputStream(targetPort);\n              OutputStream out = result.getOutboundStream(targetPort);\n              Thread t1 = copyAsync(sock.getInputStream(), out, onUnhandledError);\n              Thread t2 = copyAsync(in, sock.getOutputStream(), onUnhandledError);\n\n              t1.join();\n              in.close();\n              t2.join();\n            } catch (Exception ex) {\n              Optional.ofNullable(onUnhandledError)\n                  .orElse(Throwable::printStackTrace)\n                  .accept(ex);\n            }\n          }\n        });\n    t.start();\n    return t;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward extends ResourceAndContainerBuilder implements Executable<Boolean> {\n    private final List<Integer> localPorts = new ArrayList<>();\n    private final List<Integer> targetPorts = new ArrayList<>();\n    private final AtomicBoolean running = new AtomicBoolean(false);\n    private Consumer<Throwable> onUnhandledError;\n\n    public KubectlPortForward(String resource, String container) {\n        super(resource, container);\n    }\n\n    public KubectlPortForward ports(int localPort, int targetPort) {\n        localPorts.add(localPort);\n        targetPorts.add(targetPort);\n        return this;\n    }\n\n    public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n        this.onUnhandledError = onUnhandledError;\n        return this;\n    }\n\n    @Override\n    public Boolean execute() {\n        try {\n            executeInternal();\n            return true;\n        } catch (Exception e) {\n            if (onUnhandledError != null) {\n                onUnhandledError.accept(e);\n            }\n            return false;\n        }\n    }\n\n    public void shutdown() {\n        running.set(false);\n    }\n\n    private void executeInternal() throws ApiException, KubectlException, IOException, InterruptedException {\n        running.set(true);\n        for (int i = 0; i < localPorts.size(); i++) {\n            int localPort = localPorts.get(i);\n            int targetPort = targetPorts.get(i);\n            ServerSocket server = new ServerSocket(localPort);\n            Thread thread = portForward(new PortForward(localPort, targetPort), server, targetPort);\n            thread.start();\n        }\n    }\n\n    private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n        return new Thread(() -> {\n            while (running.get()) {\n                try (Socket client = server.accept();\n                     Socket pod = new Socket(getPodIp(), targetPort)) {\n                    Thread inputThread = copyAsync(client.getInputStream(), pod.getOutputStream(), onUnhandledError);\n                    Thread outputThread = copyAsync(pod.getInputStream(), client.getOutputStream(), onUnhandledError);\n                    inputThread.start();\n                    outputThread.start();\n                } catch (IOException e) {\n                    if (onUnhandledError != null) {\n                        onUnhandledError.accept(e);\n                    }\n                }\n            }\n        });\n    }\n\n    private static class PortForward {\n        private final int localPort;\n        private final int targetPort;\n\n        private PortForward(int localPort, int targetPort) {\n            this.localPort = localPort;\n            this.targetPort = targetPort;\n        }\n    }\n}"
  },
  {
    "Task_id": 530,
    "Instruction": "Task Description: Implement a WebSocket server class in Java that handles WebSocket connections, performs the WebSocket handshake protocol, and manages client connections.\n\nClass Description: The WebSocketServer class represents a TCP server that implements the WebSocket protocol. It listens for incoming connections, handles the WebSocket handshake, and manages client connections. The server runs in a separate thread to avoid blocking the main thread.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- port: int - The port number on which the server listens\n- serverThread: Thread - The thread in which the server runs\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> None - Starts the server in a new thread and begins listening for connections\n- stop() -> None - Stops the server and releases all resources\n- handleClientConnection(Socket client) -> None - Handles the WebSocket handshake protocol for a connected client\n- generateFinalKey(String in) -> String - Generates the Sec-WebSocket-Accept key for the WebSocket handshake response",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket client = null;\n                    try {\n                        client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        // Handle client connection error\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        Scanner in = new Scanner(client.getInputStream());\n        OutputStream os = client.getOutputStream();\n        \n        // Read client handshake\n        String input = in.nextLine();\n        String testCase = input.split(\" \")[1];\n        String seckey = \"\";\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                break;\n            }\n        }\n\n        // Send response based on test case\n        String response = \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\" +\n                         \"Sec-WebSocket-Accept: \" + generateFinalKey(seckey) + \"\\r\\n\\r\\n\";\n        os.write(response.getBytes());\n        os.flush();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String seckey = in.trim();\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            java.security.MessageDigest sh1 = java.security.MessageDigest.getInstance(\"SHA1\");\n            return org.java_websocket.util.Base64.encodeBytes(sh1.digest(acc.getBytes()));\n        } catch (java.security.NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.security.MessageDigest;\nimport java.util.Base64;\n\npublic class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                System.out.println(\"WebSocket server started on port \" + port);\n                while (!serverSocket.isClosed()) {\n                    Socket client = serverSocket.accept();\n                    handleClientConnection(client);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n\n            String requestLine = in.readLine();\n            if (requestLine == null || !requestLine.startsWith(\"GET\")) {\n                return;\n            }\n\n            String upgradeHeader = \"\";\n            String connectionHeader = \"\";\n            String secWebSocketKey = \"\";\n\n            String line;\n            while ((line = in.readLine()) != null && !line.isEmpty()) {\n                if (line.startsWith(\"Upgrade: \")) {\n                    upgradeHeader = line.substring(7).trim();\n                } else if (line.startsWith(\"Connection: \")) {\n                    connectionHeader = line.substring(11).trim();\n                } else if (line.startsWith(\"Sec-WebSocket-Key: \")) {\n                    secWebSocketKey = line.substring(19).trim();\n                }\n            }\n\n            if (!upgradeHeader.equals(\"websocket\") || !connectionHeader.contains(\"Upgrade\")) {\n                return;\n            }\n\n            String finalKey = generateFinalKey(secWebSocketKey);\n            String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                    \"Upgrade: websocket\\r\\n\" +\n                    \"Connection: Upgrade\\r\\n\" +\n                    \"Sec-WebSocket-Accept: \" + finalKey + \"\\r\\n\\r\\n\";\n\n            out.print(response);\n            out.flush();\n\n            // Handle WebSocket messages\n            handleWebSocketMessages(client);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String key = in + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            MessageDigest sha1 = MessageDigest.getInstance(\"SHA-1\");\n            byte[] hash = sha1.digest(key.getBytes());\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n\n    private void handleWebSocketMessages(Socket client) {\n        try {\n            InputStream input = client.getInputStream();\n            OutputStream output = client.getOutputStream();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = input.read(buffer)) != -1) {\n                byte[] message = new byte[bytesRead];\n                System.arraycopy(buffer, 0, message, 0, bytesRead);\n                // Process the received WebSocket message\n                // This is a simplified version; real implementations need to handle framing\n                System.out.println(\"Received message: \" + new String(message));\n                // Echo the message back\n                output.write(message);\n                output.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import android.app.Activity;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider {\n    private EvdevListener listener;\n    private String libraryPath;\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n    private Thread handlerThread;\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.activity = activity;\n        this.listener = listener;\n        this.libraryPath = \"/data/local/tmp/\";\n    }\n\n    public void destroy() {\n        shutdown = true;\n        try {\n            if (evdevIn != null) evdevIn.close();\n            if (evdevOut != null) evdevOut.close();\n            if (servSock != null) servSock.close();\n            if (evdevSock != null) evdevSock.close();\n            if (su != null) su.destroy();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void reportDeviceNotRooted() {\n        new Handler(Looper.getMainLooper()).post(() -> Toast.makeText(activity, \"Device is not rooted\", Toast.LENGTH_LONG).show());\n    }\n\n    public void start() {\n        if (started) return;\n        started = true;\n        handlerThread = new Thread(this::run);\n        handlerThread.start();\n    }\n\n    private void run() {\n        try {\n            servSock = new ServerSocket(0);\n            int port = servSock.getLocalPort();\n            String command = String.format(\"%s/evdev_reader %d\", libraryPath, port);\n            ProcessBuilder pb = new ProcessBuilder(\"su\", \"-c\", command);\n            su = pb.start();\n            evdevSock = servSock.accept();\n            evdevIn = new DataInputStream(evdevSock.getInputStream());\n            evdevOut = new DataOutputStream(evdevSock.getOutputStream());\n\n            byte[] buffer = new byte[1024];\n            while (!shutdown) {\n                int len = evdevIn.read(buffer);\n                if (len > 0) {\n                    listener.onInputEvent(buffer, len);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            reportDeviceNotRooted();\n        } finally {\n            destroy();\n        }\n    }\n\n    public interface EvdevListener {\n        void onInputEvent(byte[] data, int length);\n    }\n}"
  },
  {
    "Task_id": 536,
    "Instruction": "Task Description: Demonstrate basic TCP socket communication between a server and client using Java's ServerSocket and Socket classes. The server should echo back any data received from the client.\n\nFunction Description: The function establishes a TCP server that listens on port 5678, accepts a client connection, reads data from the client, writes the same data back (echo), and then closes the connection. Simultaneously, it creates a client that connects to this server, sends a test message, and verifies the echoed response.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function performs communication internally and handles errors through fail() calls)\n\n---\n\nNote: Since the reference code shows a complete test scenario (both server and client) implemented as a single function with internal threading rather than separate reusable components, I've described it at the function level. If you'd prefer this to be split into proper class definitions for Server and Client components, please let me know and I can provide that alternative structure instead.",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic void testServerSocketCommunication() {\n    Thread listener = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            ServerSocket s = null;\n            try {\n                s = new ServerSocket(5678);\n            } catch (IOException e) {\n                fail(\"exception creating ServerSocket\");\n            }\n\n            byte[] recv = new byte[800];\n\n            Socket peer = null;\n            try {\n                peer = s.accept();\n            } catch (IOException e) {\n                fail(\"accept failed\");\n            }\n\n            InputStream is = peer.getInputStream();\n            OutputStream os = peer.getOutputStream();\n\n            int recvLen = 0;\n            try {\n                recvLen = is.read(recv);\n            } catch (IOException e) {\n                fail(\"read failed\");\n            }\n\n            try {\n                os.write(recv, 0, recvLen);\n            } catch (IOException e) {\n                fail(\"write failed\");\n            }\n\n            try {\n                peer.close();\n                s.close();\n            } catch (IOException e) {\n                fail(\"close failed\");\n            }\n        }\n    });\n    listener.start();\n\n    Socket s = null;\n    try {\n        s = new Socket();\n        s.bind(new InetSocketAddress(\"192.168.0.3\", 0));\n    } catch (IOException e) {\n        fail(\"new socket failed\");\n    }\n\n    try {\n        s.connect(new InetSocketAddress(\"192.168.0.3\", 5678));\n    } catch (IOException e) {\n        fail(\"connect failed\");\n    }\n\n    byte[] send = \"Hello, World!\".getBytes();\n    InputStream is = s.getInputStream();\n    OutputStream os = s.getOutputStream();\n\n    try {\n        os.write(send);\n    } catch (IOException e) {\n        fail(\"exception sending on Socket\");\n    }\n\n    byte[] recv = new byte[800];\n    int recvLen = 0;\n    try {\n        recvLen = is.read(recv);\n    } catch (IOException e) {\n        fail(\"exception receiving on DatagramSocket\");\n    }\n\n    try {\n        listener.join();\n    } catch (InterruptedException e) {\n    }\n\n    try {\n        s.close();\n    } catch (IOException e) {\n        fail(\"close failed\");\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class TCPEchoTest {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        CountDownLatch serverLatch = new CountDownLatch(1);\n        CountDownLatch clientLatch = new CountDownLatch(1);\n\n        executor.submit(() -> {\n            try (ServerSocket serverSocket = new ServerSocket(5678)) {\n                System.out.println(\"Server started, waiting for connection...\");\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"Client connected.\");\n\n                try (InputStream input = clientSocket.getInputStream();\n                     OutputStream output = clientSocket.getOutputStream()) {\n\n                    byte[] buffer = new byte[1024];\n                    int bytesRead = input.read(buffer);\n                    if (bytesRead == -1) {\n                        fail(\"No data received from client\");\n                    }\n\n                    String receivedMessage = new String(buffer, 0, bytesRead);\n                    System.out.println(\"Received: \" + receivedMessage);\n\n                    output.write(buffer, 0, bytesRead);\n                    output.flush();\n                    System.out.println(\"Echoed back: \" + receivedMessage);\n                }\n                serverLatch.countDown();\n            } catch (IOException e) {\n                fail(\"Server error: \" + e.getMessage());\n            }\n        });\n\n        executor.submit(() -> {\n            try {\n                System.out.println(\"Client connecting to server...\");\n                Socket socket = new Socket(\"localhost\", 5678);\n                System.out.println(\"Connected to server.\");\n\n                String testMessage = \"Hello, Echo Server!\";\n                try (OutputStream output = socket.getOutputStream();\n                     InputStream input = socket.getInputStream()) {\n\n                    output.write(testMessage.getBytes());\n                    output.flush();\n                    System.out.println(\"Sent: \" + testMessage);\n\n                    byte[] buffer = new byte[1024];\n                    int bytesRead = input.read(buffer);\n                    if (bytesRead == -1) {\n                        fail(\"No data received from server\");\n                    }\n\n                    String echoedMessage = new String(buffer, 0, bytesRead);\n                    System.out.println(\"Received echo: \" + echoedMessage);\n\n                    if (!echoedMessage.equals(testMessage)) {\n                        fail(\"Echo mismatch. Expected: \" + testMessage + \", but got: \" + echoedMessage);\n                    }\n                }\n                clientLatch.countDown();\n            } catch (IOException e) {\n                fail(\"Client error: \" + e.getMessage());\n            }\n        });\n\n        try {\n            serverLatch.await(5, TimeUnit.SECONDS);\n            clientLatch.await(5, TimeUnit.SECONDS);\n            System.out.println(\"Test completed successfully.\");\n        } catch (InterruptedException e) {\n            fail(\"Test interrupted: \" + e.getMessage());\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n\n    private static void fail(String message) {\n        System.err.println(\"Test failed: \" + message);\n        System.exit(1);\n    }\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a Java class that handles HTTP URL connections for streaming content with support for caching, custom headers, and partial content requests.\n\nClass Description: HttpUrlSource is a class designed to manage HTTP connections for streaming media content. It supports range requests, handles redirects, injects custom headers, and caches source information (URL, content length, MIME type). The class provides methods to open, read, and close connections while managing connection timeouts and redirects.\n\nAttributes:\n\nsourceInfoStorage: [SourceInfoStorage] - Storage for caching source information (URL, length, MIME type)\nheaderInjector: [HeaderInjector] - Injects custom headers into HTTP requests\nsourceInfo: [SourceInfo] - Contains information about the media source (URL, length, MIME type)\nconnection: [HttpURLConnection] - Active HTTP connection\ninputStream: [InputStream] - Input stream for reading content\n\nMethods:\n\nlength(): [long] - Returns the content length of the source, fetching it if not already cached\nopen([long] offset) -> [void] - Opens a connection to the source with optional byte offset\nclose() -> [void] - Closes the current connection\nread([byte[]] buffer) -> [int] - Reads data from the input stream into the buffer\ngetMime() -> [String] - Returns the MIME type of the source, fetching it if not already cached\ngetUrl() -> [String] - Returns the source URL\nfetchContentInfo() -> [void] - Fetches and caches content information (length and MIME type)\nopenConnection([long] offset, [int] timeout) -> [HttpURLConnection] - Opens a connection with optional offset and timeout, handling redirects\ninjectCustomHeaders([HttpURLConnection] connection, [String] url) -> [void] - Injects custom headers into the connection\nreadSourceAvailableBytes([HttpURLConnection] connection, [long] offset, [int] responseCode) -> [long] - Calculates available bytes based on response code\ngetContentLength([HttpURLConnection] connection) -> [long] - Extracts content length from connection headers",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport static com.danikula.videocache.Preconditions.checkNotNull;\nimport static com.danikula.videocache.ProxyCacheUtils.DEFAULT_BUFFER_SIZE;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\n\npublic class HttpUrlSource {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = checkNotNull(sourceInfoStorage);\n        this.headerInjector = checkNotNull(headerInjector);\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n                new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n                : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private void fetchContentInfo() throws ProxyCacheException {\n        HttpURLConnection urlConnection = null;\n        InputStream inputStream = null;\n        try {\n            urlConnection = openConnection(0, 10000);\n            long length = getContentLength(urlConnection);\n            String mime = urlConnection.getContentType();\n            inputStream = urlConnection.getInputStream();\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error fetching info from \" + sourceInfo.url, e);\n        } finally {\n            ProxyCacheUtils.close(inputStream);\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUrlSource {\n    private SourceInfoStorage sourceInfoStorage;\n    private HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n    }\n\n    public long length() {\n        if (sourceInfo == null || sourceInfo.getLength() == -1) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getLength();\n    }\n\n    public void open(long offset) {\n        openConnection(offset, 5000);\n    }\n\n    public void close() {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (connection != null) {\n            connection.disconnect();\n        }\n    }\n\n    public int read(byte[] buffer) {\n        try {\n            return inputStream.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public String getMime() {\n        if (sourceInfo == null || sourceInfo.getMimeType() == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getMimeType();\n    }\n\n    public String getUrl() {\n        return sourceInfo.getUrl();\n    }\n\n    private void fetchContentInfo() {\n        if (sourceInfo == null) {\n            sourceInfo = new SourceInfo();\n        }\n        HttpURLConnection connection = openConnection(0, 5000);\n        if (connection != null) {\n            sourceInfo.setLength(getContentLength(connection));\n            sourceInfo.setMimeType(connection.getContentType());\n            sourceInfoStorage.store(sourceInfo);\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) {\n        try {\n            URL url = new URL(sourceInfo.getUrl());\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n            connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            injectCustomHeaders(connection, url.toString());\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 300 && responseCode < 400) {\n                String redirectUrl = connection.getHeaderField(\"Location\");\n                if (redirectUrl != null) {\n                    return openConnection(offset, timeout);\n                }\n            }\n            return connection;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        headerInjector.injectHeaders(connection, url);\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) {\n        if (responseCode == HttpURLConnection.HTTP_PARTIAL) {\n            long contentLength = getContentLength(connection);\n            return contentLength - offset;\n        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n            long contentLength = getContentLength(connection);\n            return contentLength;\n        }\n        return 0;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n        if (contentLengthHeader != null) {\n            try {\n                return Long.parseLong(contentLengthHeader);\n            } catch (NumberFormatException e) {\n                e.printStackTrace();\n            }\n        }\n        return -1;\n    }\n}"
  },
  {
    "Task_id": 540,
    "Instruction": "Task Description: Implement a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections dynamically.\n\nClass Description: The ConnectionManipulationProxyServer class acts as a TCP proxy that listens on a local port, accepts client connections, and forwards traffic to a specified remote host and port. It provides thread-safe control over the proxy's operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port on which the proxy listens for client connections\n- host: [String] - The remote host address to which traffic will be forwarded\n- remotePort: [int] - The remote port to which traffic will be forwarded\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization lock for thread-safe operation control\n- enableProxy: [boolean] - Flag indicating whether the proxy is currently enabled\n- running: [boolean] - Flag indicating whether the proxy thread should continue running\n- client: [Socket] - The client-side socket connection\n- server: [Socket] - The server-side socket connection\n- serverSocket: [ServerSocket] - The server socket listening for client connections\n\nMethods:\n- ConnectionManipulationProxyServer([String host, int remotePort, int localPort]) -> [void] - Constructor that initializes the proxy with target host and port information\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread execution method that handles connection setup and data forwarding\n- getLocalPort() -> [int] - Returns the local port on which the proxy is listening",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        this.proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            \n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) continue;\n                }\n\n                if (serverSocket == null || serverSocket.isClosed()) {\n                    serverSocket = new ServerSocket(localPort);\n                    localPort = serverSocket.getLocalPort();\n                }\n\n                log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                \n                try {\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                    \n                } catch (IOException ex) {\n                    log.warning(\"[CMPS Proxy] - General IO Exception caught in main Thread: \" + ex.getMessage());\n                    break;\n                } finally {\n                    try {\n                        if (server != null) {\n                            server.close();\n                        }\n                        if (client != null) {\n                            client.close();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException caught whilst closing proxy connection: \" + ex.getMessage());\n                    }\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            log.info(\"[CMPS Proxy] - Server Socket Closed, returning...\");\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class ConnectionManipulationProxyServer {\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private boolean running = false;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                running = true;\n                proxyThread = new Thread(this::run);\n                proxyThread.start();\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            enableProxy = false;\n            running = false;\n            killOpenSockets();\n        }\n    }\n\n    public void killOpenSockets() {\n        try {\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (running) {\n                client = serverSocket.accept();\n                server = new Socket(host, remotePort);\n                new Thread(() -> {\n                    try {\n                        forward(client, server);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    } finally {\n                        try {\n                            client.close();\n                            server.close();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    private void forward(Socket from, Socket to) throws IOException {\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        InputStream input = from.getInputStream();\n        OutputStream output = to.getOutputStream();\n        while ((bytesRead = input.read(buffer)) != -1) {\n            output.write(buffer, 0, bytesRead);\n        }\n        output.flush();\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}"
  },
  {
    "Task_id": 542,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles incoming client connections, processes commands, and interacts with a GUI frame. The server should support checking for existing instances, activating windows, and processing file operations.\n\nClass Description: TcpServer is a Thread subclass that creates a TCP server listening on a specified port. It communicates with clients to perform actions like getting window titles, activating windows, and opening files in the associated GUI frame.\n\nAttributes:\n- frame: IAppFrame - Reference to the application's GUI frame for window operations\n- port: int - The port number on which the server listens\n- file: String - File path to be processed (optional)\n\nMethods:\n- TcpServer(int port, IAppFrame frame) -> None - Constructor initializing server with port and frame reference\n- TcpServer(int port, IAppFrame frame, String file) -> None - Constructor with additional file parameter\n- checkExistInstance(int port) -> boolean - Static method checking if another instance is running on given port\n- ask(String host, String cmd, int port) -> boolean - Private static helper method for sending commands to existing instances\n- run() -> None - Main server thread method that listens for connections and processes client requests",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public static String GETWINDOWTITLE = \"GetWindowTitle\";\n    public static String ACTIVATE = \"ACTIVATE\";\n    public static String LOCALHOST = \"127.0.0.1\";\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(LOCALHOST, GETWINDOWTITLE, port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        Socket s = new Socket();\n        try {\n            InetSocketAddress isa = new InetSocketAddress(host, port);\n            s.connect(isa, 2000);\n            OutputStream os = s.getOutputStream();\n            os.write(cmd.getBytes());\n            InputStream is = s.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = is.read(buffer);\n            String res = new String(buffer, 0, len);\n            return res != null && !res.isEmpty();\n        } catch (Exception x) {\n            return false;\n        } finally {\n            try {\n                s.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    public void run() {\n        ServerSocket ss = null;\n        try {\n            ss = new ServerSocket(port, 10, InetAddress.getByName(LOCALHOST));\n            while (true) {\n                Socket s = ss.accept();\n                try {\n                    InputStream is = s.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    int len = is.read(buffer);\n                    String file = new String(buffer, 0, len);\n                    \n                    if (file.equals(GETWINDOWTITLE)) {\n                        OutputStream os = s.getOutputStream();\n                        String wTitle = ((JFrame) frame).getTitle();\n                        os.write(wTitle.getBytes());\n                    } else if (file.equals(ACTIVATE)) {\n                        ((JFrame) frame).toFront();\n                    } else {\n                        if (file.startsWith(\"\\\"\")) {\n                            file = file.substring(1, file.length() - 1);\n                        }\n                        final String sfile = file;\n                        SwingUtilities.invokeLater(() -> {\n                            try {\n                                frame.openSheetFile(sfile);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        });\n                    }\n                } finally {\n                    s.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class TcpServer extends Thread {\n    private final IAppFrame frame;\n    private final int port;\n    private final String file;\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n        this.file = null;\n    }\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this.port = port;\n        this.frame = frame;\n        this.file = file;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(\"localhost\", port), 100);\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n            out.println(cmd);\n            return in.readLine().equals(\"OK\");\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"Server started on port \" + port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new ClientHandler(clientSocket, frame, file).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class ClientHandler extends Thread {\n        private final Socket socket;\n        private final IAppFrame frame;\n        private final String file;\n\n        public ClientHandler(Socket socket, IAppFrame frame, String file) {\n            this.socket = socket;\n            this.frame = frame;\n            this.file = file;\n        }\n\n        @Override\n        public void run() {\n            try (InputStream input = socket.getInputStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n                 OutputStream output = socket.getOutputStream();\n                 PrintWriter writer = new PrintWriter(output, true)) {\n\n                String command;\n                while ((command = reader.readLine()) != null) {\n                    switch (command) {\n                        case \"GET_WINDOW_TITLES\":\n                            List<String> titles = frame.getWindowTitles();\n                            for (String title : titles) {\n                                writer.println(title);\n                            }\n                            writer.println(\"END\");\n                            break;\n                        case \"ACTIVATE_WINDOW\":\n                            String title = reader.readLine();\n                            frame.activateWindow(title);\n                            writer.println(\"OK\");\n                            break;\n                        case \"OPEN_FILE\":\n                            if (file != null) {\n                                frame.openFile(file);\n                                writer.println(\"OK\");\n                            } else {\n                                writer.println(\"ERROR: No file provided\");\n                            }\n                            break;\n                        default:\n                            writer.println(\"UNKNOWN_COMMAND\");\n                            break;\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 544,
    "Instruction": "Task Description: Create a lightweight HTTP server class that can handle incoming client connections and process requests through abstract methods that must be implemented by subclasses.\n\nClass Description: NanoHTTPD is a minimal HTTP server implementation that listens for incoming TCP connections on a specified port, handles client connections by providing input/output streams, and requires subclasses to implement the actual request processing logic.\n\nAttributes:\n- hostname: String - The hostname or IP address to bind the server to (nullable)\n- myPort: int - The port number to listen on\n- myServerSocket: ServerSocket - The server socket instance for accepting connections\n- myThread: Thread - The main listener thread for the server\n\nMethods:\n- NanoHTTPD(int port) -> void - Constructor that initializes the server with just a port number (hostname defaults to null)\n- NanoHTTPD(String hostname, int port) -> void - Constructor that initializes the server with both hostname and port\n- start() -> void - Starts the server by creating a ServerSocket and launching a daemon thread to accept connections\n- stop() -> void - Stops the server by closing the ServerSocket and joining the listener thread\n- handleConnection(InputStream inputStream, OutputStream outputStream) -> abstract void - Abstract method that must be implemented by subclasses to handle the actual client connection processing",
    "Canonical_solution": "import android.util.Log;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic abstract class NanoHTTPD {\n    private final String hostname;\n    private final int myPort;\n    private ServerSocket myServerSocket;\n    private Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this(null, port);\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() throws IOException {\n        Log.i(\"NanoHTTPD\", \"server start\");\n        myServerSocket = new ServerSocket();\n        myServerSocket.bind((hostname != null) ? new InetSocketAddress(\n                hostname, myPort) : new InetSocketAddress(myPort));\n\n        myThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                do {\n                    try {\n                        final Socket finalAccept = myServerSocket.accept();\n                        Log.i(\"NanoHTTPD\",\n                                \"accept request from \"\n                                        + finalAccept.getInetAddress());\n                        InputStream inputStream = finalAccept.getInputStream();\n                        OutputStream outputStream = finalAccept\n                                .getOutputStream();\n                        handleConnection(inputStream, outputStream);\n                        if (finalAccept != null) {\n                            finalAccept.close();\n                        }\n                    } catch (IOException e) {\n                    }\n                } while (!myServerSocket.isClosed());\n            }\n        });\n        myThread.setDaemon(true);\n        myThread.setName(\"NanoHttpd Main Listener\");\n        myThread.start();\n    }\n\n    public void stop() {\n        Log.i(\"NanoHTTPD\", \"server stop\");\n        try {\n            myServerSocket.close();\n            myThread.join();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public abstract class NanoHTTPD {\n    protected String hostname;\n    protected int myPort;\n    protected ServerSocket myServerSocket;\n    protected Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this.hostname = null;\n        this.myPort = port;\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() {\n        try {\n            if (hostname == null || hostname.isEmpty()) {\n                myServerSocket = new ServerSocket(myPort);\n            } else {\n                myServerSocket = new ServerSocket(myPort, 50, InetAddress.getByName(hostname));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Could not open server socket on port \" + myPort, e);\n        }\n\n        myThread = new Thread(() -> {\n            while (!myThread.isInterrupted()) {\n                try {\n                    Socket clientSocket = myServerSocket.accept();\n                    InputStream inputStream = clientSocket.getInputStream();\n                    OutputStream outputStream = clientSocket.getOutputStream();\n                    handleConnection(inputStream, outputStream);\n                    clientSocket.close();\n                } catch (IOException e) {\n                    if (!myThread.isInterrupted()) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }, \"NanoHTTPD-Listener\");\n        myThread.setDaemon(true);\n        myThread.start();\n    }\n\n    public void stop() {\n        try {\n            if (myServerSocket != null) {\n                myServerSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (myThread != null) {\n            myThread.interrupt();\n            try {\n                myThread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}"
  },
  {
    "Task_id": 547,
    "Instruction": "Task Description: Implement a TCP server class that listens for incoming client connections, processes client commands, and sends responses back. The server should run in a dedicated thread and support graceful shutdown.\n\nClass Description: SnapshotService is a TCP server implementation that listens on a specified port for client connections. It processes incoming commands from clients and responds with processed messages. The server runs in a separate thread and maintains its state through a boolean flag for controlled shutdown.\n\nAttributes:\n- port: [int] - The port number on which the server listens for incoming connections\n- serverSocket: [ServerSocket] - The server socket instance used to accept client connections\n- closed: [boolean] - Flag indicating whether the server has been shut down\n\nMethods:\n- SnapshotService(int port) -> [void] - Constructor that validates and sets the server port\n- listen() -> [void] - Starts the server by opening a socket and beginning to listen for connections\n- openSocket(int port) -> [int] - Creates a ServerSocket and starts a thread to handle client connections, returns the actual port being used\n- isIgnoredException() -> [boolean] - Checks if an exception should be ignored based on server socket state\n- process(Socket socket) -> [void] - Processes an individual client connection, reading input and sending responses\n- outputMessage(BufferedWriter outputWriter, String msg) -> [void] - Helper method to send messages to clients\n- close() -> [void] - Gracefully shuts down the server by closing the server socket",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n@Slf4j\npublic final class SnapshotService {\n\n    private final int port;\n    private ServerSocket serverSocket;\n    private volatile boolean closed;\n\n    public SnapshotService(final int port) {\n        Preconditions.checkArgument(port >= 0 && port <= 0xFFFF, \"Port value out of range: \" + port);\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            log.info(\"ElasticJob: Snapshot service is running on port '{}'\", openSocket(port));\n        } catch (final IOException ex) {\n            log.error(\"ElasticJob: Snapshot service listen failure, error is: \", ex);\n        }\n    }\n\n    private int openSocket(final int port) throws IOException {\n        closed = false;\n        serverSocket = new ServerSocket(port);\n        int localPort = serverSocket.getLocalPort();\n        String threadName = String.format(\"elasticjob-snapshot-service-%d\", localPort);\n        new Thread(() -> {\n            while (!closed) {\n                try {\n                    process(serverSocket.accept());\n                } catch (final IOException ex) {\n                    if (isIgnoredException()) {\n                        return;\n                    }\n                    log.error(\"ElasticJob: Snapshot service open socket failure, error is: \", ex);\n                }\n            }\n        }, threadName).start();\n        return localPort;\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket.isClosed();\n    }\n\n    private void process(final Socket socket) throws IOException {\n        try (\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n                Socket ignored = socket) {\n            String cmdLine = reader.readLine();\n            if (null != cmdLine) {\n                outputMessage(writer, \"Processed: \" + cmdLine);\n            }\n        }\n    }\n\n    private void outputMessage(final BufferedWriter outputWriter, final String msg) throws IOException {\n        outputWriter.append(msg);\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        if (null != serverSocket && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (final IOException ex) {\n                log.error(\"ElasticJob: Snapshot service close failure, error is: \", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class SnapshotService {\n    private int port;\n    private ServerSocket serverSocket;\n    private volatile boolean closed = false;\n\n    public SnapshotService(int port) {\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            openSocket(port);\n            while (!closed) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> process(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        } finally {\n            close();\n        }\n    }\n\n    private int openSocket(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            return serverSocket.getLocalPort();\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n            return -1;\n        }\n    }\n\n    private boolean isIgnoredException() {\n        return closed && serverSocket != null && serverSocket.isClosed();\n    }\n\n    private void process(Socket socket) {\n        try {\n            BufferedReader inputReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            BufferedWriter outputWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            String command;\n            while ((command = inputReader.readLine()) != null) {\n                String response = processCommand(command);\n                outputMessage(outputWriter, response);\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String processCommand(String command) {\n        return \"Processed: \" + command;\n    }\n\n    private void outputMessage(BufferedWriter outputWriter, String msg) {\n        try {\n            outputWriter.write(msg);\n            outputWriter.newLine();\n            outputWriter.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        closed = true;\n        try {\n            if (serverSocket != null && !serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JavaHttpUtility {\n    public static final int CONNECT_TIMEOUT = 10000;\n    public static final int READ_TIMEOUT = 10000;\n\n    public static Proxy getProxy() {\n        return Proxy.getProxySelector().getProxies().isEmpty() ? null : Proxy.getProxySelector().getProxies().get(0);\n    }\n\n    public static String doPost(String urlAddress, Map<String, String> param) throws IOException {\n        URL url = new URL(urlAddress);\n        HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(getProxy());\n        httpURLConnection.setRequestMethod(\"POST\");\n        httpURLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n        httpURLConnection.setReadTimeout(READ_TIMEOUT);\n        httpURLConnection.setUseCaches(false);\n        httpURLConnection.setDoOutput(true);\n\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry<String, String> paramEntry : param.entrySet()) {\n            if (postData.length() != 0) {\n                postData.append('&');\n            }\n            postData.append(paramEntry.getKey()).append('=').append(paramEntry.getValue());\n        }\n        byte[] postDataBytes = postData.toString().getBytes(\"UTF-8\");\n        httpURLConnection.getOutputStream().write(postDataBytes);\n\n        return handleResponse(httpURLConnection);\n    }\n\n    private static String handleResponse(HttpURLConnection httpURLConnection) throws IOException {\n        int responseCode = httpURLConnection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return readResult(httpURLConnection);\n        } else {\n            return handleError(httpURLConnection);\n        }\n    }\n\n    private static String readResult(HttpURLConnection urlConnection) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                urlConnection.getInputStream(), \"UTF-8\"));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        return response.toString();\n    }\n\n    private static String handleError(HttpURLConnection urlConnection) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                urlConnection.getErrorStream(), \"UTF-8\"));\n        String inputLine;\n        StringBuilder errorResponse = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            errorResponse.append(inputLine);\n        }\n        in.close();\n\n        throw new IOException(\"HTTP error code: \" + urlConnection.getResponseCode() + \" - \" + errorResponse.toString());\n    }\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=%s&type=%s\";\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.getAccessToken();\n        String url = String.format(MEDIA_URL, accessToken, type);\n\n        try {\n            CloseableHttpClient httpClient = HttpClients.createDefault();\n            HttpPost httpPost = new HttpPost(url);\n            MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n            builder.addPart(\"media\", new FileBody(new File(mediaFileUrl), judgeType(Files.probeContentType(Paths.get(mediaFileUrl))))); // Assuming mediaFileUrl is a local file path\n            HttpEntity entity = builder.build();\n            httpPost.setEntity(entity);\n\n            CloseableHttpResponse response = httpClient.execute(httpPost);\n            String responseBody = EntityUtils.toString(response.getEntity());\n            JSONObject jsonObject = new JSONObject(responseBody);\n            if (jsonObject.has(\"media_id\")) {\n                return jsonObject.getString(\"media_id\");\n            } else if (jsonObject.has(\"errcode\") && jsonObject.getInt(\"errcode\") == 40001) {\n                wechatAccessTokenUtil.refreshAccessToken();\n                return uploadMedia(type, mediaFileUrl);\n            } else {\n                throw new RuntimeException(\"Upload media failed: \" + responseBody);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error uploading media: \" + e.getMessage(), e);\n        }\n    }\n\n    private String judgeType(String contentType) {\n        if (contentType == null || contentType.isEmpty()) {\n            throw new IllegalArgumentException(\"Unsupported content type\");\n        }\n        switch (contentType) {\n            case \"image/jpeg\":\n                return \".jpg\";\n            case \"image/png\":\n                return \".png\";\n            case \"video/mp4\":\n                return \".mp4\";\n            case \"audio/mpeg\":\n                return \".mp3\";\n            default:\n                throw new IllegalArgumentException(\"Unsupported content type: \" + contentType);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\n\npublic class SocketClient {\n    private final SSLContext clientSslContext;\n    private final InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocketFactory socketFactory = clientSslContext.getSocketFactory();\n        SSLSocket sslSocket = (SSLSocket) socketFactory.createSocket(address.getAddress(), address.getPort());\n        sslSocket.startHandshake();\n\n        String request = \"GET / HTTP/1.1\\r\\nHost: \" + address.getHostString() + \"\\r\\nConnection: close\\r\\n\\r\\n\";\n        sslSocket.getOutputStream().write(request.getBytes());\n\n        readResponse(sslSocket);\n        sslSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n        return reader.readLine();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream inputStream = sslSocket.getInputStream();\n        String line;\n        while ((line = readLine(inputStream)) != null) {\n            System.out.println(line);\n        }\n    }\n}"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class RouterSocketClient {\n    public static final String TAG = \"RouterSocketClient\";\n    public static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    public static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    public static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random random) {\n        mContext = context;\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        mDelayedRestartHandler = new Handler(Looper.getMainLooper());\n    }\n\n    public static Socket connectSocket(String host, int port) {\n        return connectSocketNoProxy(host, port);\n    }\n\n    public static Socket connectSocketNoProxy(String host, int port) {\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            return socket;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to connect directly to \" + host + \":\" + port, e);\n        }\n    }\n\n    public static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) {\n        try {\n            Socket socket = new Socket();\n            socket.connect(proxyAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            OutputStream out = socket.getOutputStream();\n            PrintWriter writer = new PrintWriter(out);\n            writer.println(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\");\n            writer.println(\"Host: \" + host + \":\" + port);\n            writer.println(\"Connection: close\");\n            writer.println();\n            writer.flush();\n\n            InputStream in = socket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            String statusLine = reader.readLine();\n            if (statusLine == null || !statusLine.startsWith(\"HTTP/1.1 200\")) {\n                throw new IOException(\"Proxy CONNECT failed: \" + statusLine);\n            }\n\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            return socket;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to connect via HTTP proxy to \" + host + \":\" + port, e);\n        }\n    }\n\n    public void tryEnableSni(SSLSocket socket, String hostname) {\n        if (socket instanceof javax.net.ssl.SSLSocket) {\n            ((javax.net.ssl.SSLSocket) socket).setEnabledProtocols(new String[]{\"TLSv1.2\", \"TLSv1.1\", \"TLSv1\"});\n            ((javax.net.ssl.SSLSocket) socket).setEnabledCipherSuites(socket.getSupportedCipherSuites());\n            ((javax.net.ssl.SSLSocket) socket).setSSLParameters(\n                    ((javax.net.ssl.SSLSocket) socket).getSSLParameters().withServerNames(\n                            Collections.singletonList(new SNIHostName(hostname))));\n        }\n    }\n\n    public void tryEnableSessionTickets(SSLSocket socket) {\n        if (socket instanceof javax.net.ssl.SSLSocket) {\n            ((javax.net.ssl.SSLSocket) socket).setEnabledProtocols(new String[]{\"TLSv1.2\", \"TLSv1.1\", \"TLSv1\"});\n            ((javax.net.ssl.SSLSocket) socket).setEnabledCipherSuites(socket.getSupportedCipherSuites());\n            ((javax.net.ssl.SSLSocket) socket).setSSLParameters(\n                    ((javax.net.ssl.SSLSocket) socket).getSSLParameters().withUseSessionTickets(true));\n        }\n    }\n}"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.activation.*;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class SendMailJob {\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet fileSet, String server, String from, String subject) {\n        mailServer = server;\n        fromAddress = from;\n        mailSubject = subject;\n        recipientString = \"\";\n        boundary = \"----=_Part_\" + System.currentTimeMillis();\n        connectedToMailServer = false;\n        errorDialogTitle = \"Email Error\";\n    }\n\n    public void openConnection() {\n        try {\n            socket = new Socket(mailServer, 25);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = socket.getOutputStream();\n            readWriteLine(\"HELO localhost\");\n            readWriteLine(\"MAIL FROM:<\" + fromAddress + \">\");\n            String[] recipients = splitRecipientString(recipientString, new ArrayList<String>());\n            for (String recipient : recipients) {\n                readWriteLine(\"RCPT TO:<\" + recipient + \">\");\n            }\n            readWriteLine(\"DATA\");\n            connectedToMailServer = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendBody() {\n        try {\n            writeLine(\"From: \" + fromAddress);\n            writeLine(\"To: \" + recipientString);\n            writeLine(\"Subject: \" + mailSubject);\n            writeLine(\"MIME-Version: 1.0\");\n            writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n            writeLine(\"\");\n            writeLine(\"--\" + boundary);\n            writeLine(\"Content-Type: text/plain; charset=UTF-8\");\n            writeLine(\"Content-Transfer-Encoding: 7bit\");\n            writeLine(\"\");\n            writeLine(mailBody);\n            writeLine(\"\");\n            writeLine(\"--\" + boundary);\n            writeLine(\"Content-Type: application/octet-stream; name=\\\"attachment\\\"\");\n            writeLine(\"Content-Transfer-Encoding: base64\");\n            writeLine(\"Content-Disposition: attachment; filename=\\\"attachment\\\"\");\n            writeLine(\"\");\n            out64 = new Base64OutputStream(out);\n            writeLine(\"\");\n            out64.close();\n            writeLine(\"--\" + boundary + \"--\");\n            writeLine(\".\");\n            closeConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendAttachment(AbstractFile file) {\n        try {\n            out64.write(file.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (in != null) in.close();\n            if (out != null) out.close();\n            if (socket != null) socket.close();\n            connectedToMailServer = false;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void readWriteLine(String line) {\n        try {\n            writeLine(line);\n            String response = in.readLine();\n            System.out.println(response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void writeLine(String line) {\n        try {\n            out.write((line + \"\\r\\n\").getBytes());\n            out.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String splitRecipientString(String recipientString, List<String> recipients) {\n        String[] parts = recipientString.split(\",\");\n        for (String part : parts) {\n            recipients.add(part.trim());\n        }\n        return recipientString;\n    }\n}"
  },
  {
    "Task_id": 564,
    "Instruction": "Task Description: Write a function that tests abnormal request termination behavior in a client-server communication scenario using TCP sockets. The function should simulate sending a malformed HTTP request with incorrect content length and verify proper connection handling.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP POST request with intentionally incorrect Content-Length header, immediately closes the streams, and verifies if the completion listener is called within a timeout period. This tests the server's handling of abruptly terminated requests.\n\nInput: \n- None (uses class-level DefaultServer.getDefaultServerAddress() and completionListenerCalledLatch)\n- Implicit input through class attributes:\n  - DefaultServerAddress: Server endpoint address\n  - completionListenerCalledLatch: CountDownLatch for synchronization\n  - completionListenerCalled: boolean flag to verify listener invocation\n\nOutput: \n- None (void return type)\n- Side effects:\n  - Throws IOException if socket operations fail\n  - Throws InterruptedException if await is interrupted\n  - Asserts completionListenerCalled is true\n  - Closes socket resources in finally block",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(DefaultServer.getDefaultServerAddress());\n    try {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000; ++i) {\n            sb.append(\"hello world\\r\\n\");\n        }\n        String request = \"POST / HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n        OutputStream outputStream = socket.getOutputStream();\n\n        outputStream.write(request.getBytes(\"US-ASCII\"));\n        socket.getInputStream().close();\n        outputStream.close();\n\n        completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertTrue(completionListenerCalled);\n    } finally {\n        IoUtils.safeClose(socket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    String serverAddress = DefaultServer.getDefaultServerAddress();\n    Socket socket = new Socket();\n    socket.connect(new InetSocketAddress(serverAddress, 80));\n    OutputStream outputStream = socket.getOutputStream();\n    PrintWriter writer = new PrintWriter(outputStream, true);\n    InputStream inputStream = socket.getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n\n    writer.println(\"POST / HTTP/1.1\");\n    writer.println(\"Host: \" + serverAddress);\n    writer.println(\"Content-Length: 1000\");\n    writer.println();\n    writer.flush();\n\n    socket.close();\n\n    boolean listenerCalled = completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n    assertTrue(listenerCalled);\n    assertTrue(completionListenerCalled);\n}"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.channels.spi.AbstractSelectableChannel;\n\npublic class UnixSocket extends AbstractSocket {\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws IOException {\n        this.socketAddress = new UnixSocketAddress(path);\n        this.socketChannel = SocketChannel.open();\n        socketChannel.connect(socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        return socketChannel.socket().getInputStream();\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        return socketChannel.socket().getOutputStream();\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketChannel.getLocalAddress();\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketChannel.getRemoteAddress();\n    }\n\n    @Override\n    public void close() throws IOException {\n        socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            socketChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 567,
    "Instruction": "Task Description: Implement a TCP client class in Java that handles network communication with a server, including connection management, data transmission, and reception with proper error handling and resource management.\n\nClass Description: The TcpClient class establishes and maintains a TCP connection to a specified server, sends data packets, and receives responses. It uses a custom protocol with 8-byte headers (4 bytes for type, 4 bytes for length) followed by the message body. The class runs network operations on a dedicated background thread and provides callback mechanisms for received data.\n\nAttributes:\n- TAG: String - Tag for logging purposes\n- PACKAGE_HEAD_LENGTH: int - Fixed length of packet header (8 bytes)\n- receiveListener: ReceiveListener - Callback interface for received data\n- hostip: String - Server IP address to connect to\n- port: int - Server port number\n- socketClient: Socket - The TCP socket instance\n- handler: Handler - Handler for background thread operations\n- receiveThread: Thread - Thread for receiving data\n\nMethods:\n- TcpClient() -> void - Constructor that initializes the background thread and attempts connection\n- tryConnect() -> void - Internal method to attempt server connection in a loop\n- connect() -> boolean - Establishes socket connection to server (returns success status)\n- send(byte[] data) -> void - Sends data to the server (runs on background thread)\n- onReceive(ReceiveListener receiveListener) -> void - Sets the receive callback listener\n- destroy() -> void - Cleans up resources and stops all network operations\n- closeAll() -> void - Safely closes socket and releases resources\n- startReceive() -> void - Starts the data receiving thread\n- getLengthFromHeadByte(byte[] b) -> int - Extracts message length from header bytes\n- getTypeFromHeadByte(byte[] b) -> int - Extracts message type from header bytes\n\nNested Classes:\n- Receiver implements Runnable - Background thread implementation for continuous data reception",
    "Canonical_solution": "import android.os.Handler;\nimport android.os.HandlerThread;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\npublic class TcpClient {\n    private static final String TAG = TcpClient.class.getSimpleName();\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n\n    private ReceiveListener receiveListener;\n    private String hostip = \"192.168.3.28\";\n    private int port = 2233;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        HandlerThread tcpThread = new HandlerThread(\"tcpThread\");\n        tcpThread.start();\n        handler = new Handler(tcpThread.getLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        handler.post(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n            }\n        });\n    }\n\n    private boolean connect() {\n        closeAll();\n        try {\n            socketClient = new Socket();\n            SocketAddress socAddress = new InetSocketAddress(hostip, port);\n            socketClient.connect(socAddress, 5000);\n            Log.i(TAG, \"socket connected successfully\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public void send(byte[] data) {\n        Log.d(TAG, \"send data len:\" + data.length);\n        handler.post(() -> {\n            try {\n                OutputStream outputStream = socketClient.getOutputStream();\n                outputStream.write(data);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient == null || socketClient.isClosed() || !socketClient.isConnected()) {\n            return;\n        }\n        try {\n            socketClient.shutdownInput();\n            socketClient.shutdownOutput();\n            socketClient.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                if (receiveThread.isInterrupted()) {\n                    break;\n                }\n                try {\n                    InputStream inputStream = socketClient.getInputStream();\n                    boolean badPackage = false;\n                    int countHeadBytesLength = 0;\n                    byte[] headData = new byte[PACKAGE_HEAD_LENGTH];\n                    while (countHeadBytesLength < PACKAGE_HEAD_LENGTH) {\n                        int result = inputStream.read(headData, countHeadBytesLength, PACKAGE_HEAD_LENGTH - countHeadBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countHeadBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    int packageType = getTypeFromHeadByte(headData);\n                    int packageBodyBytesLength = getLengthFromHeadByte(headData);\n                    Log.d(TAG, \"new data received type:\" + packageType + \" body len:\" + packageBodyBytesLength);\n\n                    int countBodyBytesLength = 0;\n                    byte[] bodyData = new byte[packageBodyBytesLength];\n                    while (countBodyBytesLength < packageBodyBytesLength) {\n                        int result = inputStream.read(bodyData, countBodyBytesLength, packageBodyBytesLength - countBodyBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countBodyBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceive(packageType, bodyData);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    if (receiveThread.isInterrupted()) {\n                        break;\n                    }\n                    tryConnect();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[4] & 0x00FF;\n        int ch2 = b[5] & 0x00FF;\n        int ch3 = b[6] & 0x00FF;\n        int ch4 = b[7] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n\n    private int getTypeFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[0] & 0x00FF;\n        int ch2 = b[1] & 0x00FF;\n        int ch3 = b[2] & 0x00FF;\n        int ch4 = b[3] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\n\npublic class TcpClient {\n    private static final String TAG = \"TcpClient\";\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n    private ReceiveListener receiveListener;\n    private String hostip;\n    private int port;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        handler = new Handler();\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        new Thread(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                } else {\n                    try {\n                        Thread.sleep(5000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n\n    public boolean connect() {\n        try {\n            socketClient = new Socket(hostip, port);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void send(byte[] data) {\n        handler.post(() -> {\n            try {\n                if (socketClient != null && !socketClient.isClosed()) {\n                    OutputStream outputStream = socketClient.getOutputStream();\n                    byte[] header = new byte[PACKAGE_HEAD_LENGTH];\n                    ByteBuffer buffer = ByteBuffer.wrap(header);\n                    buffer.putInt(1); // message type\n                    buffer.putInt(data.length); // message length\n                    outputStream.write(header);\n                    outputStream.write(data);\n                    outputStream.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        closeAll();\n    }\n\n    private void closeAll() {\n        try {\n            if (socketClient != null && !socketClient.isClosed()) {\n                socketClient.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private int getLengthFromHeadByte(byte[] b) {\n        ByteBuffer buffer = ByteBuffer.wrap(b);\n        return buffer.getInt(4);\n    }\n\n    private int getTypeFromHeadByte(byte[] b) {\n        ByteBuffer buffer = ByteBuffer.wrap(b);\n        return buffer.getInt(0);\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            try {\n                InputStream inputStream = socketClient.getInputStream();\n                ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n                byte[] data = new byte[1024];\n                int bytesRead;\n\n                while ((bytesRead = inputStream.read(data)) != -1) {\n                    buffer.write(data, 0, bytesRead);\n                    if (buffer.size() >= PACKAGE_HEAD_LENGTH) {\n                        byte[] headBytes = new byte[PACKAGE_HEAD_LENGTH];\n                        System.arraycopy(buffer.toByteArray(), 0, headBytes, 0, PACKAGE_HEAD_LENGTH);\n                        int length = getLengthFromHeadByte(headBytes);\n                        if (buffer.size() >= PACKAGE_HEAD_LENGTH + length) {\n                            byte[] fullData = new byte[PACKAGE_HEAD_LENGTH + length];\n                            System.arraycopy(buffer.toByteArray(), 0, fullData, 0, fullData.length);\n                            if (receiveListener != null) {\n                                receiveListener.onReceive(fullData);\n                            }\n                            buffer.reset();\n                            buffer.write(buffer.toByteArray(), PACKAGE_HEAD_LENGTH + length, buffer.size() - (PACKAGE_HEAD_LENGTH + length));\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public interface ReceiveListener {\n        void onReceive(byte[] data);\n    }\n\n    private class Handler {\n        public void post(Runnable runnable) {\n            new Thread(runnable).start();\n        }\n    }\n}"
  },
  {
    "Task_id": 568,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for network communication, including connection management and data transmission.\n\nClass Description: The TelnetTransport class provides TCP client capabilities for establishing connections, sending/receiving data, and managing network resources. It handles multiple IP addresses for a given hostname and provides basic I/O operations.\n\nAttributes:\n- socket: Socket - The underlying TCP socket for network communication\n- is: InputStream - Input stream for receiving data from the server\n- os: OutputStream - Output stream for sending data to the server\n- connected: boolean - Connection status flag indicating whether the client is currently connected\n\nMethods:\n- connect(String hostname, int port) -> void - Establishes a connection to the specified host and port, trying all available IP addresses for the hostname. Throws IOException on connection failure.\n- close() -> void - Closes the connection and releases all network resources. Handles cleanup gracefully.\n- flush() -> void - Flushes the output stream to ensure all buffered data is sent. Throws IOException on failure.\n- isConnected() -> boolean - Returns the current connection status (true if connected).\n- read(byte[] buffer, int start, int len) -> int - Reads data from the input stream into the buffer. Returns number of bytes read or throws IOException if connection is closed.\n- write(byte[] buffer) -> void - Writes the entire buffer to the output stream. Throws IOException on failure.\n- write(int c) -> void - Writes a single byte to the output stream. Throws IOException on failure.\n- tryAllAddresses(Socket sock, String host, int port) -> void - Private helper method that attempts connection to all IP addresses associated with a hostname. Throws SocketTimeoutException if all attempts fail.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.net.UnknownHostException;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected = false;\n\n    public void connect(String hostname, int port) throws IOException {\n        socket = new Socket();\n        tryAllAddresses(socket, hostname, port);\n        connected = true;\n        is = socket.getInputStream();\n        os = socket.getOutputStream();\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress addr : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(addr, port));\n                return;\n            } catch (SocketTimeoutException ignored) {\n            }\n        }\n        throw new SocketTimeoutException(\"Could not connect; socket timed out\");\n    }\n\n    public void close() {\n        connected = false;\n        if (socket != null) {\n            try {\n                socket.close();\n                socket = null;\n            } catch (IOException e) {\n                System.err.println(\"Error closing socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void flush() throws IOException {\n        if (os != null) {\n            os.flush();\n        }\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        int n = is.read(buffer, start, len);\n        if (n < 0) {\n            throw new IOException(\"Remote end closed connection.\");\n        }\n        return n;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (os != null) {\n            os.write(buffer);\n        }\n    }\n\n    public void write(int c) throws IOException {\n        if (os != null) {\n            os.write(c);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected;\n\n    public void connect(String hostname, int port) throws IOException {\n        socket = new Socket();\n        tryAllAddresses(socket, hostname, port);\n        is = socket.getInputStream();\n        os = socket.getOutputStream();\n        connected = true;\n    }\n\n    public void close() {\n        connected = false;\n        try {\n            if (is != null) is.close();\n            if (os != null) os.close();\n            if (socket != null) socket.close();\n        } catch (IOException e) {\n            // Handle exception if needed\n        }\n    }\n\n    public void flush() throws IOException {\n        os.flush();\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        return is.read(buffer, start, len);\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(buffer);\n    }\n\n    public void write(int c) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(c);\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress addr : addresses) {\n            try {\n                sock.connect(new java.net.InetSocketAddress(addr, port), 5000);\n                return;\n            } catch (IOException e) {\n                // Try next address\n            }\n        }\n        throw new SocketTimeoutException(\"Failed to connect to \" + host + \":\" + port);\n    }\n}"
  },
  {
    "Task_id": 569,
    "Instruction": "Task Description: Create a Java class that implements an IRC client connection using TCP sockets, with built-in monitoring capabilities through Stetho for network event reporting.\n\nClass Description: The IRCClientConnection class establishes and manages a connection to an IRC server, handles message sending/receiving, and provides monitoring hooks for network events. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- mReporter: [StethoReporter] - Handles network event reporting to Stetho\n- mSocket: [Socket] - The TCP socket connection to the IRC server\n- mInput: [BufferedReader] - Stream for reading incoming messages\n- mOutput: [BufferedWriter] - Stream for sending outgoing messages\n\nMethods:\n- connect: [String host, int port] -> [IRCClientConnection] - Static factory method that establishes a connection to the specified IRC server\n- read: [] -> [String] - Reads a line from the server input stream and handles PING/PONG protocol\n- send: [String message] -> [void] - Sends a message to the server\n- maybeHandleIncomingMessage: [String message] -> [boolean] - Handles protocol-specific messages (like PING)\n- close: [] -> [void] - Closes all connection resources (implements Closeable)\n- StethoReporter (inner class): [] -> [] - Handles all Stetho-specific network event reporting",
    "Canonical_solution": "import com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.SimpleTextInspectorWebSocketFrame;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.annotation.Nullable;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        StethoReporter reporter = new StethoReporter();\n        Socket socket = new Socket();\n        reporter.onPreConnect(host, port);\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            reporter.onPostConnect();\n        } catch (IOException e) {\n            reporter.onError(e);\n            try {\n                socket.close();\n                throw e;\n            } finally {\n                reporter.onClosed();\n            }\n        }\n        return new IRCClientConnection(reporter, socket, \"UTF-8\");\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, String charset) throws IOException {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream(), charset));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));\n    }\n\n    @Nullable\n    public String read() throws IOException {\n        try {\n            String message = mInput.readLine();\n            if (message != null) {\n                mReporter.onReceive(message);\n                maybeHandleIncomingMessage(message);\n            }\n            return message;\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.onSend(message);\n        try {\n            mOutput.write(message + \"\\r\\n\");\n            mOutput.flush();\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(\"PING \".length()));\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws IOException {\n        try {\n            try {\n                mOutput.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            }\n        } finally {\n            try {\n                mSocket.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            } finally {\n                mReporter.onClosed();\n            }\n        }\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mReporter;\n        private final String mRequestId;\n\n        public StethoReporter() {\n            mReporter = NetworkEventReporterImpl.get();\n            mRequestId = mReporter.nextRequestId();\n        }\n\n        public void onPreConnect(String host, int port) {\n            mReporter.webSocketCreated(mRequestId, \"irc://\" + host + \":\" + port);\n        }\n\n        public void onPostConnect() {\n            // Sadly, nothing to report...\n        }\n\n        public void onError(IOException e) {\n            mReporter.webSocketFrameError(mRequestId, e.getMessage());\n        }\n\n        public void onClosed() {\n            mReporter.webSocketClosed(mRequestId);\n        }\n\n        public void onSend(String message) {\n            mReporter.webSocketFrameSent(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n\n        public void onReceive(String message) {\n            mReporter.webSocketFrameReceived(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\n\npublic class IRCClientConnection implements AutoCloseable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    private IRCClientConnection(Socket socket, StethoReporter reporter) {\n        mSocket = socket;\n        mReporter = reporter;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n    }\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        Socket socket = new Socket(host, port);\n        return new IRCClientConnection(socket, new StethoReporter());\n    }\n\n    public String read() throws IOException {\n        String message = mInput.readLine();\n        if (message != null) {\n            mReporter.reportIncomingMessage(message);\n            if (maybeHandleIncomingMessage(message)) {\n                return null;\n            }\n            return message;\n        }\n        return null;\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.reportOutgoingMessage(message);\n        mOutput.write(message);\n        mOutput.newLine();\n        mOutput.flush();\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) {\n        if (message.startsWith(\"PING \")) {\n            String pingTarget = message.substring(5).trim();\n            send(\"PONG \" + pingTarget);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void close() throws IOException {\n        mReporter.reportConnectionClosed();\n        mInput.close();\n        mOutput.close();\n        mSocket.close();\n    }\n\n    public class StethoReporter {\n        public void reportIncomingMessage(String message) {\n            // Implementation for reporting incoming messages to Stetho\n        }\n\n        public void reportOutgoingMessage(String message) {\n            // Implementation for reporting outgoing messages to Stetho\n        }\n\n        public void reportConnectionClosed() {\n            // Implementation for reporting connection closure to Stetho\n        }\n    }\n}"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch data from a given URL and process the response as a JSON object.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests. It uses Android's AsyncTask to perform network operations in the background and processes the response data.\n\nAttributes: None (This is a utility class with static methods and nested classes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, reads the response, and publishes the progress for JSON processing.\n\nMethod2: ConvertInputToStringNoChange(InputStream inputStream) -> String - A static helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.\n\nMethod Details:\n\nMyAsyncTaskgetNews:\n- Input Parameters: String... params (varargs where params[0] should be the URL string)\n- Return Type: String (though it primarily works through side effects)\n- Description: \n  1. Creates a URL object from the input string\n  2. Opens an HttpURLConnection with a 7-second timeout\n  3. Reads the input stream and converts it to a string\n  4. Publishes the result for JSON processing in onProgressUpdate\n  5. Disconnects the connection when done\n\nConvertInputToStringNoChange:\n- Input Parameters: InputStream inputStream (the stream to read from)\n- Return Type: String (the concatenated content of the stream)\n- Description:\n  1. Creates a BufferedReader from the InputStream\n  2. Reads all lines and concatenates them into a single string\n  3. Closes the input stream\n  4. Returns the concatenated string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n            } catch (Exception ex) {}\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                URL obj = new URL(url);\n                HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setConnectTimeout(7000);\n                con.setReadTimeout(7000);\n                int responseCode = con.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = con.getInputStream();\n                    String result = ConvertInputToStringNoChange(inputStream);\n                    publishProgress(result);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            super.onProgressUpdate(values);\n            // Process JSON here or pass to another method\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n            // Handle post-execution tasks\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] buffer = new byte[1];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            if (buffer[0] == 0x04) {\n                break;\n            }\n            destination.write(buffer[0]);\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) inputStream.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n        try {\n            if (outputStream != null) outputStream.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n        try {\n            if (socket != null) socket.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n    }\n}"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public void communicateWithService(EurekaClient eurekaClient) {\n    try {\n        InstanceInfo instance = eurekaClient.getNextServerFromEureka(\"sampleservice.mydomain.net\", false);\n        if (instance == null) {\n            System.err.println(\"No instance found for service\");\n            return;\n        }\n\n        String host = instance.getHostName();\n        int port = instance.getPort();\n        String request = \"Request at \" + new java.util.Date();\n\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            out.println(request);\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n        }\n    } catch (Exception e) {\n        System.err.println(\"Error communicating with service: \" + e.getMessage());\n        e.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        Socket client = null;\n        try {\n            client = new Socket(host, port);\n            OutputStream out = client.getOutputStream();\n            out.write((command + \"\\n\").getBytes());\n            out.flush();\n            return response(client);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"Error: \" + e.getMessage();\n        } finally {\n            cleanup(client);\n        }\n    }\n\n    private String response(Socket client) {\n        StringBuilder response = new StringBuilder();\n        try {\n            InputStream in = client.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return response.toString();\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // Handle exception silently\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class HTTPRequest extends HTTPPacket {\n    protected Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        postSocket = new Socket(host, port);\n        OutputStream out = postSocket.getOutputStream();\n        PrintWriter writer = new PrintWriter(out, true);\n        StringBuilder request = new StringBuilder(\"POST / HTTP/1.1\\r\\n\");\n        request.append(\"Host: \").append(host).append(\"\\r\\n\");\n        request.append(\"Connection: \").append(isKeepAlive ? \"keep-alive\" : \"close\").append(\"\\r\\n\");\n        request.append(\"Content-Length: 0\\r\\n\");\n        request.append(\"Transfer-Encoding: chunked\\r\\n\");\n        request.append(\"\\r\\n\");\n        writer.print(request.toString());\n\n        InputStream in = postSocket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String statusLine = reader.readLine();\n        String[] statusParts = statusLine.split(\" \");\n        int statusCode = Integer.parseInt(statusParts[1]);\n        String reasonPhrase = statusParts[2];\n        HTTPResponse response = new HTTPResponse(statusCode, reasonPhrase);\n\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.isEmpty()) {\n                break;\n            }\n            String[] headerParts = line.split(\": \", 2);\n            if (headerParts.length == 2) {\n                response.addHeader(headerParts[0], headerParts[1]);\n            }\n        }\n\n        if (response.getHeader(\"Transfer-Encoding\") != null && response.getHeader(\"Transfer-Encoding\").equals(\"chunked\")) {\n            handleChunkedResponse(reader, response);\n        } else {\n            handleContentLengthResponse(reader, response);\n        }\n\n        if (!isKeepAlive) {\n            postSocket.close();\n        }\n\n        return response;\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n\n    private void handleChunkedResponse(BufferedReader reader, HTTPResponse response) throws IOException {\n        String chunkSizeLine;\n        while ((chunkSizeLine = reader.readLine()) != null) {\n            if (chunkSizeLine.isEmpty()) {\n                continue;\n            }\n            int chunkSize = Integer.parseInt(chunkSizeLine, 16);\n            if (chunkSize == 0) {\n                break;\n            }\n            char[] buffer = new char[chunkSize];\n            reader.read(buffer, 0, chunkSize);\n            response.appendBody(new String(buffer));\n            reader.readLine(); // Read the trailing CRLF\n        }\n    }\n\n    private void handleContentLengthResponse(BufferedReader reader, HTTPResponse response) throws IOException {\n        int contentLength = Integer.parseInt(response.getHeader(\"Content-Length\"));\n        char[] buffer = new char[contentLength];\n        reader.read(buffer, 0, contentLength);\n        response.appendBody(new String(buffer));\n    }\n}"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n            \n            new Thread(() -> {\n                String serverMessage;\n                try {\n                    while ((serverMessage = mBufferedReader.readLine()) != null) {\n                        System.out.println(\"Received: \" + serverMessage);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mBufferedReader != null) mBufferedReader.close();\n            if (mPrintWriter != null) mPrintWriter.close();\n            if (mClientSocket != null) mClientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class Networker {\n    private static Networker sInstance;\n    private Executor sExecutor;\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    private Networker() {\n        sExecutor = Executors.newCachedThreadPool();\n    }\n\n    public static Networker get() {\n        if (sInstance == null) {\n            sInstance = new Networker();\n        }\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private final HttpRequest request;\n        private final Callback callback;\n\n        public HttpRequestTask(HttpRequest request, Callback callback) {\n            this.request = request;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            HttpResponse response;\n            try {\n                response = doFetch();\n                callback.onResponse(response);\n            } catch (IOException e) {\n                callback.onFailure(e);\n            }\n        }\n\n        private HttpResponse doFetch() throws IOException {\n            HttpURLConnection conn = configureAndConnectRequest();\n            requestDecompression(conn);\n            InputStream in = conn.getInputStream();\n            byte[] body = new byte[conn.getContentLength()];\n            copy(in, new ByteArrayInputStream(body), new byte[1024]);\n            return new HttpResponse(conn.getResponseCode(), body);\n        }\n\n        private HttpURLConnection configureAndConnectRequest() throws IOException {\n            HttpURLConnection conn = (HttpURLConnection) new URL(request.getUrl()).openConnection();\n            conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n            conn.setReadTimeout(READ_TIMEOUT_MS);\n            conn.setRequestMethod(request.getMethod().name());\n            if (request.getBody() != null) {\n                conn.setDoOutput(true);\n                conn.getOutputStream().write(request.getBody());\n            }\n            return conn;\n        }\n\n        private void requestDecompression(HttpURLConnection conn) {\n            conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n        }\n\n        private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n            if (\"gzip\".equals(conn.getContentEncoding())) {\n                return new GZIPInputStream(in);\n            }\n            return in;\n        }\n\n        private void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n            int n;\n            while ((n = in.read(buf)) != -1) {\n                out.write(buf, 0, n);\n            }\n        }\n    }\n\n    public static class HttpRequest {\n        private String url;\n        private HttpMethod method;\n        private byte[] body;\n\n        private HttpRequest(Builder b) {\n            this.url = b.url;\n            this.method = b.method;\n            this.body = b.body;\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        public static class Builder {\n            private String url;\n            private HttpMethod method;\n            private byte[] body;\n\n            public Builder friendlyName(String friendlyName) {\n                // Implementation for friendly name\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                this.method = method;\n                return this;\n            }\n\n            public Builder url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                this.body = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public static class HttpResponse {\n        private int statusCode;\n        private byte[] body;\n\n        public HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n        void onFailure(IOException e);\n    }\n\n    public enum HttpMethod {\n        GET, POST, PUT, DELETE\n    }\n}"
  },
  {
    "Task_id": 580,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data, and receives a response.\n\nFunction Description: The function `showText` establishes a TCP connection to a specified server using the provided IP address and port. It sends a sequence of bytes (`seq`) to the server and reads the response. The response is parsed into a `BxResp` object. The function handles connection timeouts and IO exceptions.\n\nInput:\n- `ip`: [String] - The IP address of the server to connect to.\n- `port`: [Integer] - The port number of the server to connect to.\n- `contents`: [List<String>] - A list of strings representing the data to be sent (Note: The reference code uses `seq` for sending data, but `contents` is not directly used in the provided snippet. Clarification may be needed on how `contents` maps to `seq`).\n\nOutput:\n- The function does not explicitly return a value but processes the server's response into a `BxResp` object. If an error occurs, it prints the stack trace.\n\nNote: The reference code snippet references a variable `seq` that is not defined in the provided code. Ensure `seq` is properly initialized from `contents` or another source before calling `out.write(seq)`.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\n\npublic static void showText(String ip, Integer port, List<String> contents) throws Exception {\n    // Create Socket\n    Socket client = new Socket();\n    // Create socket address\n    SocketAddress address = new InetSocketAddress(ip, port);\n    \n    try {\n        // Establish TCP connection\n        client.connect(address, 3000);\n        // Set read timeout\n        client.setSoTimeout(3000);\n        \n        // Create output stream\n        OutputStream out = client.getOutputStream();\n        // Create input stream\n        InputStream in = client.getInputStream();\n        \n        // Write data\n        out.write(seq);\n        \n        // Read response\n        byte[] resp = new byte[1024];\n        int len = in.read(resp);\n        \n        // Parse response\n        BxResp bxResp = BxResp.parse(resp, len);\n        \n        // Close resources\n        out.close();\n        in.close();\n        client.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class TcpClient {\n    public static void showText(String ip, int port, List<String> contents) {\n        Socket socket = null;\n        try {\n            socket = new Socket();\n            socket.connect(new InetSocketAddress(ip, port), 5000);\n            OutputStream out = socket.getOutputStream();\n            byte[] seq = String.join(\"\", contents).getBytes();\n            out.write(seq);\n            out.flush();\n\n            InputStream in = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            if (bytesRead > 0) {\n                String response = new String(buffer, 0, bytesRead);\n                BxResp resp = parseResponse(response);\n                // Process the BxResp object as needed\n            }\n        } catch (SocketTimeoutException e) {\n            System.err.println(\"Connection timed out: \" + e.getMessage());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static BxResp parseResponse(String response) {\n        // Implementation to parse the response into a BxResp object\n        return new BxResp();\n    }\n\n    static class BxResp {\n        // Fields and methods for the BxResp class\n    }\n}"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private final Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws IOException {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n    }\n\n    public void receive(Message msg) {\n        System.out.println(\"Received message of type: \" + msg.getType());\n    }\n\n    public static Message readMessage(byte[] buf, int offset, int length) {\n        if (buf.length < offset + length) {\n            return null;\n        }\n        // Deserialize message from byte array\n        // This is a placeholder for actual deserialization logic\n        return new Message(\"DummyType\");\n    }\n\n    private class Acceptor extends Thread {\n        public void run() {\n            while (true) {\n                try {\n                    Socket clientSocket = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n                    handleRequest(in);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleRequest(DataInputStream in) {\n            byte[] buffer = new byte[1024];\n            try {\n                int bytesRead = in.read(buffer);\n                Message msg = readMessage(buffer, 0, bytesRead);\n                receive(msg);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static class Message {\n        private String type;\n\n        public Message(String type) {\n            this.type = type;\n        }\n\n        public String getType() {\n            return type;\n        }\n    }\n}"
  },
  {
    "Task_id": 582,
    "Instruction": "Task Description: Create a TCP client class that establishes and maintains a persistent connection to a server, handles communication, and automatically reconnects on failure.\n\nClass Description: The `tcpConnection` class is an AsyncTask implementation that manages TCP socket communication in Android. It establishes a persistent connection to a specified server, handles bidirectional communication, and implements automatic reconnection logic when the connection is lost.\n\nAttributes:\n- activity: [Activity] - Reference to the calling Android activity for UI thread operations  \n- context: [Context] - Android context for system operations  \n- TAG: [String] - Logging tag identifier  \n- out: [OutputStream] - Static output stream for sending data to the server  \n\nMethods:\n- tcpConnection([Activity activity], [Context context]) -> [void] - Constructor that initializes the activity and context references  \n- doInBackground([String... strings]) -> [Void] - AsyncTask method that handles the socket connection and communication in the background  \n  - strings[0]: Server IP address  \n  - strings[1]: Server port number  \n  - Returns: null (Void)  \n  - Description:  \n    1. Continuously attempts to establish socket connection with timeout  \n    2. Sets up input/output streams upon successful connection  \n    3. Sends device information as initial message  \n    4. Listens for incoming commands in a loop  \n    5. Handles reconnection automatically on failures  \n    6. Closes connection on \"exit\" command",
    "Canonical_solution": "import android.app.Activity;\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\n\npublic class tcpConnection extends AsyncTask<String,Void,Void> {\n\n    private Activity activity;\n    private Context context;\n    private static String TAG = \"tcpConnectionClass\";\n    public static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        Socket socket = null;\n        try {\n            while(true){\n                Log.d(TAG,\"trying\");\n                socket = new Socket();\n                try{\n                    socket.connect(new InetSocketAddress(strings[0], Integer.parseInt(strings[1])),3000);\n                }catch (SocketTimeoutException | SocketException e){\n                    Log.d(TAG,\"error\");\n                    activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n                }\n                if(socket.isConnected()){\n                    Log.d(TAG,\"done\");\n                    break;\n                }\n            }\n            out = new DataOutputStream(socket.getOutputStream());\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String model = android.os.Build.MODEL+\"\\n\";\n            String welcomeMess = \"Hello there, welcome to reverse shell of \"+model;\n            out.write(welcomeMess.getBytes(\"UTF-8\"));\n            \n            String line;\n            while ((line = in.readLine()) != null) {\n                Log.d(TAG, line);\n                if (line.equals(\"exit\")) {\n                    socket.close();\n                    return null;\n                }\n                out.write(\"Unknown Command \\n\".getBytes(\"UTF-8\"));\n            }\n        } catch (Exception e) {\n            activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n            e.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class tcpConnection extends AsyncTask<String, Void, Void> {\n    private Activity activity;\n    private Context context;\n    private static final String TAG = \"TCPConnection\";\n    private static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        String serverIP = strings[0];\n        int serverPort = Integer.parseInt(strings[1]);\n\n        while (!isCancelled()) {\n            try {\n                Socket socket = new Socket();\n                socket.connect(new InetSocketAddress(serverIP, serverPort), 5000);\n                out = socket.getOutputStream();\n                InputStream in = socket.getInputStream();\n\n                // Send initial device information\n                String deviceInfo = \"DeviceInfo: Android\";\n                out.write(deviceInfo.getBytes());\n                out.flush();\n\n                // Listen for incoming commands\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    String command = new String(buffer, 0, bytesRead);\n                    if (command.trim().equalsIgnoreCase(\"exit\")) {\n                        break;\n                    }\n                    // Handle command on UI thread\n                    activity.runOnUiThread(() -> {\n                        // Process command here\n                    });\n                }\n\n                in.close();\n                out = null;\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Connection failed: \" + e.getMessage());\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException ie) {\n                    Log.e(TAG, \"Sleep interrupted: \" + ie.getMessage());\n                }\n            }\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 583,
    "Instruction": "Task Description: Create a Java class that handles network forwarding for both TCP and UDP protocols, managing connections and data transmission between clients and servers.\n\nClass Description: The NetworkForwarder class is responsible for forwarding network data to a specified destination server using either TCP or UDP protocols. It maintains UDP connections through a DatagramSocket and manages multiple TCP connections using a mapping of source addresses to Socket instances. The class provides methods for forwarding data and disconnecting specific TCP connections.\n\nAttributes:\n- LOGGER: Logger - Used for logging warnings and errors\n- destination: InetAddress - The destination address for forwarded data\n- connectionUdp: DatagramSocket - The UDP socket used for datagram communication\n- connectionsTcp: Map<InetSocketAddress, Socket> - A mapping of source addresses to their corresponding TCP Socket connections\n\nMethods:\n- NetworkForwarder(Config config) -> void - Constructor that initializes the destination address and UDP socket using configuration parameters\n- forward(InetSocketAddress source, int port, boolean datagram, byte[] data) -> void - Forwards data to the destination server using either TCP or UDP protocol based on the datagram parameter\n- disconnect(InetSocketAddress source) -> void - Closes and removes the TCP connection associated with the specified source address",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport jakarta.inject.Inject;\nimport jakarta.inject.Singleton;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Singleton\npublic class NetworkForwarder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NetworkForwarder.class);\n\n    private final InetAddress destination;\n    private final DatagramSocket connectionUdp;\n    private final Map<InetSocketAddress, Socket> connectionsTcp = new HashMap<>();\n\n    @Inject\n    public NetworkForwarder(Config config) throws IOException {\n        destination = InetAddress.getByName(config.getString(Keys.SERVER_FORWARD));\n        connectionUdp = new DatagramSocket();\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        try {\n            if (datagram) {\n                connectionUdp.send(new DatagramPacket(data, data.length, destination, port));\n            } else {\n                Socket connectionTcp = connectionsTcp.get(source);\n                if (connectionTcp == null || connectionTcp.isClosed()) {\n                    connectionTcp = new Socket(destination, port);\n                    connectionsTcp.put(source, connectionTcp);\n                }\n                connectionTcp.getOutputStream().write(data);\n            }\n        } catch (IOException e) {\n            LOGGER.warn(\"Network forwarding error\", e);\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket connectionTcp = connectionsTcp.remove(source);\n        if (connectionTcp != null) {\n            try {\n                connectionTcp.close();\n            } catch (IOException e) {\n                LOGGER.warn(\"Connection close error\", e);\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.IOException;\nimport java.net.*;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NetworkForwarder {\n    private static final Logger LOGGER = LoggerFactory.getLogger(NetworkForwarder.class);\n    private final InetAddress destination;\n    private final DatagramSocket connectionUdp;\n    private final Map<InetSocketAddress, Socket> connectionsTcp = new ConcurrentHashMap<>();\n\n    public NetworkForwarder(Config config) throws IOException {\n        this.destination = InetAddress.getByName(config.getDestinationHost());\n        this.connectionUdp = new DatagramSocket(config.getUdpPort());\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        if (datagram) {\n            try {\n                DatagramPacket packet = new DatagramPacket(data, data.length, destination, port);\n                connectionUdp.send(packet);\n            } catch (IOException e) {\n                LOGGER.warn(\"Failed to send UDP packet: {}\", e.getMessage());\n            }\n        } else {\n            Socket socket = connectionsTcp.computeIfAbsent(source, k -> {\n                try {\n                    return new Socket();\n                } catch (IOException e) {\n                    LOGGER.error(\"Failed to create TCP socket for {}: {}\", source, e.getMessage());\n                    return null;\n                }\n            });\n            if (socket != null) {\n                try {\n                    socket.getOutputStream().write(data);\n                } catch (IOException e) {\n                    LOGGER.warn(\"Failed to send TCP data: {}\", e.getMessage());\n                    disconnect(source);\n                }\n            }\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket socket = connectionsTcp.remove(source);\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                LOGGER.warn(\"Failed to close TCP socket for {}: {}\", source, e.getMessage());\n            }\n        }\n    }\n\n    public static class Config {\n        private String destinationHost;\n        private int udpPort;\n\n        public String getDestinationHost() {\n            return destinationHost;\n        }\n\n        public void setDestinationHost(String destinationHost) {\n            this.destinationHost = destinationHost;\n        }\n\n        public int getUdpPort() {\n            return udpPort;\n        }\n\n        public void setUdpPort(int udpPort) {\n            this.udpPort = udpPort;\n        }\n    }\n}"
  },
  {
    "Task_id": 585,
    "Instruction": "Task Description: Create a class that handles both Bluetooth and TCP socket communication for a Pebble device, allowing data transmission and reception through either protocol based on the device address format.\n\nClass Description: The PebbleIoThread class manages connections and data transfer to a Pebble device using either Bluetooth or TCP sockets. It automatically detects the protocol based on the device address format (TCP if address contains one colon, Bluetooth if multiple colons).\n\nAttributes:\n- mIsTCP: [boolean] - Flag indicating whether TCP mode is active\n- mBtAdapter: [BluetoothAdapter] - Android Bluetooth adapter instance\n- mBtSocket: [BluetoothSocket] - Bluetooth socket for communication\n- mTCPSocket: [Socket] - TCP socket for communication\n- mInStream: [InputStream] - Input stream for receiving data\n- mOutStream: [OutputStream] - Output stream for sending data\n- mContext: [Context] - Android application context\n- gbDevice: [GBDevice] - Device information object\n\nMethods:\n- connect(): [boolean] - Establishes connection with the device (returns true if successful)\n  Input: None\n  Output: boolean - Connection success status\n  \n- write_real(byte[] bytes): [void] - Sends data to the connected device with protocol-specific framing\n  Input: byte[] - Data bytes to send\n  Output: None\n  \n- quit(): [void] - Closes all active connections and releases resources\n  Input: None\n  Output: None",
    "Canonical_solution": "import android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothSocket;\nimport android.content.Context;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.UUID;\n\nclass PebbleIoThread {\n\n    private boolean mIsTCP = false;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    PebbleIoThread(Context context, GBDevice device, BluetoothAdapter btAdapter) {\n        mContext = context;\n        gbDevice = device;\n        mBtAdapter = btAdapter;\n    }\n\n    protected boolean connect() {\n        String deviceAddress = gbDevice.getAddress();\n        try {\n            int firstColon = deviceAddress.indexOf(\":\");\n            if (firstColon == deviceAddress.lastIndexOf(\":\")) {\n                mIsTCP = true;\n                InetAddress serverAddr = InetAddress.getByName(deviceAddress.substring(0, firstColon));\n                mTCPSocket = new Socket(serverAddr, Integer.parseInt(deviceAddress.substring(firstColon + 1)));\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n            } else {\n                mIsTCP = false;\n                BluetoothDevice btDevice = mBtAdapter.getRemoteDevice(deviceAddress);\n                final UUID UuidSDP = UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\");\n                mBtSocket = btDevice.createRfcommSocketToServiceRecord(UuidSDP);\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n            }\n            return true;\n        } catch (IOException e) {\n            mInStream = null;\n            mOutStream = null;\n            mBtSocket = null;\n            return false;\n        }\n    }\n\n    private void write_real(byte[] bytes) {\n        try {\n            if (mIsTCP) {\n                ByteBuffer buf = ByteBuffer.allocate(bytes.length + 8);\n                buf.order(ByteOrder.BIG_ENDIAN);\n                buf.putShort((short) 0xfeed);\n                buf.putShort((short) 1);\n                buf.putShort((short) bytes.length);\n                buf.put(bytes);\n                buf.putShort((short) 0xbeef);\n                mOutStream.write(buf.array());\n                mOutStream.flush();\n            } else {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            }\n        } catch (IOException e) {\n            // Error handling\n        }\n    }\n\n    public void quit() {\n        if (mBtSocket != null) {\n            try {\n                mBtSocket.close();\n            } catch (IOException ignored) {\n            }\n            mBtSocket = null;\n        }\n        if (mTCPSocket != null) {\n            try {\n                mTCPSocket.close();\n            } catch (IOException ignored) {\n            }\n            mTCPSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class PebbleIoThread extends Thread {\n    private boolean mIsTCP;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    public PebbleIoThread(Context context, GBDevice device) {\n        mContext = context;\n        gbDevice = device;\n        String address = device.getAddress();\n        mIsTCP = address.contains(\":\") && !address.contains(\":\" + \":\");\n        if (mIsTCP) {\n            try {\n                mTCPSocket = new Socket();\n                mTCPSocket.connect(new InetSocketAddress(address, 12345), 5000);\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            mBtAdapter = BluetoothManager.from(mContext).getAdapter();\n            try {\n                mBtSocket = mBtAdapter.getRemoteDevice(address).createRfcommSocketToServiceRecord(UUID.fromString(\"0000110A-0000-1000-8000-00805F9B34FB\"));\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public boolean connect() {\n        if (mIsTCP) {\n            return mTCPSocket != null && mTCPSocket.isConnected();\n        } else {\n            return mBtSocket != null && mBtSocket.isConnected();\n        }\n    }\n\n    public void write_real(byte[] bytes) {\n        if (mIsTCP) {\n            try {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            try {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void quit() {\n        try {\n            if (mIsTCP) {\n                mInStream.close();\n                mOutStream.close();\n                mTCPSocket.close();\n            } else {\n                mInStream.close();\n                mOutStream.close();\n                mBtSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class QmpClient {\n    public static final String TAG = \"QmpClient\";\n    private String requestCommandMode = \"qmp_capabilities\";\n    private boolean external = false;\n    private Socket socket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void setExternal(boolean value) {\n        this.external = value;\n    }\n\n    public String sendCommand(String command) {\n        try {\n            if (!isConnected()) {\n                connect();\n            }\n            sendRequest(out, command);\n            return getResponse(in);\n        } catch (IOException e) {\n            System.err.println(TAG + \": Error sending command: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private boolean isConnected() {\n        return socket != null && !socket.isClosed();\n    }\n\n    private void connect() throws IOException {\n        if (external) {\n            socket = new Socket(\"localhost\", 4444);\n        } else {\n            socket = new Socket(Paths.get(\"/tmp/qemu-monitor-sock\").toFile());\n        }\n        out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        sendRequest(out, requestCommandMode);\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n    }\n\n    private String getResponse(BufferedReader in) {\n        StringBuilder response = new StringBuilder();\n        String line;\n        try {\n            while ((line = in.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n                if (line.contains(\"}\")) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(TAG + \": Error reading response: \" + e.getMessage());\n        }\n        return response.toString();\n    }\n\n    public void close() {\n        try {\n            if (in != null) in.close();\n            if (out != null) out.close();\n            if (socket != null) socket.close();\n        } catch (IOException e) {\n            System.err.println(TAG + \": Error closing connection: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 587,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that enables message exchange between a client and server, supporting both sending and receiving of messages with proper resource management.\n\nClass Description: UnicastTestTcp is a class that establishes TCP connections for unicast communication between two endpoints. It acts as both a client (connecting to a remote server) and a server (accepting connections from remote clients). The class handles message serialization/deserialization and provides thread-safe operations for sending messages.\n\nAttributes:\n- local: InetSocketAddress - The local address and port for server socket binding\n- remote: InetSocketAddress - The remote address and port for client connection\n- sock: Socket - The client socket for outgoing connections\n- output: DataOutputStream - The output stream for sending data to the remote endpoint\n- output_lock: Lock - A reentrant lock for thread-safe output operations\n- srv_sock: ServerSocket - The server socket for accepting incoming connections\n- acceptor: Acceptor - A thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up both server and client sockets. Throws Exception if initialization fails.\n- writeMessage(Message msg, DataOutputStream out) -> static void - Serializes and writes a message to the output stream. Throws Exception if writing fails.\n- readMessage(DataInput in) -> static Message - Reads and deserializes a message from the input stream. Throws Exception if reading fails.\n- receive(Message msg) -> void - Processes received messages based on their type (START or DATA)\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Continuously accepts new connections and processes incoming messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from an established connection. Throws Exception if processing fails.",
    "Canonical_solution": "import org.jgroups.*;\nimport org.jgroups.stack.IpAddress;\nimport org.jgroups.util.DefaultSocketFactory;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    protected InetSocketAddress local, remote;\n    protected Socket sock;\n    protected DataOutputStream output;\n    protected final Lock output_lock = new ReentrantLock();\n    protected ServerSocket srv_sock;\n    protected Acceptor acceptor;\n\n    protected static final boolean TCP_NODELAY = false;\n    protected static final int SOCK_SEND_BUF_SIZE = 200 * 1000;\n    protected static final int SOCK_RECV_BUF_SIZE = 200 * 1000;\n    protected static final byte START = 1;\n    protected static final byte DATA = 2;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(),\n                                         local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected static final void writeMessage(final Message msg, DataOutputStream out) throws Exception {\n        byte flags = 0;\n        if(msg.getDest() == null)\n            flags += (byte)2;\n        out.writeShort(Version.version);\n        out.writeByte(flags);\n        msg.writeTo(out);\n    }\n\n    protected static final Message readMessage(DataInput in) throws Exception {\n        short ver = in.readShort();\n        byte flags = in.readByte();\n        Message msg = new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    protected class Acceptor extends Thread {\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in = new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    public void receive(Message msg) {\n        byte[] buf = msg.getArray();\n        byte type = buf[msg.getOffset()];\n\n        switch(type) {\n            case START:\n                ByteBuffer tmp = ByteBuffer.wrap(buf, 1+msg.getOffset(), Global.LONG_SIZE);\n                int num_msgs = (int)tmp.getLong();\n                System.out.println(\"Received START message with \" + num_msgs + \" messages\");\n                break;\n            case DATA:\n                System.out.println(\"Received DATA message\");\n                break;\n            default:\n                System.err.println(\"Type \" + type + \" is invalid\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private Lock output_lock;\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n        output_lock = new ReentrantLock();\n        acceptor = new Acceptor();\n        acceptor.start();\n    }\n\n    public static void writeMessage(Message msg, DataOutputStream out) throws IOException {\n        out.writeInt(msg.getType());\n        out.writeInt(msg.getLength());\n        out.write(msg.getData(), 0, msg.getLength());\n    }\n\n    public static Message readMessage(DataInputStream in) throws IOException {\n        int type = in.readInt();\n        int length = in.readInt();\n        byte[] data = new byte[length];\n        in.readFully(data);\n        return new Message(type, data);\n    }\n\n    public void receive(Message msg) {\n        switch (msg.getType()) {\n            case Message.START:\n                // Handle START message\n                break;\n            case Message.DATA:\n                // Handle DATA message\n                break;\n        }\n    }\n\n    private class Acceptor extends Thread {\n        public void run() {\n            while (true) {\n                try {\n                    Socket clientSock = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(clientSock.getInputStream());\n                    handleRequest(in);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handleRequest(DataInputStream in) throws IOException {\n            Message msg;\n            while ((msg = readMessage(in)) != null) {\n                receive(msg);\n            }\n        }\n    }\n}\n\nclass Message {\n    public static final int START = 1;\n    public static final int DATA = 2;\n\n    private int type;\n    private byte[] data;\n\n    public Message(int type, byte[] data) {\n        this.type = type;\n        this.data = data;\n    }\n\n    public int getType() {\n        return type;\n    }\n\n    public int getLength() {\n        return data.length;\n    }\n\n    public byte[] getData() {\n        return data;\n    }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class UrlTemplateResource {\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() {\n        try {\n            InputStream inputStream = inputStream();\n            if (characterEncoding != null) {\n                return new InputStreamReader(inputStream, characterEncoding);\n            } else {\n                return new InputStreamReader(inputStream);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error creating reader for URL: \" + url, e);\n        }\n    }\n\n    protected InputStream inputStream() {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return connection.getInputStream();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error opening input stream for URL: \" + url, e);\n        }\n    }\n\n    public boolean exists() {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import static org.junit.Assert.*;\nimport org.junit.Test;\nimport java.io.*;\nimport java.net.*;\n\npublic class ServletTest {\n\n    @Test\n    public void testServletInputStreamEarlyClose() throws Exception {\n        DefaultServer server = new DefaultServer(8080);\n        server.start();\n        server.deployServlet(\"/test\", new EarlyCloseClientServlet());\n\n        Socket socket = new Socket(\"localhost\", 8080);\n        OutputStream out = socket.getOutputStream();\n        PrintWriter writer = new PrintWriter(out, true);\n\n        String request = \"POST /test HTTP/1.1\\r\\n\" +\n                         \"Host: localhost:8080\\r\\n\" +\n                         \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                         \"Content-Length: 1000000\\r\\n\" +\n                         \"\\r\\n\" +\n                         \"data=largebody\";\n\n        writer.print(request);\n        socket.close(); // Close the socket immediately\n\n        // Verify that the servlet detected the premature closure\n        assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n    }\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        this.boundary = delimiter + new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date()) + \"_\" + System.currentTimeMillis();\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        URL obj = new URL(url);\n        con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setDoInput(true);\n\n        String param = \"imgName=\" + imgName;\n        os = con.getOutputStream();\n        os.write(param.getBytes());\n        os.flush();\n\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            InputStream is = con.getInputStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = is.read(buffer)) != -1) {\n                baos.write(buffer, 0, length);\n            }\n            return baos.toByteArray();\n        } else {\n            throw new IOException(\"Failed to download image. Response code: \" + responseCode);\n        }\n    }\n\n    public void connectForMultipart() throws IOException {\n        URL obj = new URL(url);\n        con = (HttpURLConnection) obj.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write((delimiter + boundary + \"--\\r\\n\").getBytes());\n        os.flush();\n    }\n\n    public String getResponse() throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return response.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n}"
  },
  {
    "Task_id": 609,
    "Instruction": "Task Description: Implement a UDP client function that sends a message to a server and waits for a response.\n\nFunction Description: The function establishes a UDP connection, sends a predefined message (\"hello world\") to a specified server (localhost on port 9876), waits for a response, prints the server's reply, and then closes the connection. This demonstrates basic UDP client-server communication.\n\nInput: None (The target address and port are hardcoded as \"localhost\" and 9876 respectively)\n\nOutput: None (The function prints the server's response to the console but doesn't return any value)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\n\nprivate void sendWifiInfoToClient() throws Exception {\n    DatagramSocket clientSocket = new DatagramSocket();\n    InetAddress IPAddress = InetAddress.getByName(\"localhost\");\n    byte[] sendData = new byte[1024];\n    byte[] receiveData = new byte[1024];\n    String sentence = \"hello world\";\n    sendData = sentence.getBytes();\n    DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 9876);\n    clientSocket.send(sendPacket);\n    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n    clientSocket.receive(receivePacket);\n    String modifiedSentence = new String(receivePacket.getData());\n    System.out.println(\"FROM SERVER:\" + modifiedSentence);\n    clientSocket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```python\nimport socket\n\ndef udp_client():\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_address = ('localhost', 9876)\n    message = \"hello world\"\n    client_socket.sendto(message.encode(), server_address)\n    response, server = client_socket.recvfrom(4096)\n    print(response.decode())\n    client_socket.close()\n```"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n    public static class Error {\n        public int responseCode;\n        public String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{responseCode=\" + responseCode + \", output='\" + output + \"'}\";\n        }\n    }\n\n    public static String post(String request) throws IOException {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        return handleResponse(connection, null);\n    }\n\n    public static String get(String request) throws IOException {\n        return get(request, null, 5000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n\n        return handleResponse(connection, callback);\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws IOException {\n        int responseCode = connection.getResponseCode();\n        BufferedReader reader;\n\n        if (responseCode >= 200 && responseCode < 300) {\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n        }\n\n        StringBuilder response = new StringBuilder();\n        String line;\n\n        while ((line = reader.readLine()) != null) {\n            if (callback != null) {\n                callback.onLineRead(line);\n            }\n            response.append(line).append(\"\\n\");\n        }\n\n        reader.close();\n\n        if (responseCode >= 200 && responseCode < 300) {\n            return response.toString();\n        } else {\n            throw new IOException(new Error(responseCode, response.toString()));\n        }\n    }\n}"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class UrlChecker {\n    public static boolean isUrlAccessible(String url) {\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            return responseCode == 200;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpFeedbackClient {\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://example.com/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n\n            String params = \"content=\" + URLEncoder.encode(content, StandardCharsets.UTF_8.toString()) +\n                    \"&env=\" + URLEncoder.encode(env, StandardCharsets.UTF_8.toString());\n\n            try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n                wr.writeBytes(params);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new IOException(\"Server returned HTTP code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection to make GET requests and handle responses.\n\nClass Description: The HttpClient class provides functionality to send HTTP GET requests to a specified URL and retrieve the response. It handles connection timeouts, sets appropriate request headers, and processes the response stream.\n\nAttributes: None\n\nMethods:\n- request: [Name](String url) -> String - Sends a GET request to the specified URL and returns the response body as a string. Sets connection timeout to 3 seconds, read timeout to 90 seconds, and configures appropriate request headers including content type and character encoding. Returns null if the request fails or response code is not 200.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n\n    public String request(String url) {\n        HttpURLConnection connection = null;\n        BufferedReader reader = null;\n        try {\n            URL getUrl = new URL(url);\n            connection = (HttpURLConnection) getUrl.openConnection();\n            connection.setReadTimeout(90000);\n            connection.setConnectTimeout(3000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            \n            if (200 == connection.getResponseCode()) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    public String request(String url) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setConnectTimeout(3000);\n            con.setReadTimeout(90000);\n            con.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n\n            int responseCode = con.getResponseCode();\n            if (responseCode != 200) {\n                return null;\n            }\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            return response.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class PreloadTask implements Runnable {\n    private final String mRawUrl;\n    private final int mPosition;\n    private final HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled = false;\n    private boolean mIsExecuted = false;\n    private static final List<String> blackList = new ArrayList<>();\n\n    public PreloadTask(String rawUrl, int position, HttpProxyCacheServer cacheServer) {\n        mRawUrl = rawUrl;\n        mPosition = position;\n        mCacheServer = cacheServer;\n    }\n\n    @Override\n    public void run() {\n        if (mIsCanceled) return;\n        start();\n    }\n\n    private void start() {\n        mIsExecuted = true;\n        try {\n            String proxiedUrl = mCacheServer.getProxiedUrl(mRawUrl);\n            URL url = new URL(proxiedUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n\n            if (connection.getResponseCode() == 200) {\n                InputStream inputStream = connection.getInputStream();\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    if (mIsCanceled) {\n                        inputStream.close();\n                        return;\n                    }\n                }\n                inputStream.close();\n            } else {\n                blackList.add(mRawUrl);\n            }\n        } catch (IOException e) {\n            blackList.add(mRawUrl);\n        } finally {\n            mIsExecuted = false;\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        mIsCanceled = true;\n        if (mIsExecuted) {\n            // Assuming there's a way to interrupt the ongoing task\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public static List<String> getBlackList() {\n        return blackList;\n    }\n}"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, specifically designed for Android applications to fetch and process JSON data from a server.\n\nClass Description: HttpRequestHandler is a utility class containing an inner AsyncTask subclass (MyAsyncTaskgetNews) that performs HTTP GET requests in the background. It handles connection setup, timeout configuration, input stream processing, and JSON response parsing. The class demonstrates typical operations for user authentication flows.\n\nAttributes:\n- None (All required objects are created locally within methods)\n\nMethods:\n- MyAsyncTaskgetNews: [Inner Class] - Extends AsyncTask<String, String, String> to perform network operations off the UI thread\n  - doInBackground(String... params) -> String - Main execution method that:\n    1. Takes URL string as input parameter\n    2. Establishes HTTP connection with 7-second timeout\n    3. Reads input stream and converts to string\n    4. Publishes progress with response data\n    5. Returns null (results handled via progress updates)\n  \n  - onProgressUpdate(String... progress) -> void - UI thread callback that:\n    1. Parses JSON response\n    2. Handles \"user is added\" case by showing toast and initiating login\n    3. Processes successful login by saving user credentials\n    4. Handles errors via logging\n\nNote: The class assumes existence of helper classes (Operations for stream conversion, SaveSettings for persistence) and Android context availability via getApplicationContext().",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(getApplicationContext());\n                    NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                if (json.getString(\"msg\") == null)\n                    return;\n                if (json.getString(\"msg\").equalsIgnoreCase(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), json.getString(\"msg\"), Toast.LENGTH_LONG).show();\n                    String url = \"http://10.0.2.2/~hussienalrubaye/twitterserver/login.php?email=\" + etEmail.getText().toString() + \"&password=\" + etPassword.getText().toString();\n                    new MyAsyncTaskgetNews().execute(url);\n                }\n\n                if (json.getString(\"msg\").equalsIgnoreCase(\"Pass Login\")) {\n                    JSONArray UserInfo = new JSONArray(json.getString(\"info\"));\n                    JSONObject UserCreintal = UserInfo.getJSONObject(0);\n                    hideProgressDialog();\n                    SaveSettings saveSettings = new SaveSettings(getApplicationContext());\n                    saveSettings.SaveData(UserCreintal.getString(\"user_id\"));\n                    finish();\n                }\n            } catch (Exception ex) {\n                Log.d(\"er\", ex.getMessage());\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\r\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\r\n        @Override\r\n        protected String doInBackground(String... params) {\r\n            String url = params[0];\r\n            HttpURLConnection urlConnection = null;\r\n            try {\r\n                URL requestUrl = new URL(url);\r\n                urlConnection = (HttpURLConnection) requestUrl.openConnection();\r\n                urlConnection.setRequestMethod(\"GET\");\r\n                urlConnection.setConnectTimeout(7000);\r\n                urlConnection.setReadTimeout(7000);\r\n                urlConnection.connect();\r\n\r\n                if (urlConnection.getResponseCode() == 200) {\r\n                    InputStream inputStream = urlConnection.getInputStream();\r\n                    String response = Operations.convertStreamToString(inputStream);\r\n                    publishProgress(response);\r\n                } else {\r\n                    publishProgress(\"Error: \" + urlConnection.getResponseMessage());\r\n                }\r\n            } catch (Exception e) {\r\n                publishProgress(\"Exception: \" + e.getMessage());\r\n            } finally {\r\n                if (urlConnection != null) {\r\n                    urlConnection.disconnect();\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        protected void onProgressUpdate(String... progress) {\r\n            super.onProgressUpdate(progress);\r\n            String response = progress[0];\r\n            try {\r\n                JSONObject jsonResponse = new JSONObject(response);\r\n                if (jsonResponse.has(\"status\") && jsonResponse.getString(\"status\").equals(\"user is added\")) {\r\n                    Toast.makeText(getApplicationContext(), \"User added successfully\", Toast.LENGTH_SHORT).show();\r\n                    // Initiate login flow\r\n                } else if (jsonResponse.has(\"token\")) {\r\n                    String token = jsonResponse.getString(\"token\");\r\n                    String username = jsonResponse.getString(\"username\");\r\n                    SaveSettings.saveUserCredentials(getApplicationContext(), username, token);\r\n                }\r\n            } catch (JSONException e) {\r\n                Log.e(\"HttpRequestHandler\", \"JSON parsing error: \" + e.getMessage());\r\n            }\r\n        }\r\n    }\r\n}"
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a utility class for making HTTP POST requests with configurable timeouts and form data submission capabilities.\n\nClass Description: TinyIdHttpUtils is a utility class that provides static methods for performing HTTP POST requests. It handles connection management, timeout configuration, form data encoding, and response reading. The class is designed to be thread-safe and includes proper resource cleanup.\n\nAttributes:\n- logger: Logger - Used for logging errors and warnings during HTTP operations\n\nMethods:\n- post(String url, Integer readTimeout, Integer connectTimeout) -> String - Makes a POST request to the specified URL with given timeout values\n- post(String url, Map<String,String> form, Integer readTimeout, Integer connectTimeout) -> String - Makes a POST request with form data to the specified URL with given timeout values",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class TinyIdHttpUtils {\n\n    private static final Logger logger = Logger.getLogger(TinyIdHttpUtils.class.getName());\n\n    private TinyIdHttpUtils() {\n    }\n\n    public static String post(String url, Integer readTimeout, Integer connectTimeout) {\n        return post(url, null, readTimeout, connectTimeout);\n    }\n\n    public static String post(String url, Map<String, String> form, Integer readTimeout, Integer connectTimeout) {\n        HttpURLConnection conn = null;\n        OutputStreamWriter os = null;\n        BufferedReader rd = null;\n        StringBuilder param = new StringBuilder();\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        String response = null;\n        if (form != null) {\n            for (Map.Entry<String, String> entry : form.entrySet()) {\n                String key = entry.getKey();\n                if (param.length() != 0) {\n                    param.append(\"&\");\n                }\n                param.append(key).append(\"=\").append(entry.getValue());\n            }\n        }\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setReadTimeout(readTimeout);\n            conn.setConnectTimeout(connectTimeout);\n            conn.setUseCaches(false);\n            conn.connect();\n            os = new OutputStreamWriter(conn.getOutputStream(), \"UTF-8\");\n            os.write(param.toString());\n            os.flush();\n            rd = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"UTF-8\"));\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            response = sb.toString();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"error post url:\" + url + param, e);\n        } finally {\n            try {\n                if (os != null) {\n                    os.close();\n                }\n                if (rd != null) {\n                    rd.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (IOException e) {\n                logger.log(Level.WARNING, \"error close conn\", e);\n            }\n        }\n        return response;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\npublic class TinyIdHttpUtils {\n    private static final Logger logger = Logger.getLogger(TinyIdHttpUtils.class.getName());\n\n    public static String post(String url, Integer readTimeout, Integer connectTimeout) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setConnectTimeout(connectTimeout != null ? connectTimeout : 5000);\n            con.setReadTimeout(readTimeout != null ? readTimeout : 5000);\n            con.setDoOutput(true);\n\n            try (OutputStream os = con.getOutputStream()) {\n                os.flush();\n            }\n\n            int responseCode = con.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                logger.warning(\"Server returned non-OK status: \" + responseCode);\n                return \"\";\n            }\n        } catch (IOException e) {\n            logger.severe(\"IOException during POST request: \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    public static String post(String url, Map<String, String> form, Integer readTimeout, Integer connectTimeout) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setConnectTimeout(connectTimeout != null ? connectTimeout : 5000);\n            con.setReadTimeout(readTimeout != null ? readTimeout : 5000);\n            con.setDoOutput(true);\n\n            StringBuilder postData = new StringBuilder();\n            for (Map.Entry<String, String> param : form.entrySet()) {\n                if (postData.length() != 0) {\n                    postData.append('&');\n                }\n                postData.append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8.toString()));\n                postData.append('=');\n                postData.append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8.toString()));\n            }\n\n            byte[] postDataBytes = postData.toString().getBytes(StandardCharsets.UTF_8);\n            try (OutputStream os = con.getOutputStream()) {\n                os.write(postDataBytes);\n                os.flush();\n            }\n\n            int responseCode = con.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                logger.warning(\"Server returned non-OK status: \" + responseCode);\n                return \"\";\n            }\n        } catch (IOException e) {\n            logger.severe(\"IOException during POST request with form data: \" + e.getMessage());\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests with support for both GET and POST methods, handling parameters, headers, and SSL configurations.\n\nClass Description: SimpleHttpUtils is a utility class that provides methods to perform HTTP requests (GET/POST) with configurable parameters, headers, timeouts, and SSL settings. It handles URL encoding, parameter serialization, and response processing.\n\nAttributes:\n- logger: Log - Logger instance for logging messages\n- DEFAULT_CHARSET: String - Default character encoding (utf-8)\n- HTTP_METHOD_POST: String - Constant for POST method\n- HTTP_METHOD_GET: String - Constant for GET method\n- HTTP_ERROR_MESSAGE: String - Key for error messages\n- DEFAULT_READ_TIMEOUT: int - Default read timeout in milliseconds\n- DEFAULT_CONNECT_TIMEOUT: int - Default connection timeout in milliseconds\n- HTTP_PREFIX: String - HTTP URL prefix\n- HTTPS_PREFIX: String - HTTPS URL prefix\n- MAX_FETCHSIZE: int - Maximum fetch size limit\n- trustAnyManagers: TrustManager[] - Array of trust managers for SSL\n\nMethods:\n- httpPost(String url, Map params) -> String - Makes an HTTP POST request to the specified URL with given parameters\n- httpGet(String url, Map params) -> String - Makes an HTTP GET request to the specified URL with given parameters\n- httpRequest(String url, Map<String,String> params, String method, String charSet, Map<String,String> headers) -> String - Makes an HTTP request with configurable method, charset and headers\n- httpRequest(SimpleHttpParam httpParam) -> SimpleHttpResult - Makes an HTTP request with comprehensive configuration options\n- mapToQueryString(Map parameters, String charSet) -> String - Converts a parameter map to a URL-encoded query string\n- urlEncode(String url, String charSet) -> String - URL-encodes a given string\n- setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) -> void - Configures SSL settings for the connection\n- makeStringList(Object value) -> List<String> - Converts an input value to a list of strings\n\nNested Classes:\n- TrustAnyTrustManager: Implements X509TrustManager for custom SSL certificate handling\n- TrustAnyHostnameVerifier: Implements HostnameVerifier for custom hostname verification",
    "Canonical_solution": "import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 20000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 5000;\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    static {\n        System.setProperty(\"sun.net.inetaddr.ttl\", \"3600\");\n    }\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String,String> params, String method,\n                                    String charSet, Map<String,String> headers) {\n        SimpleHttpParam param = new SimpleHttpParam(url);\n        if(null != param){\n            param.setParameters(params);\n        }\n        if(null != headers){\n            param.setHeaders(headers);\n        }\n        param.setCharSet(charSet);\n        param.setMethod(method);\n        SimpleHttpResult result = httpRequest(param);\n        if(result==null || !result.isSuccess()){\n            return null;\n        }else{\n            return result.getContent();\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String,Object> parameters = httpParam.getParameters();\n        String sMethod = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        boolean sslVerify = httpParam.isSslVerify();\n        int maxResultSize = httpParam.getMaxResultSize();\n        Map<String,Object> headers = httpParam.getHeaders();\n        int readTimeout = httpParam.getReadTimeout();\n        int connectTimeout = httpParam.getConnectTimeout();\n        boolean ignoreContentIfUnsuccess = httpParam.isIgnoreContentIfUnsuccess();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n        \n        if (url == null || url.trim().length() == 0) {\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        if(maxResultSize<=0){\n            throw new IllegalArgumentException(\"maxResultSize must be positive : \"+maxResultSize);\n        }\n        Charset.forName(charSet);\n        HttpURLConnection urlConn = null;\n        URL destURL = null;\n        \n        String baseUrl = url.trim();\n        if (!baseUrl.toLowerCase().startsWith(HTTPS_PREFIX) && !baseUrl.toLowerCase().startsWith(HTTP_PREFIX)) {\n            baseUrl = HTTP_PREFIX + baseUrl;\n        }\n\n        String method = null;\n        if (sMethod != null) {\n            method = sMethod.toUpperCase();\n        }\n        if (method == null\n                || !(method.equals(HTTP_METHOD_POST) || method\n                        .equals(HTTP_METHOD_GET))) {\n            throw new IllegalArgumentException(\"invalid http method : \"\n                    + method);\n        }\n        \n        int index = baseUrl.indexOf(\"?\");\n        if (index>0){\n            baseUrl = urlEncode(baseUrl, charSet);\n        }else if(index==0){\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        \n        String queryString = mapToQueryString(parameters, charSet);\n        String targetUrl = \"\";\n        if (method.equals(HTTP_METHOD_POST)) {\n            targetUrl = baseUrl;\n        } else {\n            if(index>0){\n                targetUrl = baseUrl +\"&\" + queryString;\n            }else{\n                targetUrl = baseUrl +\"?\" + queryString;\n            }\n        }\n        try {\n            destURL = new URL(targetUrl);\n            urlConn = (HttpURLConnection)destURL.openConnection();\n            \n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n               \n            \n            boolean hasContentType = false;\n            boolean hasUserAgent = false;\n            for(String key : headers.keySet()){\n                if(\"Content-Type\".equalsIgnoreCase(key)){\n                    hasContentType = true;\n                }\n                if(\"user-agent\".equalsIgnoreCase(key)){\n                    hasUserAgent = true;\n                }\n            }\n            if(!hasContentType){\n                headers.put(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n            }\n            if(!hasUserAgent){\n                headers.put(\"user-agent\", \"PlatSystem\");\n            }\n            \n            if(headers!=null && !headers.isEmpty()){\n                for(Entry<String, Object> entry : headers.entrySet()){\n                    String key = entry.getKey();\n                    Object value = entry.getValue();\n                    List<String> values = makeStringList(value);\n                    for(String v : values){\n                        urlConn.addRequestProperty(key, v);\n                    }\n                }\n            }\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setAllowUserInteraction(false);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            \n            \n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postData = queryString.length()==0?httpParam.getPostData():queryString;\n                if(postData!=null && postData.trim().length()>0){\n                    OutputStream os = urlConn.getOutputStream();\n                    OutputStreamWriter osw = new OutputStreamWriter(os, charSet);\n                    osw.write(postData);\n                    osw.flush();\n                    osw.close();\n                }\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            Map<String, List<String>> responseHeaders = urlConn.getHeaderFields();\n            String contentType = urlConn.getContentType();\n                \n            SimpleHttpResult result = new SimpleHttpResult(responseCode);\n            result.setHeaders(responseHeaders);\n            result.setContentType(contentType);\n            \n            if(responseCode!=200 && ignoreContentIfUnsuccess){\n                return result;\n            }\n            \n            InputStream is = urlConn.getInputStream();\n            byte[] temp = new byte[1024];\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int readBytes = is.read(temp);\n            while(readBytes>0){\n                baos.write(temp, 0, readBytes);\n                readBytes =  is.read(temp);\n            }\n            String resultString = new String(baos.toByteArray(), charSet);\n            baos.close();\n            result.setContent(resultString);\n            return result;\n        } catch (Exception e) {\n            logger.warn(\"connection error : \" + e.getMessage());\n            return new SimpleHttpResult(e);\n        } finally {\n            if (urlConn != null) {\n                urlConn.disconnect();\n            }\n        }\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n    \n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.netssl.X509TrustManager;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = new Log();\n    private static final String DEFAULT_CHARSET = \"utf-8\";\n    private static final String HTTP_METHOD_POST = \"POST\";\n    private static final String HTTP_METHOD_GET = \"GET\";\n    private static final String HTTP_ERROR_MESSAGE = \"errorMessage\";\n    private static final int DEFAULT_READ_TIMEOUT = 10000;\n    private static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    private static final String HTTP_PREFIX = \"http://\";\n    private static final String HTTPS_PREFIX = \"https://\";\n    private static final int MAX_FETCHSIZE = 1024 * 1024 * 10;\n    private static TrustManager[] trustAnyManagers;\n\n    static {\n        try {\n            trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n        } catch (Exception e) {\n            logger.error(\"Failed to initialize trust managers\", e);\n        }\n    }\n\n    public static String httpPost(String url, Map<String, Object> params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map<String, Object> params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String, String> params, String method, String charSet, Map<String, String> headers) {\n        try {\n            HttpURLConnection connection = createConnection(url, method, charSet, headers);\n            if (method.equals(HTTP_METHOD_POST)) {\n                String queryString = mapToQueryString(params, charSet);\n                byte[] postData = queryString.getBytes(charSet);\n                connection.setDoOutput(true);\n                connection.setRequestProperty(\"Content-Length\", Integer.toString(postData.length));\n                try (OutputStream os = connection.getOutputStream()) {\n                    os.write(postData);\n                }\n            }\n            return readResponse(connection);\n        } catch (Exception e) {\n            logger.error(\"HTTP request failed: \" + url, e);\n            return null;\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        try {\n            HttpURLConnection connection = createConnection(httpParam.getUrl(), httpParam.getMethod(), httpParam.getCharSet(), httpParam.getHeaders());\n            if (httpParam.getMethod().equals(HTTP_METHOD_POST)) {\n                String queryString = mapToQueryString(httpParam.getParams(), httpParam.getCharSet());\n                byte[] postData = queryString.getBytes(httpParam.getCharSet());\n                connection.setDoOutput(true);\n                connection.setRequestProperty(\"Content-Length\", Integer.toString(postData.length));\n                try (OutputStream os = connection.getOutputStream()) {\n                    os.write(postData);\n                }\n            }\n            return new SimpleHttpResult(readResponse(connection), connection.getResponseCode(), connection.getHeaderFields());\n        } catch (Exception e) {\n            logger.error(\"HTTP request failed: \" + httpParam.getUrl(), e);\n            return new SimpleHttpResult(null, -1, null);\n        }\n    }\n\n    private static HttpURLConnection createConnection(String url, String method, String charSet, Map<String, String> headers) throws IOException {\n        URL obj = new URL(url);\n        HttpURLConnection connection;\n        if (url.startsWith(HTTPS_PREFIX)) {\n            connection = (HttpsURLConnection) obj.openConnection();\n            setSSLSocketFactory((HttpsURLConnection) connection, true, true, null, null);\n        } else {\n            connection = (HttpURLConnection) obj.openConnection();\n        }\n        connection.setRequestMethod(method);\n        connection.setConnectTimeout(DEFAULT_CONNECT_TIMEOUT);\n        connection.setReadTimeout(DEFAULT_READ_TIMEOUT);\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        connection.setRequestProperty(\"Accept-Charset\", charSet);\n        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        return connection;\n    }\n\n    private static String readResponse(HttpURLConnection connection) throws IOException {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n        } catch (IOException e) {\n            logger.warn(\"Error reading response from server\", e);\n            try (BufferedReader errorStream = new BufferedReader(new InputStreamReader(connection.getErrorStream()))) {\n                String line;\n                while ((line = errorStream.readLine()) != null) {\n                    response.append(line);\n                }\n            }\n        }\n        return response.toString();\n    }\n\n    public static String mapToQueryString(Map<String, Object> parameters, String charSet) {\n        if (parameters == null || parameters.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder queryString = new StringBuilder();\n        for (Map.Entry<String, Object> entry : parameters.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            List<String> values = makeStringList(value);\n            for (String val : values) {\n                if (queryString.length() > 0) {\n                    queryString.append(\"&\");\n                }\n                try {\n                    queryString.append(URLEncoder.encode(key, charSet));\n                    queryString.append(\"=\");\n                    queryString.append(URLEncoder.encode(val, charSet));\n                } catch (Exception e) {\n                    logger.error(\"URL encoding failed for key: \" + key + \", value: \" + val, e);\n                }\n            }\n        }\n        return queryString.toString();\n    }\n\n    public static String urlEncode(String url, String charSet) {\n        try {\n            return URLEncoder.encode(url, charSet);\n        } catch (Exception e) {\n            logger.error(\"URL encoding failed for URL: \" + url, e);\n            return url;\n        }\n    }\n\n    public static void setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) {\n        if (urlConn instanceof HttpsURLConnection) {\n            try {\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                TrustManager[] trustManagers = trustAnyManagers;\n                if (trustKeyStore != null) {\n                    KeyStore trustStore = trustKeyStore.getKeyStore();\n                    trustManagers = new TrustManager[]{new TrustAnyTrustManager(trustStore)};\n                }\n                sslContext.init(clientKeyStore != null ? clientKeyStore.getKeyManagers() : null, trustManagers, null);\n                ((HttpsURLConnection) urlConn).setSSLSocketFactory(sslContext.getSocketFactory());\n                if (hostnameVerify) {\n                    ((HttpsURLConnection) urlConn).setHostnameVerifier(new TrustAnyHostnameVerifier());\n                } else {\n                    ((HttpsURLConnection) urlConn).setHostnameVerifier((hostname, session) -> true);\n                }\n            } catch (Exception e) {\n                logger.error(\"Failed to configure SSL settings\", e);\n            }\n        }\n    }\n\n    public static List<String> makeStringList(Object value) {\n        if (value == null) {\n            return new ArrayList<>();\n        }\n        if (value instanceof List<?>) {\n            return new ArrayList<>((List<String>) value);\n        }\n        return List.of(value.toString());\n    }\n\n    public static class TrustAnyTrustManager implements X509TrustManager {\n        private final KeyStore trustStore;\n\n        public TrustAnyTrustManager() {\n            this.trustStore = null;\n        }\n\n        public TrustAnyTrustManager(KeyStore trustStore) {\n            this.trustStore = trustStore;\n        }\n\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            // Do nothing\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            // Do nothing\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n\n    public static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n\n    public static class SimpleHttpParam {\n        private String url;\n        private String method;\n        private String charSet;\n        private Map<String, Object> params;\n        private Map<String, String> headers;\n\n        public SimpleHttpParam(String url, String method, String charSet, Map<String, Object> params, Map<String, String> headers) {\n            this.url = url;\n            this.method = method;\n            this.charSet = charSet;\n            this.params = params;\n            this.headers = headers;\n        }\n\n        public String getUrl() {\n            return url;\n        }\n\n        public String getMethod() {\n            return method;\n        }\n\n        public String getCharSet() {\n            return charSet;\n        }\n\n        public Map<String, Object> getParams() {\n            return params;\n        }\n\n        public Map<String, String> getHeaders() {\n            return headers;\n        }\n    }\n\n    public static class SimpleHttpResult {\n        private String content;\n        private int code;\n        private Map<String, List<String>> headers;\n\n        public SimpleHttpResult(String content, int code, Map<String, List<String>> headers) {\n            this.content = content;\n            this.code = code;\n            this.headers = headers;\n        }\n\n        public String getContent() {\n            return content;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public Map<String, List<String>> getHeaders() {\n            return headers;\n        }\n    }\n\n    public static class TrustKeyStore {\n        private KeyStore keyStore;\n\n        public TrustKeyStore(KeyStore keyStore) {\n            this.keyStore = keyStore;\n        }\n\n        public KeyStore getKeyStore() {\n            return keyStore;\n        }\n    }\n\n    public static class ClientKeyStore {\n        private KeyStore keyStore;\n\n        public ClientKeyStore(KeyStore keyStore) {\n            this.keyStore = keyStore;\n        }\n\n        public KeyStore getKeyStore() {\n            return keyStore;\n        }\n\n        public KeyManager[] getKeyManagers() throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {\n            return KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())\n                    .init(keyStore, null)\n                    .getKeyManagers();\n        }\n    }\n\n    public static class Log {\n        public void error(String message, Exception e) {\n            System.err.println(message);\n            e.printStackTrace();\n        }\n\n        public void warn(String message, Exception e) {\n            System.err.println(message);\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a Java utility class for making asynchronous HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable headers and parameters. The class should handle response processing and error handling through callbacks.\n\nClass Description: HttpURLConnectionUtils is a final utility class that provides static methods for performing asynchronous HTTP requests. It encapsulates the complexity of HttpURLConnection and provides a simple callback-based interface for handling responses and errors.\n\nAttributes:\n\nTIMEOUT_IN_MILLIONS: int - The connection and read timeout duration in milliseconds (default: 5000)\n\nMethods:\n\ndoGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous HTTP GET request to the specified URL and invokes the callback with the response or error.\n\ndoPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous HTTP POST request to the specified URL with the given parameters and invokes the callback with the response or error.\n\nrequest(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic for both GET and POST methods, including setting headers, writing parameters, and processing the response.\n\nCallback: interface - Defines two methods for handling request outcomes:\n  onResponse(String result, long response) -> void - Called when the request succeeds\n  onFail(Throwable error) -> void - Called when the request fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(\n            final String urlStr,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(\n            final String urlStr,\n            final String params,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n\n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public final class HttpURLConnectionUtils {\n    public static final int TIMEOUT_IN_MILLIS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long responseCode);\n        void onFail(Throwable error);\n    }\n\n    private HttpURLConnectionUtils() {}\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method);\n                conn.setConnectTimeout(TIMEOUT_IN_MILLIS);\n                conn.setReadTimeout(TIMEOUT_IN_MILLIS);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        conn.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (\"POST\".equalsIgnoreCase(method) && params != null) {\n                    conn.setDoOutput(true);\n                    try (OutputStream os = conn.getOutputStream()) {\n                        os.write(params.getBytes());\n                    }\n                }\n\n                int responseCode = conn.getResponseCode();\n                StringBuilder response = new StringBuilder();\n                try (BufferedReader br = new BufferedReader(new InputStreamReader(\n                        conn.getInputStream()))) {\n                    String line;\n                    while ((line = br.readLine()) != null) {\n                        response.append(line);\n                    }\n                } catch (IOException e) {\n                    try (BufferedReader br = new BufferedReader(new InputStreamReader(\n                            conn.getErrorStream()))) {\n                        String line;\n                        while ((line = br.readLine()) != null) {\n                            response.append(line);\n                        }\n                    }\n                }\n\n                callback.onResponse(response.toString(), responseCode);\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n}"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n    public static final Map<Long, Integer> XSTS_ERRORS = new HashMap<>();\n\n    static {\n        XSTS_ERRORS.put(2148982273L, 1001);\n        XSTS_ERRORS.put(2148982274L, 1002);\n        XSTS_ERRORS.put(2148982275L, 1003);\n        XSTS_ERRORS.put(2148982276L, 1004);\n        XSTS_ERRORS.put(2148982277L, 1005);\n        XSTS_ERRORS.put(2148982278L, 1006);\n        XSTS_ERRORS.put(2148982279L, 1007);\n        XSTS_ERRORS.put(2148982280L, 1008);\n        XSTS_ERRORS.put(2148982281L, 1009);\n        XSTS_ERRORS.put(2148982282L, 1010);\n        XSTS_ERRORS.put(2148982283L, 1011);\n        XSTS_ERRORS.put(2148982284L, 1012);\n        XSTS_ERRORS.put(2148982285L, 1013);\n        XSTS_ERRORS.put(2148982286L, 1014);\n        XSTS_ERRORS.put(2148982287L, 1015);\n        XSTS_ERRORS.put(2148982288L, 1016);\n        XSTS_ERRORS.put(2148982289L, 1017);\n        XSTS_ERRORS.put(2148982290L, 1018);\n        XSTS_ERRORS.put(2148982291L, 1019);\n        XSTS_ERRORS.put(2148982292L, 1020);\n        XSTS_ERRORS.put(2148982293L, 1021);\n        XSTS_ERRORS.put(2148982294L, 1022);\n        XSTS_ERRORS.put(2148982295L, 1023);\n        XSTS_ERRORS.put(2148982296L, 1024);\n        XSTS_ERRORS.put(2148982297L, 1025);\n        XSTS_ERRORS.put(2148982298L, 1026);\n        XSTS_ERRORS.put(2148982299L, 1027);\n        XSTS_ERRORS.put(2148982300L, 1028);\n        XSTS_ERRORS.put(2148982301L, 1029);\n        XSTS_ERRORS.put(2148982302L, 1030);\n        XSTS_ERRORS.put(2148982303L, 1031);\n        XSTS_ERRORS.put(2148982304L, 1032);\n        XSTS_ERRORS.put(2148982305L, 1033);\n        XSTS_ERRORS.put(2148982306L, 1034);\n        XSTS_ERRORS.put(2148982307L, 1035);\n        XSTS_ERRORS.put(2148982308L, 1036);\n        XSTS_ERRORS.put(2148982309L, 1037);\n        XSTS_ERRORS.put(2148982310L, 1038);\n        XSTS_ERRORS.put(2148982311L, 1039);\n        XSTS_ERRORS.put(2148982312L, 1040);\n        XSTS_ERRORS.put(2148982313L, 1041);\n        XSTS_ERRORS.put(2148982314L, 1042);\n        XSTS_ERRORS.put(2148982315L, 1043);\n        XSTS_ERRORS.put(2148982316L, 1044);\n        XSTS_ERRORS.put(2148982317L, 1045);\n        XSTS_ERRORS.put(2148982318L, 1046);\n        XSTS_ERRORS.put(2148982319L, 1047);\n        XSTS_ERRORS.put(2148982320L, 1048);\n        XSTS_ERRORS.put(2148982321L, 1049);\n        XSTS_ERRORS.put(2148982322L, 1050);\n        XSTS_ERRORS.put(2148982323L, 1051);\n        XSTS_ERRORS.put(2148982324L, 1052);\n        XSTS_ERRORS.put(2148982325L, 1053);\n        XSTS_ERRORS.put(2148982326L, 1054);\n        XSTS_ERRORS.put(2148982327L, 1055);\n        XSTS_ERRORS.put(2148982328L, 1056);\n        XSTS_ERRORS.put(2148982329L, 1057);\n        XSTS_ERRORS.put(2148982330L, 1058);\n        XSTS_ERRORS.put(2148982331L, 1059);\n        XSTS_ERRORS.put(2148982332L, 1060);\n        XSTS_ERRORS.put(2148982333L, 1061);\n        XSTS_ERRORS.put(2148982334L, 1062);\n        XSTS_ERRORS.put(2148982335L, 1063);\n        XSTS_ERRORS.put(2148982336L, 1064);\n        XSTS_ERRORS.put(2148982337L, 1065);\n        XSTS_ERRORS.put(2148982338L, 1066);\n        XSTS_ERRORS.put(2148982339L, 1067);\n        XSTS_ERRORS.put(2148982340L, 1068);\n        XSTS_ERRORS.put(2148982341L, 1069);\n        XSTS_ERRORS.put(2148982342L, 1070);\n        XSTS_ERRORS.put(2148982343L, 1071);\n        XSTS_ERRORS.put(2148982344L, 1072);\n        XSTS_ERRORS.put(2148982345L, 1073);\n        XSTS_ERRORS.put(2148982346L, 1074);\n        XSTS_ERRORS.put(2148982347L, 1075);\n        XSTS_ERRORS.put(2148982348L, 1076);\n        XSTS_ERRORS.put(2148982349L, 1077);\n        XSTS_ERRORS.put(2148982350L, 1078);\n        XSTS_ERRORS.put(2148982351L, 1079);\n        XSTS_ERRORS.put(2148982352L, 1080);\n        XSTS_ERRORS.put(2148982353L, 1081);\n        XSTS_ERRORS.put(2148982354L, 1082);\n        XSTS_ERRORS.put(2148982355L, 1083);\n        XSTS_ERRORS.put(2148982356L, 1084);\n        XSTS_ERRORS.put(2148982357L, 1085);\n        XSTS_ERRORS.put(2148982358L, 1086);\n        XSTS_ERRORS.put(2148982359L, 1087);\n        XSTS_ERRORS.put(2148982360L, 1088);\n        XSTS_ERRORS.put(2148982361L, 1089);\n        XSTS_ERRORS.put(2148982362L, 1090);\n        XSTS_ERRORS.put(2148982363L, 1091);\n        XSTS_ERRORS.put(2148982364L, 1092);\n        XSTS_ERRORS.put(2148982365L, 1093);\n        XSTS_ERRORS.put(2148982366L, 1094);\n        XSTS_ERRORS.put(2148982367L, 1095);\n        XSTS_ERRORS.put(2148982368L, 1096);\n        XSTS_ERRORS.put(2148982369L, 1097);\n        XSTS_ERRORS.put(2148982370L, 1098);\n        XSTS_ERRORS.put(2148982371L, 1099);\n        XSTS_ERRORS.put(2148982372L, 1100);\n        XSTS_ERRORS.put(2148982373L, 1101);\n        XSTS_ERRORS.put(2148982374L, 1102);\n        XSTS_ERRORS.put(2148982375L, 1103);\n        XSTS_ERRORS.put(2148982376L, 1104);\n        XSTS_ERRORS.put(2148982377L, 1105);\n        XSTS_ERRORS.put(2148982378L, 1106);\n        XSTS_ERRORS.put(2148982379L, 1107);\n        XSTS_ERRORS.put(2148982380L, 1108);\n        XSTS_ERRORS.put(2148982381L, 1109);\n        XSTS_ERRORS.put(2148982382L, 1110);\n        XSTS_ERRORS.put(2148982383L, 1111);\n        XSTS_ERRORS.put(2148982384L, 1112);\n        XSTS_ERRORS.put(2148982385L, 1113);\n        XSTS_ERRORS.put(2148982386L, 1114);\n        XSTS_ERRORS.put(2148982387L, 1115);\n        XSTS_ERRORS.put(2148982388L, 1116);\n        XSTS_ERRORS.put(2148982389L, 1117);\n        XSTS_ERRORS.put(2148982390L, 1118);\n        XSTS_ERRORS.put(2148982391L, 1119);\n        XSTS_ERRORS.put(2148982392L, 1120);\n        XSTS_ERRORS.put(2148982393L, 1121);\n        XSTS_ERRORS.put(2148982394L, 1122);\n        XSTS_ERRORS.put(2148982395L, 1123);\n        XSTS_ERRORS.put(2148982396L, 1124);\n        XSTS_ERRORS.put(2148982397L, 1125);\n        XSTS_ERRORS.put(2148982398L, 1126);\n        XSTS_ERRORS.put(2148982399L, 1127);\n        XSTS_ERRORS.put(2148982400L, 1128);\n        XSTS_ERRORS.put(2148982401L, 1129);\n        XSTS_ERRORS.put(2148982402L, 1130);\n        XSTS_ERRORS.put(2148982403L, 1131);\n        XSTS_ERRORS.put(2148982404L, 1132);\n        XSTS_ERRORS.put(2148982405L, 1133);\n        XSTS_ERRORS.put(2148982406L, 1134);\n        XSTS_ERRORS.put(2148982407L, 1135);\n        XSTS_ERRORS.put(2148982408L, 1136);\n        XSTS_ERRORS.put(2148982409L, 1137);\n        XSTS_ERRORS.put(2148982410L, 1138);\n        XSTS_ERRORS.put(2148982411L, 1139);\n        XSTS_ERRORS.put(2148982412L, 1140);\n        XSTS_ERRORS.put(2148982413L, 1141);\n        XSTS_ERRORS.put(2148982414L, 1142);\n        XSTS_ERRORS.put(2148982415L, 1143);\n        XSTS_ERRORS.put(2148982416L, 1144);\n        XSTS_ERRORS.put(2148982417L, 1145);\n        XSTS_ERRORS.put(2148982418L, 1146);\n        XSTS_ERRORS.put(2148982419L, 1147);\n        XSTS_ERRORS.put(2148982420L, 1148);\n        XSTS_ERRORS.put(2148982421L, 1149);\n        XSTS_ERRORS.put(2148982422L, 1150);\n        XSTS_ERRORS.put(2148982423L, 1151);\n        XSTS_ERRORS.put(2148982424L, 1152);\n        XSTS_ERRORS.put(2148982425L, 1153);\n        XSTS_ERRORS.put(2148982426L, 1154);\n        XSTS_ERRORS.put(2148982427L, 1155);\n        XSTS_ERRORS.put(2148982428L, 1156);\n        XSTS_ERRORS.put(2148982429L, 1157);\n        XSTS_ERRORS.put(2148982430L, 1158);\n        XSTS_ERRORS.put(2148982431L, 1159);\n        XSTS_ERRORS.put(2148982432L, 1160);\n        XSTS_ERRORS.put(2148982433L, 1161);\n        XSTS_ERRORS.put(2148982434L, 1162);\n        XSTS_ERRORS.put(2148982435L, 1163);\n        XSTS_ERRORS.put(2148982436L, 1164);\n        XSTS_ERRORS.put(2148982437L, 1165);\n        XSTS_ERRORS.put(2148982438L, 1166);\n        XSTS_ERRORS.put(2148982439L, 1167);\n        XSTS_ERRORS.put(2148982440L, 1168);\n        XSTS_ERRORS.put(2148982441L, 1169);\n        XSTS_ERRORS.put(2148982442L, 1170);\n        XSTS_ERRORS.put(2148982443L, 1171);\n        XSTS_ERRORS.put(2148982444L, 1172);\n        XSTS_ERRORS.put(2148982445L, 1173);\n        XSTS_ERRORS.put(2148982446L, 1174);\n        XSTS_ERRORS.put(2148982447L, 1175);\n        XSTS_ERRORS.put(2148982448L, 1176);\n        XSTS_ERRORS.put(2148982449L, 1177);\n        XSTS_ERRORS.put(2148982450L, 1178);\n        XSTS_ERRORS.put(2148982451L, 1179);\n        XSTS_ERRORS.put(2148982452L, 1180);\n        XSTS_ERRORS.put(2148982453L, 1181);\n        XSTS_ERRORS.put(2148982454L, 1182);\n        XSTS_ERRORS.put(2148982455L, 1183);\n        XSTS_ERRORS.put(2148982456L, 1184);\n        XSTS_ERRORS.put(2148982457L, 1185);\n        XSTS_ERRORS.put(2148982458L, 1186);\n        XSTS_ERRORS.put(2148982459L, 1187);\n        XSTS_ERRORS.put(2148982460L, 1188);\n        XSTS_ERRORS.put(2148982461L, 1189);\n        XSTS_ERRORS.put(2148982462L, 1190);\n        XSTS_ERRORS.put(2148982463L, 1191);\n        XSTS_ERRORS.put(2148982464L, 1192);\n        XSTS_ERRORS.put(2148982465L, 1193);\n        XSTS_ERRORS.put(2148982466L, 1194);\n        XSTS_ERRORS.put(2148982467L, 1195);\n        XSTS_ERRORS.put(2148982468L, 1196);\n        XSTS_ERRORS.put(2148982469L, 1197);\n        XSTS_ERRORS.put(2148982470L, 1198);\n        XSTS_ERRORS.put(2148982471L, 1199);\n        XSTS_ERRORS.put(2148982472L, 1200);\n        XSTS_ERRORS.put(2148982473L, 1201);\n        XSTS_ERRORS.put(2148982474L, 1202);\n        XSTS_ERRORS.put(2148982475L, 1203);\n        XSTS_ERRORS.put(2148982476L, 1204);\n        XSTS_ERRORS.put(2148982477L, 1205);\n        XSTS_ERRORS.put(2148982478L, 1206);\n        XSTS_ERRORS.put(2148982479L, 1207);\n        XSTS_ERRORS.put(2148982480L, 1208);\n        XSTS_ERRORS.put(2148982481L, 1209);\n        XSTS_ERRORS.put(2148982482L, 1210);\n        XSTS_ERRORS.put(2148982483L, 1211);\n        XSTS_ERRORS.put(2148982484L, 1212);\n        XSTS_ERRORS.put(2148982485L, 1213);\n        XSTS_ERRORS.put(2148982486L, 1214);\n        XSTS_ERRORS.put(2148982487L, 1215);\n        XSTS_ERRORS.put(2148982488L, 1216);\n        XSTS_ERRORS.put(2148982489L, 1217);\n        XSTS_ERRORS.put(2148982490L, 1218);\n        XSTS_ERRORS.put(2148982491L, 1219);\n        XSTS_ERRORS.put(2148982492L, 1220);\n        XSTS_ERRORS.put(2148982493L, 1221);\n        XSTS_ERRORS.put(2148982494L, 1222);\n        XSTS_ERRORS.put(2148982495L, 1223);\n        XSTS_ERRORS.put(2148982496L, 1224);\n        XSTS_ERRORS.put(2148982497L, 1225);\n        XSTS_ERRORS.put(2148982498L, 1226);\n        XSTS_ERRORS.put(2148982499L, 1227);\n        XSTS_ERRORS.put(2148982500L, 1228);\n        XSTS_ERRORS.put(2148982501L, 1229);\n        XSTS_ERRORS.put(2148982502L, 1230);\n        XSTS_ERRORS.put(2148982503L, 1231);\n        XSTS_ERRORS.put(2148982504L, 1232);\n        XSTS_ERRORS.put(2148982505L, 1233);\n        XSTS_ERRORS.put(2148982506L, 1234);\n        XSTS_ERRORS.put(2148982507L, 1235);\n        XSTS_ERRORS.put(2148982508L, 1236);\n        XSTS_ERRORS.put(2148982509L, 1237);\n        XSTS_ERRORS.put(2148982510L, 1238);\n        XSTS_ERRORS.put(2148982511L, 1239);\n        XSTS_ERRORS.put(2148982512L, 1240);\n        XSTS_ERRORS.put(2148982513L, 1241);\n        XSTS_ERRORS.put(2148982514L, 1242);\n        XSTS_ERRORS.put(2148982515L, 1243);\n        XSTS_ERRORS.put(2148982516L, 1244);\n        XSTS_ERRORS.put(2148982517L, 1245);\n        XSTS_ERRORS.put(2148982518L, 1246);\n        XSTS_ERRORS.put(2148982519L, 1247);\n        XSTS_ERRORS.put(2148982520L, 1248);\n        XSTS_ERRORS.put(2148982521L, 1249);\n        XSTS_ERRORS.put(2148982522L, 1250);\n        XSTS_ERRORS.put(2148982523L, 1251);\n        XSTS_ERRORS.put(2148982524L, 1252);\n        XSTS_ERRORS.put(2148982525L, 1253);\n        XSTS_ERRORS.put(2148982526L, 1254);\n        XSTS_ERRORS.put(2148982527L, 1255);\n        XSTS_ERRORS.put(2148982528L, 1256);\n        XSTS_ERRORS.put(2148982529L, 1257);\n        XSTS_ERRORS.put(2148982530L, 1258);\n        XSTS_ERRORS.put(2148982531L, 1259);\n        XSTS_ERRORS.put(2148982532L, 1260);\n        XSTS_ERRORS.put(2148982533L, 1261);\n        XSTS_ERRORS.put(2148982534L, 1262);\n        XSTS_ERRORS.put(2148982535L, 1263);\n        XSTS_ERRORS.put(2148982536L, 1264);\n        XSTS_ERRORS.put(2148982537L, 1265);\n        XSTS_ERRORS.put(2148982538L, 1266);\n        XSTS_ERRORS.put(2148982539L, 1267);\n        XSTS_ERRORS.put(2148982540L, 1268);\n        XSTS_ERRORS.put(2148982541L, 1269);\n        XSTS_ERRORS.put(2148982542L, 1270);\n        XSTS_ERRORS.put(2148982543L, 1271);\n        XSTS_ERRORS.put(2148982544L, 1272);\n        XSTS_ERRORS.put(2148982545L, 1273);\n        XSTS_ERRORS.put(2148982546L, 1274);\n        XSTS_ERRORS.put(2148982547L, 1275);\n        XSTS_ERRORS.put(2148982548L, 1276);\n        XSTS_ERRORS.put(2148982549L, 1277);\n        XSTS_ERRORS.put(2148982550L, 1278);\n        XSTS_ERRORS.put(2148982551L, 1279);\n        XSTS_ERRORS.put(2148982552L, 1280);\n        XSTS_ERRORS.put(2148982553L, 1281);\n        XSTS_ERRORS.put(2148982554L, 1282);\n        XSTS_ERRORS.put(2148982555L, 1283);\n        XSTS_ERRORS.put(2148982556L, 1284);\n        XSTS_ERRORS.put(2148982557L, 1285);\n        XSTS_ERRORS.put(2148982558L, 1286);\n        XSTS_ERRORS.put(2148982559L, 1287);\n        XSTS_ERRORS.put(2148982560L, 1288);\n        XSTS_ERRORS.put(2148982561L, 1289);\n        XSTS_ERRORS.put(2148982562L, 1290);\n        XSTS_ERRORS.put(2148982563L, 1291);\n        XSTS_ERRORS.put(2148982564L, 1292);\n        XSTS_ERRORS.put(2148982565L, 1293);\n        XSTS_ERRORS.put(2148982566L, 1294);\n        XSTS_ERRORS.put(2148982567L, 1295);\n        XSTS_ERRORS.put(2148982568L, 1296);\n        XSTS_ERRORS.put(2148982569L, 1297);\n        XSTS_ERRORS.put(2148982570L, 1298);\n        XSTS_ERRORS.put(2148982571L, 1299);\n        XSTS_ERRORS.put(2148982572L, 1300);\n        XSTS_ERRORS.put(2148982573L, 1301);\n        XSTS_ERRORS.put(2148982574L, 1302);\n        XSTS_ERRORS.put(2148982575L, 1303);\n        XSTS_ERRORS.put(2148982576L, 1304);\n        XSTS_ERRORS.put(2148982577L, 1305);\n        XSTS_ERRORS.put(2148982578L, 1306);\n        XSTS_ERRORS.put(2148982579L, 1307);\n        XSTS_ERRORS.put(2148982580L, 1308);\n        XSTS_ERRORS.put(2148982581L, 1309);\n        XSTS_ERRORS.put(2148982582L, 1310);\n        XSTS_ERRORS.put(2148982583L, 1311);\n        XSTS_ERRORS.put(2148982584L, 1312);\n        XSTS_ERRORS.put(2148982585L, 1313);\n        XSTS_ERRORS.put(2148982586L, 1314);\n        XSTS_ERRORS.put(2148982587L, 1315);\n        XSTS_ERRORS.put(2148982588L, 1316);\n        XSTS_ERRORS.put(2148982589L, 1317);\n        XSTS_ERRORS.put(2148982590L, 1318);\n        XSTS_ERRORS.put(2148982591L, 1319);\n        XSTS_ERRORS.put(2148982592L, 1320);\n        XSTS_ERRORS.put(2148982593L, 1321);\n        XSTS_ERRORS.put(2148982594L, 1322);\n        XSTS_ERRORS.put(2148982595L, 1323);\n        XSTS_ERRORS.put(2148982596L, 1324);\n        XSTS_ERRORS.put(2148982597L, 1325);\n        XSTS_ERRORS.put(2148982598L, 1326);\n        XSTS_ERRORS.put(2148982599L, 1327);\n        XSTS_ERRORS.put(2148982600L, 1328);\n        XSTS_ERRORS.put(2148982601L, 1329);\n        XSTS_ERRORS.put(2148982602L, 1330);\n        XSTS_ERRORS.put(2148982603L, 1331);\n        XSTS_ERRORS.put(2148982604L, 1332);\n        XSTS_ERRORS.put(2148982605L, 1333);\n        XSTS_ERRORS.put(2148982606L, 1334);\n        XSTS_ERRORS.put(2148982607L, 1335);\n        XSTS_ERRORS.put(2148982608L, 1336);\n        XSTS_ERRORS.put(2148982609L, 1337);\n        XSTS_ERRORS.put(2148982610L, 1338);\n        XSTS_ERRORS.put(2148982611L, 1339);"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HttpUtils {\n    public static String parseUrlArgs(String responseUrl, Map<String, String> jsonObject) {\n        String baseUrl = responseUrl;\n        int queryIndex = responseUrl.indexOf('?');\n        if (queryIndex != -1) {\n            baseUrl = responseUrl.substring(0, queryIndex);\n            String queryString = responseUrl.substring(queryIndex + 1);\n            String[] params = queryString.split(\"&\");\n            for (String param : params) {\n                String[] keyValue = param.split(\"=\");\n                if (keyValue.length == 2) {\n                    String key = keyValue[0];\n                    String value = keyValue[1];\n                    jsonObject.put(key, value);\n                }\n            }\n        }\n        return baseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n\n        if (content != null && !content.isEmpty()) {\n            try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {\n                wr.writeBytes(content);\n            }\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new Exception(\"Server returned HTTP \" + responseCode);\n        }\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a Java utility class for handling HTTPS network requests, including downloading content as strings or files.\n\nClass Description: NetworkUtils is a utility class that provides methods for making HTTPS requests and downloading content either as strings or files. It handles connection setup, timeout configuration, and proper resource cleanup.\n\nAttributes:\nDEBUG: [boolean] - Flag to enable debug logging\nTAG: [String] - Tag used for logging\nHTTP_READ_TIMEOUT: [int] - Timeout for reading from connection (in milliseconds)\nHTTP_CONNECTION_TIMEOUT: [int] - Timeout for establishing connection (in milliseconds)\n\nMethods:\nsetupHttpsRequest: [String urlStr] -> [HttpsURLConnection] - Sets up an HTTPS connection with the specified URL, configures timeouts and request method, and establishes the connection. Returns the connection object if successful.\ndownloadUrlMemoryAsString: [String url] -> [String] - Downloads content from the specified URL and returns it as a UTF-8 encoded string. Returns null if the download fails.\ndownloadUrlFile: [String url, File f] -> [boolean] - Downloads content from the specified URL and saves it to the specified file. Returns true if successful, false otherwise.\nDownloadCallback: [interface] - Interface defining a callback for asynchronous download completion with onDownloadComplete method.",
    "Canonical_solution": "import android.util.Log;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = false;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 60000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 60000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        URL url;\n        HttpsURLConnection urlConnection = null;\n        try {\n            url = new URL(urlStr);\n            urlConnection = (HttpsURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n            urlConnection.setRequestMethod(\"GET\");\n            urlConnection.setDoInput(true);\n            urlConnection.connect();\n            int code = urlConnection.getResponseCode();\n            if (code != HttpsURLConnection.HTTP_OK) {\n                Log.d(TAG, \"response:\" + code);\n                return null;\n            }\n            return urlConnection;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to connect to server\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        if (DEBUG) Log.d(TAG, \"download: \" + url);\n\n        HttpsURLConnection urlConnection = null;\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return null;\n            }\n\n            InputStream is = urlConnection.getInputStream();\n            ByteArrayOutputStream byteArray = new ByteArrayOutputStream();\n            int byteInt;\n\n            while ((byteInt = is.read()) >= 0) {\n                byteArray.write(byteInt);\n            }\n\n            byte[] bytes = byteArray.toByteArray();\n            if (bytes == null) {\n                return null;\n            }\n\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return null;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        if (DEBUG) Log.d(TAG, \"download:\" + url);\n\n        HttpsURLConnection urlConnection = null;\n\n        if (f.exists())\n            f.delete();\n\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return false;\n            }\n            long len = urlConnection.getContentLength();\n            if ((len > 0) && (len < 4L * 1024L * 1024L * 1024L)) {\n                byte[] buffer = new byte[262144];\n\n                InputStream is = urlConnection.getInputStream();\n                FileOutputStream os = new FileOutputStream(f, false);\n                try {\n                    int r;\n                    while ((r = is.read(buffer)) > 0) {\n                        os.write(buffer, 0, r);\n                    }\n                } finally {\n                    os.close();\n                }\n\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return false;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.*;\nimport java.net.URL;\n\npublic class NetworkUtils {\n    public static final boolean DEBUG = true;\n    public static final String TAG = \"NetworkUtils\";\n    public static final int HTTP_READ_TIMEOUT = 10000;\n    public static final int HTTP_CONNECTION_TIMEOUT = 10000;\n\n    private NetworkUtils() {\n        // Private constructor to prevent instantiation\n    }\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setReadTimeout(HTTP_READ_TIMEOUT);\n        connection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n        connection.setRequestMethod(\"GET\");\n        connection.setUseCaches(false);\n        connection.connect();\n        return connection;\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        try {\n            HttpsURLConnection connection = setupHttpsRequest(url);\n            if (connection.getResponseCode() == HttpsURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, \"UTF-8\"));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return response.toString();\n            } else {\n                if (DEBUG) {\n                    System.out.println(TAG + \": Download failed with response code: \" + connection.getResponseCode());\n                }\n                return null;\n            }\n        } catch (IOException e) {\n            if (DEBUG) {\n                System.out.println(TAG + \": Error downloading URL: \" + e.getMessage());\n            }\n            return null;\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        try {\n            HttpsURLConnection connection = setupHttpsRequest(url);\n            if (connection.getResponseCode() == HttpsURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                FileOutputStream outputStream = new FileOutputStream(f);\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, bytesRead);\n                }\n                inputStream.close();\n                outputStream.close();\n                return true;\n            } else {\n                if (DEBUG) {\n                    System.out.println(TAG + \": Download failed with response code: \" + connection.getResponseCode());\n                }\n                return false;\n            }\n        } catch (IOException e) {\n            if (DEBUG) {\n                System.out.println(TAG + \": Error downloading URL: \" + e.getMessage());\n            }\n            return false;\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function that retrieves JSON data from a Twitter URL based on a given tweet ID using Java's HttpURLConnection.\n\nFunction Description: The function makes an HTTP GET request to a Twitter URL constructed with the provided tweet ID, reads the response, and returns it as a JSONObject. It handles HTTPS connections, sets appropriate request headers, and manages the connection lifecycle.\n\nInput: \n- tweetId: long - The ID of the tweet for which to retrieve favorited popup data\n\nOutput: \n- JSONObject - The JSON response from the Twitter URL, or null if an error occurs",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic JSONObject getJson(long tweetId) {\n    try {\n        String url = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        URL obj = new URL(url);\n\n        HttpsURLConnection connection = (HttpsURLConnection) obj.openConnection();\n        connection.setRequestProperty(\"Content-Type\", \"text/html\");\n        connection.setRequestProperty(\"charset\", \"utf-8\");\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36\");\n        connection.connect();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line + \"\\n\");\n        }\n\n        String docHtml = sb.toString();\n\n        try {\n            connection.disconnect();\n        } catch (Exception e) {\n\n        }\n\n        return new JSONObject(docHtml);\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.json.JSONObject;\n\npublic class TwitterFetcher {\n    public static JSONObject getTweetFavoritedPopup(long tweetId) {\n        try {\n            String urlString = \"https://api.twitter.com/1.1/statuses/show.json?id=\" + tweetId;\n            URL url = new URL(urlString);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Authorization\", \"Bearer YOUR_BEARER_TOKEN\");\n            connection.setRequestProperty(\"User-Agent\", \"Java\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return new JSONObject(response.toString());\n            } else {\n                System.err.println(\"Error: \" + responseCode);\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for MMS (Multimedia Messaging Service) operations, supporting both HTTP and HTTPS protocols with configurable proxy settings and connection parameters.\n\nClass Description: MmsHttpClient is a specialized HTTP client designed for MMS operations that handles both GET and POST requests. It manages network connections, proxy configurations, request/response handling, and includes MMS-specific header management. The class uses OkHttp internally for connection management.\n\nAttributes:\n- mContext: Context - Android application context\n- mSocketFactory: SocketFactory - Factory for creating sockets\n- mHostResolver: MmsNetworkManager - Network host resolver for connection management\n- mConnectionPool: ConnectionPool - Pool of HTTP connections for reuse\n\nMethods:\n- execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) -> byte[] - Executes an HTTP request to the specified URL with given PDU data. Handles both GET and POST methods with proxy support. Returns the response body as byte array.\n- openConnection(URL url, Proxy proxy) -> HttpURLConnection - Creates and configures an appropriate HttpURLConnection (HTTP or HTTPS) with the given URL and proxy settings. Throws MalformedURLException for invalid protocols.\n- checkMethod(String method) -> void - Validates that the HTTP method is either GET or POST (helper method)\n- getCurrentAcceptLanguage(Locale locale) -> String - Generates Accept-Language header value from locale (helper method)\n- addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) -> void - Adds additional MMS-specific headers to the request (helper method)\n- logHttpHeaders(Map<String, List<String>> headers) -> void - Logs HTTP headers for debugging (helper method)",
    "Canonical_solution": "import android.content.Context;\nimport com.android.mms.service_alt.exception.MmsHttpException;\nimport com.squareup.okhttp.ConnectionPool;\nimport com.squareup.okhttp.ConnectionSpec;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Protocol;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.internal.Internal;\nimport com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;\nimport com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;\nimport timber.log.Timber;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MmsHttpClient {\n\n    public static final String METHOD_POST = \"POST\";\n    public static final String METHOD_GET = \"GET\";\n\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n    private static final String HEADER_ACCEPT = \"Accept\";\n    private static final String HEADER_ACCEPT_LANGUAGE = \"Accept-Language\";\n    private static final String HEADER_USER_AGENT = \"User-Agent\";\n\n    private static final String HEADER_VALUE_ACCEPT =\n            \"*/*, application/vnd.wap.mms-message, application/vnd.wap.sic\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET =\n            \"application/vnd.wap.mms-message; charset=utf-8\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET =\n            \"application/vnd.wap.mms-message\";\n\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver,\n            ConnectionPool connectionPool) {\n        mContext = context;\n        mSocketFactory = socketFactory;\n        mHostResolver = hostResolver;\n        mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet,\n            String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig)\n            throws MmsHttpException {\n        Timber.d(\"HTTP: \" + method + \" \" + urlString\n                + (isProxySet ? (\", proxy=\" + proxyHost + \":\" + proxyPort) : \"\")\n                + \", PDU size=\" + (pdu != null ? pdu.length : 0));\n        checkMethod(method);\n        HttpURLConnection connection = null;\n        try {\n            Proxy proxy = null;\n            if (isProxySet) {\n                proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n            }\n            final URL url = new URL(urlString);\n            connection = openConnection(url, proxy);\n            connection.setDoInput(true);\n            connection.setConnectTimeout(mmsConfig.getHttpSocketTimeout());\n            connection.setRequestProperty(HEADER_ACCEPT, HEADER_VALUE_ACCEPT);\n            connection.setRequestProperty(\n                    HEADER_ACCEPT_LANGUAGE, getCurrentAcceptLanguage(Locale.getDefault()));\n            final String userAgent = mmsConfig.getUserAgent();\n            Timber.i(\"HTTP: User-Agent=\" + userAgent);\n            connection.setRequestProperty(HEADER_USER_AGENT, userAgent);\n            final String uaProfUrlTagName = mmsConfig.getUaProfTagName();\n            final String uaProfUrl = mmsConfig.getUaProfUrl();\n            if (uaProfUrl != null) {\n                Timber.i(\"HTTP: UaProfUrl=\" + uaProfUrl);\n                connection.setRequestProperty(uaProfUrlTagName, uaProfUrl);\n            }\n            addExtraHeaders(connection, mmsConfig);\n            if (METHOD_POST.equals(method)) {\n                if (pdu == null || pdu.length < 1) {\n                    Timber.e(\"HTTP: empty pdu\");\n                    throw new MmsHttpException(0/*statusCode*/, \"Sending empty PDU\");\n                }\n                connection.setDoOutput(true);\n                connection.setRequestMethod(METHOD_POST);\n                if (mmsConfig.getSupportHttpCharsetHeader()) {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET);\n                } else {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET);\n                }\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setFixedLengthStreamingMode(pdu.length);\n                final OutputStream out = new BufferedOutputStream(connection.getOutputStream());\n                out.write(pdu);\n                out.flush();\n                out.close();\n            } else if (METHOD_GET.equals(method)) {\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setRequestMethod(METHOD_GET);\n            }\n            final int responseCode = connection.getResponseCode();\n            final String responseMessage = connection.getResponseMessage();\n            Timber.d(\"HTTP: \" + responseCode + \" \" + responseMessage);\n            logHttpHeaders(connection.getHeaderFields());\n            if (responseCode / 100 != 2) {\n                throw new MmsHttpException(responseCode, responseMessage);\n            }\n            final InputStream in = new BufferedInputStream(connection.getInputStream());\n            final ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n            final byte[] buf = new byte[4096];\n            int count = 0;\n            while ((count = in.read(buf)) > 0) {\n                byteOut.write(buf, 0, count);\n            }\n            in.close();\n            final byte[] responseBody = byteOut.toByteArray();\n            Timber.d(\"HTTP: response size=\"\n                    + (responseBody != null ? responseBody.length : 0));\n            return responseBody;\n        } catch (MalformedURLException e) {\n            Timber.e(e, \"HTTP: invalid URL \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL \" + urlString, e);\n        } catch (ProtocolException e) {\n            Timber.e(e, \"HTTP: invalid URL protocol \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL protocol \" + urlString, e);\n        } catch (IOException e) {\n            Timber.e(e, \"HTTP: IO failure\");\n            throw new MmsHttpException(0/*statusCode*/, e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, final Proxy proxy) throws MalformedURLException {\n        final String protocol = url.getProtocol();\n        OkHttpClient okHttpClient;\n        if (protocol.equals(\"http\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setFollowRedirects(false);\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    if (proxy != null) {\n                        return Arrays.asList(proxy);\n                    } else {\n                        return new ArrayList<Proxy>();\n                    }\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            okHttpClient.setSocketFactory(SocketFactory.getDefault());\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            if (proxy != null) {\n                okHttpClient.setProxy(proxy);\n            }\n\n            return new HttpURLConnectionImpl(url, okHttpClient);\n        } else if (protocol.equals(\"https\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();\n            okHttpClient.setHostnameVerifier(verifier);\n            okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    return Arrays.asList(proxy);\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            return new HttpsURLConnectionImpl(url, okHttpClient);\n        } else {\n            throw new MalformedURLException(\"Invalid URL or unrecognized protocol \" + protocol);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SocketFactory;\n\nimport android.content.Context;\nimport android.net.http.AndroidHttpClient;\nimport android.os.Build;\nimport android.text.TextUtils;\n\npublic class MmsHttpClient {\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver, ConnectionPool connectionPool) {\n        mContext = context;\n        mSocketFactory = socketFactory;\n        mHostResolver = hostResolver;\n        mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) throws IOException {\n        checkMethod(method);\n        URL url = new URL(urlString);\n        Proxy proxy = isProxySet ? new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort)) : null;\n        HttpURLConnection connection = openConnection(url, proxy);\n        connection.setRequestMethod(method);\n        addExtraHeaders(connection, mmsConfig);\n\n        if (method.equals(\"POST\")) {\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/vnd.3gpp.sms\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(pdu.length));\n            connection.getOutputStream().write(pdu);\n        }\n\n        int responseCode = connection.getResponseCode();\n        InputStream inputStream = (responseCode >= 200 && responseCode < 300) ? connection.getInputStream() : connection.getErrorStream();\n\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            byteArrayOutputStream.write(buffer, 0, bytesRead);\n        }\n        return byteArrayOutputStream.toByteArray();\n    }\n\n    private HttpURLConnection openConnection(URL url, Proxy proxy) throws MalformedURLException {\n        String protocol = url.getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n            throw new MalformedURLException(\"Unsupported protocol: \" + protocol);\n        }\n\n        HttpURLConnection connection;\n        if (proxy != null) {\n            connection = (HttpURLConnection) url.openConnection(proxy);\n        } else {\n            connection = (HttpURLConnection) url.openConnection();\n        }\n\n        if (protocol.equals(\"https\")) {\n            ((HttpsURLConnection) connection).setSSLSocketFactory((SSLSocketFactory) mSocketFactory);\n        }\n\n        connection.setConnectTimeout(30000);\n        connection.setReadTimeout(30000);\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(false);\n        connection.setRequestProperty(\"User-Agent\", \"MMSClient/1.0\");\n\n        return connection;\n    }\n\n    private void checkMethod(String method) {\n        if (!method.equals(\"GET\") && !method.equals(\"POST\")) {\n            throw new IllegalArgumentException(\"Unsupported HTTP method: \" + method);\n        }\n    }\n\n    private String getCurrentAcceptLanguage(Locale locale) {\n        return locale.getLanguage() + \"-\" + locale.getCountry();\n    }\n\n    private void addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) {\n        connection.setRequestProperty(\"Accept-Language\", getCurrentAcceptLanguage(mContext.getResources().getConfiguration().locale));\n        connection.setRequestProperty(\"X-Mms-Message-Type\", \"m-rep\");\n        connection.setRequestProperty(\"X-Mms-Transaction-Id\", \"1234567890\");\n        connection.setRequestProperty(\"X-Mms-Content-Location\", mmsConfig.getContentLocation());\n        connection.setRequestProperty(\"X-Mms-Subject\", mmsConfig.getSubject());\n    }\n\n    private void logHttpHeaders(Map<String, List<String>> headers) {\n        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n            for (String value : entry.getValue()) {\n                System.out.println(entry.getKey() + \": \" + value);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://example.com/api/endpoint\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            conn.setDoOutput(true);\n\n            String param = \"packageName=\" + packageName;\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = param.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode < 400) {\n                try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                    String response = br.lines().reduce(\"\", (acc, line) -> acc + line);\n                    callback.onSuccess();\n                }\n            } else {\n                callback.onFailure(new Exception(\"HTTP error code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostValidator {\n    public static void sendAndVerifyPost(String message, String url) throws IOException {\n        URL fullUrl = new URL(\"http://example.com\" + url);\n        HttpURLConnection connection = (HttpURLConnection) fullUrl.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"text/plain; charset=UTF-8\");\n\n        try (OutputStream os = connection.getOutputStream()) {\n            os.write(message.getBytes(\"UTF-8\"));\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != 200) {\n            throw new IOException(\"Unexpected response code: \" + responseCode);\n        }\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n\n        if (!response.toString().equals(message)) {\n            System.out.println(\"Response does not match the original message.\");\n            byte[] responseBytes = response.toString().getBytes();\n            StringBuilder hexString = new StringBuilder();\n            for (byte b : responseBytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) hexString.append('0');\n                hexString.append(hex).append(\" \");\n            }\n            System.out.println(hexString.toString());\n        }\n    }\n}"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.stream.Collectors;\n\npublic class RestClient {\n    private final String protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    public RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = protocol.toString();\n        this.host = host;\n        this.port = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    public URL getUrl(String path, Param... param) throws Exception {\n        StringBuilder urlBuilder = new StringBuilder();\n        urlBuilder.append(protocol).append(\"://\").append(host);\n        if (port != 80 && port != 443) {\n            urlBuilder.append(\":\").append(port);\n        }\n        urlBuilder.append(path);\n\n        if (param.length > 0) {\n            urlBuilder.append(\"?\");\n            List<String> encodedParams = new ArrayList<>();\n            for (Param p : param) {\n                encodedParams.add(URLEncoder.encode(p.getName(), StandardCharsets.UTF_8.toString()) + \"=\" + URLEncoder.encode(p.getValue(), StandardCharsets.UTF_8.toString()));\n            }\n            urlBuilder.append(encodedParams.stream().collect(Collectors.joining(\"&\")));\n        }\n\n        return new URL(urlBuilder.toString());\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                URL url = getUrl(path);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method.toString());\n\n                if (options != null) {\n                    for (Option option : options) {\n                        if (option instanceof HeaderOption) {\n                            conn.setRequestProperty(((HeaderOption) option).getName(), ((HeaderOption) option).getValue());\n                        } else if (option instanceof AuthOption) {\n                            String auth = ((AuthOption) option).getUsername() + \":\" + ((AuthOption) option).getPassword();\n                            String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));\n                            conn.setRequestProperty(\"Authorization\", \"Basic \" + encodedAuth);\n                        } else if (option instanceof ParamOption) {\n                            String paramName = ((ParamOption) option).getParam().getName();\n                            String paramValue = ((ParamOption) option).getParam().getValue();\n                            conn.setRequestProperty(paramName, paramValue);\n                        }\n                    }\n                }\n\n                if (method == Method.POST || method == Method.PUT || method == Method.PATCH) {\n                    conn.setDoOutput(true);\n                    try (OutputStream os = conn.getOutputStream()) {\n                        if (outStreamConsumer != null) {\n                            outStreamConsumer.write(os);\n                        }\n                    }\n                }\n\n                int responseCode = getResponseCodeFrom(conn);\n                String responseText = tryGetResponseTextFrom(conn, responseCode);\n                Map<String, List<String>> headers = conn.getHeaderFields();\n\n                return new Response(responseCode, responseText, headers);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n    public static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        if (status >= 200 && status < 300) {\n            try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                StringBuilder sb = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    sb.append(line);\n                }\n                return sb.toString();\n            }\n        } else {\n            try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                StringBuilder sb = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    sb.append(line);\n                }\n                return sb.toString();\n            }\n        }\n    }\n\n    public static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        int code = conn.getResponseCode();\n        if (code == HttpURLConnection.HTTP_NOT_FOUND) {\n            throw new RestException(\"Resource not found\");\n        }\n        return code;\n    }\n\n    public enum Protocol {\n        HTTP, HTTPS\n    }\n\n    public enum Method {\n        GET, POST, PUT, DELETE, PATCH\n    }\n\n    public static class Param {\n        private final String name;\n        private final String value;\n\n        public Param(String name, String value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getValue() {\n            return value;\n        }\n    }\n\n    public interface Option {\n    }\n\n    public static class HeaderOption implements Option {\n        private final String name;\n        private final String value;\n\n        public HeaderOption(String name, String value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getValue() {\n            return value;\n        }\n    }\n\n    public static class AuthOption implements Option {\n        private final String username;\n        private final String password;\n\n        public AuthOption(String username, String password) {\n            this.username = username;\n            this.password = password;\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public String getPassword() {\n            return password;\n        }\n    }\n\n    public static class ParamOption implements Option {\n        private final Param param;\n\n        public ParamOption(Param param) {\n            this.param = param;\n        }\n\n        public Param getParam() {\n            return param;\n        }\n    }\n\n    public interface StreamConsumer {\n        void write(OutputStream os) throws IOException;\n    }\n\n    public static class Response {\n        private final int statusCode;\n        private final String responseText;\n        private final Map<String, List<String>> headers;\n\n        public Response(int statusCode, String responseText, Map<String, List<String>> headers) {\n            this.statusCode = statusCode;\n            this.responseText = responseText;\n            this.headers = headers;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public String getResponseText() {\n            return responseText;\n        }\n\n        public Map<String, List<String>> getHeaders() {\n            return headers;\n        }\n    }\n\n    public static class RestException extends Exception {\n        public RestException(String message) {\n            super(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class GetDNSLogRecordTask {\n    private int status;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.config = config;\n        this.status = -1;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            String urlString = \"https://dnslog.cn/get.php\";\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            String[] result = response.toString().split(\",\");\n            if (result.length >= 2) {\n                config.setDomain(result[0]);\n                config.setSession(result[1]);\n                status = 1;\n            } else {\n                status = -1;\n            }\n        } catch (Exception e) {\n            status = -1;\n        }\n        return 1;\n    }\n\n    public static class Config {\n        private String domain;\n        private String session;\n\n        public String getDomain() {\n            return domain;\n        }\n\n        public void setDomain(String domain) {\n            this.domain = domain;\n        }\n\n        public String getSession() {\n            return session;\n        }\n\n        public void setSession(String session) {\n            this.session = session;\n        }\n    }\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously in an Android environment, using HttpURLConnection for network operations and AsyncTask for background processing.\n\nClass Description: HttpRequestHandler is a utility class designed to perform HTTP GET requests asynchronously. It contains an inner AsyncTask class for background network operations and a helper method for converting InputStream to String.\n\nAttributes: (None - this is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - An AsyncTask subclass that performs HTTP GET requests in the background. Takes a URL string as input and processes the response.\n  - onPreExecute(): void - Empty preparation method (can be overridden)\n  - doInBackground(String...): String - Performs the network request, reads response, and publishes progress\n  - onProgressUpdate(String...): void - Shows the response in a Toast message\n  - onPostExecute(String): void - Empty completion method (can be overridden)\n\nMethod2: ConvertInputToStringNoChange(InputStream) -> String - Helper method that converts an InputStream to a String by reading all lines.\n  - Input: InputStream - The input stream to convert\n  - Output: String - The concatenated string from the input stream",
    "Canonical_solution": "import android.content.Intent;\nimport android.os.AsyncTask;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            //before works\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                Toast.makeText(getApplicationContext(), progress[0], Toast.LENGTH_LONG).show();\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {}\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private static class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            // Empty preparation method\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            String urlString = params[0];\n            StringBuilder response = new StringBuilder();\n            try {\n                URL url = new URL(urlString);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setRequestMethod(\"GET\");\n                urlConnection.setReadTimeout(10000);\n                urlConnection.setConnectTimeout(15000);\n                urlConnection.setInstanceFollowRedirects(true);\n                urlConnection.connect();\n\n                int responseCode = urlConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line).append(\"\\n\");\n                        publishProgress(line);\n                    }\n                    reader.close();\n                } else {\n                    response.append(\"Error: \").append(responseCode);\n                }\n            } catch (Exception e) {\n                response.append(e.getMessage());\n            } finally {\n                urlConnection.disconnect();\n            }\n            return response.toString();\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            // Show the response in a Toast message\n            android.widget.Toast.makeText(android.app.Activity.class, values[0], android.widget.Toast.LENGTH_SHORT).show();\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            // Empty completion method\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n\n    public static MyAsyncTask getNews(String... params) {\n        return new MyAsyncTask().execute(params);\n    }\n}"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a utility class in Java that handles HTTP requests using HttpURLConnection, with support for custom headers and timeouts.\n\nClass Description: HttpHelper is a final utility class that provides static methods for making HTTP requests. It encapsulates the complexity of HttpURLConnection and provides error handling. The class cannot be instantiated.\n\nAttributes: None (This is a utility class with only static methods)\n\nMethods:\nMethod1: getHttpContents(String method, String endpoint, Map<String, String> headers) -> String - Makes an HTTP request to the specified endpoint using the given method and headers. Returns the response content as a String.\n  - Parameters:\n    - method: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n    - endpoint: String - The URL to send the request to\n    - headers: Map<String, String> - Optional map of request headers (can be null)\n  - Returns: String - The response content from the server\n  - Throws: MongoClientException if an IOException occurs during the request",
    "Canonical_solution": "import com.mongodb.MongoClientException;\nimport com.mongodb.lang.NonNull;\nimport com.mongodb.lang.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nfinal class HttpHelper {\n\n    private HttpHelper() {\n    }\n\n    @NonNull\n    public static String getHttpContents(final String method, final String endpoint, @Nullable final Map<String, String> headers) {\n        StringBuilder content = new StringBuilder();\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(endpoint).openConnection();\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(method);\n            if (headers != null) {\n                for (Map.Entry<String, String> kvp : headers.entrySet()) {\n                    conn.setRequestProperty(kvp.getKey(), kvp.getValue());\n                }\n            }\n\n            int status = conn.getResponseCode();\n            if (status != HttpURLConnection.HTTP_OK) {\n                throw new IOException(String.format(\"%d %s\", status, conn.getResponseMessage()));\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"Unexpected IOException from endpoint \" + endpoint + \".\", e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return content.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpHelper {\n    private HttpHelper() {\n        throw new UnsupportedOperationException(\"Utility class cannot be instantiated\");\n    }\n\n    public static String getHttpContents(String method, String endpoint, Map<String, String> headers) throws IOException {\n        URL url = new URL(endpoint);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(method);\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        BufferedReader reader;\n        if (responseCode >= 200 && responseCode < 300) {\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        } else {\n            reader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n        }\n\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a Java utility class for making HTTP POST requests with JSON payloads, handling authentication, and processing JSON responses.\n\nClass Description: JobRemotingUtil is a utility class that provides functionality for making remote HTTP POST requests with JSON data. It handles connection setup, request configuration, payload serialization, response processing, and error handling. The class includes logging capabilities and supports access token authentication.\n\nAttributes:\nlogger: [Logger] - SLF4J logger instance for logging errors and debug information\nXXL_RPC_ACCESS_TOKEN: [String] - Constant string for the authentication token header name\n\nMethods:\npostBody: [Name](String url, String accessToken, Object requestObj, int timeout) -> ReturnT<String> - Makes an HTTP POST request to the specified URL with the given request object serialized as JSON. Handles authentication via access token, sets appropriate headers, and processes the JSON response. Returns a ReturnT<String> object containing the response status, message, and content. The timeout parameter specifies the read timeout in seconds.",
    "Canonical_solution": "import com.wugui.datatx.core.biz.model.ReturnT;\nimport com.wugui.datax.rpc.util.json.BasicJson;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JobRemotingUtil {\n    private static Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        HttpURLConnection connection = null;\n        BufferedReader bufferedReader = null;\n        try {\n            URL realUrl = new URL(url);\n            connection = (HttpURLConnection) realUrl.openConnection();\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setReadTimeout(timeout * 1000);\n            connection.setConnectTimeout(3 * 1000);\n            connection.setRequestProperty(\"connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"application/json;charset=UTF-8\");\n\n            if(accessToken!=null && accessToken.trim().length()>0){\n                connection.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            }\n\n            connection.connect();\n\n            String requestBody = BasicJson.toJson(requestObj);\n            DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n            dataOutputStream.writeBytes(requestBody);\n            dataOutputStream.flush();\n            dataOutputStream.close();\n\n            int statusCode = connection.getResponseCode();\n            if (statusCode != 200) {\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting fail, StatusCode(\"+ statusCode +\") invalid. for url : \" + url);\n            }\n\n            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                result.append(line);\n            }\n            String resultJson = result.toString();\n\n            try {\n                Map<String, Object> resultMap = BasicJson.parseMap(resultJson);\n\n                ReturnT<String> returnT = new ReturnT<String>();\n                if (resultMap==null) {\n                    returnT.setCode(ReturnT.FAIL_CODE);\n                    returnT.setMsg(\"AdminBizClient Remoting call fail.\");\n                } else {\n                    returnT.setCode(Integer.valueOf(String.valueOf(resultMap.get(\"code\"))));\n                    returnT.setMsg(String.valueOf(resultMap.get(\"msg\")));\n                    returnT.setContent(String.valueOf(resultMap.get(\"content\")));\n                }\n                return returnT;\n            } catch (Exception e) {\n                logger.error(\"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\", e);\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\");\n            }\n\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting error(\"+ e.getMessage() +\"), for url : \" + url);\n        } finally {\n            try {\n                if (bufferedReader != null) {\n                    bufferedReader.close();\n                }\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            } catch (Exception e2) {\n                logger.error(e2.getMessage(), e2);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.client.RestTemplate;\n\nimport com.alibaba.fastjson.JSON;\nimport com.xxl.job.core.enums.ResultEnum;\nimport com.xxl.job.core.util.ReturnT;\n\npublic class JobRemotingUtil {\n    private static final Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static final String XXL_RPC_ACCESS_TOKEN = \"Xxl-Rpc-Access-Token\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        try {\n            HttpHeaders headers = new HttpHeaders();\n            headers.setContentType(MediaType.APPLICATION_JSON);\n            headers.set(XXL_RPC_ACCESS_TOKEN, accessToken);\n\n            String requestBody = JSON.toJSONString(requestObj);\n            HttpEntity<String> entity = new HttpEntity<>(requestBody, headers);\n\n            RestTemplate restTemplate = new RestTemplate();\n            ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);\n\n            return new ReturnT<>(ResultEnum.SUCCESS.getCode(), \"Success\", response.getBody());\n        } catch (Exception e) {\n            logger.error(\"JobRemotingUtil.postBody fail, url: {}, accessToken: {}\", url, accessToken, e);\n            return new ReturnT<>(ResultEnum.FAIL.getCode(), e.getMessage(), null);\n        }\n    }\n}"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostClient {\n    public static String sendPostRequest(String url, String name) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n            String urlParams = \"name=\" + name;\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = urlParams.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int responseCode = con.getResponseCode();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private HttpRequestCallback callback;\n\n    public class MyAsyncTask extends android.os.AsyncTask<String, String, String> {\n        public MyAsyncTask(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... urls) {\n            if (urls.length == 0) return null;\n            String url = urls[0];\n            try {\n                java.net.HttpURLConnection conn = (java.net.HttpURLConnection) new java.net.URL(url).openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.setConnectTimeout(5000);\n                conn.setReadTimeout(5000);\n                conn.setInstanceFollowRedirects(true);\n\n                int responseCode = conn.getResponseCode();\n                publishProgress(\"Response Code: \" + responseCode);\n\n                if (responseCode == java.net.HttpURLConnection.HTTP_OK) {\n                    java.io.InputStream inputStream = conn.getInputStream();\n                    java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(inputStream));\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    return response.toString();\n                } else {\n                    return \"Error: \" + responseCode;\n                }\n            } catch (Exception e) {\n                return \"Exception: \" + e.getMessage();\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... values);\n        void onPostExecute(String result);\n    }\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making network requests, with support for gzip compression, proxy interaction, and error handling.\n\nClass Description: The HttpService class provides HTTP client capabilities for making POST requests to specified endpoints. It handles request construction, connection management, response processing, and includes features like gzip compression, SSL socket configuration, proxy server interaction, and automatic retries for failed requests.\n\nAttributes:\n\nshouldGzipRequestPayload: boolean - Determines whether request payload should be gzip compressed\nMIN_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Minimum HTTP response code considered as service unavailable (500)\nMAX_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Maximum HTTP response code considered as service unavailable (599)\nLOGTAG: String - Tag used for logging messages\nHTTP_OUTPUT_STREAM_BUFFER_SIZE: int - Buffer size for output streams (8192 bytes)\nCONTENT_ENCODING_HEADER: String - Header key for content encoding\nGZIP_CONTENT_TYPE_HEADER: String - Value for gzip content encoding\n\nMethods:\n\nperformRequest: performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) -> byte[] - Makes an HTTP POST request to the specified endpoint with optional parameters and SSL configuration. Handles retries for failed requests and returns the response body as bytes. Throws ServiceUnavailableException for 5xx responses and IOException for other failures.\n\ngetBufferedOutputStream: getBufferedOutputStream(OutputStream out) -> OutputStream - Creates a buffered output stream, optionally wrapped in a GZIPOutputStream based on shouldGzipRequestPayload.\n\nisProxyRequest: isProxyRequest(String endpointUrl) -> boolean - Determines if the request is a proxy request by checking the endpoint URL.\n\nslurp: slurp(InputStream inputStream) -> byte[] - Reads all bytes from an input stream and returns them as a byte array.",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService implements RemoteService {\n\n    private final boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = HttpURLConnection.HTTP_INTERNAL_ERROR;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"MixpanelAPI.Message\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    @Override\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        MPLog.v(LOGTAG, \"Attempting request to \" + endpointUrl);\n\n        byte[] response = null;\n        int retries = 0;\n        boolean succeeded = false;\n        while (retries < 3 && !succeeded) {\n            InputStream in = null;\n            OutputStream out = null;\n            OutputStream bout = null;\n            HttpURLConnection connection = null;\n\n            try {\n                final URL url = new URL(endpointUrl);\n                connection = (HttpURLConnection) url.openConnection();\n                if (null != socketFactory && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    Map<String,String> headers = interactor.getProxyRequestHeaders();\n                    if (headers != null) {\n                        for (Map.Entry<String, String> entry : headers.entrySet()) {\n                            connection.setRequestProperty(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n\n                connection.setConnectTimeout(2000);\n                connection.setReadTimeout(30000);\n                if (null != params) {\n                    Uri.Builder builder = new Uri.Builder();\n                    for (Map.Entry<String, Object> param : params.entrySet()) {\n                        builder.appendQueryParameter(param.getKey(), param.getValue().toString());\n                    }\n                    String query = builder.build().getEncodedQuery();\n                    if (shouldGzipRequestPayload) {\n                        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                    } else {\n                        connection.setFixedLengthStreamingMode(query.getBytes().length);\n                    }\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    out = connection.getOutputStream();\n                    bout = getBufferedOutputStream(out);\n                    bout.write(query.getBytes(\"UTF-8\"));\n                    bout.flush();\n                    bout.close();\n                    bout = null;\n                    out.close();\n                    out = null;\n                }\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    interactor.onProxyResponse(endpointUrl, connection.getResponseCode());\n                }\n                in = connection.getInputStream();\n                response = slurp(in);\n                in.close();\n                in = null;\n                succeeded = true;\n            } catch (final EOFException e) {\n                MPLog.d(LOGTAG, \"Failure to connect, likely caused by a known issue with Android lib. Retrying.\");\n                retries = retries + 1;\n            } catch (final IOException e) {\n                if (connection != null && connection.getResponseCode() >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && connection.getResponseCode() <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service Unavailable\", connection.getHeaderField(\"Retry-After\"));\n                } else {\n                    throw e;\n                }\n            }\n            finally {\n                if (null != bout)\n                    try { bout.close(); } catch (final IOException e) {}\n                if (null != out)\n                    try { out.close(); } catch (final IOException e) {}\n                if (null != in)\n                    try { in.close(); } catch (final IOException e) {}\n                if (null != connection)\n                    connection.disconnect();\n            }\n        }\n        if (retries >= 3) {\n            MPLog.v(LOGTAG, \"Could not connect to Mixpanel service after three retries.\");\n        }\n        return response;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if(shouldGzipRequestPayload) {\n          return new GZIPOutputStream(new BufferedOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private static boolean isProxyRequest(String endpointUrl) {\n        return !endpointUrl.toLowerCase().contains(MIXPANEL_API.toLowerCase());\n    }\n\n    private static byte[] slurp(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[8192];\n\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService {\n    boolean shouldGzipRequestPayload = false;\n    int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = 500;\n    int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    String LOGTAG = \"HttpService\";\n    int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws IOException {\n        int retryCount = 3;\n        while (retryCount-- > 0) {\n            try {\n                HttpURLConnection connection = createConnection(endpointUrl, interactor, socketFactory);\n                connection.setRequestMethod(\"POST\");\n                connection.setDoOutput(true);\n                connection.setConnectTimeout(30000);\n                connection.setReadTimeout(30000);\n\n                if (params != null && !params.isEmpty()) {\n                    OutputStream out = getBufferedOutputStream(connection.getOutputStream());\n                    writeParams(out, params);\n                    out.flush();\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && responseCode <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service unavailable: \" + responseCode);\n                }\n\n                InputStream inputStream = (responseCode >= 200 && responseCode < 300) ? connection.getInputStream() : connection.getErrorStream();\n                return slurp(inputStream);\n            } catch (IOException e) {\n                if (retryCount == 0) {\n                    throw e;\n                }\n            }\n        }\n        return new byte[0];\n    }\n\n    private HttpURLConnection createConnection(String endpointUrl, ProxyServerInteractor interactor, SSLSocketFactory socketFactory) throws IOException {\n        Proxy proxy = isProxyRequest(endpointUrl) ? new Proxy(Proxy.Type.HTTP, new InetSocketAddress(interactor.getHost(), interactor.getPort())) : Proxy.NO_PROXY;\n        URL url = new URL(endpointUrl);\n        HttpURLConnection connection = (url.getProtocol().equals(\"https\") ? (HttpsURLConnection) url.openConnection(proxy) : (HttpURLConnection) url.openConnection(proxy));\n        if (socketFactory != null) {\n            ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n        }\n        return connection;\n    }\n\n    private void writeParams(OutputStream out, Map<String, Object> params) throws IOException {\n        for (Map.Entry<String, Object> entry : params.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                out.write(key.getBytes());\n                out.write(\"=\".getBytes());\n                out.write(((String) value).getBytes());\n                out.write(\"\\n\".getBytes());\n            }\n        }\n    }\n\n    public OutputStream getBufferedOutputStream(OutputStream out) {\n        if (shouldGzipRequestPayload) {\n            try {\n                return new java.util.zip.GZIPOutputStream(out);\n            } catch (IOException e) {\n                return out;\n            }\n        } else {\n            return new ByteArrayOutputStream(HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        }\n    }\n\n    public boolean isProxyRequest(String endpointUrl) {\n        return endpointUrl.contains(\"proxy\");\n    }\n\n    public byte[] slurp(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nBytesRead;\n        byte[] data = new byte[HTTP_OUTPUT_STREAM_BUFFER_SIZE];\n        while ((nBytesRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nBytesRead);\n        }\n        return buffer.toByteArray();\n    }\n}\n\nclass ServiceUnavailableException extends IOException {\n    public ServiceUnavailableException(String message) {\n        super(message);\n    }\n}\n\ninterface ProxyServerInteractor {\n    String getHost();\n    int getPort();\n}"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a Java class that checks the HTTP status of a given URL and provides information about the response code and any redirection.\n\nClass Description: The HttpStatusChecker class is responsible for making HTTP requests to a specified URL, checking the response status code, and providing information about the response. It handles redirections and provides human-readable messages for the status codes. The class is designed for Android applications, using Android-specific components for logging and resource management.\n\nAttributes:\n- context: Context - The Android context used for accessing resources and system services.\n- url: String - The URL to be checked for HTTP status.\n\nMethods:\n- checkStatus() -> StatusResult - Performs the HTTP request to the specified URL, checks the response code, handles redirections, and returns a StatusResult object containing the status message and redirection URL (if any). This method handles various exceptions and provides appropriate error messages.\n  \n  Nested Class:\n  - StatusResult - A static inner class that holds the result of the HTTP status check.\n    Attributes:\n    - message: String - A human-readable message describing the HTTP status or error.\n    - redirectionUrl: String - The URL to which the original URL redirects (null if no redirection).",
    "Canonical_solution": "import android.content.Context;\nimport android.util.Log;\n\nimport com.trianguloy.urlchecker.utilities.methods.HttpUtils;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        String message = null;\n        String redirectionUrl = null;\n\n        HttpURLConnection conn = null;\n        try {\n            // Step 2: Get the access URL\n            Log.d(\"STATUS\", \"Checking: \" + url);\n            \n            // Step 3: Create an HttpURLConnection object\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            \n            // Step 4: Set request parameters\n            conn.setInstanceFollowRedirects(false);\n            conn.setConnectTimeout(HttpUtils.CONNECT_TIMEOUT);\n            \n            // Step 5: Processing Input and Output\n            var responseCode = conn.getResponseCode();\n            Log.d(\"RESPONSE_CODE\", url + \": \" + responseCode);\n\n            var codesArray = context.getResources().getStringArray(R.array.mStatus_codes);\n            for (var s : codesArray) {\n                if (s.startsWith(String.valueOf(responseCode))) {\n                    message = s;\n                    break;\n                }\n            }\n            if (message == null) {\n                message = context.getString(R.string.mStatus_unknownCode, responseCode);\n            }\n\n            var location = conn.getHeaderField(\"Location\");\n            if (location != null) {\n                redirectionUrl = new URL(new URL(url), location).toExternalForm();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_ioerror, e.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_error, e.getMessage());\n        } finally {\n            // Step 6: Disconnect\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n\n        return new StatusResult(message, redirectionUrl);\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpStatusChecker {\n    private Context context;\n    private String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"HEAD\");\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            String redirectUrl = null;\n\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP) {\n                redirectUrl = connection.getHeaderField(\"Location\");\n            }\n\n            String message = getHttpStatusMessage(responseCode);\n            return new StatusResult(message, redirectUrl);\n        } catch (IOException e) {\n            String errorMessage = \"Error checking URL: \" + e.getMessage();\n            return new StatusResult(errorMessage, null);\n        }\n    }\n\n    private String getHttpStatusMessage(int code) {\n        switch (code) {\n            case HttpURLConnection.HTTP_OK:\n                return \"OK\";\n            case HttpURLConnection.HTTP_CREATED:\n                return \"Created\";\n            case HttpURLConnection.HTTP_ACCEPTED:\n                return \"Accepted\";\n            case HttpURLConnection.HTTP_NOT_AUTHORITATIVE:\n                return \"Non-Authoritative Information\";\n            case HttpURLConnection.HTTP_NO_CONTENT:\n                return \"No Content\";\n            case HttpURLConnection.HTTP_RESET:\n                return \"Reset Content\";\n            case HttpURLConnection.HTTP_PARTIAL:\n                return \"Partial Content\";\n            case HttpURLConnection.HTTP_MULT_CHOICE:\n                return \"Multiple Choices\";\n            case HttpURLConnection.HTTP_BAD_REQUEST:\n                return \"Bad Request\";\n            case HttpURLConnection.HTTP_UNAUTHORIZED:\n                return \"Unauthorized\";\n            case HttpURLConnection.HTTP_PAYMENT_REQUIRED:\n                return \"Payment Required\";\n            case HttpURLConnection.HTTP_FORBIDDEN:\n                return \"Forbidden\";\n            case HttpURLConnection.HTTP_NOT_FOUND:\n                return \"Not Found\";\n            case HttpURLConnection.HTTP_BAD_METHOD:\n                return \"Bad Method\";\n            case HttpURLConnection.HTTP_USE_PROXY:\n                return \"Use Proxy\";\n            case HttpURLConnection.HTTP_UNSUPPORTED_TYPE:\n                return \"Unsupported Type\";\n            case HttpURLConnection.HTTP_CLIENT_TIMEOUT:\n                return \"Client Timeout\";\n            case HttpURLConnection.HTTP_GONE:\n                return \"Gone\";\n            case HttpURLConnection.HTTP_LENGTH_REQUIRED:\n                return \"Length Required\";\n            case HttpURLConnection.HTTP_PRECON_FAILED:\n                return \"Precondition Failed\";\n            case HttpURLConnection.HTTP_ENTITY_TOO_LARGE:\n                return \"Request Entity Too Large\";\n            case HttpURLConnection.HTTP_REQ_TOO_LONG:\n                return \"Request URI Too Long\";\n            case HttpURLConnection.HTTP_UNSUPPORTED_ENCODING:\n                return \"Unsupported Encoding\";\n            case HttpURLConnection.HTTP_BAD_RANGE:\n                return \"Bad Range\";\n            case HttpURLConnection.HTTP_NOT_IMPLEMENTED:\n                return \"Not Implemented\";\n            case HttpURLConnection.HTTP_BAD_GATEWAY:\n                return \"Bad Gateway\";\n            case HttpURLConnection.HTTP_SERVICE_UNAVAIL:\n                return \"Service Unavailable\";\n            case HttpURLConnection.HTTP_GATEWAY_TIMEOUT:\n                return \"Gateway Timeout\";\n            case HttpURLConnection.HTTP_VERSION:\n                return \"HTTP Version Not Supported\";\n            default:\n                return \"Unknown status code: \" + code;\n        }\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using HttpURLConnection, supporting both GET and POST methods asynchronously, with callback mechanisms for handling responses and errors. The class should also include functionality to retrieve network time from a server.\n\nClass Description: HttpURLConnectionUtils is a utility class that provides asynchronous HTTP request capabilities using Java's HttpURLConnection. It supports GET and POST methods, allows setting custom headers, and provides callback interfaces for handling responses and errors. Additionally, it includes functionality to fetch network time from a specified URL.\n\nAttributes:\n- TAG: String - Class tag for logging purposes\n- TIMEOUT_IN_MILLIONS: int - Default timeout for connections in milliseconds (5000ms)\n- BAIDU_URL: String - Default URL for network time requests (https://www.baidu.com)\n\nMethods:\n- doGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous GET request to the specified URL and invokes the callback with the response or error\n- doPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous POST request to the specified URL with given parameters and invokes the callback\n- getNetTime(TimeCallback callback) -> void - Retrieves network time from the default BAIDU_URL using the provided callback\n- getNetTime(String urlStr, TimeCallback callback) -> void - Retrieves network time from the specified URL using the provided callback\n- request(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic\n- reqNetTime(String urlStr, TimeCallback callback) -> void - Internal method that handles network time retrieval\n\nCallback Interfaces:\n- Callback: \n  - onResponse(String result, long response) -> void - Called when request succeeds\n  - onFail(Throwable error) -> void - Called when request fails\n- TimeCallback:\n  - onResponse(long millis) -> void - Called when network time retrieval succeeds\n  - onFail(Throwable error) -> void - Called when network time retrieval fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final String TAG = HttpURLConnectionUtils.class.getSimpleName();\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(final String urlStr, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(final String urlStr, final String params, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void getNetTime(final TimeCallback callback) {\n        getNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(final String urlStr, final TimeCallback callback) {\n        new Thread(() -> reqNetTime(urlStr, callback)).start();\n    }\n\n    private static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n            \n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1)) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n\n    private static void reqNetTime(final String urlStr, final TimeCallback callback) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            long date = connection.getDate();\n            if (date <= 0) {\n                date = -1L;\n            }\n            if (callback != null) {\n                callback.onResponse(date);\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpURLConnectionUtils {\n    private static final String TAG = \"HttpURLConnectionUtils\";\n    private static final int TIMEOUT_IN_MILLIS = 5000;\n    private static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    private static final ExecutorService executor = Executors.newCachedThreadPool();\n\n    public interface Callback {\n        void onResponse(String result, long responseTime);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    public void getNetTime(TimeCallback callback) {\n        reqNetTime(BAIDU_URL, callback);\n    }\n\n    public void getNetTime(String urlStr, TimeCallback callback) {\n        reqNetTime(urlStr, callback);\n    }\n\n    private void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        executor.execute(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(method);\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIS);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        connection.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (\"POST\".equalsIgnoreCase(method) && params != null) {\n                    connection.setDoOutput(true);\n                    try (OutputStream os = connection.getOutputStream()) {\n                        os.write(params.getBytes());\n                    }\n                }\n\n                long startTime = System.currentTimeMillis();\n                int responseCode = connection.getResponseCode();\n                long endTime = System.currentTimeMillis();\n\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    StringBuilder response = new StringBuilder();\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            response.append(line);\n                        }\n                    }\n                    callback.onResponse(response.toString(), endTime - startTime);\n                } else {\n                    callback.onFail(new IOException(\"HTTP error code: \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        });\n    }\n\n    private void reqNetTime(String urlStr, TimeCallback callback) {\n        executor.execute(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIS);\n\n                long startTime = System.currentTimeMillis();\n                int responseCode = connection.getResponseCode();\n                long endTime = System.currentTimeMillis();\n\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    callback.onResponse(endTime - startTime, null);\n                } else {\n                    callback.onFail(new IOException(\"HTTP error code: \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        });\n    }\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.InetAddress;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.logging.Logger;\n\npublic class SSRFChecker {\n    private static final Logger logger = Logger.getLogger(SSRFChecker.class.getName());\n    private String decimalIp;\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        try {\n            URL currentUrl = new URL(url);\n            int redirectCount = 0;\n            while (redirectCount < checkTimes) {\n                String host = url2host(currentUrl.toString());\n                if (host == null || host.isEmpty()) {\n                    return false;\n                }\n                String ip = host2ip(host);\n                if (ip.isEmpty()) {\n                    return false;\n                }\n                if (isInternalIp(ip)) {\n                    logger.warning(\"SSRF detected: Internal IP \" + ip + \" found in URL \" + url);\n                    return false;\n                }\n                // Simulate following redirects\n                // In a real scenario, you would get the redirect URL from the response and update currentUrl\n                redirectCount++;\n            }\n            return true;\n        } catch (Exception e) {\n            logger.severe(\"Error checking SSRF for URL: \" + url + \" - \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host == null || host.isEmpty()) {\n            return false;\n        }\n        String ip = host2ip(host);\n        return !ip.isEmpty() && isInternalIp(ip);\n    }\n\n    public boolean isInternalIp(String strIP) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(strIP);\n            return isInternalIp(inetAddress);\n        } catch (UnknownHostException e) {\n            logger.warning(\"Invalid IP address: \" + strIP);\n            return false;\n        }\n    }\n\n    private boolean isInternalIp(InetAddress inetAddress) {\n        if (inetAddress.isLoopbackAddress()) {\n            return true;\n        }\n        if (inetAddress.isSiteLocalAddress()) {\n            return true;\n        }\n        if (inetAddress.getHostAddress().startsWith(\"10.\")) {\n            return true;\n        }\n        if (inetAddress.getHostAddress().startsWith(\"172.\") && inetAddress.getHostAddress().substring(4, 6).matches(\"1[6-9]|2[0-9]\")) {\n            return true;\n        }\n        if (inetAddress.getHostAddress().startsWith(\"192.168.\")) {\n            return true;\n        }\n        return false;\n    }\n\n    public String host2ip(String host) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(host);\n            decimalIp = convertToDecimal(inetAddress.getHostAddress());\n            return inetAddress.getHostAddress();\n        } catch (UnknownHostException e) {\n            logger.warning(\"Failed to resolve host: \" + host);\n            return \"\";\n        }\n    }\n\n    public String url2host(String url) {\n        try {\n            URL u = new URL(url);\n            return u.getHost();\n        } catch (Exception e) {\n            logger.warning(\"Invalid URL format: \" + url);\n            return \"\";\n        }\n    }\n\n    private boolean isOctalIP(String host) {\n        if (host == null || host.isEmpty()) {\n            return false;\n        }\n        for (char c : host.toCharArray()) {\n            if (!Character.isDigit(c) || c > '7') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private String convertToDecimal(String ipAddress) {\n        String[] parts = ipAddress.split(\"\\\\.\");\n        StringBuilder decimal = new StringBuilder();\n        for (String part : parts) {\n            int value = Integer.parseInt(part);\n            decimal.append(value);\n        }\n        return decimal.toString();\n    }\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection;\n            if (mProxyOn) {\n                Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(mProxyHost, (int) mProxyPort));\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(10000);\n            connection.setReadTimeout(10000);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                String response = readStringFromStream(inputStream);\n                callback.onSuccess(response);\n            } else {\n                callback.onFailed();\n            }\n        } catch (Exception e) {\n            callback.onFailed();\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.List;\n\npublic class HttpTinyClient {\n    public static class HttpResult {\n        public int code;\n        public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) {\n        try {\n            StringBuilder params = new StringBuilder();\n            for (int i = 0; i < paramValues.size(); i += 2) {\n                if (i > 0) params.append(\"&\");\n                String key = paramValues.get(i);\n                String value = paramValues.get(i + 1);\n                params.append(URLEncoder.encode(key, encoding)).append(\"=\").append(URLEncoder.encode(value, encoding));\n            }\n            String fullUrl = url + (params.length() > 0 ? \"?\" + params.toString() : \"\");\n            URL obj = new URL(fullUrl);\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            conn.setRequestMethod(\"GET\");\n            setHeaders(conn, headers, encoding);\n            conn.setReadTimeout((int) readTimeoutMs);\n            int responseCode = conn.getResponseCode();\n            String responseContent = readResponse(conn);\n            return new HttpResult(responseCode, responseContent);\n        } catch (Exception e) {\n            return new HttpResult(-1, e.getMessage());\n        }\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) {\n        try {\n            String encodedParams = encodingParams(paramValues, encoding);\n            URL obj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            conn.setRequestMethod(\"POST\");\n            setHeaders(conn, headers, encoding);\n            conn.setDoOutput(true);\n            conn.setReadTimeout((int) readTimeoutMs);\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(encodedParams.getBytes(encoding));\n            }\n            int responseCode = conn.getResponseCode();\n            String responseContent = readResponse(conn);\n            return new HttpResult(responseCode, responseContent);\n        } catch (Exception e) {\n            return new HttpResult(-1, e.getMessage());\n        }\n    }\n\n    public static String encodingParams(List<String> paramValues, String encoding) {\n        StringBuilder params = new StringBuilder();\n        for (int i = 0; i < paramValues.size(); i += 2) {\n            if (i > 0) params.append(\"&\");\n            String key = paramValues.get(i);\n            String value = paramValues.get(i + 1);\n            params.append(URLEncoder.encode(key, encoding)).append(\"=\").append(URLEncoder.encode(value, encoding));\n        }\n        return params.toString();\n    }\n\n    public static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        conn.setRequestProperty(\"User-Agent\", \"HttpTinyClient/1.0\");\n        conn.setRequestProperty(\"Accept-Charset\", encoding);\n        for (String header : headers) {\n            String[] parts = header.split(\": \", 2);\n            if (parts.length == 2) {\n                conn.setRequestProperty(parts[0], parts[1]);\n            }\n        }\n    }\n\n    private static String readResponse(HttpURLConnection conn) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\npublic class HttpPostUploadUtil {\n    private static final Logger logger = Logger.getLogger(HttpPostUploadUtil.class.getName());\n    private static final String BOUNDARY = \"===\" + System.currentTimeMillis() + \"===\";\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, File> fileMap) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(connectTimeout);\n            connection.setReadTimeout(readTimeout);\n            connection.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            try (OutputStream output = connection.getOutputStream();\n                 PrintWriter writer = new PrintWriter(new OutputStreamWriter(output))) {\n\n                if (textMap != null && !textMap.isEmpty()) {\n                    for (Map.Entry<String, String> entry : textMap.entrySet()) {\n                        writeTextPart(writer, entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (fileMap != null && !fileMap.isEmpty()) {\n                    for (Map.Entry<String, File> entry : fileMap.entrySet()) {\n                        writeFilePart(writer, entry.getKey(), entry.getValue());\n                    }\n                }\n\n                writer.write(\"--\" + BOUNDARY + \"--\\r\\n\");\n                writer.flush();\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                return readResponse(connection.getInputStream());\n            } else {\n                logger.severe(\"Server returned HTTP \" + responseCode + \" error: \" + readResponse(connection.getErrorStream()));\n                return null;\n            }\n        } catch (IOException e) {\n            logger.severe(\"IOException during HTTP POST request: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private static void writeTextPart(PrintWriter writer, String fieldName, String fieldValue) {\n        writer.append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n        writer.append(\"Content-Disposition: form-data; name=\\\"\").append(fieldName).append(\"\\\"\\r\\n\");\n        writer.append(\"Content-Type: text/plain; charset=UTF-8\\r\\n\\r\\n\");\n        writer.append(fieldValue).append(\"\\r\\n\");\n        writer.flush();\n    }\n\n    private static void writeFilePart(PrintWriter writer, String fieldName, File file) {\n        try (FileInputStream fileInputStream = new FileInputStream(file)) {\n            writer.append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n            writer.append(\"Content-Disposition: form-data; name=\\\"\").append(fieldName).append(\"\\\"; filename=\\\"\").append(file.getName()).append(\"\\\"\\r\\n\");\n            writer.append(\"Content-Type: application/octet-stream\\r\\n\\r\\n\");\n            writer.flush();\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = fileInputStream.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n            }\n            writer.append(\"\\r\\n\");\n            writer.flush();\n        } catch (IOException e) {\n            logger.severe(\"Error reading file for upload: \" + e.getMessage());\n        }\n    }\n\n    private static String readResponse(InputStream inputStream) throws IOException {\n        StringBuilder response = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        return response.toString();\n    }\n\n    public static void closeStream(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                logger.warning(\"Error closing stream: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.google.gson.Gson;\n\npublic class ApiHandler {\n    private String baseUrl;\n    private Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this(baseUrl);\n        this.additionalHeaders.put(\"Authorization\", \"Bearer \" + apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + endpoint + \"?\" + parseQueries(query), tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + endpoint + \"?\" + parseQueries(query), body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(connection, headers);\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            BufferedReader in;\n            if (responseCode >= 200 && responseCode < 300) {\n                in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            } else {\n                in = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n            }\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(connection, headers);\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = body.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);\n            }\n            int responseCode = connection.getResponseCode();\n            BufferedReader in;\n            if (responseCode >= 200 && responseCode < 300) {\n                in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            } else {\n                in = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n            }\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            connection.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n    }\n\n    public static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : query.entrySet()) {\n            if (sb.length() > 0) {\n                sb.append(\"&\");\n            }\n            sb.append(URLEncoder.encode(entry.getKey(), StandardCharsets.UTF_8));\n            sb.append(\"=\");\n            sb.append(URLEncoder.encode(entry.getValue().toString(), StandardCharsets.UTF_8));\n        }\n        return sb.toString();\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        String response = getRaw(headers, url);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + \"?\" + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        String jsonBody = new Gson().toJson(body);\n        String response = postRaw(headers, url, jsonBody);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(headers, url + \"?\" + parseQueries(query), body, tClass);\n    }\n\n    public static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, StandardCharsets.UTF_8.name());\n        } catch (Exception e) {\n            return input;\n        }\n    }\n}"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RemoteServiceImpl {\n    private String resporityServerUrl;\n    private Logger log = LoggerFactory.getLogger(RemoteServiceImpl.class);\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        try {\n            String response = sendRequest(packageId, timestamp);\n            return parseResponse(response);\n        } catch (Exception e) {\n            log.error(\"Failed to retrieve knowledge package: {}\", e.getMessage());\n            return null;\n        }\n    }\n\n    private String sendRequest(String packageId, String timestamp) throws Exception {\n        if (resporityServerUrl == null || resporityServerUrl.isEmpty()) {\n            throw new IllegalStateException(\"Repository server URL is not set.\");\n        }\n\n        String requestUrl = resporityServerUrl + \"/knowledge?packageId=\" + packageId + \"&timestamp=\" + timestamp;\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            log.warn(\"Server returned HTTP {} for URL: {}\", responseCode, requestUrl);\n            BufferedReader errorReader = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n            StringBuilder errorResponse = new StringBuilder();\n            String line;\n            while ((line = errorReader.readLine()) != null) {\n                errorResponse.append(line);\n            }\n            throw new RuntimeException(\"Server returned HTTP \" + responseCode + \": \" + errorResponse.toString());\n        }\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        return response.toString();\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if (resporityServerUrl == null || resporityServerUrl.isEmpty()) {\n            this.resporityServerUrl = \"\";\n        } else if (!resporityServerUrl.endsWith(\"/repository\")) {\n            this.resporityServerUrl = resporityServerUrl + \"/repository\";\n        } else {\n            this.resporityServerUrl = resporityServerUrl;\n        }\n    }\n\n    private KnowledgePackage parseResponse(String response) {\n        // Placeholder for actual parsing logic\n        return new KnowledgePackage(response);\n    }\n}\n\nclass KnowledgePackage {\n    private String content;\n\n    public KnowledgePackage(String content) {\n        this.content = content;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class FetchUrlMimeType {\n    private DownloadManager.Request mRequest;\n    private DownloadManager mDownloadManager;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        mDownloadManager = downloadManager;\n        mRequest = request;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            try {\n                URL url = new URL(mUri);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"HEAD\");\n                if (mCookies != null) {\n                    connection.setRequestProperty(\"Cookie\", mCookies);\n                }\n                if (mUserAgent != null) {\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    String mimeType = connection.getContentType();\n                    String contentDisposition = connection.getHeaderField(\"Content-Disposition\");\n\n                    if (mimeType != null) {\n                        mRequest.setMimeType(mimeType);\n                    }\n\n                    if (contentDisposition != null) {\n                        String fileName = extractFileNameFromContentDisposition(contentDisposition);\n                        if (fileName != null) {\n                            mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);\n                        } else {\n                            emitter.onSuccess(Result.FAILURE_LOCATION);\n                            return;\n                        }\n                    } else {\n                        emitter.onSuccess(Result.FAILURE_LOCATION);\n                        return;\n                    }\n\n                    long enqueueId = mDownloadManager.enqueue(mRequest);\n                    if (enqueueId != -1) {\n                        emitter.onSuccess(Result.SUCCESS);\n                    } else {\n                        emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                    }\n                } else {\n                    emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                }\n            } catch (Exception e) {\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            }\n        });\n    }\n\n    private String extractFileNameFromContentDisposition(String contentDisposition) {\n        if (contentDisposition == null) {\n            return null;\n        }\n        String[] parts = contentDisposition.split(\";\");\n        for (String part : parts) {\n            String trimmed = part.trim();\n            if (trimmed.startsWith(\"filename=\")) {\n                String fileName = trimmed.substring(\"filename=\".length());\n                if (fileName.length() > 0) {\n                    if (fileName.charAt(0) == '\"') {\n                        fileName = fileName.substring(1);\n                        if (fileName.length() > 0 && fileName.charAt(fileName.length() - 1) == '\"') {\n                            fileName = fileName.substring(0, fileName.length() - 1);\n                        }\n                    }\n                    return fileName;\n                }\n            }\n        }\n        return null;\n    }\n\n    public enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}"
  }
]